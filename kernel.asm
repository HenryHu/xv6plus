
kernel:     file format elf32-i386-freebsd

Disassembly of section .text:

00100000 <binit>:
struct buf bufhead;

void
binit(void)
{
  100000:	55                   	push   %ebp
  100001:	89 e5                	mov    %esp,%ebp
  100003:	83 ec 18             	sub    $0x18,%esp
  struct buf *b;

  initlock(&buf_table_lock, "buf_table");
  100006:	c7 44 24 04 ac a1 11 	movl   $0x11a1ac,0x4(%esp)
  10000d:	00 
  10000e:	c7 04 24 e0 b0 13 00 	movl   $0x13b0e0,(%esp)
  100015:	e8 f6 5a 00 00       	call   105b10 <initlock>

  // Create linked list of buffers
  bufhead.prev = &bufhead;
  10001a:	c7 05 cc 99 13 00 c0 	movl   $0x1399c0,0x1399cc
  100021:	99 13 00 
  bufhead.next = &bufhead;
  100024:	c7 05 d0 99 13 00 c0 	movl   $0x1399c0,0x1399d0
  10002b:	99 13 00 
  for(b = buf; b < buf+NBUF; b++){
  10002e:	c7 45 fc e0 9b 13 00 	movl   $0x139be0,0xfffffffc(%ebp)
  100035:	eb 31                	jmp    100068 <binit+0x68>
    b->next = bufhead.next;
  100037:	8b 15 d0 99 13 00    	mov    0x1399d0,%edx
  10003d:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  100040:	89 50 10             	mov    %edx,0x10(%eax)
    b->prev = &bufhead;
  100043:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  100046:	c7 40 0c c0 99 13 00 	movl   $0x1399c0,0xc(%eax)
    bufhead.next->prev = b;
  10004d:	8b 15 d0 99 13 00    	mov    0x1399d0,%edx
  100053:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  100056:	89 42 0c             	mov    %eax,0xc(%edx)
    bufhead.next = b;
  100059:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10005c:	a3 d0 99 13 00       	mov    %eax,0x1399d0
  100061:	81 45 fc 18 02 00 00 	addl   $0x218,0xfffffffc(%ebp)
  100068:	b8 d0 b0 13 00       	mov    $0x13b0d0,%eax
  10006d:	39 45 fc             	cmp    %eax,0xfffffffc(%ebp)
  100070:	72 c5                	jb     100037 <binit+0x37>
  }
}
  100072:	c9                   	leave  
  100073:	c3                   	ret    
  100074:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  10007a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

00100080 <bget>:

// Look through buffer cache for sector on device dev.
// If not found, allocate fresh block.
// In either case, return locked buffer.
static struct buf*
bget(uint dev, uint sector)
{
  100080:	55                   	push   %ebp
  100081:	89 e5                	mov    %esp,%ebp
  100083:	83 ec 28             	sub    $0x28,%esp
  struct buf *b;

  acquire(&buf_table_lock);
  100086:	c7 04 24 e0 b0 13 00 	movl   $0x13b0e0,(%esp)
  10008d:	e8 ae 5a 00 00       	call   105b40 <acquire>

 loop:
  // Try for cached block.
  for(b = bufhead.next; b != &bufhead; b = b->next){
  100092:	a1 d0 99 13 00       	mov    0x1399d0,%eax
  100097:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  10009a:	eb 70                	jmp    10010c <bget+0x8c>
    if((b->flags & (B_BUSY|B_VALID)) &&
  10009c:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10009f:	8b 00                	mov    (%eax),%eax
  1000a1:	83 e0 03             	and    $0x3,%eax
  1000a4:	85 c0                	test   %eax,%eax
  1000a6:	74 5b                	je     100103 <bget+0x83>
  1000a8:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1000ab:	8b 40 04             	mov    0x4(%eax),%eax
  1000ae:	3b 45 08             	cmp    0x8(%ebp),%eax
  1000b1:	75 50                	jne    100103 <bget+0x83>
  1000b3:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1000b6:	8b 40 08             	mov    0x8(%eax),%eax
  1000b9:	3b 45 0c             	cmp    0xc(%ebp),%eax
  1000bc:	75 45                	jne    100103 <bget+0x83>
       b->dev == dev && b->sector == sector){
      if(b->flags & B_BUSY){
  1000be:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1000c1:	8b 00                	mov    (%eax),%eax
  1000c3:	83 e0 01             	and    $0x1,%eax
  1000c6:	84 c0                	test   %al,%al
  1000c8:	74 16                	je     1000e0 <bget+0x60>
        sleep(buf, &buf_table_lock);
  1000ca:	c7 44 24 04 e0 b0 13 	movl   $0x13b0e0,0x4(%esp)
  1000d1:	00 
  1000d2:	c7 04 24 e0 9b 13 00 	movl   $0x139be0,(%esp)
  1000d9:	e8 b2 53 00 00       	call   105490 <sleep>
        goto loop;
  1000de:	eb b2                	jmp    100092 <bget+0x12>
      }
      b->flags |= B_BUSY;
  1000e0:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1000e3:	8b 00                	mov    (%eax),%eax
  1000e5:	89 c2                	mov    %eax,%edx
  1000e7:	83 ca 01             	or     $0x1,%edx
  1000ea:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1000ed:	89 10                	mov    %edx,(%eax)
      release(&buf_table_lock);
  1000ef:	c7 04 24 e0 b0 13 00 	movl   $0x13b0e0,(%esp)
  1000f6:	e8 45 5c 00 00       	call   105d40 <release>
      return b;
  1000fb:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1000fe:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  100101:	eb 75                	jmp    100178 <bget+0xf8>
  100103:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  100106:	8b 40 10             	mov    0x10(%eax),%eax
  100109:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  10010c:	81 7d fc c0 99 13 00 	cmpl   $0x1399c0,0xfffffffc(%ebp)
  100113:	75 87                	jne    10009c <bget+0x1c>
    }
  }

  // Allocate fresh block.
  for(b = bufhead.prev; b != &bufhead; b = b->prev){
  100115:	a1 cc 99 13 00       	mov    0x1399cc,%eax
  10011a:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  10011d:	eb 44                	jmp    100163 <bget+0xe3>
    if((b->flags & B_BUSY) == 0){
  10011f:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  100122:	8b 00                	mov    (%eax),%eax
  100124:	83 e0 01             	and    $0x1,%eax
  100127:	85 c0                	test   %eax,%eax
  100129:	75 2f                	jne    10015a <bget+0xda>
      b->flags = B_BUSY;
  10012b:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10012e:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
      b->dev = dev;
  100134:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  100137:	8b 45 08             	mov    0x8(%ebp),%eax
  10013a:	89 42 04             	mov    %eax,0x4(%edx)
      b->sector = sector;
  10013d:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  100140:	8b 45 0c             	mov    0xc(%ebp),%eax
  100143:	89 42 08             	mov    %eax,0x8(%edx)
      release(&buf_table_lock);
  100146:	c7 04 24 e0 b0 13 00 	movl   $0x13b0e0,(%esp)
  10014d:	e8 ee 5b 00 00       	call   105d40 <release>
      return b;
  100152:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  100155:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  100158:	eb 1e                	jmp    100178 <bget+0xf8>
  10015a:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10015d:	8b 40 0c             	mov    0xc(%eax),%eax
  100160:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  100163:	81 7d fc c0 99 13 00 	cmpl   $0x1399c0,0xfffffffc(%ebp)
  10016a:	75 b3                	jne    10011f <bget+0x9f>
    }
  }
  panic("bget: no buffers");
  10016c:	c7 04 24 b6 a1 11 00 	movl   $0x11a1b6,(%esp)
  100173:	e8 98 0e 00 00       	call   101010 <panic>
  100178:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  10017b:	c9                   	leave  
  10017c:	c3                   	ret    
  10017d:	8d 76 00             	lea    0x0(%esi),%esi

00100180 <bread>:

// Return a B_BUSY buf with the contents of the indicated disk sector.
struct buf*
bread(uint dev, uint sector)
{
  100180:	55                   	push   %ebp
  100181:	89 e5                	mov    %esp,%ebp
  100183:	83 ec 18             	sub    $0x18,%esp
  struct buf *b;

  b = bget(dev, sector);
  100186:	8b 45 0c             	mov    0xc(%ebp),%eax
  100189:	89 44 24 04          	mov    %eax,0x4(%esp)
  10018d:	8b 45 08             	mov    0x8(%ebp),%eax
  100190:	89 04 24             	mov    %eax,(%esp)
  100193:	e8 e8 fe ff ff       	call   100080 <bget>
  100198:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  if(!(b->flags & B_VALID))
  10019b:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10019e:	8b 00                	mov    (%eax),%eax
  1001a0:	83 e0 02             	and    $0x2,%eax
  1001a3:	85 c0                	test   %eax,%eax
  1001a5:	75 0b                	jne    1001b2 <bread+0x32>
    ide_rw(b);
  1001a7:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1001aa:	89 04 24             	mov    %eax,(%esp)
  1001ad:	e8 de 2e 00 00       	call   103090 <ide_rw>
  return b;
  1001b2:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
}
  1001b5:	c9                   	leave  
  1001b6:	c3                   	ret    
  1001b7:	89 f6                	mov    %esi,%esi
  1001b9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

001001c0 <bwrite>:

// Write buf's contents to disk.  Must be locked.
void
bwrite(struct buf *b)
{
  1001c0:	55                   	push   %ebp
  1001c1:	89 e5                	mov    %esp,%ebp
  1001c3:	83 ec 08             	sub    $0x8,%esp
  if((b->flags & B_BUSY) == 0)
  1001c6:	8b 45 08             	mov    0x8(%ebp),%eax
  1001c9:	8b 00                	mov    (%eax),%eax
  1001cb:	83 e0 01             	and    $0x1,%eax
  1001ce:	85 c0                	test   %eax,%eax
  1001d0:	75 0c                	jne    1001de <bwrite+0x1e>
    panic("bwrite");
  1001d2:	c7 04 24 c7 a1 11 00 	movl   $0x11a1c7,(%esp)
  1001d9:	e8 32 0e 00 00       	call   101010 <panic>
  b->flags |= B_DIRTY;
  1001de:	8b 45 08             	mov    0x8(%ebp),%eax
  1001e1:	8b 00                	mov    (%eax),%eax
  1001e3:	89 c2                	mov    %eax,%edx
  1001e5:	83 ca 04             	or     $0x4,%edx
  1001e8:	8b 45 08             	mov    0x8(%ebp),%eax
  1001eb:	89 10                	mov    %edx,(%eax)
  ide_rw(b);
  1001ed:	8b 45 08             	mov    0x8(%ebp),%eax
  1001f0:	89 04 24             	mov    %eax,(%esp)
  1001f3:	e8 98 2e 00 00       	call   103090 <ide_rw>
}
  1001f8:	c9                   	leave  
  1001f9:	c3                   	ret    
  1001fa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

00100200 <brelse>:

// Release the buffer buf.
void
brelse(struct buf *b)
{
  100200:	55                   	push   %ebp
  100201:	89 e5                	mov    %esp,%ebp
  100203:	83 ec 08             	sub    $0x8,%esp
  if((b->flags & B_BUSY) == 0)
  100206:	8b 45 08             	mov    0x8(%ebp),%eax
  100209:	8b 00                	mov    (%eax),%eax
  10020b:	83 e0 01             	and    $0x1,%eax
  10020e:	85 c0                	test   %eax,%eax
  100210:	75 0c                	jne    10021e <brelse+0x1e>
    panic("brelse");
  100212:	c7 04 24 ce a1 11 00 	movl   $0x11a1ce,(%esp)
  100219:	e8 f2 0d 00 00       	call   101010 <panic>

  acquire(&buf_table_lock);
  10021e:	c7 04 24 e0 b0 13 00 	movl   $0x13b0e0,(%esp)
  100225:	e8 16 59 00 00       	call   105b40 <acquire>

  b->next->prev = b->prev;
  10022a:	8b 45 08             	mov    0x8(%ebp),%eax
  10022d:	8b 50 10             	mov    0x10(%eax),%edx
  100230:	8b 45 08             	mov    0x8(%ebp),%eax
  100233:	8b 40 0c             	mov    0xc(%eax),%eax
  100236:	89 42 0c             	mov    %eax,0xc(%edx)
  b->prev->next = b->next;
  100239:	8b 45 08             	mov    0x8(%ebp),%eax
  10023c:	8b 50 0c             	mov    0xc(%eax),%edx
  10023f:	8b 45 08             	mov    0x8(%ebp),%eax
  100242:	8b 40 10             	mov    0x10(%eax),%eax
  100245:	89 42 10             	mov    %eax,0x10(%edx)
  b->next = bufhead.next;
  100248:	8b 15 d0 99 13 00    	mov    0x1399d0,%edx
  10024e:	8b 45 08             	mov    0x8(%ebp),%eax
  100251:	89 50 10             	mov    %edx,0x10(%eax)
  b->prev = &bufhead;
  100254:	8b 45 08             	mov    0x8(%ebp),%eax
  100257:	c7 40 0c c0 99 13 00 	movl   $0x1399c0,0xc(%eax)
  bufhead.next->prev = b;
  10025e:	8b 15 d0 99 13 00    	mov    0x1399d0,%edx
  100264:	8b 45 08             	mov    0x8(%ebp),%eax
  100267:	89 42 0c             	mov    %eax,0xc(%edx)
  bufhead.next = b;
  10026a:	8b 45 08             	mov    0x8(%ebp),%eax
  10026d:	a3 d0 99 13 00       	mov    %eax,0x1399d0

  b->flags &= ~B_BUSY;
  100272:	8b 45 08             	mov    0x8(%ebp),%eax
  100275:	8b 00                	mov    (%eax),%eax
  100277:	89 c2                	mov    %eax,%edx
  100279:	83 e2 fe             	and    $0xfffffffe,%edx
  10027c:	8b 45 08             	mov    0x8(%ebp),%eax
  10027f:	89 10                	mov    %edx,(%eax)
  wakeup(buf);
  100281:	c7 04 24 e0 9b 13 00 	movl   $0x139be0,(%esp)
  100288:	e8 93 53 00 00       	call   105620 <wakeup>

  release(&buf_table_lock);
  10028d:	c7 04 24 e0 b0 13 00 	movl   $0x13b0e0,(%esp)
  100294:	e8 a7 5a 00 00       	call   105d40 <release>
}
  100299:	c9                   	leave  
  10029a:	c3                   	ret    
  10029b:	90                   	nop    
  10029c:	90                   	nop    
  10029d:	90                   	nop    
  10029e:	90                   	nop    
  10029f:	90                   	nop    

001002a0 <lpt_putc>:
// .bochsrc to copy to the stdout:
//   parport1: enabled=1, file="/dev/stdout"
static void
lpt_putc(int c)
{
  1002a0:	55                   	push   %ebp
  1002a1:	89 e5                	mov    %esp,%ebp
  1002a3:	83 ec 18             	sub    $0x18,%esp
  int i;

  for(i = 0; !(inb(LPTPORT+1) & 0x80) && i < 12800; i++)
  1002a6:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
  1002ad:	eb 04                	jmp    1002b3 <lpt_putc+0x13>
  1002af:	83 45 fc 01          	addl   $0x1,0xfffffffc(%ebp)
  1002b3:	c7 04 24 79 03 00 00 	movl   $0x379,(%esp)
  1002ba:	e8 61 00 00 00       	call   100320 <inb>
  1002bf:	84 c0                	test   %al,%al
  1002c1:	78 09                	js     1002cc <lpt_putc+0x2c>
  1002c3:	81 7d fc ff 31 00 00 	cmpl   $0x31ff,0xfffffffc(%ebp)
  1002ca:	7e e3                	jle    1002af <lpt_putc+0xf>
    ;
  if(c == BACKSPACE)
  1002cc:	81 7d 08 00 01 00 00 	cmpl   $0x100,0x8(%ebp)
  1002d3:	75 07                	jne    1002dc <lpt_putc+0x3c>
    c = '\b';
  1002d5:	c7 45 08 08 00 00 00 	movl   $0x8,0x8(%ebp)
  outb(LPTPORT+0, c);
  1002dc:	8b 45 08             	mov    0x8(%ebp),%eax
  1002df:	0f b6 c0             	movzbl %al,%eax
  1002e2:	89 44 24 04          	mov    %eax,0x4(%esp)
  1002e6:	c7 04 24 78 03 00 00 	movl   $0x378,(%esp)
  1002ed:	e8 4e 00 00 00       	call   100340 <outb>
  outb(LPTPORT+2, 0x08|0x04|0x01);
  1002f2:	c7 44 24 04 0d 00 00 	movl   $0xd,0x4(%esp)
  1002f9:	00 
  1002fa:	c7 04 24 7a 03 00 00 	movl   $0x37a,(%esp)
  100301:	e8 3a 00 00 00       	call   100340 <outb>
  outb(LPTPORT+2, 0x08);
  100306:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
  10030d:	00 
  10030e:	c7 04 24 7a 03 00 00 	movl   $0x37a,(%esp)
  100315:	e8 26 00 00 00       	call   100340 <outb>
}
  10031a:	c9                   	leave  
  10031b:	c3                   	ret    
  10031c:	8d 74 26 00          	lea    0x0(%esi),%esi

00100320 <inb>:
// Routines to let C code use special x86 instructions.

static inline uchar
inb(ushort port)
{
  100320:	55                   	push   %ebp
  100321:	89 e5                	mov    %esp,%ebp
  100323:	83 ec 14             	sub    $0x14,%esp
  100326:	8b 45 08             	mov    0x8(%ebp),%eax
  100329:	66 89 45 ec          	mov    %ax,0xffffffec(%ebp)
  uchar data;

  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
  10032d:	0f b7 55 ec          	movzwl 0xffffffec(%ebp),%edx
  100331:	ec                   	in     (%dx),%al
  100332:	88 45 ff             	mov    %al,0xffffffff(%ebp)
  return data;
  100335:	0f b6 45 ff          	movzbl 0xffffffff(%ebp),%eax
}
  100339:	c9                   	leave  
  10033a:	c3                   	ret    
  10033b:	90                   	nop    
  10033c:	8d 74 26 00          	lea    0x0(%esi),%esi

00100340 <outb>:

static inline uint
inl(ushort port)
{
    uint data;

    asm volatile("in %1,%0" : "=a" (data) : "d" (port));
    return data;
}

static inline ushort
inw(ushort port)
{
    ushort data;

    asm volatile("in %1,%0" : "=a" (data) : "d" (port));
    return data;
}

static inline void
insl(int port, void *addr, int cnt)
{
  asm volatile("cld\n\trepne\n\tinsl"     :
                   "=D" (addr), "=c" (cnt)    :
                   "d" (port), "0" (addr), "1" (cnt)  :
                   "memory", "cc");
}

static inline void
outb(ushort port, uchar data)
{
  100340:	55                   	push   %ebp
  100341:	89 e5                	mov    %esp,%ebp
  100343:	83 ec 08             	sub    $0x8,%esp
  100346:	8b 45 08             	mov    0x8(%ebp),%eax
  100349:	8b 55 0c             	mov    0xc(%ebp),%edx
  10034c:	66 89 45 fc          	mov    %ax,0xfffffffc(%ebp)
  100350:	88 55 f8             	mov    %dl,0xfffffff8(%ebp)
  asm volatile("out %0,%1" : : "a" (data), "d" (port));
  100353:	0f b6 45 f8          	movzbl 0xfffffff8(%ebp),%eax
  100357:	0f b7 55 fc          	movzwl 0xfffffffc(%ebp),%edx
  10035b:	ee                   	out    %al,(%dx)
}
  10035c:	c9                   	leave  
  10035d:	c3                   	ret    
  10035e:	89 f6                	mov    %esi,%esi

00100360 <cga_putc>:

static void
cga_putc(int c)
{
  100360:	55                   	push   %ebp
  100361:	89 e5                	mov    %esp,%ebp
  100363:	53                   	push   %ebx
  100364:	83 ec 24             	sub    $0x24,%esp
  int pos;
  
  // Cursor position: col + 80*row.
  outb(CRTPORT, 14);
  100367:	c7 44 24 04 0e 00 00 	movl   $0xe,0x4(%esp)
  10036e:	00 
  10036f:	c7 04 24 d4 03 00 00 	movl   $0x3d4,(%esp)
  100376:	e8 c5 ff ff ff       	call   100340 <outb>
  pos = inb(CRTPORT+1) << 8;
  10037b:	c7 04 24 d5 03 00 00 	movl   $0x3d5,(%esp)
  100382:	e8 99 ff ff ff       	call   100320 <inb>
  100387:	0f b6 c0             	movzbl %al,%eax
  10038a:	c1 e0 08             	shl    $0x8,%eax
  10038d:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  outb(CRTPORT, 15);
  100390:	c7 44 24 04 0f 00 00 	movl   $0xf,0x4(%esp)
  100397:	00 
  100398:	c7 04 24 d4 03 00 00 	movl   $0x3d4,(%esp)
  10039f:	e8 9c ff ff ff       	call   100340 <outb>
  pos |= inb(CRTPORT+1);
  1003a4:	c7 04 24 d5 03 00 00 	movl   $0x3d5,(%esp)
  1003ab:	e8 70 ff ff ff       	call   100320 <inb>
  1003b0:	0f b6 c0             	movzbl %al,%eax
  1003b3:	09 45 f8             	or     %eax,0xfffffff8(%ebp)

  if(c == '\n')
  1003b6:	83 7d 08 0a          	cmpl   $0xa,0x8(%ebp)
  1003ba:	75 3e                	jne    1003fa <cga_putc+0x9a>
    pos += 80 - pos%80;
  1003bc:	8b 4d f8             	mov    0xfffffff8(%ebp),%ecx
  1003bf:	c7 45 e4 67 66 66 66 	movl   $0x66666667,0xffffffe4(%ebp)
  1003c6:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
  1003c9:	f7 e9                	imul   %ecx
  1003cb:	c1 fa 05             	sar    $0x5,%edx
  1003ce:	89 c8                	mov    %ecx,%eax
  1003d0:	c1 f8 1f             	sar    $0x1f,%eax
  1003d3:	89 d3                	mov    %edx,%ebx
  1003d5:	29 c3                	sub    %eax,%ebx
  1003d7:	89 5d e8             	mov    %ebx,0xffffffe8(%ebp)
  1003da:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  1003dd:	c1 e0 02             	shl    $0x2,%eax
  1003e0:	03 45 e8             	add    0xffffffe8(%ebp),%eax
  1003e3:	c1 e0 04             	shl    $0x4,%eax
  1003e6:	89 ca                	mov    %ecx,%edx
  1003e8:	29 c2                	sub    %eax,%edx
  1003ea:	89 55 e8             	mov    %edx,0xffffffe8(%ebp)
  1003ed:	b8 50 00 00 00       	mov    $0x50,%eax
  1003f2:	2b 45 e8             	sub    0xffffffe8(%ebp),%eax
  1003f5:	01 45 f8             	add    %eax,0xfffffff8(%ebp)
  1003f8:	eb 48                	jmp    100442 <cga_putc+0xe2>
  else if(c == BACKSPACE){
  1003fa:	81 7d 08 00 01 00 00 	cmpl   $0x100,0x8(%ebp)
  100401:	75 20                	jne    100423 <cga_putc+0xc3>
    if(pos > 0)
  100403:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  100407:	7e 39                	jle    100442 <cga_putc+0xe2>
      crt[--pos] = ' ' | 0x0700;
  100409:	83 6d f8 01          	subl   $0x1,0xfffffff8(%ebp)
  10040d:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  100410:	01 c0                	add    %eax,%eax
  100412:	89 c2                	mov    %eax,%edx
  100414:	a1 a0 c0 11 00       	mov    0x11c0a0,%eax
  100419:	8d 04 02             	lea    (%edx,%eax,1),%eax
  10041c:	66 c7 00 20 07       	movw   $0x720,(%eax)
  100421:	eb 1f                	jmp    100442 <cga_putc+0xe2>
  } else
    crt[pos++] = (c&0xff) | 0x0700;  // black on white
  100423:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  100426:	01 c0                	add    %eax,%eax
  100428:	89 c2                	mov    %eax,%edx
  10042a:	a1 a0 c0 11 00       	mov    0x11c0a0,%eax
  10042f:	01 c2                	add    %eax,%edx
  100431:	8b 45 08             	mov    0x8(%ebp),%eax
  100434:	66 25 ff 00          	and    $0xff,%ax
  100438:	80 cc 07             	or     $0x7,%ah
  10043b:	66 89 02             	mov    %ax,(%edx)
  10043e:	83 45 f8 01          	addl   $0x1,0xfffffff8(%ebp)
  
  if((pos/80) >= 24){  // Scroll up.
  100442:	81 7d f8 7f 07 00 00 	cmpl   $0x77f,0xfffffff8(%ebp)
  100449:	7e 4f                	jle    10049a <cga_putc+0x13a>
    memmove(crt, crt+80, sizeof(crt[0])*23*80);
  10044b:	a1 a0 c0 11 00       	mov    0x11c0a0,%eax
  100450:	05 a0 00 00 00       	add    $0xa0,%eax
  100455:	8b 15 a0 c0 11 00    	mov    0x11c0a0,%edx
  10045b:	c7 44 24 08 60 0e 00 	movl   $0xe60,0x8(%esp)
  100462:	00 
  100463:	89 44 24 04          	mov    %eax,0x4(%esp)
  100467:	89 14 24             	mov    %edx,(%esp)
  10046a:	e8 21 5b 00 00       	call   105f90 <memmove>
    pos -= 80;
  10046f:	83 6d f8 50          	subl   $0x50,0xfffffff8(%ebp)
    memset(crt + pos, 0, sizeof(crt[0])*80);
  100473:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  100476:	01 c0                	add    %eax,%eax
  100478:	89 c2                	mov    %eax,%edx
  10047a:	a1 a0 c0 11 00       	mov    0x11c0a0,%eax
  10047f:	8d 04 02             	lea    (%edx,%eax,1),%eax
  100482:	c7 44 24 08 a0 00 00 	movl   $0xa0,0x8(%esp)
  100489:	00 
  10048a:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  100491:	00 
  100492:	89 04 24             	mov    %eax,(%esp)
  100495:	e8 66 5a 00 00       	call   105f00 <memset>
  }
  
  outb(CRTPORT, 14);
  10049a:	c7 44 24 04 0e 00 00 	movl   $0xe,0x4(%esp)
  1004a1:	00 
  1004a2:	c7 04 24 d4 03 00 00 	movl   $0x3d4,(%esp)
  1004a9:	e8 92 fe ff ff       	call   100340 <outb>
  outb(CRTPORT+1, pos>>8);
  1004ae:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1004b1:	c1 f8 08             	sar    $0x8,%eax
  1004b4:	0f b6 c0             	movzbl %al,%eax
  1004b7:	89 44 24 04          	mov    %eax,0x4(%esp)
  1004bb:	c7 04 24 d5 03 00 00 	movl   $0x3d5,(%esp)
  1004c2:	e8 79 fe ff ff       	call   100340 <outb>
  outb(CRTPORT, 15);
  1004c7:	c7 44 24 04 0f 00 00 	movl   $0xf,0x4(%esp)
  1004ce:	00 
  1004cf:	c7 04 24 d4 03 00 00 	movl   $0x3d4,(%esp)
  1004d6:	e8 65 fe ff ff       	call   100340 <outb>
  outb(CRTPORT+1, pos);
  1004db:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1004de:	0f b6 c0             	movzbl %al,%eax
  1004e1:	89 44 24 04          	mov    %eax,0x4(%esp)
  1004e5:	c7 04 24 d5 03 00 00 	movl   $0x3d5,(%esp)
  1004ec:	e8 4f fe ff ff       	call   100340 <outb>
  crt[pos] = ' ' | 0x0700;
  1004f1:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1004f4:	01 c0                	add    %eax,%eax
  1004f6:	89 c2                	mov    %eax,%edx
  1004f8:	a1 a0 c0 11 00       	mov    0x11c0a0,%eax
  1004fd:	8d 04 02             	lea    (%edx,%eax,1),%eax
  100500:	66 c7 00 20 07       	movw   $0x720,(%eax)
}
  100505:	83 c4 24             	add    $0x24,%esp
  100508:	5b                   	pop    %ebx
  100509:	5d                   	pop    %ebp
  10050a:	c3                   	ret    
  10050b:	90                   	nop    
  10050c:	8d 74 26 00          	lea    0x0(%esi),%esi

00100510 <cons_putc>:

void
cons_putc(int c)
{
  100510:	55                   	push   %ebp
  100511:	89 e5                	mov    %esp,%ebp
  100513:	83 ec 08             	sub    $0x8,%esp
  if(panicked){
  100516:	a1 00 cd 11 00       	mov    0x11cd00,%eax
  10051b:	85 c0                	test   %eax,%eax
  10051d:	74 07                	je     100526 <cons_putc+0x16>
    cli();
  10051f:	e8 1c 00 00 00       	call   100540 <cli>
    for(;;)
      ;
  100524:	eb fe                	jmp    100524 <cons_putc+0x14>
  }

  lpt_putc(c);
  100526:	8b 45 08             	mov    0x8(%ebp),%eax
  100529:	89 04 24             	mov    %eax,(%esp)
  10052c:	e8 6f fd ff ff       	call   1002a0 <lpt_putc>
  cga_putc(c);
  100531:	8b 45 08             	mov    0x8(%ebp),%eax
  100534:	89 04 24             	mov    %eax,(%esp)
  100537:	e8 24 fe ff ff       	call   100360 <cga_putc>
}
  10053c:	c9                   	leave  
  10053d:	c3                   	ret    
  10053e:	89 f6                	mov    %esi,%esi

00100540 <cli>:
}

static inline void
cli(void)
{
  100540:	55                   	push   %ebp
  100541:	89 e5                	mov    %esp,%ebp
  asm volatile("cli");
  100543:	fa                   	cli    
}
  100544:	5d                   	pop    %ebp
  100545:	c3                   	ret    
  100546:	8d 76 00             	lea    0x0(%esi),%esi
  100549:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00100550 <printintlen>:

void
printintlen(int xx, int base, int sgn, int len, char fill)
{
  100550:	55                   	push   %ebp
  100551:	89 e5                	mov    %esp,%ebp
  100553:	53                   	push   %ebx
  100554:	83 ec 34             	sub    $0x34,%esp
  100557:	8b 45 18             	mov    0x18(%ebp),%eax
  10055a:	88 45 d8             	mov    %al,0xffffffd8(%ebp)
  static char digits[] = "0123456789ABCDEF";
  char buf[16];
  int i = 0, neg = 0, j = 0;
  10055d:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  100564:	c7 45 f0 00 00 00 00 	movl   $0x0,0xfffffff0(%ebp)
  10056b:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
  uint x;

  if(sgn && xx < 0){
  100572:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  100576:	74 17                	je     10058f <printintlen+0x3f>
  100578:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  10057c:	79 11                	jns    10058f <printintlen+0x3f>
    neg = 1;
  10057e:	c7 45 f0 01 00 00 00 	movl   $0x1,0xfffffff0(%ebp)
    x = 0 - xx;
  100585:	8b 45 08             	mov    0x8(%ebp),%eax
  100588:	f7 d8                	neg    %eax
  10058a:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  10058d:	eb 06                	jmp    100595 <printintlen+0x45>
  } else {
    x = xx;
  10058f:	8b 45 08             	mov    0x8(%ebp),%eax
  100592:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  }

  do{
    buf[i++] = digits[x % base];
  100595:	8b 4d ec             	mov    0xffffffec(%ebp),%ecx
  100598:	8b 55 0c             	mov    0xc(%ebp),%edx
  10059b:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10059e:	89 d3                	mov    %edx,%ebx
  1005a0:	ba 00 00 00 00       	mov    $0x0,%edx
  1005a5:	f7 f3                	div    %ebx
  1005a7:	89 d0                	mov    %edx,%eax
  1005a9:	0f b6 80 a4 c0 11 00 	movzbl 0x11c0a4(%eax),%eax
  1005b0:	88 44 0d dc          	mov    %al,0xffffffdc(%ebp,%ecx,1)
  1005b4:	83 45 ec 01          	addl   $0x1,0xffffffec(%ebp)
  }while((x /= base) != 0);
  1005b8:	8b 55 0c             	mov    0xc(%ebp),%edx
  1005bb:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1005be:	89 d1                	mov    %edx,%ecx
  1005c0:	ba 00 00 00 00       	mov    $0x0,%edx
  1005c5:	f7 f1                	div    %ecx
  1005c7:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  1005ca:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  1005ce:	75 c5                	jne    100595 <printintlen+0x45>
  if(neg)
  1005d0:	83 7d f0 00          	cmpl   $0x0,0xfffffff0(%ebp)
  1005d4:	74 0c                	je     1005e2 <printintlen+0x92>
    buf[i++] = '-';
  1005d6:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  1005d9:	c6 44 05 dc 2d       	movb   $0x2d,0xffffffdc(%ebp,%eax,1)
  1005de:	83 45 ec 01          	addl   $0x1,0xffffffec(%ebp)

  if (i < len)
  1005e2:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  1005e5:	3b 45 14             	cmp    0x14(%ebp),%eax
  1005e8:	7d 57                	jge    100641 <printintlen+0xf1>
  {
      if (neg)
  1005ea:	83 7d f0 00          	cmpl   $0x0,0xfffffff0(%ebp)
  1005ee:	74 10                	je     100600 <printintlen+0xb0>
      {
          cons_putc('-');
  1005f0:	c7 04 24 2d 00 00 00 	movl   $0x2d,(%esp)
  1005f7:	e8 14 ff ff ff       	call   100510 <cons_putc>
          i--;
  1005fc:	83 6d ec 01          	subl   $0x1,0xffffffec(%ebp)
      }
      j = len - i;
  100600:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  100603:	8b 55 14             	mov    0x14(%ebp),%edx
  100606:	89 d3                	mov    %edx,%ebx
  100608:	29 c3                	sub    %eax,%ebx
  10060a:	89 d8                	mov    %ebx,%eax
  10060c:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
      while (j-- > 0)
  10060f:	eb 0c                	jmp    10061d <printintlen+0xcd>
          cons_putc(fill);
  100611:	0f be 45 d8          	movsbl 0xffffffd8(%ebp),%eax
  100615:	89 04 24             	mov    %eax,(%esp)
  100618:	e8 f3 fe ff ff       	call   100510 <cons_putc>
  10061d:	83 7d f4 00          	cmpl   $0x0,0xfffffff4(%ebp)
  100621:	0f 9f c0             	setg   %al
  100624:	83 6d f4 01          	subl   $0x1,0xfffffff4(%ebp)
  100628:	84 c0                	test   %al,%al
  10062a:	75 e5                	jne    100611 <printintlen+0xc1>
  }
  while(--i >= 0)
  10062c:	eb 13                	jmp    100641 <printintlen+0xf1>
    cons_putc(buf[i]);
  10062e:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  100631:	0f b6 44 05 dc       	movzbl 0xffffffdc(%ebp,%eax,1),%eax
  100636:	0f be c0             	movsbl %al,%eax
  100639:	89 04 24             	mov    %eax,(%esp)
  10063c:	e8 cf fe ff ff       	call   100510 <cons_putc>
  100641:	83 6d ec 01          	subl   $0x1,0xffffffec(%ebp)
  100645:	83 7d ec 00          	cmpl   $0x0,0xffffffec(%ebp)
  100649:	79 e3                	jns    10062e <printintlen+0xde>
}
  10064b:	83 c4 34             	add    $0x34,%esp
  10064e:	5b                   	pop    %ebx
  10064f:	5d                   	pop    %ebp
  100650:	c3                   	ret    
  100651:	eb 0d                	jmp    100660 <printint>
  100653:	90                   	nop    
  100654:	90                   	nop    
  100655:	90                   	nop    
  100656:	90                   	nop    
  100657:	90                   	nop    
  100658:	90                   	nop    
  100659:	90                   	nop    
  10065a:	90                   	nop    
  10065b:	90                   	nop    
  10065c:	90                   	nop    
  10065d:	90                   	nop    
  10065e:	90                   	nop    
  10065f:	90                   	nop    

00100660 <printint>:

void
printint(int xx, int base, int sgn)
{
  100660:	55                   	push   %ebp
  100661:	89 e5                	mov    %esp,%ebp
  100663:	53                   	push   %ebx
  100664:	83 ec 24             	sub    $0x24,%esp
  static char digits[] = "0123456789ABCDEF";
  char buf[16];
  int i = 0, neg = 0;
  100667:	c7 45 f0 00 00 00 00 	movl   $0x0,0xfffffff0(%ebp)
  10066e:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
  uint x;

  if(sgn && xx < 0){
  100675:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  100679:	74 17                	je     100692 <printint+0x32>
  10067b:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  10067f:	79 11                	jns    100692 <printint+0x32>
    neg = 1;
  100681:	c7 45 f4 01 00 00 00 	movl   $0x1,0xfffffff4(%ebp)
    x = 0 - xx;
  100688:	8b 45 08             	mov    0x8(%ebp),%eax
  10068b:	f7 d8                	neg    %eax
  10068d:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  100690:	eb 06                	jmp    100698 <printint+0x38>
  } else {
    x = xx;
  100692:	8b 45 08             	mov    0x8(%ebp),%eax
  100695:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  }

  do{
    buf[i++] = digits[x % base];
  100698:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
  10069b:	8b 55 0c             	mov    0xc(%ebp),%edx
  10069e:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1006a1:	89 d3                	mov    %edx,%ebx
  1006a3:	ba 00 00 00 00       	mov    $0x0,%edx
  1006a8:	f7 f3                	div    %ebx
  1006aa:	89 d0                	mov    %edx,%eax
  1006ac:	0f b6 80 b5 c0 11 00 	movzbl 0x11c0b5(%eax),%eax
  1006b3:	88 44 0d e0          	mov    %al,0xffffffe0(%ebp,%ecx,1)
  1006b7:	83 45 f0 01          	addl   $0x1,0xfffffff0(%ebp)
  }while((x /= base) != 0);
  1006bb:	8b 55 0c             	mov    0xc(%ebp),%edx
  1006be:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1006c1:	89 d1                	mov    %edx,%ecx
  1006c3:	ba 00 00 00 00       	mov    $0x0,%edx
  1006c8:	f7 f1                	div    %ecx
  1006ca:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  1006cd:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  1006d1:	75 c5                	jne    100698 <printint+0x38>
  if(neg)
  1006d3:	83 7d f4 00          	cmpl   $0x0,0xfffffff4(%ebp)
  1006d7:	74 21                	je     1006fa <printint+0x9a>
    buf[i++] = '-';
  1006d9:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  1006dc:	c6 44 05 e0 2d       	movb   $0x2d,0xffffffe0(%ebp,%eax,1)
  1006e1:	83 45 f0 01          	addl   $0x1,0xfffffff0(%ebp)

  while(--i >= 0)
  1006e5:	eb 13                	jmp    1006fa <printint+0x9a>
    cons_putc(buf[i]);
  1006e7:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  1006ea:	0f b6 44 05 e0       	movzbl 0xffffffe0(%ebp,%eax,1),%eax
  1006ef:	0f be c0             	movsbl %al,%eax
  1006f2:	89 04 24             	mov    %eax,(%esp)
  1006f5:	e8 16 fe ff ff       	call   100510 <cons_putc>
  1006fa:	83 6d f0 01          	subl   $0x1,0xfffffff0(%ebp)
  1006fe:	83 7d f0 00          	cmpl   $0x0,0xfffffff0(%ebp)
  100702:	79 e3                	jns    1006e7 <printint+0x87>
}
  100704:	83 c4 24             	add    $0x24,%esp
  100707:	5b                   	pop    %ebx
  100708:	5d                   	pop    %ebp
  100709:	c3                   	ret    
  10070a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

00100710 <cprintf>:

enum fmt_types {
    CHAR,
    SHORT,
    LONG,
    LONGLONG,
};

// Print to the console. only understands %d, %x, %p, %s.
void
cprintf(char *fmt, ...)
{
  100710:	55                   	push   %ebp
  100711:	89 e5                	mov    %esp,%ebp
  100713:	83 ec 58             	sub    $0x58,%esp
  int i, c, state, locking, len = 0;
  100716:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  uint *argp;
  char *s, last, fill;
  enum fmt_types type;

  locking = use_console_lock;
  10071d:	a1 04 cd 11 00       	mov    0x11cd04,%eax
  100722:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
  if(locking)
  100725:	83 7d e8 00          	cmpl   $0x0,0xffffffe8(%ebp)
  100729:	74 0c                	je     100737 <cprintf+0x27>
    acquire(&console_lock);
  10072b:	c7 04 24 20 cd 11 00 	movl   $0x11cd20,(%esp)
  100732:	e8 09 54 00 00       	call   105b40 <acquire>

  argp = (uint*)(void*)&fmt + 1;
  100737:	8d 45 08             	lea    0x8(%ebp),%eax
  10073a:	83 c0 04             	add    $0x4,%eax
  10073d:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
  state = 0;
  100740:	c7 45 e4 00 00 00 00 	movl   $0x0,0xffffffe4(%ebp)
  c = 0;
  100747:	c7 45 e0 00 00 00 00 	movl   $0x0,0xffffffe0(%ebp)
  fill = ' ';
  10074e:	c6 45 fb 20          	movb   $0x20,0xfffffffb(%ebp)
  len = -1;
  100752:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  for(i = 0; fmt[i]; i++){
  100759:	c7 45 dc 00 00 00 00 	movl   $0x0,0xffffffdc(%ebp)
  100760:	e9 f2 02 00 00       	jmp    100a57 <cprintf+0x347>
    last = c;
  100765:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  100768:	88 45 fa             	mov    %al,0xfffffffa(%ebp)
    c = fmt[i] & 0xff;
  10076b:	8b 55 08             	mov    0x8(%ebp),%edx
  10076e:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  100771:	8d 04 02             	lea    (%edx,%eax,1),%eax
  100774:	0f b6 00             	movzbl (%eax),%eax
  100777:	0f be c0             	movsbl %al,%eax
  10077a:	25 ff 00 00 00       	and    $0xff,%eax
  10077f:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
    switch(state){
  100782:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
  100785:	89 45 cc             	mov    %eax,0xffffffcc(%ebp)
  100788:	83 7d cc 00          	cmpl   $0x0,0xffffffcc(%ebp)
  10078c:	74 0b                	je     100799 <cprintf+0x89>
  10078e:	83 7d cc 25          	cmpl   $0x25,0xffffffcc(%ebp)
  100792:	74 27                	je     1007bb <cprintf+0xab>
  100794:	e9 ba 02 00 00       	jmp    100a53 <cprintf+0x343>
    case 0:
      if(c == '%')
  100799:	83 7d e0 25          	cmpl   $0x25,0xffffffe0(%ebp)
  10079d:	75 0c                	jne    1007ab <cprintf+0x9b>
        state = '%';
  10079f:	c7 45 e4 25 00 00 00 	movl   $0x25,0xffffffe4(%ebp)
  1007a6:	e9 a8 02 00 00       	jmp    100a53 <cprintf+0x343>
      else
        cons_putc(c);
  1007ab:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  1007ae:	89 04 24             	mov    %eax,(%esp)
  1007b1:	e8 5a fd ff ff       	call   100510 <cons_putc>
      break;
  1007b6:	e9 98 02 00 00       	jmp    100a53 <cprintf+0x343>
    
    case '%':
      switch(c){
  1007bb:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
  1007be:	83 ea 25             	sub    $0x25,%edx
  1007c1:	89 55 c8             	mov    %edx,0xffffffc8(%ebp)
  1007c4:	83 7d c8 53          	cmpl   $0x53,0xffffffc8(%ebp)
  1007c8:	0f 87 6e 02 00 00    	ja     100a3c <cprintf+0x32c>
  1007ce:	8b 55 c8             	mov    0xffffffc8(%ebp),%edx
  1007d1:	8b 04 95 e0 a1 11 00 	mov    0x11a1e0(,%edx,4),%eax
  1007d8:	ff e0                	jmp    *%eax
      case 'l':
        if (last == 'l')
  1007da:	80 7d fa 6c          	cmpb   $0x6c,0xfffffffa(%ebp)
  1007de:	75 0c                	jne    1007ec <cprintf+0xdc>
        {
            // ll: long long
            type = LONGLONG;
  1007e0:	c7 45 fc 03 00 00 00 	movl   $0x3,0xfffffffc(%ebp)
  1007e7:	e9 67 02 00 00       	jmp    100a53 <cprintf+0x343>
        } else {
            type = LONG;
  1007ec:	c7 45 fc 02 00 00 00 	movl   $0x2,0xfffffffc(%ebp)
        }
        break;
  1007f3:	e9 5b 02 00 00       	jmp    100a53 <cprintf+0x343>
      case 'h':
        if (last == 'h')
  1007f8:	80 7d fa 68          	cmpb   $0x68,0xfffffffa(%ebp)
  1007fc:	75 0c                	jne    10080a <cprintf+0xfa>
        {
            // hh: char
            type = CHAR;
  1007fe:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
  100805:	e9 49 02 00 00       	jmp    100a53 <cprintf+0x343>
        } else {
            type = SHORT;
  10080a:	c7 45 fc 01 00 00 00 	movl   $0x1,0xfffffffc(%ebp)
        }
        break;
  100811:	e9 3d 02 00 00       	jmp    100a53 <cprintf+0x343>
      case 'c':
        cons_putc(*argp++);
  100816:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  100819:	8b 00                	mov    (%eax),%eax
  10081b:	83 45 f0 04          	addl   $0x4,0xfffffff0(%ebp)
  10081f:	89 04 24             	mov    %eax,(%esp)
  100822:	e8 e9 fc ff ff       	call   100510 <cons_putc>
        len = -1;
  100827:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
        state = 0;
  10082e:	c7 45 e4 00 00 00 00 	movl   $0x0,0xffffffe4(%ebp)
        break;
  100835:	e9 19 02 00 00       	jmp    100a53 <cprintf+0x343>
      case 'd':
      case 'i':
        if (len != -1)
  10083a:	83 7d ec ff          	cmpl   $0xffffffff,0xffffffec(%ebp)
  10083e:	74 34                	je     100874 <cprintf+0x164>
            printintlen(*argp++, 10, 1, len, fill);
  100840:	0f be 55 fb          	movsbl 0xfffffffb(%ebp),%edx
  100844:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  100847:	8b 00                	mov    (%eax),%eax
  100849:	89 c1                	mov    %eax,%ecx
  10084b:	83 45 f0 04          	addl   $0x4,0xfffffff0(%ebp)
  10084f:	89 54 24 10          	mov    %edx,0x10(%esp)
  100853:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  100856:	89 44 24 0c          	mov    %eax,0xc(%esp)
  10085a:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  100861:	00 
  100862:	c7 44 24 04 0a 00 00 	movl   $0xa,0x4(%esp)
  100869:	00 
  10086a:	89 0c 24             	mov    %ecx,(%esp)
  10086d:	e8 de fc ff ff       	call   100550 <printintlen>
  100872:	eb 21                	jmp    100895 <cprintf+0x185>
        else
            printint(*argp++, 10, 1);
  100874:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  100877:	8b 00                	mov    (%eax),%eax
  100879:	83 45 f0 04          	addl   $0x4,0xfffffff0(%ebp)
  10087d:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  100884:	00 
  100885:	c7 44 24 04 0a 00 00 	movl   $0xa,0x4(%esp)
  10088c:	00 
  10088d:	89 04 24             	mov    %eax,(%esp)
  100890:	e8 cb fd ff ff       	call   100660 <printint>
        fill = ' ';
  100895:	c6 45 fb 20          	movb   $0x20,0xfffffffb(%ebp)
        len = -1;
  100899:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
        state = 0;
  1008a0:	c7 45 e4 00 00 00 00 	movl   $0x0,0xffffffe4(%ebp)
        break;
  1008a7:	e9 a7 01 00 00       	jmp    100a53 <cprintf+0x343>
      case 'u':
        if (len != -1)
  1008ac:	83 7d ec ff          	cmpl   $0xffffffff,0xffffffec(%ebp)
  1008b0:	74 34                	je     1008e6 <cprintf+0x1d6>
            printintlen(*argp++, 10, 0, len, fill);
  1008b2:	0f be 55 fb          	movsbl 0xfffffffb(%ebp),%edx
  1008b6:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  1008b9:	8b 00                	mov    (%eax),%eax
  1008bb:	89 c1                	mov    %eax,%ecx
  1008bd:	83 45 f0 04          	addl   $0x4,0xfffffff0(%ebp)
  1008c1:	89 54 24 10          	mov    %edx,0x10(%esp)
  1008c5:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  1008c8:	89 44 24 0c          	mov    %eax,0xc(%esp)
  1008cc:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  1008d3:	00 
  1008d4:	c7 44 24 04 0a 00 00 	movl   $0xa,0x4(%esp)
  1008db:	00 
  1008dc:	89 0c 24             	mov    %ecx,(%esp)
  1008df:	e8 6c fc ff ff       	call   100550 <printintlen>
  1008e4:	eb 21                	jmp    100907 <cprintf+0x1f7>
        else
            printint(*argp++, 10, 0);
  1008e6:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  1008e9:	8b 00                	mov    (%eax),%eax
  1008eb:	83 45 f0 04          	addl   $0x4,0xfffffff0(%ebp)
  1008ef:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  1008f6:	00 
  1008f7:	c7 44 24 04 0a 00 00 	movl   $0xa,0x4(%esp)
  1008fe:	00 
  1008ff:	89 04 24             	mov    %eax,(%esp)
  100902:	e8 59 fd ff ff       	call   100660 <printint>
        fill = ' ';
  100907:	c6 45 fb 20          	movb   $0x20,0xfffffffb(%ebp)
        len = -1;
  10090b:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
        state = 0;
  100912:	c7 45 e4 00 00 00 00 	movl   $0x0,0xffffffe4(%ebp)
        break;
  100919:	e9 35 01 00 00       	jmp    100a53 <cprintf+0x343>
      case 'x':
      case 'p':
        if (len != -1)
  10091e:	83 7d ec ff          	cmpl   $0xffffffff,0xffffffec(%ebp)
  100922:	74 34                	je     100958 <cprintf+0x248>
            printintlen(*argp++, 16, 0, len, fill);
  100924:	0f be 55 fb          	movsbl 0xfffffffb(%ebp),%edx
  100928:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10092b:	8b 00                	mov    (%eax),%eax
  10092d:	89 c1                	mov    %eax,%ecx
  10092f:	83 45 f0 04          	addl   $0x4,0xfffffff0(%ebp)
  100933:	89 54 24 10          	mov    %edx,0x10(%esp)
  100937:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10093a:	89 44 24 0c          	mov    %eax,0xc(%esp)
  10093e:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  100945:	00 
  100946:	c7 44 24 04 10 00 00 	movl   $0x10,0x4(%esp)
  10094d:	00 
  10094e:	89 0c 24             	mov    %ecx,(%esp)
  100951:	e8 fa fb ff ff       	call   100550 <printintlen>
  100956:	eb 21                	jmp    100979 <cprintf+0x269>
        else
            printint(*argp++, 16, 0);
  100958:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10095b:	8b 00                	mov    (%eax),%eax
  10095d:	83 45 f0 04          	addl   $0x4,0xfffffff0(%ebp)
  100961:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  100968:	00 
  100969:	c7 44 24 04 10 00 00 	movl   $0x10,0x4(%esp)
  100970:	00 
  100971:	89 04 24             	mov    %eax,(%esp)
  100974:	e8 e7 fc ff ff       	call   100660 <printint>
        fill = ' ';
  100979:	c6 45 fb 20          	movb   $0x20,0xfffffffb(%ebp)
        len = -1;
  10097d:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
        state = 0;
  100984:	c7 45 e4 00 00 00 00 	movl   $0x0,0xffffffe4(%ebp)
        break;
  10098b:	e9 c3 00 00 00       	jmp    100a53 <cprintf+0x343>
      case 's':
        s = (char*)*argp++;
  100990:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  100993:	8b 00                	mov    (%eax),%eax
  100995:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  100998:	83 45 f0 04          	addl   $0x4,0xfffffff0(%ebp)
        if(s == 0)
  10099c:	83 7d f4 00          	cmpl   $0x0,0xfffffff4(%ebp)
  1009a0:	75 1e                	jne    1009c0 <cprintf+0x2b0>
          s = "(null)";
  1009a2:	c7 45 f4 d8 a1 11 00 	movl   $0x11a1d8,0xfffffff4(%ebp)
        for(; *s; s++)
  1009a9:	eb 15                	jmp    1009c0 <cprintf+0x2b0>
          cons_putc(*s);
  1009ab:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  1009ae:	0f b6 00             	movzbl (%eax),%eax
  1009b1:	0f be c0             	movsbl %al,%eax
  1009b4:	89 04 24             	mov    %eax,(%esp)
  1009b7:	e8 54 fb ff ff       	call   100510 <cons_putc>
  1009bc:	83 45 f4 01          	addl   $0x1,0xfffffff4(%ebp)
  1009c0:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  1009c3:	0f b6 00             	movzbl (%eax),%eax
  1009c6:	84 c0                	test   %al,%al
  1009c8:	75 e1                	jne    1009ab <cprintf+0x29b>
        len = -1;
  1009ca:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
        state = 0;
  1009d1:	c7 45 e4 00 00 00 00 	movl   $0x0,0xffffffe4(%ebp)
        break;
  1009d8:	eb 79                	jmp    100a53 <cprintf+0x343>
      case '%':
        cons_putc('%');
  1009da:	c7 04 24 25 00 00 00 	movl   $0x25,(%esp)
  1009e1:	e8 2a fb ff ff       	call   100510 <cons_putc>
        state = 0;
  1009e6:	c7 45 e4 00 00 00 00 	movl   $0x0,0xffffffe4(%ebp)
        break;
  1009ed:	eb 64                	jmp    100a53 <cprintf+0x343>
      case '0':
        if (len == -1)
  1009ef:	83 7d ec ff          	cmpl   $0xffffffff,0xffffffec(%ebp)
  1009f3:	75 0d                	jne    100a02 <cprintf+0x2f2>
        {
            len = 0;
  1009f5:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
            fill = '0';
  1009fc:	c6 45 fb 30          	movb   $0x30,0xfffffffb(%ebp)
  100a00:	eb 51                	jmp    100a53 <cprintf+0x343>
        } else {
            len = len * 10;
  100a02:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  100a05:	89 c2                	mov    %eax,%edx
  100a07:	c1 e2 02             	shl    $0x2,%edx
  100a0a:	01 c2                	add    %eax,%edx
  100a0c:	8d 04 12             	lea    (%edx,%edx,1),%eax
  100a0f:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
        }
        break;
  100a12:	eb 3f                	jmp    100a53 <cprintf+0x343>
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
        if (len == -1)
  100a14:	83 7d ec ff          	cmpl   $0xffffffff,0xffffffec(%ebp)
  100a18:	75 0b                	jne    100a25 <cprintf+0x315>
            len = c - '0';
  100a1a:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  100a1d:	83 e8 30             	sub    $0x30,%eax
  100a20:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  100a23:	eb 2e                	jmp    100a53 <cprintf+0x343>
        else
            len = len * 10 + c - '0';
  100a25:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
  100a28:	89 d0                	mov    %edx,%eax
  100a2a:	c1 e0 02             	shl    $0x2,%eax
  100a2d:	01 d0                	add    %edx,%eax
  100a2f:	01 c0                	add    %eax,%eax
  100a31:	03 45 e0             	add    0xffffffe0(%ebp),%eax
  100a34:	83 e8 30             	sub    $0x30,%eax
  100a37:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
        break;
  100a3a:	eb 17                	jmp    100a53 <cprintf+0x343>
      default:
        // Print unknown % sequence to draw attention.
        cons_putc('%');
  100a3c:	c7 04 24 25 00 00 00 	movl   $0x25,(%esp)
  100a43:	e8 c8 fa ff ff       	call   100510 <cons_putc>
        cons_putc(c);
  100a48:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  100a4b:	89 04 24             	mov    %eax,(%esp)
  100a4e:	e8 bd fa ff ff       	call   100510 <cons_putc>
  100a53:	83 45 dc 01          	addl   $0x1,0xffffffdc(%ebp)
  100a57:	8b 55 08             	mov    0x8(%ebp),%edx
  100a5a:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  100a5d:	8d 04 02             	lea    (%edx,%eax,1),%eax
  100a60:	0f b6 00             	movzbl (%eax),%eax
  100a63:	84 c0                	test   %al,%al
  100a65:	0f 85 fa fc ff ff    	jne    100765 <cprintf+0x55>
        break;
      }
      break;
    }
  }

  if(locking)
  100a6b:	83 7d e8 00          	cmpl   $0x0,0xffffffe8(%ebp)
  100a6f:	74 0c                	je     100a7d <cprintf+0x36d>
    release(&console_lock);
  100a71:	c7 04 24 20 cd 11 00 	movl   $0x11cd20,(%esp)
  100a78:	e8 c3 52 00 00       	call   105d40 <release>
}
  100a7d:	c9                   	leave  
  100a7e:	c3                   	ret    
  100a7f:	90                   	nop    

00100a80 <console_write>:

int
console_write(struct inode *ip, char *buf, int n)
{
  100a80:	55                   	push   %ebp
  100a81:	89 e5                	mov    %esp,%ebp
  100a83:	83 ec 18             	sub    $0x18,%esp
  int i;

  iunlock(ip);
  100a86:	8b 45 08             	mov    0x8(%ebp),%eax
  100a89:	89 04 24             	mov    %eax,(%esp)
  100a8c:	e8 8f 14 00 00       	call   101f20 <iunlock>
  acquire(&console_lock);
  100a91:	c7 04 24 20 cd 11 00 	movl   $0x11cd20,(%esp)
  100a98:	e8 a3 50 00 00       	call   105b40 <acquire>
  for(i = 0; i < n; i++)
  100a9d:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
  100aa4:	eb 1d                	jmp    100ac3 <console_write+0x43>
    cons_putc(buf[i] & 0xff);
  100aa6:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  100aa9:	03 45 0c             	add    0xc(%ebp),%eax
  100aac:	0f b6 00             	movzbl (%eax),%eax
  100aaf:	0f be c0             	movsbl %al,%eax
  100ab2:	25 ff 00 00 00       	and    $0xff,%eax
  100ab7:	89 04 24             	mov    %eax,(%esp)
  100aba:	e8 51 fa ff ff       	call   100510 <cons_putc>
  100abf:	83 45 fc 01          	addl   $0x1,0xfffffffc(%ebp)
  100ac3:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  100ac6:	3b 45 10             	cmp    0x10(%ebp),%eax
  100ac9:	7c db                	jl     100aa6 <console_write+0x26>
  release(&console_lock);
  100acb:	c7 04 24 20 cd 11 00 	movl   $0x11cd20,(%esp)
  100ad2:	e8 69 52 00 00       	call   105d40 <release>
  ilock(ip);
  100ad7:	8b 45 08             	mov    0x8(%ebp),%eax
  100ada:	89 04 24             	mov    %eax,(%esp)
  100add:	e8 de 12 00 00       	call   101dc0 <ilock>

  return n;
  100ae2:	8b 45 10             	mov    0x10(%ebp),%eax
}
  100ae5:	c9                   	leave  
  100ae6:	c3                   	ret    
  100ae7:	89 f6                	mov    %esi,%esi
  100ae9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00100af0 <console_intr>:

#define INPUT_BUF 128
struct {
  struct spinlock lock;
  char buf[INPUT_BUF];
  int r;  // Read index
  int w;  // Write index
  int e;  // Edit index
} input;

#define C(x)  ((x)-'@')  // Control-x

void
console_intr(int (*getc)(void))
{
  100af0:	55                   	push   %ebp
  100af1:	89 e5                	mov    %esp,%ebp
  100af3:	83 ec 18             	sub    $0x18,%esp
  int c;

  acquire(&input.lock);
  100af6:	c7 04 24 20 b1 13 00 	movl   $0x13b120,(%esp)
  100afd:	e8 3e 50 00 00       	call   105b40 <acquire>
  while((c = getc()) >= 0){
  100b02:	e9 30 01 00 00       	jmp    100c37 <console_intr+0x147>
    switch(c){
  100b07:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  100b0a:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  100b0d:	83 7d ec 10          	cmpl   $0x10,0xffffffec(%ebp)
  100b11:	74 11                	je     100b24 <console_intr+0x34>
  100b13:	83 7d ec 15          	cmpl   $0x15,0xffffffec(%ebp)
  100b17:	74 2e                	je     100b47 <console_intr+0x57>
  100b19:	83 7d ec 08          	cmpl   $0x8,0xffffffec(%ebp)
  100b1d:	74 65                	je     100b84 <console_intr+0x94>
  100b1f:	e9 91 00 00 00       	jmp    100bb5 <console_intr+0xc5>
    case C('P'):  // Process listing.
      procdump();
  100b24:	e8 c7 4e 00 00       	call   1059f0 <procdump>
      break;
  100b29:	e9 09 01 00 00       	jmp    100c37 <console_intr+0x147>
    case C('U'):  // Kill line.
      while(input.e > input.w &&
            input.buf[(input.e-1) % INPUT_BUF] != '\n'){
        input.e--;
  100b2e:	a1 dc b1 13 00       	mov    0x13b1dc,%eax
  100b33:	83 e8 01             	sub    $0x1,%eax
  100b36:	a3 dc b1 13 00       	mov    %eax,0x13b1dc
        cons_putc(BACKSPACE);
  100b3b:	c7 04 24 00 01 00 00 	movl   $0x100,(%esp)
  100b42:	e8 c9 f9 ff ff       	call   100510 <cons_putc>
  100b47:	8b 15 dc b1 13 00    	mov    0x13b1dc,%edx
  100b4d:	a1 d8 b1 13 00       	mov    0x13b1d8,%eax
  100b52:	39 c2                	cmp    %eax,%edx
  100b54:	0f 8e dd 00 00 00    	jle    100c37 <console_intr+0x147>
  100b5a:	a1 dc b1 13 00       	mov    0x13b1dc,%eax
  100b5f:	8d 50 ff             	lea    0xffffffff(%eax),%edx
  100b62:	89 d0                	mov    %edx,%eax
  100b64:	c1 f8 1f             	sar    $0x1f,%eax
  100b67:	89 c1                	mov    %eax,%ecx
  100b69:	c1 e9 19             	shr    $0x19,%ecx
  100b6c:	8d 04 0a             	lea    (%edx,%ecx,1),%eax
  100b6f:	83 e0 7f             	and    $0x7f,%eax
  100b72:	29 c8                	sub    %ecx,%eax
  100b74:	0f b6 80 54 b1 13 00 	movzbl 0x13b154(%eax),%eax
  100b7b:	3c 0a                	cmp    $0xa,%al
  100b7d:	75 af                	jne    100b2e <console_intr+0x3e>
      }
      break;
  100b7f:	e9 b3 00 00 00       	jmp    100c37 <console_intr+0x147>
    case C('H'):  // Backspace
      if(input.e > input.w){
  100b84:	8b 15 dc b1 13 00    	mov    0x13b1dc,%edx
  100b8a:	a1 d8 b1 13 00       	mov    0x13b1d8,%eax
  100b8f:	39 c2                	cmp    %eax,%edx
  100b91:	0f 8e a0 00 00 00    	jle    100c37 <console_intr+0x147>
        input.e--;
  100b97:	a1 dc b1 13 00       	mov    0x13b1dc,%eax
  100b9c:	83 e8 01             	sub    $0x1,%eax
  100b9f:	a3 dc b1 13 00       	mov    %eax,0x13b1dc
        cons_putc(BACKSPACE);
  100ba4:	c7 04 24 00 01 00 00 	movl   $0x100,(%esp)
  100bab:	e8 60 f9 ff ff       	call   100510 <cons_putc>
      }
      break;
  100bb0:	e9 82 00 00 00       	jmp    100c37 <console_intr+0x147>
    default:
      if(c != 0 && input.e < input.r+INPUT_BUF){
  100bb5:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  100bb9:	74 7c                	je     100c37 <console_intr+0x147>
  100bbb:	a1 dc b1 13 00       	mov    0x13b1dc,%eax
  100bc0:	8b 15 d4 b1 13 00    	mov    0x13b1d4,%edx
  100bc6:	83 ea 80             	sub    $0xffffff80,%edx
  100bc9:	39 d0                	cmp    %edx,%eax
  100bcb:	7d 6a                	jge    100c37 <console_intr+0x147>
        input.buf[input.e++ % INPUT_BUF] = c;
  100bcd:	8b 0d dc b1 13 00    	mov    0x13b1dc,%ecx
  100bd3:	89 c8                	mov    %ecx,%eax
  100bd5:	c1 f8 1f             	sar    $0x1f,%eax
  100bd8:	89 c2                	mov    %eax,%edx
  100bda:	c1 ea 19             	shr    $0x19,%edx
  100bdd:	8d 04 11             	lea    (%ecx,%edx,1),%eax
  100be0:	83 e0 7f             	and    $0x7f,%eax
  100be3:	29 d0                	sub    %edx,%eax
  100be5:	89 c2                	mov    %eax,%edx
  100be7:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  100bea:	88 82 54 b1 13 00    	mov    %al,0x13b154(%edx)
  100bf0:	8d 41 01             	lea    0x1(%ecx),%eax
  100bf3:	a3 dc b1 13 00       	mov    %eax,0x13b1dc
        cons_putc(c);
  100bf8:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  100bfb:	89 04 24             	mov    %eax,(%esp)
  100bfe:	e8 0d f9 ff ff       	call   100510 <cons_putc>
        if(c == '\n' || c == C('D') || input.e == input.r+INPUT_BUF){
  100c03:	83 7d fc 0a          	cmpl   $0xa,0xfffffffc(%ebp)
  100c07:	74 18                	je     100c21 <console_intr+0x131>
  100c09:	83 7d fc 04          	cmpl   $0x4,0xfffffffc(%ebp)
  100c0d:	74 12                	je     100c21 <console_intr+0x131>
  100c0f:	a1 dc b1 13 00       	mov    0x13b1dc,%eax
  100c14:	8b 15 d4 b1 13 00    	mov    0x13b1d4,%edx
  100c1a:	83 ea 80             	sub    $0xffffff80,%edx
  100c1d:	39 d0                	cmp    %edx,%eax
  100c1f:	75 16                	jne    100c37 <console_intr+0x147>
          input.w = input.e;
  100c21:	a1 dc b1 13 00       	mov    0x13b1dc,%eax
  100c26:	a3 d8 b1 13 00       	mov    %eax,0x13b1d8
          wakeup(&input.r);
  100c2b:	c7 04 24 d4 b1 13 00 	movl   $0x13b1d4,(%esp)
  100c32:	e8 e9 49 00 00       	call   105620 <wakeup>
  100c37:	8b 45 08             	mov    0x8(%ebp),%eax
  100c3a:	ff d0                	call   *%eax
  100c3c:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  100c3f:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  100c43:	0f 89 be fe ff ff    	jns    100b07 <console_intr+0x17>
        }
      }
      break;
    }
  }
  release(&input.lock);
  100c49:	c7 04 24 20 b1 13 00 	movl   $0x13b120,(%esp)
  100c50:	e8 eb 50 00 00       	call   105d40 <release>
}
  100c55:	c9                   	leave  
  100c56:	c3                   	ret    
  100c57:	89 f6                	mov    %esi,%esi
  100c59:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00100c60 <thread_stub>:

void
thread_stub(void * arg)
{
  100c60:	55                   	push   %ebp
  100c61:	89 e5                	mov    %esp,%ebp
  100c63:	81 ec 38 02 00 00    	sub    $0x238,%esp
/*    static int id = 0;
    id++;
//    int myid = id;
    cprintf("thread_stub started! arg: %d\n", arg);
    int i;
    for (i=0; i<100000000; i++)
    {
        if (i % 100000 == 0)
        cprintf("%d:", myid);
    }*/
  static int in = 0;
  if (in)
  100c69:	a1 08 cd 11 00       	mov    0x11cd08,%eax
  100c6e:	85 c0                	test   %eax,%eax
  100c70:	0f 85 7d 01 00 00    	jne    100df3 <thread_stub+0x193>
      return;
  in = 1;
  100c76:	c7 05 08 cd 11 00 01 	movl   $0x1,0x11cd08
  100c7d:	00 00 00 
  unsigned char data[512];
  int s;
  int len;
  s = lwip_socket(PF_INET, SOCK_STREAM, 0);
  100c80:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  100c87:	00 
  100c88:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  100c8f:	00 
  100c90:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  100c97:	e8 b4 7c 01 00       	call   118950 <lwip_socket>
  100c9c:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  struct sockaddr_in sa;
  sa.sin_family = AF_INET;
  100c9f:	c6 85 e5 fd ff ff 02 	movb   $0x2,0xfffffde5(%ebp)
  sa.sin_port = htons(80);
  100ca6:	c7 04 24 50 00 00 00 	movl   $0x50,(%esp)
  100cad:	e8 be d5 00 00       	call   10e270 <htons>
  100cb2:	66 89 85 e6 fd ff ff 	mov    %ax,0xfffffde6(%ebp)
  sa.sin_addr.s_addr = inet_addr("192.168.1.1");
  100cb9:	c7 04 24 30 a3 11 00 	movl   $0x11a330,(%esp)
  100cc0:	e8 cb d1 00 00       	call   10de90 <inet_addr>
  100cc5:	89 85 e8 fd ff ff    	mov    %eax,0xfffffde8(%ebp)
  len = 1;
  100ccb:	c7 85 f4 fd ff ff 01 	movl   $0x1,0xfffffdf4(%ebp)
  100cd2:	00 00 00 
  lwip_setsockopt(s, SOL_SOCKET, SO_REUSEPORT, &len, sizeof(int));
  100cd5:	c7 44 24 10 04 00 00 	movl   $0x4,0x10(%esp)
  100cdc:	00 
  100cdd:	8d 85 f4 fd ff ff    	lea    0xfffffdf4(%ebp),%eax
  100ce3:	89 44 24 0c          	mov    %eax,0xc(%esp)
  100ce7:	c7 44 24 08 00 02 00 	movl   $0x200,0x8(%esp)
  100cee:	00 
  100cef:	c7 44 24 04 ff 0f 00 	movl   $0xfff,0x4(%esp)
  100cf6:	00 
  100cf7:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  100cfa:	89 04 24             	mov    %eax,(%esp)
  100cfd:	e8 de 89 01 00       	call   1196e0 <lwip_setsockopt>
  lwip_bind(s, &sa, sizeof(sa));
  100d02:	8d 85 e4 fd ff ff    	lea    0xfffffde4(%ebp),%eax
  100d08:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
  100d0f:	00 
  100d10:	89 44 24 04          	mov    %eax,0x4(%esp)
  100d14:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  100d17:	89 04 24             	mov    %eax,(%esp)
  100d1a:	e8 a1 74 01 00       	call   1181c0 <lwip_bind>
  int addrlen = sizeof(sa);
  100d1f:	c7 85 e0 fd ff ff 10 	movl   $0x10,0xfffffde0(%ebp)
  100d26:	00 00 00 
//  len = lwip_recvfrom(s, data, sizeof(data), 0, &sa, &addrlen);
//  lwip_sendto(s, data, len, 0, &sa, addrlen);
  int client;
  lwip_listen(s, 1);
  100d29:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  100d30:	00 
  100d31:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  100d34:	89 04 24             	mov    %eax,(%esp)
  100d37:	e8 d4 76 01 00       	call   118410 <lwip_listen>
  while ((client = lwip_accept(s, &sa, &addrlen)) > 0)
  100d3c:	eb 74                	jmp    100db2 <thread_stub+0x152>
  {
      do {
        len = lwip_read(client, data, sizeof(data));
  100d3e:	c7 44 24 08 00 02 00 	movl   $0x200,0x8(%esp)
  100d45:	00 
  100d46:	8d 85 f8 fd ff ff    	lea    0xfffffdf8(%ebp),%eax
  100d4c:	89 44 24 04          	mov    %eax,0x4(%esp)
  100d50:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  100d53:	89 04 24             	mov    %eax,(%esp)
  100d56:	e8 55 79 01 00       	call   1186b0 <lwip_read>
  100d5b:	89 85 f4 fd ff ff    	mov    %eax,0xfffffdf4(%ebp)
//        cprintf("received %d bytes\n", len);
        lwip_send(client, data, len, 0);
  100d61:	8b 85 f4 fd ff ff    	mov    0xfffffdf4(%ebp),%eax
  100d67:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  100d6e:	00 
  100d6f:	89 44 24 08          	mov    %eax,0x8(%esp)
  100d73:	8d 85 f8 fd ff ff    	lea    0xfffffdf8(%ebp),%eax
  100d79:	89 44 24 04          	mov    %eax,0x4(%esp)
  100d7d:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  100d80:	89 04 24             	mov    %eax,(%esp)
  100d83:	e8 a8 79 01 00       	call   118730 <lwip_send>
        if (data[0] == '!')
  100d88:	0f b6 85 f8 fd ff ff 	movzbl 0xfffffdf8(%ebp),%eax
  100d8f:	3c 21                	cmp    $0x21,%al
  100d91:	75 0a                	jne    100d9d <thread_stub+0x13d>
            len = -1;
  100d93:	c7 85 f4 fd ff ff ff 	movl   $0xffffffff,0xfffffdf4(%ebp)
  100d9a:	ff ff ff 
      } while (len > 0);
  100d9d:	8b 85 f4 fd ff ff    	mov    0xfffffdf4(%ebp),%eax
  100da3:	85 c0                	test   %eax,%eax
  100da5:	7f 97                	jg     100d3e <thread_stub+0xde>
      lwip_close(client);
  100da7:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  100daa:	89 04 24             	mov    %eax,(%esp)
  100dad:	e8 ce 74 01 00       	call   118280 <lwip_close>
  100db2:	8d 95 e4 fd ff ff    	lea    0xfffffde4(%ebp),%edx
  100db8:	8d 85 e0 fd ff ff    	lea    0xfffffde0(%ebp),%eax
  100dbe:	89 44 24 08          	mov    %eax,0x8(%esp)
  100dc2:	89 54 24 04          	mov    %edx,0x4(%esp)
  100dc6:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  100dc9:	89 04 24             	mov    %eax,(%esp)
  100dcc:	e8 8f 72 01 00       	call   118060 <lwip_accept>
  100dd1:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  100dd4:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  100dd8:	0f 8f 60 ff ff ff    	jg     100d3e <thread_stub+0xde>
  }
  lwip_close(s);
  100dde:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  100de1:	89 04 24             	mov    %eax,(%esp)
  100de4:	e8 97 74 01 00       	call   118280 <lwip_close>
  in = 0;
  100de9:	c7 05 08 cd 11 00 00 	movl   $0x0,0x11cd08
  100df0:	00 00 00 
}
  100df3:	c9                   	leave  
  100df4:	c3                   	ret    
  100df5:	8d 74 26 00          	lea    0x0(%esi),%esi
  100df9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00100e00 <console_read>:


int
console_read(struct inode *ip, char *dst, int n)
{
  100e00:	55                   	push   %ebp
  100e01:	89 e5                	mov    %esp,%ebp
  100e03:	83 ec 28             	sub    $0x28,%esp
  uint target;
  int c;
  int ret;
//  unsigned char data[100];
  int mark;

//  kproc_start(thread_stub, 0, 0, 0, "[stub thread]");
//  for (c=0; c<10; c++)
//      data[c] = 0xda;
  iunlock(ip);
  100e06:	8b 45 08             	mov    0x8(%ebp),%eax
  100e09:	89 04 24             	mov    %eax,(%esp)
  100e0c:	e8 0f 11 00 00       	call   101f20 <iunlock>
  target = n;
  100e11:	8b 45 10             	mov    0x10(%ebp),%eax
  100e14:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
  acquire(&input.lock);
  100e17:	c7 04 24 20 b1 13 00 	movl   $0x13b120,(%esp)
  100e1e:	e8 1d 4d 00 00       	call   105b40 <acquire>
  while(n > 0){
  100e23:	e9 c2 00 00 00       	jmp    100eea <console_read+0xea>
    while(input.r == input.w){
      if(cp->killed){
  100e28:	e8 93 2a 00 00       	call   1038c0 <cpu>
  100e2d:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  100e34:	8b 40 1c             	mov    0x1c(%eax),%eax
  100e37:	85 c0                	test   %eax,%eax
  100e39:	74 23                	je     100e5e <console_read+0x5e>
        release(&input.lock);
  100e3b:	c7 04 24 20 b1 13 00 	movl   $0x13b120,(%esp)
  100e42:	e8 f9 4e 00 00       	call   105d40 <release>
        ilock(ip);
  100e47:	8b 45 08             	mov    0x8(%ebp),%eax
  100e4a:	89 04 24             	mov    %eax,(%esp)
  100e4d:	e8 6e 0f 00 00       	call   101dc0 <ilock>
        return -1;
  100e52:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  100e59:	e9 b4 00 00 00       	jmp    100f12 <console_read+0x112>
      }
      mark = 0;
  100e5e:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
      sleep(&input.r, &input.lock);
  100e65:	c7 44 24 04 20 b1 13 	movl   $0x13b120,0x4(%esp)
  100e6c:	00 
  100e6d:	c7 04 24 d4 b1 13 00 	movl   $0x13b1d4,(%esp)
  100e74:	e8 17 46 00 00       	call   105490 <sleep>
  100e79:	8b 15 d4 b1 13 00    	mov    0x13b1d4,%edx
  100e7f:	a1 d8 b1 13 00       	mov    0x13b1d8,%eax
  100e84:	39 c2                	cmp    %eax,%edx
  100e86:	74 a0                	je     100e28 <console_read+0x28>
/*      do {
        ret = msleep_spin(&input.r, &input.lock, 1000);
       if (ret)
        {*/
//            if ((mark = lwip_recv(s, data, 
//            sizeof(data), MSG_DONTWAIT)) > 0)
//                cprintf("received from 192.168.1.1:80: %d\n", mark);
/*            if (mark == 0)
            {
                for ( ; mark < 64; mark ++)
                    e100_send(data, sizeof(data));
            }
            int len = e100_receive(data, sizeof(data));
            cprintf("received: %d bytes\n", len);
            int i;
            for (i=0; i<len; i++)
            {
                cprintf("%02x ", data[i]);
                if ((i+1) % 10 == 0)
                    cprintf("\n");
            }
            cprintf("\n");*/
//            kproc_start(thread_stub, (void *)100, 0, 0);
//            cprintf("XXX faster!!\n");
/*        }
      } while (ret);*/
    }
    c = input.buf[input.r++ % INPUT_BUF];
  100e88:	8b 0d d4 b1 13 00    	mov    0x13b1d4,%ecx
  100e8e:	89 c8                	mov    %ecx,%eax
  100e90:	c1 f8 1f             	sar    $0x1f,%eax
  100e93:	89 c2                	mov    %eax,%edx
  100e95:	c1 ea 19             	shr    $0x19,%edx
  100e98:	8d 04 11             	lea    (%ecx,%edx,1),%eax
  100e9b:	83 e0 7f             	and    $0x7f,%eax
  100e9e:	29 d0                	sub    %edx,%eax
  100ea0:	0f b6 80 54 b1 13 00 	movzbl 0x13b154(%eax),%eax
  100ea7:	0f be c0             	movsbl %al,%eax
  100eaa:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  100ead:	8d 41 01             	lea    0x1(%ecx),%eax
  100eb0:	a3 d4 b1 13 00       	mov    %eax,0x13b1d4
    if(c == C('D')){  // EOF
  100eb5:	83 7d f4 04          	cmpl   $0x4,0xfffffff4(%ebp)
  100eb9:	75 17                	jne    100ed2 <console_read+0xd2>
      if(n < target){
  100ebb:	8b 45 10             	mov    0x10(%ebp),%eax
  100ebe:	3b 45 f0             	cmp    0xfffffff0(%ebp),%eax
  100ec1:	73 2d                	jae    100ef0 <console_read+0xf0>
        // Save ^D for next time, to make sure
        // caller gets a 0-byte result.
        input.r--;
  100ec3:	a1 d4 b1 13 00       	mov    0x13b1d4,%eax
  100ec8:	83 e8 01             	sub    $0x1,%eax
  100ecb:	a3 d4 b1 13 00       	mov    %eax,0x13b1d4
      }
      break;
  100ed0:	eb 1e                	jmp    100ef0 <console_read+0xf0>
    }
    *dst++ = c;
  100ed2:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  100ed5:	89 c2                	mov    %eax,%edx
  100ed7:	8b 45 0c             	mov    0xc(%ebp),%eax
  100eda:	88 10                	mov    %dl,(%eax)
  100edc:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
    --n;
  100ee0:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
    if(c == '\n')
  100ee4:	83 7d f4 0a          	cmpl   $0xa,0xfffffff4(%ebp)
  100ee8:	74 06                	je     100ef0 <console_read+0xf0>
  100eea:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  100eee:	7f 89                	jg     100e79 <console_read+0x79>
      break;
  }
  release(&input.lock);
  100ef0:	c7 04 24 20 b1 13 00 	movl   $0x13b120,(%esp)
  100ef7:	e8 44 4e 00 00       	call   105d40 <release>
  ilock(ip);
  100efc:	8b 45 08             	mov    0x8(%ebp),%eax
  100eff:	89 04 24             	mov    %eax,(%esp)
  100f02:	e8 b9 0e 00 00       	call   101dc0 <ilock>

  return target - n;
  100f07:	8b 55 10             	mov    0x10(%ebp),%edx
  100f0a:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  100f0d:	29 d0                	sub    %edx,%eax
  100f0f:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  100f12:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  100f15:	c9                   	leave  
  100f16:	c3                   	ret    
  100f17:	89 f6                	mov    %esi,%esi
  100f19:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00100f20 <console_init>:

void
console_init(void)
{
  100f20:	55                   	push   %ebp
  100f21:	89 e5                	mov    %esp,%ebp
  100f23:	83 ec 08             	sub    $0x8,%esp
  initlock(&console_lock, "console");
  100f26:	c7 44 24 04 3c a3 11 	movl   $0x11a33c,0x4(%esp)
  100f2d:	00 
  100f2e:	c7 04 24 20 cd 11 00 	movl   $0x11cd20,(%esp)
  100f35:	e8 d6 4b 00 00       	call   105b10 <initlock>
  initlock(&input.lock, "console input");
  100f3a:	c7 44 24 04 44 a3 11 	movl   $0x11a344,0x4(%esp)
  100f41:	00 
  100f42:	c7 04 24 20 b1 13 00 	movl   $0x13b120,(%esp)
  100f49:	e8 c2 4b 00 00       	call   105b10 <initlock>

  devsw[CONSOLE].write = console_write;
  100f4e:	c7 05 8c bb 13 00 80 	movl   $0x100a80,0x13bb8c
  100f55:	0a 10 00 
  devsw[CONSOLE].read = console_read;
  100f58:	c7 05 88 bb 13 00 00 	movl   $0x100e00,0x13bb88
  100f5f:	0e 10 00 
  //use_console_lock = 1;

  reg_irq_handler(IRQ_KBD, kbd_intr);
  100f62:	c7 44 24 04 70 37 10 	movl   $0x103770,0x4(%esp)
  100f69:	00 
  100f6a:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  100f71:	e8 1a 32 00 00       	call   104190 <reg_irq_handler>
  pic_enable(IRQ_KBD);
  100f76:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  100f7d:	e8 9e 32 00 00       	call   104220 <pic_enable>
  ioapic_enable(IRQ_KBD, 0);
  100f82:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  100f89:	00 
  100f8a:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  100f91:	e8 da 22 00 00       	call   103270 <ioapic_enable>
}
  100f96:	c9                   	leave  
  100f97:	c3                   	ret    
  100f98:	90                   	nop    
  100f99:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

00100fa0 <printstack>:

void
printstack()
{
  100fa0:	55                   	push   %ebp
  100fa1:	89 e5                	mov    %esp,%ebp
  100fa3:	83 ec 38             	sub    $0x38,%esp
  int i;
  uint ebp;
  uint pcs[10];
  cprintf("Stack trace:\n");
  100fa6:	c7 04 24 52 a3 11 00 	movl   $0x11a352,(%esp)
  100fad:	e8 5e f7 ff ff       	call   100710 <cprintf>
  asm("movl %%ebp, %0" : "=r"(ebp) : );
  100fb2:	89 e8                	mov    %ebp,%eax
  100fb4:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  getcallerpcs((void*)(ebp+8), pcs);
  100fb7:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  100fba:	83 c0 08             	add    $0x8,%eax
  100fbd:	89 c2                	mov    %eax,%edx
  100fbf:	8d 45 d0             	lea    0xffffffd0(%ebp),%eax
  100fc2:	89 44 24 04          	mov    %eax,0x4(%esp)
  100fc6:	89 14 24             	mov    %edx,(%esp)
  100fc9:	e8 42 4e 00 00       	call   105e10 <getcallerpcs>
  for(i=0; i<10; i++)
  100fce:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)
  100fd5:	eb 1b                	jmp    100ff2 <printstack+0x52>
    cprintf("0x%08x ", pcs[i]);
  100fd7:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  100fda:	8b 44 85 d0          	mov    0xffffffd0(%ebp,%eax,4),%eax
  100fde:	89 44 24 04          	mov    %eax,0x4(%esp)
  100fe2:	c7 04 24 60 a3 11 00 	movl   $0x11a360,(%esp)
  100fe9:	e8 22 f7 ff ff       	call   100710 <cprintf>
  100fee:	83 45 f8 01          	addl   $0x1,0xfffffff8(%ebp)
  100ff2:	83 7d f8 09          	cmpl   $0x9,0xfffffff8(%ebp)
  100ff6:	7e df                	jle    100fd7 <printstack+0x37>
  cprintf("\n");
  100ff8:	c7 04 24 68 a3 11 00 	movl   $0x11a368,(%esp)
  100fff:	e8 0c f7 ff ff       	call   100710 <cprintf>
}
  101004:	c9                   	leave  
  101005:	c3                   	ret    
  101006:	8d 76 00             	lea    0x0(%esi),%esi
  101009:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00101010 <panic>:


void
panic(char *s)
{
  101010:	55                   	push   %ebp
  101011:	89 e5                	mov    %esp,%ebp
  101013:	83 ec 38             	sub    $0x38,%esp
  int i;
  uint pcs[10];
  
  __asm __volatile("cli");
  101016:	fa                   	cli    
  use_console_lock = 0;
  101017:	c7 05 04 cd 11 00 00 	movl   $0x0,0x11cd04
  10101e:	00 00 00 
  cprintf("panic (%d): ", cpu());
  101021:	e8 9a 28 00 00       	call   1038c0 <cpu>
  101026:	89 44 24 04          	mov    %eax,0x4(%esp)
  10102a:	c7 04 24 6a a3 11 00 	movl   $0x11a36a,(%esp)
  101031:	e8 da f6 ff ff       	call   100710 <cprintf>
  cprintf(s, 0);
  101036:	8b 45 08             	mov    0x8(%ebp),%eax
  101039:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  101040:	00 
  101041:	89 04 24             	mov    %eax,(%esp)
  101044:	e8 c7 f6 ff ff       	call   100710 <cprintf>
  cprintf("\n", 0);
  101049:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  101050:	00 
  101051:	c7 04 24 68 a3 11 00 	movl   $0x11a368,(%esp)
  101058:	e8 b3 f6 ff ff       	call   100710 <cprintf>
  getcallerpcs(&s, pcs);
  10105d:	8d 45 d4             	lea    0xffffffd4(%ebp),%eax
  101060:	89 44 24 04          	mov    %eax,0x4(%esp)
  101064:	8d 45 08             	lea    0x8(%ebp),%eax
  101067:	89 04 24             	mov    %eax,(%esp)
  10106a:	e8 a1 4d 00 00       	call   105e10 <getcallerpcs>
  for(i=0; i<10; i++)
  10106f:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
  101076:	eb 1b                	jmp    101093 <panic+0x83>
    cprintf(" %p", pcs[i]);
  101078:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10107b:	8b 44 85 d4          	mov    0xffffffd4(%ebp,%eax,4),%eax
  10107f:	89 44 24 04          	mov    %eax,0x4(%esp)
  101083:	c7 04 24 77 a3 11 00 	movl   $0x11a377,(%esp)
  10108a:	e8 81 f6 ff ff       	call   100710 <cprintf>
  10108f:	83 45 fc 01          	addl   $0x1,0xfffffffc(%ebp)
  101093:	83 7d fc 09          	cmpl   $0x9,0xfffffffc(%ebp)
  101097:	7e df                	jle    101078 <panic+0x68>
  panicked = 1; // freeze other CPU
  101099:	c7 05 00 cd 11 00 01 	movl   $0x1,0x11cd00
  1010a0:	00 00 00 
  for(;;)
    ;
  1010a3:	eb fe                	jmp    1010a3 <panic+0x93>
  1010a5:	90                   	nop    
  1010a6:	90                   	nop    
  1010a7:	90                   	nop    
  1010a8:	90                   	nop    
  1010a9:	90                   	nop    
  1010aa:	90                   	nop    
  1010ab:	90                   	nop    
  1010ac:	90                   	nop    
  1010ad:	90                   	nop    
  1010ae:	90                   	nop    
  1010af:	90                   	nop    

001010b0 <exec>:
#include "elf.h"

int
exec(char *path, char **argv)
{
  1010b0:	55                   	push   %ebp
  1010b1:	89 e5                	mov    %esp,%ebp
  1010b3:	53                   	push   %ebx
  1010b4:	81 ec a4 00 00 00    	sub    $0xa4,%esp
  char *mem, *s, *last;
  int i, argc, arglen, len, off;
  uint sz, sp, argp;
  struct elfhdr elf;
  struct inode *ip;
  struct proghdr ph;

  if((ip = namei(path)) == 0)
  1010ba:	8b 45 08             	mov    0x8(%ebp),%eax
  1010bd:	89 04 24             	mov    %eax,(%esp)
  1010c0:	e8 9b 1b 00 00       	call   102c60 <namei>
  1010c5:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  1010c8:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  1010cc:	75 0f                	jne    1010dd <exec+0x2d>
    return -1;
  1010ce:	c7 85 68 ff ff ff ff 	movl   $0xffffffff,0xffffff68(%ebp)
  1010d5:	ff ff ff 
  1010d8:	e9 4e 04 00 00       	jmp    10152b <exec+0x47b>
//  cprintf("XXX exec\n");
  ilock(ip);
  1010dd:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1010e0:	89 04 24             	mov    %eax,(%esp)
  1010e3:	e8 d8 0c 00 00       	call   101dc0 <ilock>

  // Compute memory size of new process.
  mem = 0;
  1010e8:	c7 45 cc 00 00 00 00 	movl   $0x0,0xffffffcc(%ebp)
  sz = 0;
  1010ef:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)

  // Program segments.
  if(readi(ip, (char*)&elf, 0, sizeof(elf)) < sizeof(elf))
  1010f6:	8d 45 98             	lea    0xffffff98(%ebp),%eax
  1010f9:	c7 44 24 0c 34 00 00 	movl   $0x34,0xc(%esp)
  101100:	00 
  101101:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  101108:	00 
  101109:	89 44 24 04          	mov    %eax,0x4(%esp)
  10110d:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  101110:	89 04 24             	mov    %eax,(%esp)
  101113:	e8 b8 13 00 00       	call   1024d0 <readi>
  101118:	83 f8 33             	cmp    $0x33,%eax
  10111b:	0f 86 dd 03 00 00    	jbe    1014fe <exec+0x44e>
    goto bad;
  if(elf.magic != ELF_MAGIC)
  101121:	8b 45 98             	mov    0xffffff98(%ebp),%eax
  101124:	3d 7f 45 4c 46       	cmp    $0x464c457f,%eax
  101129:	0f 85 cf 03 00 00    	jne    1014fe <exec+0x44e>
    goto bad;
  for(i=0, off=elf.phoff; i<elf.phnum; i++, off+=sizeof(ph)){
  10112f:	c7 45 d8 00 00 00 00 	movl   $0x0,0xffffffd8(%ebp)
  101136:	8b 45 b4             	mov    0xffffffb4(%ebp),%eax
  101139:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
  10113c:	eb 59                	jmp    101197 <exec+0xe7>
    if(readi(ip, (char*)&ph, off, sizeof(ph)) != sizeof(ph))
  10113e:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  101141:	8d 95 78 ff ff ff    	lea    0xffffff78(%ebp),%edx
  101147:	c7 44 24 0c 20 00 00 	movl   $0x20,0xc(%esp)
  10114e:	00 
  10114f:	89 44 24 08          	mov    %eax,0x8(%esp)
  101153:	89 54 24 04          	mov    %edx,0x4(%esp)
  101157:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10115a:	89 04 24             	mov    %eax,(%esp)
  10115d:	e8 6e 13 00 00       	call   1024d0 <readi>
  101162:	83 f8 20             	cmp    $0x20,%eax
  101165:	0f 85 93 03 00 00    	jne    1014fe <exec+0x44e>
      goto bad;
    if(ph.type != ELF_PROG_LOAD)
  10116b:	8b 85 78 ff ff ff    	mov    0xffffff78(%ebp),%eax
  101171:	83 f8 01             	cmp    $0x1,%eax
  101174:	75 14                	jne    10118a <exec+0xda>
      continue;
    if(ph.memsz < ph.filesz)
  101176:	8b 55 8c             	mov    0xffffff8c(%ebp),%edx
  101179:	8b 45 88             	mov    0xffffff88(%ebp),%eax
  10117c:	39 c2                	cmp    %eax,%edx
  10117e:	0f 82 7a 03 00 00    	jb     1014fe <exec+0x44e>
      goto bad;
    sz += ph.memsz;
  101184:	8b 45 8c             	mov    0xffffff8c(%ebp),%eax
  101187:	01 45 ec             	add    %eax,0xffffffec(%ebp)
  10118a:	83 45 d8 01          	addl   $0x1,0xffffffd8(%ebp)
  10118e:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  101191:	83 c0 20             	add    $0x20,%eax
  101194:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
  101197:	0f b7 45 c4          	movzwl 0xffffffc4(%ebp),%eax
  10119b:	0f b7 c0             	movzwl %ax,%eax
  10119e:	3b 45 d8             	cmp    0xffffffd8(%ebp),%eax
  1011a1:	7f 9b                	jg     10113e <exec+0x8e>
  }
  
  // Arguments.
  arglen = 0;
  1011a3:	c7 45 e0 00 00 00 00 	movl   $0x0,0xffffffe0(%ebp)
  for(argc=0; argv[argc]; argc++)
  1011aa:	c7 45 dc 00 00 00 00 	movl   $0x0,0xffffffdc(%ebp)
  1011b1:	eb 1d                	jmp    1011d0 <exec+0x120>
    arglen += strlen(argv[argc]) + 1;
  1011b3:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  1011b6:	c1 e0 02             	shl    $0x2,%eax
  1011b9:	03 45 0c             	add    0xc(%ebp),%eax
  1011bc:	8b 00                	mov    (%eax),%eax
  1011be:	89 04 24             	mov    %eax,(%esp)
  1011c1:	e8 7a 4f 00 00       	call   106140 <strlen>
  1011c6:	83 c0 01             	add    $0x1,%eax
  1011c9:	01 45 e0             	add    %eax,0xffffffe0(%ebp)
  1011cc:	83 45 dc 01          	addl   $0x1,0xffffffdc(%ebp)
  1011d0:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  1011d3:	c1 e0 02             	shl    $0x2,%eax
  1011d6:	03 45 0c             	add    0xc(%ebp),%eax
  1011d9:	8b 00                	mov    (%eax),%eax
  1011db:	85 c0                	test   %eax,%eax
  1011dd:	75 d4                	jne    1011b3 <exec+0x103>
  arglen = (arglen+3) & ~3;
  1011df:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  1011e2:	83 c0 03             	add    $0x3,%eax
  1011e5:	83 e0 fc             	and    $0xfffffffc,%eax
  1011e8:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
  sz += arglen + 4*(argc+1);
  1011eb:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  1011ee:	83 c0 01             	add    $0x1,%eax
  1011f1:	c1 e0 02             	shl    $0x2,%eax
  1011f4:	03 45 e0             	add    0xffffffe0(%ebp),%eax
  1011f7:	01 45 ec             	add    %eax,0xffffffec(%ebp)

  // Stack.
  sz += PAGE;
  1011fa:	81 45 ec 00 10 00 00 	addl   $0x1000,0xffffffec(%ebp)
  
  // Allocate program memory.
  sz = (sz+PAGE-1) & ~(PAGE-1);
  101201:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  101204:	05 ff 0f 00 00       	add    $0xfff,%eax
  101209:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  10120e:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  mem = kalloc(sz);
  101211:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  101214:	89 04 24             	mov    %eax,(%esp)
  101217:	e8 84 22 00 00       	call   1034a0 <kalloc>
  10121c:	89 45 cc             	mov    %eax,0xffffffcc(%ebp)
  if(mem == 0)
  10121f:	83 7d cc 00          	cmpl   $0x0,0xffffffcc(%ebp)
  101223:	0f 84 d5 02 00 00    	je     1014fe <exec+0x44e>
    goto bad;
  memset(mem, 0, sz);
  101229:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10122c:	89 44 24 08          	mov    %eax,0x8(%esp)
  101230:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  101237:	00 
  101238:	8b 45 cc             	mov    0xffffffcc(%ebp),%eax
  10123b:	89 04 24             	mov    %eax,(%esp)
  10123e:	e8 bd 4c 00 00       	call   105f00 <memset>

  // Load program into memory.
  for(i=0, off=elf.phoff; i<elf.phnum; i++, off+=sizeof(ph)){
  101243:	c7 45 d8 00 00 00 00 	movl   $0x0,0xffffffd8(%ebp)
  10124a:	8b 45 b4             	mov    0xffffffb4(%ebp),%eax
  10124d:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
  101250:	e9 b5 00 00 00       	jmp    10130a <exec+0x25a>
    if(readi(ip, (char*)&ph, off, sizeof(ph)) != sizeof(ph))
  101255:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  101258:	8d 95 78 ff ff ff    	lea    0xffffff78(%ebp),%edx
  10125e:	c7 44 24 0c 20 00 00 	movl   $0x20,0xc(%esp)
  101265:	00 
  101266:	89 44 24 08          	mov    %eax,0x8(%esp)
  10126a:	89 54 24 04          	mov    %edx,0x4(%esp)
  10126e:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  101271:	89 04 24             	mov    %eax,(%esp)
  101274:	e8 57 12 00 00       	call   1024d0 <readi>
  101279:	83 f8 20             	cmp    $0x20,%eax
  10127c:	0f 85 7c 02 00 00    	jne    1014fe <exec+0x44e>
      goto bad;
    if(ph.type != ELF_PROG_LOAD)
  101282:	8b 85 78 ff ff ff    	mov    0xffffff78(%ebp),%eax
  101288:	83 f8 01             	cmp    $0x1,%eax
  10128b:	75 70                	jne    1012fd <exec+0x24d>
      continue;
    if(ph.va + ph.memsz > sz)
  10128d:	8b 45 80             	mov    0xffffff80(%ebp),%eax
  101290:	8b 55 8c             	mov    0xffffff8c(%ebp),%edx
  101293:	01 d0                	add    %edx,%eax
  101295:	3b 45 ec             	cmp    0xffffffec(%ebp),%eax
  101298:	0f 87 60 02 00 00    	ja     1014fe <exec+0x44e>
      goto bad;
    if(readi(ip, mem + ph.va, ph.offset, ph.filesz) != ph.filesz)
  10129e:	8b 55 88             	mov    0xffffff88(%ebp),%edx
  1012a1:	8b 8d 7c ff ff ff    	mov    0xffffff7c(%ebp),%ecx
  1012a7:	8b 45 80             	mov    0xffffff80(%ebp),%eax
  1012aa:	03 45 cc             	add    0xffffffcc(%ebp),%eax
  1012ad:	89 54 24 0c          	mov    %edx,0xc(%esp)
  1012b1:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  1012b5:	89 44 24 04          	mov    %eax,0x4(%esp)
  1012b9:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1012bc:	89 04 24             	mov    %eax,(%esp)
  1012bf:	e8 0c 12 00 00       	call   1024d0 <readi>
  1012c4:	89 c2                	mov    %eax,%edx
  1012c6:	8b 45 88             	mov    0xffffff88(%ebp),%eax
  1012c9:	39 c2                	cmp    %eax,%edx
  1012cb:	0f 85 2d 02 00 00    	jne    1014fe <exec+0x44e>
      goto bad;
    memset(mem + ph.va + ph.filesz, 0, ph.memsz - ph.filesz);
  1012d1:	8b 55 8c             	mov    0xffffff8c(%ebp),%edx
  1012d4:	8b 45 88             	mov    0xffffff88(%ebp),%eax
  1012d7:	89 d1                	mov    %edx,%ecx
  1012d9:	29 c1                	sub    %eax,%ecx
  1012db:	8b 45 80             	mov    0xffffff80(%ebp),%eax
  1012de:	89 c2                	mov    %eax,%edx
  1012e0:	03 55 cc             	add    0xffffffcc(%ebp),%edx
  1012e3:	8b 45 88             	mov    0xffffff88(%ebp),%eax
  1012e6:	8d 04 02             	lea    (%edx,%eax,1),%eax
  1012e9:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  1012ed:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  1012f4:	00 
  1012f5:	89 04 24             	mov    %eax,(%esp)
  1012f8:	e8 03 4c 00 00       	call   105f00 <memset>
  1012fd:	83 45 d8 01          	addl   $0x1,0xffffffd8(%ebp)
  101301:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  101304:	83 c0 20             	add    $0x20,%eax
  101307:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
  10130a:	0f b7 45 c4          	movzwl 0xffffffc4(%ebp),%eax
  10130e:	0f b7 c0             	movzwl %ax,%eax
  101311:	3b 45 d8             	cmp    0xffffffd8(%ebp),%eax
  101314:	0f 8f 3b ff ff ff    	jg     101255 <exec+0x1a5>
  }
  iunlockput(ip);
  10131a:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10131d:	89 04 24             	mov    %eax,(%esp)
  101320:	e8 4b 0d 00 00       	call   102070 <iunlockput>
  
  // Initialize stack.
  sp = sz;
  101325:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  101328:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
  argp = sz - arglen - 4*(argc+1);
  10132b:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
  10132e:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  101331:	89 c1                	mov    %eax,%ecx
  101333:	29 d1                	sub    %edx,%ecx
  101335:	89 ca                	mov    %ecx,%edx
  101337:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  10133a:	83 c0 01             	add    $0x1,%eax
  10133d:	c1 e0 02             	shl    $0x2,%eax
  101340:	89 d1                	mov    %edx,%ecx
  101342:	29 c1                	sub    %eax,%ecx
  101344:	89 c8                	mov    %ecx,%eax
  101346:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)

  // Copy argv strings and pointers to stack.
  *(uint*)(mem+argp + 4*argc) = 0;  // argv[argc]
  101349:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10134c:	89 c2                	mov    %eax,%edx
  10134e:	03 55 cc             	add    0xffffffcc(%ebp),%edx
  101351:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  101354:	c1 e0 02             	shl    $0x2,%eax
  101357:	8d 04 02             	lea    (%edx,%eax,1),%eax
  10135a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  for(i=argc-1; i>=0; i--){
  101360:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  101363:	83 e8 01             	sub    $0x1,%eax
  101366:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
  101369:	eb 5f                	jmp    1013ca <exec+0x31a>
    len = strlen(argv[i]) + 1;
  10136b:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  10136e:	c1 e0 02             	shl    $0x2,%eax
  101371:	03 45 0c             	add    0xc(%ebp),%eax
  101374:	8b 00                	mov    (%eax),%eax
  101376:	89 04 24             	mov    %eax,(%esp)
  101379:	e8 c2 4d 00 00       	call   106140 <strlen>
  10137e:	83 c0 01             	add    $0x1,%eax
  101381:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
    sp -= len;
  101384:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
  101387:	29 45 f0             	sub    %eax,0xfffffff0(%ebp)
    memmove(mem+sp, argv[i], len);
  10138a:	8b 4d e4             	mov    0xffffffe4(%ebp),%ecx
  10138d:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  101390:	c1 e0 02             	shl    $0x2,%eax
  101393:	03 45 0c             	add    0xc(%ebp),%eax
  101396:	8b 10                	mov    (%eax),%edx
  101398:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10139b:	03 45 cc             	add    0xffffffcc(%ebp),%eax
  10139e:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  1013a2:	89 54 24 04          	mov    %edx,0x4(%esp)
  1013a6:	89 04 24             	mov    %eax,(%esp)
  1013a9:	e8 e2 4b 00 00       	call   105f90 <memmove>
    *(uint*)(mem+argp + 4*i) = sp;  // argv[i]
  1013ae:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  1013b1:	89 c2                	mov    %eax,%edx
  1013b3:	03 55 cc             	add    0xffffffcc(%ebp),%edx
  1013b6:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  1013b9:	c1 e0 02             	shl    $0x2,%eax
  1013bc:	8d 04 02             	lea    (%edx,%eax,1),%eax
  1013bf:	89 c2                	mov    %eax,%edx
  1013c1:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  1013c4:	89 02                	mov    %eax,(%edx)
  1013c6:	83 6d d8 01          	subl   $0x1,0xffffffd8(%ebp)
  1013ca:	83 7d d8 00          	cmpl   $0x0,0xffffffd8(%ebp)
  1013ce:	79 9b                	jns    10136b <exec+0x2bb>
  }

  // Stack frame for main(argc, argv), below arguments.
  sp = argp;
  1013d0:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  1013d3:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
  sp -= 4;
  1013d6:	83 6d f0 04          	subl   $0x4,0xfffffff0(%ebp)
  *(uint*)(mem+sp) = argp;
  1013da:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  1013dd:	03 45 cc             	add    0xffffffcc(%ebp),%eax
  1013e0:	89 c2                	mov    %eax,%edx
  1013e2:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  1013e5:	89 02                	mov    %eax,(%edx)
  sp -= 4;
  1013e7:	83 6d f0 04          	subl   $0x4,0xfffffff0(%ebp)
  *(uint*)(mem+sp) = argc;
  1013eb:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  1013ee:	03 45 cc             	add    0xffffffcc(%ebp),%eax
  1013f1:	89 c2                	mov    %eax,%edx
  1013f3:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  1013f6:	89 02                	mov    %eax,(%edx)
  sp -= 4;
  1013f8:	83 6d f0 04          	subl   $0x4,0xfffffff0(%ebp)
  *(uint*)(mem+sp) = 0xffffffff;   // fake return pc
  1013fc:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  1013ff:	03 45 cc             	add    0xffffffcc(%ebp),%eax
  101402:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)

  // Save program name for debugging.
  for(last=s=path; *s; s++)
  101408:	8b 45 08             	mov    0x8(%ebp),%eax
  10140b:	89 45 d0             	mov    %eax,0xffffffd0(%ebp)
  10140e:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
  101411:	89 45 d4             	mov    %eax,0xffffffd4(%ebp)
  101414:	eb 17                	jmp    10142d <exec+0x37d>
    if(*s == '/')
  101416:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
  101419:	0f b6 00             	movzbl (%eax),%eax
  10141c:	3c 2f                	cmp    $0x2f,%al
  10141e:	75 09                	jne    101429 <exec+0x379>
      last = s+1;
  101420:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
  101423:	83 c0 01             	add    $0x1,%eax
  101426:	89 45 d4             	mov    %eax,0xffffffd4(%ebp)
  101429:	83 45 d0 01          	addl   $0x1,0xffffffd0(%ebp)
  10142d:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
  101430:	0f b6 00             	movzbl (%eax),%eax
  101433:	84 c0                	test   %al,%al
  101435:	75 df                	jne    101416 <exec+0x366>
  safestrcpy(cp->name, last, sizeof(cp->name));
  101437:	e8 84 24 00 00       	call   1038c0 <cpu>
  10143c:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  101443:	8d 90 88 00 00 00    	lea    0x88(%eax),%edx
  101449:	c7 44 24 08 20 00 00 	movl   $0x20,0x8(%esp)
  101450:	00 
  101451:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
  101454:	89 44 24 04          	mov    %eax,0x4(%esp)
  101458:	89 14 24             	mov    %edx,(%esp)
  10145b:	e8 80 4c 00 00       	call   1060e0 <safestrcpy>

  // Commit to the new image.
  kfree(cp->mem, cp->sz);
  101460:	e8 5b 24 00 00       	call   1038c0 <cpu>
  101465:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  10146c:	8b 40 04             	mov    0x4(%eax),%eax
  10146f:	89 c3                	mov    %eax,%ebx
  101471:	e8 4a 24 00 00       	call   1038c0 <cpu>
  101476:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  10147d:	8b 00                	mov    (%eax),%eax
  10147f:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  101483:	89 04 24             	mov    %eax,(%esp)
  101486:	e8 a5 1e 00 00       	call   103330 <kfree>
  cp->mem = mem;
  10148b:	e8 30 24 00 00       	call   1038c0 <cpu>
  101490:	8b 14 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%edx
  101497:	8b 45 cc             	mov    0xffffffcc(%ebp),%eax
  10149a:	89 02                	mov    %eax,(%edx)
  cp->sz = sz;
  10149c:	e8 1f 24 00 00       	call   1038c0 <cpu>
  1014a1:	8b 14 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%edx
  1014a8:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  1014ab:	89 42 04             	mov    %eax,0x4(%edx)
  cp->tf->eip = elf.entry;  // main
  1014ae:	e8 0d 24 00 00       	call   1038c0 <cpu>
  1014b3:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  1014ba:	8b 90 84 00 00 00    	mov    0x84(%eax),%edx
  1014c0:	8b 45 b0             	mov    0xffffffb0(%ebp),%eax
  1014c3:	89 42 30             	mov    %eax,0x30(%edx)
  cp->tf->esp = sp;
  1014c6:	e8 f5 23 00 00       	call   1038c0 <cpu>
  1014cb:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  1014d2:	8b 90 84 00 00 00    	mov    0x84(%eax),%edx
  1014d8:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  1014db:	89 42 3c             	mov    %eax,0x3c(%edx)
  setupsegs(cp);
  1014de:	e8 dd 23 00 00       	call   1038c0 <cpu>
  1014e3:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  1014ea:	89 04 24             	mov    %eax,(%esp)
  1014ed:	e8 ae 34 00 00       	call   1049a0 <setupsegs>
  return 0;
  1014f2:	c7 85 68 ff ff ff 00 	movl   $0x0,0xffffff68(%ebp)
  1014f9:	00 00 00 
  1014fc:	eb 2d                	jmp    10152b <exec+0x47b>

 bad:
  if(mem)
  1014fe:	83 7d cc 00          	cmpl   $0x0,0xffffffcc(%ebp)
  101502:	74 12                	je     101516 <exec+0x466>
    kfree(mem, sz);
  101504:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  101507:	89 44 24 04          	mov    %eax,0x4(%esp)
  10150b:	8b 45 cc             	mov    0xffffffcc(%ebp),%eax
  10150e:	89 04 24             	mov    %eax,(%esp)
  101511:	e8 1a 1e 00 00       	call   103330 <kfree>
  iunlockput(ip);
  101516:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  101519:	89 04 24             	mov    %eax,(%esp)
  10151c:	e8 4f 0b 00 00       	call   102070 <iunlockput>
  return -1;
  101521:	c7 85 68 ff ff ff ff 	movl   $0xffffffff,0xffffff68(%ebp)
  101528:	ff ff ff 
  10152b:	8b 85 68 ff ff ff    	mov    0xffffff68(%ebp),%eax
}
  101531:	81 c4 a4 00 00 00    	add    $0xa4,%esp
  101537:	5b                   	pop    %ebx
  101538:	5d                   	pop    %ebp
  101539:	c3                   	ret    
  10153a:	90                   	nop    
  10153b:	90                   	nop    
  10153c:	90                   	nop    
  10153d:	90                   	nop    
  10153e:	90                   	nop    
  10153f:	90                   	nop    

00101540 <fileinit>:
struct file file[NFILE];

void
fileinit(void)
{
  101540:	55                   	push   %ebp
  101541:	89 e5                	mov    %esp,%ebp
  101543:	83 ec 08             	sub    $0x8,%esp
  initlock(&file_table_lock, "file_table");
  101546:	c7 44 24 04 7b a3 11 	movl   $0x11a37b,0x4(%esp)
  10154d:	00 
  10154e:	c7 04 24 40 bb 13 00 	movl   $0x13bb40,(%esp)
  101555:	e8 b6 45 00 00       	call   105b10 <initlock>
}
  10155a:	c9                   	leave  
  10155b:	c3                   	ret    
  10155c:	8d 74 26 00          	lea    0x0(%esi),%esi

00101560 <filealloc>:

// Allocate a file structure.
struct file*
filealloc(void)
{
  101560:	55                   	push   %ebp
  101561:	89 e5                	mov    %esp,%ebp
  101563:	83 ec 18             	sub    $0x18,%esp
  int i;

  acquire(&file_table_lock);
  101566:	c7 04 24 40 bb 13 00 	movl   $0x13bb40,(%esp)
  10156d:	e8 ce 45 00 00       	call   105b40 <acquire>
  for(i = 0; i < NFILE; i++){
  101572:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
  101579:	eb 68                	jmp    1015e3 <filealloc+0x83>
    if(file[i].type == FD_CLOSED){
  10157b:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  10157e:	89 d0                	mov    %edx,%eax
  101580:	01 c0                	add    %eax,%eax
  101582:	01 d0                	add    %edx,%eax
  101584:	c1 e0 03             	shl    $0x3,%eax
  101587:	8b 80 e0 b1 13 00    	mov    0x13b1e0(%eax),%eax
  10158d:	85 c0                	test   %eax,%eax
  10158f:	75 4e                	jne    1015df <filealloc+0x7f>
      file[i].type = FD_NONE;
  101591:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  101594:	89 d0                	mov    %edx,%eax
  101596:	01 c0                	add    %eax,%eax
  101598:	01 d0                	add    %edx,%eax
  10159a:	c1 e0 03             	shl    $0x3,%eax
  10159d:	c7 80 e0 b1 13 00 01 	movl   $0x1,0x13b1e0(%eax)
  1015a4:	00 00 00 
      file[i].ref = 1;
  1015a7:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  1015aa:	89 d0                	mov    %edx,%eax
  1015ac:	01 c0                	add    %eax,%eax
  1015ae:	01 d0                	add    %edx,%eax
  1015b0:	c1 e0 03             	shl    $0x3,%eax
  1015b3:	c7 80 e4 b1 13 00 01 	movl   $0x1,0x13b1e4(%eax)
  1015ba:	00 00 00 
      release(&file_table_lock);
  1015bd:	c7 04 24 40 bb 13 00 	movl   $0x13bb40,(%esp)
  1015c4:	e8 77 47 00 00       	call   105d40 <release>
      return file + i;
  1015c9:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  1015cc:	89 d0                	mov    %edx,%eax
  1015ce:	01 c0                	add    %eax,%eax
  1015d0:	01 d0                	add    %edx,%eax
  1015d2:	c1 e0 03             	shl    $0x3,%eax
  1015d5:	05 e0 b1 13 00       	add    $0x13b1e0,%eax
  1015da:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  1015dd:	eb 1d                	jmp    1015fc <filealloc+0x9c>
  1015df:	83 45 fc 01          	addl   $0x1,0xfffffffc(%ebp)
  1015e3:	83 7d fc 63          	cmpl   $0x63,0xfffffffc(%ebp)
  1015e7:	7e 92                	jle    10157b <filealloc+0x1b>
    }
  }
  release(&file_table_lock);
  1015e9:	c7 04 24 40 bb 13 00 	movl   $0x13bb40,(%esp)
  1015f0:	e8 4b 47 00 00       	call   105d40 <release>
  return 0;
  1015f5:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  1015fc:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  1015ff:	c9                   	leave  
  101600:	c3                   	ret    
  101601:	eb 0d                	jmp    101610 <filedup>
  101603:	90                   	nop    
  101604:	90                   	nop    
  101605:	90                   	nop    
  101606:	90                   	nop    
  101607:	90                   	nop    
  101608:	90                   	nop    
  101609:	90                   	nop    
  10160a:	90                   	nop    
  10160b:	90                   	nop    
  10160c:	90                   	nop    
  10160d:	90                   	nop    
  10160e:	90                   	nop    
  10160f:	90                   	nop    

00101610 <filedup>:

// Increment ref count for file f.
struct file*
filedup(struct file *f)
{
  101610:	55                   	push   %ebp
  101611:	89 e5                	mov    %esp,%ebp
  101613:	83 ec 08             	sub    $0x8,%esp
  acquire(&file_table_lock);
  101616:	c7 04 24 40 bb 13 00 	movl   $0x13bb40,(%esp)
  10161d:	e8 1e 45 00 00       	call   105b40 <acquire>
  if(f->ref < 1 || f->type == FD_CLOSED)
  101622:	8b 45 08             	mov    0x8(%ebp),%eax
  101625:	8b 40 04             	mov    0x4(%eax),%eax
  101628:	85 c0                	test   %eax,%eax
  10162a:	7e 09                	jle    101635 <filedup+0x25>
  10162c:	8b 45 08             	mov    0x8(%ebp),%eax
  10162f:	8b 00                	mov    (%eax),%eax
  101631:	85 c0                	test   %eax,%eax
  101633:	75 0c                	jne    101641 <filedup+0x31>
    panic("filedup");
  101635:	c7 04 24 86 a3 11 00 	movl   $0x11a386,(%esp)
  10163c:	e8 cf f9 ff ff       	call   101010 <panic>
  f->ref++;
  101641:	8b 45 08             	mov    0x8(%ebp),%eax
  101644:	8b 40 04             	mov    0x4(%eax),%eax
  101647:	8d 50 01             	lea    0x1(%eax),%edx
  10164a:	8b 45 08             	mov    0x8(%ebp),%eax
  10164d:	89 50 04             	mov    %edx,0x4(%eax)
  release(&file_table_lock);
  101650:	c7 04 24 40 bb 13 00 	movl   $0x13bb40,(%esp)
  101657:	e8 e4 46 00 00       	call   105d40 <release>
  return f;
  10165c:	8b 45 08             	mov    0x8(%ebp),%eax
}
  10165f:	c9                   	leave  
  101660:	c3                   	ret    
  101661:	eb 0d                	jmp    101670 <fileclose>
  101663:	90                   	nop    
  101664:	90                   	nop    
  101665:	90                   	nop    
  101666:	90                   	nop    
  101667:	90                   	nop    
  101668:	90                   	nop    
  101669:	90                   	nop    
  10166a:	90                   	nop    
  10166b:	90                   	nop    
  10166c:	90                   	nop    
  10166d:	90                   	nop    
  10166e:	90                   	nop    
  10166f:	90                   	nop    

00101670 <fileclose>:

// Close file f.  (Decrement ref count, close when reaches 0.)
void
fileclose(struct file *f)
{
  101670:	55                   	push   %ebp
  101671:	89 e5                	mov    %esp,%ebp
  101673:	83 ec 38             	sub    $0x38,%esp
  struct file ff;

  acquire(&file_table_lock);
  101676:	c7 04 24 40 bb 13 00 	movl   $0x13bb40,(%esp)
  10167d:	e8 be 44 00 00       	call   105b40 <acquire>
  if(f->ref < 1 || f->type == FD_CLOSED)
  101682:	8b 45 08             	mov    0x8(%ebp),%eax
  101685:	8b 40 04             	mov    0x4(%eax),%eax
  101688:	85 c0                	test   %eax,%eax
  10168a:	7e 09                	jle    101695 <fileclose+0x25>
  10168c:	8b 45 08             	mov    0x8(%ebp),%eax
  10168f:	8b 00                	mov    (%eax),%eax
  101691:	85 c0                	test   %eax,%eax
  101693:	75 2b                	jne    1016c0 <fileclose+0x50>
  {
      cprintf("ref: %d type: %d\n", f->ref, f->type);
  101695:	8b 45 08             	mov    0x8(%ebp),%eax
  101698:	8b 10                	mov    (%eax),%edx
  10169a:	8b 45 08             	mov    0x8(%ebp),%eax
  10169d:	8b 40 04             	mov    0x4(%eax),%eax
  1016a0:	89 54 24 08          	mov    %edx,0x8(%esp)
  1016a4:	89 44 24 04          	mov    %eax,0x4(%esp)
  1016a8:	c7 04 24 8e a3 11 00 	movl   $0x11a38e,(%esp)
  1016af:	e8 5c f0 ff ff       	call   100710 <cprintf>
      panic("fileclose: file closed");
  1016b4:	c7 04 24 a0 a3 11 00 	movl   $0x11a3a0,(%esp)
  1016bb:	e8 50 f9 ff ff       	call   101010 <panic>
  }
  if(--f->ref > 0){
  1016c0:	8b 45 08             	mov    0x8(%ebp),%eax
  1016c3:	8b 40 04             	mov    0x4(%eax),%eax
  1016c6:	8d 50 ff             	lea    0xffffffff(%eax),%edx
  1016c9:	8b 45 08             	mov    0x8(%ebp),%eax
  1016cc:	89 50 04             	mov    %edx,0x4(%eax)
  1016cf:	8b 45 08             	mov    0x8(%ebp),%eax
  1016d2:	8b 40 04             	mov    0x4(%eax),%eax
  1016d5:	85 c0                	test   %eax,%eax
  1016d7:	7e 11                	jle    1016ea <fileclose+0x7a>
    release(&file_table_lock);
  1016d9:	c7 04 24 40 bb 13 00 	movl   $0x13bb40,(%esp)
  1016e0:	e8 5b 46 00 00       	call   105d40 <release>
    return;
  1016e5:	e9 9a 00 00 00       	jmp    101784 <fileclose+0x114>
  }
  ff = *f;
  1016ea:	8b 55 08             	mov    0x8(%ebp),%edx
  1016ed:	8b 02                	mov    (%edx),%eax
  1016ef:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
  1016f2:	8b 42 04             	mov    0x4(%edx),%eax
  1016f5:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  1016f8:	8b 42 08             	mov    0x8(%edx),%eax
  1016fb:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
  1016fe:	8b 42 0c             	mov    0xc(%edx),%eax
  101701:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  101704:	8b 42 10             	mov    0x10(%edx),%eax
  101707:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  10170a:	8b 42 14             	mov    0x14(%edx),%eax
  10170d:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  f->ref = 0;
  101710:	8b 45 08             	mov    0x8(%ebp),%eax
  101713:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  f->type = FD_CLOSED;
  10171a:	8b 45 08             	mov    0x8(%ebp),%eax
  10171d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  release(&file_table_lock);
  101723:	c7 04 24 40 bb 13 00 	movl   $0x13bb40,(%esp)
  10172a:	e8 11 46 00 00       	call   105d40 <release>
  
  if(ff.type == FD_PIPE)
  10172f:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  101732:	83 f8 02             	cmp    $0x2,%eax
  101735:	75 18                	jne    10174f <fileclose+0xdf>
    pipeclose(ff.pipe, ff.writable);
  101737:	0f b6 45 f1          	movzbl 0xfffffff1(%ebp),%eax
  10173b:	0f be c0             	movsbl %al,%eax
  10173e:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
  101741:	89 44 24 04          	mov    %eax,0x4(%esp)
  101745:	89 14 24             	mov    %edx,(%esp)
  101748:	e8 d3 2d 00 00       	call   104520 <pipeclose>
  10174d:	eb 35                	jmp    101784 <fileclose+0x114>
  else if(ff.type == FD_INODE)
  10174f:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  101752:	83 f8 03             	cmp    $0x3,%eax
  101755:	75 0d                	jne    101764 <fileclose+0xf4>
    iput(ff.ip);
  101757:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10175a:	89 04 24             	mov    %eax,(%esp)
  10175d:	e8 2e 08 00 00       	call   101f90 <iput>
  101762:	eb 20                	jmp    101784 <fileclose+0x114>
  else if(ff.type == FD_NONE)
  101764:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  101767:	83 f8 01             	cmp    $0x1,%eax
  10176a:	74 18                	je     101784 <fileclose+0x114>
  {
      // Nothing to do: fd alloc failure
      // Do not need to panic
      //    just because too many files
      //    opened!
  }
  else
  {
      cprintf("type: %d\n");
  10176c:	c7 04 24 b7 a3 11 00 	movl   $0x11a3b7,(%esp)
  101773:	e8 98 ef ff ff       	call   100710 <cprintf>
      panic("fileclose: file type error");
  101778:	c7 04 24 c1 a3 11 00 	movl   $0x11a3c1,(%esp)
  10177f:	e8 8c f8 ff ff       	call   101010 <panic>
  }
}
  101784:	c9                   	leave  
  101785:	c3                   	ret    
  101786:	8d 76 00             	lea    0x0(%esi),%esi
  101789:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00101790 <filestat>:

// Get metadata about file f.
int
filestat(struct file *f, struct stat *st)
{
  101790:	55                   	push   %ebp
  101791:	89 e5                	mov    %esp,%ebp
  101793:	83 ec 18             	sub    $0x18,%esp
  if(f->type == FD_INODE){
  101796:	8b 45 08             	mov    0x8(%ebp),%eax
  101799:	8b 00                	mov    (%eax),%eax
  10179b:	83 f8 03             	cmp    $0x3,%eax
  10179e:	75 3a                	jne    1017da <filestat+0x4a>
    ilock(f->ip);
  1017a0:	8b 45 08             	mov    0x8(%ebp),%eax
  1017a3:	8b 40 10             	mov    0x10(%eax),%eax
  1017a6:	89 04 24             	mov    %eax,(%esp)
  1017a9:	e8 12 06 00 00       	call   101dc0 <ilock>
    stati(f->ip, st);
  1017ae:	8b 45 08             	mov    0x8(%ebp),%eax
  1017b1:	8b 50 10             	mov    0x10(%eax),%edx
  1017b4:	8b 45 0c             	mov    0xc(%ebp),%eax
  1017b7:	89 44 24 04          	mov    %eax,0x4(%esp)
  1017bb:	89 14 24             	mov    %edx,(%esp)
  1017be:	e8 bd 0c 00 00       	call   102480 <stati>
    iunlock(f->ip);
  1017c3:	8b 45 08             	mov    0x8(%ebp),%eax
  1017c6:	8b 40 10             	mov    0x10(%eax),%eax
  1017c9:	89 04 24             	mov    %eax,(%esp)
  1017cc:	e8 4f 07 00 00       	call   101f20 <iunlock>
    return 0;
  1017d1:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
  1017d8:	eb 07                	jmp    1017e1 <filestat+0x51>
  }
  return -1;
  1017da:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,0xfffffffc(%ebp)
  1017e1:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
}
  1017e4:	c9                   	leave  
  1017e5:	c3                   	ret    
  1017e6:	8d 76 00             	lea    0x0(%esi),%esi
  1017e9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

001017f0 <fileread>:

// Read from file f.  Addr is kernel address.
int
fileread(struct file *f, char *addr, int n)
{
  1017f0:	55                   	push   %ebp
  1017f1:	89 e5                	mov    %esp,%ebp
  1017f3:	53                   	push   %ebx
  1017f4:	83 ec 24             	sub    $0x24,%esp
  int r;

  if(f->readable == 0)
  1017f7:	8b 45 08             	mov    0x8(%ebp),%eax
  1017fa:	0f b6 40 08          	movzbl 0x8(%eax),%eax
  1017fe:	84 c0                	test   %al,%al
  101800:	75 0c                	jne    10180e <fileread+0x1e>
    return -1;
  101802:	c7 45 e8 ff ff ff ff 	movl   $0xffffffff,0xffffffe8(%ebp)
  101809:	e9 a5 00 00 00       	jmp    1018b3 <fileread+0xc3>
  if(f->type == FD_PIPE)
  10180e:	8b 45 08             	mov    0x8(%ebp),%eax
  101811:	8b 00                	mov    (%eax),%eax
  101813:	83 f8 02             	cmp    $0x2,%eax
  101816:	75 21                	jne    101839 <fileread+0x49>
    return piperead(f->pipe, addr, n);
  101818:	8b 45 08             	mov    0x8(%ebp),%eax
  10181b:	8b 50 0c             	mov    0xc(%eax),%edx
  10181e:	8b 45 10             	mov    0x10(%ebp),%eax
  101821:	89 44 24 08          	mov    %eax,0x8(%esp)
  101825:	8b 45 0c             	mov    0xc(%ebp),%eax
  101828:	89 44 24 04          	mov    %eax,0x4(%esp)
  10182c:	89 14 24             	mov    %edx,(%esp)
  10182f:	e8 9c 2e 00 00       	call   1046d0 <piperead>
  101834:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
  101837:	eb 7a                	jmp    1018b3 <fileread+0xc3>
  if(f->type == FD_INODE){
  101839:	8b 45 08             	mov    0x8(%ebp),%eax
  10183c:	8b 00                	mov    (%eax),%eax
  10183e:	83 f8 03             	cmp    $0x3,%eax
  101841:	75 64                	jne    1018a7 <fileread+0xb7>
    ilock(f->ip);
  101843:	8b 45 08             	mov    0x8(%ebp),%eax
  101846:	8b 40 10             	mov    0x10(%eax),%eax
  101849:	89 04 24             	mov    %eax,(%esp)
  10184c:	e8 6f 05 00 00       	call   101dc0 <ilock>
    if((r = readi(f->ip, addr, f->off, n)) > 0)
  101851:	8b 55 10             	mov    0x10(%ebp),%edx
  101854:	8b 45 08             	mov    0x8(%ebp),%eax
  101857:	8b 48 14             	mov    0x14(%eax),%ecx
  10185a:	8b 45 08             	mov    0x8(%ebp),%eax
  10185d:	8b 58 10             	mov    0x10(%eax),%ebx
  101860:	89 54 24 0c          	mov    %edx,0xc(%esp)
  101864:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  101868:	8b 45 0c             	mov    0xc(%ebp),%eax
  10186b:	89 44 24 04          	mov    %eax,0x4(%esp)
  10186f:	89 1c 24             	mov    %ebx,(%esp)
  101872:	e8 59 0c 00 00       	call   1024d0 <readi>
  101877:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  10187a:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  10187e:	7e 11                	jle    101891 <fileread+0xa1>
      f->off += r;
  101880:	8b 45 08             	mov    0x8(%ebp),%eax
  101883:	8b 50 14             	mov    0x14(%eax),%edx
  101886:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  101889:	01 c2                	add    %eax,%edx
  10188b:	8b 45 08             	mov    0x8(%ebp),%eax
  10188e:	89 50 14             	mov    %edx,0x14(%eax)
    iunlock(f->ip);
  101891:	8b 45 08             	mov    0x8(%ebp),%eax
  101894:	8b 40 10             	mov    0x10(%eax),%eax
  101897:	89 04 24             	mov    %eax,(%esp)
  10189a:	e8 81 06 00 00       	call   101f20 <iunlock>
    return r;
  10189f:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1018a2:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
  1018a5:	eb 0c                	jmp    1018b3 <fileread+0xc3>
  }
  panic("fileread");
  1018a7:	c7 04 24 dc a3 11 00 	movl   $0x11a3dc,(%esp)
  1018ae:	e8 5d f7 ff ff       	call   101010 <panic>
  1018b3:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
}
  1018b6:	83 c4 24             	add    $0x24,%esp
  1018b9:	5b                   	pop    %ebx
  1018ba:	5d                   	pop    %ebp
  1018bb:	c3                   	ret    
  1018bc:	8d 74 26 00          	lea    0x0(%esi),%esi

001018c0 <filewrite>:

// Write to file f.  Addr is kernel address.
int
filewrite(struct file *f, char *addr, int n)
{
  1018c0:	55                   	push   %ebp
  1018c1:	89 e5                	mov    %esp,%ebp
  1018c3:	53                   	push   %ebx
  1018c4:	83 ec 24             	sub    $0x24,%esp
  int r;

  if(f->writable == 0)
  1018c7:	8b 45 08             	mov    0x8(%ebp),%eax
  1018ca:	0f b6 40 09          	movzbl 0x9(%eax),%eax
  1018ce:	84 c0                	test   %al,%al
  1018d0:	75 0c                	jne    1018de <filewrite+0x1e>
    return -1;
  1018d2:	c7 45 e8 ff ff ff ff 	movl   $0xffffffff,0xffffffe8(%ebp)
  1018d9:	e9 a5 00 00 00       	jmp    101983 <filewrite+0xc3>
  if(f->type == FD_PIPE)
  1018de:	8b 45 08             	mov    0x8(%ebp),%eax
  1018e1:	8b 00                	mov    (%eax),%eax
  1018e3:	83 f8 02             	cmp    $0x2,%eax
  1018e6:	75 21                	jne    101909 <filewrite+0x49>
    return pipewrite(f->pipe, addr, n);
  1018e8:	8b 45 08             	mov    0x8(%ebp),%eax
  1018eb:	8b 50 0c             	mov    0xc(%eax),%edx
  1018ee:	8b 45 10             	mov    0x10(%ebp),%eax
  1018f1:	89 44 24 08          	mov    %eax,0x8(%esp)
  1018f5:	8b 45 0c             	mov    0xc(%ebp),%eax
  1018f8:	89 44 24 04          	mov    %eax,0x4(%esp)
  1018fc:	89 14 24             	mov    %edx,(%esp)
  1018ff:	e8 ac 2c 00 00       	call   1045b0 <pipewrite>
  101904:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
  101907:	eb 7a                	jmp    101983 <filewrite+0xc3>
  if(f->type == FD_INODE){
  101909:	8b 45 08             	mov    0x8(%ebp),%eax
  10190c:	8b 00                	mov    (%eax),%eax
  10190e:	83 f8 03             	cmp    $0x3,%eax
  101911:	75 64                	jne    101977 <filewrite+0xb7>
    ilock(f->ip);
  101913:	8b 45 08             	mov    0x8(%ebp),%eax
  101916:	8b 40 10             	mov    0x10(%eax),%eax
  101919:	89 04 24             	mov    %eax,(%esp)
  10191c:	e8 9f 04 00 00       	call   101dc0 <ilock>
    if((r = writei(f->ip, addr, f->off, n)) > 0)
  101921:	8b 55 10             	mov    0x10(%ebp),%edx
  101924:	8b 45 08             	mov    0x8(%ebp),%eax
  101927:	8b 48 14             	mov    0x14(%eax),%ecx
  10192a:	8b 45 08             	mov    0x8(%ebp),%eax
  10192d:	8b 58 10             	mov    0x10(%eax),%ebx
  101930:	89 54 24 0c          	mov    %edx,0xc(%esp)
  101934:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  101938:	8b 45 0c             	mov    0xc(%ebp),%eax
  10193b:	89 44 24 04          	mov    %eax,0x4(%esp)
  10193f:	89 1c 24             	mov    %ebx,(%esp)
  101942:	e8 19 0d 00 00       	call   102660 <writei>
  101947:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  10194a:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  10194e:	7e 11                	jle    101961 <filewrite+0xa1>
      f->off += r;
  101950:	8b 45 08             	mov    0x8(%ebp),%eax
  101953:	8b 50 14             	mov    0x14(%eax),%edx
  101956:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  101959:	01 c2                	add    %eax,%edx
  10195b:	8b 45 08             	mov    0x8(%ebp),%eax
  10195e:	89 50 14             	mov    %edx,0x14(%eax)
    iunlock(f->ip);
  101961:	8b 45 08             	mov    0x8(%ebp),%eax
  101964:	8b 40 10             	mov    0x10(%eax),%eax
  101967:	89 04 24             	mov    %eax,(%esp)
  10196a:	e8 b1 05 00 00       	call   101f20 <iunlock>
    return r;
  10196f:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  101972:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
  101975:	eb 0c                	jmp    101983 <filewrite+0xc3>
  }
  panic("filewrite");
  101977:	c7 04 24 e5 a3 11 00 	movl   $0x11a3e5,(%esp)
  10197e:	e8 8d f6 ff ff       	call   101010 <panic>
  101983:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
}
  101986:	83 c4 24             	add    $0x24,%esp
  101989:	5b                   	pop    %ebx
  10198a:	5d                   	pop    %ebp
  10198b:	c3                   	ret    
  10198c:	90                   	nop    
  10198d:	90                   	nop    
  10198e:	90                   	nop    
  10198f:	90                   	nop    

00101990 <readsb>:

// Read the super block.
static void
readsb(int dev, struct superblock *sb)
{
  101990:	55                   	push   %ebp
  101991:	89 e5                	mov    %esp,%ebp
  101993:	83 ec 28             	sub    $0x28,%esp
  struct buf *bp;
  
//  cprintf("XXX %s\n",__func__);
  bp = bread(dev, 1);
  101996:	8b 45 08             	mov    0x8(%ebp),%eax
  101999:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  1019a0:	00 
  1019a1:	89 04 24             	mov    %eax,(%esp)
  1019a4:	e8 d7 e7 ff ff       	call   100180 <bread>
  1019a9:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  memmove(sb, bp->data, sizeof(*sb));
  1019ac:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1019af:	83 c0 18             	add    $0x18,%eax
  1019b2:	c7 44 24 08 0c 00 00 	movl   $0xc,0x8(%esp)
  1019b9:	00 
  1019ba:	89 44 24 04          	mov    %eax,0x4(%esp)
  1019be:	8b 45 0c             	mov    0xc(%ebp),%eax
  1019c1:	89 04 24             	mov    %eax,(%esp)
  1019c4:	e8 c7 45 00 00       	call   105f90 <memmove>
  brelse(bp);
  1019c9:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1019cc:	89 04 24             	mov    %eax,(%esp)
  1019cf:	e8 2c e8 ff ff       	call   100200 <brelse>
}
  1019d4:	c9                   	leave  
  1019d5:	c3                   	ret    
  1019d6:	8d 76 00             	lea    0x0(%esi),%esi
  1019d9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

001019e0 <bzero>:

// Zero a block.
static void
bzero(int dev, int bno)
{
  1019e0:	55                   	push   %ebp
  1019e1:	89 e5                	mov    %esp,%ebp
  1019e3:	83 ec 28             	sub    $0x28,%esp
  struct buf *bp;
  
//  cprintf("XXX %s\n",__func__);
  bp = bread(dev, bno);
  1019e6:	8b 45 0c             	mov    0xc(%ebp),%eax
  1019e9:	8b 55 08             	mov    0x8(%ebp),%edx
  1019ec:	89 44 24 04          	mov    %eax,0x4(%esp)
  1019f0:	89 14 24             	mov    %edx,(%esp)
  1019f3:	e8 88 e7 ff ff       	call   100180 <bread>
  1019f8:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  memset(bp->data, 0, BSIZE);
  1019fb:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1019fe:	83 c0 18             	add    $0x18,%eax
  101a01:	c7 44 24 08 00 02 00 	movl   $0x200,0x8(%esp)
  101a08:	00 
  101a09:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  101a10:	00 
  101a11:	89 04 24             	mov    %eax,(%esp)
  101a14:	e8 e7 44 00 00       	call   105f00 <memset>
  bwrite(bp);
  101a19:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  101a1c:	89 04 24             	mov    %eax,(%esp)
  101a1f:	e8 9c e7 ff ff       	call   1001c0 <bwrite>
  brelse(bp);
  101a24:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  101a27:	89 04 24             	mov    %eax,(%esp)
  101a2a:	e8 d1 e7 ff ff       	call   100200 <brelse>
}
  101a2f:	c9                   	leave  
  101a30:	c3                   	ret    
  101a31:	eb 0d                	jmp    101a40 <balloc>
  101a33:	90                   	nop    
  101a34:	90                   	nop    
  101a35:	90                   	nop    
  101a36:	90                   	nop    
  101a37:	90                   	nop    
  101a38:	90                   	nop    
  101a39:	90                   	nop    
  101a3a:	90                   	nop    
  101a3b:	90                   	nop    
  101a3c:	90                   	nop    
  101a3d:	90                   	nop    
  101a3e:	90                   	nop    
  101a3f:	90                   	nop    

00101a40 <balloc>:

// Blocks. 

// Allocate a disk block.
static uint
balloc(uint dev)
{
  101a40:	55                   	push   %ebp
  101a41:	89 e5                	mov    %esp,%ebp
  101a43:	83 ec 38             	sub    $0x38,%esp
  int b, bi, m;
  struct buf *bp;
  struct superblock sb;

//  cprintf("XXX %s\n",__func__);
  bp = 0;
  101a46:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
  readsb(dev, &sb);
  101a4d:	8b 55 08             	mov    0x8(%ebp),%edx
  101a50:	8d 45 e4             	lea    0xffffffe4(%ebp),%eax
  101a53:	89 44 24 04          	mov    %eax,0x4(%esp)
  101a57:	89 14 24             	mov    %edx,(%esp)
  101a5a:	e8 31 ff ff ff       	call   101990 <readsb>
  for(b = 0; b < sb.size; b += BPB){
  101a5f:	c7 45 f0 00 00 00 00 	movl   $0x0,0xfffffff0(%ebp)
  101a66:	e9 f1 00 00 00       	jmp    101b5c <balloc+0x11c>
    bp = bread(dev, BBLOCK(b, sb.ninodes));
  101a6b:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
  101a6e:	89 d0                	mov    %edx,%eax
  101a70:	c1 f8 1f             	sar    $0x1f,%eax
  101a73:	c1 e8 14             	shr    $0x14,%eax
  101a76:	01 d0                	add    %edx,%eax
  101a78:	c1 f8 0c             	sar    $0xc,%eax
  101a7b:	89 c2                	mov    %eax,%edx
  101a7d:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  101a80:	c1 e8 03             	shr    $0x3,%eax
  101a83:	8d 04 02             	lea    (%edx,%eax,1),%eax
  101a86:	83 c0 03             	add    $0x3,%eax
  101a89:	89 44 24 04          	mov    %eax,0x4(%esp)
  101a8d:	8b 45 08             	mov    0x8(%ebp),%eax
  101a90:	89 04 24             	mov    %eax,(%esp)
  101a93:	e8 e8 e6 ff ff       	call   100180 <bread>
  101a98:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
    for(bi = 0; bi < BPB; bi++){
  101a9b:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
  101aa2:	e9 96 00 00 00       	jmp    101b3d <balloc+0xfd>
      m = 1 << (bi % 8);
  101aa7:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
  101aaa:	89 d0                	mov    %edx,%eax
  101aac:	c1 f8 1f             	sar    $0x1f,%eax
  101aaf:	89 c1                	mov    %eax,%ecx
  101ab1:	c1 e9 1d             	shr    $0x1d,%ecx
  101ab4:	8d 04 0a             	lea    (%edx,%ecx,1),%eax
  101ab7:	83 e0 07             	and    $0x7,%eax
  101aba:	29 c8                	sub    %ecx,%eax
  101abc:	89 c1                	mov    %eax,%ecx
  101abe:	b8 01 00 00 00       	mov    $0x1,%eax
  101ac3:	d3 e0                	shl    %cl,%eax
  101ac5:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
      if((bp->data[bi/8] & m) == 0){  // Is block free?
  101ac8:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
  101acb:	89 d0                	mov    %edx,%eax
  101acd:	c1 f8 1f             	sar    $0x1f,%eax
  101ad0:	c1 e8 1d             	shr    $0x1d,%eax
  101ad3:	01 d0                	add    %edx,%eax
  101ad5:	c1 f8 03             	sar    $0x3,%eax
  101ad8:	89 c2                	mov    %eax,%edx
  101ada:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  101add:	0f b6 44 02 18       	movzbl 0x18(%edx,%eax,1),%eax
  101ae2:	0f b6 c0             	movzbl %al,%eax
  101ae5:	23 45 f8             	and    0xfffffff8(%ebp),%eax
  101ae8:	85 c0                	test   %eax,%eax
  101aea:	75 4d                	jne    101b39 <balloc+0xf9>
        bp->data[bi/8] |= m;  // Mark block in use on disk.
  101aec:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
  101aef:	89 d0                	mov    %edx,%eax
  101af1:	c1 f8 1f             	sar    $0x1f,%eax
  101af4:	c1 e8 1d             	shr    $0x1d,%eax
  101af7:	01 d0                	add    %edx,%eax
  101af9:	c1 f8 03             	sar    $0x3,%eax
  101afc:	89 c1                	mov    %eax,%ecx
  101afe:	89 c2                	mov    %eax,%edx
  101b00:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  101b03:	0f b6 44 02 18       	movzbl 0x18(%edx,%eax,1),%eax
  101b08:	89 c2                	mov    %eax,%edx
  101b0a:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  101b0d:	09 d0                	or     %edx,%eax
  101b0f:	89 c2                	mov    %eax,%edx
  101b11:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  101b14:	88 54 01 18          	mov    %dl,0x18(%ecx,%eax,1)
        bwrite(bp);
  101b18:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  101b1b:	89 04 24             	mov    %eax,(%esp)
  101b1e:	e8 9d e6 ff ff       	call   1001c0 <bwrite>
        brelse(bp);
  101b23:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  101b26:	89 04 24             	mov    %eax,(%esp)
  101b29:	e8 d2 e6 ff ff       	call   100200 <brelse>
        return b + bi;
  101b2e:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  101b31:	03 45 f0             	add    0xfffffff0(%ebp),%eax
  101b34:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
  101b37:	eb 3d                	jmp    101b76 <balloc+0x136>
  101b39:	83 45 f4 01          	addl   $0x1,0xfffffff4(%ebp)
  101b3d:	81 7d f4 ff 0f 00 00 	cmpl   $0xfff,0xfffffff4(%ebp)
  101b44:	0f 8e 5d ff ff ff    	jle    101aa7 <balloc+0x67>
      }
    }
    brelse(bp);
  101b4a:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  101b4d:	89 04 24             	mov    %eax,(%esp)
  101b50:	e8 ab e6 ff ff       	call   100200 <brelse>
  101b55:	81 45 f0 00 10 00 00 	addl   $0x1000,0xfffffff0(%ebp)
  101b5c:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
  101b5f:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
  101b62:	39 c2                	cmp    %eax,%edx
  101b64:	0f 82 01 ff ff ff    	jb     101a6b <balloc+0x2b>
  }
  panic("balloc: out of blocks");
  101b6a:	c7 04 24 ef a3 11 00 	movl   $0x11a3ef,(%esp)
  101b71:	e8 9a f4 ff ff       	call   101010 <panic>
}
  101b76:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  101b79:	c9                   	leave  
  101b7a:	c3                   	ret    
  101b7b:	90                   	nop    
  101b7c:	8d 74 26 00          	lea    0x0(%esi),%esi

00101b80 <bfree>:

// Free a disk block.
static void
bfree(int dev, uint b)
{
  101b80:	55                   	push   %ebp
  101b81:	89 e5                	mov    %esp,%ebp
  101b83:	83 ec 28             	sub    $0x28,%esp
  struct buf *bp;
  struct superblock sb;
  int bi, m;

  bzero(dev, b);
  101b86:	8b 45 0c             	mov    0xc(%ebp),%eax
  101b89:	89 44 24 04          	mov    %eax,0x4(%esp)
  101b8d:	8b 45 08             	mov    0x8(%ebp),%eax
  101b90:	89 04 24             	mov    %eax,(%esp)
  101b93:	e8 48 fe ff ff       	call   1019e0 <bzero>

//  cprintf("XXX %s\n",__func__);
  readsb(dev, &sb);
  101b98:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
  101b9b:	89 44 24 04          	mov    %eax,0x4(%esp)
  101b9f:	8b 45 08             	mov    0x8(%ebp),%eax
  101ba2:	89 04 24             	mov    %eax,(%esp)
  101ba5:	e8 e6 fd ff ff       	call   101990 <readsb>
  bp = bread(dev, BBLOCK(b, sb.ninodes));
  101baa:	8b 45 0c             	mov    0xc(%ebp),%eax
  101bad:	89 c2                	mov    %eax,%edx
  101baf:	c1 ea 0c             	shr    $0xc,%edx
  101bb2:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  101bb5:	c1 e8 03             	shr    $0x3,%eax
  101bb8:	8d 04 02             	lea    (%edx,%eax,1),%eax
  101bbb:	83 c0 03             	add    $0x3,%eax
  101bbe:	8b 55 08             	mov    0x8(%ebp),%edx
  101bc1:	89 44 24 04          	mov    %eax,0x4(%esp)
  101bc5:	89 14 24             	mov    %edx,(%esp)
  101bc8:	e8 b3 e5 ff ff       	call   100180 <bread>
  101bcd:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  bi = b % BPB;
  101bd0:	8b 45 0c             	mov    0xc(%ebp),%eax
  101bd3:	25 ff 0f 00 00       	and    $0xfff,%eax
  101bd8:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  m = 1 << (bi % 8);
  101bdb:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  101bde:	89 d0                	mov    %edx,%eax
  101be0:	c1 f8 1f             	sar    $0x1f,%eax
  101be3:	89 c1                	mov    %eax,%ecx
  101be5:	c1 e9 1d             	shr    $0x1d,%ecx
  101be8:	8d 04 0a             	lea    (%edx,%ecx,1),%eax
  101beb:	83 e0 07             	and    $0x7,%eax
  101bee:	29 c8                	sub    %ecx,%eax
  101bf0:	89 c1                	mov    %eax,%ecx
  101bf2:	b8 01 00 00 00       	mov    $0x1,%eax
  101bf7:	d3 e0                	shl    %cl,%eax
  101bf9:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  if((bp->data[bi/8] & m) == 0)
  101bfc:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  101bff:	89 d0                	mov    %edx,%eax
  101c01:	c1 f8 1f             	sar    $0x1f,%eax
  101c04:	c1 e8 1d             	shr    $0x1d,%eax
  101c07:	01 d0                	add    %edx,%eax
  101c09:	c1 f8 03             	sar    $0x3,%eax
  101c0c:	89 c2                	mov    %eax,%edx
  101c0e:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  101c11:	0f b6 44 02 18       	movzbl 0x18(%edx,%eax,1),%eax
  101c16:	0f b6 c0             	movzbl %al,%eax
  101c19:	23 45 fc             	and    0xfffffffc(%ebp),%eax
  101c1c:	85 c0                	test   %eax,%eax
  101c1e:	75 0c                	jne    101c2c <bfree+0xac>
    panic("freeing free block");
  101c20:	c7 04 24 05 a4 11 00 	movl   $0x11a405,(%esp)
  101c27:	e8 e4 f3 ff ff       	call   101010 <panic>
  bp->data[bi/8] &= ~m;  // Mark block free on disk.
  101c2c:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  101c2f:	89 d0                	mov    %edx,%eax
  101c31:	c1 f8 1f             	sar    $0x1f,%eax
  101c34:	c1 e8 1d             	shr    $0x1d,%eax
  101c37:	01 d0                	add    %edx,%eax
  101c39:	c1 f8 03             	sar    $0x3,%eax
  101c3c:	89 c1                	mov    %eax,%ecx
  101c3e:	89 c2                	mov    %eax,%edx
  101c40:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  101c43:	0f b6 44 02 18       	movzbl 0x18(%edx,%eax,1),%eax
  101c48:	89 c2                	mov    %eax,%edx
  101c4a:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  101c4d:	f7 d0                	not    %eax
  101c4f:	21 d0                	and    %edx,%eax
  101c51:	89 c2                	mov    %eax,%edx
  101c53:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  101c56:	88 54 01 18          	mov    %dl,0x18(%ecx,%eax,1)
  bwrite(bp);
  101c5a:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  101c5d:	89 04 24             	mov    %eax,(%esp)
  101c60:	e8 5b e5 ff ff       	call   1001c0 <bwrite>
  brelse(bp);
  101c65:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  101c68:	89 04 24             	mov    %eax,(%esp)
  101c6b:	e8 90 e5 ff ff       	call   100200 <brelse>
}
  101c70:	c9                   	leave  
  101c71:	c3                   	ret    
  101c72:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi
  101c79:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00101c80 <iinit>:

// Inodes.
//
// An inode is a single, unnamed file in the file system.
// The inode disk structure holds metadata (the type, device numbers,
// and data size) along with a list of blocks where the associated
// data can be found.
//
// The inodes are laid out sequentially on disk immediately after
// the superblock.  The kernel keeps a cache of the in-use
// on-disk structures to provide a place for synchronizing access
// to inodes shared between multiple processes.
// 
// ip->ref counts the number of pointer references to this cached
// inode; references are typically kept in struct file and in cp->cwd.
// When ip->ref falls to zero, the inode is no longer cached.
// It is an error to use an inode without holding a reference to it.
//
// Processes are only allowed to read and write inode
// metadata and contents when holding the inode's lock,
// represented by the I_BUSY flag in the in-memory copy.
// Because inode locks are held during disk accesses, 
// they are implemented using a flag rather than with
// spin locks.  Callers are responsible for locking
// inodes before passing them to routines in this file; leaving
// this responsibility with the caller makes it possible for them
// to create arbitrarily-sized atomic operations.
//
// To give maximum control over locking to the callers, 
// the routines in this file that return inode pointers 
// return pointers to *unlocked* inodes.  It is the callers'
// responsibility to lock them before using them.  A non-zero
// ip->ref keeps these unlocked inodes in the cache.

struct {
  struct spinlock lock;
  struct inode inode[NINODE];
} icache;

void
iinit(void)
{
  101c80:	55                   	push   %ebp
  101c81:	89 e5                	mov    %esp,%ebp
  101c83:	83 ec 08             	sub    $0x8,%esp
  initlock(&icache.lock, "icache.lock");
  101c86:	c7 44 24 04 18 a4 11 	movl   $0x11a418,0x4(%esp)
  101c8d:	00 
  101c8e:	c7 04 24 e0 bb 13 00 	movl   $0x13bbe0,(%esp)
  101c95:	e8 76 3e 00 00       	call   105b10 <initlock>
}
  101c9a:	c9                   	leave  
  101c9b:	c3                   	ret    
  101c9c:	8d 74 26 00          	lea    0x0(%esi),%esi

00101ca0 <iget>:

// Find the inode with number inum on device dev
// and return the in-memory copy.
static struct inode*
iget(uint dev, uint inum)
{
  101ca0:	55                   	push   %ebp
  101ca1:	89 e5                	mov    %esp,%ebp
  101ca3:	83 ec 18             	sub    $0x18,%esp
  struct inode *ip, *empty;

  acquire(&icache.lock);
  101ca6:	c7 04 24 e0 bb 13 00 	movl   $0x13bbe0,(%esp)
  101cad:	e8 8e 3e 00 00       	call   105b40 <acquire>

  // Try for cached inode.
  empty = 0;
  101cb2:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
  for(ip = &icache.inode[0]; ip < &icache.inode[NINODE]; ip++){
  101cb9:	c7 45 f8 14 bc 13 00 	movl   $0x13bc14,0xfffffff8(%ebp)
  101cc0:	eb 5c                	jmp    101d1e <iget+0x7e>
    if(ip->ref > 0 && ip->dev == dev && ip->inum == inum){
  101cc2:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  101cc5:	8b 40 08             	mov    0x8(%eax),%eax
  101cc8:	85 c0                	test   %eax,%eax
  101cca:	7e 38                	jle    101d04 <iget+0x64>
  101ccc:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  101ccf:	8b 00                	mov    (%eax),%eax
  101cd1:	3b 45 08             	cmp    0x8(%ebp),%eax
  101cd4:	75 2e                	jne    101d04 <iget+0x64>
  101cd6:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  101cd9:	8b 40 04             	mov    0x4(%eax),%eax
  101cdc:	3b 45 0c             	cmp    0xc(%ebp),%eax
  101cdf:	75 23                	jne    101d04 <iget+0x64>
      ip->ref++;
  101ce1:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  101ce4:	8b 40 08             	mov    0x8(%eax),%eax
  101ce7:	8d 50 01             	lea    0x1(%eax),%edx
  101cea:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  101ced:	89 50 08             	mov    %edx,0x8(%eax)
      release(&icache.lock);
  101cf0:	c7 04 24 e0 bb 13 00 	movl   $0x13bbe0,(%esp)
  101cf7:	e8 44 40 00 00       	call   105d40 <release>
//      cprintf("XXX iget: found in cache\n");
      return ip;
  101cfc:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  101cff:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  101d02:	eb 73                	jmp    101d77 <iget+0xd7>
    }
    if(empty == 0 && ip->ref == 0)    // Remember empty slot.
  101d04:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  101d08:	75 10                	jne    101d1a <iget+0x7a>
  101d0a:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  101d0d:	8b 40 08             	mov    0x8(%eax),%eax
  101d10:	85 c0                	test   %eax,%eax
  101d12:	75 06                	jne    101d1a <iget+0x7a>
      empty = ip;
  101d14:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  101d17:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  101d1a:	83 45 f8 50          	addl   $0x50,0xfffffff8(%ebp)
  101d1e:	b8 b4 cb 13 00       	mov    $0x13cbb4,%eax
  101d23:	39 45 f8             	cmp    %eax,0xfffffff8(%ebp)
  101d26:	72 9a                	jb     101cc2 <iget+0x22>
  }

  // Allocate fresh inode.
  if(empty == 0)
  101d28:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  101d2c:	75 0c                	jne    101d3a <iget+0x9a>
    panic("iget: no inodes");
  101d2e:	c7 04 24 24 a4 11 00 	movl   $0x11a424,(%esp)
  101d35:	e8 d6 f2 ff ff       	call   101010 <panic>

//  cprintf("XXX iget: allocating new\n");
  ip = empty;
  101d3a:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  101d3d:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  ip->dev = dev;
  101d40:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  101d43:	8b 45 08             	mov    0x8(%ebp),%eax
  101d46:	89 02                	mov    %eax,(%edx)
  ip->inum = inum;
  101d48:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  101d4b:	8b 45 0c             	mov    0xc(%ebp),%eax
  101d4e:	89 42 04             	mov    %eax,0x4(%edx)
  ip->ref = 1;
  101d51:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  101d54:	c7 40 08 01 00 00 00 	movl   $0x1,0x8(%eax)
  ip->flags = 0;
  101d5b:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  101d5e:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
  release(&icache.lock);
  101d65:	c7 04 24 e0 bb 13 00 	movl   $0x13bbe0,(%esp)
  101d6c:	e8 cf 3f 00 00       	call   105d40 <release>

  return ip;
  101d71:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  101d74:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  101d77:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  101d7a:	c9                   	leave  
  101d7b:	c3                   	ret    
  101d7c:	8d 74 26 00          	lea    0x0(%esi),%esi

00101d80 <idup>:

// Increment reference count for ip.
// Returns ip to enable ip = idup(ip1) idiom.
struct inode*
idup(struct inode *ip)
{
  101d80:	55                   	push   %ebp
  101d81:	89 e5                	mov    %esp,%ebp
  101d83:	83 ec 08             	sub    $0x8,%esp
  acquire(&icache.lock);
  101d86:	c7 04 24 e0 bb 13 00 	movl   $0x13bbe0,(%esp)
  101d8d:	e8 ae 3d 00 00       	call   105b40 <acquire>
  ip->ref++;
  101d92:	8b 45 08             	mov    0x8(%ebp),%eax
  101d95:	8b 40 08             	mov    0x8(%eax),%eax
  101d98:	8d 50 01             	lea    0x1(%eax),%edx
  101d9b:	8b 45 08             	mov    0x8(%ebp),%eax
  101d9e:	89 50 08             	mov    %edx,0x8(%eax)
  release(&icache.lock);
  101da1:	c7 04 24 e0 bb 13 00 	movl   $0x13bbe0,(%esp)
  101da8:	e8 93 3f 00 00       	call   105d40 <release>
  return ip;
  101dad:	8b 45 08             	mov    0x8(%ebp),%eax
}
  101db0:	c9                   	leave  
  101db1:	c3                   	ret    
  101db2:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi
  101db9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00101dc0 <ilock>:

// Lock the given inode.
void
ilock(struct inode *ip)
{
  101dc0:	55                   	push   %ebp
  101dc1:	89 e5                	mov    %esp,%ebp
  101dc3:	83 ec 28             	sub    $0x28,%esp
  struct buf *bp;
  struct dinode *dip;

  if(ip == 0 || ip->ref < 1)
  101dc6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  101dca:	74 0a                	je     101dd6 <ilock+0x16>
  101dcc:	8b 45 08             	mov    0x8(%ebp),%eax
  101dcf:	8b 40 08             	mov    0x8(%eax),%eax
  101dd2:	85 c0                	test   %eax,%eax
  101dd4:	7f 0c                	jg     101de2 <ilock+0x22>
    panic("ilock");
  101dd6:	c7 04 24 34 a4 11 00 	movl   $0x11a434,(%esp)
  101ddd:	e8 2e f2 ff ff       	call   101010 <panic>

  acquire(&icache.lock);
  101de2:	c7 04 24 e0 bb 13 00 	movl   $0x13bbe0,(%esp)
  101de9:	e8 52 3d 00 00       	call   105b40 <acquire>
  while(ip->flags & I_BUSY)
  101dee:	eb 13                	jmp    101e03 <ilock+0x43>
    sleep(ip, &icache.lock);
  101df0:	c7 44 24 04 e0 bb 13 	movl   $0x13bbe0,0x4(%esp)
  101df7:	00 
  101df8:	8b 45 08             	mov    0x8(%ebp),%eax
  101dfb:	89 04 24             	mov    %eax,(%esp)
  101dfe:	e8 8d 36 00 00       	call   105490 <sleep>
  101e03:	8b 45 08             	mov    0x8(%ebp),%eax
  101e06:	8b 40 0c             	mov    0xc(%eax),%eax
  101e09:	83 e0 01             	and    $0x1,%eax
  101e0c:	84 c0                	test   %al,%al
  101e0e:	75 e0                	jne    101df0 <ilock+0x30>
  ip->flags |= I_BUSY;
  101e10:	8b 45 08             	mov    0x8(%ebp),%eax
  101e13:	8b 40 0c             	mov    0xc(%eax),%eax
  101e16:	89 c2                	mov    %eax,%edx
  101e18:	83 ca 01             	or     $0x1,%edx
  101e1b:	8b 45 08             	mov    0x8(%ebp),%eax
  101e1e:	89 50 0c             	mov    %edx,0xc(%eax)
  release(&icache.lock);
  101e21:	c7 04 24 e0 bb 13 00 	movl   $0x13bbe0,(%esp)
  101e28:	e8 13 3f 00 00       	call   105d40 <release>

  if(!(ip->flags & I_VALID)){
  101e2d:	8b 45 08             	mov    0x8(%ebp),%eax
  101e30:	8b 40 0c             	mov    0xc(%eax),%eax
  101e33:	83 e0 02             	and    $0x2,%eax
  101e36:	85 c0                	test   %eax,%eax
  101e38:	0f 85 d1 00 00 00    	jne    101f0f <ilock+0x14f>
    bp = bread(ip->dev, IBLOCK(ip->inum));
  101e3e:	8b 45 08             	mov    0x8(%ebp),%eax
  101e41:	8b 40 04             	mov    0x4(%eax),%eax
  101e44:	c1 e8 03             	shr    $0x3,%eax
  101e47:	8d 50 02             	lea    0x2(%eax),%edx
  101e4a:	8b 45 08             	mov    0x8(%ebp),%eax
  101e4d:	8b 00                	mov    (%eax),%eax
  101e4f:	89 54 24 04          	mov    %edx,0x4(%esp)
  101e53:	89 04 24             	mov    %eax,(%esp)
  101e56:	e8 25 e3 ff ff       	call   100180 <bread>
  101e5b:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
//  cprintf("XXX %s:after bread \n",__func__);
    dip = (struct dinode*)bp->data + ip->inum%IPB;
  101e5e:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  101e61:	83 c0 18             	add    $0x18,%eax
  101e64:	89 c2                	mov    %eax,%edx
  101e66:	8b 45 08             	mov    0x8(%ebp),%eax
  101e69:	8b 40 04             	mov    0x4(%eax),%eax
  101e6c:	83 e0 07             	and    $0x7,%eax
  101e6f:	c1 e0 06             	shl    $0x6,%eax
  101e72:	8d 04 02             	lea    (%edx,%eax,1),%eax
  101e75:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
    ip->type = dip->type;
  101e78:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  101e7b:	0f b7 10             	movzwl (%eax),%edx
  101e7e:	8b 45 08             	mov    0x8(%ebp),%eax
  101e81:	66 89 50 10          	mov    %dx,0x10(%eax)
    ip->major = dip->major;
  101e85:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  101e88:	0f b7 50 02          	movzwl 0x2(%eax),%edx
  101e8c:	8b 45 08             	mov    0x8(%ebp),%eax
  101e8f:	66 89 50 12          	mov    %dx,0x12(%eax)
    ip->minor = dip->minor;
  101e93:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  101e96:	0f b7 50 04          	movzwl 0x4(%eax),%edx
  101e9a:	8b 45 08             	mov    0x8(%ebp),%eax
  101e9d:	66 89 50 14          	mov    %dx,0x14(%eax)
    ip->nlink = dip->nlink;
  101ea1:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  101ea4:	0f b7 50 06          	movzwl 0x6(%eax),%edx
  101ea8:	8b 45 08             	mov    0x8(%ebp),%eax
  101eab:	66 89 50 16          	mov    %dx,0x16(%eax)
    ip->size = dip->size;
  101eaf:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  101eb2:	8b 50 08             	mov    0x8(%eax),%edx
  101eb5:	8b 45 08             	mov    0x8(%ebp),%eax
  101eb8:	89 50 18             	mov    %edx,0x18(%eax)
    memmove(ip->addrs, dip->addrs, sizeof(ip->addrs));
  101ebb:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  101ebe:	83 c0 0c             	add    $0xc,%eax
  101ec1:	8b 55 08             	mov    0x8(%ebp),%edx
  101ec4:	83 c2 1c             	add    $0x1c,%edx
  101ec7:	c7 44 24 08 34 00 00 	movl   $0x34,0x8(%esp)
  101ece:	00 
  101ecf:	89 44 24 04          	mov    %eax,0x4(%esp)
  101ed3:	89 14 24             	mov    %edx,(%esp)
  101ed6:	e8 b5 40 00 00       	call   105f90 <memmove>
    brelse(bp);
  101edb:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  101ede:	89 04 24             	mov    %eax,(%esp)
  101ee1:	e8 1a e3 ff ff       	call   100200 <brelse>
    ip->flags |= I_VALID;
  101ee6:	8b 45 08             	mov    0x8(%ebp),%eax
  101ee9:	8b 40 0c             	mov    0xc(%eax),%eax
  101eec:	89 c2                	mov    %eax,%edx
  101eee:	83 ca 02             	or     $0x2,%edx
  101ef1:	8b 45 08             	mov    0x8(%ebp),%eax
  101ef4:	89 50 0c             	mov    %edx,0xc(%eax)
    if(ip->type == 0)
  101ef7:	8b 45 08             	mov    0x8(%ebp),%eax
  101efa:	0f b7 40 10          	movzwl 0x10(%eax),%eax
  101efe:	66 85 c0             	test   %ax,%ax
  101f01:	75 0c                	jne    101f0f <ilock+0x14f>
      panic("ilock: no type");
  101f03:	c7 04 24 3a a4 11 00 	movl   $0x11a43a,(%esp)
  101f0a:	e8 01 f1 ff ff       	call   101010 <panic>
  }
}
  101f0f:	c9                   	leave  
  101f10:	c3                   	ret    
  101f11:	eb 0d                	jmp    101f20 <iunlock>
  101f13:	90                   	nop    
  101f14:	90                   	nop    
  101f15:	90                   	nop    
  101f16:	90                   	nop    
  101f17:	90                   	nop    
  101f18:	90                   	nop    
  101f19:	90                   	nop    
  101f1a:	90                   	nop    
  101f1b:	90                   	nop    
  101f1c:	90                   	nop    
  101f1d:	90                   	nop    
  101f1e:	90                   	nop    
  101f1f:	90                   	nop    

00101f20 <iunlock>:

// Unlock the given inode.
void
iunlock(struct inode *ip)
{
  101f20:	55                   	push   %ebp
  101f21:	89 e5                	mov    %esp,%ebp
  101f23:	83 ec 08             	sub    $0x8,%esp
  if(ip == 0 || !(ip->flags & I_BUSY) || ip->ref < 1)
  101f26:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  101f2a:	74 17                	je     101f43 <iunlock+0x23>
  101f2c:	8b 45 08             	mov    0x8(%ebp),%eax
  101f2f:	8b 40 0c             	mov    0xc(%eax),%eax
  101f32:	83 e0 01             	and    $0x1,%eax
  101f35:	85 c0                	test   %eax,%eax
  101f37:	74 0a                	je     101f43 <iunlock+0x23>
  101f39:	8b 45 08             	mov    0x8(%ebp),%eax
  101f3c:	8b 40 08             	mov    0x8(%eax),%eax
  101f3f:	85 c0                	test   %eax,%eax
  101f41:	7f 0c                	jg     101f4f <iunlock+0x2f>
    panic("iunlock");
  101f43:	c7 04 24 49 a4 11 00 	movl   $0x11a449,(%esp)
  101f4a:	e8 c1 f0 ff ff       	call   101010 <panic>

  acquire(&icache.lock);
  101f4f:	c7 04 24 e0 bb 13 00 	movl   $0x13bbe0,(%esp)
  101f56:	e8 e5 3b 00 00       	call   105b40 <acquire>
  ip->flags &= ~I_BUSY;
  101f5b:	8b 45 08             	mov    0x8(%ebp),%eax
  101f5e:	8b 40 0c             	mov    0xc(%eax),%eax
  101f61:	89 c2                	mov    %eax,%edx
  101f63:	83 e2 fe             	and    $0xfffffffe,%edx
  101f66:	8b 45 08             	mov    0x8(%ebp),%eax
  101f69:	89 50 0c             	mov    %edx,0xc(%eax)
  wakeup(ip);
  101f6c:	8b 45 08             	mov    0x8(%ebp),%eax
  101f6f:	89 04 24             	mov    %eax,(%esp)
  101f72:	e8 a9 36 00 00       	call   105620 <wakeup>
  release(&icache.lock);
  101f77:	c7 04 24 e0 bb 13 00 	movl   $0x13bbe0,(%esp)
  101f7e:	e8 bd 3d 00 00       	call   105d40 <release>
}
  101f83:	c9                   	leave  
  101f84:	c3                   	ret    
  101f85:	8d 74 26 00          	lea    0x0(%esi),%esi
  101f89:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00101f90 <iput>:

// Caller holds reference to unlocked ip.  Drop reference.
void
iput(struct inode *ip)
{
  101f90:	55                   	push   %ebp
  101f91:	89 e5                	mov    %esp,%ebp
  101f93:	83 ec 08             	sub    $0x8,%esp
  acquire(&icache.lock);
  101f96:	c7 04 24 e0 bb 13 00 	movl   $0x13bbe0,(%esp)
  101f9d:	e8 9e 3b 00 00       	call   105b40 <acquire>
  if(ip->ref == 1 && (ip->flags & I_VALID) && ip->nlink == 0){
  101fa2:	8b 45 08             	mov    0x8(%ebp),%eax
  101fa5:	8b 40 08             	mov    0x8(%eax),%eax
  101fa8:	83 f8 01             	cmp    $0x1,%eax
  101fab:	0f 85 9a 00 00 00    	jne    10204b <iput+0xbb>
  101fb1:	8b 45 08             	mov    0x8(%ebp),%eax
  101fb4:	8b 40 0c             	mov    0xc(%eax),%eax
  101fb7:	83 e0 02             	and    $0x2,%eax
  101fba:	85 c0                	test   %eax,%eax
  101fbc:	0f 84 89 00 00 00    	je     10204b <iput+0xbb>
  101fc2:	8b 45 08             	mov    0x8(%ebp),%eax
  101fc5:	0f b7 40 16          	movzwl 0x16(%eax),%eax
  101fc9:	66 85 c0             	test   %ax,%ax
  101fcc:	75 7d                	jne    10204b <iput+0xbb>
    // inode is no longer used: truncate and free inode.
    if(ip->flags & I_BUSY)
  101fce:	8b 45 08             	mov    0x8(%ebp),%eax
  101fd1:	8b 40 0c             	mov    0xc(%eax),%eax
  101fd4:	83 e0 01             	and    $0x1,%eax
  101fd7:	84 c0                	test   %al,%al
  101fd9:	74 0c                	je     101fe7 <iput+0x57>
      panic("iput busy");
  101fdb:	c7 04 24 51 a4 11 00 	movl   $0x11a451,(%esp)
  101fe2:	e8 29 f0 ff ff       	call   101010 <panic>
    ip->flags |= I_BUSY;
  101fe7:	8b 45 08             	mov    0x8(%ebp),%eax
  101fea:	8b 40 0c             	mov    0xc(%eax),%eax
  101fed:	89 c2                	mov    %eax,%edx
  101fef:	83 ca 01             	or     $0x1,%edx
  101ff2:	8b 45 08             	mov    0x8(%ebp),%eax
  101ff5:	89 50 0c             	mov    %edx,0xc(%eax)
    release(&icache.lock);
  101ff8:	c7 04 24 e0 bb 13 00 	movl   $0x13bbe0,(%esp)
  101fff:	e8 3c 3d 00 00       	call   105d40 <release>
    itrunc(ip);
  102004:	8b 45 08             	mov    0x8(%ebp),%eax
  102007:	89 04 24             	mov    %eax,(%esp)
  10200a:	e8 81 03 00 00       	call   102390 <itrunc>
    ip->type = 0;
  10200f:	8b 45 08             	mov    0x8(%ebp),%eax
  102012:	66 c7 40 10 00 00    	movw   $0x0,0x10(%eax)
    iupdate(ip);
  102018:	8b 45 08             	mov    0x8(%ebp),%eax
  10201b:	89 04 24             	mov    %eax,(%esp)
  10201e:	e8 5d 01 00 00       	call   102180 <iupdate>
    acquire(&icache.lock);
  102023:	c7 04 24 e0 bb 13 00 	movl   $0x13bbe0,(%esp)
  10202a:	e8 11 3b 00 00       	call   105b40 <acquire>
    ip->flags &= ~I_BUSY;
  10202f:	8b 45 08             	mov    0x8(%ebp),%eax
  102032:	8b 40 0c             	mov    0xc(%eax),%eax
  102035:	89 c2                	mov    %eax,%edx
  102037:	83 e2 fe             	and    $0xfffffffe,%edx
  10203a:	8b 45 08             	mov    0x8(%ebp),%eax
  10203d:	89 50 0c             	mov    %edx,0xc(%eax)
    wakeup(ip);
  102040:	8b 45 08             	mov    0x8(%ebp),%eax
  102043:	89 04 24             	mov    %eax,(%esp)
  102046:	e8 d5 35 00 00       	call   105620 <wakeup>
  }
  ip->ref--;
  10204b:	8b 45 08             	mov    0x8(%ebp),%eax
  10204e:	8b 40 08             	mov    0x8(%eax),%eax
  102051:	8d 50 ff             	lea    0xffffffff(%eax),%edx
  102054:	8b 45 08             	mov    0x8(%ebp),%eax
  102057:	89 50 08             	mov    %edx,0x8(%eax)
  release(&icache.lock);
  10205a:	c7 04 24 e0 bb 13 00 	movl   $0x13bbe0,(%esp)
  102061:	e8 da 3c 00 00       	call   105d40 <release>
}
  102066:	c9                   	leave  
  102067:	c3                   	ret    
  102068:	90                   	nop    
  102069:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

00102070 <iunlockput>:

// Common idiom: unlock, then put.
void
iunlockput(struct inode *ip)
{
  102070:	55                   	push   %ebp
  102071:	89 e5                	mov    %esp,%ebp
  102073:	83 ec 08             	sub    $0x8,%esp
  iunlock(ip);
  102076:	8b 45 08             	mov    0x8(%ebp),%eax
  102079:	89 04 24             	mov    %eax,(%esp)
  10207c:	e8 9f fe ff ff       	call   101f20 <iunlock>
  iput(ip);
  102081:	8b 45 08             	mov    0x8(%ebp),%eax
  102084:	89 04 24             	mov    %eax,(%esp)
  102087:	e8 04 ff ff ff       	call   101f90 <iput>
}
  10208c:	c9                   	leave  
  10208d:	c3                   	ret    
  10208e:	89 f6                	mov    %esi,%esi

00102090 <ialloc>:

// Allocate a new inode with the given type on device dev.
struct inode*
ialloc(uint dev, short type)
{
  102090:	55                   	push   %ebp
  102091:	89 e5                	mov    %esp,%ebp
  102093:	83 ec 38             	sub    $0x38,%esp
  102096:	8b 45 0c             	mov    0xc(%ebp),%eax
  102099:	66 89 45 dc          	mov    %ax,0xffffffdc(%ebp)
  int inum;
  struct buf *bp;
  struct dinode *dip;
  struct superblock sb;

//  cprintf("XXX %s\n",__func__);
  readsb(dev, &sb);
  10209d:	8b 55 08             	mov    0x8(%ebp),%edx
  1020a0:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
  1020a3:	89 44 24 04          	mov    %eax,0x4(%esp)
  1020a7:	89 14 24             	mov    %edx,(%esp)
  1020aa:	e8 e1 f8 ff ff       	call   101990 <readsb>
  for(inum = 1; inum < sb.ninodes; inum++){  // loop over inode blocks
  1020af:	c7 45 f4 01 00 00 00 	movl   $0x1,0xfffffff4(%ebp)
  1020b6:	e9 9e 00 00 00       	jmp    102159 <ialloc+0xc9>
    bp = bread(dev, IBLOCK(inum));
  1020bb:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  1020be:	c1 e8 03             	shr    $0x3,%eax
  1020c1:	83 c0 02             	add    $0x2,%eax
  1020c4:	89 44 24 04          	mov    %eax,0x4(%esp)
  1020c8:	8b 45 08             	mov    0x8(%ebp),%eax
  1020cb:	89 04 24             	mov    %eax,(%esp)
  1020ce:	e8 ad e0 ff ff       	call   100180 <bread>
  1020d3:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
    dip = (struct dinode*)bp->data + inum%IPB;
  1020d6:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1020d9:	83 c0 18             	add    $0x18,%eax
  1020dc:	89 c2                	mov    %eax,%edx
  1020de:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  1020e1:	83 e0 07             	and    $0x7,%eax
  1020e4:	c1 e0 06             	shl    $0x6,%eax
  1020e7:	8d 04 02             	lea    (%edx,%eax,1),%eax
  1020ea:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
    if(dip->type == 0){  // a free inode
  1020ed:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1020f0:	0f b7 00             	movzwl (%eax),%eax
  1020f3:	66 85 c0             	test   %ax,%ax
  1020f6:	75 52                	jne    10214a <ialloc+0xba>
      memset(dip, 0, sizeof(*dip));
  1020f8:	c7 44 24 08 40 00 00 	movl   $0x40,0x8(%esp)
  1020ff:	00 
  102100:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  102107:	00 
  102108:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10210b:	89 04 24             	mov    %eax,(%esp)
  10210e:	e8 ed 3d 00 00       	call   105f00 <memset>
      dip->type = type;
  102113:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  102116:	0f b7 45 dc          	movzwl 0xffffffdc(%ebp),%eax
  10211a:	66 89 02             	mov    %ax,(%edx)
      bwrite(bp);   // mark it allocated on the disk
  10211d:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  102120:	89 04 24             	mov    %eax,(%esp)
  102123:	e8 98 e0 ff ff       	call   1001c0 <bwrite>
      brelse(bp);
  102128:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10212b:	89 04 24             	mov    %eax,(%esp)
  10212e:	e8 cd e0 ff ff       	call   100200 <brelse>
      return iget(dev, inum);
  102133:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  102136:	89 44 24 04          	mov    %eax,0x4(%esp)
  10213a:	8b 45 08             	mov    0x8(%ebp),%eax
  10213d:	89 04 24             	mov    %eax,(%esp)
  102140:	e8 5b fb ff ff       	call   101ca0 <iget>
  102145:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
  102148:	eb 29                	jmp    102173 <ialloc+0xe3>
    }
    brelse(bp);
  10214a:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10214d:	89 04 24             	mov    %eax,(%esp)
  102150:	e8 ab e0 ff ff       	call   100200 <brelse>
  102155:	83 45 f4 01          	addl   $0x1,0xfffffff4(%ebp)
  102159:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
  10215c:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10215f:	39 c2                	cmp    %eax,%edx
  102161:	0f 82 54 ff ff ff    	jb     1020bb <ialloc+0x2b>
  }
  panic("ialloc: no inodes");
  102167:	c7 04 24 5b a4 11 00 	movl   $0x11a45b,(%esp)
  10216e:	e8 9d ee ff ff       	call   101010 <panic>
}
  102173:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  102176:	c9                   	leave  
  102177:	c3                   	ret    
  102178:	90                   	nop    
  102179:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

00102180 <iupdate>:

// Copy inode, which has changed, from memory to disk.
void
iupdate(struct inode *ip)
{
  102180:	55                   	push   %ebp
  102181:	89 e5                	mov    %esp,%ebp
  102183:	83 ec 28             	sub    $0x28,%esp
  struct buf *bp;
  struct dinode *dip;

  bp = bread(ip->dev, IBLOCK(ip->inum));
  102186:	8b 45 08             	mov    0x8(%ebp),%eax
  102189:	8b 40 04             	mov    0x4(%eax),%eax
  10218c:	c1 e8 03             	shr    $0x3,%eax
  10218f:	8d 50 02             	lea    0x2(%eax),%edx
  102192:	8b 45 08             	mov    0x8(%ebp),%eax
  102195:	8b 00                	mov    (%eax),%eax
  102197:	89 54 24 04          	mov    %edx,0x4(%esp)
  10219b:	89 04 24             	mov    %eax,(%esp)
  10219e:	e8 dd df ff ff       	call   100180 <bread>
  1021a3:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  dip = (struct dinode*)bp->data + ip->inum%IPB;
  1021a6:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1021a9:	83 c0 18             	add    $0x18,%eax
  1021ac:	89 c2                	mov    %eax,%edx
  1021ae:	8b 45 08             	mov    0x8(%ebp),%eax
  1021b1:	8b 40 04             	mov    0x4(%eax),%eax
  1021b4:	83 e0 07             	and    $0x7,%eax
  1021b7:	c1 e0 06             	shl    $0x6,%eax
  1021ba:	8d 04 02             	lea    (%edx,%eax,1),%eax
  1021bd:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  dip->type = ip->type;
  1021c0:	8b 45 08             	mov    0x8(%ebp),%eax
  1021c3:	0f b7 50 10          	movzwl 0x10(%eax),%edx
  1021c7:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1021ca:	66 89 10             	mov    %dx,(%eax)
  dip->major = ip->major;
  1021cd:	8b 45 08             	mov    0x8(%ebp),%eax
  1021d0:	0f b7 50 12          	movzwl 0x12(%eax),%edx
  1021d4:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1021d7:	66 89 50 02          	mov    %dx,0x2(%eax)
  dip->minor = ip->minor;
  1021db:	8b 45 08             	mov    0x8(%ebp),%eax
  1021de:	0f b7 50 14          	movzwl 0x14(%eax),%edx
  1021e2:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1021e5:	66 89 50 04          	mov    %dx,0x4(%eax)
  dip->nlink = ip->nlink;
  1021e9:	8b 45 08             	mov    0x8(%ebp),%eax
  1021ec:	0f b7 50 16          	movzwl 0x16(%eax),%edx
  1021f0:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1021f3:	66 89 50 06          	mov    %dx,0x6(%eax)
  dip->size = ip->size;
  1021f7:	8b 45 08             	mov    0x8(%ebp),%eax
  1021fa:	8b 50 18             	mov    0x18(%eax),%edx
  1021fd:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  102200:	89 50 08             	mov    %edx,0x8(%eax)
  memmove(dip->addrs, ip->addrs, sizeof(ip->addrs));
  102203:	8b 45 08             	mov    0x8(%ebp),%eax
  102206:	83 c0 1c             	add    $0x1c,%eax
  102209:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  10220c:	83 c2 0c             	add    $0xc,%edx
  10220f:	c7 44 24 08 34 00 00 	movl   $0x34,0x8(%esp)
  102216:	00 
  102217:	89 44 24 04          	mov    %eax,0x4(%esp)
  10221b:	89 14 24             	mov    %edx,(%esp)
  10221e:	e8 6d 3d 00 00       	call   105f90 <memmove>
  bwrite(bp);
  102223:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  102226:	89 04 24             	mov    %eax,(%esp)
  102229:	e8 92 df ff ff       	call   1001c0 <bwrite>
  brelse(bp);
  10222e:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  102231:	89 04 24             	mov    %eax,(%esp)
  102234:	e8 c7 df ff ff       	call   100200 <brelse>
}
  102239:	c9                   	leave  
  10223a:	c3                   	ret    
  10223b:	90                   	nop    
  10223c:	8d 74 26 00          	lea    0x0(%esi),%esi

00102240 <bmap>:

// Inode contents
//
// The contents (data) associated with each inode is stored
// in a sequence of blocks on the disk.  The first NDIRECT blocks
// are listed in ip->addrs[].  The next NINDIRECT blocks are 
// listed in the block ip->addrs[INDIRECT].

// Return the disk block address of the nth block in inode ip.
// If there is no such block, alloc controls whether one is allocated.
static uint
bmap(struct inode *ip, uint bn, int alloc)
{
  102240:	55                   	push   %ebp
  102241:	89 e5                	mov    %esp,%ebp
  102243:	53                   	push   %ebx
  102244:	83 ec 24             	sub    $0x24,%esp
  uint addr, *a;
  struct buf *bp;

  if(bn < NDIRECT){
  102247:	83 7d 0c 0b          	cmpl   $0xb,0xc(%ebp)
  10224b:	77 4d                	ja     10229a <bmap+0x5a>
    if((addr = ip->addrs[bn]) == 0){
  10224d:	8b 45 0c             	mov    0xc(%ebp),%eax
  102250:	8b 55 08             	mov    0x8(%ebp),%edx
  102253:	8b 44 82 1c          	mov    0x1c(%edx,%eax,4),%eax
  102257:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
  10225a:	83 7d f0 00          	cmpl   $0x0,0xfffffff0(%ebp)
  10225e:	75 2f                	jne    10228f <bmap+0x4f>
      if(!alloc)
  102260:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  102264:	75 0c                	jne    102272 <bmap+0x32>
        return -1;
  102266:	c7 45 e8 ff ff ff ff 	movl   $0xffffffff,0xffffffe8(%ebp)
  10226d:	e9 08 01 00 00       	jmp    10237a <bmap+0x13a>
      ip->addrs[bn] = addr = balloc(ip->dev);
  102272:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  102275:	8b 45 08             	mov    0x8(%ebp),%eax
  102278:	8b 00                	mov    (%eax),%eax
  10227a:	89 04 24             	mov    %eax,(%esp)
  10227d:	e8 be f7 ff ff       	call   101a40 <balloc>
  102282:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
  102285:	8b 55 08             	mov    0x8(%ebp),%edx
  102288:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10228b:	89 44 9a 1c          	mov    %eax,0x1c(%edx,%ebx,4)
    }
    return addr;
  10228f:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  102292:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
  102295:	e9 e0 00 00 00       	jmp    10237a <bmap+0x13a>
  }
  bn -= NDIRECT;
  10229a:	83 6d 0c 0c          	subl   $0xc,0xc(%ebp)

  if(bn < NINDIRECT){
  10229e:	83 7d 0c 7f          	cmpl   $0x7f,0xc(%ebp)
  1022a2:	0f 87 c6 00 00 00    	ja     10236e <bmap+0x12e>
    // Load indirect block, allocating if necessary.
    if((addr = ip->addrs[INDIRECT]) == 0){
  1022a8:	8b 45 08             	mov    0x8(%ebp),%eax
  1022ab:	8b 40 4c             	mov    0x4c(%eax),%eax
  1022ae:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
  1022b1:	83 7d f0 00          	cmpl   $0x0,0xfffffff0(%ebp)
  1022b5:	75 2b                	jne    1022e2 <bmap+0xa2>
      if(!alloc)
  1022b7:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  1022bb:	75 0c                	jne    1022c9 <bmap+0x89>
        return -1;
  1022bd:	c7 45 e8 ff ff ff ff 	movl   $0xffffffff,0xffffffe8(%ebp)
  1022c4:	e9 b1 00 00 00       	jmp    10237a <bmap+0x13a>
      ip->addrs[INDIRECT] = addr = balloc(ip->dev);
  1022c9:	8b 45 08             	mov    0x8(%ebp),%eax
  1022cc:	8b 00                	mov    (%eax),%eax
  1022ce:	89 04 24             	mov    %eax,(%esp)
  1022d1:	e8 6a f7 ff ff       	call   101a40 <balloc>
  1022d6:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
  1022d9:	8b 55 08             	mov    0x8(%ebp),%edx
  1022dc:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  1022df:	89 42 4c             	mov    %eax,0x4c(%edx)
    }
    bp = bread(ip->dev, addr);
  1022e2:	8b 45 08             	mov    0x8(%ebp),%eax
  1022e5:	8b 10                	mov    (%eax),%edx
  1022e7:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  1022ea:	89 44 24 04          	mov    %eax,0x4(%esp)
  1022ee:	89 14 24             	mov    %edx,(%esp)
  1022f1:	e8 8a de ff ff       	call   100180 <bread>
  1022f6:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
    a = (uint*)bp->data;
  1022f9:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1022fc:	83 c0 18             	add    $0x18,%eax
  1022ff:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  
    if((addr = a[bn]) == 0){
  102302:	8b 45 0c             	mov    0xc(%ebp),%eax
  102305:	c1 e0 02             	shl    $0x2,%eax
  102308:	03 45 f4             	add    0xfffffff4(%ebp),%eax
  10230b:	8b 00                	mov    (%eax),%eax
  10230d:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
  102310:	83 7d f0 00          	cmpl   $0x0,0xfffffff0(%ebp)
  102314:	75 45                	jne    10235b <bmap+0x11b>
      if(!alloc){
  102316:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  10231a:	75 14                	jne    102330 <bmap+0xf0>
        brelse(bp);
  10231c:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10231f:	89 04 24             	mov    %eax,(%esp)
  102322:	e8 d9 de ff ff       	call   100200 <brelse>
        return -1;
  102327:	c7 45 e8 ff ff ff ff 	movl   $0xffffffff,0xffffffe8(%ebp)
  10232e:	eb 4a                	jmp    10237a <bmap+0x13a>
      }
      a[bn] = addr = balloc(ip->dev);
  102330:	8b 45 0c             	mov    0xc(%ebp),%eax
  102333:	c1 e0 02             	shl    $0x2,%eax
  102336:	89 c3                	mov    %eax,%ebx
  102338:	03 5d f4             	add    0xfffffff4(%ebp),%ebx
  10233b:	8b 45 08             	mov    0x8(%ebp),%eax
  10233e:	8b 00                	mov    (%eax),%eax
  102340:	89 04 24             	mov    %eax,(%esp)
  102343:	e8 f8 f6 ff ff       	call   101a40 <balloc>
  102348:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
  10234b:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10234e:	89 03                	mov    %eax,(%ebx)
      bwrite(bp);
  102350:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  102353:	89 04 24             	mov    %eax,(%esp)
  102356:	e8 65 de ff ff       	call   1001c0 <bwrite>
    }
    brelse(bp);
  10235b:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10235e:	89 04 24             	mov    %eax,(%esp)
  102361:	e8 9a de ff ff       	call   100200 <brelse>
    return addr;
  102366:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  102369:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
  10236c:	eb 0c                	jmp    10237a <bmap+0x13a>
  }

  panic("bmap: out of range");
  10236e:	c7 04 24 6d a4 11 00 	movl   $0x11a46d,(%esp)
  102375:	e8 96 ec ff ff       	call   101010 <panic>
  10237a:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
}
  10237d:	83 c4 24             	add    $0x24,%esp
  102380:	5b                   	pop    %ebx
  102381:	5d                   	pop    %ebp
  102382:	c3                   	ret    
  102383:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  102389:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00102390 <itrunc>:

// Truncate inode (discard contents).
static void
itrunc(struct inode *ip)
{
  102390:	55                   	push   %ebp
  102391:	89 e5                	mov    %esp,%ebp
  102393:	83 ec 18             	sub    $0x18,%esp
  int i, j;
  struct buf *bp;
  uint *a;

  for(i = 0; i < NDIRECT; i++){
  102396:	c7 45 f0 00 00 00 00 	movl   $0x0,0xfffffff0(%ebp)
  10239d:	eb 3b                	jmp    1023da <itrunc+0x4a>
    if(ip->addrs[i]){
  10239f:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  1023a2:	8b 55 08             	mov    0x8(%ebp),%edx
  1023a5:	8b 44 82 1c          	mov    0x1c(%edx,%eax,4),%eax
  1023a9:	85 c0                	test   %eax,%eax
  1023ab:	74 29                	je     1023d6 <itrunc+0x46>
      bfree(ip->dev, ip->addrs[i]);
  1023ad:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
  1023b0:	8b 45 08             	mov    0x8(%ebp),%eax
  1023b3:	8b 54 90 1c          	mov    0x1c(%eax,%edx,4),%edx
  1023b7:	8b 45 08             	mov    0x8(%ebp),%eax
  1023ba:	8b 00                	mov    (%eax),%eax
  1023bc:	89 54 24 04          	mov    %edx,0x4(%esp)
  1023c0:	89 04 24             	mov    %eax,(%esp)
  1023c3:	e8 b8 f7 ff ff       	call   101b80 <bfree>
      ip->addrs[i] = 0;
  1023c8:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
  1023cb:	8b 45 08             	mov    0x8(%ebp),%eax
  1023ce:	c7 44 90 1c 00 00 00 	movl   $0x0,0x1c(%eax,%edx,4)
  1023d5:	00 
  1023d6:	83 45 f0 01          	addl   $0x1,0xfffffff0(%ebp)
  1023da:	83 7d f0 0b          	cmpl   $0xb,0xfffffff0(%ebp)
  1023de:	7e bf                	jle    10239f <itrunc+0xf>
    }
  }
  
  if(ip->addrs[INDIRECT]){
  1023e0:	8b 45 08             	mov    0x8(%ebp),%eax
  1023e3:	8b 40 4c             	mov    0x4c(%eax),%eax
  1023e6:	85 c0                	test   %eax,%eax
  1023e8:	74 78                	je     102462 <itrunc+0xd2>
    bp = bread(ip->dev, ip->addrs[INDIRECT]);
  1023ea:	8b 45 08             	mov    0x8(%ebp),%eax
  1023ed:	8b 50 4c             	mov    0x4c(%eax),%edx
  1023f0:	8b 45 08             	mov    0x8(%ebp),%eax
  1023f3:	8b 00                	mov    (%eax),%eax
  1023f5:	89 54 24 04          	mov    %edx,0x4(%esp)
  1023f9:	89 04 24             	mov    %eax,(%esp)
  1023fc:	e8 7f dd ff ff       	call   100180 <bread>
  102401:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
    a = (uint*)bp->data;
  102404:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  102407:	83 c0 18             	add    $0x18,%eax
  10240a:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
    for(j = 0; j < NINDIRECT; j++){
  10240d:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
  102414:	eb 2f                	jmp    102445 <itrunc+0xb5>
      if(a[j])
  102416:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  102419:	c1 e0 02             	shl    $0x2,%eax
  10241c:	03 45 fc             	add    0xfffffffc(%ebp),%eax
  10241f:	8b 00                	mov    (%eax),%eax
  102421:	85 c0                	test   %eax,%eax
  102423:	74 1c                	je     102441 <itrunc+0xb1>
        bfree(ip->dev, a[j]);
  102425:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  102428:	c1 e0 02             	shl    $0x2,%eax
  10242b:	03 45 fc             	add    0xfffffffc(%ebp),%eax
  10242e:	8b 10                	mov    (%eax),%edx
  102430:	8b 45 08             	mov    0x8(%ebp),%eax
  102433:	8b 00                	mov    (%eax),%eax
  102435:	89 54 24 04          	mov    %edx,0x4(%esp)
  102439:	89 04 24             	mov    %eax,(%esp)
  10243c:	e8 3f f7 ff ff       	call   101b80 <bfree>
  102441:	83 45 f4 01          	addl   $0x1,0xfffffff4(%ebp)
  102445:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  102448:	83 f8 7f             	cmp    $0x7f,%eax
  10244b:	76 c9                	jbe    102416 <itrunc+0x86>
    }
    brelse(bp);
  10244d:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  102450:	89 04 24             	mov    %eax,(%esp)
  102453:	e8 a8 dd ff ff       	call   100200 <brelse>
    ip->addrs[INDIRECT] = 0;
  102458:	8b 45 08             	mov    0x8(%ebp),%eax
  10245b:	c7 40 4c 00 00 00 00 	movl   $0x0,0x4c(%eax)
  }

  ip->size = 0;
  102462:	8b 45 08             	mov    0x8(%ebp),%eax
  102465:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
  iupdate(ip);
  10246c:	8b 45 08             	mov    0x8(%ebp),%eax
  10246f:	89 04 24             	mov    %eax,(%esp)
  102472:	e8 09 fd ff ff       	call   102180 <iupdate>
}
  102477:	c9                   	leave  
  102478:	c3                   	ret    
  102479:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

00102480 <stati>:

// Copy stat information from inode.
void
stati(struct inode *ip, struct stat *st)
{
  102480:	55                   	push   %ebp
  102481:	89 e5                	mov    %esp,%ebp
  st->dev = ip->dev;
  102483:	8b 45 08             	mov    0x8(%ebp),%eax
  102486:	8b 00                	mov    (%eax),%eax
  102488:	89 c2                	mov    %eax,%edx
  10248a:	8b 45 0c             	mov    0xc(%ebp),%eax
  10248d:	89 10                	mov    %edx,(%eax)
  st->ino = ip->inum;
  10248f:	8b 45 08             	mov    0x8(%ebp),%eax
  102492:	8b 50 04             	mov    0x4(%eax),%edx
  102495:	8b 45 0c             	mov    0xc(%ebp),%eax
  102498:	89 50 04             	mov    %edx,0x4(%eax)
  st->type = ip->type;
  10249b:	8b 45 08             	mov    0x8(%ebp),%eax
  10249e:	0f b7 50 10          	movzwl 0x10(%eax),%edx
  1024a2:	8b 45 0c             	mov    0xc(%ebp),%eax
  1024a5:	66 89 50 08          	mov    %dx,0x8(%eax)
  st->nlink = ip->nlink;
  1024a9:	8b 45 08             	mov    0x8(%ebp),%eax
  1024ac:	0f b7 50 16          	movzwl 0x16(%eax),%edx
  1024b0:	8b 45 0c             	mov    0xc(%ebp),%eax
  1024b3:	66 89 50 0a          	mov    %dx,0xa(%eax)
  st->size = ip->size;
  1024b7:	8b 45 08             	mov    0x8(%ebp),%eax
  1024ba:	8b 50 18             	mov    0x18(%eax),%edx
  1024bd:	8b 45 0c             	mov    0xc(%ebp),%eax
  1024c0:	89 50 0c             	mov    %edx,0xc(%eax)
}
  1024c3:	5d                   	pop    %ebp
  1024c4:	c3                   	ret    
  1024c5:	8d 74 26 00          	lea    0x0(%esi),%esi
  1024c9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

001024d0 <readi>:

// Read data from inode.
int
readi(struct inode *ip, char *dst, uint off, uint n)
{
  1024d0:	55                   	push   %ebp
  1024d1:	89 e5                	mov    %esp,%ebp
  1024d3:	53                   	push   %ebx
  1024d4:	83 ec 34             	sub    $0x34,%esp
  uint tot, m;
  struct buf *bp;

//  cprintf("XXX readi %d.%d\n", ip->dev, ip->inum);
  if(ip->type == T_DEV){
  1024d7:	8b 45 08             	mov    0x8(%ebp),%eax
  1024da:	0f b7 40 10          	movzwl 0x10(%eax),%eax
  1024de:	66 83 f8 03          	cmp    $0x3,%ax
  1024e2:	75 65                	jne    102549 <readi+0x79>
    if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].read)
  1024e4:	8b 45 08             	mov    0x8(%ebp),%eax
  1024e7:	0f b7 40 12          	movzwl 0x12(%eax),%eax
  1024eb:	66 85 c0             	test   %ax,%ax
  1024ee:	78 20                	js     102510 <readi+0x40>
  1024f0:	8b 45 08             	mov    0x8(%ebp),%eax
  1024f3:	0f b7 40 12          	movzwl 0x12(%eax),%eax
  1024f7:	66 83 f8 09          	cmp    $0x9,%ax
  1024fb:	7f 13                	jg     102510 <readi+0x40>
  1024fd:	8b 45 08             	mov    0x8(%ebp),%eax
  102500:	0f b7 40 12          	movzwl 0x12(%eax),%eax
  102504:	98                   	cwtl   
  102505:	8b 04 c5 80 bb 13 00 	mov    0x13bb80(,%eax,8),%eax
  10250c:	85 c0                	test   %eax,%eax
  10250e:	75 0c                	jne    10251c <readi+0x4c>
      return -1;
  102510:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,0xffffffe4(%ebp)
  102517:	e9 37 01 00 00       	jmp    102653 <readi+0x183>
    return devsw[ip->major].read(ip, dst, n);
  10251c:	8b 45 08             	mov    0x8(%ebp),%eax
  10251f:	0f b7 40 12          	movzwl 0x12(%eax),%eax
  102523:	98                   	cwtl   
  102524:	8b 14 c5 80 bb 13 00 	mov    0x13bb80(,%eax,8),%edx
  10252b:	8b 45 14             	mov    0x14(%ebp),%eax
  10252e:	89 44 24 08          	mov    %eax,0x8(%esp)
  102532:	8b 45 0c             	mov    0xc(%ebp),%eax
  102535:	89 44 24 04          	mov    %eax,0x4(%esp)
  102539:	8b 45 08             	mov    0x8(%ebp),%eax
  10253c:	89 04 24             	mov    %eax,(%esp)
  10253f:	ff d2                	call   *%edx
  102541:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
  102544:	e9 0a 01 00 00       	jmp    102653 <readi+0x183>
  }

  if(off > ip->size || off + n < off)
  102549:	8b 45 08             	mov    0x8(%ebp),%eax
  10254c:	8b 40 18             	mov    0x18(%eax),%eax
  10254f:	3b 45 10             	cmp    0x10(%ebp),%eax
  102552:	72 0b                	jb     10255f <readi+0x8f>
  102554:	8b 45 14             	mov    0x14(%ebp),%eax
  102557:	03 45 10             	add    0x10(%ebp),%eax
  10255a:	3b 45 10             	cmp    0x10(%ebp),%eax
  10255d:	73 0c                	jae    10256b <readi+0x9b>
    return -1;
  10255f:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,0xffffffe4(%ebp)
  102566:	e9 e8 00 00 00       	jmp    102653 <readi+0x183>
  if(off + n > ip->size)
  10256b:	8b 45 14             	mov    0x14(%ebp),%eax
  10256e:	8b 55 10             	mov    0x10(%ebp),%edx
  102571:	01 c2                	add    %eax,%edx
  102573:	8b 45 08             	mov    0x8(%ebp),%eax
  102576:	8b 40 18             	mov    0x18(%eax),%eax
  102579:	39 c2                	cmp    %eax,%edx
  10257b:	76 0c                	jbe    102589 <readi+0xb9>
    n = ip->size - off;
  10257d:	8b 45 08             	mov    0x8(%ebp),%eax
  102580:	8b 40 18             	mov    0x18(%eax),%eax
  102583:	2b 45 10             	sub    0x10(%ebp),%eax
  102586:	89 45 14             	mov    %eax,0x14(%ebp)

  for(tot=0; tot<n; tot+=m, off+=m, dst+=m){
  102589:	c7 45 f0 00 00 00 00 	movl   $0x0,0xfffffff0(%ebp)
  102590:	e9 ac 00 00 00       	jmp    102641 <readi+0x171>
    bp = bread(ip->dev, bmap(ip, off/BSIZE, 0));
  102595:	8b 45 10             	mov    0x10(%ebp),%eax
  102598:	c1 e8 09             	shr    $0x9,%eax
  10259b:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  1025a2:	00 
  1025a3:	89 44 24 04          	mov    %eax,0x4(%esp)
  1025a7:	8b 45 08             	mov    0x8(%ebp),%eax
  1025aa:	89 04 24             	mov    %eax,(%esp)
  1025ad:	e8 8e fc ff ff       	call   102240 <bmap>
  1025b2:	89 c2                	mov    %eax,%edx
  1025b4:	8b 45 08             	mov    0x8(%ebp),%eax
  1025b7:	8b 00                	mov    (%eax),%eax
  1025b9:	89 54 24 04          	mov    %edx,0x4(%esp)
  1025bd:	89 04 24             	mov    %eax,(%esp)
  1025c0:	e8 bb db ff ff       	call   100180 <bread>
  1025c5:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
    m = min(n - tot, BSIZE - off%BSIZE);
  1025c8:	8b 55 10             	mov    0x10(%ebp),%edx
  1025cb:	81 e2 ff 01 00 00    	and    $0x1ff,%edx
  1025d1:	b8 00 02 00 00       	mov    $0x200,%eax
  1025d6:	89 c1                	mov    %eax,%ecx
  1025d8:	29 d1                	sub    %edx,%ecx
  1025da:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
  1025dd:	8b 45 14             	mov    0x14(%ebp),%eax
  1025e0:	89 c3                	mov    %eax,%ebx
  1025e2:	29 d3                	sub    %edx,%ebx
  1025e4:	89 5d e8             	mov    %ebx,0xffffffe8(%ebp)
  1025e7:	89 4d e0             	mov    %ecx,0xffffffe0(%ebp)
  1025ea:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  1025ed:	39 45 e0             	cmp    %eax,0xffffffe0(%ebp)
  1025f0:	76 06                	jbe    1025f8 <readi+0x128>
  1025f2:	8b 5d e8             	mov    0xffffffe8(%ebp),%ebx
  1025f5:	89 5d e0             	mov    %ebx,0xffffffe0(%ebp)
  1025f8:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  1025fb:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
    memmove(dst, bp->data + off%BSIZE, m);
  1025fe:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  102601:	83 c2 18             	add    $0x18,%edx
  102604:	8b 45 10             	mov    0x10(%ebp),%eax
  102607:	25 ff 01 00 00       	and    $0x1ff,%eax
  10260c:	01 c2                	add    %eax,%edx
  10260e:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  102611:	89 44 24 08          	mov    %eax,0x8(%esp)
  102615:	89 54 24 04          	mov    %edx,0x4(%esp)
  102619:	8b 45 0c             	mov    0xc(%ebp),%eax
  10261c:	89 04 24             	mov    %eax,(%esp)
  10261f:	e8 6c 39 00 00       	call   105f90 <memmove>
    brelse(bp);
  102624:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  102627:	89 04 24             	mov    %eax,(%esp)
  10262a:	e8 d1 db ff ff       	call   100200 <brelse>
  10262f:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  102632:	01 45 f0             	add    %eax,0xfffffff0(%ebp)
  102635:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  102638:	01 45 10             	add    %eax,0x10(%ebp)
  10263b:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10263e:	01 45 0c             	add    %eax,0xc(%ebp)
  102641:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  102644:	3b 45 14             	cmp    0x14(%ebp),%eax
  102647:	0f 82 48 ff ff ff    	jb     102595 <readi+0xc5>
  }
  return n;
  10264d:	8b 5d 14             	mov    0x14(%ebp),%ebx
  102650:	89 5d e4             	mov    %ebx,0xffffffe4(%ebp)
  102653:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
}
  102656:	83 c4 34             	add    $0x34,%esp
  102659:	5b                   	pop    %ebx
  10265a:	5d                   	pop    %ebp
  10265b:	c3                   	ret    
  10265c:	8d 74 26 00          	lea    0x0(%esi),%esi

00102660 <writei>:

// Write data to inode.
int
writei(struct inode *ip, char *src, uint off, uint n)
{
  102660:	55                   	push   %ebp
  102661:	89 e5                	mov    %esp,%ebp
  102663:	53                   	push   %ebx
  102664:	83 ec 34             	sub    $0x34,%esp
  uint tot, m;
  struct buf *bp;

  if(ip->type == T_DEV){
  102667:	8b 45 08             	mov    0x8(%ebp),%eax
  10266a:	0f b7 40 10          	movzwl 0x10(%eax),%eax
  10266e:	66 83 f8 03          	cmp    $0x3,%ax
  102672:	75 65                	jne    1026d9 <writei+0x79>
    if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].write)
  102674:	8b 45 08             	mov    0x8(%ebp),%eax
  102677:	0f b7 40 12          	movzwl 0x12(%eax),%eax
  10267b:	66 85 c0             	test   %ax,%ax
  10267e:	78 20                	js     1026a0 <writei+0x40>
  102680:	8b 45 08             	mov    0x8(%ebp),%eax
  102683:	0f b7 40 12          	movzwl 0x12(%eax),%eax
  102687:	66 83 f8 09          	cmp    $0x9,%ax
  10268b:	7f 13                	jg     1026a0 <writei+0x40>
  10268d:	8b 45 08             	mov    0x8(%ebp),%eax
  102690:	0f b7 40 12          	movzwl 0x12(%eax),%eax
  102694:	98                   	cwtl   
  102695:	8b 04 c5 84 bb 13 00 	mov    0x13bb84(,%eax,8),%eax
  10269c:	85 c0                	test   %eax,%eax
  10269e:	75 0c                	jne    1026ac <writei+0x4c>
      return -1;
  1026a0:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,0xffffffe4(%ebp)
  1026a7:	e9 56 01 00 00       	jmp    102802 <writei+0x1a2>
    return devsw[ip->major].write(ip, src, n);
  1026ac:	8b 45 08             	mov    0x8(%ebp),%eax
  1026af:	0f b7 40 12          	movzwl 0x12(%eax),%eax
  1026b3:	98                   	cwtl   
  1026b4:	8b 14 c5 84 bb 13 00 	mov    0x13bb84(,%eax,8),%edx
  1026bb:	8b 45 14             	mov    0x14(%ebp),%eax
  1026be:	89 44 24 08          	mov    %eax,0x8(%esp)
  1026c2:	8b 45 0c             	mov    0xc(%ebp),%eax
  1026c5:	89 44 24 04          	mov    %eax,0x4(%esp)
  1026c9:	8b 45 08             	mov    0x8(%ebp),%eax
  1026cc:	89 04 24             	mov    %eax,(%esp)
  1026cf:	ff d2                	call   *%edx
  1026d1:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
  1026d4:	e9 29 01 00 00       	jmp    102802 <writei+0x1a2>
  }

  if(off + n < off)
  1026d9:	8b 45 14             	mov    0x14(%ebp),%eax
  1026dc:	03 45 10             	add    0x10(%ebp),%eax
  1026df:	3b 45 10             	cmp    0x10(%ebp),%eax
  1026e2:	73 0c                	jae    1026f0 <writei+0x90>
    return -1;
  1026e4:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,0xffffffe4(%ebp)
  1026eb:	e9 12 01 00 00       	jmp    102802 <writei+0x1a2>
  if(off + n > MAXFILE*BSIZE)
  1026f0:	8b 45 14             	mov    0x14(%ebp),%eax
  1026f3:	03 45 10             	add    0x10(%ebp),%eax
  1026f6:	3d 00 18 01 00       	cmp    $0x11800,%eax
  1026fb:	76 0b                	jbe    102708 <writei+0xa8>
    n = MAXFILE*BSIZE - off;
  1026fd:	b8 00 18 01 00       	mov    $0x11800,%eax
  102702:	2b 45 10             	sub    0x10(%ebp),%eax
  102705:	89 45 14             	mov    %eax,0x14(%ebp)

  for(tot=0; tot<n; tot+=m, off+=m, src+=m){
  102708:	c7 45 f0 00 00 00 00 	movl   $0x0,0xfffffff0(%ebp)
  10270f:	e9 b7 00 00 00       	jmp    1027cb <writei+0x16b>
    bp = bread(ip->dev, bmap(ip, off/BSIZE, 1));
  102714:	8b 45 10             	mov    0x10(%ebp),%eax
  102717:	c1 e8 09             	shr    $0x9,%eax
  10271a:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  102721:	00 
  102722:	89 44 24 04          	mov    %eax,0x4(%esp)
  102726:	8b 45 08             	mov    0x8(%ebp),%eax
  102729:	89 04 24             	mov    %eax,(%esp)
  10272c:	e8 0f fb ff ff       	call   102240 <bmap>
  102731:	89 c2                	mov    %eax,%edx
  102733:	8b 45 08             	mov    0x8(%ebp),%eax
  102736:	8b 00                	mov    (%eax),%eax
  102738:	89 54 24 04          	mov    %edx,0x4(%esp)
  10273c:	89 04 24             	mov    %eax,(%esp)
  10273f:	e8 3c da ff ff       	call   100180 <bread>
  102744:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
    m = min(n - tot, BSIZE - off%BSIZE);
  102747:	8b 55 10             	mov    0x10(%ebp),%edx
  10274a:	81 e2 ff 01 00 00    	and    $0x1ff,%edx
  102750:	b8 00 02 00 00       	mov    $0x200,%eax
  102755:	89 c1                	mov    %eax,%ecx
  102757:	29 d1                	sub    %edx,%ecx
  102759:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
  10275c:	8b 45 14             	mov    0x14(%ebp),%eax
  10275f:	89 c3                	mov    %eax,%ebx
  102761:	29 d3                	sub    %edx,%ebx
  102763:	89 5d e8             	mov    %ebx,0xffffffe8(%ebp)
  102766:	89 4d e0             	mov    %ecx,0xffffffe0(%ebp)
  102769:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  10276c:	39 45 e0             	cmp    %eax,0xffffffe0(%ebp)
  10276f:	76 06                	jbe    102777 <writei+0x117>
  102771:	8b 5d e8             	mov    0xffffffe8(%ebp),%ebx
  102774:	89 5d e0             	mov    %ebx,0xffffffe0(%ebp)
  102777:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  10277a:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
    memmove(bp->data + off%BSIZE, src, m);
  10277d:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  102780:	83 c2 18             	add    $0x18,%edx
  102783:	8b 45 10             	mov    0x10(%ebp),%eax
  102786:	25 ff 01 00 00       	and    $0x1ff,%eax
  10278b:	01 c2                	add    %eax,%edx
  10278d:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  102790:	89 44 24 08          	mov    %eax,0x8(%esp)
  102794:	8b 45 0c             	mov    0xc(%ebp),%eax
  102797:	89 44 24 04          	mov    %eax,0x4(%esp)
  10279b:	89 14 24             	mov    %edx,(%esp)
  10279e:	e8 ed 37 00 00       	call   105f90 <memmove>
    bwrite(bp);
  1027a3:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1027a6:	89 04 24             	mov    %eax,(%esp)
  1027a9:	e8 12 da ff ff       	call   1001c0 <bwrite>
    brelse(bp);
  1027ae:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1027b1:	89 04 24             	mov    %eax,(%esp)
  1027b4:	e8 47 da ff ff       	call   100200 <brelse>
  1027b9:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  1027bc:	01 45 f0             	add    %eax,0xfffffff0(%ebp)
  1027bf:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  1027c2:	01 45 10             	add    %eax,0x10(%ebp)
  1027c5:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  1027c8:	01 45 0c             	add    %eax,0xc(%ebp)
  1027cb:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  1027ce:	3b 45 14             	cmp    0x14(%ebp),%eax
  1027d1:	0f 82 3d ff ff ff    	jb     102714 <writei+0xb4>
  }

  if(n > 0 && off > ip->size){
  1027d7:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
  1027db:	74 1f                	je     1027fc <writei+0x19c>
  1027dd:	8b 45 08             	mov    0x8(%ebp),%eax
  1027e0:	8b 40 18             	mov    0x18(%eax),%eax
  1027e3:	3b 45 10             	cmp    0x10(%ebp),%eax
  1027e6:	73 14                	jae    1027fc <writei+0x19c>
    ip->size = off;
  1027e8:	8b 45 08             	mov    0x8(%ebp),%eax
  1027eb:	8b 55 10             	mov    0x10(%ebp),%edx
  1027ee:	89 50 18             	mov    %edx,0x18(%eax)
    iupdate(ip);
  1027f1:	8b 45 08             	mov    0x8(%ebp),%eax
  1027f4:	89 04 24             	mov    %eax,(%esp)
  1027f7:	e8 84 f9 ff ff       	call   102180 <iupdate>
  }
  return n;
  1027fc:	8b 5d 14             	mov    0x14(%ebp),%ebx
  1027ff:	89 5d e4             	mov    %ebx,0xffffffe4(%ebp)
  102802:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
}
  102805:	83 c4 34             	add    $0x34,%esp
  102808:	5b                   	pop    %ebx
  102809:	5d                   	pop    %ebp
  10280a:	c3                   	ret    
  10280b:	90                   	nop    
  10280c:	8d 74 26 00          	lea    0x0(%esi),%esi

00102810 <namecmp>:

// Directories

int
namecmp(const char *s, const char *t)
{
  102810:	55                   	push   %ebp
  102811:	89 e5                	mov    %esp,%ebp
  102813:	83 ec 18             	sub    $0x18,%esp
  return strncmp(s, t, DIRSIZ);
  102816:	c7 44 24 08 0e 00 00 	movl   $0xe,0x8(%esp)
  10281d:	00 
  10281e:	8b 45 0c             	mov    0xc(%ebp),%eax
  102821:	89 44 24 04          	mov    %eax,0x4(%esp)
  102825:	8b 45 08             	mov    0x8(%ebp),%eax
  102828:	89 04 24             	mov    %eax,(%esp)
  10282b:	e8 e0 37 00 00       	call   106010 <strncmp>
}
  102830:	c9                   	leave  
  102831:	c3                   	ret    
  102832:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi
  102839:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00102840 <dirlookup>:

// Look for a directory entry in a directory.
// If found, set *poff to byte offset of entry.
// Caller must have already locked dp.
struct inode*
dirlookup(struct inode *dp, char *name, uint *poff)
{
  102840:	55                   	push   %ebp
  102841:	89 e5                	mov    %esp,%ebp
  102843:	83 ec 28             	sub    $0x28,%esp
  uint off, inum;
  struct buf *bp;
  struct dirent *de;

  if(dp->type != T_DIR)
  102846:	8b 45 08             	mov    0x8(%ebp),%eax
  102849:	0f b7 40 10          	movzwl 0x10(%eax),%eax
  10284d:	66 83 f8 01          	cmp    $0x1,%ax
  102851:	74 0c                	je     10285f <dirlookup+0x1f>
    panic("dirlookup not DIR");
  102853:	c7 04 24 80 a4 11 00 	movl   $0x11a480,(%esp)
  10285a:	e8 b1 e7 ff ff       	call   101010 <panic>

  for(off = 0; off < dp->size; off += BSIZE){
  10285f:	c7 45 f0 00 00 00 00 	movl   $0x0,0xfffffff0(%ebp)
  102866:	e9 e0 00 00 00       	jmp    10294b <dirlookup+0x10b>
    bp = bread(dp->dev, bmap(dp, off / BSIZE, 0));
  10286b:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10286e:	c1 e8 09             	shr    $0x9,%eax
  102871:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  102878:	00 
  102879:	89 44 24 04          	mov    %eax,0x4(%esp)
  10287d:	8b 45 08             	mov    0x8(%ebp),%eax
  102880:	89 04 24             	mov    %eax,(%esp)
  102883:	e8 b8 f9 ff ff       	call   102240 <bmap>
  102888:	89 c2                	mov    %eax,%edx
  10288a:	8b 45 08             	mov    0x8(%ebp),%eax
  10288d:	8b 00                	mov    (%eax),%eax
  10288f:	89 54 24 04          	mov    %edx,0x4(%esp)
  102893:	89 04 24             	mov    %eax,(%esp)
  102896:	e8 e5 d8 ff ff       	call   100180 <bread>
  10289b:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
    for(de = (struct dirent*)bp->data;
  10289e:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1028a1:	83 c0 18             	add    $0x18,%eax
  1028a4:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
        de < (struct dirent*)(bp->data + BSIZE);
  1028a7:	eb 7c                	jmp    102925 <dirlookup+0xe5>
        de++){
      if(de->inum == 0)
  1028a9:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1028ac:	0f b7 00             	movzwl (%eax),%eax
  1028af:	66 85 c0             	test   %ax,%ax
  1028b2:	74 6d                	je     102921 <dirlookup+0xe1>
        continue;
      if(namecmp(name, de->name) == 0){
  1028b4:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1028b7:	83 c0 02             	add    $0x2,%eax
  1028ba:	89 44 24 04          	mov    %eax,0x4(%esp)
  1028be:	8b 45 0c             	mov    0xc(%ebp),%eax
  1028c1:	89 04 24             	mov    %eax,(%esp)
  1028c4:	e8 47 ff ff ff       	call   102810 <namecmp>
  1028c9:	85 c0                	test   %eax,%eax
  1028cb:	75 54                	jne    102921 <dirlookup+0xe1>
        // entry matches path element
        if(poff)
  1028cd:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  1028d1:	74 1e                	je     1028f1 <dirlookup+0xb1>
          *poff = off + (uchar*)de - bp->data;
  1028d3:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  1028d6:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  1028d9:	8d 04 02             	lea    (%edx,%eax,1),%eax
  1028dc:	89 c2                	mov    %eax,%edx
  1028de:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1028e1:	83 c0 18             	add    $0x18,%eax
  1028e4:	89 d1                	mov    %edx,%ecx
  1028e6:	29 c1                	sub    %eax,%ecx
  1028e8:	89 c8                	mov    %ecx,%eax
  1028ea:	89 c2                	mov    %eax,%edx
  1028ec:	8b 45 10             	mov    0x10(%ebp),%eax
  1028ef:	89 10                	mov    %edx,(%eax)
        inum = de->inum;
  1028f1:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1028f4:	0f b7 00             	movzwl (%eax),%eax
  1028f7:	0f b7 c0             	movzwl %ax,%eax
  1028fa:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
        brelse(bp);
  1028fd:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  102900:	89 04 24             	mov    %eax,(%esp)
  102903:	e8 f8 d8 ff ff       	call   100200 <brelse>
        return iget(dp->dev, inum);
  102908:	8b 45 08             	mov    0x8(%ebp),%eax
  10290b:	8b 10                	mov    (%eax),%edx
  10290d:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  102910:	89 44 24 04          	mov    %eax,0x4(%esp)
  102914:	89 14 24             	mov    %edx,(%esp)
  102917:	e8 84 f3 ff ff       	call   101ca0 <iget>
  10291c:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  10291f:	eb 40                	jmp    102961 <dirlookup+0x121>
  102921:	83 45 fc 10          	addl   $0x10,0xfffffffc(%ebp)
  102925:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  102928:	83 c0 18             	add    $0x18,%eax
  10292b:	05 00 02 00 00       	add    $0x200,%eax
  102930:	3b 45 fc             	cmp    0xfffffffc(%ebp),%eax
  102933:	0f 87 70 ff ff ff    	ja     1028a9 <dirlookup+0x69>
      }
    }
    brelse(bp);
  102939:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10293c:	89 04 24             	mov    %eax,(%esp)
  10293f:	e8 bc d8 ff ff       	call   100200 <brelse>
  102944:	81 45 f0 00 02 00 00 	addl   $0x200,0xfffffff0(%ebp)
  10294b:	8b 45 08             	mov    0x8(%ebp),%eax
  10294e:	8b 40 18             	mov    0x18(%eax),%eax
  102951:	3b 45 f0             	cmp    0xfffffff0(%ebp),%eax
  102954:	0f 87 11 ff ff ff    	ja     10286b <dirlookup+0x2b>
  }
  return 0;
  10295a:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  102961:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  102964:	c9                   	leave  
  102965:	c3                   	ret    
  102966:	8d 76 00             	lea    0x0(%esi),%esi
  102969:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00102970 <dirlink>:

// Write a new directory entry (name, ino) into the directory dp.
int
dirlink(struct inode *dp, char *name, uint ino)
{
  102970:	55                   	push   %ebp
  102971:	89 e5                	mov    %esp,%ebp
  102973:	83 ec 38             	sub    $0x38,%esp
  int off;
  struct dirent de;
  struct inode *ip;

  // Check that name is not present.
  if((ip = dirlookup(dp, name, 0)) != 0){
  102976:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  10297d:	00 
  10297e:	8b 45 0c             	mov    0xc(%ebp),%eax
  102981:	89 44 24 04          	mov    %eax,0x4(%esp)
  102985:	8b 45 08             	mov    0x8(%ebp),%eax
  102988:	89 04 24             	mov    %eax,(%esp)
  10298b:	e8 b0 fe ff ff       	call   102840 <dirlookup>
  102990:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  102993:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  102997:	74 17                	je     1029b0 <dirlink+0x40>
    iput(ip);
  102999:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10299c:	89 04 24             	mov    %eax,(%esp)
  10299f:	e8 ec f5 ff ff       	call   101f90 <iput>
    return -1;
  1029a4:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,0xffffffdc(%ebp)
  1029ab:	e9 b7 00 00 00       	jmp    102a67 <dirlink+0xf7>
  }

  // Look for an empty dirent.
  for(off = 0; off < dp->size; off += sizeof(de)){
  1029b0:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)
  1029b7:	eb 44                	jmp    1029fd <dirlink+0x8d>
    if(readi(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
  1029b9:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1029bc:	8d 55 e8             	lea    0xffffffe8(%ebp),%edx
  1029bf:	c7 44 24 0c 10 00 00 	movl   $0x10,0xc(%esp)
  1029c6:	00 
  1029c7:	89 44 24 08          	mov    %eax,0x8(%esp)
  1029cb:	89 54 24 04          	mov    %edx,0x4(%esp)
  1029cf:	8b 45 08             	mov    0x8(%ebp),%eax
  1029d2:	89 04 24             	mov    %eax,(%esp)
  1029d5:	e8 f6 fa ff ff       	call   1024d0 <readi>
  1029da:	83 f8 10             	cmp    $0x10,%eax
  1029dd:	74 0c                	je     1029eb <dirlink+0x7b>
      panic("dirlink read");
  1029df:	c7 04 24 92 a4 11 00 	movl   $0x11a492,(%esp)
  1029e6:	e8 25 e6 ff ff       	call   101010 <panic>
    if(de.inum == 0)
  1029eb:	0f b7 45 e8          	movzwl 0xffffffe8(%ebp),%eax
  1029ef:	66 85 c0             	test   %ax,%ax
  1029f2:	74 16                	je     102a0a <dirlink+0x9a>
  1029f4:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1029f7:	83 c0 10             	add    $0x10,%eax
  1029fa:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  1029fd:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  102a00:	8b 55 08             	mov    0x8(%ebp),%edx
  102a03:	8b 52 18             	mov    0x18(%edx),%edx
  102a06:	39 d0                	cmp    %edx,%eax
  102a08:	72 af                	jb     1029b9 <dirlink+0x49>
      break;
  }

  strncpy(de.name, name, DIRSIZ);
  102a0a:	c7 44 24 08 0e 00 00 	movl   $0xe,0x8(%esp)
  102a11:	00 
  102a12:	8b 45 0c             	mov    0xc(%ebp),%eax
  102a15:	89 44 24 04          	mov    %eax,0x4(%esp)
  102a19:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
  102a1c:	83 c0 02             	add    $0x2,%eax
  102a1f:	89 04 24             	mov    %eax,(%esp)
  102a22:	e8 59 36 00 00       	call   106080 <strncpy>
  de.inum = ino;
  102a27:	8b 45 10             	mov    0x10(%ebp),%eax
  102a2a:	66 89 45 e8          	mov    %ax,0xffffffe8(%ebp)
  if(writei(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
  102a2e:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  102a31:	8d 55 e8             	lea    0xffffffe8(%ebp),%edx
  102a34:	c7 44 24 0c 10 00 00 	movl   $0x10,0xc(%esp)
  102a3b:	00 
  102a3c:	89 44 24 08          	mov    %eax,0x8(%esp)
  102a40:	89 54 24 04          	mov    %edx,0x4(%esp)
  102a44:	8b 45 08             	mov    0x8(%ebp),%eax
  102a47:	89 04 24             	mov    %eax,(%esp)
  102a4a:	e8 11 fc ff ff       	call   102660 <writei>
  102a4f:	83 f8 10             	cmp    $0x10,%eax
  102a52:	74 0c                	je     102a60 <dirlink+0xf0>
    panic("dirlink");
  102a54:	c7 04 24 9f a4 11 00 	movl   $0x11a49f,(%esp)
  102a5b:	e8 b0 e5 ff ff       	call   101010 <panic>
  
  return 0;
  102a60:	c7 45 dc 00 00 00 00 	movl   $0x0,0xffffffdc(%ebp)
  102a67:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
}
  102a6a:	c9                   	leave  
  102a6b:	c3                   	ret    
  102a6c:	8d 74 26 00          	lea    0x0(%esi),%esi

00102a70 <skipelem>:

// Paths

// Copy the next path element from path into name.
// Return a pointer to the element following the copied one.
// The returned path has no leading slashes,
// so the caller can check *path=='\0' to see if the name is the last one.
// If no name to remove, return 0.
//
// Examples:
//   skipelem("a/bb/c", name) = "bb/c", setting name = "a"
//   skipelem("///a//bb", name) = "bb", setting name = "a"
//   skipelem("", name) = skipelem("////", name) = 0
//
static char*
skipelem(char *path, char *name)
{
  102a70:	55                   	push   %ebp
  102a71:	89 e5                	mov    %esp,%ebp
  102a73:	83 ec 28             	sub    $0x28,%esp
  char *s;
  int len;

  while(*path == '/')
  102a76:	eb 04                	jmp    102a7c <skipelem+0xc>
    path++;
  102a78:	83 45 08 01          	addl   $0x1,0x8(%ebp)
  102a7c:	8b 45 08             	mov    0x8(%ebp),%eax
  102a7f:	0f b6 00             	movzbl (%eax),%eax
  102a82:	3c 2f                	cmp    $0x2f,%al
  102a84:	74 f2                	je     102a78 <skipelem+0x8>
  if(*path == 0)
  102a86:	8b 45 08             	mov    0x8(%ebp),%eax
  102a89:	0f b6 00             	movzbl (%eax),%eax
  102a8c:	84 c0                	test   %al,%al
  102a8e:	75 0c                	jne    102a9c <skipelem+0x2c>
    return 0;
  102a90:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  102a97:	e9 85 00 00 00       	jmp    102b21 <skipelem+0xb1>
  s = path;
  102a9c:	8b 45 08             	mov    0x8(%ebp),%eax
  102a9f:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  while(*path != '/' && *path != 0)
  102aa2:	eb 04                	jmp    102aa8 <skipelem+0x38>
    path++;
  102aa4:	83 45 08 01          	addl   $0x1,0x8(%ebp)
  102aa8:	8b 45 08             	mov    0x8(%ebp),%eax
  102aab:	0f b6 00             	movzbl (%eax),%eax
  102aae:	3c 2f                	cmp    $0x2f,%al
  102ab0:	74 0a                	je     102abc <skipelem+0x4c>
  102ab2:	8b 45 08             	mov    0x8(%ebp),%eax
  102ab5:	0f b6 00             	movzbl (%eax),%eax
  102ab8:	84 c0                	test   %al,%al
  102aba:	75 e8                	jne    102aa4 <skipelem+0x34>
  len = path - s;
  102abc:	8b 45 08             	mov    0x8(%ebp),%eax
  102abf:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  102ac2:	29 d0                	sub    %edx,%eax
  102ac4:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  if(len >= DIRSIZ)
  102ac7:	83 7d fc 0d          	cmpl   $0xd,0xfffffffc(%ebp)
  102acb:	7e 1c                	jle    102ae9 <skipelem+0x79>
    memmove(name, s, DIRSIZ);
  102acd:	c7 44 24 08 0e 00 00 	movl   $0xe,0x8(%esp)
  102ad4:	00 
  102ad5:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  102ad8:	89 44 24 04          	mov    %eax,0x4(%esp)
  102adc:	8b 45 0c             	mov    0xc(%ebp),%eax
  102adf:	89 04 24             	mov    %eax,(%esp)
  102ae2:	e8 a9 34 00 00       	call   105f90 <memmove>
  102ae7:	eb 28                	jmp    102b11 <skipelem+0xa1>
  else {
    memmove(name, s, len);
  102ae9:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  102aec:	89 44 24 08          	mov    %eax,0x8(%esp)
  102af0:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  102af3:	89 44 24 04          	mov    %eax,0x4(%esp)
  102af7:	8b 45 0c             	mov    0xc(%ebp),%eax
  102afa:	89 04 24             	mov    %eax,(%esp)
  102afd:	e8 8e 34 00 00       	call   105f90 <memmove>
    name[len] = 0;
  102b02:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  102b05:	03 45 0c             	add    0xc(%ebp),%eax
  102b08:	c6 00 00             	movb   $0x0,(%eax)
  }
  while(*path == '/')
  102b0b:	eb 04                	jmp    102b11 <skipelem+0xa1>
    path++;
  102b0d:	83 45 08 01          	addl   $0x1,0x8(%ebp)
  102b11:	8b 45 08             	mov    0x8(%ebp),%eax
  102b14:	0f b6 00             	movzbl (%eax),%eax
  102b17:	3c 2f                	cmp    $0x2f,%al
  102b19:	74 f2                	je     102b0d <skipelem+0x9d>
  return path;
  102b1b:	8b 45 08             	mov    0x8(%ebp),%eax
  102b1e:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  102b21:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  102b24:	c9                   	leave  
  102b25:	c3                   	ret    
  102b26:	8d 76 00             	lea    0x0(%esi),%esi
  102b29:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00102b30 <_namei>:

// Look up and return the inode for a path name.
// If parent != 0, return the inode for the parent and copy the final
// path element into name, which must have room for DIRSIZ bytes.
static struct inode*
_namei(char *path, int parent, char *name)
{
  102b30:	55                   	push   %ebp
  102b31:	89 e5                	mov    %esp,%ebp
  102b33:	83 ec 28             	sub    $0x28,%esp
  struct inode *ip, *next;

//  cprintf("XXX _namei %s\n", path);
  if(*path == '/')
  102b36:	8b 45 08             	mov    0x8(%ebp),%eax
  102b39:	0f b6 00             	movzbl (%eax),%eax
  102b3c:	3c 2f                	cmp    $0x2f,%al
  102b3e:	75 1c                	jne    102b5c <_namei+0x2c>
    ip = iget(ROOTDEV, 1);
  102b40:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  102b47:	00 
  102b48:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  102b4f:	e8 4c f1 ff ff       	call   101ca0 <iget>
  102b54:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  102b57:	e9 bc 00 00 00       	jmp    102c18 <_namei+0xe8>
  else
    ip = idup(cp->cwd);
  102b5c:	e8 5f 0d 00 00       	call   1038c0 <cpu>
  102b61:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  102b68:	8b 40 60             	mov    0x60(%eax),%eax
  102b6b:	89 04 24             	mov    %eax,(%esp)
  102b6e:	e8 0d f2 ff ff       	call   101d80 <idup>
  102b73:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)

  while((path = skipelem(path, name)) != 0){
  102b76:	e9 9d 00 00 00       	jmp    102c18 <_namei+0xe8>
//    cprintf("XXX ready to ilock\n");
    ilock(ip);
  102b7b:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  102b7e:	89 04 24             	mov    %eax,(%esp)
  102b81:	e8 3a f2 ff ff       	call   101dc0 <ilock>
//    cprintf("XXX here %d\n", ip->type);
    if(ip->type != T_DIR){
  102b86:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  102b89:	0f b7 40 10          	movzwl 0x10(%eax),%eax
  102b8d:	66 83 f8 01          	cmp    $0x1,%ax
  102b91:	74 17                	je     102baa <_namei+0x7a>
      iunlockput(ip);
  102b93:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  102b96:	89 04 24             	mov    %eax,(%esp)
  102b99:	e8 d2 f4 ff ff       	call   102070 <iunlockput>
      return 0;
  102b9e:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  102ba5:	e9 ad 00 00 00       	jmp    102c57 <_namei+0x127>
    }
    if(parent && *path == '\0'){
  102baa:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  102bae:	74 20                	je     102bd0 <_namei+0xa0>
  102bb0:	8b 45 08             	mov    0x8(%ebp),%eax
  102bb3:	0f b6 00             	movzbl (%eax),%eax
  102bb6:	84 c0                	test   %al,%al
  102bb8:	75 16                	jne    102bd0 <_namei+0xa0>
      // Stop one level early.
      iunlock(ip);
  102bba:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  102bbd:	89 04 24             	mov    %eax,(%esp)
  102bc0:	e8 5b f3 ff ff       	call   101f20 <iunlock>
      return ip;
  102bc5:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  102bc8:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  102bcb:	e9 87 00 00 00       	jmp    102c57 <_namei+0x127>
    }
    if((next = dirlookup(ip, name, 0)) == 0){
  102bd0:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  102bd7:	00 
  102bd8:	8b 45 10             	mov    0x10(%ebp),%eax
  102bdb:	89 44 24 04          	mov    %eax,0x4(%esp)
  102bdf:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  102be2:	89 04 24             	mov    %eax,(%esp)
  102be5:	e8 56 fc ff ff       	call   102840 <dirlookup>
  102bea:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  102bed:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  102bf1:	75 14                	jne    102c07 <_namei+0xd7>
      iunlockput(ip);
  102bf3:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  102bf6:	89 04 24             	mov    %eax,(%esp)
  102bf9:	e8 72 f4 ff ff       	call   102070 <iunlockput>
      return 0;
  102bfe:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  102c05:	eb 50                	jmp    102c57 <_namei+0x127>
    }
    iunlockput(ip);
  102c07:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  102c0a:	89 04 24             	mov    %eax,(%esp)
  102c0d:	e8 5e f4 ff ff       	call   102070 <iunlockput>
    ip = next;
  102c12:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  102c15:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  102c18:	8b 45 10             	mov    0x10(%ebp),%eax
  102c1b:	89 44 24 04          	mov    %eax,0x4(%esp)
  102c1f:	8b 45 08             	mov    0x8(%ebp),%eax
  102c22:	89 04 24             	mov    %eax,(%esp)
  102c25:	e8 46 fe ff ff       	call   102a70 <skipelem>
  102c2a:	89 45 08             	mov    %eax,0x8(%ebp)
  102c2d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  102c31:	0f 85 44 ff ff ff    	jne    102b7b <_namei+0x4b>
  }
  if(parent){
  102c37:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  102c3b:	74 14                	je     102c51 <_namei+0x121>
    iput(ip);
  102c3d:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  102c40:	89 04 24             	mov    %eax,(%esp)
  102c43:	e8 48 f3 ff ff       	call   101f90 <iput>
    return 0;
  102c48:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  102c4f:	eb 06                	jmp    102c57 <_namei+0x127>
  }
  return ip;
  102c51:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  102c54:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  102c57:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  102c5a:	c9                   	leave  
  102c5b:	c3                   	ret    
  102c5c:	8d 74 26 00          	lea    0x0(%esi),%esi

00102c60 <namei>:

struct inode*
namei(char *path)
{
  102c60:	55                   	push   %ebp
  102c61:	89 e5                	mov    %esp,%ebp
  102c63:	83 ec 28             	sub    $0x28,%esp
  char name[DIRSIZ];
  return _namei(path, 0, name);
  102c66:	8d 45 f2             	lea    0xfffffff2(%ebp),%eax
  102c69:	89 44 24 08          	mov    %eax,0x8(%esp)
  102c6d:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  102c74:	00 
  102c75:	8b 45 08             	mov    0x8(%ebp),%eax
  102c78:	89 04 24             	mov    %eax,(%esp)
  102c7b:	e8 b0 fe ff ff       	call   102b30 <_namei>
}
  102c80:	c9                   	leave  
  102c81:	c3                   	ret    
  102c82:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi
  102c89:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00102c90 <nameiparent>:

struct inode*
nameiparent(char *path, char *name)
{
  102c90:	55                   	push   %ebp
  102c91:	89 e5                	mov    %esp,%ebp
  102c93:	83 ec 18             	sub    $0x18,%esp
  return _namei(path, 1, name);
  102c96:	8b 45 0c             	mov    0xc(%ebp),%eax
  102c99:	89 44 24 08          	mov    %eax,0x8(%esp)
  102c9d:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  102ca4:	00 
  102ca5:	8b 45 08             	mov    0x8(%ebp),%eax
  102ca8:	89 04 24             	mov    %eax,(%esp)
  102cab:	e8 80 fe ff ff       	call   102b30 <_namei>
}
  102cb0:	c9                   	leave  
  102cb1:	c3                   	ret    
  102cb2:	90                   	nop    
  102cb3:	90                   	nop    
  102cb4:	90                   	nop    
  102cb5:	90                   	nop    
  102cb6:	90                   	nop    
  102cb7:	90                   	nop    
  102cb8:	90                   	nop    
  102cb9:	90                   	nop    
  102cba:	90                   	nop    
  102cbb:	90                   	nop    
  102cbc:	90                   	nop    
  102cbd:	90                   	nop    
  102cbe:	90                   	nop    
  102cbf:	90                   	nop    

00102cc0 <ide_wait_ready>:

// Wait for IDE disk to become ready.
static int
ide_wait_ready(int check_error)
{
  102cc0:	55                   	push   %ebp
  102cc1:	89 e5                	mov    %esp,%ebp
  102cc3:	83 ec 18             	sub    $0x18,%esp
  int r;

  while(((r = inb(0x1f7)) & IDE_BSY) || !(r & IDE_DRDY))
  102cc6:	c7 04 24 f7 01 00 00 	movl   $0x1f7,(%esp)
  102ccd:	e8 4e 00 00 00       	call   102d20 <inb>
  102cd2:	0f b6 c0             	movzbl %al,%eax
  102cd5:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  102cd8:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  102cdb:	25 80 00 00 00       	and    $0x80,%eax
  102ce0:	85 c0                	test   %eax,%eax
  102ce2:	75 e2                	jne    102cc6 <ide_wait_ready+0x6>
  102ce4:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  102ce7:	83 e0 40             	and    $0x40,%eax
  102cea:	85 c0                	test   %eax,%eax
  102cec:	74 d8                	je     102cc6 <ide_wait_ready+0x6>
    ;
  if(check_error && (r & (IDE_DF|IDE_ERR)) != 0)
  102cee:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  102cf2:	74 13                	je     102d07 <ide_wait_ready+0x47>
  102cf4:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  102cf7:	83 e0 21             	and    $0x21,%eax
  102cfa:	85 c0                	test   %eax,%eax
  102cfc:	74 09                	je     102d07 <ide_wait_ready+0x47>
    return -1;
  102cfe:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  102d05:	eb 07                	jmp    102d0e <ide_wait_ready+0x4e>
  return 0;
  102d07:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  102d0e:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  102d11:	c9                   	leave  
  102d12:	c3                   	ret    
  102d13:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  102d19:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00102d20 <inb>:
// Routines to let C code use special x86 instructions.

static inline uchar
inb(ushort port)
{
  102d20:	55                   	push   %ebp
  102d21:	89 e5                	mov    %esp,%ebp
  102d23:	83 ec 14             	sub    $0x14,%esp
  102d26:	8b 45 08             	mov    0x8(%ebp),%eax
  102d29:	66 89 45 ec          	mov    %ax,0xffffffec(%ebp)
  uchar data;

  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
  102d2d:	0f b7 55 ec          	movzwl 0xffffffec(%ebp),%edx
  102d31:	ec                   	in     (%dx),%al
  102d32:	88 45 ff             	mov    %al,0xffffffff(%ebp)
  return data;
  102d35:	0f b6 45 ff          	movzbl 0xffffffff(%ebp),%eax
}
  102d39:	c9                   	leave  
  102d3a:	c3                   	ret    
  102d3b:	90                   	nop    
  102d3c:	8d 74 26 00          	lea    0x0(%esi),%esi

00102d40 <dummy_ide_intr>:

void
dummy_ide_intr(struct trapframe *tf)
{
  102d40:	55                   	push   %ebp
  102d41:	89 e5                	mov    %esp,%ebp
}
  102d43:	5d                   	pop    %ebp
  102d44:	c3                   	ret    
  102d45:	8d 74 26 00          	lea    0x0(%esi),%esi
  102d49:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00102d50 <ide_init>:

void
ide_init(void)
{
  102d50:	55                   	push   %ebp
  102d51:	89 e5                	mov    %esp,%ebp
  102d53:	83 ec 18             	sub    $0x18,%esp
  int i;

  initlock(&ide_lock, "ide");
  102d56:	c7 44 24 04 a7 a4 11 	movl   $0x11a4a7,0x4(%esp)
  102d5d:	00 
  102d5e:	c7 04 24 60 cd 11 00 	movl   $0x11cd60,(%esp)
  102d65:	e8 a6 2d 00 00       	call   105b10 <initlock>
  reg_irq_handler(IRQ_IDE, ide_intr);
  102d6a:	b8 a0 2f 10 00       	mov    $0x102fa0,%eax
  102d6f:	89 44 24 04          	mov    %eax,0x4(%esp)
  102d73:	c7 04 24 0e 00 00 00 	movl   $0xe,(%esp)
  102d7a:	e8 11 14 00 00       	call   104190 <reg_irq_handler>
  pic_enable(IRQ_IDE);
  102d7f:	c7 04 24 0e 00 00 00 	movl   $0xe,(%esp)
  102d86:	e8 95 14 00 00       	call   104220 <pic_enable>
  ioapic_enable(IRQ_IDE, ncpu - 1);
  102d8b:	a1 0c dd 13 00       	mov    0x13dd0c,%eax
  102d90:	83 e8 01             	sub    $0x1,%eax
  102d93:	89 44 24 04          	mov    %eax,0x4(%esp)
  102d97:	c7 04 24 0e 00 00 00 	movl   $0xe,(%esp)
  102d9e:	e8 cd 04 00 00       	call   103270 <ioapic_enable>
  ide_wait_ready(0);
  102da3:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  102daa:	e8 11 ff ff ff       	call   102cc0 <ide_wait_ready>
  reg_irq_handler(IRQ_IDE_2, dummy_ide_intr);
  102daf:	c7 44 24 04 40 2d 10 	movl   $0x102d40,0x4(%esp)
  102db6:	00 
  102db7:	c7 04 24 0f 00 00 00 	movl   $0xf,(%esp)
  102dbe:	e8 cd 13 00 00       	call   104190 <reg_irq_handler>
  
  // Check if disk 1 is present
  outb(0x1f6, 0xe0 | (1<<4));
  102dc3:	c7 44 24 04 f0 00 00 	movl   $0xf0,0x4(%esp)
  102dca:	00 
  102dcb:	c7 04 24 f6 01 00 00 	movl   $0x1f6,(%esp)
  102dd2:	e8 69 00 00 00       	call   102e40 <outb>
  for(i=0; i<1000; i++){
  102dd7:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
  102dde:	eb 20                	jmp    102e00 <ide_init+0xb0>
    if(inb(0x1f7) != 0){
  102de0:	c7 04 24 f7 01 00 00 	movl   $0x1f7,(%esp)
  102de7:	e8 34 ff ff ff       	call   102d20 <inb>
  102dec:	84 c0                	test   %al,%al
  102dee:	74 0c                	je     102dfc <ide_init+0xac>
      disk_1_present = 1;
  102df0:	c7 05 98 cd 11 00 01 	movl   $0x1,0x11cd98
  102df7:	00 00 00 
      break;
  102dfa:	eb 0d                	jmp    102e09 <ide_init+0xb9>
  102dfc:	83 45 fc 01          	addl   $0x1,0xfffffffc(%ebp)
  102e00:	81 7d fc e7 03 00 00 	cmpl   $0x3e7,0xfffffffc(%ebp)
  102e07:	7e d7                	jle    102de0 <ide_init+0x90>
    }
  }
  
  // Switch back to disk 0.
  outb(0x1f6, 0xe0 | (0<<4));
  102e09:	c7 44 24 04 e0 00 00 	movl   $0xe0,0x4(%esp)
  102e10:	00 
  102e11:	c7 04 24 f6 01 00 00 	movl   $0x1f6,(%esp)
  102e18:	e8 23 00 00 00       	call   102e40 <outb>
  outb(0x3f6, 0);  // generate interrupt
  102e1d:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  102e24:	00 
  102e25:	c7 04 24 f6 03 00 00 	movl   $0x3f6,(%esp)
  102e2c:	e8 0f 00 00 00       	call   102e40 <outb>
}
  102e31:	c9                   	leave  
  102e32:	c3                   	ret    
  102e33:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  102e39:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00102e40 <outb>:
}

static inline void
outb(ushort port, uchar data)
{
  102e40:	55                   	push   %ebp
  102e41:	89 e5                	mov    %esp,%ebp
  102e43:	83 ec 08             	sub    $0x8,%esp
  102e46:	8b 45 08             	mov    0x8(%ebp),%eax
  102e49:	8b 55 0c             	mov    0xc(%ebp),%edx
  102e4c:	66 89 45 fc          	mov    %ax,0xfffffffc(%ebp)
  102e50:	88 55 f8             	mov    %dl,0xfffffff8(%ebp)
  asm volatile("out %0,%1" : : "a" (data), "d" (port));
  102e53:	0f b6 45 f8          	movzbl 0xfffffff8(%ebp),%eax
  102e57:	0f b7 55 fc          	movzwl 0xfffffffc(%ebp),%edx
  102e5b:	ee                   	out    %al,(%dx)
}
  102e5c:	c9                   	leave  
  102e5d:	c3                   	ret    
  102e5e:	89 f6                	mov    %esi,%esi

00102e60 <ide_start_request>:

// Start the request for b.  Caller must hold ide_lock.
static void
ide_start_request(struct buf *b)
{
  102e60:	55                   	push   %ebp
  102e61:	89 e5                	mov    %esp,%ebp
  102e63:	83 ec 18             	sub    $0x18,%esp
//    cprintf("XXX ide_start_request\n");
  if(b == 0)
  102e66:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  102e6a:	75 0c                	jne    102e78 <ide_start_request+0x18>
    panic("ide_start_request");
  102e6c:	c7 04 24 ab a4 11 00 	movl   $0x11a4ab,(%esp)
  102e73:	e8 98 e1 ff ff       	call   101010 <panic>

  ide_wait_ready(0);
  102e78:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  102e7f:	e8 3c fe ff ff       	call   102cc0 <ide_wait_ready>
  outb(0x1f2, 1);  // number of sectors
  102e84:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  102e8b:	00 
  102e8c:	c7 04 24 f2 01 00 00 	movl   $0x1f2,(%esp)
  102e93:	e8 a8 ff ff ff       	call   102e40 <outb>
  outb(0x1f3, b->sector & 0xff);
  102e98:	8b 45 08             	mov    0x8(%ebp),%eax
  102e9b:	8b 40 08             	mov    0x8(%eax),%eax
  102e9e:	0f b6 c0             	movzbl %al,%eax
  102ea1:	89 44 24 04          	mov    %eax,0x4(%esp)
  102ea5:	c7 04 24 f3 01 00 00 	movl   $0x1f3,(%esp)
  102eac:	e8 8f ff ff ff       	call   102e40 <outb>
  outb(0x1f4, (b->sector >> 8) & 0xff);
  102eb1:	8b 45 08             	mov    0x8(%ebp),%eax
  102eb4:	8b 40 08             	mov    0x8(%eax),%eax
  102eb7:	c1 e8 08             	shr    $0x8,%eax
  102eba:	0f b6 c0             	movzbl %al,%eax
  102ebd:	89 44 24 04          	mov    %eax,0x4(%esp)
  102ec1:	c7 04 24 f4 01 00 00 	movl   $0x1f4,(%esp)
  102ec8:	e8 73 ff ff ff       	call   102e40 <outb>
  outb(0x1f5, (b->sector >> 16) & 0xff);
  102ecd:	8b 45 08             	mov    0x8(%ebp),%eax
  102ed0:	8b 40 08             	mov    0x8(%eax),%eax
  102ed3:	c1 e8 10             	shr    $0x10,%eax
  102ed6:	0f b6 c0             	movzbl %al,%eax
  102ed9:	89 44 24 04          	mov    %eax,0x4(%esp)
  102edd:	c7 04 24 f5 01 00 00 	movl   $0x1f5,(%esp)
  102ee4:	e8 57 ff ff ff       	call   102e40 <outb>
  outb(0x1f6, 0xe0 | ((b->dev&1)<<4) | ((b->sector>>24)&0x0f));
  102ee9:	8b 45 08             	mov    0x8(%ebp),%eax
  102eec:	8b 40 04             	mov    0x4(%eax),%eax
  102eef:	83 e0 01             	and    $0x1,%eax
  102ef2:	89 c2                	mov    %eax,%edx
  102ef4:	c1 e2 04             	shl    $0x4,%edx
  102ef7:	8b 45 08             	mov    0x8(%ebp),%eax
  102efa:	8b 40 08             	mov    0x8(%eax),%eax
  102efd:	c1 e8 18             	shr    $0x18,%eax
  102f00:	83 e0 0f             	and    $0xf,%eax
  102f03:	09 d0                	or     %edx,%eax
  102f05:	83 c8 e0             	or     $0xffffffe0,%eax
  102f08:	0f b6 c0             	movzbl %al,%eax
  102f0b:	89 44 24 04          	mov    %eax,0x4(%esp)
  102f0f:	c7 04 24 f6 01 00 00 	movl   $0x1f6,(%esp)
  102f16:	e8 25 ff ff ff       	call   102e40 <outb>
  if(b->flags & B_DIRTY){
  102f1b:	8b 45 08             	mov    0x8(%ebp),%eax
  102f1e:	8b 00                	mov    (%eax),%eax
  102f20:	83 e0 04             	and    $0x4,%eax
  102f23:	85 c0                	test   %eax,%eax
  102f25:	74 34                	je     102f5b <ide_start_request+0xfb>
    outb(0x1f7, IDE_CMD_WRITE);
  102f27:	c7 44 24 04 30 00 00 	movl   $0x30,0x4(%esp)
  102f2e:	00 
  102f2f:	c7 04 24 f7 01 00 00 	movl   $0x1f7,(%esp)
  102f36:	e8 05 ff ff ff       	call   102e40 <outb>
    outsl(0x1f0, b->data, 512/4);
  102f3b:	8b 45 08             	mov    0x8(%ebp),%eax
  102f3e:	83 c0 18             	add    $0x18,%eax
  102f41:	c7 44 24 08 80 00 00 	movl   $0x80,0x8(%esp)
  102f48:	00 
  102f49:	89 44 24 04          	mov    %eax,0x4(%esp)
  102f4d:	c7 04 24 f0 01 00 00 	movl   $0x1f0,(%esp)
  102f54:	e8 27 00 00 00       	call   102f80 <outsl>
  102f59:	eb 14                	jmp    102f6f <ide_start_request+0x10f>
  } else {
    outb(0x1f7, IDE_CMD_READ);
  102f5b:	c7 44 24 04 20 00 00 	movl   $0x20,0x4(%esp)
  102f62:	00 
  102f63:	c7 04 24 f7 01 00 00 	movl   $0x1f7,(%esp)
  102f6a:	e8 d1 fe ff ff       	call   102e40 <outb>
  }
}
  102f6f:	c9                   	leave  
  102f70:	c3                   	ret    
  102f71:	eb 0d                	jmp    102f80 <outsl>
  102f73:	90                   	nop    
  102f74:	90                   	nop    
  102f75:	90                   	nop    
  102f76:	90                   	nop    
  102f77:	90                   	nop    
  102f78:	90                   	nop    
  102f79:	90                   	nop    
  102f7a:	90                   	nop    
  102f7b:	90                   	nop    
  102f7c:	90                   	nop    
  102f7d:	90                   	nop    
  102f7e:	90                   	nop    
  102f7f:	90                   	nop    

00102f80 <outsl>:
}

static inline void
outsl(int port, const void *addr, int cnt)
{
  102f80:	55                   	push   %ebp
  102f81:	89 e5                	mov    %esp,%ebp
  102f83:	56                   	push   %esi
  asm volatile("cld\n\trepne\n\toutsl"    :
  102f84:	8b 55 08             	mov    0x8(%ebp),%edx
  102f87:	8b 75 0c             	mov    0xc(%ebp),%esi
  102f8a:	8b 4d 10             	mov    0x10(%ebp),%ecx
  102f8d:	fc                   	cld    
  102f8e:	f2 6f                	repnz outsl %ds:(%esi),(%dx)
  102f90:	89 75 0c             	mov    %esi,0xc(%ebp)
  102f93:	89 4d 10             	mov    %ecx,0x10(%ebp)
                   "=S" (addr), "=c" (cnt)    :
                   "d" (port), "0" (addr), "1" (cnt)  :
                   "cc");
}
  102f96:	5e                   	pop    %esi
  102f97:	5d                   	pop    %ebp
  102f98:	c3                   	ret    
  102f99:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

00102fa0 <ide_intr>:

// Interrupt handler.
void
ide_intr(void)
{
  102fa0:	55                   	push   %ebp
  102fa1:	89 e5                	mov    %esp,%ebp
  102fa3:	83 ec 28             	sub    $0x28,%esp
  struct buf *b;

  acquire(&ide_lock);
  102fa6:	c7 04 24 60 cd 11 00 	movl   $0x11cd60,(%esp)
  102fad:	e8 8e 2b 00 00       	call   105b40 <acquire>
  if((b = ide_queue) == 0){
  102fb2:	a1 94 cd 11 00       	mov    0x11cd94,%eax
  102fb7:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  102fba:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  102fbe:	75 11                	jne    102fd1 <ide_intr+0x31>
    release(&ide_lock);
  102fc0:	c7 04 24 60 cd 11 00 	movl   $0x11cd60,(%esp)
  102fc7:	e8 74 2d 00 00       	call   105d40 <release>
    return;
  102fcc:	e9 90 00 00 00       	jmp    103061 <ide_intr+0xc1>
  }

  // Read data if needed.
  if(!(b->flags & B_DIRTY) && ide_wait_ready(1) >= 0)
  102fd1:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  102fd4:	8b 00                	mov    (%eax),%eax
  102fd6:	83 e0 04             	and    $0x4,%eax
  102fd9:	85 c0                	test   %eax,%eax
  102fdb:	75 2e                	jne    10300b <ide_intr+0x6b>
  102fdd:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  102fe4:	e8 d7 fc ff ff       	call   102cc0 <ide_wait_ready>
  102fe9:	85 c0                	test   %eax,%eax
  102feb:	78 1e                	js     10300b <ide_intr+0x6b>
    insl(0x1f0, b->data, 512/4);
  102fed:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  102ff0:	83 c0 18             	add    $0x18,%eax
  102ff3:	c7 44 24 08 80 00 00 	movl   $0x80,0x8(%esp)
  102ffa:	00 
  102ffb:	89 44 24 04          	mov    %eax,0x4(%esp)
  102fff:	c7 04 24 f0 01 00 00 	movl   $0x1f0,(%esp)
  103006:	e8 65 00 00 00       	call   103070 <insl>
  
  // Wake process waiting for this buf.
  b->flags |= B_VALID;
  10300b:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10300e:	8b 00                	mov    (%eax),%eax
  103010:	89 c2                	mov    %eax,%edx
  103012:	83 ca 02             	or     $0x2,%edx
  103015:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  103018:	89 10                	mov    %edx,(%eax)
  b->flags &= ~B_DIRTY;
  10301a:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10301d:	8b 00                	mov    (%eax),%eax
  10301f:	89 c2                	mov    %eax,%edx
  103021:	83 e2 fb             	and    $0xfffffffb,%edx
  103024:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  103027:	89 10                	mov    %edx,(%eax)
  wakeup(b);
  103029:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10302c:	89 04 24             	mov    %eax,(%esp)
  10302f:	e8 ec 25 00 00       	call   105620 <wakeup>
  
  // Start disk on next buf in queue.
  if((ide_queue = b->qnext) != 0)
  103034:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  103037:	8b 40 14             	mov    0x14(%eax),%eax
  10303a:	a3 94 cd 11 00       	mov    %eax,0x11cd94
  10303f:	a1 94 cd 11 00       	mov    0x11cd94,%eax
  103044:	85 c0                	test   %eax,%eax
  103046:	74 0d                	je     103055 <ide_intr+0xb5>
    ide_start_request(ide_queue);
  103048:	a1 94 cd 11 00       	mov    0x11cd94,%eax
  10304d:	89 04 24             	mov    %eax,(%esp)
  103050:	e8 0b fe ff ff       	call   102e60 <ide_start_request>

  release(&ide_lock);
  103055:	c7 04 24 60 cd 11 00 	movl   $0x11cd60,(%esp)
  10305c:	e8 df 2c 00 00       	call   105d40 <release>
}
  103061:	c9                   	leave  
  103062:	c3                   	ret    
  103063:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  103069:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00103070 <insl>:
}

static inline void
insl(int port, void *addr, int cnt)
{
  103070:	55                   	push   %ebp
  103071:	89 e5                	mov    %esp,%ebp
  103073:	57                   	push   %edi
  asm volatile("cld\n\trepne\n\tinsl"     :
  103074:	8b 55 08             	mov    0x8(%ebp),%edx
  103077:	8b 7d 0c             	mov    0xc(%ebp),%edi
  10307a:	8b 4d 10             	mov    0x10(%ebp),%ecx
  10307d:	fc                   	cld    
  10307e:	f2 6d                	repnz insl (%dx),%es:(%edi)
  103080:	89 7d 0c             	mov    %edi,0xc(%ebp)
  103083:	89 4d 10             	mov    %ecx,0x10(%ebp)
                   "=D" (addr), "=c" (cnt)    :
                   "d" (port), "0" (addr), "1" (cnt)  :
                   "memory", "cc");
}
  103086:	5f                   	pop    %edi
  103087:	5d                   	pop    %ebp
  103088:	c3                   	ret    
  103089:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

00103090 <ide_rw>:

// Sync buf with disk. 
// If B_DIRTY is set, write buf to disk, clear B_DIRTY, set B_VALID.
// Else if B_VALID is not set, read buf from disk, set B_VALID.
void
ide_rw(struct buf *b)
{
  103090:	55                   	push   %ebp
  103091:	89 e5                	mov    %esp,%ebp
  103093:	83 ec 18             	sub    $0x18,%esp
  struct buf **pp;

  if(!(b->flags & B_BUSY))
  103096:	8b 45 08             	mov    0x8(%ebp),%eax
  103099:	8b 00                	mov    (%eax),%eax
  10309b:	83 e0 01             	and    $0x1,%eax
  10309e:	85 c0                	test   %eax,%eax
  1030a0:	75 0c                	jne    1030ae <ide_rw+0x1e>
    panic("ide_rw: buf not busy");
  1030a2:	c7 04 24 bd a4 11 00 	movl   $0x11a4bd,(%esp)
  1030a9:	e8 62 df ff ff       	call   101010 <panic>
  if((b->flags & (B_VALID|B_DIRTY)) == B_VALID)
  1030ae:	8b 45 08             	mov    0x8(%ebp),%eax
  1030b1:	8b 00                	mov    (%eax),%eax
  1030b3:	83 e0 06             	and    $0x6,%eax
  1030b6:	83 f8 02             	cmp    $0x2,%eax
  1030b9:	75 0c                	jne    1030c7 <ide_rw+0x37>
    panic("ide_rw: nothing to do");
  1030bb:	c7 04 24 d2 a4 11 00 	movl   $0x11a4d2,(%esp)
  1030c2:	e8 49 df ff ff       	call   101010 <panic>
  if(b->dev != 0 && !disk_1_present)
  1030c7:	8b 45 08             	mov    0x8(%ebp),%eax
  1030ca:	8b 40 04             	mov    0x4(%eax),%eax
  1030cd:	85 c0                	test   %eax,%eax
  1030cf:	74 15                	je     1030e6 <ide_rw+0x56>
  1030d1:	a1 98 cd 11 00       	mov    0x11cd98,%eax
  1030d6:	85 c0                	test   %eax,%eax
  1030d8:	75 0c                	jne    1030e6 <ide_rw+0x56>
    panic("ide disk 1 not present");
  1030da:	c7 04 24 e8 a4 11 00 	movl   $0x11a4e8,(%esp)
  1030e1:	e8 2a df ff ff       	call   101010 <panic>

  acquire(&ide_lock);
  1030e6:	c7 04 24 60 cd 11 00 	movl   $0x11cd60,(%esp)
  1030ed:	e8 4e 2a 00 00       	call   105b40 <acquire>

  // Append b to ide_queue.
  b->qnext = 0;
  1030f2:	8b 45 08             	mov    0x8(%ebp),%eax
  1030f5:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
  for(pp=&ide_queue; *pp; pp=&(*pp)->qnext)
  1030fc:	c7 45 fc 94 cd 11 00 	movl   $0x11cd94,0xfffffffc(%ebp)
  103103:	eb 0b                	jmp    103110 <ide_rw+0x80>
  103105:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  103108:	8b 00                	mov    (%eax),%eax
  10310a:	83 c0 14             	add    $0x14,%eax
  10310d:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  103110:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  103113:	8b 00                	mov    (%eax),%eax
  103115:	85 c0                	test   %eax,%eax
  103117:	75 ec                	jne    103105 <ide_rw+0x75>
    ;
  *pp = b;
  103119:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10311c:	8b 55 08             	mov    0x8(%ebp),%edx
  10311f:	89 10                	mov    %edx,(%eax)
  
  // Start disk if necessary.
  if(ide_queue == b)
  103121:	a1 94 cd 11 00       	mov    0x11cd94,%eax
  103126:	3b 45 08             	cmp    0x8(%ebp),%eax
  103129:	75 20                	jne    10314b <ide_rw+0xbb>
    ide_start_request(b);
  10312b:	8b 45 08             	mov    0x8(%ebp),%eax
  10312e:	89 04 24             	mov    %eax,(%esp)
  103131:	e8 2a fd ff ff       	call   102e60 <ide_start_request>
  
  // Wait for request to finish.
  // Assuming will not sleep too long: ignore cp->killed.
  while((b->flags & (B_VALID|B_DIRTY)) != B_VALID)
  103136:	eb 13                	jmp    10314b <ide_rw+0xbb>
  {
    sleep(b, &ide_lock);
  103138:	c7 44 24 04 60 cd 11 	movl   $0x11cd60,0x4(%esp)
  10313f:	00 
  103140:	8b 45 08             	mov    0x8(%ebp),%eax
  103143:	89 04 24             	mov    %eax,(%esp)
  103146:	e8 45 23 00 00       	call   105490 <sleep>
  10314b:	8b 45 08             	mov    0x8(%ebp),%eax
  10314e:	8b 00                	mov    (%eax),%eax
  103150:	83 e0 06             	and    $0x6,%eax
  103153:	83 f8 02             	cmp    $0x2,%eax
  103156:	75 e0                	jne    103138 <ide_rw+0xa8>
  }
//  cprintf("XXX ide_rw: finished\n");

  release(&ide_lock);
  103158:	c7 04 24 60 cd 11 00 	movl   $0x11cd60,(%esp)
  10315f:	e8 dc 2b 00 00       	call   105d40 <release>
}
  103164:	c9                   	leave  
  103165:	c3                   	ret    
  103166:	90                   	nop    
  103167:	90                   	nop    
  103168:	90                   	nop    
  103169:	90                   	nop    
  10316a:	90                   	nop    
  10316b:	90                   	nop    
  10316c:	90                   	nop    
  10316d:	90                   	nop    
  10316e:	90                   	nop    
  10316f:	90                   	nop    

00103170 <ioapic_read>:
};

static uint
ioapic_read(int reg)
{
  103170:	55                   	push   %ebp
  103171:	89 e5                	mov    %esp,%ebp
  ioapic->reg = reg;
  103173:	8b 15 b4 cb 13 00    	mov    0x13cbb4,%edx
  103179:	8b 45 08             	mov    0x8(%ebp),%eax
  10317c:	89 02                	mov    %eax,(%edx)
  return ioapic->data;
  10317e:	a1 b4 cb 13 00       	mov    0x13cbb4,%eax
  103183:	8b 40 10             	mov    0x10(%eax),%eax
}
  103186:	5d                   	pop    %ebp
  103187:	c3                   	ret    
  103188:	90                   	nop    
  103189:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

00103190 <ioapic_write>:

static void
ioapic_write(int reg, uint data)
{
  103190:	55                   	push   %ebp
  103191:	89 e5                	mov    %esp,%ebp
  ioapic->reg = reg;
  103193:	8b 15 b4 cb 13 00    	mov    0x13cbb4,%edx
  103199:	8b 45 08             	mov    0x8(%ebp),%eax
  10319c:	89 02                	mov    %eax,(%edx)
  ioapic->data = data;
  10319e:	8b 15 b4 cb 13 00    	mov    0x13cbb4,%edx
  1031a4:	8b 45 0c             	mov    0xc(%ebp),%eax
  1031a7:	89 42 10             	mov    %eax,0x10(%edx)
}
  1031aa:	5d                   	pop    %ebp
  1031ab:	c3                   	ret    
  1031ac:	8d 74 26 00          	lea    0x0(%esi),%esi

001031b0 <ioapic_init>:

void
ioapic_init(void)
{
  1031b0:	55                   	push   %ebp
  1031b1:	89 e5                	mov    %esp,%ebp
  1031b3:	83 ec 18             	sub    $0x18,%esp
  int i, id, maxintr;

  if(!ismp)
  1031b6:	a1 00 cc 13 00       	mov    0x13cc00,%eax
  1031bb:	85 c0                	test   %eax,%eax
  1031bd:	0f 84 9c 00 00 00    	je     10325f <ioapic_init+0xaf>
    return;

  ioapic = (volatile struct ioapic*)IOAPIC;
  1031c3:	c7 05 b4 cb 13 00 00 	movl   $0xfec00000,0x13cbb4
  1031ca:	00 c0 fe 
  maxintr = (ioapic_read(REG_VER) >> 16) & 0xFF;
  1031cd:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  1031d4:	e8 97 ff ff ff       	call   103170 <ioapic_read>
  1031d9:	c1 e8 10             	shr    $0x10,%eax
  1031dc:	25 ff 00 00 00       	and    $0xff,%eax
  1031e1:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  id = ioapic_read(REG_ID) >> 24;
  1031e4:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  1031eb:	e8 80 ff ff ff       	call   103170 <ioapic_read>
  1031f0:	c1 e8 18             	shr    $0x18,%eax
  1031f3:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  if(id != ioapic_id)
  1031f6:	0f b6 05 04 cc 13 00 	movzbl 0x13cc04,%eax
  1031fd:	0f b6 c0             	movzbl %al,%eax
  103200:	3b 45 f8             	cmp    0xfffffff8(%ebp),%eax
  103203:	74 0c                	je     103211 <ioapic_init+0x61>
    cprintf("ioapic_init: id isn't equal to ioapic_id; not a MP\n");
  103205:	c7 04 24 00 a5 11 00 	movl   $0x11a500,(%esp)
  10320c:	e8 ff d4 ff ff       	call   100710 <cprintf>

  // Mark all interrupts edge-triggered, active high, disabled,
  // and not routed to any CPUs.
  for(i = 0; i <= maxintr; i++){
  103211:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
  103218:	eb 3d                	jmp    103257 <ioapic_init+0xa7>
    ioapic_write(REG_TABLE+2*i, INT_DISABLED | (IRQ_OFFSET + i));
  10321a:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10321d:	83 c0 20             	add    $0x20,%eax
  103220:	0d 00 00 10 00       	or     $0x100000,%eax
  103225:	89 c2                	mov    %eax,%edx
  103227:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10322a:	01 c0                	add    %eax,%eax
  10322c:	83 c0 10             	add    $0x10,%eax
  10322f:	89 54 24 04          	mov    %edx,0x4(%esp)
  103233:	89 04 24             	mov    %eax,(%esp)
  103236:	e8 55 ff ff ff       	call   103190 <ioapic_write>
    ioapic_write(REG_TABLE+2*i+1, 0);
  10323b:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10323e:	01 c0                	add    %eax,%eax
  103240:	83 c0 11             	add    $0x11,%eax
  103243:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  10324a:	00 
  10324b:	89 04 24             	mov    %eax,(%esp)
  10324e:	e8 3d ff ff ff       	call   103190 <ioapic_write>
  103253:	83 45 f4 01          	addl   $0x1,0xfffffff4(%ebp)
  103257:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10325a:	3b 45 fc             	cmp    0xfffffffc(%ebp),%eax
  10325d:	7e bb                	jle    10321a <ioapic_init+0x6a>
  }
}
  10325f:	c9                   	leave  
  103260:	c3                   	ret    
  103261:	eb 0d                	jmp    103270 <ioapic_enable>
  103263:	90                   	nop    
  103264:	90                   	nop    
  103265:	90                   	nop    
  103266:	90                   	nop    
  103267:	90                   	nop    
  103268:	90                   	nop    
  103269:	90                   	nop    
  10326a:	90                   	nop    
  10326b:	90                   	nop    
  10326c:	90                   	nop    
  10326d:	90                   	nop    
  10326e:	90                   	nop    
  10326f:	90                   	nop    

00103270 <ioapic_enable>:

void
ioapic_enable(int irq, int cpunum)
{
  103270:	55                   	push   %ebp
  103271:	89 e5                	mov    %esp,%ebp
  103273:	83 ec 08             	sub    $0x8,%esp
  if(!ismp)
  103276:	a1 00 cc 13 00       	mov    0x13cc00,%eax
  10327b:	85 c0                	test   %eax,%eax
  10327d:	74 38                	je     1032b7 <ioapic_enable+0x47>
    return;

  // Mark interrupt edge-triggered, active high,
  // enabled, and routed to the given cpunum,
  // which happens to be that cpu's APIC ID.
  ioapic_write(REG_TABLE+2*irq, IRQ_OFFSET + irq);
  10327f:	8b 45 08             	mov    0x8(%ebp),%eax
  103282:	83 c0 20             	add    $0x20,%eax
  103285:	89 c2                	mov    %eax,%edx
  103287:	8b 45 08             	mov    0x8(%ebp),%eax
  10328a:	01 c0                	add    %eax,%eax
  10328c:	83 c0 10             	add    $0x10,%eax
  10328f:	89 54 24 04          	mov    %edx,0x4(%esp)
  103293:	89 04 24             	mov    %eax,(%esp)
  103296:	e8 f5 fe ff ff       	call   103190 <ioapic_write>
  ioapic_write(REG_TABLE+2*irq+1, cpunum << 24);
  10329b:	8b 45 0c             	mov    0xc(%ebp),%eax
  10329e:	c1 e0 18             	shl    $0x18,%eax
  1032a1:	89 c2                	mov    %eax,%edx
  1032a3:	8b 45 08             	mov    0x8(%ebp),%eax
  1032a6:	01 c0                	add    %eax,%eax
  1032a8:	83 c0 11             	add    $0x11,%eax
  1032ab:	89 54 24 04          	mov    %edx,0x4(%esp)
  1032af:	89 04 24             	mov    %eax,(%esp)
  1032b2:	e8 d9 fe ff ff       	call   103190 <ioapic_write>
}
  1032b7:	c9                   	leave  
  1032b8:	c3                   	ret    
  1032b9:	90                   	nop    
  1032ba:	90                   	nop    
  1032bb:	90                   	nop    
  1032bc:	90                   	nop    
  1032bd:	90                   	nop    
  1032be:	90                   	nop    
  1032bf:	90                   	nop    

001032c0 <kinit>:
// pages after _end.  Real systems would determine the
// amount of memory available in the system and use it all.
void
kinit(void)
{
  1032c0:	55                   	push   %ebp
  1032c1:	89 e5                	mov    %esp,%ebp
  1032c3:	83 ec 18             	sub    $0x18,%esp
  extern int end;
  uint mem;
  char *start;

  initlock(&kalloc_lock, "kalloc");
  1032c6:	c7 44 24 04 34 a5 11 	movl   $0x11a534,0x4(%esp)
  1032cd:	00 
  1032ce:	c7 04 24 c0 cb 13 00 	movl   $0x13cbc0,(%esp)
  1032d5:	e8 36 28 00 00       	call   105b10 <initlock>
  start = (char*) &end;
  1032da:	c7 45 fc 70 16 14 00 	movl   $0x141670,0xfffffffc(%ebp)
  start = (char*) (((uint)start + PAGE) & ~(PAGE-1));
  1032e1:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1032e4:	05 00 10 00 00       	add    $0x1000,%eax
  1032e9:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  1032ee:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  mem = 256; // assume computer has 256 pages of RAM
  1032f1:	c7 45 f8 00 01 00 00 	movl   $0x100,0xfffffff8(%ebp)
  cprintf("mem = %d\n", mem * PAGE);
  1032f8:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1032fb:	c1 e0 0c             	shl    $0xc,%eax
  1032fe:	89 44 24 04          	mov    %eax,0x4(%esp)
  103302:	c7 04 24 3b a5 11 00 	movl   $0x11a53b,(%esp)
  103309:	e8 02 d4 ff ff       	call   100710 <cprintf>
  kfree(start, mem * PAGE);
  10330e:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  103311:	c1 e0 0c             	shl    $0xc,%eax
  103314:	89 44 24 04          	mov    %eax,0x4(%esp)
  103318:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10331b:	89 04 24             	mov    %eax,(%esp)
  10331e:	e8 0d 00 00 00       	call   103330 <kfree>
}
  103323:	c9                   	leave  
  103324:	c3                   	ret    
  103325:	8d 74 26 00          	lea    0x0(%esi),%esi
  103329:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00103330 <kfree>:

// Free the len bytes of memory pointed at by v,
// which normally should have been returned by a
// call to kalloc(len).  (The exception is when
// initializing the allocator; see kinit above.)
void
kfree(char *v, int len)
{
  103330:	55                   	push   %ebp
  103331:	89 e5                	mov    %esp,%ebp
  103333:	83 ec 38             	sub    $0x38,%esp
  struct run *r, *rend, **rp, *p, *pend;

#ifdef MEM_DEBUG
  cprintf("kfree: %d pages\n", len / PAGE);
#endif
  if(len <= 0 || len % PAGE)
  103336:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  10333a:	7e 0c                	jle    103348 <kfree+0x18>
  10333c:	8b 45 0c             	mov    0xc(%ebp),%eax
  10333f:	25 ff 0f 00 00       	and    $0xfff,%eax
  103344:	85 c0                	test   %eax,%eax
  103346:	74 1f                	je     103367 <kfree+0x37>
  {
    cprintf("kfree: length = %d\n", len);
  103348:	8b 45 0c             	mov    0xc(%ebp),%eax
  10334b:	89 44 24 04          	mov    %eax,0x4(%esp)
  10334f:	c7 04 24 45 a5 11 00 	movl   $0x11a545,(%esp)
  103356:	e8 b5 d3 ff ff       	call   100710 <cprintf>
    panic("kfree");
  10335b:	c7 04 24 59 a5 11 00 	movl   $0x11a559,(%esp)
  103362:	e8 a9 dc ff ff       	call   101010 <panic>
  }

  // Fill with junk to catch dangling refs.
  memset(v, 1, len);
  103367:	8b 45 0c             	mov    0xc(%ebp),%eax
  10336a:	89 44 24 08          	mov    %eax,0x8(%esp)
  10336e:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  103375:	00 
  103376:	8b 45 08             	mov    0x8(%ebp),%eax
  103379:	89 04 24             	mov    %eax,(%esp)
  10337c:	e8 7f 2b 00 00       	call   105f00 <memset>

  acquire(&kalloc_lock);
  103381:	c7 04 24 c0 cb 13 00 	movl   $0x13cbc0,(%esp)
  103388:	e8 b3 27 00 00       	call   105b40 <acquire>
  p = (struct run*)v;
  10338d:	8b 45 08             	mov    0x8(%ebp),%eax
  103390:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  pend = (struct run*)(v + len);
  103393:	8b 45 0c             	mov    0xc(%ebp),%eax
  103396:	03 45 08             	add    0x8(%ebp),%eax
  103399:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  for(rp=&freelist; (r=*rp) != 0 && r <= pend; rp=&r->next){
  10339c:	c7 45 f4 f4 cb 13 00 	movl   $0x13cbf4,0xfffffff4(%ebp)
  1033a3:	e9 b3 00 00 00       	jmp    10345b <kfree+0x12b>
    rend = (struct run*)((char*)r + r->len);
  1033a8:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  1033ab:	8b 40 04             	mov    0x4(%eax),%eax
  1033ae:	89 c2                	mov    %eax,%edx
  1033b0:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  1033b3:	8d 04 02             	lea    (%edx,%eax,1),%eax
  1033b6:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
    if(r <= p && p < rend)
  1033b9:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  1033bc:	3b 45 f8             	cmp    0xfffffff8(%ebp),%eax
  1033bf:	77 14                	ja     1033d5 <kfree+0xa5>
  1033c1:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1033c4:	3b 45 f0             	cmp    0xfffffff0(%ebp),%eax
  1033c7:	73 0c                	jae    1033d5 <kfree+0xa5>
      panic("freeing free page");
  1033c9:	c7 04 24 5f a5 11 00 	movl   $0x11a55f,(%esp)
  1033d0:	e8 3b dc ff ff       	call   101010 <panic>
    if(pend == r){  // p next to r: replace r with p
  1033d5:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1033d8:	3b 45 ec             	cmp    0xffffffec(%ebp),%eax
  1033db:	75 28                	jne    103405 <kfree+0xd5>
      p->len = len + r->len;
  1033dd:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  1033e0:	8b 40 04             	mov    0x4(%eax),%eax
  1033e3:	89 c2                	mov    %eax,%edx
  1033e5:	03 55 0c             	add    0xc(%ebp),%edx
  1033e8:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1033eb:	89 50 04             	mov    %edx,0x4(%eax)
      p->next = r->next;
  1033ee:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  1033f1:	8b 10                	mov    (%eax),%edx
  1033f3:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1033f6:	89 10                	mov    %edx,(%eax)
      *rp = p;
  1033f8:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
  1033fb:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1033fe:	89 02                	mov    %eax,(%edx)
      goto out;
  103400:	e9 89 00 00 00       	jmp    10348e <kfree+0x15e>
    }
    if(rend == p){  // r next to p: replace p with r
  103405:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  103408:	3b 45 f8             	cmp    0xfffffff8(%ebp),%eax
  10340b:	75 48                	jne    103455 <kfree+0x125>
      r->len += len;
  10340d:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  103410:	8b 40 04             	mov    0x4(%eax),%eax
  103413:	89 c2                	mov    %eax,%edx
  103415:	03 55 0c             	add    0xc(%ebp),%edx
  103418:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10341b:	89 50 04             	mov    %edx,0x4(%eax)
      if(r->next && r->next == pend){  // r now next to r->next?
  10341e:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  103421:	8b 00                	mov    (%eax),%eax
  103423:	85 c0                	test   %eax,%eax
  103425:	74 67                	je     10348e <kfree+0x15e>
  103427:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10342a:	8b 00                	mov    (%eax),%eax
  10342c:	3b 45 fc             	cmp    0xfffffffc(%ebp),%eax
  10342f:	75 5d                	jne    10348e <kfree+0x15e>
        r->len += r->next->len;
  103431:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  103434:	8b 50 04             	mov    0x4(%eax),%edx
  103437:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10343a:	8b 00                	mov    (%eax),%eax
  10343c:	8b 40 04             	mov    0x4(%eax),%eax
  10343f:	01 c2                	add    %eax,%edx
  103441:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  103444:	89 50 04             	mov    %edx,0x4(%eax)
        r->next = r->next->next;
  103447:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10344a:	8b 00                	mov    (%eax),%eax
  10344c:	8b 10                	mov    (%eax),%edx
  10344e:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  103451:	89 10                	mov    %edx,(%eax)
      }
      goto out;
  103453:	eb 39                	jmp    10348e <kfree+0x15e>
  103455:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  103458:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  10345b:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10345e:	8b 00                	mov    (%eax),%eax
  103460:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  103463:	83 7d ec 00          	cmpl   $0x0,0xffffffec(%ebp)
  103467:	74 0c                	je     103475 <kfree+0x145>
  103469:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10346c:	3b 45 fc             	cmp    0xfffffffc(%ebp),%eax
  10346f:	0f 86 33 ff ff ff    	jbe    1033a8 <kfree+0x78>
    }
  }
  // Insert p before r in list.
  p->len = len;
  103475:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  103478:	8b 45 0c             	mov    0xc(%ebp),%eax
  10347b:	89 42 04             	mov    %eax,0x4(%edx)
  p->next = r;
  10347e:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  103481:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  103484:	89 02                	mov    %eax,(%edx)
  *rp = p;
  103486:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
  103489:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10348c:	89 02                	mov    %eax,(%edx)

 out:
  release(&kalloc_lock);
  10348e:	c7 04 24 c0 cb 13 00 	movl   $0x13cbc0,(%esp)
  103495:	e8 a6 28 00 00       	call   105d40 <release>
}
  10349a:	c9                   	leave  
  10349b:	c3                   	ret    
  10349c:	8d 74 26 00          	lea    0x0(%esi),%esi

001034a0 <kalloc>:

// Allocate n bytes of physical memory.
// Returns a kernel-segment pointer.
// Returns 0 if the memory cannot be allocated.
char*
kalloc(int n)
{
  1034a0:	55                   	push   %ebp
  1034a1:	89 e5                	mov    %esp,%ebp
  1034a3:	83 ec 18             	sub    $0x18,%esp
  char *p;
  struct run *r, **rp;

#ifdef MEM_DEBUG
  cprintf("kalloc: %d pages\n", n / PAGE);
  printstack();
#endif
  if(n % PAGE || n <= 0)
  1034a6:	8b 45 08             	mov    0x8(%ebp),%eax
  1034a9:	25 ff 0f 00 00       	and    $0xfff,%eax
  1034ae:	85 c0                	test   %eax,%eax
  1034b0:	75 06                	jne    1034b8 <kalloc+0x18>
  1034b2:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  1034b6:	7f 0c                	jg     1034c4 <kalloc+0x24>
    panic("kalloc");
  1034b8:	c7 04 24 34 a5 11 00 	movl   $0x11a534,(%esp)
  1034bf:	e8 4c db ff ff       	call   101010 <panic>

  acquire(&kalloc_lock);
  1034c4:	c7 04 24 c0 cb 13 00 	movl   $0x13cbc0,(%esp)
  1034cb:	e8 70 26 00 00       	call   105b40 <acquire>
  for(rp=&freelist; (r=*rp) != 0; rp=&r->next){
  1034d0:	c7 45 fc f4 cb 13 00 	movl   $0x13cbf4,0xfffffffc(%ebp)
  1034d7:	eb 70                	jmp    103549 <kalloc+0xa9>
    if(r->len == n){
  1034d9:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1034dc:	8b 40 04             	mov    0x4(%eax),%eax
  1034df:	3b 45 08             	cmp    0x8(%ebp),%eax
  1034e2:	75 1e                	jne    103502 <kalloc+0x62>
      *rp = r->next;
  1034e4:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1034e7:	8b 10                	mov    (%eax),%edx
  1034e9:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1034ec:	89 10                	mov    %edx,(%eax)
      release(&kalloc_lock);
  1034ee:	c7 04 24 c0 cb 13 00 	movl   $0x13cbc0,(%esp)
  1034f5:	e8 46 28 00 00       	call   105d40 <release>
      return (char*)r;
  1034fa:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1034fd:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  103500:	eb 74                	jmp    103576 <kalloc+0xd6>
    }
    if(r->len > n){
  103502:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  103505:	8b 40 04             	mov    0x4(%eax),%eax
  103508:	3b 45 08             	cmp    0x8(%ebp),%eax
  10350b:	7e 36                	jle    103543 <kalloc+0xa3>
      r->len -= n;
  10350d:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  103510:	8b 40 04             	mov    0x4(%eax),%eax
  103513:	89 c2                	mov    %eax,%edx
  103515:	2b 55 08             	sub    0x8(%ebp),%edx
  103518:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10351b:	89 50 04             	mov    %edx,0x4(%eax)
      p = (char*)r + r->len;
  10351e:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  103521:	8b 40 04             	mov    0x4(%eax),%eax
  103524:	89 c2                	mov    %eax,%edx
  103526:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  103529:	8d 04 02             	lea    (%edx,%eax,1),%eax
  10352c:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
      release(&kalloc_lock);
  10352f:	c7 04 24 c0 cb 13 00 	movl   $0x13cbc0,(%esp)
  103536:	e8 05 28 00 00       	call   105d40 <release>
      return p;
  10353b:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10353e:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  103541:	eb 33                	jmp    103576 <kalloc+0xd6>
  103543:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  103546:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  103549:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10354c:	8b 00                	mov    (%eax),%eax
  10354e:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  103551:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  103555:	75 82                	jne    1034d9 <kalloc+0x39>
    }
  }
  release(&kalloc_lock);
  103557:	c7 04 24 c0 cb 13 00 	movl   $0x13cbc0,(%esp)
  10355e:	e8 dd 27 00 00       	call   105d40 <release>

  cprintf("kalloc: out of memory\n");
  103563:	c7 04 24 71 a5 11 00 	movl   $0x11a571,(%esp)
  10356a:	e8 a1 d1 ff ff       	call   100710 <cprintf>
  return 0;
  10356f:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  103576:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  103579:	c9                   	leave  
  10357a:	c3                   	ret    
  10357b:	90                   	nop    
  10357c:	8d 74 26 00          	lea    0x0(%esi),%esi

00103580 <kmalloc>:

void *
kmalloc(int n)
{
  103580:	55                   	push   %ebp
  103581:	89 e5                	mov    %esp,%ebp
  103583:	83 ec 08             	sub    $0x8,%esp
#ifdef MEM_DEBUG
    cprintf("kmalloc: %d bytes\n", n);
#endif
    return kalloc(((n - 1) / PAGE + 1) * PAGE);
  103586:	8b 55 08             	mov    0x8(%ebp),%edx
  103589:	83 ea 01             	sub    $0x1,%edx
  10358c:	89 d0                	mov    %edx,%eax
  10358e:	c1 f8 1f             	sar    $0x1f,%eax
  103591:	c1 e8 14             	shr    $0x14,%eax
  103594:	01 d0                	add    %edx,%eax
  103596:	c1 f8 0c             	sar    $0xc,%eax
  103599:	83 c0 01             	add    $0x1,%eax
  10359c:	c1 e0 0c             	shl    $0xc,%eax
  10359f:	89 04 24             	mov    %eax,(%esp)
  1035a2:	e8 f9 fe ff ff       	call   1034a0 <kalloc>
}
  1035a7:	c9                   	leave  
  1035a8:	c3                   	ret    
  1035a9:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

001035b0 <kmfree>:

void
kmfree(void *p, int n)
{
  1035b0:	55                   	push   %ebp
  1035b1:	89 e5                	mov    %esp,%ebp
  1035b3:	83 ec 08             	sub    $0x8,%esp
#ifdef MEM_DEBUG
    cprintf("kmfree: %d bytes\n", n);
#endif
    return kfree(p, ((n - 1) / PAGE + 1) * PAGE);
  1035b6:	8b 55 0c             	mov    0xc(%ebp),%edx
  1035b9:	83 ea 01             	sub    $0x1,%edx
  1035bc:	89 d0                	mov    %edx,%eax
  1035be:	c1 f8 1f             	sar    $0x1f,%eax
  1035c1:	c1 e8 14             	shr    $0x14,%eax
  1035c4:	01 d0                	add    %edx,%eax
  1035c6:	c1 f8 0c             	sar    $0xc,%eax
  1035c9:	83 c0 01             	add    $0x1,%eax
  1035cc:	c1 e0 0c             	shl    $0xc,%eax
  1035cf:	8b 55 08             	mov    0x8(%ebp),%edx
  1035d2:	89 44 24 04          	mov    %eax,0x4(%esp)
  1035d6:	89 14 24             	mov    %edx,(%esp)
  1035d9:	e8 52 fd ff ff       	call   103330 <kfree>
}
  1035de:	c9                   	leave  
  1035df:	c3                   	ret    

001035e0 <kbd_getc>:
#include "kbd.h"

int
kbd_getc(void)
{
  1035e0:	55                   	push   %ebp
  1035e1:	89 e5                	mov    %esp,%ebp
  1035e3:	83 ec 28             	sub    $0x28,%esp
  static uint shift;
  static uchar *charcode[4] = {
    normalmap, shiftmap, ctlmap, ctlmap
  };
  uint st, data, c;

  st = inb(KBSTATP);
  1035e6:	c7 04 24 64 00 00 00 	movl   $0x64,(%esp)
  1035ed:	e8 5e 01 00 00       	call   103750 <inb>
  1035f2:	0f b6 c0             	movzbl %al,%eax
  1035f5:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  if((st & KBS_DIB) == 0)
  1035f8:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  1035fb:	83 e0 01             	and    $0x1,%eax
  1035fe:	85 c0                	test   %eax,%eax
  103600:	75 0c                	jne    10360e <kbd_getc+0x2e>
    return -1;
  103602:	c7 45 e8 ff ff ff ff 	movl   $0xffffffff,0xffffffe8(%ebp)
  103609:	e9 33 01 00 00       	jmp    103741 <kbd_getc+0x161>
  data = inb(KBDATAP);
  10360e:	c7 04 24 60 00 00 00 	movl   $0x60,(%esp)
  103615:	e8 36 01 00 00       	call   103750 <inb>
  10361a:	0f b6 c0             	movzbl %al,%eax
  10361d:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)

  if(data == 0xE0){
  103620:	81 7d f8 e0 00 00 00 	cmpl   $0xe0,0xfffffff8(%ebp)
  103627:	75 19                	jne    103642 <kbd_getc+0x62>
    shift |= E0ESC;
  103629:	a1 9c cd 11 00       	mov    0x11cd9c,%eax
  10362e:	83 c8 40             	or     $0x40,%eax
  103631:	a3 9c cd 11 00       	mov    %eax,0x11cd9c
    return 0;
  103636:	c7 45 e8 00 00 00 00 	movl   $0x0,0xffffffe8(%ebp)
  10363d:	e9 ff 00 00 00       	jmp    103741 <kbd_getc+0x161>
  } else if(data & 0x80){
  103642:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  103645:	25 80 00 00 00       	and    $0x80,%eax
  10364a:	85 c0                	test   %eax,%eax
  10364c:	74 4f                	je     10369d <kbd_getc+0xbd>
    // Key released
    data = (shift & E0ESC ? data : data & 0x7F);
  10364e:	a1 9c cd 11 00       	mov    0x11cd9c,%eax
  103653:	83 e0 40             	and    $0x40,%eax
  103656:	85 c0                	test   %eax,%eax
  103658:	75 0b                	jne    103665 <kbd_getc+0x85>
  10365a:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10365d:	83 e0 7f             	and    $0x7f,%eax
  103660:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  103663:	eb 06                	jmp    10366b <kbd_getc+0x8b>
  103665:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  103668:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  10366b:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10366e:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
    shift &= ~(shiftcode[data] | E0ESC);
  103671:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  103674:	0f b6 80 e0 c0 11 00 	movzbl 0x11c0e0(%eax),%eax
  10367b:	83 c8 40             	or     $0x40,%eax
  10367e:	0f b6 c0             	movzbl %al,%eax
  103681:	f7 d0                	not    %eax
  103683:	89 c2                	mov    %eax,%edx
  103685:	a1 9c cd 11 00       	mov    0x11cd9c,%eax
  10368a:	21 d0                	and    %edx,%eax
  10368c:	a3 9c cd 11 00       	mov    %eax,0x11cd9c
    return 0;
  103691:	c7 45 e8 00 00 00 00 	movl   $0x0,0xffffffe8(%ebp)
  103698:	e9 a4 00 00 00       	jmp    103741 <kbd_getc+0x161>
  } else if(shift & E0ESC){
  10369d:	a1 9c cd 11 00       	mov    0x11cd9c,%eax
  1036a2:	83 e0 40             	and    $0x40,%eax
  1036a5:	85 c0                	test   %eax,%eax
  1036a7:	74 14                	je     1036bd <kbd_getc+0xdd>
    // Last character was an E0 escape; or with 0x80
    data |= 0x80;
  1036a9:	81 4d f8 80 00 00 00 	orl    $0x80,0xfffffff8(%ebp)
    shift &= ~E0ESC;
  1036b0:	a1 9c cd 11 00       	mov    0x11cd9c,%eax
  1036b5:	83 e0 bf             	and    $0xffffffbf,%eax
  1036b8:	a3 9c cd 11 00       	mov    %eax,0x11cd9c
  }

  shift |= shiftcode[data];
  1036bd:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1036c0:	0f b6 80 e0 c0 11 00 	movzbl 0x11c0e0(%eax),%eax
  1036c7:	0f b6 d0             	movzbl %al,%edx
  1036ca:	a1 9c cd 11 00       	mov    0x11cd9c,%eax
  1036cf:	09 d0                	or     %edx,%eax
  1036d1:	a3 9c cd 11 00       	mov    %eax,0x11cd9c
  shift ^= togglecode[data];
  1036d6:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1036d9:	0f b6 80 e0 c1 11 00 	movzbl 0x11c1e0(%eax),%eax
  1036e0:	0f b6 d0             	movzbl %al,%edx
  1036e3:	a1 9c cd 11 00       	mov    0x11cd9c,%eax
  1036e8:	31 d0                	xor    %edx,%eax
  1036ea:	a3 9c cd 11 00       	mov    %eax,0x11cd9c
  c = charcode[shift & (CTL | SHIFT)][data];
  1036ef:	a1 9c cd 11 00       	mov    0x11cd9c,%eax
  1036f4:	83 e0 03             	and    $0x3,%eax
  1036f7:	8b 14 85 e0 c5 11 00 	mov    0x11c5e0(,%eax,4),%edx
  1036fe:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  103701:	8d 04 02             	lea    (%edx,%eax,1),%eax
  103704:	0f b6 00             	movzbl (%eax),%eax
  103707:	0f b6 c0             	movzbl %al,%eax
  10370a:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  if(shift & CAPSLOCK){
  10370d:	a1 9c cd 11 00       	mov    0x11cd9c,%eax
  103712:	83 e0 08             	and    $0x8,%eax
  103715:	85 c0                	test   %eax,%eax
  103717:	74 22                	je     10373b <kbd_getc+0x15b>
    if('a' <= c && c <= 'z')
  103719:	83 7d fc 60          	cmpl   $0x60,0xfffffffc(%ebp)
  10371d:	76 0c                	jbe    10372b <kbd_getc+0x14b>
  10371f:	83 7d fc 7a          	cmpl   $0x7a,0xfffffffc(%ebp)
  103723:	77 06                	ja     10372b <kbd_getc+0x14b>
      c += 'A' - 'a';
  103725:	83 6d fc 20          	subl   $0x20,0xfffffffc(%ebp)
  103729:	eb 10                	jmp    10373b <kbd_getc+0x15b>
    else if('A' <= c && c <= 'Z')
  10372b:	83 7d fc 40          	cmpl   $0x40,0xfffffffc(%ebp)
  10372f:	76 0a                	jbe    10373b <kbd_getc+0x15b>
  103731:	83 7d fc 5a          	cmpl   $0x5a,0xfffffffc(%ebp)
  103735:	77 04                	ja     10373b <kbd_getc+0x15b>
      c += 'a' - 'A';
  103737:	83 45 fc 20          	addl   $0x20,0xfffffffc(%ebp)
  }
  return c;
  10373b:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10373e:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
  103741:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
}
  103744:	c9                   	leave  
  103745:	c3                   	ret    
  103746:	8d 76 00             	lea    0x0(%esi),%esi
  103749:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00103750 <inb>:
// Routines to let C code use special x86 instructions.

static inline uchar
inb(ushort port)
{
  103750:	55                   	push   %ebp
  103751:	89 e5                	mov    %esp,%ebp
  103753:	83 ec 14             	sub    $0x14,%esp
  103756:	8b 45 08             	mov    0x8(%ebp),%eax
  103759:	66 89 45 ec          	mov    %ax,0xffffffec(%ebp)
  uchar data;

  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
  10375d:	0f b7 55 ec          	movzwl 0xffffffec(%ebp),%edx
  103761:	ec                   	in     (%dx),%al
  103762:	88 45 ff             	mov    %al,0xffffffff(%ebp)
  return data;
  103765:	0f b6 45 ff          	movzbl 0xffffffff(%ebp),%eax
}
  103769:	c9                   	leave  
  10376a:	c3                   	ret    
  10376b:	90                   	nop    
  10376c:	8d 74 26 00          	lea    0x0(%esi),%esi

00103770 <kbd_intr>:

void
kbd_intr(void)
{
  103770:	55                   	push   %ebp
  103771:	89 e5                	mov    %esp,%ebp
  103773:	83 ec 08             	sub    $0x8,%esp
  console_intr(kbd_getc);
  103776:	c7 04 24 e0 35 10 00 	movl   $0x1035e0,(%esp)
  10377d:	e8 6e d3 ff ff       	call   100af0 <console_intr>
}
  103782:	c9                   	leave  
  103783:	c3                   	ret    
  103784:	90                   	nop    
  103785:	90                   	nop    
  103786:	90                   	nop    
  103787:	90                   	nop    
  103788:	90                   	nop    
  103789:	90                   	nop    
  10378a:	90                   	nop    
  10378b:	90                   	nop    
  10378c:	90                   	nop    
  10378d:	90                   	nop    
  10378e:	90                   	nop    
  10378f:	90                   	nop    

00103790 <lapic_init>:
volatile uint *lapic;  // Initialized in mp.c

void
lapic_init(int c)
{
  103790:	55                   	push   %ebp
  103791:	89 e5                	mov    %esp,%ebp
  if(!lapic) 
  103793:	a1 f8 cb 13 00       	mov    0x13cbf8,%eax
  103798:	85 c0                	test   %eax,%eax
  10379a:	0f 84 1a 01 00 00    	je     1038ba <lapic_init+0x12a>
    return;

  // Enable local APIC; set spurious interrupt vector.
  lapic[SVR] = ENABLE | (IRQ_OFFSET+IRQ_SPURIOUS);
  1037a0:	a1 f8 cb 13 00       	mov    0x13cbf8,%eax
  1037a5:	05 f0 00 00 00       	add    $0xf0,%eax
  1037aa:	c7 00 3f 01 00 00    	movl   $0x13f,(%eax)

  // The timer repeatedly counts down at bus frequency
  // from lapic[TICR] and then issues an interrupt.  
  // Lapic[TCCR] is the current counter value.
  // If xv6 cared more about precise timekeeping, the
  // values of TICR and TCCR would be calibrated using
  // an external time source.
  lapic[TDCR] = X1;
  1037b0:	a1 f8 cb 13 00       	mov    0x13cbf8,%eax
  1037b5:	05 e0 03 00 00       	add    $0x3e0,%eax
  1037ba:	c7 00 0b 00 00 00    	movl   $0xb,(%eax)
  lapic[TICR] = 10000000;
  1037c0:	a1 f8 cb 13 00       	mov    0x13cbf8,%eax
  1037c5:	05 80 03 00 00       	add    $0x380,%eax
  1037ca:	c7 00 80 96 98 00    	movl   $0x989680,(%eax)
  lapic[TCCR] = 10000000;
  1037d0:	a1 f8 cb 13 00       	mov    0x13cbf8,%eax
  1037d5:	05 90 03 00 00       	add    $0x390,%eax
  1037da:	c7 00 80 96 98 00    	movl   $0x989680,(%eax)
  lapic[TIMER] = PERIODIC | (IRQ_OFFSET + IRQ_TIMER);
  1037e0:	a1 f8 cb 13 00       	mov    0x13cbf8,%eax
  1037e5:	05 20 03 00 00       	add    $0x320,%eax
  1037ea:	c7 00 20 00 02 00    	movl   $0x20020,(%eax)

  // Disable logical interrupt lines.
  lapic[LINT0] = MASKED;
  1037f0:	a1 f8 cb 13 00       	mov    0x13cbf8,%eax
  1037f5:	05 50 03 00 00       	add    $0x350,%eax
  1037fa:	c7 00 00 00 01 00    	movl   $0x10000,(%eax)
  lapic[LINT1] = MASKED;
  103800:	a1 f8 cb 13 00       	mov    0x13cbf8,%eax
  103805:	05 60 03 00 00       	add    $0x360,%eax
  10380a:	c7 00 00 00 01 00    	movl   $0x10000,(%eax)

  // Disable performance counter overflow interrupts
  // on machines that provide that interrupt entry.
  if(((lapic[VER]>>16) & 0xFF) >= 4)
  103810:	a1 f8 cb 13 00       	mov    0x13cbf8,%eax
  103815:	83 c0 30             	add    $0x30,%eax
  103818:	8b 00                	mov    (%eax),%eax
  10381a:	c1 e8 10             	shr    $0x10,%eax
  10381d:	25 ff 00 00 00       	and    $0xff,%eax
  103822:	83 f8 03             	cmp    $0x3,%eax
  103825:	76 10                	jbe    103837 <lapic_init+0xa7>
    lapic[PCINT] = MASKED;
  103827:	a1 f8 cb 13 00       	mov    0x13cbf8,%eax
  10382c:	05 40 03 00 00       	add    $0x340,%eax
  103831:	c7 00 00 00 01 00    	movl   $0x10000,(%eax)

  // Map error interrupt to IRQ_ERROR.
  lapic[ERROR] = IRQ_OFFSET+IRQ_ERROR;
  103837:	a1 f8 cb 13 00       	mov    0x13cbf8,%eax
  10383c:	05 70 03 00 00       	add    $0x370,%eax
  103841:	c7 00 33 00 00 00    	movl   $0x33,(%eax)

  // Clear error status register (requires back-to-back writes).
  lapic[ESR] = 0;
  103847:	a1 f8 cb 13 00       	mov    0x13cbf8,%eax
  10384c:	05 80 02 00 00       	add    $0x280,%eax
  103851:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  lapic[ESR] = 0;
  103857:	a1 f8 cb 13 00       	mov    0x13cbf8,%eax
  10385c:	05 80 02 00 00       	add    $0x280,%eax
  103861:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

  // Ack any outstanding interrupts.
  lapic[EOI] = 0;
  103867:	a1 f8 cb 13 00       	mov    0x13cbf8,%eax
  10386c:	05 b0 00 00 00       	add    $0xb0,%eax
  103871:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

  // Send an Init Level De-Assert to synchronise arbitration ID's.
  lapic[ICRHI] = 0;
  103877:	a1 f8 cb 13 00       	mov    0x13cbf8,%eax
  10387c:	05 10 03 00 00       	add    $0x310,%eax
  103881:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  lapic[ICRLO] = BCAST | INIT | LEVEL;
  103887:	a1 f8 cb 13 00       	mov    0x13cbf8,%eax
  10388c:	05 00 03 00 00       	add    $0x300,%eax
  103891:	c7 00 00 85 08 00    	movl   $0x88500,(%eax)
  while(lapic[ICRLO] & DELIVS)
  103897:	a1 f8 cb 13 00       	mov    0x13cbf8,%eax
  10389c:	05 00 03 00 00       	add    $0x300,%eax
  1038a1:	8b 00                	mov    (%eax),%eax
  1038a3:	25 00 10 00 00       	and    $0x1000,%eax
  1038a8:	85 c0                	test   %eax,%eax
  1038aa:	75 eb                	jne    103897 <lapic_init+0x107>
    ;

  // Enable interrupts on the APIC (but not on the processor).
  lapic[TPR] = 0;
  1038ac:	a1 f8 cb 13 00       	mov    0x13cbf8,%eax
  1038b1:	83 e8 80             	sub    $0xffffff80,%eax
  1038b4:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
  1038ba:	5d                   	pop    %ebp
  1038bb:	c3                   	ret    
  1038bc:	8d 74 26 00          	lea    0x0(%esi),%esi

001038c0 <cpu>:

int
cpu(void)
{
  1038c0:	55                   	push   %ebp
  1038c1:	89 e5                	mov    %esp,%ebp
  1038c3:	83 ec 04             	sub    $0x4,%esp
  if(lapic)
  1038c6:	a1 f8 cb 13 00       	mov    0x13cbf8,%eax
  1038cb:	85 c0                	test   %eax,%eax
  1038cd:	74 12                	je     1038e1 <cpu+0x21>
    return lapic[ID]>>24;
  1038cf:	a1 f8 cb 13 00       	mov    0x13cbf8,%eax
  1038d4:	83 c0 20             	add    $0x20,%eax
  1038d7:	8b 00                	mov    (%eax),%eax
  1038d9:	c1 e8 18             	shr    $0x18,%eax
  1038dc:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  1038df:	eb 07                	jmp    1038e8 <cpu+0x28>
  return 0;
  1038e1:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
  1038e8:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
}
  1038eb:	c9                   	leave  
  1038ec:	c3                   	ret    
  1038ed:	8d 76 00             	lea    0x0(%esi),%esi

001038f0 <lapic_eoi>:

// Acknowledge interrupt.
void
lapic_eoi(void)
{
  1038f0:	55                   	push   %ebp
  1038f1:	89 e5                	mov    %esp,%ebp
  if(lapic)
  1038f3:	a1 f8 cb 13 00       	mov    0x13cbf8,%eax
  1038f8:	85 c0                	test   %eax,%eax
  1038fa:	74 10                	je     10390c <lapic_eoi+0x1c>
    lapic[EOI] = 0;
  1038fc:	a1 f8 cb 13 00       	mov    0x13cbf8,%eax
  103901:	05 b0 00 00 00       	add    $0xb0,%eax
  103906:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
  10390c:	5d                   	pop    %ebp
  10390d:	c3                   	ret    
  10390e:	89 f6                	mov    %esi,%esi

00103910 <microdelay>:

// Spin for a given number of microseconds.
// On real hardware would want to tune this dynamically.
static void
microdelay(int us)
{
  103910:	55                   	push   %ebp
  103911:	89 e5                	mov    %esp,%ebp
  103913:	83 ec 10             	sub    $0x10,%esp
  volatile int j = 0;
  103916:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
  
  while(us-- > 0)
  10391d:	eb 1c                	jmp    10393b <microdelay+0x2b>
    for(j=0; j<10000; j++);
  10391f:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
  103926:	eb 09                	jmp    103931 <microdelay+0x21>
  103928:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10392b:	83 c0 01             	add    $0x1,%eax
  10392e:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  103931:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  103934:	3d 0f 27 00 00       	cmp    $0x270f,%eax
  103939:	7e ed                	jle    103928 <microdelay+0x18>
  10393b:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  10393f:	0f 9f c0             	setg   %al
  103942:	83 6d 08 01          	subl   $0x1,0x8(%ebp)
  103946:	84 c0                	test   %al,%al
  103948:	75 d5                	jne    10391f <microdelay+0xf>
}
  10394a:	c9                   	leave  
  10394b:	c3                   	ret    
  10394c:	8d 74 26 00          	lea    0x0(%esi),%esi

00103950 <lapic_startap>:

// Start additional processor running bootstrap code at addr.
// See Appendix B of MultiProcessor Specification.
void
lapic_startap(uchar apicid, uint addr)
{
  103950:	55                   	push   %ebp
  103951:	89 e5                	mov    %esp,%ebp
  103953:	83 ec 18             	sub    $0x18,%esp
  103956:	8b 45 08             	mov    0x8(%ebp),%eax
  103959:	88 45 ec             	mov    %al,0xffffffec(%ebp)
  int i;
  volatile int j = 0;
  10395c:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)

  // Send INIT interrupt to reset other CPU.
  lapic[ICRHI] = apicid<<24;
  103963:	a1 f8 cb 13 00       	mov    0x13cbf8,%eax
  103968:	8d 90 10 03 00 00    	lea    0x310(%eax),%edx
  10396e:	0f b6 45 ec          	movzbl 0xffffffec(%ebp),%eax
  103972:	c1 e0 18             	shl    $0x18,%eax
  103975:	89 02                	mov    %eax,(%edx)
  lapic[ICRLO] = INIT | LEVEL;
  103977:	a1 f8 cb 13 00       	mov    0x13cbf8,%eax
  10397c:	05 00 03 00 00       	add    $0x300,%eax
  103981:	c7 00 00 85 00 00    	movl   $0x8500,(%eax)
  microdelay(10);
  103987:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
  10398e:	e8 7d ff ff ff       	call   103910 <microdelay>
  
  // Send startup IPI (twice!) to enter bootstrap code.
  for(i = 0; i < 2; i++){
  103993:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
  10399a:	eb 4a                	jmp    1039e6 <lapic_startap+0x96>
    lapic[ICRHI] = apicid<<24;
  10399c:	a1 f8 cb 13 00       	mov    0x13cbf8,%eax
  1039a1:	8d 90 10 03 00 00    	lea    0x310(%eax),%edx
  1039a7:	0f b6 45 ec          	movzbl 0xffffffec(%ebp),%eax
  1039ab:	c1 e0 18             	shl    $0x18,%eax
  1039ae:	89 02                	mov    %eax,(%edx)
    lapic[ICRLO] = STARTUP | (addr>>12);
  1039b0:	a1 f8 cb 13 00       	mov    0x13cbf8,%eax
  1039b5:	8d 90 00 03 00 00    	lea    0x300(%eax),%edx
  1039bb:	8b 45 0c             	mov    0xc(%ebp),%eax
  1039be:	c1 e8 0c             	shr    $0xc,%eax
  1039c1:	80 cc 06             	or     $0x6,%ah
  1039c4:	89 02                	mov    %eax,(%edx)
    for(j=0; j<10000; j++);  // 200us
  1039c6:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)
  1039cd:	eb 09                	jmp    1039d8 <lapic_startap+0x88>
  1039cf:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1039d2:	83 c0 01             	add    $0x1,%eax
  1039d5:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  1039d8:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1039db:	3d 0f 27 00 00       	cmp    $0x270f,%eax
  1039e0:	7e ed                	jle    1039cf <lapic_startap+0x7f>
  1039e2:	83 45 fc 01          	addl   $0x1,0xfffffffc(%ebp)
  1039e6:	83 7d fc 01          	cmpl   $0x1,0xfffffffc(%ebp)
  1039ea:	7e b0                	jle    10399c <lapic_startap+0x4c>
  }
}
  1039ec:	c9                   	leave  
  1039ed:	c3                   	ret    
  1039ee:	90                   	nop    
  1039ef:	90                   	nop    

001039f0 <main>:

// Bootstrap processor starts running C code here.
int
main(void)
{
  1039f0:	8d 4c 24 04          	lea    0x4(%esp),%ecx
  1039f4:	83 e4 f0             	and    $0xfffffff0,%esp
  1039f7:	ff 71 fc             	pushl  0xfffffffc(%ecx)
  1039fa:	55                   	push   %ebp
  1039fb:	89 e5                	mov    %esp,%ebp
  1039fd:	51                   	push   %ecx
  1039fe:	83 ec 24             	sub    $0x24,%esp
  int i;
  static volatile int bcpu;  // cannot be on stack
  extern char edata[], end[];

  // clear BSS
  memset(edata, 0, end - edata);
  103a01:	ba 70 16 14 00       	mov    $0x141670,%edx
  103a06:	b8 f2 cc 11 00       	mov    $0x11ccf2,%eax
  103a0b:	89 d1                	mov    %edx,%ecx
  103a0d:	29 c1                	sub    %eax,%ecx
  103a0f:	89 c8                	mov    %ecx,%eax
  103a11:	89 44 24 08          	mov    %eax,0x8(%esp)
  103a15:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  103a1c:	00 
  103a1d:	c7 04 24 f2 cc 11 00 	movl   $0x11ccf2,(%esp)
  103a24:	e8 d7 24 00 00       	call   105f00 <memset>

  // Prevent release() from enabling interrupts.
  for(i=0; i<NCPU; i++)
  103a29:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)
  103a30:	eb 17                	jmp    103a49 <main+0x59>
    cpus[i].nlock = 1;
  103a32:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  103a35:	69 c0 ec 10 00 00    	imul   $0x10ec,%eax,%eax
  103a3b:	c7 80 e0 dc 13 00 01 	movl   $0x1,0x13dce0(%eax)
  103a42:	00 00 00 
  103a45:	83 45 f8 01          	addl   $0x1,0xfffffff8(%ebp)
  103a49:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  103a4d:	7e e3                	jle    103a32 <main+0x42>

//  mp_init(); // collect info about this machine
  bcpu = mp_bcpu();
  103a4f:	e8 1c 03 00 00       	call   103d70 <mp_bcpu>
  103a54:	a3 a0 cd 11 00       	mov    %eax,0x11cda0

  // Switch to bootstrap processor's stack
  asm volatile("movl %0, %%esp" : : "r" (cpus[bcpu].mpstack+MPSTACK-32));
  103a59:	a1 a0 cd 11 00       	mov    0x11cda0,%eax
  103a5e:	69 c0 ec 10 00 00    	imul   $0x10ec,%eax,%eax
  103a64:	05 b0 00 00 00       	add    $0xb0,%eax
  103a69:	05 20 cc 13 00       	add    $0x13cc20,%eax
  103a6e:	83 c0 0c             	add    $0xc,%eax
  103a71:	05 e0 0f 00 00       	add    $0xfe0,%eax
  103a76:	89 c4                	mov    %eax,%esp
  asm volatile("movl %0, %%ebp" : : "r" (cpus[bcpu].mpstack+MPSTACK));
  103a78:	a1 a0 cd 11 00       	mov    0x11cda0,%eax
  103a7d:	69 c0 ec 10 00 00    	imul   $0x10ec,%eax,%eax
  103a83:	05 b0 00 00 00       	add    $0xb0,%eax
  103a88:	05 20 cc 13 00       	add    $0x13cc20,%eax
  103a8d:	83 c0 0c             	add    $0xc,%eax
  103a90:	05 00 10 00 00       	add    $0x1000,%eax
  103a95:	89 c5                	mov    %eax,%ebp

  lapic_init(bcpu);
  103a97:	a1 a0 cd 11 00       	mov    0x11cda0,%eax
  103a9c:	89 04 24             	mov    %eax,(%esp)
  103a9f:	e8 ec fc ff ff       	call   103790 <lapic_init>
  cprintf("\ncpu%d: starting xv6\n\n", cpu());
  103aa4:	e8 17 fe ff ff       	call   1038c0 <cpu>
  103aa9:	89 44 24 04          	mov    %eax,0x4(%esp)
  103aad:	c7 04 24 88 a5 11 00 	movl   $0x11a588,(%esp)
  103ab4:	e8 57 cc ff ff       	call   100710 <cprintf>

  pinit();         // process table
  103ab9:	e8 12 0d 00 00       	call   1047d0 <pinit>
  binit();         // buffer cache
  103abe:	e8 3d c5 ff ff       	call   100000 <binit>
  pic_init();      // interrupt controller
  103ac3:	e8 88 07 00 00       	call   104250 <pic_init>
  ioapic_init();   // another interrupt controller
  103ac8:	e8 e3 f6 ff ff       	call   1031b0 <ioapic_init>
  kinit();         // physical memory allocator
  103acd:	e8 ee f7 ff ff       	call   1032c0 <kinit>
  tvinit();        // trap vectors
  103ad2:	e8 f9 44 00 00       	call   107fd0 <tvinit>
  idtinit();       // interrupt descriptor table
  103ad7:	e8 74 46 00 00       	call   108150 <idtinit>
  fileinit();      // file table
  103adc:	e8 5f da ff ff       	call   101540 <fileinit>
  iinit();         // inode cache
  103ae1:	e8 9a e1 ff ff       	call   101c80 <iinit>
  setupsegs(0);    // segments & TSS
  103ae6:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  103aed:	e8 ae 0e 00 00       	call   1049a0 <setupsegs>
  console_init();  // I/O devices & their interrupts
  103af2:	e8 29 d4 ff ff       	call   100f20 <console_init>
  ide_init();      // disk
  103af7:	e8 54 f2 ff ff       	call   102d50 <ide_init>

  // lwIP init
  memp_init();
  103afc:	e8 5f ad 00 00       	call   10e860 <memp_init>
  mem_init();
  103b01:	e8 ea a8 00 00       	call   10e3f0 <mem_init>
  netif_init();
  103b06:	e8 25 b3 00 00       	call   10ee30 <netif_init>
  pbuf_init();
  103b0b:	e8 40 b3 00 00       	call   10ee50 <pbuf_init>
  tcpip_init(0, 0);
  103b10:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  103b17:	00 
  103b18:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  103b1f:	e8 dc 61 01 00       	call   119d00 <tcpip_init>

  pci_init();      // PCI
  103b24:	e8 b7 5d 00 00       	call   1098e0 <pci_init>
  bootothers();    // boot other CPUs
  103b29:	e8 92 01 00 00       	call   103cc0 <bootothers>
  if(!ismp)
  103b2e:	a1 00 cc 13 00       	mov    0x13cc00,%eax
  103b33:	85 c0                	test   %eax,%eax
  103b35:	75 05                	jne    103b3c <main+0x14c>
    timer_init(); // uniprocessor timer
  103b37:	e8 e4 43 00 00       	call   107f20 <timer_init>
  userinit();      // first user process
  103b3c:	e8 df 14 00 00       	call   105020 <userinit>

  // enable interrupts on this processor.
  cpus[cpu()].nlock--;
  103b41:	e8 7a fd ff ff       	call   1038c0 <cpu>
  103b46:	89 c1                	mov    %eax,%ecx
  103b48:	69 c1 ec 10 00 00    	imul   $0x10ec,%ecx,%eax
  103b4e:	8b 80 e0 dc 13 00    	mov    0x13dce0(%eax),%eax
  103b54:	8d 50 ff             	lea    0xffffffff(%eax),%edx
  103b57:	69 c1 ec 10 00 00    	imul   $0x10ec,%ecx,%eax
  103b5d:	89 90 e0 dc 13 00    	mov    %edx,0x13dce0(%eax)
  if (cpus[cpu()].nlock == 0)
  103b63:	e8 58 fd ff ff       	call   1038c0 <cpu>
  103b68:	69 c0 ec 10 00 00    	imul   $0x10ec,%eax,%eax
  103b6e:	8b 80 e0 dc 13 00    	mov    0x13dce0(%eax),%eax
  103b74:	85 c0                	test   %eax,%eax
  103b76:	75 05                	jne    103b7d <main+0x18d>
    sti();
  103b78:	e8 13 00 00 00       	call   103b90 <sti>

  scheduler();
  103b7d:	e8 1e 16 00 00       	call   1051a0 <scheduler>
  103b82:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi
  103b89:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00103b90 <sti>:
}

static inline void
sti(void)
{
  103b90:	55                   	push   %ebp
  103b91:	89 e5                	mov    %esp,%ebp
  asm volatile("sti");
  103b93:	fb                   	sti    
}
  103b94:	5d                   	pop    %ebp
  103b95:	c3                   	ret    
  103b96:	8d 76 00             	lea    0x0(%esi),%esi
  103b99:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00103ba0 <mpmain>:
}

// Additional processors start here.
static void
mpmain(void)
{
  103ba0:	55                   	push   %ebp
  103ba1:	89 e5                	mov    %esp,%ebp
  103ba3:	83 ec 18             	sub    $0x18,%esp
  cprintf("cpu%d: starting\n", cpu());
  103ba6:	e8 15 fd ff ff       	call   1038c0 <cpu>
  103bab:	89 44 24 04          	mov    %eax,0x4(%esp)
  103baf:	c7 04 24 9f a5 11 00 	movl   $0x11a59f,(%esp)
  103bb6:	e8 55 cb ff ff       	call   100710 <cprintf>
  idtinit();
  103bbb:	e8 90 45 00 00       	call   108150 <idtinit>
  lapic_init(cpu());
  103bc0:	e8 fb fc ff ff       	call   1038c0 <cpu>
  103bc5:	89 04 24             	mov    %eax,(%esp)
  103bc8:	e8 c3 fb ff ff       	call   103790 <lapic_init>
  setupsegs(0);
  103bcd:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  103bd4:	e8 c7 0d 00 00       	call   1049a0 <setupsegs>
  cpuid(0, 0, 0, 0, 0);  // memory barrier
  103bd9:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  103be0:	00 
  103be1:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  103be8:	00 
  103be9:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  103bf0:	00 
  103bf1:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  103bf8:	00 
  103bf9:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  103c00:	e8 5b 00 00 00       	call   103c60 <cpuid>
  cpus[cpu()].booted = 1;
  103c05:	e8 b6 fc ff ff       	call   1038c0 <cpu>
  103c0a:	69 c0 ec 10 00 00    	imul   $0x10ec,%eax,%eax
  103c10:	c7 80 dc dc 13 00 01 	movl   $0x1,0x13dcdc(%eax)
  103c17:	00 00 00 

  // Enable interrupts on this processor.
  cpus[cpu()].nlock--;
  103c1a:	e8 a1 fc ff ff       	call   1038c0 <cpu>
  103c1f:	89 c1                	mov    %eax,%ecx
  103c21:	69 c1 ec 10 00 00    	imul   $0x10ec,%ecx,%eax
  103c27:	8b 80 e0 dc 13 00    	mov    0x13dce0(%eax),%eax
  103c2d:	8d 50 ff             	lea    0xffffffff(%eax),%edx
  103c30:	69 c1 ec 10 00 00    	imul   $0x10ec,%ecx,%eax
  103c36:	89 90 e0 dc 13 00    	mov    %edx,0x13dce0(%eax)
  if (cpus[cpu()].nlock == 0)
  103c3c:	e8 7f fc ff ff       	call   1038c0 <cpu>
  103c41:	69 c0 ec 10 00 00    	imul   $0x10ec,%eax,%eax
  103c47:	8b 80 e0 dc 13 00    	mov    0x13dce0(%eax),%eax
  103c4d:	85 c0                	test   %eax,%eax
  103c4f:	75 05                	jne    103c56 <mpmain+0xb6>
    sti();
  103c51:	e8 3a ff ff ff       	call   103b90 <sti>

  scheduler();
  103c56:	e8 45 15 00 00       	call   1051a0 <scheduler>
  103c5b:	90                   	nop    
  103c5c:	8d 74 26 00          	lea    0x0(%esi),%esi

00103c60 <cpuid>:
}

static inline void
cpuid(uint info, uint *eaxp, uint *ebxp, uint *ecxp, uint *edxp)
{
  103c60:	55                   	push   %ebp
  103c61:	89 e5                	mov    %esp,%ebp
  103c63:	53                   	push   %ebx
  103c64:	83 ec 10             	sub    $0x10,%esp
  uint eax, ebx, ecx, edx;

  asm volatile("cpuid" :
  103c67:	8b 45 08             	mov    0x8(%ebp),%eax
  103c6a:	0f a2                	cpuid  
  103c6c:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  103c6f:	89 5d f0             	mov    %ebx,0xfffffff0(%ebp)
  103c72:	89 4d f4             	mov    %ecx,0xfffffff4(%ebp)
  103c75:	89 55 f8             	mov    %edx,0xfffffff8(%ebp)
               "=a" (eax), "=b" (ebx), "=c" (ecx), "=d" (edx) :
               "a" (info));
  if(eaxp)
  103c78:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  103c7c:	74 08                	je     103c86 <cpuid+0x26>
    *eaxp = eax;
  103c7e:	8b 55 0c             	mov    0xc(%ebp),%edx
  103c81:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  103c84:	89 02                	mov    %eax,(%edx)
  if(ebxp)
  103c86:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  103c8a:	74 08                	je     103c94 <cpuid+0x34>
    *ebxp = ebx;
  103c8c:	8b 55 10             	mov    0x10(%ebp),%edx
  103c8f:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  103c92:	89 02                	mov    %eax,(%edx)
  if(ecxp)
  103c94:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
  103c98:	74 08                	je     103ca2 <cpuid+0x42>
    *ecxp = ecx;
  103c9a:	8b 55 14             	mov    0x14(%ebp),%edx
  103c9d:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  103ca0:	89 02                	mov    %eax,(%edx)
  if(edxp)
  103ca2:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
  103ca6:	74 08                	je     103cb0 <cpuid+0x50>
    *edxp = edx;
  103ca8:	8b 55 18             	mov    0x18(%ebp),%edx
  103cab:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  103cae:	89 02                	mov    %eax,(%edx)
}
  103cb0:	83 c4 10             	add    $0x10,%esp
  103cb3:	5b                   	pop    %ebx
  103cb4:	5d                   	pop    %ebp
  103cb5:	c3                   	ret    
  103cb6:	8d 76 00             	lea    0x0(%esi),%esi
  103cb9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00103cc0 <bootothers>:
}

static void
bootothers(void)
{
  103cc0:	55                   	push   %ebp
  103cc1:	89 e5                	mov    %esp,%ebp
  103cc3:	83 ec 28             	sub    $0x28,%esp
  extern uchar _binary_bootother_start[], _binary_bootother_size[];
  uchar *code;
  struct cpu *c;

  // Write bootstrap code to unused memory at 0x7000.
  code = (uchar*)0x7000;
  103cc6:	c7 45 f8 00 70 00 00 	movl   $0x7000,0xfffffff8(%ebp)
  memmove(code, _binary_bootother_start, (uint)_binary_bootother_size);
  103ccd:	b8 5a 00 00 00       	mov    $0x5a,%eax
  103cd2:	89 44 24 08          	mov    %eax,0x8(%esp)
  103cd6:	c7 44 24 04 98 cc 11 	movl   $0x11cc98,0x4(%esp)
  103cdd:	00 
  103cde:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  103ce1:	89 04 24             	mov    %eax,(%esp)
  103ce4:	e8 a7 22 00 00       	call   105f90 <memmove>

  for(c = cpus; c < cpus+ncpu; c++){
  103ce9:	c7 45 fc 20 cc 13 00 	movl   $0x13cc20,0xfffffffc(%ebp)
  103cf0:	eb 66                	jmp    103d58 <bootothers+0x98>
    if(c == cpus+cpu())  // We've started already.
  103cf2:	e8 c9 fb ff ff       	call   1038c0 <cpu>
  103cf7:	69 c0 ec 10 00 00    	imul   $0x10ec,%eax,%eax
  103cfd:	05 20 cc 13 00       	add    $0x13cc20,%eax
  103d02:	3b 45 fc             	cmp    0xfffffffc(%ebp),%eax
  103d05:	74 4a                	je     103d51 <bootothers+0x91>
      continue;

    // Fill in %esp, %eip and start code on cpu.
    *(void**)(code-4) = c->mpstack + MPSTACK;
  103d07:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  103d0a:	83 e8 04             	sub    $0x4,%eax
  103d0d:	89 c2                	mov    %eax,%edx
  103d0f:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  103d12:	05 bc 00 00 00       	add    $0xbc,%eax
  103d17:	05 00 10 00 00       	add    $0x1000,%eax
  103d1c:	89 02                	mov    %eax,(%edx)
    *(void**)(code-8) = mpmain;
  103d1e:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  103d21:	83 e8 08             	sub    $0x8,%eax
  103d24:	c7 00 a0 3b 10 00    	movl   $0x103ba0,(%eax)
    lapic_startap(c->apicid, (uint)code);
  103d2a:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  103d2d:	89 c2                	mov    %eax,%edx
  103d2f:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  103d32:	0f b6 00             	movzbl (%eax),%eax
  103d35:	0f b6 c0             	movzbl %al,%eax
  103d38:	89 54 24 04          	mov    %edx,0x4(%esp)
  103d3c:	89 04 24             	mov    %eax,(%esp)
  103d3f:	e8 0c fc ff ff       	call   103950 <lapic_startap>

    // Wait for cpu to get through bootstrap.
    while(c->booted == 0)
  103d44:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  103d47:	8b 80 bc 10 00 00    	mov    0x10bc(%eax),%eax
  103d4d:	85 c0                	test   %eax,%eax
  103d4f:	74 f3                	je     103d44 <bootothers+0x84>
  103d51:	81 45 fc ec 10 00 00 	addl   $0x10ec,0xfffffffc(%ebp)
  103d58:	a1 0c dd 13 00       	mov    0x13dd0c,%eax
  103d5d:	69 c0 ec 10 00 00    	imul   $0x10ec,%eax,%eax
  103d63:	05 20 cc 13 00       	add    $0x13cc20,%eax
  103d68:	3b 45 fc             	cmp    0xfffffffc(%ebp),%eax
  103d6b:	77 85                	ja     103cf2 <bootothers+0x32>
      ;
  }
}
  103d6d:	c9                   	leave  
  103d6e:	c3                   	ret    
  103d6f:	90                   	nop    

00103d70 <mp_bcpu>:
uchar ioapic_id;

int
mp_bcpu(void)
{
  103d70:	55                   	push   %ebp
  103d71:	89 e5                	mov    %esp,%ebp
  return bcpu-cpus;
  103d73:	a1 a4 cd 11 00       	mov    0x11cda4,%eax
  103d78:	89 c2                	mov    %eax,%edx
  103d7a:	b8 20 cc 13 00       	mov    $0x13cc20,%eax
  103d7f:	89 d1                	mov    %edx,%ecx
  103d81:	29 c1                	sub    %eax,%ecx
  103d83:	89 c8                	mov    %ecx,%eax
  103d85:	c1 f8 02             	sar    $0x2,%eax
  103d88:	69 c0 f3 34 60 ab    	imul   $0xab6034f3,%eax,%eax
}
  103d8e:	5d                   	pop    %ebp
  103d8f:	c3                   	ret    

00103d90 <sum>:

static uchar
sum(uchar *addr, int len)
{
  103d90:	55                   	push   %ebp
  103d91:	89 e5                	mov    %esp,%ebp
  103d93:	83 ec 10             	sub    $0x10,%esp
  int i, sum;
  
  sum = 0;
  103d96:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
  for(i=0; i<len; i++)
  103d9d:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)
  103da4:	eb 13                	jmp    103db9 <sum+0x29>
    sum += addr[i];
  103da6:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  103da9:	03 45 08             	add    0x8(%ebp),%eax
  103dac:	0f b6 00             	movzbl (%eax),%eax
  103daf:	0f b6 c0             	movzbl %al,%eax
  103db2:	01 45 fc             	add    %eax,0xfffffffc(%ebp)
  103db5:	83 45 f8 01          	addl   $0x1,0xfffffff8(%ebp)
  103db9:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  103dbc:	3b 45 0c             	cmp    0xc(%ebp),%eax
  103dbf:	7c e5                	jl     103da6 <sum+0x16>
  return sum;
  103dc1:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  103dc4:	0f b6 c0             	movzbl %al,%eax
}
  103dc7:	c9                   	leave  
  103dc8:	c3                   	ret    
  103dc9:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

00103dd0 <mp_search1>:

// Look for an MP structure in the len bytes at addr.
static struct mp*
mp_search1(uchar *addr, int len)
{
  103dd0:	55                   	push   %ebp
  103dd1:	89 e5                	mov    %esp,%ebp
  103dd3:	83 ec 28             	sub    $0x28,%esp
  uchar *e, *p;

  e = addr+len;
  103dd6:	8b 45 0c             	mov    0xc(%ebp),%eax
  103dd9:	03 45 08             	add    0x8(%ebp),%eax
  103ddc:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  for(p = addr; p < e; p += sizeof(struct mp))
  103ddf:	8b 45 08             	mov    0x8(%ebp),%eax
  103de2:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  103de5:	eb 42                	jmp    103e29 <mp_search1+0x59>
    if(memcmp(p, "_MP_", 4) == 0 && sum(p, sizeof(struct mp)) == 0)
  103de7:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  103dee:	00 
  103def:	c7 44 24 04 b0 a5 11 	movl   $0x11a5b0,0x4(%esp)
  103df6:	00 
  103df7:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  103dfa:	89 04 24             	mov    %eax,(%esp)
  103dfd:	e8 2e 21 00 00       	call   105f30 <memcmp>
  103e02:	85 c0                	test   %eax,%eax
  103e04:	75 1f                	jne    103e25 <mp_search1+0x55>
  103e06:	c7 44 24 04 10 00 00 	movl   $0x10,0x4(%esp)
  103e0d:	00 
  103e0e:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  103e11:	89 04 24             	mov    %eax,(%esp)
  103e14:	e8 77 ff ff ff       	call   103d90 <sum>
  103e19:	84 c0                	test   %al,%al
  103e1b:	75 08                	jne    103e25 <mp_search1+0x55>
      return (struct mp*)p;
  103e1d:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  103e20:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  103e23:	eb 13                	jmp    103e38 <mp_search1+0x68>
  103e25:	83 45 fc 10          	addl   $0x10,0xfffffffc(%ebp)
  103e29:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  103e2c:	3b 45 f8             	cmp    0xfffffff8(%ebp),%eax
  103e2f:	72 b6                	jb     103de7 <mp_search1+0x17>
  return 0;
  103e31:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  103e38:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  103e3b:	c9                   	leave  
  103e3c:	c3                   	ret    
  103e3d:	8d 76 00             	lea    0x0(%esi),%esi

00103e40 <mp_search>:

// Search for the MP Floating Pointer Structure, which according to the
// spec is in one of the following three locations:
// 1) in the first KB of the EBDA;
// 2) in the last KB of system base memory;
// 3) in the BIOS ROM between 0xE0000 and 0xFFFFF.
static struct mp*
mp_search(void)
{
  103e40:	55                   	push   %ebp
  103e41:	89 e5                	mov    %esp,%ebp
  103e43:	83 ec 28             	sub    $0x28,%esp
  uchar *bda;
  uint p;
  struct mp *mp;

  bda = (uchar*)0x400;
  103e46:	c7 45 f4 00 04 00 00 	movl   $0x400,0xfffffff4(%ebp)
  if((p = (bda[0x0F]<<8)|bda[0x0E])){
  103e4d:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  103e50:	83 c0 0f             	add    $0xf,%eax
  103e53:	0f b6 00             	movzbl (%eax),%eax
  103e56:	0f b6 c0             	movzbl %al,%eax
  103e59:	89 c2                	mov    %eax,%edx
  103e5b:	c1 e2 08             	shl    $0x8,%edx
  103e5e:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  103e61:	83 c0 0e             	add    $0xe,%eax
  103e64:	0f b6 00             	movzbl (%eax),%eax
  103e67:	0f b6 c0             	movzbl %al,%eax
  103e6a:	09 d0                	or     %edx,%eax
  103e6c:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  103e6f:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  103e73:	74 24                	je     103e99 <mp_search+0x59>
    if((mp = mp_search1((uchar*)p, 1024)))
  103e75:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  103e78:	c7 44 24 04 00 04 00 	movl   $0x400,0x4(%esp)
  103e7f:	00 
  103e80:	89 04 24             	mov    %eax,(%esp)
  103e83:	e8 48 ff ff ff       	call   103dd0 <mp_search1>
  103e88:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  103e8b:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  103e8f:	74 56                	je     103ee7 <mp_search+0xa7>
      return mp;
  103e91:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  103e94:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  103e97:	eb 65                	jmp    103efe <mp_search+0xbe>
  } else {
    p = ((bda[0x14]<<8)|bda[0x13])*1024;
  103e99:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  103e9c:	83 c0 14             	add    $0x14,%eax
  103e9f:	0f b6 00             	movzbl (%eax),%eax
  103ea2:	0f b6 c0             	movzbl %al,%eax
  103ea5:	89 c2                	mov    %eax,%edx
  103ea7:	c1 e2 08             	shl    $0x8,%edx
  103eaa:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  103ead:	83 c0 13             	add    $0x13,%eax
  103eb0:	0f b6 00             	movzbl (%eax),%eax
  103eb3:	0f b6 c0             	movzbl %al,%eax
  103eb6:	09 d0                	or     %edx,%eax
  103eb8:	c1 e0 0a             	shl    $0xa,%eax
  103ebb:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
    if((mp = mp_search1((uchar*)p-1024, 1024)))
  103ebe:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  103ec1:	2d 00 04 00 00       	sub    $0x400,%eax
  103ec6:	c7 44 24 04 00 04 00 	movl   $0x400,0x4(%esp)
  103ecd:	00 
  103ece:	89 04 24             	mov    %eax,(%esp)
  103ed1:	e8 fa fe ff ff       	call   103dd0 <mp_search1>
  103ed6:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  103ed9:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  103edd:	74 08                	je     103ee7 <mp_search+0xa7>
      return mp;
  103edf:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  103ee2:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  103ee5:	eb 17                	jmp    103efe <mp_search+0xbe>
  }
  return mp_search1((uchar*)0xF0000, 0x10000);
  103ee7:	c7 44 24 04 00 00 01 	movl   $0x10000,0x4(%esp)
  103eee:	00 
  103eef:	c7 04 24 00 00 0f 00 	movl   $0xf0000,(%esp)
  103ef6:	e8 d5 fe ff ff       	call   103dd0 <mp_search1>
  103efb:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  103efe:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  103f01:	c9                   	leave  
  103f02:	c3                   	ret    
  103f03:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  103f09:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00103f10 <mp_config>:

// Search for an MP configuration table.  For now,
// don't accept the default configurations (physaddr == 0).
// Check for correct signature, calculate the checksum and,
// if correct, check the version.
// To do: check extended table checksum.
static struct mpconf*
mp_config(struct mp **pmp)
{
  103f10:	55                   	push   %ebp
  103f11:	89 e5                	mov    %esp,%ebp
  103f13:	83 ec 28             	sub    $0x28,%esp
  struct mpconf *conf;
  struct mp *mp;

  if((mp = mp_search()) == 0 || mp->physaddr == 0)
  103f16:	e8 25 ff ff ff       	call   103e40 <mp_search>
  103f1b:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  103f1e:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  103f22:	74 0a                	je     103f2e <mp_config+0x1e>
  103f24:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  103f27:	8b 40 04             	mov    0x4(%eax),%eax
  103f2a:	85 c0                	test   %eax,%eax
  103f2c:	75 0c                	jne    103f3a <mp_config+0x2a>
    return 0;
  103f2e:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  103f35:	e9 84 00 00 00       	jmp    103fbe <mp_config+0xae>
  conf = (struct mpconf*)mp->physaddr;
  103f3a:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  103f3d:	8b 40 04             	mov    0x4(%eax),%eax
  103f40:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  if(memcmp(conf, "PCMP", 4) != 0)
  103f43:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  103f4a:	00 
  103f4b:	c7 44 24 04 b5 a5 11 	movl   $0x11a5b5,0x4(%esp)
  103f52:	00 
  103f53:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  103f56:	89 04 24             	mov    %eax,(%esp)
  103f59:	e8 d2 1f 00 00       	call   105f30 <memcmp>
  103f5e:	85 c0                	test   %eax,%eax
  103f60:	74 09                	je     103f6b <mp_config+0x5b>
    return 0;
  103f62:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  103f69:	eb 53                	jmp    103fbe <mp_config+0xae>
  if(conf->version != 1 && conf->version != 4)
  103f6b:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  103f6e:	0f b6 40 06          	movzbl 0x6(%eax),%eax
  103f72:	3c 01                	cmp    $0x1,%al
  103f74:	74 14                	je     103f8a <mp_config+0x7a>
  103f76:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  103f79:	0f b6 40 06          	movzbl 0x6(%eax),%eax
  103f7d:	3c 04                	cmp    $0x4,%al
  103f7f:	74 09                	je     103f8a <mp_config+0x7a>
    return 0;
  103f81:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  103f88:	eb 34                	jmp    103fbe <mp_config+0xae>
  if(sum((uchar*)conf, conf->length) != 0)
  103f8a:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  103f8d:	0f b7 40 04          	movzwl 0x4(%eax),%eax
  103f91:	0f b7 c0             	movzwl %ax,%eax
  103f94:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  103f97:	89 44 24 04          	mov    %eax,0x4(%esp)
  103f9b:	89 14 24             	mov    %edx,(%esp)
  103f9e:	e8 ed fd ff ff       	call   103d90 <sum>
  103fa3:	84 c0                	test   %al,%al
  103fa5:	74 09                	je     103fb0 <mp_config+0xa0>
    return 0;
  103fa7:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  103fae:	eb 0e                	jmp    103fbe <mp_config+0xae>
  *pmp = mp;
  103fb0:	8b 55 08             	mov    0x8(%ebp),%edx
  103fb3:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  103fb6:	89 02                	mov    %eax,(%edx)
  return conf;
  103fb8:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  103fbb:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  103fbe:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  103fc1:	c9                   	leave  
  103fc2:	c3                   	ret    
  103fc3:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  103fc9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00103fd0 <mp_init>:

void
mp_init(void)
{
  103fd0:	55                   	push   %ebp
  103fd1:	89 e5                	mov    %esp,%ebp
  103fd3:	83 ec 38             	sub    $0x38,%esp
  uchar *p, *e;
  struct mp *mp;
  struct mpconf *conf;
  struct mpproc *proc;
  struct mpioapic *ioapic;

  bcpu = &cpus[ncpu];
  103fd6:	a1 0c dd 13 00       	mov    0x13dd0c,%eax
  103fdb:	69 c0 ec 10 00 00    	imul   $0x10ec,%eax,%eax
  103fe1:	05 20 cc 13 00       	add    $0x13cc20,%eax
  103fe6:	a3 a4 cd 11 00       	mov    %eax,0x11cda4
  if((conf = mp_config(&mp)) == 0)
  103feb:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
  103fee:	89 04 24             	mov    %eax,(%esp)
  103ff1:	e8 1a ff ff ff       	call   103f10 <mp_config>
  103ff6:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  103ff9:	83 7d f4 00          	cmpl   $0x0,0xfffffff4(%ebp)
  103ffd:	0f 84 42 01 00 00    	je     104145 <mp_init+0x175>
    return;

  ismp = 1;
  104003:	c7 05 00 cc 13 00 01 	movl   $0x1,0x13cc00
  10400a:	00 00 00 
  lapic = (uint*)conf->lapicaddr;
  10400d:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  104010:	8b 40 24             	mov    0x24(%eax),%eax
  104013:	a3 f8 cb 13 00       	mov    %eax,0x13cbf8

  for(p=(uchar*)(conf+1), e=(uchar*)conf+conf->length; p<e; ){
  104018:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10401b:	83 c0 2c             	add    $0x2c,%eax
  10401e:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  104021:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  104024:	0f b7 40 04          	movzwl 0x4(%eax),%eax
  104028:	0f b7 c0             	movzwl %ax,%eax
  10402b:	89 c2                	mov    %eax,%edx
  10402d:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  104030:	8d 04 02             	lea    (%edx,%eax,1),%eax
  104033:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
  104036:	e9 bd 00 00 00       	jmp    1040f8 <mp_init+0x128>
    switch(*p){
  10403b:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10403e:	0f b6 00             	movzbl (%eax),%eax
  104041:	0f b6 c0             	movzbl %al,%eax
  104044:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
  104047:	83 7d dc 04          	cmpl   $0x4,0xffffffdc(%ebp)
  10404b:	0f 87 82 00 00 00    	ja     1040d3 <mp_init+0x103>
  104051:	8b 55 dc             	mov    0xffffffdc(%ebp),%edx
  104054:	8b 04 95 e8 a5 11 00 	mov    0x11a5e8(,%edx,4),%eax
  10405b:	ff e0                	jmp    *%eax
    case MPPROC:
      proc = (struct mpproc*)p;
  10405d:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  104060:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
      cpus[ncpu].apicid = proc->apicid;
  104063:	8b 0d 0c dd 13 00    	mov    0x13dd0c,%ecx
  104069:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10406c:	0f b6 50 01          	movzbl 0x1(%eax),%edx
  104070:	69 c1 ec 10 00 00    	imul   $0x10ec,%ecx,%eax
  104076:	88 90 20 cc 13 00    	mov    %dl,0x13cc20(%eax)
      if(proc->flags & MPBOOT)
  10407c:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10407f:	0f b6 40 03          	movzbl 0x3(%eax),%eax
  104083:	0f b6 c0             	movzbl %al,%eax
  104086:	83 e0 02             	and    $0x2,%eax
  104089:	85 c0                	test   %eax,%eax
  10408b:	74 15                	je     1040a2 <mp_init+0xd2>
        bcpu = &cpus[ncpu];
  10408d:	a1 0c dd 13 00       	mov    0x13dd0c,%eax
  104092:	69 c0 ec 10 00 00    	imul   $0x10ec,%eax,%eax
  104098:	05 20 cc 13 00       	add    $0x13cc20,%eax
  10409d:	a3 a4 cd 11 00       	mov    %eax,0x11cda4
      ncpu++;
  1040a2:	a1 0c dd 13 00       	mov    0x13dd0c,%eax
  1040a7:	83 c0 01             	add    $0x1,%eax
  1040aa:	a3 0c dd 13 00       	mov    %eax,0x13dd0c
      p += sizeof(struct mpproc);
  1040af:	83 45 ec 14          	addl   $0x14,0xffffffec(%ebp)
      continue;
  1040b3:	eb 43                	jmp    1040f8 <mp_init+0x128>
    case MPIOAPIC:
      ioapic = (struct mpioapic*)p;
  1040b5:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  1040b8:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
      ioapic_id = ioapic->apicno;
  1040bb:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1040be:	0f b6 40 01          	movzbl 0x1(%eax),%eax
  1040c2:	a2 04 cc 13 00       	mov    %al,0x13cc04
      p += sizeof(struct mpioapic);
  1040c7:	83 45 ec 08          	addl   $0x8,0xffffffec(%ebp)
      continue;
  1040cb:	eb 2b                	jmp    1040f8 <mp_init+0x128>
    case MPBUS:
    case MPIOINTR:
    case MPLINTR:
      p += 8;
  1040cd:	83 45 ec 08          	addl   $0x8,0xffffffec(%ebp)
      continue;
  1040d1:	eb 25                	jmp    1040f8 <mp_init+0x128>
    default:
      cprintf("mp_init: unknown config type %x\n", *p);
  1040d3:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  1040d6:	0f b6 00             	movzbl (%eax),%eax
  1040d9:	0f b6 c0             	movzbl %al,%eax
  1040dc:	89 44 24 04          	mov    %eax,0x4(%esp)
  1040e0:	c7 04 24 bc a5 11 00 	movl   $0x11a5bc,(%esp)
  1040e7:	e8 24 c6 ff ff       	call   100710 <cprintf>
      panic("mp_init");
  1040ec:	c7 04 24 dd a5 11 00 	movl   $0x11a5dd,(%esp)
  1040f3:	e8 18 cf ff ff       	call   101010 <panic>
  1040f8:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  1040fb:	3b 45 f0             	cmp    0xfffffff0(%ebp),%eax
  1040fe:	0f 82 37 ff ff ff    	jb     10403b <mp_init+0x6b>
    }
  }

  if(mp->imcrp){
  104104:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  104107:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
  10410b:	84 c0                	test   %al,%al
  10410d:	74 36                	je     104145 <mp_init+0x175>
    // Bochs doesn't support IMCR, so this doesn't run on Bochs.
    // But it would on real hardware.
    outb(0x22, 0x70);   // Select IMCR
  10410f:	c7 44 24 04 70 00 00 	movl   $0x70,0x4(%esp)
  104116:	00 
  104117:	c7 04 24 22 00 00 00 	movl   $0x22,(%esp)
  10411e:	e8 4d 00 00 00       	call   104170 <outb>
    outb(0x23, inb(0x23) | 1);  // Mask external interrupts.
  104123:	c7 04 24 23 00 00 00 	movl   $0x23,(%esp)
  10412a:	e8 21 00 00 00       	call   104150 <inb>
  10412f:	83 c8 01             	or     $0x1,%eax
  104132:	0f b6 c0             	movzbl %al,%eax
  104135:	89 44 24 04          	mov    %eax,0x4(%esp)
  104139:	c7 04 24 23 00 00 00 	movl   $0x23,(%esp)
  104140:	e8 2b 00 00 00       	call   104170 <outb>
  }
}
  104145:	c9                   	leave  
  104146:	c3                   	ret    
  104147:	89 f6                	mov    %esi,%esi
  104149:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00104150 <inb>:
// Routines to let C code use special x86 instructions.

static inline uchar
inb(ushort port)
{
  104150:	55                   	push   %ebp
  104151:	89 e5                	mov    %esp,%ebp
  104153:	83 ec 14             	sub    $0x14,%esp
  104156:	8b 45 08             	mov    0x8(%ebp),%eax
  104159:	66 89 45 ec          	mov    %ax,0xffffffec(%ebp)
  uchar data;

  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
  10415d:	0f b7 55 ec          	movzwl 0xffffffec(%ebp),%edx
  104161:	ec                   	in     (%dx),%al
  104162:	88 45 ff             	mov    %al,0xffffffff(%ebp)
  return data;
  104165:	0f b6 45 ff          	movzbl 0xffffffff(%ebp),%eax
}
  104169:	c9                   	leave  
  10416a:	c3                   	ret    
  10416b:	90                   	nop    
  10416c:	8d 74 26 00          	lea    0x0(%esi),%esi

00104170 <outb>:

static inline uint
inl(ushort port)
{
    uint data;

    asm volatile("in %1,%0" : "=a" (data) : "d" (port));
    return data;
}

static inline ushort
inw(ushort port)
{
    ushort data;

    asm volatile("in %1,%0" : "=a" (data) : "d" (port));
    return data;
}

static inline void
insl(int port, void *addr, int cnt)
{
  asm volatile("cld\n\trepne\n\tinsl"     :
                   "=D" (addr), "=c" (cnt)    :
                   "d" (port), "0" (addr), "1" (cnt)  :
                   "memory", "cc");
}

static inline void
outb(ushort port, uchar data)
{
  104170:	55                   	push   %ebp
  104171:	89 e5                	mov    %esp,%ebp
  104173:	83 ec 08             	sub    $0x8,%esp
  104176:	8b 45 08             	mov    0x8(%ebp),%eax
  104179:	8b 55 0c             	mov    0xc(%ebp),%edx
  10417c:	66 89 45 fc          	mov    %ax,0xfffffffc(%ebp)
  104180:	88 55 f8             	mov    %dl,0xfffffff8(%ebp)
  asm volatile("out %0,%1" : : "a" (data), "d" (port));
  104183:	0f b6 45 f8          	movzbl 0xfffffff8(%ebp),%eax
  104187:	0f b7 55 fc          	movzwl 0xfffffffc(%ebp),%edx
  10418b:	ee                   	out    %al,(%dx)
}
  10418c:	c9                   	leave  
  10418d:	c3                   	ret    
  10418e:	90                   	nop    
  10418f:	90                   	nop    

00104190 <reg_irq_handler>:
static ushort irqmask = 0xFFFF & ~(1<<IRQ_SLAVE);

void
reg_irq_handler(int irq_num, irq_handler_t handler)
{
  104190:	55                   	push   %ebp
  104191:	89 e5                	mov    %esp,%ebp
    irq_handler[irq_num] = handler;
  104193:	8b 55 08             	mov    0x8(%ebp),%edx
  104196:	8b 45 0c             	mov    0xc(%ebp),%eax
  104199:	89 04 95 20 dd 13 00 	mov    %eax,0x13dd20(,%edx,4)
}
  1041a0:	5d                   	pop    %ebp
  1041a1:	c3                   	ret    
  1041a2:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi
  1041a9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

001041b0 <pic_setmask>:

static void
pic_setmask(ushort mask)
{
  1041b0:	55                   	push   %ebp
  1041b1:	89 e5                	mov    %esp,%ebp
  1041b3:	83 ec 18             	sub    $0x18,%esp
  1041b6:	8b 45 08             	mov    0x8(%ebp),%eax
  1041b9:	66 89 45 fc          	mov    %ax,0xfffffffc(%ebp)
  irqmask = mask;
  1041bd:	0f b7 45 fc          	movzwl 0xfffffffc(%ebp),%eax
  1041c1:	66 a3 f0 c5 11 00    	mov    %ax,0x11c5f0
  outb(IO_PIC1+1, mask);
  1041c7:	0f b7 45 fc          	movzwl 0xfffffffc(%ebp),%eax
  1041cb:	0f b6 c0             	movzbl %al,%eax
  1041ce:	89 44 24 04          	mov    %eax,0x4(%esp)
  1041d2:	c7 04 24 21 00 00 00 	movl   $0x21,(%esp)
  1041d9:	e8 22 00 00 00       	call   104200 <outb>
  outb(IO_PIC2+1, mask >> 8);
  1041de:	0f b7 45 fc          	movzwl 0xfffffffc(%ebp),%eax
  1041e2:	66 c1 e8 08          	shr    $0x8,%ax
  1041e6:	0f b6 c0             	movzbl %al,%eax
  1041e9:	89 44 24 04          	mov    %eax,0x4(%esp)
  1041ed:	c7 04 24 a1 00 00 00 	movl   $0xa1,(%esp)
  1041f4:	e8 07 00 00 00       	call   104200 <outb>
}
  1041f9:	c9                   	leave  
  1041fa:	c3                   	ret    
  1041fb:	90                   	nop    
  1041fc:	8d 74 26 00          	lea    0x0(%esi),%esi

00104200 <outb>:
}

static inline void
outb(ushort port, uchar data)
{
  104200:	55                   	push   %ebp
  104201:	89 e5                	mov    %esp,%ebp
  104203:	83 ec 08             	sub    $0x8,%esp
  104206:	8b 45 08             	mov    0x8(%ebp),%eax
  104209:	8b 55 0c             	mov    0xc(%ebp),%edx
  10420c:	66 89 45 fc          	mov    %ax,0xfffffffc(%ebp)
  104210:	88 55 f8             	mov    %dl,0xfffffff8(%ebp)
  asm volatile("out %0,%1" : : "a" (data), "d" (port));
  104213:	0f b6 45 f8          	movzbl 0xfffffff8(%ebp),%eax
  104217:	0f b7 55 fc          	movzwl 0xfffffffc(%ebp),%edx
  10421b:	ee                   	out    %al,(%dx)
}
  10421c:	c9                   	leave  
  10421d:	c3                   	ret    
  10421e:	89 f6                	mov    %esi,%esi

00104220 <pic_enable>:

void
pic_enable(int irq)
{
  104220:	55                   	push   %ebp
  104221:	89 e5                	mov    %esp,%ebp
  104223:	83 ec 08             	sub    $0x8,%esp
  pic_setmask(irqmask & ~(1<<irq));
  104226:	8b 4d 08             	mov    0x8(%ebp),%ecx
  104229:	b8 01 00 00 00       	mov    $0x1,%eax
  10422e:	d3 e0                	shl    %cl,%eax
  104230:	89 c2                	mov    %eax,%edx
  104232:	f7 d2                	not    %edx
  104234:	0f b7 05 f0 c5 11 00 	movzwl 0x11c5f0,%eax
  10423b:	21 d0                	and    %edx,%eax
  10423d:	0f b7 c0             	movzwl %ax,%eax
  104240:	89 04 24             	mov    %eax,(%esp)
  104243:	e8 68 ff ff ff       	call   1041b0 <pic_setmask>
}
  104248:	c9                   	leave  
  104249:	c3                   	ret    
  10424a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

00104250 <pic_init>:

// Initialize the 8259A interrupt controllers.
void
pic_init(void)
{
  104250:	55                   	push   %ebp
  104251:	89 e5                	mov    %esp,%ebp
  104253:	83 ec 18             	sub    $0x18,%esp
  // mask all interrupts
  outb(IO_PIC1+1, 0xFF);
  104256:	c7 44 24 04 ff 00 00 	movl   $0xff,0x4(%esp)
  10425d:	00 
  10425e:	c7 04 24 21 00 00 00 	movl   $0x21,(%esp)
  104265:	e8 96 ff ff ff       	call   104200 <outb>
  outb(IO_PIC2+1, 0xFF);
  10426a:	c7 44 24 04 ff 00 00 	movl   $0xff,0x4(%esp)
  104271:	00 
  104272:	c7 04 24 a1 00 00 00 	movl   $0xa1,(%esp)
  104279:	e8 82 ff ff ff       	call   104200 <outb>

  // Set up master (8259A-1)

  // ICW1:  0001g0hi
  //    g:  0 = edge triggering, 1 = level triggering
  //    h:  0 = cascaded PICs, 1 = master only
  //    i:  0 = no ICW4, 1 = ICW4 required
  outb(IO_PIC1, 0x11);
  10427e:	c7 44 24 04 11 00 00 	movl   $0x11,0x4(%esp)
  104285:	00 
  104286:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
  10428d:	e8 6e ff ff ff       	call   104200 <outb>

  // ICW2:  Vector offset
  outb(IO_PIC1+1, IRQ_OFFSET);
  104292:	c7 44 24 04 20 00 00 	movl   $0x20,0x4(%esp)
  104299:	00 
  10429a:	c7 04 24 21 00 00 00 	movl   $0x21,(%esp)
  1042a1:	e8 5a ff ff ff       	call   104200 <outb>

  // ICW3:  (master PIC) bit mask of IR lines connected to slaves
  //        (slave PIC) 3-bit # of slave's connection to master
  outb(IO_PIC1+1, 1<<IRQ_SLAVE);
  1042a6:	c7 44 24 04 04 00 00 	movl   $0x4,0x4(%esp)
  1042ad:	00 
  1042ae:	c7 04 24 21 00 00 00 	movl   $0x21,(%esp)
  1042b5:	e8 46 ff ff ff       	call   104200 <outb>

  // ICW4:  000nbmap
  //    n:  1 = special fully nested mode
  //    b:  1 = buffered mode
  //    m:  0 = slave PIC, 1 = master PIC
  //      (ignored when b is 0, as the master/slave role
  //      can be hardwired).
  //    a:  1 = Automatic EOI mode
  //    p:  0 = MCS-80/85 mode, 1 = intel x86 mode
  outb(IO_PIC1+1, 0x3);
  1042ba:	c7 44 24 04 03 00 00 	movl   $0x3,0x4(%esp)
  1042c1:	00 
  1042c2:	c7 04 24 21 00 00 00 	movl   $0x21,(%esp)
  1042c9:	e8 32 ff ff ff       	call   104200 <outb>

  // Set up slave (8259A-2)
  outb(IO_PIC2, 0x11);                  // ICW1
  1042ce:	c7 44 24 04 11 00 00 	movl   $0x11,0x4(%esp)
  1042d5:	00 
  1042d6:	c7 04 24 a0 00 00 00 	movl   $0xa0,(%esp)
  1042dd:	e8 1e ff ff ff       	call   104200 <outb>
  outb(IO_PIC2+1, IRQ_OFFSET + 8);      // ICW2
  1042e2:	c7 44 24 04 28 00 00 	movl   $0x28,0x4(%esp)
  1042e9:	00 
  1042ea:	c7 04 24 a1 00 00 00 	movl   $0xa1,(%esp)
  1042f1:	e8 0a ff ff ff       	call   104200 <outb>
  outb(IO_PIC2+1, IRQ_SLAVE);           // ICW3
  1042f6:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
  1042fd:	00 
  1042fe:	c7 04 24 a1 00 00 00 	movl   $0xa1,(%esp)
  104305:	e8 f6 fe ff ff       	call   104200 <outb>
  // NB Automatic EOI mode doesn't tend to work on the slave.
  // Linux source code says it's "to be investigated".
  outb(IO_PIC2+1, 0x3);                 // ICW4
  10430a:	c7 44 24 04 03 00 00 	movl   $0x3,0x4(%esp)
  104311:	00 
  104312:	c7 04 24 a1 00 00 00 	movl   $0xa1,(%esp)
  104319:	e8 e2 fe ff ff       	call   104200 <outb>

  // OCW3:  0ef01prs
  //   ef:  0x = NOP, 10 = clear specific mask, 11 = set specific mask
  //    p:  0 = no polling, 1 = polling mode
  //   rs:  0x = NOP, 10 = read IRR, 11 = read ISR
  outb(IO_PIC1, 0x68);             // clear specific mask
  10431e:	c7 44 24 04 68 00 00 	movl   $0x68,0x4(%esp)
  104325:	00 
  104326:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
  10432d:	e8 ce fe ff ff       	call   104200 <outb>
  outb(IO_PIC1, 0x0a);             // read IRR by default
  104332:	c7 44 24 04 0a 00 00 	movl   $0xa,0x4(%esp)
  104339:	00 
  10433a:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
  104341:	e8 ba fe ff ff       	call   104200 <outb>

  outb(IO_PIC2, 0x68);             // OCW3
  104346:	c7 44 24 04 68 00 00 	movl   $0x68,0x4(%esp)
  10434d:	00 
  10434e:	c7 04 24 a0 00 00 00 	movl   $0xa0,(%esp)
  104355:	e8 a6 fe ff ff       	call   104200 <outb>
  outb(IO_PIC2, 0x0a);             // OCW3
  10435a:	c7 44 24 04 0a 00 00 	movl   $0xa,0x4(%esp)
  104361:	00 
  104362:	c7 04 24 a0 00 00 00 	movl   $0xa0,(%esp)
  104369:	e8 92 fe ff ff       	call   104200 <outb>

  if(irqmask != 0xFFFF)
  10436e:	0f b7 05 f0 c5 11 00 	movzwl 0x11c5f0,%eax
  104375:	66 83 f8 ff          	cmp    $0xffffffff,%ax
  104379:	74 12                	je     10438d <pic_init+0x13d>
    pic_setmask(irqmask);
  10437b:	0f b7 05 f0 c5 11 00 	movzwl 0x11c5f0,%eax
  104382:	0f b7 c0             	movzwl %ax,%eax
  104385:	89 04 24             	mov    %eax,(%esp)
  104388:	e8 23 fe ff ff       	call   1041b0 <pic_setmask>
  memset(irq_handler, 0, sizeof(irq_handler));
  10438d:	c7 44 24 08 00 04 00 	movl   $0x400,0x8(%esp)
  104394:	00 
  104395:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  10439c:	00 
  10439d:	c7 04 24 20 dd 13 00 	movl   $0x13dd20,(%esp)
  1043a4:	e8 57 1b 00 00       	call   105f00 <memset>
}
  1043a9:	c9                   	leave  
  1043aa:	c3                   	ret    
  1043ab:	90                   	nop    
  1043ac:	90                   	nop    
  1043ad:	90                   	nop    
  1043ae:	90                   	nop    
  1043af:	90                   	nop    

001043b0 <pipealloc>:
};

int
pipealloc(struct file **f0, struct file **f1)
{
  1043b0:	55                   	push   %ebp
  1043b1:	89 e5                	mov    %esp,%ebp
  1043b3:	83 ec 28             	sub    $0x28,%esp
  struct pipe *p;

  p = 0;
  1043b6:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
  *f0 = *f1 = 0;
  1043bd:	8b 45 0c             	mov    0xc(%ebp),%eax
  1043c0:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  1043c6:	8b 45 0c             	mov    0xc(%ebp),%eax
  1043c9:	8b 10                	mov    (%eax),%edx
  1043cb:	8b 45 08             	mov    0x8(%ebp),%eax
  1043ce:	89 10                	mov    %edx,(%eax)
  if((*f0 = filealloc()) == 0 || (*f1 = filealloc()) == 0)
  1043d0:	e8 8b d1 ff ff       	call   101560 <filealloc>
  1043d5:	89 c2                	mov    %eax,%edx
  1043d7:	8b 45 08             	mov    0x8(%ebp),%eax
  1043da:	89 10                	mov    %edx,(%eax)
  1043dc:	8b 45 08             	mov    0x8(%ebp),%eax
  1043df:	8b 00                	mov    (%eax),%eax
  1043e1:	85 c0                	test   %eax,%eax
  1043e3:	0f 84 c8 00 00 00    	je     1044b1 <pipealloc+0x101>
  1043e9:	e8 72 d1 ff ff       	call   101560 <filealloc>
  1043ee:	89 c2                	mov    %eax,%edx
  1043f0:	8b 45 0c             	mov    0xc(%ebp),%eax
  1043f3:	89 10                	mov    %edx,(%eax)
  1043f5:	8b 45 0c             	mov    0xc(%ebp),%eax
  1043f8:	8b 00                	mov    (%eax),%eax
  1043fa:	85 c0                	test   %eax,%eax
  1043fc:	0f 84 af 00 00 00    	je     1044b1 <pipealloc+0x101>
    goto bad;
  if((p = (struct pipe*)kalloc(PAGE)) == 0)
  104402:	c7 04 24 00 10 00 00 	movl   $0x1000,(%esp)
  104409:	e8 92 f0 ff ff       	call   1034a0 <kalloc>
  10440e:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  104411:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  104415:	0f 84 96 00 00 00    	je     1044b1 <pipealloc+0x101>
    goto bad;
  p->readopen = 1;
  10441b:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10441e:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
  p->writeopen = 1;
  104424:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  104427:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
  p->writep = 0;
  10442e:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  104431:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
  p->readp = 0;
  104438:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10443b:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
  initlock(&p->lock, "pipe");
  104442:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  104445:	83 c0 10             	add    $0x10,%eax
  104448:	c7 44 24 04 fc a5 11 	movl   $0x11a5fc,0x4(%esp)
  10444f:	00 
  104450:	89 04 24             	mov    %eax,(%esp)
  104453:	e8 b8 16 00 00       	call   105b10 <initlock>
  (*f0)->type = FD_PIPE;
  104458:	8b 45 08             	mov    0x8(%ebp),%eax
  10445b:	8b 00                	mov    (%eax),%eax
  10445d:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
  (*f0)->readable = 1;
  104463:	8b 45 08             	mov    0x8(%ebp),%eax
  104466:	8b 00                	mov    (%eax),%eax
  104468:	c6 40 08 01          	movb   $0x1,0x8(%eax)
  (*f0)->writable = 0;
  10446c:	8b 45 08             	mov    0x8(%ebp),%eax
  10446f:	8b 00                	mov    (%eax),%eax
  104471:	c6 40 09 00          	movb   $0x0,0x9(%eax)
  (*f0)->pipe = p;
  104475:	8b 45 08             	mov    0x8(%ebp),%eax
  104478:	8b 10                	mov    (%eax),%edx
  10447a:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10447d:	89 42 0c             	mov    %eax,0xc(%edx)
  (*f1)->type = FD_PIPE;
  104480:	8b 45 0c             	mov    0xc(%ebp),%eax
  104483:	8b 00                	mov    (%eax),%eax
  104485:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
  (*f1)->readable = 0;
  10448b:	8b 45 0c             	mov    0xc(%ebp),%eax
  10448e:	8b 00                	mov    (%eax),%eax
  104490:	c6 40 08 00          	movb   $0x0,0x8(%eax)
  (*f1)->writable = 1;
  104494:	8b 45 0c             	mov    0xc(%ebp),%eax
  104497:	8b 00                	mov    (%eax),%eax
  104499:	c6 40 09 01          	movb   $0x1,0x9(%eax)
  (*f1)->pipe = p;
  10449d:	8b 45 0c             	mov    0xc(%ebp),%eax
  1044a0:	8b 10                	mov    (%eax),%edx
  1044a2:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1044a5:	89 42 0c             	mov    %eax,0xc(%edx)
  return 0;
  1044a8:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  1044af:	eb 62                	jmp    104513 <pipealloc+0x163>

 bad:
  if(p)
  1044b1:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  1044b5:	74 13                	je     1044ca <pipealloc+0x11a>
    kfree((char*)p, PAGE);
  1044b7:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1044ba:	c7 44 24 04 00 10 00 	movl   $0x1000,0x4(%esp)
  1044c1:	00 
  1044c2:	89 04 24             	mov    %eax,(%esp)
  1044c5:	e8 66 ee ff ff       	call   103330 <kfree>
  if(*f0){
  1044ca:	8b 45 08             	mov    0x8(%ebp),%eax
  1044cd:	8b 00                	mov    (%eax),%eax
  1044cf:	85 c0                	test   %eax,%eax
  1044d1:	74 18                	je     1044eb <pipealloc+0x13b>
    (*f0)->type = FD_NONE;
  1044d3:	8b 45 08             	mov    0x8(%ebp),%eax
  1044d6:	8b 00                	mov    (%eax),%eax
  1044d8:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    fileclose(*f0);
  1044de:	8b 45 08             	mov    0x8(%ebp),%eax
  1044e1:	8b 00                	mov    (%eax),%eax
  1044e3:	89 04 24             	mov    %eax,(%esp)
  1044e6:	e8 85 d1 ff ff       	call   101670 <fileclose>
  }
  if(*f1){
  1044eb:	8b 45 0c             	mov    0xc(%ebp),%eax
  1044ee:	8b 00                	mov    (%eax),%eax
  1044f0:	85 c0                	test   %eax,%eax
  1044f2:	74 18                	je     10450c <pipealloc+0x15c>
    (*f1)->type = FD_NONE;
  1044f4:	8b 45 0c             	mov    0xc(%ebp),%eax
  1044f7:	8b 00                	mov    (%eax),%eax
  1044f9:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    fileclose(*f1);
  1044ff:	8b 45 0c             	mov    0xc(%ebp),%eax
  104502:	8b 00                	mov    (%eax),%eax
  104504:	89 04 24             	mov    %eax,(%esp)
  104507:	e8 64 d1 ff ff       	call   101670 <fileclose>
  }
  return -1;
  10450c:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  104513:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  104516:	c9                   	leave  
  104517:	c3                   	ret    
  104518:	90                   	nop    
  104519:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

00104520 <pipeclose>:

void
pipeclose(struct pipe *p, int writable)
{
  104520:	55                   	push   %ebp
  104521:	89 e5                	mov    %esp,%ebp
  104523:	83 ec 08             	sub    $0x8,%esp
  acquire(&p->lock);
  104526:	8b 45 08             	mov    0x8(%ebp),%eax
  104529:	83 c0 10             	add    $0x10,%eax
  10452c:	89 04 24             	mov    %eax,(%esp)
  10452f:	e8 0c 16 00 00       	call   105b40 <acquire>
  if(writable){
  104534:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  104538:	74 1a                	je     104554 <pipeclose+0x34>
    p->writeopen = 0;
  10453a:	8b 45 08             	mov    0x8(%ebp),%eax
  10453d:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    wakeup(&p->readp);
  104544:	8b 45 08             	mov    0x8(%ebp),%eax
  104547:	83 c0 0c             	add    $0xc,%eax
  10454a:	89 04 24             	mov    %eax,(%esp)
  10454d:	e8 ce 10 00 00       	call   105620 <wakeup>
  104552:	eb 17                	jmp    10456b <pipeclose+0x4b>
  } else {
    p->readopen = 0;
  104554:	8b 45 08             	mov    0x8(%ebp),%eax
  104557:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    wakeup(&p->writep);
  10455d:	8b 45 08             	mov    0x8(%ebp),%eax
  104560:	83 c0 08             	add    $0x8,%eax
  104563:	89 04 24             	mov    %eax,(%esp)
  104566:	e8 b5 10 00 00       	call   105620 <wakeup>
  }
  release(&p->lock);
  10456b:	8b 45 08             	mov    0x8(%ebp),%eax
  10456e:	83 c0 10             	add    $0x10,%eax
  104571:	89 04 24             	mov    %eax,(%esp)
  104574:	e8 c7 17 00 00       	call   105d40 <release>

  if(p->readopen == 0 && p->writeopen == 0)
  104579:	8b 45 08             	mov    0x8(%ebp),%eax
  10457c:	8b 00                	mov    (%eax),%eax
  10457e:	85 c0                	test   %eax,%eax
  104580:	75 1d                	jne    10459f <pipeclose+0x7f>
  104582:	8b 45 08             	mov    0x8(%ebp),%eax
  104585:	8b 40 04             	mov    0x4(%eax),%eax
  104588:	85 c0                	test   %eax,%eax
  10458a:	75 13                	jne    10459f <pipeclose+0x7f>
    kfree((char*)p, PAGE);
  10458c:	8b 45 08             	mov    0x8(%ebp),%eax
  10458f:	c7 44 24 04 00 10 00 	movl   $0x1000,0x4(%esp)
  104596:	00 
  104597:	89 04 24             	mov    %eax,(%esp)
  10459a:	e8 91 ed ff ff       	call   103330 <kfree>
}
  10459f:	c9                   	leave  
  1045a0:	c3                   	ret    
  1045a1:	eb 0d                	jmp    1045b0 <pipewrite>
  1045a3:	90                   	nop    
  1045a4:	90                   	nop    
  1045a5:	90                   	nop    
  1045a6:	90                   	nop    
  1045a7:	90                   	nop    
  1045a8:	90                   	nop    
  1045a9:	90                   	nop    
  1045aa:	90                   	nop    
  1045ab:	90                   	nop    
  1045ac:	90                   	nop    
  1045ad:	90                   	nop    
  1045ae:	90                   	nop    
  1045af:	90                   	nop    

001045b0 <pipewrite>:

int
pipewrite(struct pipe *p, char *addr, int n)
{
  1045b0:	55                   	push   %ebp
  1045b1:	89 e5                	mov    %esp,%ebp
  1045b3:	83 ec 28             	sub    $0x28,%esp
  int i;

  acquire(&p->lock);
  1045b6:	8b 45 08             	mov    0x8(%ebp),%eax
  1045b9:	83 c0 10             	add    $0x10,%eax
  1045bc:	89 04 24             	mov    %eax,(%esp)
  1045bf:	e8 7c 15 00 00       	call   105b40 <acquire>
  for(i = 0; i < n; i++){
  1045c4:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
  1045cb:	e9 c8 00 00 00       	jmp    104698 <pipewrite+0xe8>
    while(((p->writep + 1) % PIPESIZE) == p->readp){
      if(p->readopen == 0 || cp->killed){
  1045d0:	8b 45 08             	mov    0x8(%ebp),%eax
  1045d3:	8b 00                	mov    (%eax),%eax
  1045d5:	85 c0                	test   %eax,%eax
  1045d7:	74 13                	je     1045ec <pipewrite+0x3c>
  1045d9:	e8 e2 f2 ff ff       	call   1038c0 <cpu>
  1045de:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  1045e5:	8b 40 1c             	mov    0x1c(%eax),%eax
  1045e8:	85 c0                	test   %eax,%eax
  1045ea:	74 1a                	je     104606 <pipewrite+0x56>
        release(&p->lock);
  1045ec:	8b 45 08             	mov    0x8(%ebp),%eax
  1045ef:	83 c0 10             	add    $0x10,%eax
  1045f2:	89 04 24             	mov    %eax,(%esp)
  1045f5:	e8 46 17 00 00       	call   105d40 <release>
        return -1;
  1045fa:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  104601:	e9 bc 00 00 00       	jmp    1046c2 <pipewrite+0x112>
      }
      wakeup(&p->readp);
  104606:	8b 45 08             	mov    0x8(%ebp),%eax
  104609:	83 c0 0c             	add    $0xc,%eax
  10460c:	89 04 24             	mov    %eax,(%esp)
  10460f:	e8 0c 10 00 00       	call   105620 <wakeup>
      sleep(&p->writep, &p->lock);
  104614:	8b 45 08             	mov    0x8(%ebp),%eax
  104617:	83 c0 10             	add    $0x10,%eax
  10461a:	8b 55 08             	mov    0x8(%ebp),%edx
  10461d:	83 c2 08             	add    $0x8,%edx
  104620:	89 44 24 04          	mov    %eax,0x4(%esp)
  104624:	89 14 24             	mov    %edx,(%esp)
  104627:	e8 64 0e 00 00       	call   105490 <sleep>
  10462c:	8b 45 08             	mov    0x8(%ebp),%eax
  10462f:	8b 40 08             	mov    0x8(%eax),%eax
  104632:	8d 50 01             	lea    0x1(%eax),%edx
  104635:	89 d0                	mov    %edx,%eax
  104637:	c1 f8 1f             	sar    $0x1f,%eax
  10463a:	89 c1                	mov    %eax,%ecx
  10463c:	c1 e9 17             	shr    $0x17,%ecx
  10463f:	8d 04 0a             	lea    (%edx,%ecx,1),%eax
  104642:	25 ff 01 00 00       	and    $0x1ff,%eax
  104647:	29 c8                	sub    %ecx,%eax
  104649:	89 c2                	mov    %eax,%edx
  10464b:	8b 45 08             	mov    0x8(%ebp),%eax
  10464e:	8b 40 0c             	mov    0xc(%eax),%eax
  104651:	39 c2                	cmp    %eax,%edx
  104653:	0f 84 77 ff ff ff    	je     1045d0 <pipewrite+0x20>
    }
    p->data[p->writep] = addr[i];
  104659:	8b 45 08             	mov    0x8(%ebp),%eax
  10465c:	8b 48 08             	mov    0x8(%eax),%ecx
  10465f:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  104662:	03 45 0c             	add    0xc(%ebp),%eax
  104665:	0f b6 10             	movzbl (%eax),%edx
  104668:	8b 45 08             	mov    0x8(%ebp),%eax
  10466b:	88 54 01 44          	mov    %dl,0x44(%ecx,%eax,1)
    p->writep = (p->writep + 1) % PIPESIZE;
  10466f:	8b 45 08             	mov    0x8(%ebp),%eax
  104672:	8b 40 08             	mov    0x8(%eax),%eax
  104675:	8d 50 01             	lea    0x1(%eax),%edx
  104678:	89 d0                	mov    %edx,%eax
  10467a:	c1 f8 1f             	sar    $0x1f,%eax
  10467d:	89 c1                	mov    %eax,%ecx
  10467f:	c1 e9 17             	shr    $0x17,%ecx
  104682:	8d 04 0a             	lea    (%edx,%ecx,1),%eax
  104685:	25 ff 01 00 00       	and    $0x1ff,%eax
  10468a:	29 c8                	sub    %ecx,%eax
  10468c:	89 c2                	mov    %eax,%edx
  10468e:	8b 45 08             	mov    0x8(%ebp),%eax
  104691:	89 50 08             	mov    %edx,0x8(%eax)
  104694:	83 45 fc 01          	addl   $0x1,0xfffffffc(%ebp)
  104698:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10469b:	3b 45 10             	cmp    0x10(%ebp),%eax
  10469e:	7c 8c                	jl     10462c <pipewrite+0x7c>
  }
  wakeup(&p->readp);
  1046a0:	8b 45 08             	mov    0x8(%ebp),%eax
  1046a3:	83 c0 0c             	add    $0xc,%eax
  1046a6:	89 04 24             	mov    %eax,(%esp)
  1046a9:	e8 72 0f 00 00       	call   105620 <wakeup>
  release(&p->lock);
  1046ae:	8b 45 08             	mov    0x8(%ebp),%eax
  1046b1:	83 c0 10             	add    $0x10,%eax
  1046b4:	89 04 24             	mov    %eax,(%esp)
  1046b7:	e8 84 16 00 00       	call   105d40 <release>
  return i;
  1046bc:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1046bf:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  1046c2:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  1046c5:	c9                   	leave  
  1046c6:	c3                   	ret    
  1046c7:	89 f6                	mov    %esi,%esi
  1046c9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

001046d0 <piperead>:

int
piperead(struct pipe *p, char *addr, int n)
{
  1046d0:	55                   	push   %ebp
  1046d1:	89 e5                	mov    %esp,%ebp
  1046d3:	83 ec 28             	sub    $0x28,%esp
  int i;

  acquire(&p->lock);
  1046d6:	8b 45 08             	mov    0x8(%ebp),%eax
  1046d9:	83 c0 10             	add    $0x10,%eax
  1046dc:	89 04 24             	mov    %eax,(%esp)
  1046df:	e8 5c 14 00 00       	call   105b40 <acquire>
  while(p->readp == p->writep && p->writeopen){
  1046e4:	eb 45                	jmp    10472b <piperead+0x5b>
    if(cp->killed){
  1046e6:	e8 d5 f1 ff ff       	call   1038c0 <cpu>
  1046eb:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  1046f2:	8b 40 1c             	mov    0x1c(%eax),%eax
  1046f5:	85 c0                	test   %eax,%eax
  1046f7:	74 1a                	je     104713 <piperead+0x43>
      release(&p->lock);
  1046f9:	8b 45 08             	mov    0x8(%ebp),%eax
  1046fc:	83 c0 10             	add    $0x10,%eax
  1046ff:	89 04 24             	mov    %eax,(%esp)
  104702:	e8 39 16 00 00       	call   105d40 <release>
      return -1;
  104707:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  10470e:	e9 b6 00 00 00       	jmp    1047c9 <piperead+0xf9>
    }
    sleep(&p->readp, &p->lock);
  104713:	8b 45 08             	mov    0x8(%ebp),%eax
  104716:	83 c0 10             	add    $0x10,%eax
  104719:	8b 55 08             	mov    0x8(%ebp),%edx
  10471c:	83 c2 0c             	add    $0xc,%edx
  10471f:	89 44 24 04          	mov    %eax,0x4(%esp)
  104723:	89 14 24             	mov    %edx,(%esp)
  104726:	e8 65 0d 00 00       	call   105490 <sleep>
  10472b:	8b 45 08             	mov    0x8(%ebp),%eax
  10472e:	8b 50 0c             	mov    0xc(%eax),%edx
  104731:	8b 45 08             	mov    0x8(%ebp),%eax
  104734:	8b 40 08             	mov    0x8(%eax),%eax
  104737:	39 c2                	cmp    %eax,%edx
  104739:	75 0a                	jne    104745 <piperead+0x75>
  10473b:	8b 45 08             	mov    0x8(%ebp),%eax
  10473e:	8b 40 04             	mov    0x4(%eax),%eax
  104741:	85 c0                	test   %eax,%eax
  104743:	75 a1                	jne    1046e6 <piperead+0x16>
  }
  for(i = 0; i < n; i++){
  104745:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
  10474c:	eb 51                	jmp    10479f <piperead+0xcf>
    if(p->readp == p->writep)
  10474e:	8b 45 08             	mov    0x8(%ebp),%eax
  104751:	8b 50 0c             	mov    0xc(%eax),%edx
  104754:	8b 45 08             	mov    0x8(%ebp),%eax
  104757:	8b 40 08             	mov    0x8(%eax),%eax
  10475a:	39 c2                	cmp    %eax,%edx
  10475c:	74 49                	je     1047a7 <piperead+0xd7>
      break;
    addr[i] = p->data[p->readp];
  10475e:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  104761:	89 c1                	mov    %eax,%ecx
  104763:	03 4d 0c             	add    0xc(%ebp),%ecx
  104766:	8b 45 08             	mov    0x8(%ebp),%eax
  104769:	8b 50 0c             	mov    0xc(%eax),%edx
  10476c:	8b 45 08             	mov    0x8(%ebp),%eax
  10476f:	0f b6 44 02 44       	movzbl 0x44(%edx,%eax,1),%eax
  104774:	88 01                	mov    %al,(%ecx)
    p->readp = (p->readp + 1) % PIPESIZE;
  104776:	8b 45 08             	mov    0x8(%ebp),%eax
  104779:	8b 40 0c             	mov    0xc(%eax),%eax
  10477c:	8d 50 01             	lea    0x1(%eax),%edx
  10477f:	89 d0                	mov    %edx,%eax
  104781:	c1 f8 1f             	sar    $0x1f,%eax
  104784:	89 c1                	mov    %eax,%ecx
  104786:	c1 e9 17             	shr    $0x17,%ecx
  104789:	8d 04 0a             	lea    (%edx,%ecx,1),%eax
  10478c:	25 ff 01 00 00       	and    $0x1ff,%eax
  104791:	29 c8                	sub    %ecx,%eax
  104793:	89 c2                	mov    %eax,%edx
  104795:	8b 45 08             	mov    0x8(%ebp),%eax
  104798:	89 50 0c             	mov    %edx,0xc(%eax)
  10479b:	83 45 fc 01          	addl   $0x1,0xfffffffc(%ebp)
  10479f:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1047a2:	3b 45 10             	cmp    0x10(%ebp),%eax
  1047a5:	7c a7                	jl     10474e <piperead+0x7e>
  }
  wakeup(&p->writep);
  1047a7:	8b 45 08             	mov    0x8(%ebp),%eax
  1047aa:	83 c0 08             	add    $0x8,%eax
  1047ad:	89 04 24             	mov    %eax,(%esp)
  1047b0:	e8 6b 0e 00 00       	call   105620 <wakeup>
  release(&p->lock);
  1047b5:	8b 45 08             	mov    0x8(%ebp),%eax
  1047b8:	83 c0 10             	add    $0x10,%eax
  1047bb:	89 04 24             	mov    %eax,(%esp)
  1047be:	e8 7d 15 00 00       	call   105d40 <release>
  return i;
  1047c3:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1047c6:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  1047c9:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  1047cc:	c9                   	leave  
  1047cd:	c3                   	ret    
  1047ce:	90                   	nop    
  1047cf:	90                   	nop    

001047d0 <pinit>:
extern void forkret1(struct trapframe*);

void
pinit(void)
{
  1047d0:	55                   	push   %ebp
  1047d1:	89 e5                	mov    %esp,%ebp
  1047d3:	83 ec 08             	sub    $0x8,%esp
  initlock(&proc_table_lock, "proc_table");
  1047d6:	c7 44 24 04 01 a6 11 	movl   $0x11a601,0x4(%esp)
  1047dd:	00 
  1047de:	c7 04 24 40 0c 14 00 	movl   $0x140c40,(%esp)
  1047e5:	e8 26 13 00 00       	call   105b10 <initlock>
}
  1047ea:	c9                   	leave  
  1047eb:	c3                   	ret    
  1047ec:	8d 74 26 00          	lea    0x0(%esi),%esi

001047f0 <allocproc>:

// Look in the process table for an UNUSED proc.
// If found, change state to EMBRYO and return it.
// Otherwise return 0.
struct proc*
allocproc(void)
{
  1047f0:	55                   	push   %ebp
  1047f1:	89 e5                	mov    %esp,%ebp
  1047f3:	83 ec 18             	sub    $0x18,%esp
  int i;
  struct proc *p;

  acquire(&proc_table_lock);
  1047f6:	c7 04 24 40 0c 14 00 	movl   $0x140c40,(%esp)
  1047fd:	e8 3e 13 00 00       	call   105b40 <acquire>
  for(i = 0; i < NPROC; i++){
  104802:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)
  104809:	eb 5e                	jmp    104869 <allocproc+0x79>
    p = &proc[i];
  10480b:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10480e:	69 c0 ac 00 00 00    	imul   $0xac,%eax,%eax
  104814:	05 20 e1 13 00       	add    $0x13e120,%eax
  104819:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
    if(p->state == UNUSED){
  10481c:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10481f:	8b 40 0c             	mov    0xc(%eax),%eax
  104822:	85 c0                	test   %eax,%eax
  104824:	75 3f                	jne    104865 <allocproc+0x75>
      p->state = EMBRYO;
  104826:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  104829:	c7 40 0c 01 00 00 00 	movl   $0x1,0xc(%eax)
      p->pid = nextpid++;
  104830:	8b 15 f4 c5 11 00    	mov    0x11c5f4,%edx
  104836:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  104839:	89 50 10             	mov    %edx,0x10(%eax)
  10483c:	8d 42 01             	lea    0x1(%edx),%eax
  10483f:	a3 f4 c5 11 00       	mov    %eax,0x11c5f4
      p->thr = 0;
  104844:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  104847:	c7 80 a8 00 00 00 00 	movl   $0x0,0xa8(%eax)
  10484e:	00 00 00 
      release(&proc_table_lock);
  104851:	c7 04 24 40 0c 14 00 	movl   $0x140c40,(%esp)
  104858:	e8 e3 14 00 00       	call   105d40 <release>
      return p;
  10485d:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  104860:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  104863:	eb 1d                	jmp    104882 <allocproc+0x92>
  104865:	83 45 f8 01          	addl   $0x1,0xfffffff8(%ebp)
  104869:	83 7d f8 3f          	cmpl   $0x3f,0xfffffff8(%ebp)
  10486d:	7e 9c                	jle    10480b <allocproc+0x1b>
    }
  }
  release(&proc_table_lock);
  10486f:	c7 04 24 40 0c 14 00 	movl   $0x140c40,(%esp)
  104876:	e8 c5 14 00 00       	call   105d40 <release>
  return 0;
  10487b:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  104882:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  104885:	c9                   	leave  
  104886:	c3                   	ret    
  104887:	89 f6                	mov    %esi,%esi
  104889:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00104890 <growproc>:

// Grow current process's memory by n bytes.
// Return old size on success, -1 on failure.
int
growproc(int n)
{
  104890:	55                   	push   %ebp
  104891:	89 e5                	mov    %esp,%ebp
  104893:	53                   	push   %ebx
  104894:	83 ec 24             	sub    $0x24,%esp
  char *newmem, *oldmem;

  newmem = kalloc(cp->sz + n);
  104897:	e8 24 f0 ff ff       	call   1038c0 <cpu>
  10489c:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  1048a3:	8b 50 04             	mov    0x4(%eax),%edx
  1048a6:	8b 45 08             	mov    0x8(%ebp),%eax
  1048a9:	8d 04 02             	lea    (%edx,%eax,1),%eax
  1048ac:	89 04 24             	mov    %eax,(%esp)
  1048af:	e8 ec eb ff ff       	call   1034a0 <kalloc>
  1048b4:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  if(newmem == 0)
  1048b7:	83 7d f4 00          	cmpl   $0x0,0xfffffff4(%ebp)
  1048bb:	75 0c                	jne    1048c9 <growproc+0x39>
    return -1;
  1048bd:	c7 45 e8 ff ff ff ff 	movl   $0xffffffff,0xffffffe8(%ebp)
  1048c4:	e9 cc 00 00 00       	jmp    104995 <growproc+0x105>
  memmove(newmem, cp->mem, cp->sz);
  1048c9:	e8 f2 ef ff ff       	call   1038c0 <cpu>
  1048ce:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  1048d5:	8b 58 04             	mov    0x4(%eax),%ebx
  1048d8:	e8 e3 ef ff ff       	call   1038c0 <cpu>
  1048dd:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  1048e4:	8b 00                	mov    (%eax),%eax
  1048e6:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  1048ea:	89 44 24 04          	mov    %eax,0x4(%esp)
  1048ee:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  1048f1:	89 04 24             	mov    %eax,(%esp)
  1048f4:	e8 97 16 00 00       	call   105f90 <memmove>
  memset(newmem + cp->sz, 0, n);
  1048f9:	8b 5d 08             	mov    0x8(%ebp),%ebx
  1048fc:	e8 bf ef ff ff       	call   1038c0 <cpu>
  104901:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  104908:	8b 40 04             	mov    0x4(%eax),%eax
  10490b:	03 45 f4             	add    0xfffffff4(%ebp),%eax
  10490e:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  104912:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  104919:	00 
  10491a:	89 04 24             	mov    %eax,(%esp)
  10491d:	e8 de 15 00 00       	call   105f00 <memset>
  oldmem = cp->mem;
  104922:	e8 99 ef ff ff       	call   1038c0 <cpu>
  104927:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  10492e:	8b 00                	mov    (%eax),%eax
  104930:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  cp->mem = newmem;
  104933:	e8 88 ef ff ff       	call   1038c0 <cpu>
  104938:	8b 14 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%edx
  10493f:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  104942:	89 02                	mov    %eax,(%edx)
  kfree(oldmem, cp->sz);
  104944:	e8 77 ef ff ff       	call   1038c0 <cpu>
  104949:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  104950:	8b 40 04             	mov    0x4(%eax),%eax
  104953:	89 44 24 04          	mov    %eax,0x4(%esp)
  104957:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10495a:	89 04 24             	mov    %eax,(%esp)
  10495d:	e8 ce e9 ff ff       	call   103330 <kfree>
  cp->sz += n;
  104962:	e8 59 ef ff ff       	call   1038c0 <cpu>
  104967:	8b 0c 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%ecx
  10496e:	8b 51 04             	mov    0x4(%ecx),%edx
  104971:	8b 45 08             	mov    0x8(%ebp),%eax
  104974:	8d 04 02             	lea    (%edx,%eax,1),%eax
  104977:	89 41 04             	mov    %eax,0x4(%ecx)
  return cp->sz - n;
  10497a:	e8 41 ef ff ff       	call   1038c0 <cpu>
  10497f:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  104986:	8b 50 04             	mov    0x4(%eax),%edx
  104989:	8b 45 08             	mov    0x8(%ebp),%eax
  10498c:	89 d1                	mov    %edx,%ecx
  10498e:	29 c1                	sub    %eax,%ecx
  104990:	89 c8                	mov    %ecx,%eax
  104992:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
  104995:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
}
  104998:	83 c4 24             	add    $0x24,%esp
  10499b:	5b                   	pop    %ebx
  10499c:	5d                   	pop    %ebp
  10499d:	c3                   	ret    
  10499e:	89 f6                	mov    %esi,%esi

001049a0 <setupsegs>:

// Set up CPU's segment descriptors and task state for a given process.
// If p==0, set up for "idle" state for when scheduler() is running.
void
setupsegs(struct proc *p)
{
  1049a0:	55                   	push   %ebp
  1049a1:	89 e5                	mov    %esp,%ebp
  1049a3:	57                   	push   %edi
  1049a4:	56                   	push   %esi
  1049a5:	53                   	push   %ebx
  1049a6:	83 ec 5c             	sub    $0x5c,%esp
  struct cpu *c;
  
  c = &cpus[cpu()];
  1049a9:	e8 12 ef ff ff       	call   1038c0 <cpu>
  1049ae:	69 c0 ec 10 00 00    	imul   $0x10ec,%eax,%eax
  1049b4:	05 20 cc 13 00       	add    $0x13cc20,%eax
  1049b9:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
  c->ts.ss0 = SEG_KDATA << 3;
  1049bc:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  1049bf:	66 c7 40 2c 10 00    	movw   $0x10,0x2c(%eax)
  if(p)
  1049c5:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  1049c9:	74 15                	je     1049e0 <setupsegs+0x40>
    c->ts.esp0 = (uint)(p->kstack + KSTACKSIZE);
  1049cb:	8b 45 08             	mov    0x8(%ebp),%eax
  1049ce:	8b 40 08             	mov    0x8(%eax),%eax
  1049d1:	05 00 10 00 00       	add    $0x1000,%eax
  1049d6:	89 c2                	mov    %eax,%edx
  1049d8:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  1049db:	89 50 28             	mov    %edx,0x28(%eax)
  1049de:	eb 0a                	jmp    1049ea <setupsegs+0x4a>
  else
    c->ts.esp0 = 0xffffffff;
  1049e0:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  1049e3:	c7 40 28 ff ff ff ff 	movl   $0xffffffff,0x28(%eax)

  c->gdt[0] = SEG_NULL;
  1049ea:	c7 45 b0 00 00 00 00 	movl   $0x0,0xffffffb0(%ebp)
  1049f1:	c7 45 b4 00 00 00 00 	movl   $0x0,0xffffffb4(%ebp)
  1049f8:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
  1049fb:	8b 45 b0             	mov    0xffffffb0(%ebp),%eax
  1049fe:	8b 55 b4             	mov    0xffffffb4(%ebp),%edx
  104a01:	89 81 8c 00 00 00    	mov    %eax,0x8c(%ecx)
  104a07:	89 91 90 00 00 00    	mov    %edx,0x90(%ecx)
  c->gdt[SEG_KCODE] = SEG(STA_X|STA_R, 0, 0x100000 + 64*1024-1, 0);
  104a0d:	66 c7 45 b8 0f 01    	movw   $0x10f,0xffffffb8(%ebp)
  104a13:	66 c7 45 ba 00 00    	movw   $0x0,0xffffffba(%ebp)
  104a19:	c6 45 bc 00          	movb   $0x0,0xffffffbc(%ebp)
  104a1d:	0f b6 45 bd          	movzbl 0xffffffbd(%ebp),%eax
  104a21:	83 e0 f0             	and    $0xfffffff0,%eax
  104a24:	83 c8 0a             	or     $0xa,%eax
  104a27:	88 45 bd             	mov    %al,0xffffffbd(%ebp)
  104a2a:	0f b6 45 bd          	movzbl 0xffffffbd(%ebp),%eax
  104a2e:	83 c8 10             	or     $0x10,%eax
  104a31:	88 45 bd             	mov    %al,0xffffffbd(%ebp)
  104a34:	0f b6 45 bd          	movzbl 0xffffffbd(%ebp),%eax
  104a38:	83 e0 9f             	and    $0xffffff9f,%eax
  104a3b:	88 45 bd             	mov    %al,0xffffffbd(%ebp)
  104a3e:	0f b6 45 bd          	movzbl 0xffffffbd(%ebp),%eax
  104a42:	83 c8 80             	or     $0xffffff80,%eax
  104a45:	88 45 bd             	mov    %al,0xffffffbd(%ebp)
  104a48:	0f b6 45 be          	movzbl 0xffffffbe(%ebp),%eax
  104a4c:	83 e0 f0             	and    $0xfffffff0,%eax
  104a4f:	88 45 be             	mov    %al,0xffffffbe(%ebp)
  104a52:	0f b6 45 be          	movzbl 0xffffffbe(%ebp),%eax
  104a56:	83 e0 ef             	and    $0xffffffef,%eax
  104a59:	88 45 be             	mov    %al,0xffffffbe(%ebp)
  104a5c:	0f b6 45 be          	movzbl 0xffffffbe(%ebp),%eax
  104a60:	83 e0 df             	and    $0xffffffdf,%eax
  104a63:	88 45 be             	mov    %al,0xffffffbe(%ebp)
  104a66:	0f b6 45 be          	movzbl 0xffffffbe(%ebp),%eax
  104a6a:	83 c8 40             	or     $0x40,%eax
  104a6d:	88 45 be             	mov    %al,0xffffffbe(%ebp)
  104a70:	0f b6 45 be          	movzbl 0xffffffbe(%ebp),%eax
  104a74:	83 c8 80             	or     $0xffffff80,%eax
  104a77:	88 45 be             	mov    %al,0xffffffbe(%ebp)
  104a7a:	c6 45 bf 00          	movb   $0x0,0xffffffbf(%ebp)
  104a7e:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
  104a81:	8b 45 b8             	mov    0xffffffb8(%ebp),%eax
  104a84:	8b 55 bc             	mov    0xffffffbc(%ebp),%edx
  104a87:	89 81 94 00 00 00    	mov    %eax,0x94(%ecx)
  104a8d:	89 91 98 00 00 00    	mov    %edx,0x98(%ecx)
  c->gdt[SEG_KDATA] = SEG(STA_W, 0, 0xffffffff, 0);
  104a93:	66 c7 45 c0 ff ff    	movw   $0xffff,0xffffffc0(%ebp)
  104a99:	66 c7 45 c2 00 00    	movw   $0x0,0xffffffc2(%ebp)
  104a9f:	c6 45 c4 00          	movb   $0x0,0xffffffc4(%ebp)
  104aa3:	0f b6 45 c5          	movzbl 0xffffffc5(%ebp),%eax
  104aa7:	83 e0 f0             	and    $0xfffffff0,%eax
  104aaa:	83 c8 02             	or     $0x2,%eax
  104aad:	88 45 c5             	mov    %al,0xffffffc5(%ebp)
  104ab0:	0f b6 45 c5          	movzbl 0xffffffc5(%ebp),%eax
  104ab4:	83 c8 10             	or     $0x10,%eax
  104ab7:	88 45 c5             	mov    %al,0xffffffc5(%ebp)
  104aba:	0f b6 45 c5          	movzbl 0xffffffc5(%ebp),%eax
  104abe:	83 e0 9f             	and    $0xffffff9f,%eax
  104ac1:	88 45 c5             	mov    %al,0xffffffc5(%ebp)
  104ac4:	0f b6 45 c5          	movzbl 0xffffffc5(%ebp),%eax
  104ac8:	83 c8 80             	or     $0xffffff80,%eax
  104acb:	88 45 c5             	mov    %al,0xffffffc5(%ebp)
  104ace:	0f b6 45 c6          	movzbl 0xffffffc6(%ebp),%eax
  104ad2:	83 c8 0f             	or     $0xf,%eax
  104ad5:	88 45 c6             	mov    %al,0xffffffc6(%ebp)
  104ad8:	0f b6 45 c6          	movzbl 0xffffffc6(%ebp),%eax
  104adc:	83 e0 ef             	and    $0xffffffef,%eax
  104adf:	88 45 c6             	mov    %al,0xffffffc6(%ebp)
  104ae2:	0f b6 45 c6          	movzbl 0xffffffc6(%ebp),%eax
  104ae6:	83 e0 df             	and    $0xffffffdf,%eax
  104ae9:	88 45 c6             	mov    %al,0xffffffc6(%ebp)
  104aec:	0f b6 45 c6          	movzbl 0xffffffc6(%ebp),%eax
  104af0:	83 c8 40             	or     $0x40,%eax
  104af3:	88 45 c6             	mov    %al,0xffffffc6(%ebp)
  104af6:	0f b6 45 c6          	movzbl 0xffffffc6(%ebp),%eax
  104afa:	83 c8 80             	or     $0xffffff80,%eax
  104afd:	88 45 c6             	mov    %al,0xffffffc6(%ebp)
  104b00:	c6 45 c7 00          	movb   $0x0,0xffffffc7(%ebp)
  104b04:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
  104b07:	8b 45 c0             	mov    0xffffffc0(%ebp),%eax
  104b0a:	8b 55 c4             	mov    0xffffffc4(%ebp),%edx
  104b0d:	89 81 9c 00 00 00    	mov    %eax,0x9c(%ecx)
  104b13:	89 91 a0 00 00 00    	mov    %edx,0xa0(%ecx)
  c->gdt[SEG_TSS] = SEG16(STS_T32A, (uint)&c->ts, sizeof(c->ts)-1, 0);
  104b19:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  104b1c:	83 c0 24             	add    $0x24,%eax
  104b1f:	89 c1                	mov    %eax,%ecx
  104b21:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  104b24:	83 c0 24             	add    $0x24,%eax
  104b27:	c1 e8 10             	shr    $0x10,%eax
  104b2a:	89 c2                	mov    %eax,%edx
  104b2c:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  104b2f:	83 c0 24             	add    $0x24,%eax
  104b32:	c1 e8 18             	shr    $0x18,%eax
  104b35:	89 c3                	mov    %eax,%ebx
  104b37:	66 c7 45 c8 67 00    	movw   $0x67,0xffffffc8(%ebp)
  104b3d:	66 89 4d ca          	mov    %cx,0xffffffca(%ebp)
  104b41:	88 55 cc             	mov    %dl,0xffffffcc(%ebp)
  104b44:	0f b6 45 cd          	movzbl 0xffffffcd(%ebp),%eax
  104b48:	83 e0 f0             	and    $0xfffffff0,%eax
  104b4b:	83 c8 09             	or     $0x9,%eax
  104b4e:	88 45 cd             	mov    %al,0xffffffcd(%ebp)
  104b51:	0f b6 45 cd          	movzbl 0xffffffcd(%ebp),%eax
  104b55:	83 c8 10             	or     $0x10,%eax
  104b58:	88 45 cd             	mov    %al,0xffffffcd(%ebp)
  104b5b:	0f b6 45 cd          	movzbl 0xffffffcd(%ebp),%eax
  104b5f:	83 e0 9f             	and    $0xffffff9f,%eax
  104b62:	88 45 cd             	mov    %al,0xffffffcd(%ebp)
  104b65:	0f b6 45 cd          	movzbl 0xffffffcd(%ebp),%eax
  104b69:	83 c8 80             	or     $0xffffff80,%eax
  104b6c:	88 45 cd             	mov    %al,0xffffffcd(%ebp)
  104b6f:	0f b6 45 ce          	movzbl 0xffffffce(%ebp),%eax
  104b73:	83 e0 f0             	and    $0xfffffff0,%eax
  104b76:	88 45 ce             	mov    %al,0xffffffce(%ebp)
  104b79:	0f b6 45 ce          	movzbl 0xffffffce(%ebp),%eax
  104b7d:	83 e0 ef             	and    $0xffffffef,%eax
  104b80:	88 45 ce             	mov    %al,0xffffffce(%ebp)
  104b83:	0f b6 45 ce          	movzbl 0xffffffce(%ebp),%eax
  104b87:	83 e0 df             	and    $0xffffffdf,%eax
  104b8a:	88 45 ce             	mov    %al,0xffffffce(%ebp)
  104b8d:	0f b6 45 ce          	movzbl 0xffffffce(%ebp),%eax
  104b91:	83 c8 40             	or     $0x40,%eax
  104b94:	88 45 ce             	mov    %al,0xffffffce(%ebp)
  104b97:	0f b6 45 ce          	movzbl 0xffffffce(%ebp),%eax
  104b9b:	83 e0 7f             	and    $0x7f,%eax
  104b9e:	88 45 ce             	mov    %al,0xffffffce(%ebp)
  104ba1:	88 5d cf             	mov    %bl,0xffffffcf(%ebp)
  104ba4:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
  104ba7:	8b 45 c8             	mov    0xffffffc8(%ebp),%eax
  104baa:	8b 55 cc             	mov    0xffffffcc(%ebp),%edx
  104bad:	89 81 b4 00 00 00    	mov    %eax,0xb4(%ecx)
  104bb3:	89 91 b8 00 00 00    	mov    %edx,0xb8(%ecx)
  c->gdt[SEG_TSS].s = 0;
  104bb9:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
  104bbc:	0f b6 82 b9 00 00 00 	movzbl 0xb9(%edx),%eax
  104bc3:	83 e0 ef             	and    $0xffffffef,%eax
  104bc6:	88 82 b9 00 00 00    	mov    %al,0xb9(%edx)
  if(p){
  104bcc:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  104bd0:	0f 84 96 01 00 00    	je     104d6c <setupsegs+0x3cc>
    c->gdt[SEG_UCODE] = SEG(STA_X|STA_R, (uint)p->mem, p->sz-1, DPL_USER);
  104bd6:	8b 45 08             	mov    0x8(%ebp),%eax
  104bd9:	8b 40 04             	mov    0x4(%eax),%eax
  104bdc:	83 e8 01             	sub    $0x1,%eax
  104bdf:	c1 e8 0c             	shr    $0xc,%eax
  104be2:	89 c2                	mov    %eax,%edx
  104be4:	8b 45 08             	mov    0x8(%ebp),%eax
  104be7:	8b 00                	mov    (%eax),%eax
  104be9:	89 c1                	mov    %eax,%ecx
  104beb:	8b 45 08             	mov    0x8(%ebp),%eax
  104bee:	8b 00                	mov    (%eax),%eax
  104bf0:	c1 e8 10             	shr    $0x10,%eax
  104bf3:	89 c3                	mov    %eax,%ebx
  104bf5:	8b 45 08             	mov    0x8(%ebp),%eax
  104bf8:	8b 40 04             	mov    0x4(%eax),%eax
  104bfb:	83 e8 01             	sub    $0x1,%eax
  104bfe:	c1 e8 1c             	shr    $0x1c,%eax
  104c01:	88 45 a3             	mov    %al,0xffffffa3(%ebp)
  104c04:	0f b6 45 a3          	movzbl 0xffffffa3(%ebp),%eax
  104c08:	83 e0 0f             	and    $0xf,%eax
  104c0b:	89 c6                	mov    %eax,%esi
  104c0d:	8b 45 08             	mov    0x8(%ebp),%eax
  104c10:	8b 00                	mov    (%eax),%eax
  104c12:	c1 e8 18             	shr    $0x18,%eax
  104c15:	89 c7                	mov    %eax,%edi
  104c17:	66 89 55 d0          	mov    %dx,0xffffffd0(%ebp)
  104c1b:	66 89 4d d2          	mov    %cx,0xffffffd2(%ebp)
  104c1f:	88 5d d4             	mov    %bl,0xffffffd4(%ebp)
  104c22:	0f b6 45 d5          	movzbl 0xffffffd5(%ebp),%eax
  104c26:	83 e0 f0             	and    $0xfffffff0,%eax
  104c29:	83 c8 0a             	or     $0xa,%eax
  104c2c:	88 45 d5             	mov    %al,0xffffffd5(%ebp)
  104c2f:	0f b6 45 d5          	movzbl 0xffffffd5(%ebp),%eax
  104c33:	83 c8 10             	or     $0x10,%eax
  104c36:	88 45 d5             	mov    %al,0xffffffd5(%ebp)
  104c39:	0f b6 45 d5          	movzbl 0xffffffd5(%ebp),%eax
  104c3d:	83 c8 60             	or     $0x60,%eax
  104c40:	88 45 d5             	mov    %al,0xffffffd5(%ebp)
  104c43:	0f b6 45 d5          	movzbl 0xffffffd5(%ebp),%eax
  104c47:	83 c8 80             	or     $0xffffff80,%eax
  104c4a:	88 45 d5             	mov    %al,0xffffffd5(%ebp)
  104c4d:	89 f2                	mov    %esi,%edx
  104c4f:	83 e2 0f             	and    $0xf,%edx
  104c52:	0f b6 45 d6          	movzbl 0xffffffd6(%ebp),%eax
  104c56:	83 e0 f0             	and    $0xfffffff0,%eax
  104c59:	09 d0                	or     %edx,%eax
  104c5b:	88 45 d6             	mov    %al,0xffffffd6(%ebp)
  104c5e:	0f b6 45 d6          	movzbl 0xffffffd6(%ebp),%eax
  104c62:	83 e0 ef             	and    $0xffffffef,%eax
  104c65:	88 45 d6             	mov    %al,0xffffffd6(%ebp)
  104c68:	0f b6 45 d6          	movzbl 0xffffffd6(%ebp),%eax
  104c6c:	83 e0 df             	and    $0xffffffdf,%eax
  104c6f:	88 45 d6             	mov    %al,0xffffffd6(%ebp)
  104c72:	0f b6 45 d6          	movzbl 0xffffffd6(%ebp),%eax
  104c76:	83 c8 40             	or     $0x40,%eax
  104c79:	88 45 d6             	mov    %al,0xffffffd6(%ebp)
  104c7c:	0f b6 45 d6          	movzbl 0xffffffd6(%ebp),%eax
  104c80:	83 c8 80             	or     $0xffffff80,%eax
  104c83:	88 45 d6             	mov    %al,0xffffffd6(%ebp)
  104c86:	89 f8                	mov    %edi,%eax
  104c88:	88 45 d7             	mov    %al,0xffffffd7(%ebp)
  104c8b:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
  104c8e:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
  104c91:	8b 55 d4             	mov    0xffffffd4(%ebp),%edx
  104c94:	89 81 a4 00 00 00    	mov    %eax,0xa4(%ecx)
  104c9a:	89 91 a8 00 00 00    	mov    %edx,0xa8(%ecx)
    c->gdt[SEG_UDATA] = SEG(STA_W, (uint)p->mem, p->sz-1, DPL_USER);
  104ca0:	8b 45 08             	mov    0x8(%ebp),%eax
  104ca3:	8b 40 04             	mov    0x4(%eax),%eax
  104ca6:	83 e8 01             	sub    $0x1,%eax
  104ca9:	c1 e8 0c             	shr    $0xc,%eax
  104cac:	89 c2                	mov    %eax,%edx
  104cae:	8b 45 08             	mov    0x8(%ebp),%eax
  104cb1:	8b 00                	mov    (%eax),%eax
  104cb3:	89 c1                	mov    %eax,%ecx
  104cb5:	8b 45 08             	mov    0x8(%ebp),%eax
  104cb8:	8b 00                	mov    (%eax),%eax
  104cba:	c1 e8 10             	shr    $0x10,%eax
  104cbd:	89 c3                	mov    %eax,%ebx
  104cbf:	8b 45 08             	mov    0x8(%ebp),%eax
  104cc2:	8b 40 04             	mov    0x4(%eax),%eax
  104cc5:	83 e8 01             	sub    $0x1,%eax
  104cc8:	c1 e8 1c             	shr    $0x1c,%eax
  104ccb:	88 45 a3             	mov    %al,0xffffffa3(%ebp)
  104cce:	0f b6 45 a3          	movzbl 0xffffffa3(%ebp),%eax
  104cd2:	83 e0 0f             	and    $0xf,%eax
  104cd5:	89 c6                	mov    %eax,%esi
  104cd7:	8b 45 08             	mov    0x8(%ebp),%eax
  104cda:	8b 00                	mov    (%eax),%eax
  104cdc:	c1 e8 18             	shr    $0x18,%eax
  104cdf:	89 c7                	mov    %eax,%edi
  104ce1:	66 89 55 d8          	mov    %dx,0xffffffd8(%ebp)
  104ce5:	66 89 4d da          	mov    %cx,0xffffffda(%ebp)
  104ce9:	88 5d dc             	mov    %bl,0xffffffdc(%ebp)
  104cec:	0f b6 45 dd          	movzbl 0xffffffdd(%ebp),%eax
  104cf0:	83 e0 f0             	and    $0xfffffff0,%eax
  104cf3:	83 c8 02             	or     $0x2,%eax
  104cf6:	88 45 dd             	mov    %al,0xffffffdd(%ebp)
  104cf9:	0f b6 45 dd          	movzbl 0xffffffdd(%ebp),%eax
  104cfd:	83 c8 10             	or     $0x10,%eax
  104d00:	88 45 dd             	mov    %al,0xffffffdd(%ebp)
  104d03:	0f b6 45 dd          	movzbl 0xffffffdd(%ebp),%eax
  104d07:	83 c8 60             	or     $0x60,%eax
  104d0a:	88 45 dd             	mov    %al,0xffffffdd(%ebp)
  104d0d:	0f b6 45 dd          	movzbl 0xffffffdd(%ebp),%eax
  104d11:	83 c8 80             	or     $0xffffff80,%eax
  104d14:	88 45 dd             	mov    %al,0xffffffdd(%ebp)
  104d17:	89 f2                	mov    %esi,%edx
  104d19:	83 e2 0f             	and    $0xf,%edx
  104d1c:	0f b6 45 de          	movzbl 0xffffffde(%ebp),%eax
  104d20:	83 e0 f0             	and    $0xfffffff0,%eax
  104d23:	09 d0                	or     %edx,%eax
  104d25:	88 45 de             	mov    %al,0xffffffde(%ebp)
  104d28:	0f b6 45 de          	movzbl 0xffffffde(%ebp),%eax
  104d2c:	83 e0 ef             	and    $0xffffffef,%eax
  104d2f:	88 45 de             	mov    %al,0xffffffde(%ebp)
  104d32:	0f b6 45 de          	movzbl 0xffffffde(%ebp),%eax
  104d36:	83 e0 df             	and    $0xffffffdf,%eax
  104d39:	88 45 de             	mov    %al,0xffffffde(%ebp)
  104d3c:	0f b6 45 de          	movzbl 0xffffffde(%ebp),%eax
  104d40:	83 c8 40             	or     $0x40,%eax
  104d43:	88 45 de             	mov    %al,0xffffffde(%ebp)
  104d46:	0f b6 45 de          	movzbl 0xffffffde(%ebp),%eax
  104d4a:	83 c8 80             	or     $0xffffff80,%eax
  104d4d:	88 45 de             	mov    %al,0xffffffde(%ebp)
  104d50:	89 f8                	mov    %edi,%eax
  104d52:	88 45 df             	mov    %al,0xffffffdf(%ebp)
  104d55:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
  104d58:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  104d5b:	8b 55 dc             	mov    0xffffffdc(%ebp),%edx
  104d5e:	89 81 ac 00 00 00    	mov    %eax,0xac(%ecx)
  104d64:	89 91 b0 00 00 00    	mov    %edx,0xb0(%ecx)
  104d6a:	eb 46                	jmp    104db2 <setupsegs+0x412>
  } else {
    c->gdt[SEG_UCODE] = SEG_NULL;
  104d6c:	c7 45 e0 00 00 00 00 	movl   $0x0,0xffffffe0(%ebp)
  104d73:	c7 45 e4 00 00 00 00 	movl   $0x0,0xffffffe4(%ebp)
  104d7a:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
  104d7d:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  104d80:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
  104d83:	89 81 a4 00 00 00    	mov    %eax,0xa4(%ecx)
  104d89:	89 91 a8 00 00 00    	mov    %edx,0xa8(%ecx)
    c->gdt[SEG_UDATA] = SEG_NULL;
  104d8f:	c7 45 e8 00 00 00 00 	movl   $0x0,0xffffffe8(%ebp)
  104d96:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  104d9d:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
  104da0:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  104da3:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
  104da6:	89 81 ac 00 00 00    	mov    %eax,0xac(%ecx)
  104dac:	89 91 b0 00 00 00    	mov    %edx,0xb0(%ecx)
  }

  lgdt(c->gdt, sizeof(c->gdt));
  104db2:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  104db5:	05 8c 00 00 00       	add    $0x8c,%eax
  104dba:	c7 44 24 04 30 00 00 	movl   $0x30,0x4(%esp)
  104dc1:	00 
  104dc2:	89 04 24             	mov    %eax,(%esp)
  104dc5:	e8 16 00 00 00       	call   104de0 <lgdt>
  ltr(SEG_TSS << 3);
  104dca:	c7 04 24 28 00 00 00 	movl   $0x28,(%esp)
  104dd1:	e8 3a 00 00 00       	call   104e10 <ltr>
}
  104dd6:	83 c4 5c             	add    $0x5c,%esp
  104dd9:	5b                   	pop    %ebx
  104dda:	5e                   	pop    %esi
  104ddb:	5f                   	pop    %edi
  104ddc:	5d                   	pop    %ebp
  104ddd:	c3                   	ret    
  104dde:	89 f6                	mov    %esi,%esi

00104de0 <lgdt>:
struct segdesc;

static inline void
lgdt(struct segdesc *p, int size)
{
  104de0:	55                   	push   %ebp
  104de1:	89 e5                	mov    %esp,%ebp
  104de3:	83 ec 10             	sub    $0x10,%esp
  volatile ushort pd[3];

  pd[0] = size-1;
  104de6:	8b 45 0c             	mov    0xc(%ebp),%eax
  104de9:	83 e8 01             	sub    $0x1,%eax
  104dec:	66 89 45 fa          	mov    %ax,0xfffffffa(%ebp)
  pd[1] = (uint)p;
  104df0:	8b 45 08             	mov    0x8(%ebp),%eax
  104df3:	66 89 45 fc          	mov    %ax,0xfffffffc(%ebp)
  pd[2] = (uint)p >> 16;
  104df7:	8b 45 08             	mov    0x8(%ebp),%eax
  104dfa:	c1 e8 10             	shr    $0x10,%eax
  104dfd:	66 89 45 fe          	mov    %ax,0xfffffffe(%ebp)

  asm volatile("lgdt (%0)" : : "r" (pd));
  104e01:	8d 45 fa             	lea    0xfffffffa(%ebp),%eax
  104e04:	0f 01 10             	lgdtl  (%eax)
}
  104e07:	c9                   	leave  
  104e08:	c3                   	ret    
  104e09:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

00104e10 <ltr>:

struct gatedesc;

static inline void
lidt(struct gatedesc *p, int size)
{
  volatile ushort pd[3];

  pd[0] = size-1;
  pd[1] = (uint)p;
  pd[2] = (uint)p >> 16;

  asm volatile("lidt (%0)" : : "r" (pd));
}

static inline void
ltr(ushort sel)
{
  104e10:	55                   	push   %ebp
  104e11:	89 e5                	mov    %esp,%ebp
  104e13:	83 ec 04             	sub    $0x4,%esp
  104e16:	8b 45 08             	mov    0x8(%ebp),%eax
  104e19:	66 89 45 fc          	mov    %ax,0xfffffffc(%ebp)
  asm volatile("ltr %0" : : "r" (sel));
  104e1d:	0f b7 45 fc          	movzwl 0xfffffffc(%ebp),%eax
  104e21:	0f 00 d8             	ltr    %ax
}
  104e24:	c9                   	leave  
  104e25:	c3                   	ret    
  104e26:	8d 76 00             	lea    0x0(%esi),%esi
  104e29:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00104e30 <copyproc>:

// Create a new process copying p as the parent.
// Sets up stack to return as if from system call.
// Caller must set state of returned proc to RUNNABLE.
struct proc*
copyproc(struct proc *p)
{
  104e30:	55                   	push   %ebp
  104e31:	89 e5                	mov    %esp,%ebp
  104e33:	53                   	push   %ebx
  104e34:	83 ec 24             	sub    $0x24,%esp
  int i;
  struct proc *np;

  // Allocate process.
  if((np = allocproc()) == 0)
  104e37:	e8 b4 f9 ff ff       	call   1047f0 <allocproc>
  104e3c:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  104e3f:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  104e43:	75 0c                	jne    104e51 <copyproc+0x21>
    return 0;
  104e45:	c7 45 e8 00 00 00 00 	movl   $0x0,0xffffffe8(%ebp)
  104e4c:	e9 b9 01 00 00       	jmp    10500a <copyproc+0x1da>

  // Allocate kernel stack.
  if((np->kstack = kalloc(KSTACKSIZE)) == 0){
  104e51:	c7 04 24 00 10 00 00 	movl   $0x1000,(%esp)
  104e58:	e8 43 e6 ff ff       	call   1034a0 <kalloc>
  104e5d:	89 c2                	mov    %eax,%edx
  104e5f:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  104e62:	89 50 08             	mov    %edx,0x8(%eax)
  104e65:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  104e68:	8b 40 08             	mov    0x8(%eax),%eax
  104e6b:	85 c0                	test   %eax,%eax
  104e6d:	75 16                	jne    104e85 <copyproc+0x55>
    np->state = UNUSED;
  104e6f:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  104e72:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
    return 0;
  104e79:	c7 45 e8 00 00 00 00 	movl   $0x0,0xffffffe8(%ebp)
  104e80:	e9 85 01 00 00       	jmp    10500a <copyproc+0x1da>
  }
  np->tf = (struct trapframe*)(np->kstack + KSTACKSIZE) - 1;
  104e85:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  104e88:	8b 40 08             	mov    0x8(%eax),%eax
  104e8b:	8d 90 bc 0f 00 00    	lea    0xfbc(%eax),%edx
  104e91:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  104e94:	89 90 84 00 00 00    	mov    %edx,0x84(%eax)

  if(p){  // Copy process state from p.
  104e9a:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  104e9e:	0f 84 16 01 00 00    	je     104fba <copyproc+0x18a>
    np->parent = p;
  104ea4:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  104ea7:	8b 45 08             	mov    0x8(%ebp),%eax
  104eaa:	89 42 14             	mov    %eax,0x14(%edx)
    memmove(np->tf, p->tf, sizeof(*np->tf));
  104ead:	8b 45 08             	mov    0x8(%ebp),%eax
  104eb0:	8b 90 84 00 00 00    	mov    0x84(%eax),%edx
  104eb6:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  104eb9:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
  104ebf:	c7 44 24 08 44 00 00 	movl   $0x44,0x8(%esp)
  104ec6:	00 
  104ec7:	89 54 24 04          	mov    %edx,0x4(%esp)
  104ecb:	89 04 24             	mov    %eax,(%esp)
  104ece:	e8 bd 10 00 00       	call   105f90 <memmove>
  
    np->sz = p->sz;
  104ed3:	8b 45 08             	mov    0x8(%ebp),%eax
  104ed6:	8b 50 04             	mov    0x4(%eax),%edx
  104ed9:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  104edc:	89 50 04             	mov    %edx,0x4(%eax)
    if((np->mem = kalloc(np->sz)) == 0){
  104edf:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  104ee2:	8b 40 04             	mov    0x4(%eax),%eax
  104ee5:	89 04 24             	mov    %eax,(%esp)
  104ee8:	e8 b3 e5 ff ff       	call   1034a0 <kalloc>
  104eed:	89 c2                	mov    %eax,%edx
  104eef:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  104ef2:	89 10                	mov    %edx,(%eax)
  104ef4:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  104ef7:	8b 00                	mov    (%eax),%eax
  104ef9:	85 c0                	test   %eax,%eax
  104efb:	75 36                	jne    104f33 <copyproc+0x103>
      kfree(np->kstack, KSTACKSIZE);
  104efd:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  104f00:	8b 40 08             	mov    0x8(%eax),%eax
  104f03:	c7 44 24 04 00 10 00 	movl   $0x1000,0x4(%esp)
  104f0a:	00 
  104f0b:	89 04 24             	mov    %eax,(%esp)
  104f0e:	e8 1d e4 ff ff       	call   103330 <kfree>
      np->kstack = 0;
  104f13:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  104f16:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
      np->state = UNUSED;
  104f1d:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  104f20:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
      return 0;
  104f27:	c7 45 e8 00 00 00 00 	movl   $0x0,0xffffffe8(%ebp)
  104f2e:	e9 d7 00 00 00       	jmp    10500a <copyproc+0x1da>
    }
    memmove(np->mem, p->mem, np->sz);
  104f33:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  104f36:	8b 50 04             	mov    0x4(%eax),%edx
  104f39:	8b 45 08             	mov    0x8(%ebp),%eax
  104f3c:	8b 08                	mov    (%eax),%ecx
  104f3e:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  104f41:	8b 00                	mov    (%eax),%eax
  104f43:	89 54 24 08          	mov    %edx,0x8(%esp)
  104f47:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  104f4b:	89 04 24             	mov    %eax,(%esp)
  104f4e:	e8 3d 10 00 00       	call   105f90 <memmove>

    for(i = 0; i < NOFILE; i++)
  104f53:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
  104f5a:	eb 30                	jmp    104f8c <copyproc+0x15c>
      if(p->ofile[i])
  104f5c:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  104f5f:	8b 55 08             	mov    0x8(%ebp),%edx
  104f62:	8b 44 82 20          	mov    0x20(%edx,%eax,4),%eax
  104f66:	85 c0                	test   %eax,%eax
  104f68:	74 1e                	je     104f88 <copyproc+0x158>
        np->ofile[i] = filedup(p->ofile[i]);
  104f6a:	8b 5d f4             	mov    0xfffffff4(%ebp),%ebx
  104f6d:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
  104f70:	8b 45 08             	mov    0x8(%ebp),%eax
  104f73:	8b 44 90 20          	mov    0x20(%eax,%edx,4),%eax
  104f77:	89 04 24             	mov    %eax,(%esp)
  104f7a:	e8 91 c6 ff ff       	call   101610 <filedup>
  104f7f:	89 c2                	mov    %eax,%edx
  104f81:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  104f84:	89 54 98 20          	mov    %edx,0x20(%eax,%ebx,4)
  104f88:	83 45 f4 01          	addl   $0x1,0xfffffff4(%ebp)
  104f8c:	83 7d f4 0f          	cmpl   $0xf,0xfffffff4(%ebp)
  104f90:	7e ca                	jle    104f5c <copyproc+0x12c>
    np->cwd = idup(p->cwd);
  104f92:	8b 45 08             	mov    0x8(%ebp),%eax
  104f95:	8b 40 60             	mov    0x60(%eax),%eax
  104f98:	89 04 24             	mov    %eax,(%esp)
  104f9b:	e8 e0 cd ff ff       	call   101d80 <idup>
  104fa0:	89 c2                	mov    %eax,%edx
  104fa2:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  104fa5:	89 50 60             	mov    %edx,0x60(%eax)
    np->thr = p->thr;
  104fa8:	8b 45 08             	mov    0x8(%ebp),%eax
  104fab:	8b 90 a8 00 00 00    	mov    0xa8(%eax),%edx
  104fb1:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  104fb4:	89 90 a8 00 00 00    	mov    %edx,0xa8(%eax)
  }

  // Set up new context to start executing at forkret (see below).
  memset(&np->context, 0, sizeof(np->context));
  104fba:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  104fbd:	83 c0 64             	add    $0x64,%eax
  104fc0:	c7 44 24 08 20 00 00 	movl   $0x20,0x8(%esp)
  104fc7:	00 
  104fc8:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  104fcf:	00 
  104fd0:	89 04 24             	mov    %eax,(%esp)
  104fd3:	e8 28 0f 00 00       	call   105f00 <memset>
  np->context.eip = (uint)forkret;
  104fd8:	ba 40 53 10 00       	mov    $0x105340,%edx
  104fdd:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  104fe0:	89 50 64             	mov    %edx,0x64(%eax)
  np->context.esp = (uint)np->tf;
  104fe3:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  104fe6:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
  104fec:	89 c2                	mov    %eax,%edx
  104fee:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  104ff1:	89 50 68             	mov    %edx,0x68(%eax)

  // Clear %eax so that fork system call returns 0 in child.
  np->tf->eax = 0;
  104ff4:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  104ff7:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
  104ffd:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
  return np;
  105004:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  105007:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
  10500a:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
}
  10500d:	83 c4 24             	add    $0x24,%esp
  105010:	5b                   	pop    %ebx
  105011:	5d                   	pop    %ebp
  105012:	c3                   	ret    
  105013:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  105019:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00105020 <userinit>:

// Set up first user process.
void
userinit(void)
{
  105020:	55                   	push   %ebp
  105021:	89 e5                	mov    %esp,%ebp
  105023:	83 ec 28             	sub    $0x28,%esp
  struct proc *p;
  extern uchar _binary_initcode_start[], _binary_initcode_size[];
  
  p = copyproc(0);
  105026:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  10502d:	e8 fe fd ff ff       	call   104e30 <copyproc>
  105032:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  p->sz = PAGE;
  105035:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  105038:	c7 40 04 00 10 00 00 	movl   $0x1000,0x4(%eax)
  p->mem = kalloc(p->sz);
  10503f:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  105042:	8b 40 04             	mov    0x4(%eax),%eax
  105045:	89 04 24             	mov    %eax,(%esp)
  105048:	e8 53 e4 ff ff       	call   1034a0 <kalloc>
  10504d:	89 c2                	mov    %eax,%edx
  10504f:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  105052:	89 10                	mov    %edx,(%eax)
  p->cwd = namei("/");
  105054:	c7 04 24 0c a6 11 00 	movl   $0x11a60c,(%esp)
  10505b:	e8 00 dc ff ff       	call   102c60 <namei>
  105060:	89 c2                	mov    %eax,%edx
  105062:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  105065:	89 50 60             	mov    %edx,0x60(%eax)
  memset(p->tf, 0, sizeof(*p->tf));
  105068:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10506b:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
  105071:	c7 44 24 08 44 00 00 	movl   $0x44,0x8(%esp)
  105078:	00 
  105079:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  105080:	00 
  105081:	89 04 24             	mov    %eax,(%esp)
  105084:	e8 77 0e 00 00       	call   105f00 <memset>
  p->tf->cs = (SEG_UCODE << 3) | DPL_USER;
  105089:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10508c:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
  105092:	66 c7 40 34 1b 00    	movw   $0x1b,0x34(%eax)
  p->tf->ds = (SEG_UDATA << 3) | DPL_USER;
  105098:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10509b:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
  1050a1:	66 c7 40 24 23 00    	movw   $0x23,0x24(%eax)
  p->tf->es = p->tf->ds;
  1050a7:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1050aa:	8b 90 84 00 00 00    	mov    0x84(%eax),%edx
  1050b0:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1050b3:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
  1050b9:	0f b7 40 24          	movzwl 0x24(%eax),%eax
  1050bd:	66 89 42 20          	mov    %ax,0x20(%edx)
  p->tf->ss = p->tf->ds;
  1050c1:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1050c4:	8b 90 84 00 00 00    	mov    0x84(%eax),%edx
  1050ca:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1050cd:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
  1050d3:	0f b7 40 24          	movzwl 0x24(%eax),%eax
  1050d7:	66 89 42 40          	mov    %ax,0x40(%edx)
  p->tf->eflags = FL_IF;
  1050db:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1050de:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
  1050e4:	c7 40 38 00 02 00 00 	movl   $0x200,0x38(%eax)
  p->tf->esp = p->sz;
  1050eb:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1050ee:	8b 90 84 00 00 00    	mov    0x84(%eax),%edx
  1050f4:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1050f7:	8b 40 04             	mov    0x4(%eax),%eax
  1050fa:	89 42 3c             	mov    %eax,0x3c(%edx)
  
  // Make return address readable; needed for some gcc.
  p->tf->esp -= 4;
  1050fd:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  105100:	8b 90 84 00 00 00    	mov    0x84(%eax),%edx
  105106:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  105109:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
  10510f:	8b 40 3c             	mov    0x3c(%eax),%eax
  105112:	83 e8 04             	sub    $0x4,%eax
  105115:	89 42 3c             	mov    %eax,0x3c(%edx)
  *(uint*)(p->mem + p->tf->esp) = 0xefefefef;
  105118:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10511b:	8b 10                	mov    (%eax),%edx
  10511d:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  105120:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
  105126:	8b 40 3c             	mov    0x3c(%eax),%eax
  105129:	8d 04 02             	lea    (%edx,%eax,1),%eax
  10512c:	c7 00 ef ef ef ef    	movl   $0xefefefef,(%eax)

  // On entry to user space, start executing at beginning of initcode.S.
  p->tf->eip = 0;
  105132:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  105135:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
  10513b:	c7 40 30 00 00 00 00 	movl   $0x0,0x30(%eax)
  memmove(p->mem, _binary_initcode_start, (int)_binary_initcode_size);
  105142:	b8 2c 00 00 00       	mov    $0x2c,%eax
  105147:	89 c2                	mov    %eax,%edx
  105149:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10514c:	8b 00                	mov    (%eax),%eax
  10514e:	89 54 24 08          	mov    %edx,0x8(%esp)
  105152:	c7 44 24 04 6c cc 11 	movl   $0x11cc6c,0x4(%esp)
  105159:	00 
  10515a:	89 04 24             	mov    %eax,(%esp)
  10515d:	e8 2e 0e 00 00       	call   105f90 <memmove>
  safestrcpy(p->name, "initcode", sizeof(p->name));
  105162:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  105165:	05 88 00 00 00       	add    $0x88,%eax
  10516a:	c7 44 24 08 20 00 00 	movl   $0x20,0x8(%esp)
  105171:	00 
  105172:	c7 44 24 04 0e a6 11 	movl   $0x11a60e,0x4(%esp)
  105179:	00 
  10517a:	89 04 24             	mov    %eax,(%esp)
  10517d:	e8 5e 0f 00 00       	call   1060e0 <safestrcpy>
  p->state = RUNNABLE;
  105182:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  105185:	c7 40 0c 03 00 00 00 	movl   $0x3,0xc(%eax)
  
  initproc = p;
  10518c:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10518f:	a3 24 0c 14 00       	mov    %eax,0x140c24
}
  105194:	c9                   	leave  
  105195:	c3                   	ret    
  105196:	8d 76 00             	lea    0x0(%esi),%esi
  105199:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

001051a0 <scheduler>:

// Per-CPU process scheduler.
// Each CPU calls scheduler() after setting itself up.
// Scheduler never returns.  It loops, doing:
//  - choose a process to run
//  - swtch to start running that process
//  - eventually that process transfers control
//      via swtch back to the scheduler.
void
scheduler(void)
{
  1051a0:	55                   	push   %ebp
  1051a1:	89 e5                	mov    %esp,%ebp
  1051a3:	53                   	push   %ebx
  1051a4:	83 ec 24             	sub    $0x24,%esp
  struct proc *p;
  int i;

  for(;;){
    // Loop over process table looking for process to run.
    acquire(&proc_table_lock);
  1051a7:	c7 04 24 40 0c 14 00 	movl   $0x140c40,(%esp)
  1051ae:	e8 8d 09 00 00       	call   105b40 <acquire>

    for(i = 0; i < NPROC; i++){
  1051b3:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)
  1051ba:	e9 9d 00 00 00       	jmp    10525c <scheduler+0xbc>
      p = &proc[i];
  1051bf:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1051c2:	69 c0 ac 00 00 00    	imul   $0xac,%eax,%eax
  1051c8:	05 20 e1 13 00       	add    $0x13e120,%eax
  1051cd:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
      if((p->state != RUNNABLE) && (p->state != MSLEEPING))
  1051d0:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  1051d3:	8b 40 0c             	mov    0xc(%eax),%eax
  1051d6:	83 f8 03             	cmp    $0x3,%eax
  1051d9:	74 0b                	je     1051e6 <scheduler+0x46>
  1051db:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  1051de:	8b 40 0c             	mov    0xc(%eax),%eax
  1051e1:	83 f8 06             	cmp    $0x6,%eax
  1051e4:	75 72                	jne    105258 <scheduler+0xb8>
        continue;

//      cprintf("switch to %s eip: 0x%08x...\n", p->name, p->context.eip);
      // Switch to chosen process.  It is the process's job
      // to release proc_table_lock and then reacquire it
      // before jumping back to us.
      cp = p;
  1051e6:	e8 d5 e6 ff ff       	call   1038c0 <cpu>
  1051eb:	89 c2                	mov    %eax,%edx
  1051ed:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  1051f0:	89 04 95 20 0c 14 00 	mov    %eax,0x140c20(,%edx,4)
      setupsegs(p);
  1051f7:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  1051fa:	89 04 24             	mov    %eax,(%esp)
  1051fd:	e8 9e f7 ff ff       	call   1049a0 <setupsegs>
      if (p->state == RUNNABLE)
  105202:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  105205:	8b 40 0c             	mov    0xc(%eax),%eax
  105208:	83 f8 03             	cmp    $0x3,%eax
  10520b:	75 0a                	jne    105217 <scheduler+0x77>
        p->state = RUNNING;
  10520d:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  105210:	c7 40 0c 04 00 00 00 	movl   $0x4,0xc(%eax)
      swtch(&cpus[cpu()].context, &p->context);
  105217:	8b 5d f4             	mov    0xfffffff4(%ebp),%ebx
  10521a:	83 c3 64             	add    $0x64,%ebx
  10521d:	e8 9e e6 ff ff       	call   1038c0 <cpu>
  105222:	69 c0 ec 10 00 00    	imul   $0x10ec,%eax,%eax
  105228:	05 20 cc 13 00       	add    $0x13cc20,%eax
  10522d:	83 c0 04             	add    $0x4,%eax
  105230:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  105234:	89 04 24             	mov    %eax,(%esp)
  105237:	e8 2c 0f 00 00       	call   106168 <swtch>

//      cprintf("done.\n");
      // Process is done running for now.
      // It should have changed its p->state before coming back.
      cp = 0;
  10523c:	e8 7f e6 ff ff       	call   1038c0 <cpu>
  105241:	c7 04 85 20 0c 14 00 	movl   $0x0,0x140c20(,%eax,4)
  105248:	00 00 00 00 
      setupsegs(0);
  10524c:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  105253:	e8 48 f7 ff ff       	call   1049a0 <setupsegs>
  105258:	83 45 f8 01          	addl   $0x1,0xfffffff8(%ebp)
  10525c:	83 7d f8 3f          	cmpl   $0x3f,0xfffffff8(%ebp)
  105260:	0f 8e 59 ff ff ff    	jle    1051bf <scheduler+0x1f>
    }

    release(&proc_table_lock);
  105266:	c7 04 24 40 0c 14 00 	movl   $0x140c40,(%esp)
  10526d:	e8 ce 0a 00 00       	call   105d40 <release>
  }
  105272:	e9 30 ff ff ff       	jmp    1051a7 <scheduler+0x7>
  105277:	89 f6                	mov    %esi,%esi
  105279:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00105280 <sched>:
}

// Enter scheduler.  Must already hold proc_table_lock
// and have changed curproc[cpu()]->state.
void
sched(void)
{
  105280:	55                   	push   %ebp
  105281:	89 e5                	mov    %esp,%ebp
  105283:	53                   	push   %ebx
  105284:	83 ec 14             	sub    $0x14,%esp
  if(cp->state == RUNNING)
  105287:	e8 34 e6 ff ff       	call   1038c0 <cpu>
  10528c:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  105293:	8b 40 0c             	mov    0xc(%eax),%eax
  105296:	83 f8 04             	cmp    $0x4,%eax
  105299:	75 0c                	jne    1052a7 <sched+0x27>
    panic("sched running");
  10529b:	c7 04 24 17 a6 11 00 	movl   $0x11a617,(%esp)
  1052a2:	e8 69 bd ff ff       	call   101010 <panic>
  if(!holding(&proc_table_lock))
  1052a7:	c7 04 24 40 0c 14 00 	movl   $0x140c40,(%esp)
  1052ae:	e8 cd 0b 00 00       	call   105e80 <holding>
  1052b3:	85 c0                	test   %eax,%eax
  1052b5:	75 0c                	jne    1052c3 <sched+0x43>
    panic("sched proc_table_lock");
  1052b7:	c7 04 24 25 a6 11 00 	movl   $0x11a625,(%esp)
  1052be:	e8 4d bd ff ff       	call   101010 <panic>
//  if(cpus[cpu()].nlock != 1)
//    panic("sched locks");

  swtch(&cp->context, &cpus[cpu()].context);
  1052c3:	e8 f8 e5 ff ff       	call   1038c0 <cpu>
  1052c8:	69 c0 ec 10 00 00    	imul   $0x10ec,%eax,%eax
  1052ce:	05 20 cc 13 00       	add    $0x13cc20,%eax
  1052d3:	8d 58 04             	lea    0x4(%eax),%ebx
  1052d6:	e8 e5 e5 ff ff       	call   1038c0 <cpu>
  1052db:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  1052e2:	83 c0 64             	add    $0x64,%eax
  1052e5:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  1052e9:	89 04 24             	mov    %eax,(%esp)
  1052ec:	e8 77 0e 00 00       	call   106168 <swtch>
}
  1052f1:	83 c4 14             	add    $0x14,%esp
  1052f4:	5b                   	pop    %ebx
  1052f5:	5d                   	pop    %ebp
  1052f6:	c3                   	ret    
  1052f7:	89 f6                	mov    %esi,%esi
  1052f9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00105300 <yield>:

// Give up the CPU for one scheduling round.
void
yield(void)
{
  105300:	55                   	push   %ebp
  105301:	89 e5                	mov    %esp,%ebp
  105303:	83 ec 08             	sub    $0x8,%esp
  acquire(&proc_table_lock);
  105306:	c7 04 24 40 0c 14 00 	movl   $0x140c40,(%esp)
  10530d:	e8 2e 08 00 00       	call   105b40 <acquire>
  cp->state = RUNNABLE;
  105312:	e8 a9 e5 ff ff       	call   1038c0 <cpu>
  105317:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  10531e:	c7 40 0c 03 00 00 00 	movl   $0x3,0xc(%eax)
  sched();
  105325:	e8 56 ff ff ff       	call   105280 <sched>
  release(&proc_table_lock);
  10532a:	c7 04 24 40 0c 14 00 	movl   $0x140c40,(%esp)
  105331:	e8 0a 0a 00 00       	call   105d40 <release>
}
  105336:	c9                   	leave  
  105337:	c3                   	ret    
  105338:	90                   	nop    
  105339:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

00105340 <forkret>:

// A fork child's very first scheduling by scheduler()
// will swtch here.  "Return" to user space.
void
forkret(void)
{
  105340:	55                   	push   %ebp
  105341:	89 e5                	mov    %esp,%ebp
  105343:	83 ec 08             	sub    $0x8,%esp
  // Still holding proc_table_lock from scheduler.
  release(&proc_table_lock);
  105346:	c7 04 24 40 0c 14 00 	movl   $0x140c40,(%esp)
  10534d:	e8 ee 09 00 00       	call   105d40 <release>

  // Jump into assembly, never to return.
  forkret1(cp->tf);
  105352:	e8 69 e5 ff ff       	call   1038c0 <cpu>
  105357:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  10535e:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
  105364:	89 04 24             	mov    %eax,(%esp)
  105367:	e8 54 2c 00 00       	call   107fc0 <forkret1>
}
  10536c:	c9                   	leave  
  10536d:	c3                   	ret    
  10536e:	89 f6                	mov    %esi,%esi

00105370 <msleep_spin>:

int
msleep_spin(void *chan, struct spinlock *lk, int timo)
{
  105370:	55                   	push   %ebp
  105371:	89 e5                	mov    %esp,%ebp
  105373:	83 ec 18             	sub    $0x18,%esp
    uint32_t s = millitime();
  105376:	e8 15 2c 00 00       	call   107f90 <millitime>
  10537b:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
    uint32_t p = s;
  10537e:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  105381:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
    int ret = 1; // Time Out
  105384:	c7 45 fc 01 00 00 00 	movl   $0x1,0xfffffffc(%ebp)
    s += timo;
  10538b:	8b 45 10             	mov    0x10(%ebp),%eax
  10538e:	01 45 f4             	add    %eax,0xfffffff4(%ebp)

    if (cp == 0)
  105391:	e8 2a e5 ff ff       	call   1038c0 <cpu>
  105396:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  10539d:	85 c0                	test   %eax,%eax
  10539f:	75 0c                	jne    1053ad <msleep_spin+0x3d>
        panic("msleep with cp == 0");
  1053a1:	c7 04 24 3b a6 11 00 	movl   $0x11a63b,(%esp)
  1053a8:	e8 63 bc ff ff       	call   101010 <panic>
    if (lk == 0)
  1053ad:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  1053b1:	75 0c                	jne    1053bf <msleep_spin+0x4f>
        panic("msleep without lock");
  1053b3:	c7 04 24 4f a6 11 00 	movl   $0x11a64f,(%esp)
  1053ba:	e8 51 bc ff ff       	call   101010 <panic>

    if (lk != &proc_table_lock)
  1053bf:	81 7d 0c 40 0c 14 00 	cmpl   $0x140c40,0xc(%ebp)
  1053c6:	74 17                	je     1053df <msleep_spin+0x6f>
    {
        acquire(&proc_table_lock);
  1053c8:	c7 04 24 40 0c 14 00 	movl   $0x140c40,(%esp)
  1053cf:	e8 6c 07 00 00       	call   105b40 <acquire>
        release(lk);
  1053d4:	8b 45 0c             	mov    0xc(%ebp),%eax
  1053d7:	89 04 24             	mov    %eax,(%esp)
  1053da:	e8 61 09 00 00       	call   105d40 <release>
    }

    cp->chan = chan;
  1053df:	e8 dc e4 ff ff       	call   1038c0 <cpu>
  1053e4:	8b 14 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%edx
  1053eb:	8b 45 08             	mov    0x8(%ebp),%eax
  1053ee:	89 42 18             	mov    %eax,0x18(%edx)
    cp->state = MSLEEPING;
  1053f1:	e8 ca e4 ff ff       	call   1038c0 <cpu>
  1053f6:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  1053fd:	c7 40 0c 06 00 00 00 	movl   $0x6,0xc(%eax)
    while (p < s)
  105404:	eb 2a                	jmp    105430 <msleep_spin+0xc0>
    {
        sched();
  105406:	e8 75 fe ff ff       	call   105280 <sched>
        if (cp->state == RUNNING)
  10540b:	e8 b0 e4 ff ff       	call   1038c0 <cpu>
  105410:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  105417:	8b 40 0c             	mov    0xc(%eax),%eax
  10541a:	83 f8 04             	cmp    $0x4,%eax
  10541d:	75 09                	jne    105428 <msleep_spin+0xb8>
        {
            ret = 0;
  10541f:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
            break;
  105426:	eb 10                	jmp    105438 <msleep_spin+0xc8>
        }
        p = millitime();
  105428:	e8 63 2b 00 00       	call   107f90 <millitime>
  10542d:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  105430:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  105433:	3b 45 f4             	cmp    0xfffffff4(%ebp),%eax
  105436:	72 ce                	jb     105406 <msleep_spin+0x96>
    }
    cp->chan = 0;
  105438:	e8 83 e4 ff ff       	call   1038c0 <cpu>
  10543d:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  105444:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
    cp->state = RUNNING;
  10544b:	e8 70 e4 ff ff       	call   1038c0 <cpu>
  105450:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  105457:	c7 40 0c 04 00 00 00 	movl   $0x4,0xc(%eax)

    if (lk != &proc_table_lock)
  10545e:	81 7d 0c 40 0c 14 00 	cmpl   $0x140c40,0xc(%ebp)
  105465:	74 17                	je     10547e <msleep_spin+0x10e>
    {
        release(&proc_table_lock);
  105467:	c7 04 24 40 0c 14 00 	movl   $0x140c40,(%esp)
  10546e:	e8 cd 08 00 00       	call   105d40 <release>
        acquire(lk);
  105473:	8b 45 0c             	mov    0xc(%ebp),%eax
  105476:	89 04 24             	mov    %eax,(%esp)
  105479:	e8 c2 06 00 00       	call   105b40 <acquire>
    }
    return ret;
  10547e:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
}
  105481:	c9                   	leave  
  105482:	c3                   	ret    
  105483:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  105489:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00105490 <sleep>:

// Atomically release lock and sleep on chan.
// Reacquires lock when reawakened.
void
sleep(void *chan, struct spinlock *lk)
{
  105490:	55                   	push   %ebp
  105491:	89 e5                	mov    %esp,%ebp
  105493:	83 ec 08             	sub    $0x8,%esp
  if(cp == 0)
  105496:	e8 25 e4 ff ff       	call   1038c0 <cpu>
  10549b:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  1054a2:	85 c0                	test   %eax,%eax
  1054a4:	75 0c                	jne    1054b2 <sleep+0x22>
    panic("sleep");
  1054a6:	c7 04 24 63 a6 11 00 	movl   $0x11a663,(%esp)
  1054ad:	e8 5e bb ff ff       	call   101010 <panic>

  if(lk == 0)
  1054b2:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  1054b6:	75 0c                	jne    1054c4 <sleep+0x34>
    panic("sleep without lk");
  1054b8:	c7 04 24 69 a6 11 00 	movl   $0x11a669,(%esp)
  1054bf:	e8 4c bb ff ff       	call   101010 <panic>

  // Must acquire proc_table_lock in order to
  // change p->state and then call sched.
  // Once we hold proc_table_lock, we can be
  // guaranteed that we won't miss any wakeup
  // (wakeup runs with proc_table_lock locked),
  // so it's okay to release lk.
  if(lk != &proc_table_lock){
  1054c4:	81 7d 0c 40 0c 14 00 	cmpl   $0x140c40,0xc(%ebp)
  1054cb:	74 17                	je     1054e4 <sleep+0x54>
    acquire(&proc_table_lock);
  1054cd:	c7 04 24 40 0c 14 00 	movl   $0x140c40,(%esp)
  1054d4:	e8 67 06 00 00       	call   105b40 <acquire>
    release(lk);
  1054d9:	8b 45 0c             	mov    0xc(%ebp),%eax
  1054dc:	89 04 24             	mov    %eax,(%esp)
  1054df:	e8 5c 08 00 00       	call   105d40 <release>
  }

  // Go to sleep.
  cp->chan = chan;
  1054e4:	e8 d7 e3 ff ff       	call   1038c0 <cpu>
  1054e9:	8b 14 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%edx
  1054f0:	8b 45 08             	mov    0x8(%ebp),%eax
  1054f3:	89 42 18             	mov    %eax,0x18(%edx)
  cp->state = SLEEPING;
  1054f6:	e8 c5 e3 ff ff       	call   1038c0 <cpu>
  1054fb:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  105502:	c7 40 0c 02 00 00 00 	movl   $0x2,0xc(%eax)
  sched();
  105509:	e8 72 fd ff ff       	call   105280 <sched>

  // Tidy up.
  cp->chan = 0;
  10550e:	e8 ad e3 ff ff       	call   1038c0 <cpu>
  105513:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  10551a:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)

  // Reacquire original lock.
  if(lk != &proc_table_lock){
  105521:	81 7d 0c 40 0c 14 00 	cmpl   $0x140c40,0xc(%ebp)
  105528:	74 17                	je     105541 <sleep+0xb1>
    release(&proc_table_lock);
  10552a:	c7 04 24 40 0c 14 00 	movl   $0x140c40,(%esp)
  105531:	e8 0a 08 00 00       	call   105d40 <release>
    acquire(lk);
  105536:	8b 45 0c             	mov    0xc(%ebp),%eax
  105539:	89 04 24             	mov    %eax,(%esp)
  10553c:	e8 ff 05 00 00       	call   105b40 <acquire>
  }
}
  105541:	c9                   	leave  
  105542:	c3                   	ret    
  105543:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  105549:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00105550 <wakeup1>:

// Wake up all processes sleeping on chan.
// Proc_table_lock must be held.
static void
wakeup1(void *chan)
{
  105550:	55                   	push   %ebp
  105551:	89 e5                	mov    %esp,%ebp
  105553:	83 ec 10             	sub    $0x10,%esp
  struct proc *p;

  for(p = proc; p < &proc[NPROC]; p++)
  105556:	c7 45 fc 20 e1 13 00 	movl   $0x13e120,0xfffffffc(%ebp)
  10555d:	eb 32                	jmp    105591 <wakeup1+0x41>
    if(((p->state == SLEEPING) || 
  10555f:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  105562:	8b 40 0c             	mov    0xc(%eax),%eax
  105565:	83 f8 02             	cmp    $0x2,%eax
  105568:	74 0b                	je     105575 <wakeup1+0x25>
  10556a:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10556d:	8b 40 0c             	mov    0xc(%eax),%eax
  105570:	83 f8 06             	cmp    $0x6,%eax
  105573:	75 15                	jne    10558a <wakeup1+0x3a>
  105575:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  105578:	8b 40 18             	mov    0x18(%eax),%eax
  10557b:	3b 45 08             	cmp    0x8(%ebp),%eax
  10557e:	75 0a                	jne    10558a <wakeup1+0x3a>
                (p->state == MSLEEPING)) && p->chan == chan)
      p->state = RUNNABLE;
  105580:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  105583:	c7 40 0c 03 00 00 00 	movl   $0x3,0xc(%eax)
  10558a:	81 45 fc ac 00 00 00 	addl   $0xac,0xfffffffc(%ebp)
  105591:	b8 20 0c 14 00       	mov    $0x140c20,%eax
  105596:	39 45 fc             	cmp    %eax,0xfffffffc(%ebp)
  105599:	72 c4                	jb     10555f <wakeup1+0xf>
}
  10559b:	c9                   	leave  
  10559c:	c3                   	ret    
  10559d:	8d 76 00             	lea    0x0(%esi),%esi

001055a0 <wakeup_one1>:

// Wake up all processes sleeping on chan.
// Proc_table_lock must be held.
static void
wakeup_one1(void *chan)
{
  1055a0:	55                   	push   %ebp
  1055a1:	89 e5                	mov    %esp,%ebp
  1055a3:	83 ec 10             	sub    $0x10,%esp
  struct proc *p;

  for(p = proc; p < &proc[NPROC]; p++)
  1055a6:	c7 45 fc 20 e1 13 00 	movl   $0x13e120,0xfffffffc(%ebp)
  1055ad:	eb 34                	jmp    1055e3 <wakeup_one1+0x43>
    if(((p->state == SLEEPING) || 
  1055af:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1055b2:	8b 40 0c             	mov    0xc(%eax),%eax
  1055b5:	83 f8 02             	cmp    $0x2,%eax
  1055b8:	74 0b                	je     1055c5 <wakeup_one1+0x25>
  1055ba:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1055bd:	8b 40 0c             	mov    0xc(%eax),%eax
  1055c0:	83 f8 06             	cmp    $0x6,%eax
  1055c3:	75 17                	jne    1055dc <wakeup_one1+0x3c>
  1055c5:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1055c8:	8b 40 18             	mov    0x18(%eax),%eax
  1055cb:	3b 45 08             	cmp    0x8(%ebp),%eax
  1055ce:	75 0c                	jne    1055dc <wakeup_one1+0x3c>
                (p->state == MSLEEPING)) && p->chan == chan)
    {
      p->state = RUNNABLE;
  1055d0:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1055d3:	c7 40 0c 03 00 00 00 	movl   $0x3,0xc(%eax)
      break;
  1055da:	eb 11                	jmp    1055ed <wakeup_one1+0x4d>
  1055dc:	81 45 fc ac 00 00 00 	addl   $0xac,0xfffffffc(%ebp)
  1055e3:	b8 20 0c 14 00       	mov    $0x140c20,%eax
  1055e8:	39 45 fc             	cmp    %eax,0xfffffffc(%ebp)
  1055eb:	72 c2                	jb     1055af <wakeup_one1+0xf>
    }
}
  1055ed:	c9                   	leave  
  1055ee:	c3                   	ret    
  1055ef:	90                   	nop    

001055f0 <wakeup_one>:

void
wakeup_one(void *chan)
{
  1055f0:	55                   	push   %ebp
  1055f1:	89 e5                	mov    %esp,%ebp
  1055f3:	83 ec 08             	sub    $0x8,%esp
  acquire(&proc_table_lock);
  1055f6:	c7 04 24 40 0c 14 00 	movl   $0x140c40,(%esp)
  1055fd:	e8 3e 05 00 00       	call   105b40 <acquire>
  wakeup_one1(chan);
  105602:	8b 45 08             	mov    0x8(%ebp),%eax
  105605:	89 04 24             	mov    %eax,(%esp)
  105608:	e8 93 ff ff ff       	call   1055a0 <wakeup_one1>
  release(&proc_table_lock);
  10560d:	c7 04 24 40 0c 14 00 	movl   $0x140c40,(%esp)
  105614:	e8 27 07 00 00       	call   105d40 <release>
}
  105619:	c9                   	leave  
  10561a:	c3                   	ret    
  10561b:	90                   	nop    
  10561c:	8d 74 26 00          	lea    0x0(%esi),%esi

00105620 <wakeup>:

// Wake up all processes sleeping on chan.
// Proc_table_lock is acquired and released.
void
wakeup(void *chan)
{
  105620:	55                   	push   %ebp
  105621:	89 e5                	mov    %esp,%ebp
  105623:	83 ec 08             	sub    $0x8,%esp
  acquire(&proc_table_lock);
  105626:	c7 04 24 40 0c 14 00 	movl   $0x140c40,(%esp)
  10562d:	e8 0e 05 00 00       	call   105b40 <acquire>
  wakeup1(chan);
  105632:	8b 45 08             	mov    0x8(%ebp),%eax
  105635:	89 04 24             	mov    %eax,(%esp)
  105638:	e8 13 ff ff ff       	call   105550 <wakeup1>
  release(&proc_table_lock);
  10563d:	c7 04 24 40 0c 14 00 	movl   $0x140c40,(%esp)
  105644:	e8 f7 06 00 00       	call   105d40 <release>
}
  105649:	c9                   	leave  
  10564a:	c3                   	ret    
  10564b:	90                   	nop    
  10564c:	8d 74 26 00          	lea    0x0(%esi),%esi

00105650 <kill>:

// Kill the process with the given pid.
// Process won't actually exit until it returns
// to user space (see trap in trap.c).
int
kill(int pid)
{
  105650:	55                   	push   %ebp
  105651:	89 e5                	mov    %esp,%ebp
  105653:	83 ec 18             	sub    $0x18,%esp
  struct proc *p;

  acquire(&proc_table_lock);
  105656:	c7 04 24 40 0c 14 00 	movl   $0x140c40,(%esp)
  10565d:	e8 de 04 00 00       	call   105b40 <acquire>
  for(p = proc; p < &proc[NPROC]; p++){
  105662:	c7 45 fc 20 e1 13 00 	movl   $0x13e120,0xfffffffc(%ebp)
  105669:	eb 46                	jmp    1056b1 <kill+0x61>
    if(p->pid == pid){
  10566b:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10566e:	8b 40 10             	mov    0x10(%eax),%eax
  105671:	3b 45 08             	cmp    0x8(%ebp),%eax
  105674:	75 34                	jne    1056aa <kill+0x5a>
      p->killed = 1;
  105676:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  105679:	c7 40 1c 01 00 00 00 	movl   $0x1,0x1c(%eax)
      // Wake process from sleep if necessary.
      if(p->state == SLEEPING)
  105680:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  105683:	8b 40 0c             	mov    0xc(%eax),%eax
  105686:	83 f8 02             	cmp    $0x2,%eax
  105689:	75 0a                	jne    105695 <kill+0x45>
        p->state = RUNNABLE;
  10568b:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10568e:	c7 40 0c 03 00 00 00 	movl   $0x3,0xc(%eax)
      release(&proc_table_lock);
  105695:	c7 04 24 40 0c 14 00 	movl   $0x140c40,(%esp)
  10569c:	e8 9f 06 00 00       	call   105d40 <release>
      return 0;
  1056a1:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  1056a8:	eb 24                	jmp    1056ce <kill+0x7e>
  1056aa:	81 45 fc ac 00 00 00 	addl   $0xac,0xfffffffc(%ebp)
  1056b1:	b8 20 0c 14 00       	mov    $0x140c20,%eax
  1056b6:	39 45 fc             	cmp    %eax,0xfffffffc(%ebp)
  1056b9:	72 b0                	jb     10566b <kill+0x1b>
    }
  }
  release(&proc_table_lock);
  1056bb:	c7 04 24 40 0c 14 00 	movl   $0x140c40,(%esp)
  1056c2:	e8 79 06 00 00       	call   105d40 <release>
  return -1;
  1056c7:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  1056ce:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  1056d1:	c9                   	leave  
  1056d2:	c3                   	ret    
  1056d3:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  1056d9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

001056e0 <exit>:

// Exit the current process.  Does not return.
// Exited processes remain in the zombie state
// until their parent calls wait() to find out they exited.
void
exit(void)
{
  1056e0:	55                   	push   %ebp
  1056e1:	89 e5                	mov    %esp,%ebp
  1056e3:	53                   	push   %ebx
  1056e4:	83 ec 14             	sub    $0x14,%esp
  struct proc *p;
  int fd;

  if(cp == initproc)
  1056e7:	e8 d4 e1 ff ff       	call   1038c0 <cpu>
  1056ec:	8b 14 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%edx
  1056f3:	a1 24 0c 14 00       	mov    0x140c24,%eax
  1056f8:	39 c2                	cmp    %eax,%edx
  1056fa:	75 0c                	jne    105708 <exit+0x28>
    panic("init exiting");
  1056fc:	c7 04 24 7a a6 11 00 	movl   $0x11a67a,(%esp)
  105703:	e8 08 b9 ff ff       	call   101010 <panic>

  // Close all open files.
  for(fd = 0; fd < NOFILE; fd++){
  105708:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)
  10570f:	eb 4d                	jmp    10575e <exit+0x7e>
    if(cp->ofile[fd]){
  105711:	e8 aa e1 ff ff       	call   1038c0 <cpu>
  105716:	8b 14 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%edx
  10571d:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  105720:	8b 44 82 20          	mov    0x20(%edx,%eax,4),%eax
  105724:	85 c0                	test   %eax,%eax
  105726:	74 32                	je     10575a <exit+0x7a>
      fileclose(cp->ofile[fd]);
  105728:	e8 93 e1 ff ff       	call   1038c0 <cpu>
  10572d:	8b 14 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%edx
  105734:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  105737:	8b 44 82 20          	mov    0x20(%edx,%eax,4),%eax
  10573b:	89 04 24             	mov    %eax,(%esp)
  10573e:	e8 2d bf ff ff       	call   101670 <fileclose>
      cp->ofile[fd] = 0;
  105743:	e8 78 e1 ff ff       	call   1038c0 <cpu>
  105748:	8b 14 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%edx
  10574f:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  105752:	c7 44 82 20 00 00 00 	movl   $0x0,0x20(%edx,%eax,4)
  105759:	00 
  10575a:	83 45 f8 01          	addl   $0x1,0xfffffff8(%ebp)
  10575e:	83 7d f8 0f          	cmpl   $0xf,0xfffffff8(%ebp)
  105762:	7e ad                	jle    105711 <exit+0x31>
    }
  }

  iput(cp->cwd);
  105764:	e8 57 e1 ff ff       	call   1038c0 <cpu>
  105769:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  105770:	8b 40 60             	mov    0x60(%eax),%eax
  105773:	89 04 24             	mov    %eax,(%esp)
  105776:	e8 15 c8 ff ff       	call   101f90 <iput>
  cp->cwd = 0;
  10577b:	e8 40 e1 ff ff       	call   1038c0 <cpu>
  105780:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  105787:	c7 40 60 00 00 00 00 	movl   $0x0,0x60(%eax)

  acquire(&proc_table_lock);
  10578e:	c7 04 24 40 0c 14 00 	movl   $0x140c40,(%esp)
  105795:	e8 a6 03 00 00       	call   105b40 <acquire>

  // Parent might be sleeping in proc_wait.
  wakeup1(cp->parent);
  10579a:	e8 21 e1 ff ff       	call   1038c0 <cpu>
  10579f:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  1057a6:	8b 40 14             	mov    0x14(%eax),%eax
  1057a9:	89 04 24             	mov    %eax,(%esp)
  1057ac:	e8 9f fd ff ff       	call   105550 <wakeup1>

  // Pass abandoned children to init.
  for(p = proc; p < &proc[NPROC]; p++){
  1057b1:	c7 45 f4 20 e1 13 00 	movl   $0x13e120,0xfffffff4(%ebp)
  1057b8:	eb 41                	jmp    1057fb <exit+0x11b>
    if(p->parent == cp){
  1057ba:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  1057bd:	8b 58 14             	mov    0x14(%eax),%ebx
  1057c0:	e8 fb e0 ff ff       	call   1038c0 <cpu>
  1057c5:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  1057cc:	39 c3                	cmp    %eax,%ebx
  1057ce:	75 24                	jne    1057f4 <exit+0x114>
      p->parent = initproc;
  1057d0:	8b 15 24 0c 14 00    	mov    0x140c24,%edx
  1057d6:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  1057d9:	89 50 14             	mov    %edx,0x14(%eax)
      if(p->state == ZOMBIE)
  1057dc:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  1057df:	8b 40 0c             	mov    0xc(%eax),%eax
  1057e2:	83 f8 05             	cmp    $0x5,%eax
  1057e5:	75 0d                	jne    1057f4 <exit+0x114>
        wakeup1(initproc);
  1057e7:	a1 24 0c 14 00       	mov    0x140c24,%eax
  1057ec:	89 04 24             	mov    %eax,(%esp)
  1057ef:	e8 5c fd ff ff       	call   105550 <wakeup1>
  1057f4:	81 45 f4 ac 00 00 00 	addl   $0xac,0xfffffff4(%ebp)
  1057fb:	b8 20 0c 14 00       	mov    $0x140c20,%eax
  105800:	39 45 f4             	cmp    %eax,0xfffffff4(%ebp)
  105803:	72 b5                	jb     1057ba <exit+0xda>
    }
  }

  if (cp->thr)
  105805:	e8 b6 e0 ff ff       	call   1038c0 <cpu>
  10580a:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  105811:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
  105817:	85 c0                	test   %eax,%eax
  105819:	74 1a                	je     105835 <exit+0x155>
      kproc_free(cp->thr);
  10581b:	e8 a0 e0 ff ff       	call   1038c0 <cpu>
  105820:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  105827:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
  10582d:	89 04 24             	mov    %eax,(%esp)
  105830:	e8 2b 45 00 00       	call   109d60 <kproc_free>

  // Jump into the scheduler, never to return.
  cp->killed = 0;
  105835:	e8 86 e0 ff ff       	call   1038c0 <cpu>
  10583a:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  105841:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
  cp->state = ZOMBIE;
  105848:	e8 73 e0 ff ff       	call   1038c0 <cpu>
  10584d:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  105854:	c7 40 0c 05 00 00 00 	movl   $0x5,0xc(%eax)
  cp->thr = 0;
  10585b:	e8 60 e0 ff ff       	call   1038c0 <cpu>
  105860:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  105867:	c7 80 a8 00 00 00 00 	movl   $0x0,0xa8(%eax)
  10586e:	00 00 00 
  sched();
  105871:	e8 0a fa ff ff       	call   105280 <sched>
  panic("zombie exit");
  105876:	c7 04 24 87 a6 11 00 	movl   $0x11a687,(%esp)
  10587d:	e8 8e b7 ff ff       	call   101010 <panic>
  105882:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi
  105889:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00105890 <wait>:
}

// Wait for a child process to exit and return its pid.
// Return -1 if this process has no children.
int
wait(void)
{
  105890:	55                   	push   %ebp
  105891:	89 e5                	mov    %esp,%ebp
  105893:	53                   	push   %ebx
  105894:	83 ec 24             	sub    $0x24,%esp
  struct proc *p;
  int i, havekids, pid;

  acquire(&proc_table_lock);
  105897:	c7 04 24 40 0c 14 00 	movl   $0x140c40,(%esp)
  10589e:	e8 9d 02 00 00       	call   105b40 <acquire>
  for(;;){
    // Scan through table looking for zombie children.
    havekids = 0;
  1058a3:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
    for(i = 0; i < NPROC; i++){
  1058aa:	c7 45 f0 00 00 00 00 	movl   $0x0,0xfffffff0(%ebp)
  1058b1:	e9 cd 00 00 00       	jmp    105983 <wait+0xf3>
      p = &proc[i];
  1058b6:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  1058b9:	69 c0 ac 00 00 00    	imul   $0xac,%eax,%eax
  1058bf:	05 20 e1 13 00       	add    $0x13e120,%eax
  1058c4:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
      if(p->state == UNUSED)
  1058c7:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  1058ca:	8b 40 0c             	mov    0xc(%eax),%eax
  1058cd:	85 c0                	test   %eax,%eax
  1058cf:	0f 84 aa 00 00 00    	je     10597f <wait+0xef>
        continue;
      if(p->parent == cp){
  1058d5:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  1058d8:	8b 58 14             	mov    0x14(%eax),%ebx
  1058db:	e8 e0 df ff ff       	call   1038c0 <cpu>
  1058e0:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  1058e7:	39 c3                	cmp    %eax,%ebx
  1058e9:	0f 85 90 00 00 00    	jne    10597f <wait+0xef>
        if(p->state == ZOMBIE){
  1058ef:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  1058f2:	8b 40 0c             	mov    0xc(%eax),%eax
  1058f5:	83 f8 05             	cmp    $0x5,%eax
  1058f8:	75 7e                	jne    105978 <wait+0xe8>
          // Found one.
#ifdef PROC_DEBUG
          cprintf("wait: freeing ZOMBIE %d %s\n", p->pid, p->name);
          cprintf("      freeing mem\n");
#endif
          if (p->sz != 0) // kernel thread doesn't have mem
  1058fa:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  1058fd:	8b 40 04             	mov    0x4(%eax),%eax
  105900:	85 c0                	test   %eax,%eax
  105902:	74 19                	je     10591d <wait+0x8d>
            kfree(p->mem, p->sz);
  105904:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  105907:	8b 40 04             	mov    0x4(%eax),%eax
  10590a:	89 c2                	mov    %eax,%edx
  10590c:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10590f:	8b 00                	mov    (%eax),%eax
  105911:	89 54 24 04          	mov    %edx,0x4(%esp)
  105915:	89 04 24             	mov    %eax,(%esp)
  105918:	e8 13 da ff ff       	call   103330 <kfree>
#ifdef PROC_DEBUG
          cprintf("      freeing kstack\n");
#endif
          kfree(p->kstack, KSTACKSIZE);
  10591d:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  105920:	8b 40 08             	mov    0x8(%eax),%eax
  105923:	c7 44 24 04 00 10 00 	movl   $0x1000,0x4(%esp)
  10592a:	00 
  10592b:	89 04 24             	mov    %eax,(%esp)
  10592e:	e8 fd d9 ff ff       	call   103330 <kfree>
          pid = p->pid;
  105933:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  105936:	8b 40 10             	mov    0x10(%eax),%eax
  105939:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
          p->state = UNUSED;
  10593c:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10593f:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
          p->pid = 0;
  105946:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  105949:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
          p->parent = 0;
  105950:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  105953:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
          p->name[0] = 0;
  10595a:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10595d:	c6 80 88 00 00 00 00 	movb   $0x0,0x88(%eax)
          release(&proc_table_lock);
  105964:	c7 04 24 40 0c 14 00 	movl   $0x140c40,(%esp)
  10596b:	e8 d0 03 00 00       	call   105d40 <release>
          return pid;
  105970:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  105973:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
  105976:	eb 64                	jmp    1059dc <wait+0x14c>
        }
        havekids = 1;
  105978:	c7 45 f4 01 00 00 00 	movl   $0x1,0xfffffff4(%ebp)
  10597f:	83 45 f0 01          	addl   $0x1,0xfffffff0(%ebp)
  105983:	83 7d f0 3f          	cmpl   $0x3f,0xfffffff0(%ebp)
  105987:	0f 8e 29 ff ff ff    	jle    1058b6 <wait+0x26>
      }
    }

    // No point waiting if we don't have any children.
    if(!havekids || cp->killed){
  10598d:	83 7d f4 00          	cmpl   $0x0,0xfffffff4(%ebp)
  105991:	74 13                	je     1059a6 <wait+0x116>
  105993:	e8 28 df ff ff       	call   1038c0 <cpu>
  105998:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  10599f:	8b 40 1c             	mov    0x1c(%eax),%eax
  1059a2:	85 c0                	test   %eax,%eax
  1059a4:	74 15                	je     1059bb <wait+0x12b>
      release(&proc_table_lock);
  1059a6:	c7 04 24 40 0c 14 00 	movl   $0x140c40,(%esp)
  1059ad:	e8 8e 03 00 00       	call   105d40 <release>
      return -1;
  1059b2:	c7 45 e8 ff ff ff ff 	movl   $0xffffffff,0xffffffe8(%ebp)
  1059b9:	eb 21                	jmp    1059dc <wait+0x14c>
    }

    // Wait for children to exit.  (See wakeup1 call in proc_exit.)
    sleep(cp, &proc_table_lock);
  1059bb:	e8 00 df ff ff       	call   1038c0 <cpu>
  1059c0:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  1059c7:	c7 44 24 04 40 0c 14 	movl   $0x140c40,0x4(%esp)
  1059ce:	00 
  1059cf:	89 04 24             	mov    %eax,(%esp)
  1059d2:	e8 b9 fa ff ff       	call   105490 <sleep>
  }
  1059d7:	e9 c7 fe ff ff       	jmp    1058a3 <wait+0x13>
  1059dc:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
}
  1059df:	83 c4 24             	add    $0x24,%esp
  1059e2:	5b                   	pop    %ebx
  1059e3:	5d                   	pop    %ebp
  1059e4:	c3                   	ret    
  1059e5:	8d 74 26 00          	lea    0x0(%esi),%esi
  1059e9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

001059f0 <procdump>:

// Print a process listing to console.  For debugging.
// Runs when user types ^P on console.
// No lock to avoid wedging a stuck machine further.
void
procdump(void)
{
  1059f0:	55                   	push   %ebp
  1059f1:	89 e5                	mov    %esp,%ebp
  1059f3:	83 ec 58             	sub    $0x58,%esp
  static char *states[] = {
  [UNUSED]    "unused",
  [EMBRYO]    "embryo",
  [SLEEPING]  "sleep ",
  [RUNNABLE]  "runble",
  [RUNNING]   "run   ",
  [ZOMBIE]    "zombie",
  [MSLEEPING] "msleep"
  };
  int i, j;
  struct proc *p;
  char *state;
  uint pc[10];
  
  for(i = 0; i < NPROC; i++){
  1059f6:	c7 45 f0 00 00 00 00 	movl   $0x0,0xfffffff0(%ebp)
  1059fd:	e9 f4 00 00 00       	jmp    105af6 <procdump+0x106>
    p = &proc[i];
  105a02:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  105a05:	69 c0 ac 00 00 00    	imul   $0xac,%eax,%eax
  105a0b:	05 20 e1 13 00       	add    $0x13e120,%eax
  105a10:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
    if(p->state == UNUSED)
  105a13:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  105a16:	8b 40 0c             	mov    0xc(%eax),%eax
  105a19:	85 c0                	test   %eax,%eax
  105a1b:	0f 84 d1 00 00 00    	je     105af2 <procdump+0x102>
      continue;
    if(p->state >= 0 && p->state < NELEM(states) && states[p->state])
  105a21:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  105a24:	8b 40 0c             	mov    0xc(%eax),%eax
  105a27:	83 f8 06             	cmp    $0x6,%eax
  105a2a:	77 23                	ja     105a4f <procdump+0x5f>
  105a2c:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  105a2f:	8b 40 0c             	mov    0xc(%eax),%eax
  105a32:	8b 04 85 f8 c5 11 00 	mov    0x11c5f8(,%eax,4),%eax
  105a39:	85 c0                	test   %eax,%eax
  105a3b:	74 12                	je     105a4f <procdump+0x5f>
      state = states[p->state];
  105a3d:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  105a40:	8b 40 0c             	mov    0xc(%eax),%eax
  105a43:	8b 04 85 f8 c5 11 00 	mov    0x11c5f8(,%eax,4),%eax
  105a4a:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  105a4d:	eb 07                	jmp    105a56 <procdump+0x66>
    else
      state = "???";
  105a4f:	c7 45 fc c4 a6 11 00 	movl   $0x11a6c4,0xfffffffc(%ebp)
    cprintf("%d %s %s", p->pid, state, p->name);
  105a56:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  105a59:	81 c2 88 00 00 00    	add    $0x88,%edx
  105a5f:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  105a62:	8b 48 10             	mov    0x10(%eax),%ecx
  105a65:	89 54 24 0c          	mov    %edx,0xc(%esp)
  105a69:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  105a6c:	89 44 24 08          	mov    %eax,0x8(%esp)
  105a70:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  105a74:	c7 04 24 c8 a6 11 00 	movl   $0x11a6c8,(%esp)
  105a7b:	e8 90 ac ff ff       	call   100710 <cprintf>
    if((p->state == SLEEPING) || (p->state == MSLEEPING)){
  105a80:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  105a83:	8b 40 0c             	mov    0xc(%eax),%eax
  105a86:	83 f8 02             	cmp    $0x2,%eax
  105a89:	74 0b                	je     105a96 <procdump+0xa6>
  105a8b:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  105a8e:	8b 40 0c             	mov    0xc(%eax),%eax
  105a91:	83 f8 06             	cmp    $0x6,%eax
  105a94:	75 50                	jne    105ae6 <procdump+0xf6>
      getcallerpcs((uint*)p->context.ebp+2, pc);
  105a96:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  105a99:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
  105a9f:	8d 50 08             	lea    0x8(%eax),%edx
  105aa2:	8d 45 c8             	lea    0xffffffc8(%ebp),%eax
  105aa5:	89 44 24 04          	mov    %eax,0x4(%esp)
  105aa9:	89 14 24             	mov    %edx,(%esp)
  105aac:	e8 5f 03 00 00       	call   105e10 <getcallerpcs>
      for(j=0; j<10 && pc[j] != 0; j++)
  105ab1:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
  105ab8:	eb 1b                	jmp    105ad5 <procdump+0xe5>
        cprintf(" %p", pc[j]);
  105aba:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  105abd:	8b 44 85 c8          	mov    0xffffffc8(%ebp,%eax,4),%eax
  105ac1:	89 44 24 04          	mov    %eax,0x4(%esp)
  105ac5:	c7 04 24 d1 a6 11 00 	movl   $0x11a6d1,(%esp)
  105acc:	e8 3f ac ff ff       	call   100710 <cprintf>
  105ad1:	83 45 f4 01          	addl   $0x1,0xfffffff4(%ebp)
  105ad5:	83 7d f4 09          	cmpl   $0x9,0xfffffff4(%ebp)
  105ad9:	7f 0b                	jg     105ae6 <procdump+0xf6>
  105adb:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  105ade:	8b 44 85 c8          	mov    0xffffffc8(%ebp,%eax,4),%eax
  105ae2:	85 c0                	test   %eax,%eax
  105ae4:	75 d4                	jne    105aba <procdump+0xca>
    }
    cprintf("\n");
  105ae6:	c7 04 24 d5 a6 11 00 	movl   $0x11a6d5,(%esp)
  105aed:	e8 1e ac ff ff       	call   100710 <cprintf>
  105af2:	83 45 f0 01          	addl   $0x1,0xfffffff0(%ebp)
  105af6:	83 7d f0 3f          	cmpl   $0x3f,0xfffffff0(%ebp)
  105afa:	0f 8e 02 ff ff ff    	jle    105a02 <procdump+0x12>
  }
}
  105b00:	c9                   	leave  
  105b01:	c3                   	ret    
  105b02:	90                   	nop    
  105b03:	90                   	nop    
  105b04:	90                   	nop    
  105b05:	90                   	nop    
  105b06:	90                   	nop    
  105b07:	90                   	nop    
  105b08:	90                   	nop    
  105b09:	90                   	nop    
  105b0a:	90                   	nop    
  105b0b:	90                   	nop    
  105b0c:	90                   	nop    
  105b0d:	90                   	nop    
  105b0e:	90                   	nop    
  105b0f:	90                   	nop    

00105b10 <initlock>:
extern int use_console_lock;

void
initlock(struct spinlock *lock, char *name)
{
  105b10:	55                   	push   %ebp
  105b11:	89 e5                	mov    %esp,%ebp
  lock->name = name;
  105b13:	8b 55 08             	mov    0x8(%ebp),%edx
  105b16:	8b 45 0c             	mov    0xc(%ebp),%eax
  105b19:	89 42 04             	mov    %eax,0x4(%edx)
  lock->locked = 0;
  105b1c:	8b 45 08             	mov    0x8(%ebp),%eax
  105b1f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  lock->cpu = 0xffffffff;
  105b25:	8b 45 08             	mov    0x8(%ebp),%eax
  105b28:	c7 40 08 ff ff ff ff 	movl   $0xffffffff,0x8(%eax)
}
  105b2f:	5d                   	pop    %ebp
  105b30:	c3                   	ret    
  105b31:	eb 0d                	jmp    105b40 <acquire>
  105b33:	90                   	nop    
  105b34:	90                   	nop    
  105b35:	90                   	nop    
  105b36:	90                   	nop    
  105b37:	90                   	nop    
  105b38:	90                   	nop    
  105b39:	90                   	nop    
  105b3a:	90                   	nop    
  105b3b:	90                   	nop    
  105b3c:	90                   	nop    
  105b3d:	90                   	nop    
  105b3e:	90                   	nop    
  105b3f:	90                   	nop    

00105b40 <acquire>:

int int_enabled;
// Acquire the lock.
// Loops (spins) until the lock is acquired.
// Holding a lock for a long time may cause
// other CPUs to waste time spinning to acquire it.
void
acquire(struct spinlock *lock)
{
  105b40:	55                   	push   %ebp
  105b41:	89 e5                	mov    %esp,%ebp
  105b43:	53                   	push   %ebx
  105b44:	83 ec 24             	sub    $0x24,%esp
  if(holding(lock))
  105b47:	8b 45 08             	mov    0x8(%ebp),%eax
  105b4a:	89 04 24             	mov    %eax,(%esp)
  105b4d:	e8 2e 03 00 00       	call   105e80 <holding>
  105b52:	85 c0                	test   %eax,%eax
  105b54:	74 6e                	je     105bc4 <acquire+0x84>
  {
    cprintf("lock already acquired by:\n");
  105b56:	c7 04 24 d8 a6 11 00 	movl   $0x11a6d8,(%esp)
  105b5d:	e8 ae ab ff ff       	call   100710 <cprintf>
    int i;
    for (i=0; i<10; i++)
  105b62:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)
  105b69:	eb 3b                	jmp    105ba6 <acquire+0x66>
    {
        if ((lock->pcs[i] == 0) || (lock->pcs[i] == 0xffffffff))
  105b6b:	8b 45 08             	mov    0x8(%ebp),%eax
  105b6e:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  105b71:	8b 44 90 0c          	mov    0xc(%eax,%edx,4),%eax
  105b75:	85 c0                	test   %eax,%eax
  105b77:	74 33                	je     105bac <acquire+0x6c>
  105b79:	8b 45 08             	mov    0x8(%ebp),%eax
  105b7c:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  105b7f:	8b 44 90 0c          	mov    0xc(%eax,%edx,4),%eax
  105b83:	83 f8 ff             	cmp    $0xffffffff,%eax
  105b86:	74 24                	je     105bac <acquire+0x6c>
            break;
        cprintf("0x%08x ", lock->pcs[i]);
  105b88:	8b 45 08             	mov    0x8(%ebp),%eax
  105b8b:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  105b8e:	8b 44 90 0c          	mov    0xc(%eax,%edx,4),%eax
  105b92:	89 44 24 04          	mov    %eax,0x4(%esp)
  105b96:	c7 04 24 f3 a6 11 00 	movl   $0x11a6f3,(%esp)
  105b9d:	e8 6e ab ff ff       	call   100710 <cprintf>
  105ba2:	83 45 f8 01          	addl   $0x1,0xfffffff8(%ebp)
  105ba6:	83 7d f8 09          	cmpl   $0x9,0xfffffff8(%ebp)
  105baa:	7e bf                	jle    105b6b <acquire+0x2b>
    }
    cprintf("\n");
  105bac:	c7 04 24 fb a6 11 00 	movl   $0x11a6fb,(%esp)
  105bb3:	e8 58 ab ff ff       	call   100710 <cprintf>
    panic("acquire");
  105bb8:	c7 04 24 fd a6 11 00 	movl   $0x11a6fd,(%esp)
  105bbf:	e8 4c b4 ff ff       	call   101010 <panic>
  }

//  if(cpus[cpu()].nlock == 0)
//  {
//    int_enabled = 0;
    cli();
  105bc4:	e8 c7 00 00 00       	call   105c90 <cli>
//    cprintf("!D");
// }
  cpus[cpu()].nlock++;
  105bc9:	e8 f2 dc ff ff       	call   1038c0 <cpu>
  105bce:	89 c1                	mov    %eax,%ecx
  105bd0:	69 c1 ec 10 00 00    	imul   $0x10ec,%ecx,%eax
  105bd6:	8b 80 e0 dc 13 00    	mov    0x13dce0(%eax),%eax
  105bdc:	8d 50 01             	lea    0x1(%eax),%edx
  105bdf:	69 c1 ec 10 00 00    	imul   $0x10ec,%ecx,%eax
  105be5:	89 90 e0 dc 13 00    	mov    %edx,0x13dce0(%eax)
  cpus[cpu()].locks[cpus[cpu()].nlock] = lock;
  105beb:	e8 d0 dc ff ff       	call   1038c0 <cpu>
  105bf0:	89 c3                	mov    %eax,%ebx
  105bf2:	e8 c9 dc ff ff       	call   1038c0 <cpu>
  105bf7:	69 c0 ec 10 00 00    	imul   $0x10ec,%eax,%eax
  105bfd:	8b 90 e0 dc 13 00    	mov    0x13dce0(%eax),%edx
  105c03:	8b 4d 08             	mov    0x8(%ebp),%ecx
  105c06:	69 c3 3b 04 00 00    	imul   $0x43b,%ebx,%eax
  105c0c:	01 d0                	add    %edx,%eax
  105c0e:	89 0c 85 e4 dc 13 00 	mov    %ecx,0x13dce4(,%eax,4)

  while(cmpxchg(0, 1, &lock->locked) == 1)
  105c15:	8b 45 08             	mov    0x8(%ebp),%eax
  105c18:	89 44 24 08          	mov    %eax,0x8(%esp)
  105c1c:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  105c23:	00 
  105c24:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  105c2b:	e8 70 00 00 00       	call   105ca0 <cmpxchg>
  105c30:	83 f8 01             	cmp    $0x1,%eax
  105c33:	74 e0                	je     105c15 <acquire+0xd5>
    ;

  // Serialize instructions: now that lock is acquired, make sure 
  // we wait for all pending writes from other processors.
  cpuid(0, 0, 0, 0, 0);  // memory barrier (see Ch 7, IA-32 manual vol 3)
  105c35:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  105c3c:	00 
  105c3d:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  105c44:	00 
  105c45:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  105c4c:	00 
  105c4d:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  105c54:	00 
  105c55:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  105c5c:	e8 7f 00 00 00       	call   105ce0 <cpuid>
  
  // Record info about lock acquisition for debugging.
  // The +10 is only so that we can tell the difference
  // between forgetting to initialize lock->cpu
  // and holding a lock on cpu 0.
  lock->cpu = cpu() + 10;
  105c61:	8b 5d 08             	mov    0x8(%ebp),%ebx
  105c64:	e8 57 dc ff ff       	call   1038c0 <cpu>
  105c69:	83 c0 0a             	add    $0xa,%eax
  105c6c:	89 43 08             	mov    %eax,0x8(%ebx)
  getcallerpcs(&lock, lock->pcs);
  105c6f:	8b 45 08             	mov    0x8(%ebp),%eax
  105c72:	83 c0 0c             	add    $0xc,%eax
  105c75:	89 44 24 04          	mov    %eax,0x4(%esp)
  105c79:	8d 45 08             	lea    0x8(%ebp),%eax
  105c7c:	89 04 24             	mov    %eax,(%esp)
  105c7f:	e8 8c 01 00 00       	call   105e10 <getcallerpcs>
}
  105c84:	83 c4 24             	add    $0x24,%esp
  105c87:	5b                   	pop    %ebx
  105c88:	5d                   	pop    %ebp
  105c89:	c3                   	ret    
  105c8a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

00105c90 <cli>:
}

static inline void
cli(void)
{
  105c90:	55                   	push   %ebp
  105c91:	89 e5                	mov    %esp,%ebp
  asm volatile("cli");
  105c93:	fa                   	cli    
}
  105c94:	5d                   	pop    %ebp
  105c95:	c3                   	ret    
  105c96:	8d 76 00             	lea    0x0(%esi),%esi
  105c99:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00105ca0 <cmpxchg>:
  105ca0:	55                   	push   %ebp
  105ca1:	89 e5                	mov    %esp,%ebp
  105ca3:	56                   	push   %esi
  105ca4:	53                   	push   %ebx
  105ca5:	83 ec 14             	sub    $0x14,%esp
  105ca8:	8b 5d 10             	mov    0x10(%ebp),%ebx
  105cab:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  105cae:	8b 55 08             	mov    0x8(%ebp),%edx
  105cb1:	8b 45 10             	mov    0x10(%ebp),%eax
  105cb4:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
  105cb7:	89 d0                	mov    %edx,%eax
  105cb9:	8b 75 e4             	mov    0xffffffe4(%ebp),%esi
  105cbc:	f0 0f b1 0b          	lock cmpxchg %ecx,(%ebx)
  105cc0:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
  105cc3:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
  105cc6:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  105cc9:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  105ccc:	83 c4 14             	add    $0x14,%esp
  105ccf:	5b                   	pop    %ebx
  105cd0:	5e                   	pop    %esi
  105cd1:	5d                   	pop    %ebp
  105cd2:	c3                   	ret    
  105cd3:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  105cd9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00105ce0 <cpuid>:
  105ce0:	55                   	push   %ebp
  105ce1:	89 e5                	mov    %esp,%ebp
  105ce3:	53                   	push   %ebx
  105ce4:	83 ec 10             	sub    $0x10,%esp
  105ce7:	8b 45 08             	mov    0x8(%ebp),%eax
  105cea:	0f a2                	cpuid  
  105cec:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  105cef:	89 5d f0             	mov    %ebx,0xfffffff0(%ebp)
  105cf2:	89 4d f4             	mov    %ecx,0xfffffff4(%ebp)
  105cf5:	89 55 f8             	mov    %edx,0xfffffff8(%ebp)
  105cf8:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  105cfc:	74 08                	je     105d06 <cpuid+0x26>
  105cfe:	8b 55 0c             	mov    0xc(%ebp),%edx
  105d01:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  105d04:	89 02                	mov    %eax,(%edx)
  105d06:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  105d0a:	74 08                	je     105d14 <cpuid+0x34>
  105d0c:	8b 55 10             	mov    0x10(%ebp),%edx
  105d0f:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  105d12:	89 02                	mov    %eax,(%edx)
  105d14:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
  105d18:	74 08                	je     105d22 <cpuid+0x42>
  105d1a:	8b 55 14             	mov    0x14(%ebp),%edx
  105d1d:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  105d20:	89 02                	mov    %eax,(%edx)
  105d22:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
  105d26:	74 08                	je     105d30 <cpuid+0x50>
  105d28:	8b 55 18             	mov    0x18(%ebp),%edx
  105d2b:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  105d2e:	89 02                	mov    %eax,(%edx)
  105d30:	83 c4 10             	add    $0x10,%esp
  105d33:	5b                   	pop    %ebx
  105d34:	5d                   	pop    %ebp
  105d35:	c3                   	ret    
  105d36:	8d 76 00             	lea    0x0(%esi),%esi
  105d39:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00105d40 <release>:

// Release the lock.
void
release(struct spinlock *lock)
{
  105d40:	55                   	push   %ebp
  105d41:	89 e5                	mov    %esp,%ebp
  105d43:	83 ec 18             	sub    $0x18,%esp
  if(!holding(lock))
  105d46:	8b 45 08             	mov    0x8(%ebp),%eax
  105d49:	89 04 24             	mov    %eax,(%esp)
  105d4c:	e8 2f 01 00 00       	call   105e80 <holding>
  105d51:	85 c0                	test   %eax,%eax
  105d53:	75 0c                	jne    105d61 <release+0x21>
    panic("release");
  105d55:	c7 04 24 05 a7 11 00 	movl   $0x11a705,(%esp)
  105d5c:	e8 af b2 ff ff       	call   101010 <panic>

  lock->pcs[0] = 0;
  105d61:	8b 45 08             	mov    0x8(%ebp),%eax
  105d64:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
  lock->cpu = 0xffffffff;
  105d6b:	8b 45 08             	mov    0x8(%ebp),%eax
  105d6e:	c7 40 08 ff ff ff ff 	movl   $0xffffffff,0x8(%eax)
  
  // Serialize instructions: before unlocking the lock, make sure
  // to flush any pending memory writes from this processor.
  cpuid(0, 0, 0, 0, 0);  // memory barrier (see Ch 7, IA-32 manual vol 3)
  105d75:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  105d7c:	00 
  105d7d:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  105d84:	00 
  105d85:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  105d8c:	00 
  105d8d:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  105d94:	00 
  105d95:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  105d9c:	e8 3f ff ff ff       	call   105ce0 <cpuid>

  if (int_enabled)
  105da1:	a1 74 0c 14 00       	mov    0x140c74,%eax
  105da6:	85 c0                	test   %eax,%eax
  105da8:	74 0c                	je     105db6 <release+0x76>
      panic("release when interrupts enabled");
  105daa:	c7 04 24 10 a7 11 00 	movl   $0x11a710,(%esp)
  105db1:	e8 5a b2 ff ff       	call   101010 <panic>
  lock->locked = 0;
  105db6:	8b 45 08             	mov    0x8(%ebp),%eax
  105db9:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  if(--cpus[cpu()].nlock == 0)
  105dbf:	e8 fc da ff ff       	call   1038c0 <cpu>
  105dc4:	89 c2                	mov    %eax,%edx
  105dc6:	69 c2 ec 10 00 00    	imul   $0x10ec,%edx,%eax
  105dcc:	8b 80 e0 dc 13 00    	mov    0x13dce0(%eax),%eax
  105dd2:	8d 48 ff             	lea    0xffffffff(%eax),%ecx
  105dd5:	69 c2 ec 10 00 00    	imul   $0x10ec,%edx,%eax
  105ddb:	89 88 e0 dc 13 00    	mov    %ecx,0x13dce0(%eax)
  105de1:	69 c2 ec 10 00 00    	imul   $0x10ec,%edx,%eax
  105de7:	8b 80 e0 dc 13 00    	mov    0x13dce0(%eax),%eax
  105ded:	85 c0                	test   %eax,%eax
  105def:	75 05                	jne    105df6 <release+0xb6>
  {
//      int_enabled = 1;
    sti();
  105df1:	e8 0a 00 00 00       	call   105e00 <sti>
 //   cprintf("!E");
  }
}
  105df6:	c9                   	leave  
  105df7:	c3                   	ret    
  105df8:	90                   	nop    
  105df9:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

00105e00 <sti>:
}

static inline void
sti(void)
{
  105e00:	55                   	push   %ebp
  105e01:	89 e5                	mov    %esp,%ebp
  asm volatile("sti");
  105e03:	fb                   	sti    
}
  105e04:	5d                   	pop    %ebp
  105e05:	c3                   	ret    
  105e06:	8d 76 00             	lea    0x0(%esi),%esi
  105e09:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00105e10 <getcallerpcs>:

// Record the current call stack in pcs[] by following the %ebp chain.
void
getcallerpcs(void *v, uint pcs[])
{
  105e10:	55                   	push   %ebp
  105e11:	89 e5                	mov    %esp,%ebp
  105e13:	83 ec 10             	sub    $0x10,%esp
  uint *ebp;
  int i;
  
  ebp = (uint*)v - 2;
  105e16:	8b 45 08             	mov    0x8(%ebp),%eax
  105e19:	83 e8 08             	sub    $0x8,%eax
  105e1c:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  for(i = 0; i < 10; i++){
  105e1f:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
  105e26:	eb 2d                	jmp    105e55 <getcallerpcs+0x45>
    if(ebp == 0 || ebp == (uint*)0xffffffff)
  105e28:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  105e2c:	74 42                	je     105e70 <getcallerpcs+0x60>
  105e2e:	83 7d f8 ff          	cmpl   $0xffffffff,0xfffffff8(%ebp)
  105e32:	74 3c                	je     105e70 <getcallerpcs+0x60>
      break;
    pcs[i] = ebp[1];     // saved %eip
  105e34:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  105e37:	c1 e0 02             	shl    $0x2,%eax
  105e3a:	89 c2                	mov    %eax,%edx
  105e3c:	03 55 0c             	add    0xc(%ebp),%edx
  105e3f:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  105e42:	83 c0 04             	add    $0x4,%eax
  105e45:	8b 00                	mov    (%eax),%eax
  105e47:	89 02                	mov    %eax,(%edx)
    ebp = (uint*)ebp[0]; // saved %ebp
  105e49:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  105e4c:	8b 00                	mov    (%eax),%eax
  105e4e:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  105e51:	83 45 fc 01          	addl   $0x1,0xfffffffc(%ebp)
  105e55:	83 7d fc 09          	cmpl   $0x9,0xfffffffc(%ebp)
  105e59:	7e cd                	jle    105e28 <getcallerpcs+0x18>
  }
  for(; i < 10; i++)
  105e5b:	eb 13                	jmp    105e70 <getcallerpcs+0x60>
    pcs[i] = 0;
  105e5d:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  105e60:	c1 e0 02             	shl    $0x2,%eax
  105e63:	03 45 0c             	add    0xc(%ebp),%eax
  105e66:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  105e6c:	83 45 fc 01          	addl   $0x1,0xfffffffc(%ebp)
  105e70:	83 7d fc 09          	cmpl   $0x9,0xfffffffc(%ebp)
  105e74:	7e e7                	jle    105e5d <getcallerpcs+0x4d>
}
  105e76:	c9                   	leave  
  105e77:	c3                   	ret    
  105e78:	90                   	nop    
  105e79:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

00105e80 <holding>:

// Check whether this cpu is holding the lock.
int
holding(struct spinlock *lock)
{
  105e80:	55                   	push   %ebp
  105e81:	89 e5                	mov    %esp,%ebp
  105e83:	53                   	push   %ebx
  105e84:	83 ec 04             	sub    $0x4,%esp
  return lock->locked && lock->cpu == cpu() + 10;
  105e87:	8b 45 08             	mov    0x8(%ebp),%eax
  105e8a:	8b 00                	mov    (%eax),%eax
  105e8c:	85 c0                	test   %eax,%eax
  105e8e:	74 1b                	je     105eab <holding+0x2b>
  105e90:	8b 45 08             	mov    0x8(%ebp),%eax
  105e93:	8b 58 08             	mov    0x8(%eax),%ebx
  105e96:	e8 25 da ff ff       	call   1038c0 <cpu>
  105e9b:	83 c0 0a             	add    $0xa,%eax
  105e9e:	39 c3                	cmp    %eax,%ebx
  105ea0:	75 09                	jne    105eab <holding+0x2b>
  105ea2:	c7 45 f8 01 00 00 00 	movl   $0x1,0xfffffff8(%ebp)
  105ea9:	eb 07                	jmp    105eb2 <holding+0x32>
  105eab:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)
  105eb2:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
}
  105eb5:	83 c4 04             	add    $0x4,%esp
  105eb8:	5b                   	pop    %ebx
  105eb9:	5d                   	pop    %ebp
  105eba:	c3                   	ret    
  105ebb:	90                   	nop    
  105ebc:	90                   	nop    
  105ebd:	90                   	nop    
  105ebe:	90                   	nop    
  105ebf:	90                   	nop    

00105ec0 <memcpy>:
#include "types.h"

void*
memcpy(void *dst, const void *src, uint n)
{
  105ec0:	55                   	push   %ebp
  105ec1:	89 e5                	mov    %esp,%ebp
  105ec3:	83 ec 10             	sub    $0x10,%esp
    const uchar *s1;
    uchar *s2;
    
    s1 = src;
  105ec6:	8b 45 0c             	mov    0xc(%ebp),%eax
  105ec9:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
    s2 = dst;
  105ecc:	8b 45 08             	mov    0x8(%ebp),%eax
  105ecf:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
    while(n-- > 0){
  105ed2:	eb 13                	jmp    105ee7 <memcpy+0x27>
        *s2 = *s1;
  105ed4:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  105ed7:	0f b6 10             	movzbl (%eax),%edx
  105eda:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  105edd:	88 10                	mov    %dl,(%eax)
        s1++;
  105edf:	83 45 f8 01          	addl   $0x1,0xfffffff8(%ebp)
        s2++;
  105ee3:	83 45 fc 01          	addl   $0x1,0xfffffffc(%ebp)
  105ee7:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
  105eeb:	83 7d 10 ff          	cmpl   $0xffffffff,0x10(%ebp)
  105eef:	75 e3                	jne    105ed4 <memcpy+0x14>
    }

    return 0;
  105ef1:	b8 00 00 00 00       	mov    $0x0,%eax
}
  105ef6:	c9                   	leave  
  105ef7:	c3                   	ret    
  105ef8:	90                   	nop    
  105ef9:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

00105f00 <memset>:

void*
memset(void *dst, int c, uint n)
{
  105f00:	55                   	push   %ebp
  105f01:	89 e5                	mov    %esp,%ebp
  105f03:	83 ec 10             	sub    $0x10,%esp
  char *d;

  d = (char*)dst;
  105f06:	8b 45 08             	mov    0x8(%ebp),%eax
  105f09:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  while(n-- > 0)
  105f0c:	eb 0e                	jmp    105f1c <memset+0x1c>
    *d++ = c;
  105f0e:	8b 45 0c             	mov    0xc(%ebp),%eax
  105f11:	89 c2                	mov    %eax,%edx
  105f13:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  105f16:	88 10                	mov    %dl,(%eax)
  105f18:	83 45 fc 01          	addl   $0x1,0xfffffffc(%ebp)
  105f1c:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
  105f20:	83 7d 10 ff          	cmpl   $0xffffffff,0x10(%ebp)
  105f24:	75 e8                	jne    105f0e <memset+0xe>

  return dst;
  105f26:	8b 45 08             	mov    0x8(%ebp),%eax
}
  105f29:	c9                   	leave  
  105f2a:	c3                   	ret    
  105f2b:	90                   	nop    
  105f2c:	8d 74 26 00          	lea    0x0(%esi),%esi

00105f30 <memcmp>:

int
memcmp(const void *v1, const void *v2, uint n)
{
  105f30:	55                   	push   %ebp
  105f31:	89 e5                	mov    %esp,%ebp
  105f33:	83 ec 14             	sub    $0x14,%esp
  const uchar *s1, *s2;
  
  s1 = v1;
  105f36:	8b 45 08             	mov    0x8(%ebp),%eax
  105f39:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  s2 = v2;
  105f3c:	8b 45 0c             	mov    0xc(%ebp),%eax
  105f3f:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  while(n-- > 0){
  105f42:	eb 33                	jmp    105f77 <memcmp+0x47>
    if(*s1 != *s2)
  105f44:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  105f47:	0f b6 10             	movzbl (%eax),%edx
  105f4a:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  105f4d:	0f b6 00             	movzbl (%eax),%eax
  105f50:	38 c2                	cmp    %al,%dl
  105f52:	74 1b                	je     105f6f <memcmp+0x3f>
      return *s1 - *s2;
  105f54:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  105f57:	0f b6 00             	movzbl (%eax),%eax
  105f5a:	0f b6 d0             	movzbl %al,%edx
  105f5d:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  105f60:	0f b6 00             	movzbl (%eax),%eax
  105f63:	0f b6 c0             	movzbl %al,%eax
  105f66:	89 d1                	mov    %edx,%ecx
  105f68:	29 c1                	sub    %eax,%ecx
  105f6a:	89 4d ec             	mov    %ecx,0xffffffec(%ebp)
  105f6d:	eb 19                	jmp    105f88 <memcmp+0x58>
    s1++, s2++;
  105f6f:	83 45 f8 01          	addl   $0x1,0xfffffff8(%ebp)
  105f73:	83 45 fc 01          	addl   $0x1,0xfffffffc(%ebp)
  105f77:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
  105f7b:	83 7d 10 ff          	cmpl   $0xffffffff,0x10(%ebp)
  105f7f:	75 c3                	jne    105f44 <memcmp+0x14>
  }

  return 0;
  105f81:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  105f88:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  105f8b:	c9                   	leave  
  105f8c:	c3                   	ret    
  105f8d:	8d 76 00             	lea    0x0(%esi),%esi

00105f90 <memmove>:

void*
memmove(void *dst, const void *src, uint n)
{
  105f90:	55                   	push   %ebp
  105f91:	89 e5                	mov    %esp,%ebp
  105f93:	83 ec 10             	sub    $0x10,%esp
  const char *s;
  char *d;

  s = src;
  105f96:	8b 45 0c             	mov    0xc(%ebp),%eax
  105f99:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  d = dst;
  105f9c:	8b 45 08             	mov    0x8(%ebp),%eax
  105f9f:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  if(s < d && s + n > d){
  105fa2:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  105fa5:	3b 45 fc             	cmp    0xfffffffc(%ebp),%eax
  105fa8:	73 4b                	jae    105ff5 <memmove+0x65>
  105faa:	8b 45 10             	mov    0x10(%ebp),%eax
  105fad:	03 45 f8             	add    0xfffffff8(%ebp),%eax
  105fb0:	3b 45 fc             	cmp    0xfffffffc(%ebp),%eax
  105fb3:	76 40                	jbe    105ff5 <memmove+0x65>
    s += n;
  105fb5:	8b 45 10             	mov    0x10(%ebp),%eax
  105fb8:	01 45 f8             	add    %eax,0xfffffff8(%ebp)
    d += n;
  105fbb:	8b 45 10             	mov    0x10(%ebp),%eax
  105fbe:	01 45 fc             	add    %eax,0xfffffffc(%ebp)
    while(n-- > 0)
  105fc1:	eb 13                	jmp    105fd6 <memmove+0x46>
      *--d = *--s;
  105fc3:	83 6d fc 01          	subl   $0x1,0xfffffffc(%ebp)
  105fc7:	83 6d f8 01          	subl   $0x1,0xfffffff8(%ebp)
  105fcb:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  105fce:	0f b6 10             	movzbl (%eax),%edx
  105fd1:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  105fd4:	88 10                	mov    %dl,(%eax)
  105fd6:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
  105fda:	83 7d 10 ff          	cmpl   $0xffffffff,0x10(%ebp)
  105fde:	75 e3                	jne    105fc3 <memmove+0x33>
  105fe0:	eb 1d                	jmp    105fff <memmove+0x6f>
  } else
    while(n-- > 0)
      *d++ = *s++;
  105fe2:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  105fe5:	0f b6 10             	movzbl (%eax),%edx
  105fe8:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  105feb:	88 10                	mov    %dl,(%eax)
  105fed:	83 45 fc 01          	addl   $0x1,0xfffffffc(%ebp)
  105ff1:	83 45 f8 01          	addl   $0x1,0xfffffff8(%ebp)
  105ff5:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
  105ff9:	83 7d 10 ff          	cmpl   $0xffffffff,0x10(%ebp)
  105ffd:	75 e3                	jne    105fe2 <memmove+0x52>

  return dst;
  105fff:	8b 45 08             	mov    0x8(%ebp),%eax
}
  106002:	c9                   	leave  
  106003:	c3                   	ret    
  106004:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  10600a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

00106010 <strncmp>:

int
strncmp(const char *p, const char *q, uint n)
{
  106010:	55                   	push   %ebp
  106011:	89 e5                	mov    %esp,%ebp
  106013:	83 ec 04             	sub    $0x4,%esp
  while(n > 0 && *p && *p == *q)
  106016:	eb 0c                	jmp    106024 <strncmp+0x14>
    n--, p++, q++;
  106018:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
  10601c:	83 45 08 01          	addl   $0x1,0x8(%ebp)
  106020:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
  106024:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  106028:	74 1a                	je     106044 <strncmp+0x34>
  10602a:	8b 45 08             	mov    0x8(%ebp),%eax
  10602d:	0f b6 00             	movzbl (%eax),%eax
  106030:	84 c0                	test   %al,%al
  106032:	74 10                	je     106044 <strncmp+0x34>
  106034:	8b 45 08             	mov    0x8(%ebp),%eax
  106037:	0f b6 10             	movzbl (%eax),%edx
  10603a:	8b 45 0c             	mov    0xc(%ebp),%eax
  10603d:	0f b6 00             	movzbl (%eax),%eax
  106040:	38 c2                	cmp    %al,%dl
  106042:	74 d4                	je     106018 <strncmp+0x8>
  if(n == 0)
  106044:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  106048:	75 09                	jne    106053 <strncmp+0x43>
    return 0;
  10604a:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
  106051:	eb 19                	jmp    10606c <strncmp+0x5c>
  return (uchar)*p - (uchar)*q;
  106053:	8b 45 08             	mov    0x8(%ebp),%eax
  106056:	0f b6 00             	movzbl (%eax),%eax
  106059:	0f b6 d0             	movzbl %al,%edx
  10605c:	8b 45 0c             	mov    0xc(%ebp),%eax
  10605f:	0f b6 00             	movzbl (%eax),%eax
  106062:	0f b6 c0             	movzbl %al,%eax
  106065:	89 d1                	mov    %edx,%ecx
  106067:	29 c1                	sub    %eax,%ecx
  106069:	89 4d fc             	mov    %ecx,0xfffffffc(%ebp)
  10606c:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
}
  10606f:	c9                   	leave  
  106070:	c3                   	ret    
  106071:	eb 0d                	jmp    106080 <strncpy>
  106073:	90                   	nop    
  106074:	90                   	nop    
  106075:	90                   	nop    
  106076:	90                   	nop    
  106077:	90                   	nop    
  106078:	90                   	nop    
  106079:	90                   	nop    
  10607a:	90                   	nop    
  10607b:	90                   	nop    
  10607c:	90                   	nop    
  10607d:	90                   	nop    
  10607e:	90                   	nop    
  10607f:	90                   	nop    

00106080 <strncpy>:

char*
strncpy(char *s, const char *t, int n)
{
  106080:	55                   	push   %ebp
  106081:	89 e5                	mov    %esp,%ebp
  106083:	83 ec 10             	sub    $0x10,%esp
  char *os;
  
  os = s;
  106086:	8b 45 08             	mov    0x8(%ebp),%eax
  106089:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  while(n-- > 0 && (*s++ = *t++) != 0)
  10608c:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  106090:	0f 9f c0             	setg   %al
  106093:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
  106097:	83 f0 01             	xor    $0x1,%eax
  10609a:	84 c0                	test   %al,%al
  10609c:	75 2e                	jne    1060cc <strncpy+0x4c>
  10609e:	8b 45 0c             	mov    0xc(%ebp),%eax
  1060a1:	0f b6 10             	movzbl (%eax),%edx
  1060a4:	8b 45 08             	mov    0x8(%ebp),%eax
  1060a7:	88 10                	mov    %dl,(%eax)
  1060a9:	8b 45 08             	mov    0x8(%ebp),%eax
  1060ac:	0f b6 00             	movzbl (%eax),%eax
  1060af:	84 c0                	test   %al,%al
  1060b1:	0f 95 c0             	setne  %al
  1060b4:	83 45 08 01          	addl   $0x1,0x8(%ebp)
  1060b8:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
  1060bc:	84 c0                	test   %al,%al
  1060be:	75 cc                	jne    10608c <strncpy+0xc>
    ;
  while(n-- > 0)
  1060c0:	eb 0a                	jmp    1060cc <strncpy+0x4c>
    *s++ = 0;
  1060c2:	8b 45 08             	mov    0x8(%ebp),%eax
  1060c5:	c6 00 00             	movb   $0x0,(%eax)
  1060c8:	83 45 08 01          	addl   $0x1,0x8(%ebp)
  1060cc:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  1060d0:	0f 9f c0             	setg   %al
  1060d3:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
  1060d7:	84 c0                	test   %al,%al
  1060d9:	75 e7                	jne    1060c2 <strncpy+0x42>
  return os;
  1060db:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
}
  1060de:	c9                   	leave  
  1060df:	c3                   	ret    

001060e0 <safestrcpy>:

// Like strncpy but guaranteed to NUL-terminate.
char*
safestrcpy(char *s, const char *t, int n)
{
  1060e0:	55                   	push   %ebp
  1060e1:	89 e5                	mov    %esp,%ebp
  1060e3:	83 ec 14             	sub    $0x14,%esp
  char *os;
  
  os = s;
  1060e6:	8b 45 08             	mov    0x8(%ebp),%eax
  1060e9:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  if(n <= 0)
  1060ec:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  1060f0:	7f 08                	jg     1060fa <safestrcpy+0x1a>
    return os;
  1060f2:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1060f5:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  1060f8:	eb 38                	jmp    106132 <safestrcpy+0x52>
  while(--n > 0 && (*s++ = *t++) != 0)
  1060fa:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
  1060fe:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  106102:	7e 22                	jle    106126 <safestrcpy+0x46>
  106104:	8b 45 0c             	mov    0xc(%ebp),%eax
  106107:	0f b6 10             	movzbl (%eax),%edx
  10610a:	8b 45 08             	mov    0x8(%ebp),%eax
  10610d:	88 10                	mov    %dl,(%eax)
  10610f:	8b 45 08             	mov    0x8(%ebp),%eax
  106112:	0f b6 00             	movzbl (%eax),%eax
  106115:	84 c0                	test   %al,%al
  106117:	0f 95 c0             	setne  %al
  10611a:	83 45 08 01          	addl   $0x1,0x8(%ebp)
  10611e:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
  106122:	84 c0                	test   %al,%al
  106124:	75 d4                	jne    1060fa <safestrcpy+0x1a>
    ;
  *s = 0;
  106126:	8b 45 08             	mov    0x8(%ebp),%eax
  106129:	c6 00 00             	movb   $0x0,(%eax)
  return os;
  10612c:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10612f:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  106132:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  106135:	c9                   	leave  
  106136:	c3                   	ret    
  106137:	89 f6                	mov    %esi,%esi
  106139:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00106140 <strlen>:

int
strlen(const char *s)
{
  106140:	55                   	push   %ebp
  106141:	89 e5                	mov    %esp,%ebp
  106143:	83 ec 10             	sub    $0x10,%esp
  int n;

  for(n = 0; s[n]; n++)
  106146:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
  10614d:	eb 04                	jmp    106153 <strlen+0x13>
  10614f:	83 45 fc 01          	addl   $0x1,0xfffffffc(%ebp)
  106153:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  106156:	03 45 08             	add    0x8(%ebp),%eax
  106159:	0f b6 00             	movzbl (%eax),%eax
  10615c:	84 c0                	test   %al,%al
  10615e:	75 ef                	jne    10614f <strlen+0xf>
    ;
  return n;
  106160:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
}
  106163:	c9                   	leave  
  106164:	c3                   	ret    
  106165:	90                   	nop    
  106166:	90                   	nop    
  106167:	90                   	nop    

00106168 <swtch>:
  106168:	8b 44 24 04          	mov    0x4(%esp),%eax
  10616c:	8f 40 00             	popl   0x0(%eax)
  10616f:	89 60 04             	mov    %esp,0x4(%eax)
  106172:	89 58 08             	mov    %ebx,0x8(%eax)
  106175:	89 48 0c             	mov    %ecx,0xc(%eax)
  106178:	89 50 10             	mov    %edx,0x10(%eax)
  10617b:	89 70 14             	mov    %esi,0x14(%eax)
  10617e:	89 78 18             	mov    %edi,0x18(%eax)
  106181:	89 68 1c             	mov    %ebp,0x1c(%eax)
  106184:	8b 44 24 04          	mov    0x4(%esp),%eax
  106188:	8b 68 1c             	mov    0x1c(%eax),%ebp
  10618b:	8b 78 18             	mov    0x18(%eax),%edi
  10618e:	8b 70 14             	mov    0x14(%eax),%esi
  106191:	8b 50 10             	mov    0x10(%eax),%edx
  106194:	8b 48 0c             	mov    0xc(%eax),%ecx
  106197:	8b 58 08             	mov    0x8(%eax),%ebx
  10619a:	8b 60 04             	mov    0x4(%eax),%esp
  10619d:	ff 70 00             	pushl  0x0(%eax)
  1061a0:	c3                   	ret    
  1061a1:	90                   	nop    
  1061a2:	90                   	nop    
  1061a3:	90                   	nop    
  1061a4:	90                   	nop    
  1061a5:	90                   	nop    
  1061a6:	90                   	nop    
  1061a7:	90                   	nop    
  1061a8:	90                   	nop    
  1061a9:	90                   	nop    
  1061aa:	90                   	nop    
  1061ab:	90                   	nop    
  1061ac:	90                   	nop    
  1061ad:	90                   	nop    
  1061ae:	90                   	nop    
  1061af:	90                   	nop    

001061b0 <fetchint>:

// Fetch the int at addr from process p.
int
fetchint(struct proc *p, uint addr, int *ip)
{
  1061b0:	55                   	push   %ebp
  1061b1:	89 e5                	mov    %esp,%ebp
  1061b3:	83 ec 04             	sub    $0x4,%esp
  if(addr >= p->sz || addr+4 > p->sz)
  1061b6:	8b 45 08             	mov    0x8(%ebp),%eax
  1061b9:	8b 40 04             	mov    0x4(%eax),%eax
  1061bc:	3b 45 0c             	cmp    0xc(%ebp),%eax
  1061bf:	76 10                	jbe    1061d1 <fetchint+0x21>
  1061c1:	8b 45 0c             	mov    0xc(%ebp),%eax
  1061c4:	83 c0 04             	add    $0x4,%eax
  1061c7:	8b 55 08             	mov    0x8(%ebp),%edx
  1061ca:	8b 52 04             	mov    0x4(%edx),%edx
  1061cd:	39 d0                	cmp    %edx,%eax
  1061cf:	76 09                	jbe    1061da <fetchint+0x2a>
    return -1;
  1061d1:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,0xfffffffc(%ebp)
  1061d8:	eb 19                	jmp    1061f3 <fetchint+0x43>
  *ip = *(int*)(p->mem + addr);
  1061da:	8b 45 08             	mov    0x8(%ebp),%eax
  1061dd:	8b 10                	mov    (%eax),%edx
  1061df:	8b 45 0c             	mov    0xc(%ebp),%eax
  1061e2:	8d 04 02             	lea    (%edx,%eax,1),%eax
  1061e5:	8b 10                	mov    (%eax),%edx
  1061e7:	8b 45 10             	mov    0x10(%ebp),%eax
  1061ea:	89 10                	mov    %edx,(%eax)
  return 0;
  1061ec:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
  1061f3:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
}
  1061f6:	c9                   	leave  
  1061f7:	c3                   	ret    
  1061f8:	90                   	nop    
  1061f9:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

00106200 <fetchstr>:

// Fetch the nul-terminated string at addr from process p.
// Doesn't actually copy the string - just sets *pp to point at it.
// Returns length of string, not including nul.
int
fetchstr(struct proc *p, uint addr, char **pp)
{
  106200:	55                   	push   %ebp
  106201:	89 e5                	mov    %esp,%ebp
  106203:	83 ec 14             	sub    $0x14,%esp
  char *s, *ep;

  if(addr >= p->sz)
  106206:	8b 45 08             	mov    0x8(%ebp),%eax
  106209:	8b 40 04             	mov    0x4(%eax),%eax
  10620c:	3b 45 0c             	cmp    0xc(%ebp),%eax
  10620f:	77 09                	ja     10621a <fetchstr+0x1a>
    return -1;
  106211:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  106218:	eb 58                	jmp    106272 <fetchstr+0x72>
  *pp = p->mem + addr;
  10621a:	8b 45 08             	mov    0x8(%ebp),%eax
  10621d:	8b 10                	mov    (%eax),%edx
  10621f:	8b 45 0c             	mov    0xc(%ebp),%eax
  106222:	01 c2                	add    %eax,%edx
  106224:	8b 45 10             	mov    0x10(%ebp),%eax
  106227:	89 10                	mov    %edx,(%eax)
  ep = p->mem + p->sz;
  106229:	8b 45 08             	mov    0x8(%ebp),%eax
  10622c:	8b 10                	mov    (%eax),%edx
  10622e:	8b 45 08             	mov    0x8(%ebp),%eax
  106231:	8b 40 04             	mov    0x4(%eax),%eax
  106234:	8d 04 02             	lea    (%edx,%eax,1),%eax
  106237:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  for(s = *pp; s < ep; s++)
  10623a:	8b 45 10             	mov    0x10(%ebp),%eax
  10623d:	8b 00                	mov    (%eax),%eax
  10623f:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  106242:	eb 1f                	jmp    106263 <fetchstr+0x63>
    if(*s == 0)
  106244:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  106247:	0f b6 00             	movzbl (%eax),%eax
  10624a:	84 c0                	test   %al,%al
  10624c:	75 11                	jne    10625f <fetchstr+0x5f>
      return s - *pp;
  10624e:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  106251:	8b 45 10             	mov    0x10(%ebp),%eax
  106254:	8b 00                	mov    (%eax),%eax
  106256:	89 d1                	mov    %edx,%ecx
  106258:	29 c1                	sub    %eax,%ecx
  10625a:	89 4d ec             	mov    %ecx,0xffffffec(%ebp)
  10625d:	eb 13                	jmp    106272 <fetchstr+0x72>
  10625f:	83 45 f8 01          	addl   $0x1,0xfffffff8(%ebp)
  106263:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  106266:	3b 45 fc             	cmp    0xfffffffc(%ebp),%eax
  106269:	72 d9                	jb     106244 <fetchstr+0x44>
  return -1;
  10626b:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  106272:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  106275:	c9                   	leave  
  106276:	c3                   	ret    
  106277:	89 f6                	mov    %esi,%esi
  106279:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00106280 <argint>:

// Fetch the nth 32-bit system call argument.
int
argint(int n, int *ip)
{
  106280:	55                   	push   %ebp
  106281:	89 e5                	mov    %esp,%ebp
  106283:	53                   	push   %ebx
  106284:	83 ec 14             	sub    $0x14,%esp
  return fetchint(cp, cp->tf->esp + 4 + 4*n, ip);
  106287:	e8 34 d6 ff ff       	call   1038c0 <cpu>
  10628c:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  106293:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
  106299:	8b 50 3c             	mov    0x3c(%eax),%edx
  10629c:	8b 45 08             	mov    0x8(%ebp),%eax
  10629f:	c1 e0 02             	shl    $0x2,%eax
  1062a2:	8d 04 02             	lea    (%edx,%eax,1),%eax
  1062a5:	8d 58 04             	lea    0x4(%eax),%ebx
  1062a8:	e8 13 d6 ff ff       	call   1038c0 <cpu>
  1062ad:	8b 14 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%edx
  1062b4:	8b 45 0c             	mov    0xc(%ebp),%eax
  1062b7:	89 44 24 08          	mov    %eax,0x8(%esp)
  1062bb:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  1062bf:	89 14 24             	mov    %edx,(%esp)
  1062c2:	e8 e9 fe ff ff       	call   1061b0 <fetchint>
}
  1062c7:	83 c4 14             	add    $0x14,%esp
  1062ca:	5b                   	pop    %ebx
  1062cb:	5d                   	pop    %ebp
  1062cc:	c3                   	ret    
  1062cd:	8d 76 00             	lea    0x0(%esi),%esi

001062d0 <argptr>:

// Fetch the nth word-sized system call argument as a pointer
// to a block of memory of size n bytes.  Check that the pointer
// lies within the process address space.
int
argptr(int n, char **pp, int size)
{
  1062d0:	55                   	push   %ebp
  1062d1:	89 e5                	mov    %esp,%ebp
  1062d3:	53                   	push   %ebx
  1062d4:	83 ec 24             	sub    $0x24,%esp
  int i;
  
  if(argint(n, &i) < 0)
  1062d7:	8d 45 f8             	lea    0xfffffff8(%ebp),%eax
  1062da:	89 44 24 04          	mov    %eax,0x4(%esp)
  1062de:	8b 45 08             	mov    0x8(%ebp),%eax
  1062e1:	89 04 24             	mov    %eax,(%esp)
  1062e4:	e8 97 ff ff ff       	call   106280 <argint>
  1062e9:	85 c0                	test   %eax,%eax
  1062eb:	79 09                	jns    1062f6 <argptr+0x26>
    return -1;
  1062ed:	c7 45 e8 ff ff ff ff 	movl   $0xffffffff,0xffffffe8(%ebp)
  1062f4:	eb 5e                	jmp    106354 <argptr+0x84>
  if((uint)i >= cp->sz || (uint)i+size >= cp->sz)
  1062f6:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1062f9:	89 c3                	mov    %eax,%ebx
  1062fb:	e8 c0 d5 ff ff       	call   1038c0 <cpu>
  106300:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  106307:	8b 40 04             	mov    0x4(%eax),%eax
  10630a:	39 c3                	cmp    %eax,%ebx
  10630c:	73 1e                	jae    10632c <argptr+0x5c>
  10630e:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  106311:	89 c2                	mov    %eax,%edx
  106313:	8b 45 10             	mov    0x10(%ebp),%eax
  106316:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
  106319:	e8 a2 d5 ff ff       	call   1038c0 <cpu>
  10631e:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  106325:	8b 40 04             	mov    0x4(%eax),%eax
  106328:	39 c3                	cmp    %eax,%ebx
  10632a:	72 09                	jb     106335 <argptr+0x65>
    return -1;
  10632c:	c7 45 e8 ff ff ff ff 	movl   $0xffffffff,0xffffffe8(%ebp)
  106333:	eb 1f                	jmp    106354 <argptr+0x84>
  *pp = cp->mem + i;
  106335:	e8 86 d5 ff ff       	call   1038c0 <cpu>
  10633a:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  106341:	8b 10                	mov    (%eax),%edx
  106343:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  106346:	01 c2                	add    %eax,%edx
  106348:	8b 45 0c             	mov    0xc(%ebp),%eax
  10634b:	89 10                	mov    %edx,(%eax)
  return 0;
  10634d:	c7 45 e8 00 00 00 00 	movl   $0x0,0xffffffe8(%ebp)
  106354:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
}
  106357:	83 c4 24             	add    $0x24,%esp
  10635a:	5b                   	pop    %ebx
  10635b:	5d                   	pop    %ebp
  10635c:	c3                   	ret    
  10635d:	8d 76 00             	lea    0x0(%esi),%esi

00106360 <argstr>:

// Fetch the nth word-sized system call argument as a string pointer.
// Check that the pointer is valid and the string is nul-terminated.
// (There is no shared writable memory, so the string can't change
// between this check and being used by the kernel.)
int
argstr(int n, char **pp)
{
  106360:	55                   	push   %ebp
  106361:	89 e5                	mov    %esp,%ebp
  106363:	53                   	push   %ebx
  106364:	83 ec 24             	sub    $0x24,%esp
  int addr;
  if(argint(n, &addr) < 0)
  106367:	8d 45 f8             	lea    0xfffffff8(%ebp),%eax
  10636a:	89 44 24 04          	mov    %eax,0x4(%esp)
  10636e:	8b 45 08             	mov    0x8(%ebp),%eax
  106371:	89 04 24             	mov    %eax,(%esp)
  106374:	e8 07 ff ff ff       	call   106280 <argint>
  106379:	85 c0                	test   %eax,%eax
  10637b:	79 09                	jns    106386 <argstr+0x26>
    return -1;
  10637d:	c7 45 e8 ff ff ff ff 	movl   $0xffffffff,0xffffffe8(%ebp)
  106384:	eb 27                	jmp    1063ad <argstr+0x4d>
  return fetchstr(cp, addr, pp);
  106386:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  106389:	89 c3                	mov    %eax,%ebx
  10638b:	e8 30 d5 ff ff       	call   1038c0 <cpu>
  106390:	8b 14 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%edx
  106397:	8b 45 0c             	mov    0xc(%ebp),%eax
  10639a:	89 44 24 08          	mov    %eax,0x8(%esp)
  10639e:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  1063a2:	89 14 24             	mov    %edx,(%esp)
  1063a5:	e8 56 fe ff ff       	call   106200 <fetchstr>
  1063aa:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
  1063ad:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
}
  1063b0:	83 c4 24             	add    $0x24,%esp
  1063b3:	5b                   	pop    %ebx
  1063b4:	5d                   	pop    %ebp
  1063b5:	c3                   	ret    
  1063b6:	8d 76 00             	lea    0x0(%esi),%esi
  1063b9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

001063c0 <syscall>:

extern int sys_chdir(void);
extern int sys_close(void);
extern int sys_dup(void);
extern int sys_exec(void);
extern int sys_exit(void);
extern int sys_fork(void);
extern int sys_fstat(void);
extern int sys_getpid(void);
extern int sys_kill(void);
extern int sys_link(void);
extern int sys_mkdir(void);
extern int sys_mknod(void);
extern int sys_open(void);
extern int sys_pipe(void);
extern int sys_read(void);
extern int sys_sbrk(void);
extern int sys_sleep(void);
extern int sys_unlink(void);
extern int sys_wait(void);
extern int sys_write(void);
extern int sys_upmsec(void);
// BSD sockets
extern int sys_accept(void);
extern int sys_bind(void);
extern int sys_shutdown(void);
extern int sys_getsockopt(void);
extern int sys_setsockopt(void);
extern int sys_sockclose(void);
extern int sys_connect(void);
extern int sys_listen(void);
extern int sys_recv(void);
extern int sys_recvfrom(void);
extern int sys_send(void);
extern int sys_sendto(void);
extern int sys_socket(void);
extern int sys_getpeername (void);
extern int sys_getsockname (void);
//int lwip_read(int s, void *mem, int len);
//int lwip_write(int s, void *dataptr, int size);
//int lwip_select(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset,
//                struct timeval *timeout);
//extern int sys_sockioctl(void);

static int (*syscalls[])(void) = {
[SYS_chdir]   sys_chdir,
[SYS_close]   sys_close,
[SYS_dup]     sys_dup,
[SYS_exec]    sys_exec,
[SYS_exit]    sys_exit,
[SYS_fork]    sys_fork,
[SYS_fstat]   sys_fstat,
[SYS_getpid]  sys_getpid,
[SYS_kill]    sys_kill,
[SYS_link]    sys_link,
[SYS_mkdir]   sys_mkdir,
[SYS_mknod]   sys_mknod,
[SYS_open]    sys_open,
[SYS_pipe]    sys_pipe,
[SYS_read]    sys_read,
[SYS_sbrk]    sys_sbrk,
[SYS_sleep]   sys_sleep,
[SYS_unlink]  sys_unlink,
[SYS_wait]    sys_wait,
[SYS_write]   sys_write,
[SYS_upmsec]  sys_upmsec,
// BSD socket
[SYS_socket]  sys_socket,
[SYS_bind]    sys_bind,
[SYS_listen]  sys_listen,
[SYS_accept]  sys_accept,
[SYS_recv]    sys_recv,
[SYS_recvfrom] sys_recvfrom,
[SYS_send]    sys_send,
[SYS_sendto]  sys_sendto,
[SYS_shutdown] sys_shutdown,
[SYS_getsockopt] sys_getsockopt,
[SYS_setsockopt] sys_setsockopt,
[SYS_sockclose] sys_sockclose,
[SYS_connect] sys_connect,
[SYS_getpeername] sys_getpeername,
[SYS_getsockname] sys_getsockname,
};

void
syscall(void)
{
  1063c0:	55                   	push   %ebp
  1063c1:	89 e5                	mov    %esp,%ebp
  1063c3:	53                   	push   %ebx
  1063c4:	83 ec 24             	sub    $0x24,%esp
  int num;
  
  num = cp->tf->eax;
  1063c7:	e8 f4 d4 ff ff       	call   1038c0 <cpu>
  1063cc:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  1063d3:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
  1063d9:	8b 40 1c             	mov    0x1c(%eax),%eax
  1063dc:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  if(num >= 0 && num < NELEM(syscalls) && syscalls[num])
  1063df:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  1063e3:	78 39                	js     10641e <syscall+0x5e>
  1063e5:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1063e8:	83 f8 24             	cmp    $0x24,%eax
  1063eb:	77 31                	ja     10641e <syscall+0x5e>
  1063ed:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1063f0:	8b 04 85 20 c6 11 00 	mov    0x11c620(,%eax,4),%eax
  1063f7:	85 c0                	test   %eax,%eax
  1063f9:	74 23                	je     10641e <syscall+0x5e>
    cp->tf->eax = syscalls[num]();
  1063fb:	e8 c0 d4 ff ff       	call   1038c0 <cpu>
  106400:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  106407:	8b 98 84 00 00 00    	mov    0x84(%eax),%ebx
  10640d:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  106410:	8b 04 85 20 c6 11 00 	mov    0x11c620(,%eax,4),%eax
  106417:	ff d0                	call   *%eax
  106419:	89 43 1c             	mov    %eax,0x1c(%ebx)
  10641c:	eb 55                	jmp    106473 <syscall+0xb3>
  else {
    cprintf("%d %s: unknown sys call %d\n",
  10641e:	e8 9d d4 ff ff       	call   1038c0 <cpu>
  106423:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  10642a:	8d 98 88 00 00 00    	lea    0x88(%eax),%ebx
  106430:	e8 8b d4 ff ff       	call   1038c0 <cpu>
  106435:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  10643c:	8b 50 10             	mov    0x10(%eax),%edx
  10643f:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  106442:	89 44 24 0c          	mov    %eax,0xc(%esp)
  106446:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  10644a:	89 54 24 04          	mov    %edx,0x4(%esp)
  10644e:	c7 04 24 30 a7 11 00 	movl   $0x11a730,(%esp)
  106455:	e8 b6 a2 ff ff       	call   100710 <cprintf>
            cp->pid, cp->name, num);
    cp->tf->eax = -1;
  10645a:	e8 61 d4 ff ff       	call   1038c0 <cpu>
  10645f:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  106466:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
  10646c:	c7 40 1c ff ff ff ff 	movl   $0xffffffff,0x1c(%eax)
  }
}
  106473:	83 c4 24             	add    $0x24,%esp
  106476:	5b                   	pop    %ebx
  106477:	5d                   	pop    %ebp
  106478:	c3                   	ret    
  106479:	90                   	nop    
  10647a:	90                   	nop    
  10647b:	90                   	nop    
  10647c:	90                   	nop    
  10647d:	90                   	nop    
  10647e:	90                   	nop    
  10647f:	90                   	nop    

00106480 <argfd>:
// Fetch the nth word-sized system call argument as a file descriptor
// and return both the descriptor and the corresponding struct file.
static int
argfd(int n, int *pfd, struct file **pf)
{
  106480:	55                   	push   %ebp
  106481:	89 e5                	mov    %esp,%ebp
  106483:	83 ec 28             	sub    $0x28,%esp
  int fd;
  struct file *f;

  if(argint(n, &fd) < 0)
  106486:	8d 45 f8             	lea    0xfffffff8(%ebp),%eax
  106489:	89 44 24 04          	mov    %eax,0x4(%esp)
  10648d:	8b 45 08             	mov    0x8(%ebp),%eax
  106490:	89 04 24             	mov    %eax,(%esp)
  106493:	e8 e8 fd ff ff       	call   106280 <argint>
  106498:	85 c0                	test   %eax,%eax
  10649a:	79 09                	jns    1064a5 <argfd+0x25>
    return -1;
  10649c:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  1064a3:	eb 57                	jmp    1064fc <argfd+0x7c>
  if(fd < 0 || fd >= NOFILE || (f=cp->ofile[fd]) == 0)
  1064a5:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1064a8:	85 c0                	test   %eax,%eax
  1064aa:	78 24                	js     1064d0 <argfd+0x50>
  1064ac:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1064af:	83 f8 0f             	cmp    $0xf,%eax
  1064b2:	7f 1c                	jg     1064d0 <argfd+0x50>
  1064b4:	e8 07 d4 ff ff       	call   1038c0 <cpu>
  1064b9:	8b 14 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%edx
  1064c0:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1064c3:	8b 44 82 20          	mov    0x20(%edx,%eax,4),%eax
  1064c7:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  1064ca:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  1064ce:	75 09                	jne    1064d9 <argfd+0x59>
    return -1;
  1064d0:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  1064d7:	eb 23                	jmp    1064fc <argfd+0x7c>
  if(pfd)
  1064d9:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  1064dd:	74 08                	je     1064e7 <argfd+0x67>
    *pfd = fd;
  1064df:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  1064e2:	8b 45 0c             	mov    0xc(%ebp),%eax
  1064e5:	89 10                	mov    %edx,(%eax)
  if(pf)
  1064e7:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  1064eb:	74 08                	je     1064f5 <argfd+0x75>
    *pf = f;
  1064ed:	8b 55 10             	mov    0x10(%ebp),%edx
  1064f0:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1064f3:	89 02                	mov    %eax,(%edx)
  return 0;
  1064f5:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  1064fc:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  1064ff:	c9                   	leave  
  106500:	c3                   	ret    
  106501:	eb 0d                	jmp    106510 <fdalloc>
  106503:	90                   	nop    
  106504:	90                   	nop    
  106505:	90                   	nop    
  106506:	90                   	nop    
  106507:	90                   	nop    
  106508:	90                   	nop    
  106509:	90                   	nop    
  10650a:	90                   	nop    
  10650b:	90                   	nop    
  10650c:	90                   	nop    
  10650d:	90                   	nop    
  10650e:	90                   	nop    
  10650f:	90                   	nop    

00106510 <fdalloc>:

// Allocate a file descriptor for the given file.
// Takes over file reference from caller on success.
static int
fdalloc(struct file *f)
{
  106510:	55                   	push   %ebp
  106511:	89 e5                	mov    %esp,%ebp
  106513:	83 ec 18             	sub    $0x18,%esp
  int fd;

  for(fd = 0; fd < NOFILE; fd++){
  106516:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
  10651d:	eb 39                	jmp    106558 <fdalloc+0x48>
    if(cp->ofile[fd] == 0){
  10651f:	e8 9c d3 ff ff       	call   1038c0 <cpu>
  106524:	8b 14 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%edx
  10652b:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10652e:	8b 44 82 20          	mov    0x20(%edx,%eax,4),%eax
  106532:	85 c0                	test   %eax,%eax
  106534:	75 1e                	jne    106554 <fdalloc+0x44>
      cp->ofile[fd] = f;
  106536:	e8 85 d3 ff ff       	call   1038c0 <cpu>
  10653b:	8b 0c 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%ecx
  106542:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  106545:	8b 45 08             	mov    0x8(%ebp),%eax
  106548:	89 44 91 20          	mov    %eax,0x20(%ecx,%edx,4)
      return fd;
  10654c:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10654f:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  106552:	eb 11                	jmp    106565 <fdalloc+0x55>
  106554:	83 45 fc 01          	addl   $0x1,0xfffffffc(%ebp)
  106558:	83 7d fc 0f          	cmpl   $0xf,0xfffffffc(%ebp)
  10655c:	7e c1                	jle    10651f <fdalloc+0xf>
    }
  }
  return -1;
  10655e:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  106565:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  106568:	c9                   	leave  
  106569:	c3                   	ret    
  10656a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

00106570 <sys_read>:

int
sys_read(void)
{
  106570:	55                   	push   %ebp
  106571:	89 e5                	mov    %esp,%ebp
  106573:	56                   	push   %esi
  106574:	53                   	push   %ebx
  106575:	83 ec 30             	sub    $0x30,%esp
  106578:	89 e0                	mov    %esp,%eax
  10657a:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
  struct file *f;
  int n;
  char *cp;
  10657d:	e8 3e d3 ff ff       	call   1038c0 <cpu>
  106582:	c1 e0 02             	shl    $0x2,%eax
  106585:	83 c0 0f             	add    $0xf,%eax
  106588:	83 c0 0f             	add    $0xf,%eax
  10658b:	c1 e8 04             	shr    $0x4,%eax
  10658e:	c1 e0 04             	shl    $0x4,%eax
  106591:	29 c4                	sub    %eax,%esp
  106593:	8d 44 24 0c          	lea    0xc(%esp),%eax
  106597:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
  10659a:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  10659d:	83 c0 0f             	add    $0xf,%eax
  1065a0:	c1 e8 04             	shr    $0x4,%eax
  1065a3:	c1 e0 04             	shl    $0x4,%eax
  1065a6:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
  1065a9:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  1065ac:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)

  if(argfd(0, 0, &f) < 0 || argint(2, &n) < 0 || argptr(1, &cp, n) < 0)
  1065af:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
  1065b2:	89 44 24 08          	mov    %eax,0x8(%esp)
  1065b6:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  1065bd:	00 
  1065be:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  1065c5:	e8 b6 fe ff ff       	call   106480 <argfd>
  1065ca:	85 c0                	test   %eax,%eax
  1065cc:	78 40                	js     10660e <sys_read+0x9e>
  1065ce:	8d 45 ec             	lea    0xffffffec(%ebp),%eax
  1065d1:	89 44 24 04          	mov    %eax,0x4(%esp)
  1065d5:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  1065dc:	e8 9f fc ff ff       	call   106280 <argint>
  1065e1:	85 c0                	test   %eax,%eax
  1065e3:	78 29                	js     10660e <sys_read+0x9e>
  1065e5:	8b 5d ec             	mov    0xffffffec(%ebp),%ebx
  1065e8:	8b 75 f4             	mov    0xfffffff4(%ebp),%esi
  1065eb:	e8 d0 d2 ff ff       	call   1038c0 <cpu>
  1065f0:	c1 e0 02             	shl    $0x2,%eax
  1065f3:	8d 04 06             	lea    (%esi,%eax,1),%eax
  1065f6:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  1065fa:	89 44 24 04          	mov    %eax,0x4(%esp)
  1065fe:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  106605:	e8 c6 fc ff ff       	call   1062d0 <argptr>
  10660a:	85 c0                	test   %eax,%eax
  10660c:	79 09                	jns    106617 <sys_read+0xa7>
    return -1;
  10660e:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,0xffffffe0(%ebp)
  106615:	eb 26                	jmp    10663d <sys_read+0xcd>
  return fileread(f, cp, n);
  106617:	8b 5d ec             	mov    0xffffffec(%ebp),%ebx
  10661a:	e8 a1 d2 ff ff       	call   1038c0 <cpu>
  10661f:	89 c2                	mov    %eax,%edx
  106621:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  106624:	8b 04 90             	mov    (%eax,%edx,4),%eax
  106627:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
  10662a:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  10662e:	89 44 24 04          	mov    %eax,0x4(%esp)
  106632:	89 14 24             	mov    %edx,(%esp)
  106635:	e8 b6 b1 ff ff       	call   1017f0 <fileread>
  10663a:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
  10663d:	8b 65 e4             	mov    0xffffffe4(%ebp),%esp
  106640:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
}
  106643:	8d 65 f8             	lea    0xfffffff8(%ebp),%esp
  106646:	5b                   	pop    %ebx
  106647:	5e                   	pop    %esi
  106648:	5d                   	pop    %ebp
  106649:	c3                   	ret    
  10664a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

00106650 <sys_write>:

int
sys_write(void)
{
  106650:	55                   	push   %ebp
  106651:	89 e5                	mov    %esp,%ebp
  106653:	56                   	push   %esi
  106654:	53                   	push   %ebx
  106655:	83 ec 30             	sub    $0x30,%esp
  106658:	89 e0                	mov    %esp,%eax
  10665a:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
  struct file *f;
  int n;
  char *cp;
  10665d:	e8 5e d2 ff ff       	call   1038c0 <cpu>
  106662:	c1 e0 02             	shl    $0x2,%eax
  106665:	83 c0 0f             	add    $0xf,%eax
  106668:	83 c0 0f             	add    $0xf,%eax
  10666b:	c1 e8 04             	shr    $0x4,%eax
  10666e:	c1 e0 04             	shl    $0x4,%eax
  106671:	29 c4                	sub    %eax,%esp
  106673:	8d 44 24 0c          	lea    0xc(%esp),%eax
  106677:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
  10667a:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  10667d:	83 c0 0f             	add    $0xf,%eax
  106680:	c1 e8 04             	shr    $0x4,%eax
  106683:	c1 e0 04             	shl    $0x4,%eax
  106686:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
  106689:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  10668c:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)

  if(argfd(0, 0, &f) < 0 || argint(2, &n) < 0 || argptr(1, &cp, n) < 0)
  10668f:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
  106692:	89 44 24 08          	mov    %eax,0x8(%esp)
  106696:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  10669d:	00 
  10669e:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  1066a5:	e8 d6 fd ff ff       	call   106480 <argfd>
  1066aa:	85 c0                	test   %eax,%eax
  1066ac:	78 40                	js     1066ee <sys_write+0x9e>
  1066ae:	8d 45 ec             	lea    0xffffffec(%ebp),%eax
  1066b1:	89 44 24 04          	mov    %eax,0x4(%esp)
  1066b5:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  1066bc:	e8 bf fb ff ff       	call   106280 <argint>
  1066c1:	85 c0                	test   %eax,%eax
  1066c3:	78 29                	js     1066ee <sys_write+0x9e>
  1066c5:	8b 5d ec             	mov    0xffffffec(%ebp),%ebx
  1066c8:	8b 75 f4             	mov    0xfffffff4(%ebp),%esi
  1066cb:	e8 f0 d1 ff ff       	call   1038c0 <cpu>
  1066d0:	c1 e0 02             	shl    $0x2,%eax
  1066d3:	8d 04 06             	lea    (%esi,%eax,1),%eax
  1066d6:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  1066da:	89 44 24 04          	mov    %eax,0x4(%esp)
  1066de:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  1066e5:	e8 e6 fb ff ff       	call   1062d0 <argptr>
  1066ea:	85 c0                	test   %eax,%eax
  1066ec:	79 09                	jns    1066f7 <sys_write+0xa7>
    return -1;
  1066ee:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,0xffffffe0(%ebp)
  1066f5:	eb 26                	jmp    10671d <sys_write+0xcd>
  return filewrite(f, cp, n);
  1066f7:	8b 5d ec             	mov    0xffffffec(%ebp),%ebx
  1066fa:	e8 c1 d1 ff ff       	call   1038c0 <cpu>
  1066ff:	89 c2                	mov    %eax,%edx
  106701:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  106704:	8b 04 90             	mov    (%eax,%edx,4),%eax
  106707:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
  10670a:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  10670e:	89 44 24 04          	mov    %eax,0x4(%esp)
  106712:	89 14 24             	mov    %edx,(%esp)
  106715:	e8 a6 b1 ff ff       	call   1018c0 <filewrite>
  10671a:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
  10671d:	8b 65 e4             	mov    0xffffffe4(%ebp),%esp
  106720:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
}
  106723:	8d 65 f8             	lea    0xfffffff8(%ebp),%esp
  106726:	5b                   	pop    %ebx
  106727:	5e                   	pop    %esi
  106728:	5d                   	pop    %ebp
  106729:	c3                   	ret    
  10672a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

00106730 <sys_dup>:

int
sys_dup(void)
{
  106730:	55                   	push   %ebp
  106731:	89 e5                	mov    %esp,%ebp
  106733:	83 ec 28             	sub    $0x28,%esp
  struct file *f;
  int fd;
  
  if(argfd(0, 0, &f) < 0)
  106736:	8d 45 f8             	lea    0xfffffff8(%ebp),%eax
  106739:	89 44 24 08          	mov    %eax,0x8(%esp)
  10673d:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  106744:	00 
  106745:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  10674c:	e8 2f fd ff ff       	call   106480 <argfd>
  106751:	85 c0                	test   %eax,%eax
  106753:	79 09                	jns    10675e <sys_dup+0x2e>
    return -1;
  106755:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  10675c:	eb 2e                	jmp    10678c <sys_dup+0x5c>
  if((fd=fdalloc(f)) < 0)
  10675e:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  106761:	89 04 24             	mov    %eax,(%esp)
  106764:	e8 a7 fd ff ff       	call   106510 <fdalloc>
  106769:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  10676c:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  106770:	79 09                	jns    10677b <sys_dup+0x4b>
    return -1;
  106772:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  106779:	eb 11                	jmp    10678c <sys_dup+0x5c>
  filedup(f);
  10677b:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10677e:	89 04 24             	mov    %eax,(%esp)
  106781:	e8 8a ae ff ff       	call   101610 <filedup>
  return fd;
  106786:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  106789:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  10678c:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  10678f:	c9                   	leave  
  106790:	c3                   	ret    
  106791:	eb 0d                	jmp    1067a0 <sys_close>
  106793:	90                   	nop    
  106794:	90                   	nop    
  106795:	90                   	nop    
  106796:	90                   	nop    
  106797:	90                   	nop    
  106798:	90                   	nop    
  106799:	90                   	nop    
  10679a:	90                   	nop    
  10679b:	90                   	nop    
  10679c:	90                   	nop    
  10679d:	90                   	nop    
  10679e:	90                   	nop    
  10679f:	90                   	nop    

001067a0 <sys_close>:

int
sys_close(void)
{
  1067a0:	55                   	push   %ebp
  1067a1:	89 e5                	mov    %esp,%ebp
  1067a3:	83 ec 28             	sub    $0x28,%esp
  int fd;
  struct file *f;
  
  if(argfd(0, &fd, &f) < 0)
  1067a6:	8d 45 f8             	lea    0xfffffff8(%ebp),%eax
  1067a9:	89 44 24 08          	mov    %eax,0x8(%esp)
  1067ad:	8d 45 fc             	lea    0xfffffffc(%ebp),%eax
  1067b0:	89 44 24 04          	mov    %eax,0x4(%esp)
  1067b4:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  1067bb:	e8 c0 fc ff ff       	call   106480 <argfd>
  1067c0:	85 c0                	test   %eax,%eax
  1067c2:	79 09                	jns    1067cd <sys_close+0x2d>
    return -1;
  1067c4:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  1067cb:	eb 29                	jmp    1067f6 <sys_close+0x56>
  cp->ofile[fd] = 0;
  1067cd:	e8 ee d0 ff ff       	call   1038c0 <cpu>
  1067d2:	8b 14 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%edx
  1067d9:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1067dc:	c7 44 82 20 00 00 00 	movl   $0x0,0x20(%edx,%eax,4)
  1067e3:	00 
  fileclose(f);
  1067e4:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1067e7:	89 04 24             	mov    %eax,(%esp)
  1067ea:	e8 81 ae ff ff       	call   101670 <fileclose>
  return 0;
  1067ef:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  1067f6:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  1067f9:	c9                   	leave  
  1067fa:	c3                   	ret    
  1067fb:	90                   	nop    
  1067fc:	8d 74 26 00          	lea    0x0(%esi),%esi

00106800 <sys_fstat>:

int
sys_fstat(void)
{
  106800:	55                   	push   %ebp
  106801:	89 e5                	mov    %esp,%ebp
  106803:	83 ec 28             	sub    $0x28,%esp
  struct file *f;
  struct stat *st;
  
  if(argfd(0, 0, &f) < 0 || argptr(1, (void*)&st, sizeof(*st)) < 0)
  106806:	8d 45 fc             	lea    0xfffffffc(%ebp),%eax
  106809:	89 44 24 08          	mov    %eax,0x8(%esp)
  10680d:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  106814:	00 
  106815:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  10681c:	e8 5f fc ff ff       	call   106480 <argfd>
  106821:	85 c0                	test   %eax,%eax
  106823:	78 1f                	js     106844 <sys_fstat+0x44>
  106825:	8d 45 f8             	lea    0xfffffff8(%ebp),%eax
  106828:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
  10682f:	00 
  106830:	89 44 24 04          	mov    %eax,0x4(%esp)
  106834:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  10683b:	e8 90 fa ff ff       	call   1062d0 <argptr>
  106840:	85 c0                	test   %eax,%eax
  106842:	79 09                	jns    10684d <sys_fstat+0x4d>
    return -1;
  106844:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  10684b:	eb 15                	jmp    106862 <sys_fstat+0x62>
  return filestat(f, st);
  10684d:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  106850:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  106853:	89 44 24 04          	mov    %eax,0x4(%esp)
  106857:	89 14 24             	mov    %edx,(%esp)
  10685a:	e8 31 af ff ff       	call   101790 <filestat>
  10685f:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  106862:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  106865:	c9                   	leave  
  106866:	c3                   	ret    
  106867:	89 f6                	mov    %esi,%esi
  106869:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00106870 <sys_link>:

// Create the path new as a link to the same inode as old.
int
sys_link(void)
{
  106870:	55                   	push   %ebp
  106871:	89 e5                	mov    %esp,%ebp
  106873:	83 ec 38             	sub    $0x38,%esp
  char name[DIRSIZ], *new, *old;
  struct inode *dp, *ip;

  if(argstr(0, &old) < 0 || argstr(1, &new) < 0)
  106876:	8d 45 e0             	lea    0xffffffe0(%ebp),%eax
  106879:	89 44 24 04          	mov    %eax,0x4(%esp)
  10687d:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  106884:	e8 d7 fa ff ff       	call   106360 <argstr>
  106889:	85 c0                	test   %eax,%eax
  10688b:	78 17                	js     1068a4 <sys_link+0x34>
  10688d:	8d 45 e4             	lea    0xffffffe4(%ebp),%eax
  106890:	89 44 24 04          	mov    %eax,0x4(%esp)
  106894:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  10689b:	e8 c0 fa ff ff       	call   106360 <argstr>
  1068a0:	85 c0                	test   %eax,%eax
  1068a2:	79 0c                	jns    1068b0 <sys_link+0x40>
    return -1;
  1068a4:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,0xffffffdc(%ebp)
  1068ab:	e9 33 01 00 00       	jmp    1069e3 <sys_link+0x173>
  if((ip = namei(old)) == 0)
  1068b0:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  1068b3:	89 04 24             	mov    %eax,(%esp)
  1068b6:	e8 a5 c3 ff ff       	call   102c60 <namei>
  1068bb:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  1068be:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  1068c2:	75 0c                	jne    1068d0 <sys_link+0x60>
    return -1;
  1068c4:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,0xffffffdc(%ebp)
  1068cb:	e9 13 01 00 00       	jmp    1069e3 <sys_link+0x173>
  ilock(ip);
  1068d0:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1068d3:	89 04 24             	mov    %eax,(%esp)
  1068d6:	e8 e5 b4 ff ff       	call   101dc0 <ilock>
  if(ip->type == T_DIR){
  1068db:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1068de:	0f b7 40 10          	movzwl 0x10(%eax),%eax
  1068e2:	66 83 f8 01          	cmp    $0x1,%ax
  1068e6:	75 17                	jne    1068ff <sys_link+0x8f>
    iunlockput(ip);
  1068e8:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1068eb:	89 04 24             	mov    %eax,(%esp)
  1068ee:	e8 7d b7 ff ff       	call   102070 <iunlockput>
    return -1;
  1068f3:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,0xffffffdc(%ebp)
  1068fa:	e9 e4 00 00 00       	jmp    1069e3 <sys_link+0x173>
  }
  ip->nlink++;
  1068ff:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  106902:	0f b7 40 16          	movzwl 0x16(%eax),%eax
  106906:	8d 50 01             	lea    0x1(%eax),%edx
  106909:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10690c:	66 89 50 16          	mov    %dx,0x16(%eax)
  iupdate(ip);
  106910:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  106913:	89 04 24             	mov    %eax,(%esp)
  106916:	e8 65 b8 ff ff       	call   102180 <iupdate>
  iunlock(ip);
  10691b:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10691e:	89 04 24             	mov    %eax,(%esp)
  106921:	e8 fa b5 ff ff       	call   101f20 <iunlock>

  if((dp = nameiparent(new, name)) == 0)
  106926:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
  106929:	8d 45 ea             	lea    0xffffffea(%ebp),%eax
  10692c:	89 44 24 04          	mov    %eax,0x4(%esp)
  106930:	89 14 24             	mov    %edx,(%esp)
  106933:	e8 58 c3 ff ff       	call   102c90 <nameiparent>
  106938:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  10693b:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  10693f:	74 58                	je     106999 <sys_link+0x129>
    goto  bad;
  ilock(dp);
  106941:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  106944:	89 04 24             	mov    %eax,(%esp)
  106947:	e8 74 b4 ff ff       	call   101dc0 <ilock>
  if(dp->dev != ip->dev || dirlink(dp, name, ip->inum) < 0)
  10694c:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10694f:	8b 10                	mov    (%eax),%edx
  106951:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  106954:	8b 00                	mov    (%eax),%eax
  106956:	39 c2                	cmp    %eax,%edx
  106958:	75 3f                	jne    106999 <sys_link+0x129>
  10695a:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10695d:	8b 40 04             	mov    0x4(%eax),%eax
  106960:	89 44 24 08          	mov    %eax,0x8(%esp)
  106964:	8d 45 ea             	lea    0xffffffea(%ebp),%eax
  106967:	89 44 24 04          	mov    %eax,0x4(%esp)
  10696b:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10696e:	89 04 24             	mov    %eax,(%esp)
  106971:	e8 fa bf ff ff       	call   102970 <dirlink>
  106976:	85 c0                	test   %eax,%eax
  106978:	78 1f                	js     106999 <sys_link+0x129>
    goto bad;
  iunlockput(dp);
  10697a:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10697d:	89 04 24             	mov    %eax,(%esp)
  106980:	e8 eb b6 ff ff       	call   102070 <iunlockput>
  iput(ip);
  106985:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  106988:	89 04 24             	mov    %eax,(%esp)
  10698b:	e8 00 b6 ff ff       	call   101f90 <iput>
  return 0;
  106990:	c7 45 dc 00 00 00 00 	movl   $0x0,0xffffffdc(%ebp)
  106997:	eb 4a                	jmp    1069e3 <sys_link+0x173>

bad:
  if(dp)
  106999:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  10699d:	74 0b                	je     1069aa <sys_link+0x13a>
    iunlockput(dp);
  10699f:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1069a2:	89 04 24             	mov    %eax,(%esp)
  1069a5:	e8 c6 b6 ff ff       	call   102070 <iunlockput>
  ilock(ip);
  1069aa:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1069ad:	89 04 24             	mov    %eax,(%esp)
  1069b0:	e8 0b b4 ff ff       	call   101dc0 <ilock>
  ip->nlink--;
  1069b5:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1069b8:	0f b7 40 16          	movzwl 0x16(%eax),%eax
  1069bc:	8d 50 ff             	lea    0xffffffff(%eax),%edx
  1069bf:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1069c2:	66 89 50 16          	mov    %dx,0x16(%eax)
  iupdate(ip);
  1069c6:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1069c9:	89 04 24             	mov    %eax,(%esp)
  1069cc:	e8 af b7 ff ff       	call   102180 <iupdate>
  iunlockput(ip);
  1069d1:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1069d4:	89 04 24             	mov    %eax,(%esp)
  1069d7:	e8 94 b6 ff ff       	call   102070 <iunlockput>
  return -1;
  1069dc:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,0xffffffdc(%ebp)
  1069e3:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
}
  1069e6:	c9                   	leave  
  1069e7:	c3                   	ret    
  1069e8:	90                   	nop    
  1069e9:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

001069f0 <isdirempty>:

// Is the directory dp empty except for "." and ".." ?
static int
isdirempty(struct inode *dp)
{
  1069f0:	55                   	push   %ebp
  1069f1:	89 e5                	mov    %esp,%ebp
  1069f3:	83 ec 38             	sub    $0x38,%esp
  int off;
  struct dirent de;

  for(off=2*sizeof(de); off<dp->size; off+=sizeof(de)){
  1069f6:	c7 45 fc 20 00 00 00 	movl   $0x20,0xfffffffc(%ebp)
  1069fd:	eb 4d                	jmp    106a4c <isdirempty+0x5c>
    if(readi(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
  1069ff:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  106a02:	8d 55 ec             	lea    0xffffffec(%ebp),%edx
  106a05:	c7 44 24 0c 10 00 00 	movl   $0x10,0xc(%esp)
  106a0c:	00 
  106a0d:	89 44 24 08          	mov    %eax,0x8(%esp)
  106a11:	89 54 24 04          	mov    %edx,0x4(%esp)
  106a15:	8b 45 08             	mov    0x8(%ebp),%eax
  106a18:	89 04 24             	mov    %eax,(%esp)
  106a1b:	e8 b0 ba ff ff       	call   1024d0 <readi>
  106a20:	83 f8 10             	cmp    $0x10,%eax
  106a23:	74 0c                	je     106a31 <isdirempty+0x41>
      panic("isdirempty: readi");
  106a25:	c7 04 24 4c a7 11 00 	movl   $0x11a74c,(%esp)
  106a2c:	e8 df a5 ff ff       	call   101010 <panic>
    if(de.inum != 0)
  106a31:	0f b7 45 ec          	movzwl 0xffffffec(%ebp),%eax
  106a35:	66 85 c0             	test   %ax,%ax
  106a38:	74 09                	je     106a43 <isdirempty+0x53>
      return 0;
  106a3a:	c7 45 dc 00 00 00 00 	movl   $0x0,0xffffffdc(%ebp)
  106a41:	eb 1d                	jmp    106a60 <isdirempty+0x70>
  106a43:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  106a46:	83 c0 10             	add    $0x10,%eax
  106a49:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  106a4c:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  106a4f:	8b 55 08             	mov    0x8(%ebp),%edx
  106a52:	8b 52 18             	mov    0x18(%edx),%edx
  106a55:	39 d0                	cmp    %edx,%eax
  106a57:	72 a6                	jb     1069ff <isdirempty+0xf>
  }
  return 1;
  106a59:	c7 45 dc 01 00 00 00 	movl   $0x1,0xffffffdc(%ebp)
  106a60:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
}
  106a63:	c9                   	leave  
  106a64:	c3                   	ret    
  106a65:	8d 74 26 00          	lea    0x0(%esi),%esi
  106a69:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00106a70 <sys_unlink>:

int
sys_unlink(void)
{
  106a70:	55                   	push   %ebp
  106a71:	89 e5                	mov    %esp,%ebp
  106a73:	83 ec 48             	sub    $0x48,%esp
  struct inode *ip, *dp;
  struct dirent de;
  char name[DIRSIZ], *path;
  uint off;

  if(argstr(0, &path) < 0)
  106a76:	8d 45 d4             	lea    0xffffffd4(%ebp),%eax
  106a79:	89 44 24 04          	mov    %eax,0x4(%esp)
  106a7d:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  106a84:	e8 d7 f8 ff ff       	call   106360 <argstr>
  106a89:	85 c0                	test   %eax,%eax
  106a8b:	79 0c                	jns    106a99 <sys_unlink+0x29>
    return -1;
  106a8d:	c7 45 cc ff ff ff ff 	movl   $0xffffffff,0xffffffcc(%ebp)
  106a94:	e9 97 01 00 00       	jmp    106c30 <sys_unlink+0x1c0>
  if((dp = nameiparent(path, name)) == 0)
  106a99:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
  106a9c:	8d 55 da             	lea    0xffffffda(%ebp),%edx
  106a9f:	89 54 24 04          	mov    %edx,0x4(%esp)
  106aa3:	89 04 24             	mov    %eax,(%esp)
  106aa6:	e8 e5 c1 ff ff       	call   102c90 <nameiparent>
  106aab:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  106aae:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  106ab2:	75 0c                	jne    106ac0 <sys_unlink+0x50>
    return -1;
  106ab4:	c7 45 cc ff ff ff ff 	movl   $0xffffffff,0xffffffcc(%ebp)
  106abb:	e9 70 01 00 00       	jmp    106c30 <sys_unlink+0x1c0>
  ilock(dp);
  106ac0:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  106ac3:	89 04 24             	mov    %eax,(%esp)
  106ac6:	e8 f5 b2 ff ff       	call   101dc0 <ilock>

  // Cannot unlink "." or "..".
  if(namecmp(name, ".") == 0 || namecmp(name, "..") == 0){
  106acb:	c7 44 24 04 5e a7 11 	movl   $0x11a75e,0x4(%esp)
  106ad2:	00 
  106ad3:	8d 45 da             	lea    0xffffffda(%ebp),%eax
  106ad6:	89 04 24             	mov    %eax,(%esp)
  106ad9:	e8 32 bd ff ff       	call   102810 <namecmp>
  106ade:	85 c0                	test   %eax,%eax
  106ae0:	74 17                	je     106af9 <sys_unlink+0x89>
  106ae2:	c7 44 24 04 60 a7 11 	movl   $0x11a760,0x4(%esp)
  106ae9:	00 
  106aea:	8d 45 da             	lea    0xffffffda(%ebp),%eax
  106aed:	89 04 24             	mov    %eax,(%esp)
  106af0:	e8 1b bd ff ff       	call   102810 <namecmp>
  106af5:	85 c0                	test   %eax,%eax
  106af7:	75 17                	jne    106b10 <sys_unlink+0xa0>
    iunlockput(dp);
  106af9:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  106afc:	89 04 24             	mov    %eax,(%esp)
  106aff:	e8 6c b5 ff ff       	call   102070 <iunlockput>
    return -1;
  106b04:	c7 45 cc ff ff ff ff 	movl   $0xffffffff,0xffffffcc(%ebp)
  106b0b:	e9 20 01 00 00       	jmp    106c30 <sys_unlink+0x1c0>
  }

  if((ip = dirlookup(dp, name, &off)) == 0){
  106b10:	8d 45 d0             	lea    0xffffffd0(%ebp),%eax
  106b13:	89 44 24 08          	mov    %eax,0x8(%esp)
  106b17:	8d 45 da             	lea    0xffffffda(%ebp),%eax
  106b1a:	89 44 24 04          	mov    %eax,0x4(%esp)
  106b1e:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  106b21:	89 04 24             	mov    %eax,(%esp)
  106b24:	e8 17 bd ff ff       	call   102840 <dirlookup>
  106b29:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  106b2c:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  106b30:	75 17                	jne    106b49 <sys_unlink+0xd9>
    iunlockput(dp);
  106b32:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  106b35:	89 04 24             	mov    %eax,(%esp)
  106b38:	e8 33 b5 ff ff       	call   102070 <iunlockput>
    return -1;
  106b3d:	c7 45 cc ff ff ff ff 	movl   $0xffffffff,0xffffffcc(%ebp)
  106b44:	e9 e7 00 00 00       	jmp    106c30 <sys_unlink+0x1c0>
  }
  ilock(ip);
  106b49:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  106b4c:	89 04 24             	mov    %eax,(%esp)
  106b4f:	e8 6c b2 ff ff       	call   101dc0 <ilock>

  if(ip->nlink < 1)
  106b54:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  106b57:	0f b7 40 16          	movzwl 0x16(%eax),%eax
  106b5b:	66 85 c0             	test   %ax,%ax
  106b5e:	7f 0c                	jg     106b6c <sys_unlink+0xfc>
    panic("unlink: nlink < 1");
  106b60:	c7 04 24 63 a7 11 00 	movl   $0x11a763,(%esp)
  106b67:	e8 a4 a4 ff ff       	call   101010 <panic>
  if(ip->type == T_DIR && !isdirempty(ip)){
  106b6c:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  106b6f:	0f b7 40 10          	movzwl 0x10(%eax),%eax
  106b73:	66 83 f8 01          	cmp    $0x1,%ax
  106b77:	75 31                	jne    106baa <sys_unlink+0x13a>
  106b79:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  106b7c:	89 04 24             	mov    %eax,(%esp)
  106b7f:	e8 6c fe ff ff       	call   1069f0 <isdirempty>
  106b84:	85 c0                	test   %eax,%eax
  106b86:	75 22                	jne    106baa <sys_unlink+0x13a>
    iunlockput(ip);
  106b88:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  106b8b:	89 04 24             	mov    %eax,(%esp)
  106b8e:	e8 dd b4 ff ff       	call   102070 <iunlockput>
    iunlockput(dp);
  106b93:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  106b96:	89 04 24             	mov    %eax,(%esp)
  106b99:	e8 d2 b4 ff ff       	call   102070 <iunlockput>
    return -1;
  106b9e:	c7 45 cc ff ff ff ff 	movl   $0xffffffff,0xffffffcc(%ebp)
  106ba5:	e9 86 00 00 00       	jmp    106c30 <sys_unlink+0x1c0>
  }

  memset(&de, 0, sizeof(de));
  106baa:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
  106bb1:	00 
  106bb2:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  106bb9:	00 
  106bba:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
  106bbd:	89 04 24             	mov    %eax,(%esp)
  106bc0:	e8 3b f3 ff ff       	call   105f00 <memset>
  if(writei(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
  106bc5:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
  106bc8:	8d 55 e8             	lea    0xffffffe8(%ebp),%edx
  106bcb:	c7 44 24 0c 10 00 00 	movl   $0x10,0xc(%esp)
  106bd2:	00 
  106bd3:	89 44 24 08          	mov    %eax,0x8(%esp)
  106bd7:	89 54 24 04          	mov    %edx,0x4(%esp)
  106bdb:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  106bde:	89 04 24             	mov    %eax,(%esp)
  106be1:	e8 7a ba ff ff       	call   102660 <writei>
  106be6:	83 f8 10             	cmp    $0x10,%eax
  106be9:	74 0c                	je     106bf7 <sys_unlink+0x187>
    panic("unlink: writei");
  106beb:	c7 04 24 75 a7 11 00 	movl   $0x11a775,(%esp)
  106bf2:	e8 19 a4 ff ff       	call   101010 <panic>
  iunlockput(dp);
  106bf7:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  106bfa:	89 04 24             	mov    %eax,(%esp)
  106bfd:	e8 6e b4 ff ff       	call   102070 <iunlockput>

  ip->nlink--;
  106c02:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  106c05:	0f b7 40 16          	movzwl 0x16(%eax),%eax
  106c09:	8d 50 ff             	lea    0xffffffff(%eax),%edx
  106c0c:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  106c0f:	66 89 50 16          	mov    %dx,0x16(%eax)
  iupdate(ip);
  106c13:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  106c16:	89 04 24             	mov    %eax,(%esp)
  106c19:	e8 62 b5 ff ff       	call   102180 <iupdate>
  iunlockput(ip);
  106c1e:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  106c21:	89 04 24             	mov    %eax,(%esp)
  106c24:	e8 47 b4 ff ff       	call   102070 <iunlockput>
  return 0;
  106c29:	c7 45 cc 00 00 00 00 	movl   $0x0,0xffffffcc(%ebp)
  106c30:	8b 45 cc             	mov    0xffffffcc(%ebp),%eax
}
  106c33:	c9                   	leave  
  106c34:	c3                   	ret    
  106c35:	8d 74 26 00          	lea    0x0(%esi),%esi
  106c39:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00106c40 <create>:

static struct inode*
create(char *path, int canexist, short type, short major, short minor)
{
  106c40:	55                   	push   %ebp
  106c41:	89 e5                	mov    %esp,%ebp
  106c43:	83 ec 48             	sub    $0x48,%esp
  106c46:	8b 45 10             	mov    0x10(%ebp),%eax
  106c49:	8b 55 14             	mov    0x14(%ebp),%edx
  106c4c:	8b 4d 18             	mov    0x18(%ebp),%ecx
  106c4f:	66 89 45 dc          	mov    %ax,0xffffffdc(%ebp)
  106c53:	66 89 55 d8          	mov    %dx,0xffffffd8(%ebp)
  106c57:	66 89 4d d4          	mov    %cx,0xffffffd4(%ebp)
  uint off;
  struct inode *ip, *dp;
  char name[DIRSIZ];

  if((dp = nameiparent(path, name)) == 0)
  106c5b:	8d 45 e6             	lea    0xffffffe6(%ebp),%eax
  106c5e:	89 44 24 04          	mov    %eax,0x4(%esp)
  106c62:	8b 45 08             	mov    0x8(%ebp),%eax
  106c65:	89 04 24             	mov    %eax,(%esp)
  106c68:	e8 23 c0 ff ff       	call   102c90 <nameiparent>
  106c6d:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  106c70:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  106c74:	75 0c                	jne    106c82 <create+0x42>
    return 0;
  106c76:	c7 45 d0 00 00 00 00 	movl   $0x0,0xffffffd0(%ebp)
  106c7d:	e9 cd 01 00 00       	jmp    106e4f <create+0x20f>
  ilock(dp);
  106c82:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  106c85:	89 04 24             	mov    %eax,(%esp)
  106c88:	e8 33 b1 ff ff       	call   101dc0 <ilock>

  if(canexist && (ip = dirlookup(dp, name, &off)) != 0){
  106c8d:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  106c91:	0f 84 81 00 00 00    	je     106d18 <create+0xd8>
  106c97:	8d 45 f4             	lea    0xfffffff4(%ebp),%eax
  106c9a:	89 44 24 08          	mov    %eax,0x8(%esp)
  106c9e:	8d 45 e6             	lea    0xffffffe6(%ebp),%eax
  106ca1:	89 44 24 04          	mov    %eax,0x4(%esp)
  106ca5:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  106ca8:	89 04 24             	mov    %eax,(%esp)
  106cab:	e8 90 bb ff ff       	call   102840 <dirlookup>
  106cb0:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  106cb3:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  106cb7:	74 5f                	je     106d18 <create+0xd8>
    iunlockput(dp);
  106cb9:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  106cbc:	89 04 24             	mov    %eax,(%esp)
  106cbf:	e8 ac b3 ff ff       	call   102070 <iunlockput>
    ilock(ip);
  106cc4:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  106cc7:	89 04 24             	mov    %eax,(%esp)
  106cca:	e8 f1 b0 ff ff       	call   101dc0 <ilock>
    if(ip->type != type || ip->major != major || ip->minor != minor){
  106ccf:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  106cd2:	0f b7 40 10          	movzwl 0x10(%eax),%eax
  106cd6:	66 3b 45 dc          	cmp    0xffffffdc(%ebp),%ax
  106cda:	75 1a                	jne    106cf6 <create+0xb6>
  106cdc:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  106cdf:	0f b7 40 12          	movzwl 0x12(%eax),%eax
  106ce3:	66 3b 45 d8          	cmp    0xffffffd8(%ebp),%ax
  106ce7:	75 0d                	jne    106cf6 <create+0xb6>
  106ce9:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  106cec:	0f b7 40 14          	movzwl 0x14(%eax),%eax
  106cf0:	66 3b 45 d4          	cmp    0xffffffd4(%ebp),%ax
  106cf4:	74 17                	je     106d0d <create+0xcd>
      iunlockput(ip);
  106cf6:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  106cf9:	89 04 24             	mov    %eax,(%esp)
  106cfc:	e8 6f b3 ff ff       	call   102070 <iunlockput>
      return 0;
  106d01:	c7 45 d0 00 00 00 00 	movl   $0x0,0xffffffd0(%ebp)
  106d08:	e9 42 01 00 00       	jmp    106e4f <create+0x20f>
    }
    return ip;
  106d0d:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  106d10:	89 45 d0             	mov    %eax,0xffffffd0(%ebp)
  106d13:	e9 37 01 00 00       	jmp    106e4f <create+0x20f>
  }

  if((ip = ialloc(dp->dev, type)) == 0){
  106d18:	0f bf 55 dc          	movswl 0xffffffdc(%ebp),%edx
  106d1c:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  106d1f:	8b 00                	mov    (%eax),%eax
  106d21:	89 54 24 04          	mov    %edx,0x4(%esp)
  106d25:	89 04 24             	mov    %eax,(%esp)
  106d28:	e8 63 b3 ff ff       	call   102090 <ialloc>
  106d2d:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  106d30:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  106d34:	75 17                	jne    106d4d <create+0x10d>
    iunlockput(dp);
  106d36:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  106d39:	89 04 24             	mov    %eax,(%esp)
  106d3c:	e8 2f b3 ff ff       	call   102070 <iunlockput>
    return 0;
  106d41:	c7 45 d0 00 00 00 00 	movl   $0x0,0xffffffd0(%ebp)
  106d48:	e9 02 01 00 00       	jmp    106e4f <create+0x20f>
  }
  ilock(ip);
  106d4d:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  106d50:	89 04 24             	mov    %eax,(%esp)
  106d53:	e8 68 b0 ff ff       	call   101dc0 <ilock>
  ip->major = major;
  106d58:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  106d5b:	0f b7 45 d8          	movzwl 0xffffffd8(%ebp),%eax
  106d5f:	66 89 42 12          	mov    %ax,0x12(%edx)
  ip->minor = minor;
  106d63:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  106d66:	0f b7 45 d4          	movzwl 0xffffffd4(%ebp),%eax
  106d6a:	66 89 42 14          	mov    %ax,0x14(%edx)
  ip->nlink = 1;
  106d6e:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  106d71:	66 c7 40 16 01 00    	movw   $0x1,0x16(%eax)
  iupdate(ip);
  106d77:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  106d7a:	89 04 24             	mov    %eax,(%esp)
  106d7d:	e8 fe b3 ff ff       	call   102180 <iupdate>
  
  if(dirlink(dp, name, ip->inum) < 0){
  106d82:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  106d85:	8b 40 04             	mov    0x4(%eax),%eax
  106d88:	89 44 24 08          	mov    %eax,0x8(%esp)
  106d8c:	8d 45 e6             	lea    0xffffffe6(%ebp),%eax
  106d8f:	89 44 24 04          	mov    %eax,0x4(%esp)
  106d93:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  106d96:	89 04 24             	mov    %eax,(%esp)
  106d99:	e8 d2 bb ff ff       	call   102970 <dirlink>
  106d9e:	85 c0                	test   %eax,%eax
  106da0:	79 2b                	jns    106dcd <create+0x18d>
    ip->nlink = 0;
  106da2:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  106da5:	66 c7 40 16 00 00    	movw   $0x0,0x16(%eax)
    iunlockput(ip);
  106dab:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  106dae:	89 04 24             	mov    %eax,(%esp)
  106db1:	e8 ba b2 ff ff       	call   102070 <iunlockput>
    iunlockput(dp);
  106db6:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  106db9:	89 04 24             	mov    %eax,(%esp)
  106dbc:	e8 af b2 ff ff       	call   102070 <iunlockput>
    return 0;
  106dc1:	c7 45 d0 00 00 00 00 	movl   $0x0,0xffffffd0(%ebp)
  106dc8:	e9 82 00 00 00       	jmp    106e4f <create+0x20f>
  }

  if(type == T_DIR){  // Create . and .. entries.
  106dcd:	66 83 7d dc 01       	cmpw   $0x1,0xffffffdc(%ebp)
  106dd2:	75 6a                	jne    106e3e <create+0x1fe>
    dp->nlink++;  // for ".."
  106dd4:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  106dd7:	0f b7 40 16          	movzwl 0x16(%eax),%eax
  106ddb:	8d 50 01             	lea    0x1(%eax),%edx
  106dde:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  106de1:	66 89 50 16          	mov    %dx,0x16(%eax)
    iupdate(dp);
  106de5:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  106de8:	89 04 24             	mov    %eax,(%esp)
  106deb:	e8 90 b3 ff ff       	call   102180 <iupdate>
    // No ip->nlink++ for ".": avoid cyclic ref count.
    if(dirlink(ip, ".", ip->inum) < 0 || dirlink(ip, "..", dp->inum) < 0)
  106df0:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  106df3:	8b 40 04             	mov    0x4(%eax),%eax
  106df6:	89 44 24 08          	mov    %eax,0x8(%esp)
  106dfa:	c7 44 24 04 5e a7 11 	movl   $0x11a75e,0x4(%esp)
  106e01:	00 
  106e02:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  106e05:	89 04 24             	mov    %eax,(%esp)
  106e08:	e8 63 bb ff ff       	call   102970 <dirlink>
  106e0d:	85 c0                	test   %eax,%eax
  106e0f:	78 21                	js     106e32 <create+0x1f2>
  106e11:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  106e14:	8b 40 04             	mov    0x4(%eax),%eax
  106e17:	89 44 24 08          	mov    %eax,0x8(%esp)
  106e1b:	c7 44 24 04 60 a7 11 	movl   $0x11a760,0x4(%esp)
  106e22:	00 
  106e23:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  106e26:	89 04 24             	mov    %eax,(%esp)
  106e29:	e8 42 bb ff ff       	call   102970 <dirlink>
  106e2e:	85 c0                	test   %eax,%eax
  106e30:	79 0c                	jns    106e3e <create+0x1fe>
      panic("create dots");
  106e32:	c7 04 24 84 a7 11 00 	movl   $0x11a784,(%esp)
  106e39:	e8 d2 a1 ff ff       	call   101010 <panic>
  }
  iunlockput(dp);
  106e3e:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  106e41:	89 04 24             	mov    %eax,(%esp)
  106e44:	e8 27 b2 ff ff       	call   102070 <iunlockput>
  return ip;
  106e49:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  106e4c:	89 45 d0             	mov    %eax,0xffffffd0(%ebp)
  106e4f:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
}
  106e52:	c9                   	leave  
  106e53:	c3                   	ret    
  106e54:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  106e5a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

00106e60 <sys_open>:

int
sys_open(void)
{
  106e60:	55                   	push   %ebp
  106e61:	89 e5                	mov    %esp,%ebp
  106e63:	83 ec 48             	sub    $0x48,%esp
  char *path;
  int fd, omode;
  struct file *f;
  struct inode *ip;

  if(argstr(0, &path) < 0 || argint(1, &omode) < 0)
  106e66:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
  106e69:	89 44 24 04          	mov    %eax,0x4(%esp)
  106e6d:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  106e74:	e8 e7 f4 ff ff       	call   106360 <argstr>
  106e79:	85 c0                	test   %eax,%eax
  106e7b:	78 17                	js     106e94 <sys_open+0x34>
  106e7d:	8d 45 ec             	lea    0xffffffec(%ebp),%eax
  106e80:	89 44 24 04          	mov    %eax,0x4(%esp)
  106e84:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  106e8b:	e8 f0 f3 ff ff       	call   106280 <argint>
  106e90:	85 c0                	test   %eax,%eax
  106e92:	79 0c                	jns    106ea0 <sys_open+0x40>
    return -1;
  106e94:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,0xffffffd8(%ebp)
  106e9b:	e9 58 01 00 00       	jmp    106ff8 <sys_open+0x198>

  if(omode & O_CREATE){
  106ea0:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  106ea3:	25 00 02 00 00       	and    $0x200,%eax
  106ea8:	85 c0                	test   %eax,%eax
  106eaa:	74 40                	je     106eec <sys_open+0x8c>
    if((ip = create(path, 1, T_FILE, 0, 0)) == 0)
  106eac:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  106eaf:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  106eb6:	00 
  106eb7:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  106ebe:	00 
  106ebf:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
  106ec6:	00 
  106ec7:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  106ece:	00 
  106ecf:	89 04 24             	mov    %eax,(%esp)
  106ed2:	e8 69 fd ff ff       	call   106c40 <create>
  106ed7:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  106eda:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  106ede:	75 65                	jne    106f45 <sys_open+0xe5>
      return -1;
  106ee0:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,0xffffffd8(%ebp)
  106ee7:	e9 0c 01 00 00       	jmp    106ff8 <sys_open+0x198>
  } else {
    if((ip = namei(path)) == 0)
  106eec:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  106eef:	89 04 24             	mov    %eax,(%esp)
  106ef2:	e8 69 bd ff ff       	call   102c60 <namei>
  106ef7:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  106efa:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  106efe:	75 0c                	jne    106f0c <sys_open+0xac>
      return -1;
  106f00:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,0xffffffd8(%ebp)
  106f07:	e9 ec 00 00 00       	jmp    106ff8 <sys_open+0x198>
    ilock(ip);
  106f0c:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  106f0f:	89 04 24             	mov    %eax,(%esp)
  106f12:	e8 a9 ae ff ff       	call   101dc0 <ilock>
    if(ip->type == T_DIR && (omode & (O_RDWR|O_WRONLY))){
  106f17:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  106f1a:	0f b7 40 10          	movzwl 0x10(%eax),%eax
  106f1e:	66 83 f8 01          	cmp    $0x1,%ax
  106f22:	75 21                	jne    106f45 <sys_open+0xe5>
  106f24:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  106f27:	83 e0 03             	and    $0x3,%eax
  106f2a:	85 c0                	test   %eax,%eax
  106f2c:	74 17                	je     106f45 <sys_open+0xe5>
      iunlockput(ip);
  106f2e:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  106f31:	89 04 24             	mov    %eax,(%esp)
  106f34:	e8 37 b1 ff ff       	call   102070 <iunlockput>
      return -1;
  106f39:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,0xffffffd8(%ebp)
  106f40:	e9 b3 00 00 00       	jmp    106ff8 <sys_open+0x198>
    }
  }

  if((f = filealloc()) == 0 || (fd = fdalloc(f)) < 0){
  106f45:	e8 16 a6 ff ff       	call   101560 <filealloc>
  106f4a:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  106f4d:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  106f51:	74 14                	je     106f67 <sys_open+0x107>
  106f53:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  106f56:	89 04 24             	mov    %eax,(%esp)
  106f59:	e8 b2 f5 ff ff       	call   106510 <fdalloc>
  106f5e:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  106f61:	83 7d f4 00          	cmpl   $0x0,0xfffffff4(%ebp)
  106f65:	79 25                	jns    106f8c <sys_open+0x12c>
    if(f)
  106f67:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  106f6b:	74 0b                	je     106f78 <sys_open+0x118>
      fileclose(f);
  106f6d:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  106f70:	89 04 24             	mov    %eax,(%esp)
  106f73:	e8 f8 a6 ff ff       	call   101670 <fileclose>
    iunlockput(ip);
  106f78:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  106f7b:	89 04 24             	mov    %eax,(%esp)
  106f7e:	e8 ed b0 ff ff       	call   102070 <iunlockput>
    return -1;
  106f83:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,0xffffffd8(%ebp)
  106f8a:	eb 6c                	jmp    106ff8 <sys_open+0x198>
  }
  iunlock(ip);
  106f8c:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  106f8f:	89 04 24             	mov    %eax,(%esp)
  106f92:	e8 89 af ff ff       	call   101f20 <iunlock>

  f->type = FD_INODE;
  106f97:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  106f9a:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
  f->ip = ip;
  106fa0:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  106fa3:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  106fa6:	89 42 10             	mov    %eax,0x10(%edx)
  f->off = 0;
  106fa9:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  106fac:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
  f->readable = !(omode & O_WRONLY);
  106fb3:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  106fb6:	83 e0 01             	and    $0x1,%eax
  106fb9:	85 c0                	test   %eax,%eax
  106fbb:	0f 94 c2             	sete   %dl
  106fbe:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  106fc1:	88 50 08             	mov    %dl,0x8(%eax)
  f->writable = (omode & O_WRONLY) || (omode & O_RDWR);
  106fc4:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  106fc7:	83 e0 01             	and    $0x1,%eax
  106fca:	84 c0                	test   %al,%al
  106fcc:	75 0a                	jne    106fd8 <sys_open+0x178>
  106fce:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  106fd1:	83 e0 02             	and    $0x2,%eax
  106fd4:	85 c0                	test   %eax,%eax
  106fd6:	74 09                	je     106fe1 <sys_open+0x181>
  106fd8:	c7 45 dc 01 00 00 00 	movl   $0x1,0xffffffdc(%ebp)
  106fdf:	eb 07                	jmp    106fe8 <sys_open+0x188>
  106fe1:	c7 45 dc 00 00 00 00 	movl   $0x0,0xffffffdc(%ebp)
  106fe8:	0f b6 55 dc          	movzbl 0xffffffdc(%ebp),%edx
  106fec:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  106fef:	88 50 09             	mov    %dl,0x9(%eax)

  return fd;
  106ff2:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  106ff5:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
  106ff8:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
}
  106ffb:	c9                   	leave  
  106ffc:	c3                   	ret    
  106ffd:	8d 76 00             	lea    0x0(%esi),%esi

00107000 <sys_mknod>:

int
sys_mknod(void)
{
  107000:	55                   	push   %ebp
  107001:	89 e5                	mov    %esp,%ebp
  107003:	83 ec 38             	sub    $0x38,%esp
  struct inode *ip;
  char *path;
  int len;
  int major, minor;
  
  if((len=argstr(0, &path)) < 0 ||
  107006:	8d 45 f4             	lea    0xfffffff4(%ebp),%eax
  107009:	89 44 24 04          	mov    %eax,0x4(%esp)
  10700d:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  107014:	e8 47 f3 ff ff       	call   106360 <argstr>
  107019:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  10701c:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  107020:	78 64                	js     107086 <sys_mknod+0x86>
  107022:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
  107025:	89 44 24 04          	mov    %eax,0x4(%esp)
  107029:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  107030:	e8 4b f2 ff ff       	call   106280 <argint>
  107035:	85 c0                	test   %eax,%eax
  107037:	78 4d                	js     107086 <sys_mknod+0x86>
  107039:	8d 45 ec             	lea    0xffffffec(%ebp),%eax
  10703c:	89 44 24 04          	mov    %eax,0x4(%esp)
  107040:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  107047:	e8 34 f2 ff ff       	call   106280 <argint>
  10704c:	85 c0                	test   %eax,%eax
  10704e:	78 36                	js     107086 <sys_mknod+0x86>
  107050:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  107053:	0f bf d0             	movswl %ax,%edx
  107056:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  107059:	98                   	cwtl   
  10705a:	8b 4d f4             	mov    0xfffffff4(%ebp),%ecx
  10705d:	89 54 24 10          	mov    %edx,0x10(%esp)
  107061:	89 44 24 0c          	mov    %eax,0xc(%esp)
  107065:	c7 44 24 08 03 00 00 	movl   $0x3,0x8(%esp)
  10706c:	00 
  10706d:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  107074:	00 
  107075:	89 0c 24             	mov    %ecx,(%esp)
  107078:	e8 c3 fb ff ff       	call   106c40 <create>
  10707d:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  107080:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  107084:	75 09                	jne    10708f <sys_mknod+0x8f>
     argint(1, &major) < 0 ||
     argint(2, &minor) < 0 ||
     (ip = create(path, 0, T_DEV, major, minor)) == 0)
    return -1;
  107086:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,0xffffffdc(%ebp)
  10708d:	eb 12                	jmp    1070a1 <sys_mknod+0xa1>
  iunlockput(ip);
  10708f:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  107092:	89 04 24             	mov    %eax,(%esp)
  107095:	e8 d6 af ff ff       	call   102070 <iunlockput>
  return 0;
  10709a:	c7 45 dc 00 00 00 00 	movl   $0x0,0xffffffdc(%ebp)
  1070a1:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
}
  1070a4:	c9                   	leave  
  1070a5:	c3                   	ret    
  1070a6:	8d 76 00             	lea    0x0(%esi),%esi
  1070a9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

001070b0 <sys_mkdir>:

int
sys_mkdir(void)
{
  1070b0:	55                   	push   %ebp
  1070b1:	89 e5                	mov    %esp,%ebp
  1070b3:	83 ec 28             	sub    $0x28,%esp
  char *path;
  struct inode *ip;

  if(argstr(0, &path) < 0 || (ip = create(path, 0, T_DIR, 0, 0)) == 0)
  1070b6:	8d 45 f8             	lea    0xfffffff8(%ebp),%eax
  1070b9:	89 44 24 04          	mov    %eax,0x4(%esp)
  1070bd:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  1070c4:	e8 97 f2 ff ff       	call   106360 <argstr>
  1070c9:	85 c0                	test   %eax,%eax
  1070cb:	78 34                	js     107101 <sys_mkdir+0x51>
  1070cd:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1070d0:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  1070d7:	00 
  1070d8:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  1070df:	00 
  1070e0:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  1070e7:	00 
  1070e8:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  1070ef:	00 
  1070f0:	89 04 24             	mov    %eax,(%esp)
  1070f3:	e8 48 fb ff ff       	call   106c40 <create>
  1070f8:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  1070fb:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  1070ff:	75 09                	jne    10710a <sys_mkdir+0x5a>
    return -1;
  107101:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  107108:	eb 12                	jmp    10711c <sys_mkdir+0x6c>
  iunlockput(ip);
  10710a:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10710d:	89 04 24             	mov    %eax,(%esp)
  107110:	e8 5b af ff ff       	call   102070 <iunlockput>
  return 0;
  107115:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  10711c:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  10711f:	c9                   	leave  
  107120:	c3                   	ret    
  107121:	eb 0d                	jmp    107130 <sys_chdir>
  107123:	90                   	nop    
  107124:	90                   	nop    
  107125:	90                   	nop    
  107126:	90                   	nop    
  107127:	90                   	nop    
  107128:	90                   	nop    
  107129:	90                   	nop    
  10712a:	90                   	nop    
  10712b:	90                   	nop    
  10712c:	90                   	nop    
  10712d:	90                   	nop    
  10712e:	90                   	nop    
  10712f:	90                   	nop    

00107130 <sys_chdir>:

int
sys_chdir(void)
{
  107130:	55                   	push   %ebp
  107131:	89 e5                	mov    %esp,%ebp
  107133:	83 ec 28             	sub    $0x28,%esp
  char *path;
  struct inode *ip;

  if(argstr(0, &path) < 0 || (ip = namei(path)) == 0)
  107136:	8d 45 f8             	lea    0xfffffff8(%ebp),%eax
  107139:	89 44 24 04          	mov    %eax,0x4(%esp)
  10713d:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  107144:	e8 17 f2 ff ff       	call   106360 <argstr>
  107149:	85 c0                	test   %eax,%eax
  10714b:	78 14                	js     107161 <sys_chdir+0x31>
  10714d:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  107150:	89 04 24             	mov    %eax,(%esp)
  107153:	e8 08 bb ff ff       	call   102c60 <namei>
  107158:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  10715b:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  10715f:	75 09                	jne    10716a <sys_chdir+0x3a>
    return -1;
  107161:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  107168:	eb 67                	jmp    1071d1 <sys_chdir+0xa1>
  ilock(ip);
  10716a:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10716d:	89 04 24             	mov    %eax,(%esp)
  107170:	e8 4b ac ff ff       	call   101dc0 <ilock>
  if(ip->type != T_DIR){
  107175:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  107178:	0f b7 40 10          	movzwl 0x10(%eax),%eax
  10717c:	66 83 f8 01          	cmp    $0x1,%ax
  107180:	74 14                	je     107196 <sys_chdir+0x66>
    iunlockput(ip);
  107182:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  107185:	89 04 24             	mov    %eax,(%esp)
  107188:	e8 e3 ae ff ff       	call   102070 <iunlockput>
    return -1;
  10718d:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  107194:	eb 3b                	jmp    1071d1 <sys_chdir+0xa1>
  }
  iunlock(ip);
  107196:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  107199:	89 04 24             	mov    %eax,(%esp)
  10719c:	e8 7f ad ff ff       	call   101f20 <iunlock>
  iput(cp->cwd);
  1071a1:	e8 1a c7 ff ff       	call   1038c0 <cpu>
  1071a6:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  1071ad:	8b 40 60             	mov    0x60(%eax),%eax
  1071b0:	89 04 24             	mov    %eax,(%esp)
  1071b3:	e8 d8 ad ff ff       	call   101f90 <iput>
  cp->cwd = ip;
  1071b8:	e8 03 c7 ff ff       	call   1038c0 <cpu>
  1071bd:	8b 14 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%edx
  1071c4:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1071c7:	89 42 60             	mov    %eax,0x60(%edx)
  return 0;
  1071ca:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  1071d1:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  1071d4:	c9                   	leave  
  1071d5:	c3                   	ret    
  1071d6:	8d 76 00             	lea    0x0(%esi),%esi
  1071d9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

001071e0 <sys_exec>:

int
sys_exec(void)
{
  1071e0:	55                   	push   %ebp
  1071e1:	89 e5                	mov    %esp,%ebp
  1071e3:	56                   	push   %esi
  1071e4:	53                   	push   %ebx
  1071e5:	83 ec 70             	sub    $0x70,%esp
  char *path, *argv[20];
  int i;
  uint uargv, uarg;

  if(argstr(0, &path) < 0 || argint(1, (int*)&uargv) < 0)
  1071e8:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
  1071eb:	89 44 24 04          	mov    %eax,0x4(%esp)
  1071ef:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  1071f6:	e8 65 f1 ff ff       	call   106360 <argstr>
  1071fb:	85 c0                	test   %eax,%eax
  1071fd:	78 17                	js     107216 <sys_exec+0x36>
  1071ff:	8d 45 9c             	lea    0xffffff9c(%ebp),%eax
  107202:	89 44 24 04          	mov    %eax,0x4(%esp)
  107206:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  10720d:	e8 6e f0 ff ff       	call   106280 <argint>
  107212:	85 c0                	test   %eax,%eax
  107214:	79 0c                	jns    107222 <sys_exec+0x42>
    return -1;
  107216:	c7 45 94 ff ff ff ff 	movl   $0xffffffff,0xffffff94(%ebp)
  10721d:	e9 d9 00 00 00       	jmp    1072fb <sys_exec+0x11b>
  memset(argv, 0, sizeof(argv));
  107222:	c7 44 24 08 50 00 00 	movl   $0x50,0x8(%esp)
  107229:	00 
  10722a:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  107231:	00 
  107232:	8d 45 a0             	lea    0xffffffa0(%ebp),%eax
  107235:	89 04 24             	mov    %eax,(%esp)
  107238:	e8 c3 ec ff ff       	call   105f00 <memset>
  for(i=0;; i++){
  10723d:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
    if(i >= NELEM(argv))
  107244:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  107247:	83 f8 13             	cmp    $0x13,%eax
  10724a:	76 0c                	jbe    107258 <sys_exec+0x78>
      return -1;
  10724c:	c7 45 94 ff ff ff ff 	movl   $0xffffffff,0xffffff94(%ebp)
  107253:	e9 a3 00 00 00       	jmp    1072fb <sys_exec+0x11b>
    if(fetchint(cp, uargv+4*i, (int*)&uarg) < 0)
  107258:	8d 75 98             	lea    0xffffff98(%ebp),%esi
  10725b:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10725e:	c1 e0 02             	shl    $0x2,%eax
  107261:	89 c2                	mov    %eax,%edx
  107263:	8b 45 9c             	mov    0xffffff9c(%ebp),%eax
  107266:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
  107269:	e8 52 c6 ff ff       	call   1038c0 <cpu>
  10726e:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  107275:	89 74 24 08          	mov    %esi,0x8(%esp)
  107279:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  10727d:	89 04 24             	mov    %eax,(%esp)
  107280:	e8 2b ef ff ff       	call   1061b0 <fetchint>
  107285:	85 c0                	test   %eax,%eax
  107287:	79 09                	jns    107292 <sys_exec+0xb2>
      return -1;
  107289:	c7 45 94 ff ff ff ff 	movl   $0xffffffff,0xffffff94(%ebp)
  107290:	eb 69                	jmp    1072fb <sys_exec+0x11b>
    if(uarg == 0){
  107292:	8b 45 98             	mov    0xffffff98(%ebp),%eax
  107295:	85 c0                	test   %eax,%eax
  107297:	75 22                	jne    1072bb <sys_exec+0xdb>
      argv[i] = 0;
  107299:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10729c:	c7 44 85 a0 00 00 00 	movl   $0x0,0xffffffa0(%ebp,%eax,4)
  1072a3:	00 
      break;
    }
    if(fetchstr(cp, uarg, &argv[i]) < 0)
      return -1;
  }
  return exec(path, argv);
  1072a4:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
  1072a7:	8d 45 a0             	lea    0xffffffa0(%ebp),%eax
  1072aa:	89 44 24 04          	mov    %eax,0x4(%esp)
  1072ae:	89 14 24             	mov    %edx,(%esp)
  1072b1:	e8 fa 9d ff ff       	call   1010b0 <exec>
  1072b6:	89 45 94             	mov    %eax,0xffffff94(%ebp)
  1072b9:	eb 40                	jmp    1072fb <sys_exec+0x11b>
  1072bb:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  1072be:	c1 e0 02             	shl    $0x2,%eax
  1072c1:	8d 5d a0             	lea    0xffffffa0(%ebp),%ebx
  1072c4:	01 c3                	add    %eax,%ebx
  1072c6:	8b 75 98             	mov    0xffffff98(%ebp),%esi
  1072c9:	e8 f2 c5 ff ff       	call   1038c0 <cpu>
  1072ce:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  1072d5:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  1072d9:	89 74 24 04          	mov    %esi,0x4(%esp)
  1072dd:	89 04 24             	mov    %eax,(%esp)
  1072e0:	e8 1b ef ff ff       	call   106200 <fetchstr>
  1072e5:	85 c0                	test   %eax,%eax
  1072e7:	79 09                	jns    1072f2 <sys_exec+0x112>
  1072e9:	c7 45 94 ff ff ff ff 	movl   $0xffffffff,0xffffff94(%ebp)
  1072f0:	eb 09                	jmp    1072fb <sys_exec+0x11b>
  1072f2:	83 45 f4 01          	addl   $0x1,0xfffffff4(%ebp)
  1072f6:	e9 49 ff ff ff       	jmp    107244 <sys_exec+0x64>
  1072fb:	8b 45 94             	mov    0xffffff94(%ebp),%eax
}
  1072fe:	83 c4 70             	add    $0x70,%esp
  107301:	5b                   	pop    %ebx
  107302:	5e                   	pop    %esi
  107303:	5d                   	pop    %ebp
  107304:	c3                   	ret    
  107305:	8d 74 26 00          	lea    0x0(%esi),%esi
  107309:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00107310 <sys_pipe>:

int
sys_pipe(void)
{
  107310:	55                   	push   %ebp
  107311:	89 e5                	mov    %esp,%ebp
  107313:	83 ec 38             	sub    $0x38,%esp
  int *fd;
  struct file *rf, *wf;
  int fd0, fd1;

  if(argptr(0, (void*)&fd, 2*sizeof(fd[0])) < 0)
  107316:	8d 45 f4             	lea    0xfffffff4(%ebp),%eax
  107319:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  107320:	00 
  107321:	89 44 24 04          	mov    %eax,0x4(%esp)
  107325:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  10732c:	e8 9f ef ff ff       	call   1062d0 <argptr>
  107331:	85 c0                	test   %eax,%eax
  107333:	79 0c                	jns    107341 <sys_pipe+0x31>
    return -1;
  107335:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,0xffffffdc(%ebp)
  10733c:	e9 a7 00 00 00       	jmp    1073e8 <sys_pipe+0xd8>
  if(pipealloc(&rf, &wf) < 0)
  107341:	8d 45 ec             	lea    0xffffffec(%ebp),%eax
  107344:	89 44 24 04          	mov    %eax,0x4(%esp)
  107348:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
  10734b:	89 04 24             	mov    %eax,(%esp)
  10734e:	e8 5d d0 ff ff       	call   1043b0 <pipealloc>
  107353:	85 c0                	test   %eax,%eax
  107355:	79 0c                	jns    107363 <sys_pipe+0x53>
    return -1;
  107357:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,0xffffffdc(%ebp)
  10735e:	e9 85 00 00 00       	jmp    1073e8 <sys_pipe+0xd8>
  fd0 = -1;
  107363:	c7 45 f8 ff ff ff ff 	movl   $0xffffffff,0xfffffff8(%ebp)
  if((fd0 = fdalloc(rf)) < 0 || (fd1 = fdalloc(wf)) < 0){
  10736a:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10736d:	89 04 24             	mov    %eax,(%esp)
  107370:	e8 9b f1 ff ff       	call   106510 <fdalloc>
  107375:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  107378:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  10737c:	78 14                	js     107392 <sys_pipe+0x82>
  10737e:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  107381:	89 04 24             	mov    %eax,(%esp)
  107384:	e8 87 f1 ff ff       	call   106510 <fdalloc>
  107389:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  10738c:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  107390:	79 3c                	jns    1073ce <sys_pipe+0xbe>
    if(fd0 >= 0)
  107392:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  107396:	78 17                	js     1073af <sys_pipe+0x9f>
      cp->ofile[fd0] = 0;
  107398:	e8 23 c5 ff ff       	call   1038c0 <cpu>
  10739d:	8b 14 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%edx
  1073a4:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1073a7:	c7 44 82 20 00 00 00 	movl   $0x0,0x20(%edx,%eax,4)
  1073ae:	00 
    fileclose(rf);
  1073af:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  1073b2:	89 04 24             	mov    %eax,(%esp)
  1073b5:	e8 b6 a2 ff ff       	call   101670 <fileclose>
    fileclose(wf);
  1073ba:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  1073bd:	89 04 24             	mov    %eax,(%esp)
  1073c0:	e8 ab a2 ff ff       	call   101670 <fileclose>
    return -1;
  1073c5:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,0xffffffdc(%ebp)
  1073cc:	eb 1a                	jmp    1073e8 <sys_pipe+0xd8>
  }
  fd[0] = fd0;
  1073ce:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
  1073d1:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1073d4:	89 02                	mov    %eax,(%edx)
  fd[1] = fd1;
  1073d6:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  1073d9:	8d 50 04             	lea    0x4(%eax),%edx
  1073dc:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1073df:	89 02                	mov    %eax,(%edx)
  return 0;
  1073e1:	c7 45 dc 00 00 00 00 	movl   $0x0,0xffffffdc(%ebp)
  1073e8:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
}
  1073eb:	c9                   	leave  
  1073ec:	c3                   	ret    
  1073ed:	90                   	nop    
  1073ee:	90                   	nop    
  1073ef:	90                   	nop    

001073f0 <sys_fork>:
#include "lwip/include/lwip/sockets.h"

int
sys_fork(void)
{
  1073f0:	55                   	push   %ebp
  1073f1:	89 e5                	mov    %esp,%ebp
  1073f3:	83 ec 18             	sub    $0x18,%esp
  struct proc *np;

  if((np = copyproc(cp)) == 0)
  1073f6:	e8 c5 c4 ff ff       	call   1038c0 <cpu>
  1073fb:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  107402:	89 04 24             	mov    %eax,(%esp)
  107405:	e8 26 da ff ff       	call   104e30 <copyproc>
  10740a:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  10740d:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  107411:	75 09                	jne    10741c <sys_fork+0x2c>
    return -1;
  107413:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  10741a:	eb 13                	jmp    10742f <sys_fork+0x3f>
  np->state = RUNNABLE;
  10741c:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10741f:	c7 40 0c 03 00 00 00 	movl   $0x3,0xc(%eax)
  return np->pid;
  107426:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  107429:	8b 40 10             	mov    0x10(%eax),%eax
  10742c:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  10742f:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  107432:	c9                   	leave  
  107433:	c3                   	ret    
  107434:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  10743a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

00107440 <sys_exit>:

int
sys_exit(void)
{
  107440:	55                   	push   %ebp
  107441:	89 e5                	mov    %esp,%ebp
  107443:	83 ec 08             	sub    $0x8,%esp
  exit();
  107446:	e8 95 e2 ff ff       	call   1056e0 <exit>
  return 0;  // not reached
  10744b:	b8 00 00 00 00       	mov    $0x0,%eax
}
  107450:	c9                   	leave  
  107451:	c3                   	ret    
  107452:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi
  107459:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00107460 <sys_wait>:

int
sys_wait(void)
{
  107460:	55                   	push   %ebp
  107461:	89 e5                	mov    %esp,%ebp
  107463:	83 ec 08             	sub    $0x8,%esp
  return wait();
  107466:	e8 25 e4 ff ff       	call   105890 <wait>
}
  10746b:	c9                   	leave  
  10746c:	c3                   	ret    
  10746d:	8d 76 00             	lea    0x0(%esi),%esi

00107470 <sys_kill>:

int
sys_kill(void)
{
  107470:	55                   	push   %ebp
  107471:	89 e5                	mov    %esp,%ebp
  107473:	83 ec 28             	sub    $0x28,%esp
  int pid;

  if(argint(0, &pid) < 0)
  107476:	8d 45 fc             	lea    0xfffffffc(%ebp),%eax
  107479:	89 44 24 04          	mov    %eax,0x4(%esp)
  10747d:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  107484:	e8 f7 ed ff ff       	call   106280 <argint>
  107489:	85 c0                	test   %eax,%eax
  10748b:	79 09                	jns    107496 <sys_kill+0x26>
    return -1;
  10748d:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  107494:	eb 0e                	jmp    1074a4 <sys_kill+0x34>
  return kill(pid);
  107496:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  107499:	89 04 24             	mov    %eax,(%esp)
  10749c:	e8 af e1 ff ff       	call   105650 <kill>
  1074a1:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  1074a4:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  1074a7:	c9                   	leave  
  1074a8:	c3                   	ret    
  1074a9:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

001074b0 <sys_getpid>:

int
sys_getpid(void)
{
  1074b0:	55                   	push   %ebp
  1074b1:	89 e5                	mov    %esp,%ebp
  1074b3:	83 ec 08             	sub    $0x8,%esp
  return cp->pid;
  1074b6:	e8 05 c4 ff ff       	call   1038c0 <cpu>
  1074bb:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  1074c2:	8b 40 10             	mov    0x10(%eax),%eax
}
  1074c5:	c9                   	leave  
  1074c6:	c3                   	ret    
  1074c7:	89 f6                	mov    %esi,%esi
  1074c9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

001074d0 <sys_sbrk>:

int
sys_sbrk(void)
{
  1074d0:	55                   	push   %ebp
  1074d1:	89 e5                	mov    %esp,%ebp
  1074d3:	83 ec 28             	sub    $0x28,%esp
  int addr;
  int n;

  if(argint(0, &n) < 0)
  1074d6:	8d 45 f8             	lea    0xfffffff8(%ebp),%eax
  1074d9:	89 44 24 04          	mov    %eax,0x4(%esp)
  1074dd:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  1074e4:	e8 97 ed ff ff       	call   106280 <argint>
  1074e9:	85 c0                	test   %eax,%eax
  1074eb:	79 09                	jns    1074f6 <sys_sbrk+0x26>
    return -1;
  1074ed:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  1074f4:	eb 37                	jmp    10752d <sys_sbrk+0x5d>
  if((addr = growproc(n)) < 0)
  1074f6:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1074f9:	89 04 24             	mov    %eax,(%esp)
  1074fc:	e8 8f d3 ff ff       	call   104890 <growproc>
  107501:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  107504:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  107508:	79 09                	jns    107513 <sys_sbrk+0x43>
    return -1;
  10750a:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  107511:	eb 1a                	jmp    10752d <sys_sbrk+0x5d>
  setupsegs(cp);
  107513:	e8 a8 c3 ff ff       	call   1038c0 <cpu>
  107518:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  10751f:	89 04 24             	mov    %eax,(%esp)
  107522:	e8 79 d4 ff ff       	call   1049a0 <setupsegs>
  return addr;
  107527:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10752a:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  10752d:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  107530:	c9                   	leave  
  107531:	c3                   	ret    
  107532:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi
  107539:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00107540 <sys_sleep>:

int
sys_sleep(void)
{
  107540:	55                   	push   %ebp
  107541:	89 e5                	mov    %esp,%ebp
  107543:	83 ec 28             	sub    $0x28,%esp
  int n, ticks0;
  
  if(argint(0, &n) < 0)
  107546:	8d 45 f8             	lea    0xfffffff8(%ebp),%eax
  107549:	89 44 24 04          	mov    %eax,0x4(%esp)
  10754d:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  107554:	e8 27 ed ff ff       	call   106280 <argint>
  107559:	85 c0                	test   %eax,%eax
  10755b:	79 09                	jns    107566 <sys_sleep+0x26>
    return -1;
  10755d:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  107564:	eb 76                	jmp    1075dc <sys_sleep+0x9c>
  acquire(&tickslock);
  107566:	c7 04 24 80 0c 14 00 	movl   $0x140c80,(%esp)
  10756d:	e8 ce e5 ff ff       	call   105b40 <acquire>
  ticks0 = ticks;
  107572:	a1 c0 14 14 00       	mov    0x1414c0,%eax
  107577:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  while(ticks - ticks0 < n){
  10757a:	eb 3c                	jmp    1075b8 <sys_sleep+0x78>
    if(cp->killed){
  10757c:	e8 3f c3 ff ff       	call   1038c0 <cpu>
  107581:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  107588:	8b 40 1c             	mov    0x1c(%eax),%eax
  10758b:	85 c0                	test   %eax,%eax
  10758d:	74 15                	je     1075a4 <sys_sleep+0x64>
      release(&tickslock);
  10758f:	c7 04 24 80 0c 14 00 	movl   $0x140c80,(%esp)
  107596:	e8 a5 e7 ff ff       	call   105d40 <release>
      return -1;
  10759b:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  1075a2:	eb 38                	jmp    1075dc <sys_sleep+0x9c>
    }
    sleep(&ticks, &tickslock);
  1075a4:	c7 44 24 04 80 0c 14 	movl   $0x140c80,0x4(%esp)
  1075ab:	00 
  1075ac:	c7 04 24 c0 14 14 00 	movl   $0x1414c0,(%esp)
  1075b3:	e8 d8 de ff ff       	call   105490 <sleep>
  1075b8:	a1 c0 14 14 00       	mov    0x1414c0,%eax
  1075bd:	89 c2                	mov    %eax,%edx
  1075bf:	2b 55 fc             	sub    0xfffffffc(%ebp),%edx
  1075c2:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1075c5:	39 c2                	cmp    %eax,%edx
  1075c7:	7c b3                	jl     10757c <sys_sleep+0x3c>
  }
  release(&tickslock);
  1075c9:	c7 04 24 80 0c 14 00 	movl   $0x140c80,(%esp)
  1075d0:	e8 6b e7 ff ff       	call   105d40 <release>
  return 0;
  1075d5:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  1075dc:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  1075df:	c9                   	leave  
  1075e0:	c3                   	ret    
  1075e1:	eb 0d                	jmp    1075f0 <sys_upmsec>
  1075e3:	90                   	nop    
  1075e4:	90                   	nop    
  1075e5:	90                   	nop    
  1075e6:	90                   	nop    
  1075e7:	90                   	nop    
  1075e8:	90                   	nop    
  1075e9:	90                   	nop    
  1075ea:	90                   	nop    
  1075eb:	90                   	nop    
  1075ec:	90                   	nop    
  1075ed:	90                   	nop    
  1075ee:	90                   	nop    
  1075ef:	90                   	nop    

001075f0 <sys_upmsec>:

int
sys_upmsec(void)
{
  1075f0:	55                   	push   %ebp
  1075f1:	89 e5                	mov    %esp,%ebp
  1075f3:	83 ec 08             	sub    $0x8,%esp
    return millitime();
  1075f6:	e8 95 09 00 00       	call   107f90 <millitime>
}
  1075fb:	c9                   	leave  
  1075fc:	c3                   	ret    
  1075fd:	8d 76 00             	lea    0x0(%esi),%esi

00107600 <sys_accept>:

int 
sys_accept(void)
{
  107600:	55                   	push   %ebp
  107601:	89 e5                	mov    %esp,%ebp
  107603:	83 ec 28             	sub    $0x28,%esp
    int s;
    struct sockaddr *addr;
    socklen_t *addrlen;
    if((argint(0, &s)<0) || 
  107606:	8d 45 fc             	lea    0xfffffffc(%ebp),%eax
  107609:	89 44 24 04          	mov    %eax,0x4(%esp)
  10760d:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  107614:	e8 67 ec ff ff       	call   106280 <argint>
  107619:	85 c0                	test   %eax,%eax
  10761b:	78 3e                	js     10765b <sys_accept+0x5b>
  10761d:	8d 45 f8             	lea    0xfffffff8(%ebp),%eax
  107620:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
  107627:	00 
  107628:	89 44 24 04          	mov    %eax,0x4(%esp)
  10762c:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  107633:	e8 98 ec ff ff       	call   1062d0 <argptr>
  107638:	85 c0                	test   %eax,%eax
  10763a:	78 1f                	js     10765b <sys_accept+0x5b>
  10763c:	8d 45 f4             	lea    0xfffffff4(%ebp),%eax
  10763f:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  107646:	00 
  107647:	89 44 24 04          	mov    %eax,0x4(%esp)
  10764b:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  107652:	e8 79 ec ff ff       	call   1062d0 <argptr>
  107657:	85 c0                	test   %eax,%eax
  107659:	79 09                	jns    107664 <sys_accept+0x64>
            (argptr(1, &addr, sizeof(struct sockaddr))<0) ||
            (argptr(2, &addrlen, sizeof(socklen_t))<0))
        return -1;
  10765b:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  107662:	eb 1c                	jmp    107680 <sys_accept+0x80>
    return lwip_accept(s, addr, addrlen);
  107664:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  107667:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  10766a:	8b 4d fc             	mov    0xfffffffc(%ebp),%ecx
  10766d:	89 44 24 08          	mov    %eax,0x8(%esp)
  107671:	89 54 24 04          	mov    %edx,0x4(%esp)
  107675:	89 0c 24             	mov    %ecx,(%esp)
  107678:	e8 e3 09 01 00       	call   118060 <lwip_accept>
  10767d:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  107680:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  107683:	c9                   	leave  
  107684:	c3                   	ret    
  107685:	8d 74 26 00          	lea    0x0(%esi),%esi
  107689:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00107690 <sys_bind>:

int 
sys_bind(void)
{
  107690:	55                   	push   %ebp
  107691:	89 e5                	mov    %esp,%ebp
  107693:	83 ec 28             	sub    $0x28,%esp
    int s;
    struct sockaddr *name;
    socklen_t *namelen;
    if((argint(0, &s)<0) || 
  107696:	8d 45 fc             	lea    0xfffffffc(%ebp),%eax
  107699:	89 44 24 04          	mov    %eax,0x4(%esp)
  10769d:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  1076a4:	e8 d7 eb ff ff       	call   106280 <argint>
  1076a9:	85 c0                	test   %eax,%eax
  1076ab:	78 3e                	js     1076eb <sys_bind+0x5b>
  1076ad:	8d 45 f8             	lea    0xfffffff8(%ebp),%eax
  1076b0:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
  1076b7:	00 
  1076b8:	89 44 24 04          	mov    %eax,0x4(%esp)
  1076bc:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  1076c3:	e8 08 ec ff ff       	call   1062d0 <argptr>
  1076c8:	85 c0                	test   %eax,%eax
  1076ca:	78 1f                	js     1076eb <sys_bind+0x5b>
  1076cc:	8d 45 f4             	lea    0xfffffff4(%ebp),%eax
  1076cf:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  1076d6:	00 
  1076d7:	89 44 24 04          	mov    %eax,0x4(%esp)
  1076db:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  1076e2:	e8 e9 eb ff ff       	call   1062d0 <argptr>
  1076e7:	85 c0                	test   %eax,%eax
  1076e9:	79 09                	jns    1076f4 <sys_bind+0x64>
            (argptr(1, &name, sizeof(struct sockaddr))<0) ||
            (argptr(2, &namelen, sizeof(socklen_t))<0))
        return -1;
  1076eb:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  1076f2:	eb 1c                	jmp    107710 <sys_bind+0x80>
    return lwip_bind(s, name, namelen);
  1076f4:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  1076f7:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  1076fa:	8b 4d fc             	mov    0xfffffffc(%ebp),%ecx
  1076fd:	89 44 24 08          	mov    %eax,0x8(%esp)
  107701:	89 54 24 04          	mov    %edx,0x4(%esp)
  107705:	89 0c 24             	mov    %ecx,(%esp)
  107708:	e8 b3 0a 01 00       	call   1181c0 <lwip_bind>
  10770d:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  107710:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  107713:	c9                   	leave  
  107714:	c3                   	ret    
  107715:	8d 74 26 00          	lea    0x0(%esi),%esi
  107719:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00107720 <sys_shutdown>:

int 
sys_shutdown(void)
{
  107720:	55                   	push   %ebp
  107721:	89 e5                	mov    %esp,%ebp
  107723:	83 ec 28             	sub    $0x28,%esp
    int s;
    int how;
    if ((argint(0, &s)<0) || (argint(1, &how) < 0))
  107726:	8d 45 fc             	lea    0xfffffffc(%ebp),%eax
  107729:	89 44 24 04          	mov    %eax,0x4(%esp)
  10772d:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  107734:	e8 47 eb ff ff       	call   106280 <argint>
  107739:	85 c0                	test   %eax,%eax
  10773b:	78 17                	js     107754 <sys_shutdown+0x34>
  10773d:	8d 45 f8             	lea    0xfffffff8(%ebp),%eax
  107740:	89 44 24 04          	mov    %eax,0x4(%esp)
  107744:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  10774b:	e8 30 eb ff ff       	call   106280 <argint>
  107750:	85 c0                	test   %eax,%eax
  107752:	79 09                	jns    10775d <sys_shutdown+0x3d>
        return -1;
  107754:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  10775b:	eb 15                	jmp    107772 <sys_shutdown+0x52>
    return lwip_shutdown(s, how);
  10775d:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  107760:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  107763:	89 44 24 04          	mov    %eax,0x4(%esp)
  107767:	89 14 24             	mov    %edx,(%esp)
  10776a:	e8 91 1a 01 00       	call   119200 <lwip_shutdown>
  10776f:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  107772:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  107775:	c9                   	leave  
  107776:	c3                   	ret    
  107777:	89 f6                	mov    %esi,%esi
  107779:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00107780 <sys_getsockopt>:

int 
sys_getsockopt(void)
{
  107780:	55                   	push   %ebp
  107781:	89 e5                	mov    %esp,%ebp
  107783:	56                   	push   %esi
  107784:	53                   	push   %ebx
  107785:	83 ec 40             	sub    $0x40,%esp
    int s;
    int level;
    int optname;
    void *optval;
    socklen_t *optlen;
    if ((argint(0, &s)<0) ||
  107788:	8d 45 f4             	lea    0xfffffff4(%ebp),%eax
  10778b:	89 44 24 04          	mov    %eax,0x4(%esp)
  10778f:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  107796:	e8 e5 ea ff ff       	call   106280 <argint>
  10779b:	85 c0                	test   %eax,%eax
  10779d:	78 6c                	js     10780b <sys_getsockopt+0x8b>
  10779f:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
  1077a2:	89 44 24 04          	mov    %eax,0x4(%esp)
  1077a6:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  1077ad:	e8 ce ea ff ff       	call   106280 <argint>
  1077b2:	85 c0                	test   %eax,%eax
  1077b4:	78 55                	js     10780b <sys_getsockopt+0x8b>
  1077b6:	8d 45 ec             	lea    0xffffffec(%ebp),%eax
  1077b9:	89 44 24 04          	mov    %eax,0x4(%esp)
  1077bd:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  1077c4:	e8 b7 ea ff ff       	call   106280 <argint>
  1077c9:	85 c0                	test   %eax,%eax
  1077cb:	78 3e                	js     10780b <sys_getsockopt+0x8b>
  1077cd:	8d 45 e4             	lea    0xffffffe4(%ebp),%eax
  1077d0:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  1077d7:	00 
  1077d8:	89 44 24 04          	mov    %eax,0x4(%esp)
  1077dc:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  1077e3:	e8 e8 ea ff ff       	call   1062d0 <argptr>
  1077e8:	85 c0                	test   %eax,%eax
  1077ea:	78 1f                	js     10780b <sys_getsockopt+0x8b>
  1077ec:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
  1077ef:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  1077f6:	00 
  1077f7:	89 44 24 04          	mov    %eax,0x4(%esp)
  1077fb:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  107802:	e8 c9 ea ff ff       	call   1062d0 <argptr>
  107807:	85 c0                	test   %eax,%eax
  107809:	79 09                	jns    107814 <sys_getsockopt+0x94>
        (argint(1, &level)<0) ||
        (argint(2, &optname)<0) ||
        (argptr(4, &optlen, sizeof(socklen_t))<0) ||
        (argptr(3, &optval, 0)<0))
        return -1;
  10780b:	c7 45 d4 ff ff ff ff 	movl   $0xffffffff,0xffffffd4(%ebp)
  107812:	eb 2a                	jmp    10783e <sys_getsockopt+0xbe>
    return lwip_getsockopt(s, level, optname, optval, optlen);
  107814:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
  107817:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
  10781a:	8b 4d ec             	mov    0xffffffec(%ebp),%ecx
  10781d:	8b 5d f0             	mov    0xfffffff0(%ebp),%ebx
  107820:	8b 75 f4             	mov    0xfffffff4(%ebp),%esi
  107823:	89 44 24 10          	mov    %eax,0x10(%esp)
  107827:	89 54 24 0c          	mov    %edx,0xc(%esp)
  10782b:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  10782f:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  107833:	89 34 24             	mov    %esi,(%esp)
  107836:	e8 85 1b 01 00       	call   1193c0 <lwip_getsockopt>
  10783b:	89 45 d4             	mov    %eax,0xffffffd4(%ebp)
  10783e:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
}
  107841:	83 c4 40             	add    $0x40,%esp
  107844:	5b                   	pop    %ebx
  107845:	5e                   	pop    %esi
  107846:	5d                   	pop    %ebp
  107847:	c3                   	ret    
  107848:	90                   	nop    
  107849:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

00107850 <sys_setsockopt>:

int sys_setsockopt(void)
{
  107850:	55                   	push   %ebp
  107851:	89 e5                	mov    %esp,%ebp
  107853:	56                   	push   %esi
  107854:	53                   	push   %ebx
  107855:	83 ec 40             	sub    $0x40,%esp
    int s;
    int level;
    int optname;
    void *optval;
    socklen_t *optlen;
    if ((argint(0, &s)<0) ||
  107858:	8d 45 f4             	lea    0xfffffff4(%ebp),%eax
  10785b:	89 44 24 04          	mov    %eax,0x4(%esp)
  10785f:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  107866:	e8 15 ea ff ff       	call   106280 <argint>
  10786b:	85 c0                	test   %eax,%eax
  10786d:	78 6d                	js     1078dc <sys_setsockopt+0x8c>
  10786f:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
  107872:	89 44 24 04          	mov    %eax,0x4(%esp)
  107876:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  10787d:	e8 fe e9 ff ff       	call   106280 <argint>
  107882:	85 c0                	test   %eax,%eax
  107884:	78 56                	js     1078dc <sys_setsockopt+0x8c>
  107886:	8d 45 ec             	lea    0xffffffec(%ebp),%eax
  107889:	89 44 24 04          	mov    %eax,0x4(%esp)
  10788d:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  107894:	e8 e7 e9 ff ff       	call   106280 <argint>
  107899:	85 c0                	test   %eax,%eax
  10789b:	78 3f                	js     1078dc <sys_setsockopt+0x8c>
  10789d:	8d 45 e4             	lea    0xffffffe4(%ebp),%eax
  1078a0:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  1078a7:	00 
  1078a8:	89 44 24 04          	mov    %eax,0x4(%esp)
  1078ac:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  1078b3:	e8 18 ea ff ff       	call   1062d0 <argptr>
  1078b8:	85 c0                	test   %eax,%eax
  1078ba:	78 20                	js     1078dc <sys_setsockopt+0x8c>
  1078bc:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
  1078bf:	8b 00                	mov    (%eax),%eax
  1078c1:	8d 55 e8             	lea    0xffffffe8(%ebp),%edx
  1078c4:	89 44 24 08          	mov    %eax,0x8(%esp)
  1078c8:	89 54 24 04          	mov    %edx,0x4(%esp)
  1078cc:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  1078d3:	e8 f8 e9 ff ff       	call   1062d0 <argptr>
  1078d8:	85 c0                	test   %eax,%eax
  1078da:	79 09                	jns    1078e5 <sys_setsockopt+0x95>
        (argint(1, &level)<0) ||
        (argint(2, &optname)<0) ||
        (argptr(4, &optlen, sizeof(socklen_t))<0) ||
        (argptr(3, &optval, *optlen)<0))
        return -1;
  1078dc:	c7 45 d4 ff ff ff ff 	movl   $0xffffffff,0xffffffd4(%ebp)
  1078e3:	eb 2a                	jmp    10790f <sys_setsockopt+0xbf>
    return lwip_setsockopt(s, level, optname, optval, optlen);
  1078e5:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
  1078e8:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
  1078eb:	8b 4d ec             	mov    0xffffffec(%ebp),%ecx
  1078ee:	8b 5d f0             	mov    0xfffffff0(%ebp),%ebx
  1078f1:	8b 75 f4             	mov    0xfffffff4(%ebp),%esi
  1078f4:	89 44 24 10          	mov    %eax,0x10(%esp)
  1078f8:	89 54 24 0c          	mov    %edx,0xc(%esp)
  1078fc:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  107900:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  107904:	89 34 24             	mov    %esi,(%esp)
  107907:	e8 d4 1d 01 00       	call   1196e0 <lwip_setsockopt>
  10790c:	89 45 d4             	mov    %eax,0xffffffd4(%ebp)
  10790f:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
}
  107912:	83 c4 40             	add    $0x40,%esp
  107915:	5b                   	pop    %ebx
  107916:	5e                   	pop    %esi
  107917:	5d                   	pop    %ebp
  107918:	c3                   	ret    
  107919:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

00107920 <sys_sockclose>:

int sys_sockclose(void)
{
  107920:	55                   	push   %ebp
  107921:	89 e5                	mov    %esp,%ebp
  107923:	83 ec 28             	sub    $0x28,%esp
    int s;
    if (argint(0, &s) <0)
  107926:	8d 45 fc             	lea    0xfffffffc(%ebp),%eax
  107929:	89 44 24 04          	mov    %eax,0x4(%esp)
  10792d:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  107934:	e8 47 e9 ff ff       	call   106280 <argint>
  107939:	85 c0                	test   %eax,%eax
  10793b:	79 09                	jns    107946 <sys_sockclose+0x26>
        return -1;
  10793d:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  107944:	eb 0e                	jmp    107954 <sys_sockclose+0x34>
    return lwip_close(s);
  107946:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  107949:	89 04 24             	mov    %eax,(%esp)
  10794c:	e8 2f 09 01 00       	call   118280 <lwip_close>
  107951:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  107954:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  107957:	c9                   	leave  
  107958:	c3                   	ret    
  107959:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

00107960 <sys_connect>:

int sys_connect(void)
{
  107960:	55                   	push   %ebp
  107961:	89 e5                	mov    %esp,%ebp
  107963:	83 ec 28             	sub    $0x28,%esp
    int s;
    struct sockaddr *name;
    socklen_t *namelen;
    if((argint(0, &s)<0) || 
  107966:	8d 45 fc             	lea    0xfffffffc(%ebp),%eax
  107969:	89 44 24 04          	mov    %eax,0x4(%esp)
  10796d:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  107974:	e8 07 e9 ff ff       	call   106280 <argint>
  107979:	85 c0                	test   %eax,%eax
  10797b:	78 3e                	js     1079bb <sys_connect+0x5b>
  10797d:	8d 45 f8             	lea    0xfffffff8(%ebp),%eax
  107980:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
  107987:	00 
  107988:	89 44 24 04          	mov    %eax,0x4(%esp)
  10798c:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  107993:	e8 38 e9 ff ff       	call   1062d0 <argptr>
  107998:	85 c0                	test   %eax,%eax
  10799a:	78 1f                	js     1079bb <sys_connect+0x5b>
  10799c:	8d 45 f4             	lea    0xfffffff4(%ebp),%eax
  10799f:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  1079a6:	00 
  1079a7:	89 44 24 04          	mov    %eax,0x4(%esp)
  1079ab:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  1079b2:	e8 19 e9 ff ff       	call   1062d0 <argptr>
  1079b7:	85 c0                	test   %eax,%eax
  1079b9:	79 09                	jns    1079c4 <sys_connect+0x64>
            (argptr(1, &name, sizeof(struct sockaddr))<0) ||
            (argptr(2, &namelen, sizeof(socklen_t))<0))
        return -1;
  1079bb:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  1079c2:	eb 1c                	jmp    1079e0 <sys_connect+0x80>
    return lwip_connect(s, name, namelen);
  1079c4:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  1079c7:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  1079ca:	8b 4d fc             	mov    0xfffffffc(%ebp),%ecx
  1079cd:	89 44 24 08          	mov    %eax,0x8(%esp)
  1079d1:	89 54 24 04          	mov    %edx,0x4(%esp)
  1079d5:	89 0c 24             	mov    %ecx,(%esp)
  1079d8:	e8 63 09 01 00       	call   118340 <lwip_connect>
  1079dd:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  1079e0:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  1079e3:	c9                   	leave  
  1079e4:	c3                   	ret    
  1079e5:	8d 74 26 00          	lea    0x0(%esi),%esi
  1079e9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

001079f0 <sys_listen>:

int sys_listen(void)
{
  1079f0:	55                   	push   %ebp
  1079f1:	89 e5                	mov    %esp,%ebp
  1079f3:	83 ec 28             	sub    $0x28,%esp
    int s;
    int backlog;
    if ((argint(0, &s)<0) ||
  1079f6:	8d 45 fc             	lea    0xfffffffc(%ebp),%eax
  1079f9:	89 44 24 04          	mov    %eax,0x4(%esp)
  1079fd:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  107a04:	e8 77 e8 ff ff       	call   106280 <argint>
  107a09:	85 c0                	test   %eax,%eax
  107a0b:	78 17                	js     107a24 <sys_listen+0x34>
  107a0d:	8d 45 f8             	lea    0xfffffff8(%ebp),%eax
  107a10:	89 44 24 04          	mov    %eax,0x4(%esp)
  107a14:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  107a1b:	e8 60 e8 ff ff       	call   106280 <argint>
  107a20:	85 c0                	test   %eax,%eax
  107a22:	79 09                	jns    107a2d <sys_listen+0x3d>
        (argint(1, &backlog)<0))
        return -1;
  107a24:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  107a2b:	eb 15                	jmp    107a42 <sys_listen+0x52>
    return lwip_listen(s, backlog);
  107a2d:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  107a30:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  107a33:	89 44 24 04          	mov    %eax,0x4(%esp)
  107a37:	89 14 24             	mov    %edx,(%esp)
  107a3a:	e8 d1 09 01 00       	call   118410 <lwip_listen>
  107a3f:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  107a42:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  107a45:	c9                   	leave  
  107a46:	c3                   	ret    
  107a47:	89 f6                	mov    %esi,%esi
  107a49:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00107a50 <sys_recv>:

int sys_recv(void)
{
  107a50:	55                   	push   %ebp
  107a51:	89 e5                	mov    %esp,%ebp
  107a53:	53                   	push   %ebx
  107a54:	83 ec 24             	sub    $0x24,%esp
    int s;
    void *mem;
    int len;
    unsigned int flags;
    if ((argint(0, &s)<0) ||
  107a57:	8d 45 f8             	lea    0xfffffff8(%ebp),%eax
  107a5a:	89 44 24 04          	mov    %eax,0x4(%esp)
  107a5e:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  107a65:	e8 16 e8 ff ff       	call   106280 <argint>
  107a6a:	85 c0                	test   %eax,%eax
  107a6c:	78 4c                	js     107aba <sys_recv+0x6a>
  107a6e:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
  107a71:	89 44 24 04          	mov    %eax,0x4(%esp)
  107a75:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  107a7c:	e8 ff e7 ff ff       	call   106280 <argint>
  107a81:	85 c0                	test   %eax,%eax
  107a83:	78 35                	js     107aba <sys_recv+0x6a>
  107a85:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  107a88:	8d 55 f4             	lea    0xfffffff4(%ebp),%edx
  107a8b:	89 44 24 08          	mov    %eax,0x8(%esp)
  107a8f:	89 54 24 04          	mov    %edx,0x4(%esp)
  107a93:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  107a9a:	e8 31 e8 ff ff       	call   1062d0 <argptr>
  107a9f:	85 c0                	test   %eax,%eax
  107aa1:	78 17                	js     107aba <sys_recv+0x6a>
  107aa3:	8d 45 ec             	lea    0xffffffec(%ebp),%eax
  107aa6:	89 44 24 04          	mov    %eax,0x4(%esp)
  107aaa:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  107ab1:	e8 ca e7 ff ff       	call   106280 <argint>
  107ab6:	85 c0                	test   %eax,%eax
  107ab8:	79 09                	jns    107ac3 <sys_recv+0x73>
        (argint(2, &len)<0) ||
        (argptr(1, &mem, len)<0) ||
        (argint(3, &flags)<0))
        return -1;
  107aba:	c7 45 e8 ff ff ff ff 	movl   $0xffffffff,0xffffffe8(%ebp)
  107ac1:	eb 23                	jmp    107ae6 <sys_recv+0x96>
    return lwip_recv(s, mem, len, flags);
  107ac3:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  107ac6:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
  107ac9:	8b 4d f4             	mov    0xfffffff4(%ebp),%ecx
  107acc:	8b 5d f8             	mov    0xfffffff8(%ebp),%ebx
  107acf:	89 44 24 0c          	mov    %eax,0xc(%esp)
  107ad3:	89 54 24 08          	mov    %edx,0x8(%esp)
  107ad7:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  107adb:	89 1c 24             	mov    %ebx,(%esp)
  107ade:	e8 0d 0c 01 00       	call   1186f0 <lwip_recv>
  107ae3:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
  107ae6:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
}
  107ae9:	83 c4 24             	add    $0x24,%esp
  107aec:	5b                   	pop    %ebx
  107aed:	5d                   	pop    %ebp
  107aee:	c3                   	ret    
  107aef:	90                   	nop    

00107af0 <sys_recvfrom>:

int sys_recvfrom(void)
{
  107af0:	55                   	push   %ebp
  107af1:	89 e5                	mov    %esp,%ebp
  107af3:	57                   	push   %edi
  107af4:	56                   	push   %esi
  107af5:	53                   	push   %ebx
  107af6:	83 ec 3c             	sub    $0x3c,%esp
    int s;
    void *mem;
    int len;
    unsigned int flags;
    struct sockaddr *from;
    socklen_t *fromlen;
    if ((argint(0, &s)<0) ||
  107af9:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
  107afc:	89 44 24 04          	mov    %eax,0x4(%esp)
  107b00:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  107b07:	e8 74 e7 ff ff       	call   106280 <argint>
  107b0c:	85 c0                	test   %eax,%eax
  107b0e:	0f 88 8a 00 00 00    	js     107b9e <sys_recvfrom+0xae>
  107b14:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
  107b17:	89 44 24 04          	mov    %eax,0x4(%esp)
  107b1b:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  107b22:	e8 59 e7 ff ff       	call   106280 <argint>
  107b27:	85 c0                	test   %eax,%eax
  107b29:	78 73                	js     107b9e <sys_recvfrom+0xae>
  107b2b:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  107b2e:	8d 55 ec             	lea    0xffffffec(%ebp),%edx
  107b31:	89 44 24 08          	mov    %eax,0x8(%esp)
  107b35:	89 54 24 04          	mov    %edx,0x4(%esp)
  107b39:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  107b40:	e8 8b e7 ff ff       	call   1062d0 <argptr>
  107b45:	85 c0                	test   %eax,%eax
  107b47:	78 55                	js     107b9e <sys_recvfrom+0xae>
  107b49:	8d 45 e4             	lea    0xffffffe4(%ebp),%eax
  107b4c:	89 44 24 04          	mov    %eax,0x4(%esp)
  107b50:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  107b57:	e8 24 e7 ff ff       	call   106280 <argint>
  107b5c:	85 c0                	test   %eax,%eax
  107b5e:	78 3e                	js     107b9e <sys_recvfrom+0xae>
  107b60:	8d 45 e0             	lea    0xffffffe0(%ebp),%eax
  107b63:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  107b6a:	00 
  107b6b:	89 44 24 04          	mov    %eax,0x4(%esp)
  107b6f:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  107b76:	e8 55 e7 ff ff       	call   1062d0 <argptr>
  107b7b:	85 c0                	test   %eax,%eax
  107b7d:	78 1f                	js     107b9e <sys_recvfrom+0xae>
  107b7f:	8d 45 dc             	lea    0xffffffdc(%ebp),%eax
  107b82:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  107b89:	00 
  107b8a:	89 44 24 04          	mov    %eax,0x4(%esp)
  107b8e:	c7 04 24 05 00 00 00 	movl   $0x5,(%esp)
  107b95:	e8 36 e7 ff ff       	call   1062d0 <argptr>
  107b9a:	85 c0                	test   %eax,%eax
  107b9c:	79 09                	jns    107ba7 <sys_recvfrom+0xb7>
        (argint(2, &len)<0) ||
        (argptr(1, &mem, len)<0) ||
        (argint(3, &flags)<0) ||
        (argptr(4, &from, 0)<0) ||
        (argptr(5, &fromlen, sizeof(socklen_t))<0))
        return -1;
  107b9e:	c7 45 d0 ff ff ff ff 	movl   $0xffffffff,0xffffffd0(%ebp)
  107ba5:	eb 31                	jmp    107bd8 <sys_recvfrom+0xe8>
    return lwip_recvfrom(s, mem, len, flags, from, fromlen);
  107ba7:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  107baa:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
  107bad:	8b 4d e4             	mov    0xffffffe4(%ebp),%ecx
  107bb0:	8b 5d e8             	mov    0xffffffe8(%ebp),%ebx
  107bb3:	8b 75 ec             	mov    0xffffffec(%ebp),%esi
  107bb6:	8b 7d f0             	mov    0xfffffff0(%ebp),%edi
  107bb9:	89 44 24 14          	mov    %eax,0x14(%esp)
  107bbd:	89 54 24 10          	mov    %edx,0x10(%esp)
  107bc1:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
  107bc5:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  107bc9:	89 74 24 04          	mov    %esi,0x4(%esp)
  107bcd:	89 3c 24             	mov    %edi,(%esp)
  107bd0:	e8 cb 08 01 00       	call   1184a0 <lwip_recvfrom>
  107bd5:	89 45 d0             	mov    %eax,0xffffffd0(%ebp)
  107bd8:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
}
  107bdb:	83 c4 3c             	add    $0x3c,%esp
  107bde:	5b                   	pop    %ebx
  107bdf:	5e                   	pop    %esi
  107be0:	5f                   	pop    %edi
  107be1:	5d                   	pop    %ebp
  107be2:	c3                   	ret    
  107be3:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  107be9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00107bf0 <sys_send>:

int sys_send(void)
{
  107bf0:	55                   	push   %ebp
  107bf1:	89 e5                	mov    %esp,%ebp
  107bf3:	53                   	push   %ebx
  107bf4:	83 ec 24             	sub    $0x24,%esp
    int s;
    void *dataptr;
    int size;
    unsigned int flags;
    if ((argint(0, &s)<0) ||
  107bf7:	8d 45 f8             	lea    0xfffffff8(%ebp),%eax
  107bfa:	89 44 24 04          	mov    %eax,0x4(%esp)
  107bfe:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  107c05:	e8 76 e6 ff ff       	call   106280 <argint>
  107c0a:	85 c0                	test   %eax,%eax
  107c0c:	78 4c                	js     107c5a <sys_send+0x6a>
  107c0e:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
  107c11:	89 44 24 04          	mov    %eax,0x4(%esp)
  107c15:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  107c1c:	e8 5f e6 ff ff       	call   106280 <argint>
  107c21:	85 c0                	test   %eax,%eax
  107c23:	78 35                	js     107c5a <sys_send+0x6a>
  107c25:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  107c28:	8d 55 f4             	lea    0xfffffff4(%ebp),%edx
  107c2b:	89 44 24 08          	mov    %eax,0x8(%esp)
  107c2f:	89 54 24 04          	mov    %edx,0x4(%esp)
  107c33:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  107c3a:	e8 91 e6 ff ff       	call   1062d0 <argptr>
  107c3f:	85 c0                	test   %eax,%eax
  107c41:	78 17                	js     107c5a <sys_send+0x6a>
  107c43:	8d 45 ec             	lea    0xffffffec(%ebp),%eax
  107c46:	89 44 24 04          	mov    %eax,0x4(%esp)
  107c4a:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  107c51:	e8 2a e6 ff ff       	call   106280 <argint>
  107c56:	85 c0                	test   %eax,%eax
  107c58:	79 09                	jns    107c63 <sys_send+0x73>
        (argint(2, &size)<0) ||
        (argptr(1, &dataptr, size)<0) ||
        (argint(3, &flags)<0))
        return -1;
  107c5a:	c7 45 e8 ff ff ff ff 	movl   $0xffffffff,0xffffffe8(%ebp)
  107c61:	eb 23                	jmp    107c86 <sys_send+0x96>
    return lwip_send(s, dataptr, size, flags);
  107c63:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  107c66:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
  107c69:	8b 4d f4             	mov    0xfffffff4(%ebp),%ecx
  107c6c:	8b 5d f8             	mov    0xfffffff8(%ebp),%ebx
  107c6f:	89 44 24 0c          	mov    %eax,0xc(%esp)
  107c73:	89 54 24 08          	mov    %edx,0x8(%esp)
  107c77:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  107c7b:	89 1c 24             	mov    %ebx,(%esp)
  107c7e:	e8 ad 0a 01 00       	call   118730 <lwip_send>
  107c83:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
  107c86:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
}
  107c89:	83 c4 24             	add    $0x24,%esp
  107c8c:	5b                   	pop    %ebx
  107c8d:	5d                   	pop    %ebp
  107c8e:	c3                   	ret    
  107c8f:	90                   	nop    

00107c90 <sys_sendto>:

int sys_sendto(void)
{
  107c90:	55                   	push   %ebp
  107c91:	89 e5                	mov    %esp,%ebp
  107c93:	53                   	push   %ebx
  107c94:	83 ec 34             	sub    $0x34,%esp
    int s;
    void *dataptr;
    int size;
    unsigned int flags;
    struct sockaddr *to;
    socklen_t *tolen;
    if ((argint(0, &s)<0) ||
  107c97:	8d 45 f8             	lea    0xfffffff8(%ebp),%eax
  107c9a:	89 44 24 04          	mov    %eax,0x4(%esp)
  107c9e:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  107ca5:	e8 d6 e5 ff ff       	call   106280 <argint>
  107caa:	85 c0                	test   %eax,%eax
  107cac:	0f 88 8b 00 00 00    	js     107d3d <sys_sendto+0xad>
  107cb2:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
  107cb5:	89 44 24 04          	mov    %eax,0x4(%esp)
  107cb9:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  107cc0:	e8 bb e5 ff ff       	call   106280 <argint>
  107cc5:	85 c0                	test   %eax,%eax
  107cc7:	78 74                	js     107d3d <sys_sendto+0xad>
  107cc9:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  107ccc:	8d 55 f4             	lea    0xfffffff4(%ebp),%edx
  107ccf:	89 44 24 08          	mov    %eax,0x8(%esp)
  107cd3:	89 54 24 04          	mov    %edx,0x4(%esp)
  107cd7:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  107cde:	e8 ed e5 ff ff       	call   1062d0 <argptr>
  107ce3:	85 c0                	test   %eax,%eax
  107ce5:	78 56                	js     107d3d <sys_sendto+0xad>
  107ce7:	8d 45 ec             	lea    0xffffffec(%ebp),%eax
  107cea:	89 44 24 04          	mov    %eax,0x4(%esp)
  107cee:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  107cf5:	e8 86 e5 ff ff       	call   106280 <argint>
  107cfa:	85 c0                	test   %eax,%eax
  107cfc:	78 3f                	js     107d3d <sys_sendto+0xad>
  107cfe:	8d 45 e4             	lea    0xffffffe4(%ebp),%eax
  107d01:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  107d08:	00 
  107d09:	89 44 24 04          	mov    %eax,0x4(%esp)
  107d0d:	c7 04 24 05 00 00 00 	movl   $0x5,(%esp)
  107d14:	e8 b7 e5 ff ff       	call   1062d0 <argptr>
  107d19:	85 c0                	test   %eax,%eax
  107d1b:	78 20                	js     107d3d <sys_sendto+0xad>
  107d1d:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
  107d20:	8b 00                	mov    (%eax),%eax
  107d22:	8d 55 e8             	lea    0xffffffe8(%ebp),%edx
  107d25:	89 44 24 08          	mov    %eax,0x8(%esp)
  107d29:	89 54 24 04          	mov    %edx,0x4(%esp)
  107d2d:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  107d34:	e8 97 e5 ff ff       	call   1062d0 <argptr>
  107d39:	85 c0                	test   %eax,%eax
  107d3b:	79 09                	jns    107d46 <sys_sendto+0xb6>
        (argint(2, &size)<0) ||
        (argptr(1, &dataptr, size)<0) ||
        (argint(3, &flags)<0) ||
        (argptr(5, &tolen, sizeof(socklen_t))<0) ||
        (argptr(4, &to, *tolen)<0))
        return -1;
  107d3d:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,0xffffffd8(%ebp)
  107d44:	eb 23                	jmp    107d69 <sys_sendto+0xd9>
    return lwip_send(s, dataptr, size, flags);
  107d46:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  107d49:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
  107d4c:	8b 4d f4             	mov    0xfffffff4(%ebp),%ecx
  107d4f:	8b 5d f8             	mov    0xfffffff8(%ebp),%ebx
  107d52:	89 44 24 0c          	mov    %eax,0xc(%esp)
  107d56:	89 54 24 08          	mov    %edx,0x8(%esp)
  107d5a:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  107d5e:	89 1c 24             	mov    %ebx,(%esp)
  107d61:	e8 ca 09 01 00       	call   118730 <lwip_send>
  107d66:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
  107d69:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
}
  107d6c:	83 c4 34             	add    $0x34,%esp
  107d6f:	5b                   	pop    %ebx
  107d70:	5d                   	pop    %ebp
  107d71:	c3                   	ret    
  107d72:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi
  107d79:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00107d80 <sys_socket>:

int sys_socket(void)
{
  107d80:	55                   	push   %ebp
  107d81:	89 e5                	mov    %esp,%ebp
  107d83:	83 ec 28             	sub    $0x28,%esp
    int domain;
    int type;
    int protocol;
    if ((argint(0, &domain)<0) ||
  107d86:	8d 45 fc             	lea    0xfffffffc(%ebp),%eax
  107d89:	89 44 24 04          	mov    %eax,0x4(%esp)
  107d8d:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  107d94:	e8 e7 e4 ff ff       	call   106280 <argint>
  107d99:	85 c0                	test   %eax,%eax
  107d9b:	78 2e                	js     107dcb <sys_socket+0x4b>
  107d9d:	8d 45 f8             	lea    0xfffffff8(%ebp),%eax
  107da0:	89 44 24 04          	mov    %eax,0x4(%esp)
  107da4:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  107dab:	e8 d0 e4 ff ff       	call   106280 <argint>
  107db0:	85 c0                	test   %eax,%eax
  107db2:	78 17                	js     107dcb <sys_socket+0x4b>
  107db4:	8d 45 f4             	lea    0xfffffff4(%ebp),%eax
  107db7:	89 44 24 04          	mov    %eax,0x4(%esp)
  107dbb:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  107dc2:	e8 b9 e4 ff ff       	call   106280 <argint>
  107dc7:	85 c0                	test   %eax,%eax
  107dc9:	79 09                	jns    107dd4 <sys_socket+0x54>
        (argint(1, &type)<0) ||
        (argint(2, &protocol)<0))
        return -1;
  107dcb:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  107dd2:	eb 1c                	jmp    107df0 <sys_socket+0x70>
    return lwip_socket(domain, type, protocol);
  107dd4:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  107dd7:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  107dda:	8b 4d fc             	mov    0xfffffffc(%ebp),%ecx
  107ddd:	89 44 24 08          	mov    %eax,0x8(%esp)
  107de1:	89 54 24 04          	mov    %edx,0x4(%esp)
  107de5:	89 0c 24             	mov    %ecx,(%esp)
  107de8:	e8 63 0b 01 00       	call   118950 <lwip_socket>
  107ded:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  107df0:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  107df3:	c9                   	leave  
  107df4:	c3                   	ret    
  107df5:	8d 74 26 00          	lea    0x0(%esi),%esi
  107df9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00107e00 <sys_getpeername>:

int
sys_getpeername(void)
{
  107e00:	55                   	push   %ebp
  107e01:	89 e5                	mov    %esp,%ebp
  107e03:	83 ec 28             	sub    $0x28,%esp
    int s;
    struct sockaddr *name;
    socklen_t *namelen;
    if((argint(0, &s)<0) || 
  107e06:	8d 45 fc             	lea    0xfffffffc(%ebp),%eax
  107e09:	89 44 24 04          	mov    %eax,0x4(%esp)
  107e0d:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  107e14:	e8 67 e4 ff ff       	call   106280 <argint>
  107e19:	85 c0                	test   %eax,%eax
  107e1b:	78 3e                	js     107e5b <sys_getpeername+0x5b>
  107e1d:	8d 45 f8             	lea    0xfffffff8(%ebp),%eax
  107e20:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
  107e27:	00 
  107e28:	89 44 24 04          	mov    %eax,0x4(%esp)
  107e2c:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  107e33:	e8 98 e4 ff ff       	call   1062d0 <argptr>
  107e38:	85 c0                	test   %eax,%eax
  107e3a:	78 1f                	js     107e5b <sys_getpeername+0x5b>
  107e3c:	8d 45 f4             	lea    0xfffffff4(%ebp),%eax
  107e3f:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  107e46:	00 
  107e47:	89 44 24 04          	mov    %eax,0x4(%esp)
  107e4b:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  107e52:	e8 79 e4 ff ff       	call   1062d0 <argptr>
  107e57:	85 c0                	test   %eax,%eax
  107e59:	79 09                	jns    107e64 <sys_getpeername+0x64>
            (argptr(1, &name, sizeof(struct sockaddr))<0) ||
            (argptr(2, &namelen, sizeof(socklen_t))<0))
        return -1;
  107e5b:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  107e62:	eb 1c                	jmp    107e80 <sys_getpeername+0x80>
    return lwip_getpeername(s, name, namelen);
  107e64:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  107e67:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  107e6a:	8b 4d fc             	mov    0xfffffffc(%ebp),%ecx
  107e6d:	89 44 24 08          	mov    %eax,0x8(%esp)
  107e71:	89 54 24 04          	mov    %edx,0x4(%esp)
  107e75:	89 0c 24             	mov    %ecx,(%esp)
  107e78:	e8 a3 13 01 00       	call   119220 <lwip_getpeername>
  107e7d:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  107e80:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  107e83:	c9                   	leave  
  107e84:	c3                   	ret    
  107e85:	8d 74 26 00          	lea    0x0(%esi),%esi
  107e89:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00107e90 <sys_getsockname>:

int
sys_getsockname(void)
{
  107e90:	55                   	push   %ebp
  107e91:	89 e5                	mov    %esp,%ebp
  107e93:	83 ec 28             	sub    $0x28,%esp
    int s;
    struct sockaddr *name;
    socklen_t *namelen;
    if((argint(0, &s)<0) || 
  107e96:	8d 45 fc             	lea    0xfffffffc(%ebp),%eax
  107e99:	89 44 24 04          	mov    %eax,0x4(%esp)
  107e9d:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  107ea4:	e8 d7 e3 ff ff       	call   106280 <argint>
  107ea9:	85 c0                	test   %eax,%eax
  107eab:	78 3e                	js     107eeb <sys_getsockname+0x5b>
  107ead:	8d 45 f8             	lea    0xfffffff8(%ebp),%eax
  107eb0:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
  107eb7:	00 
  107eb8:	89 44 24 04          	mov    %eax,0x4(%esp)
  107ebc:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  107ec3:	e8 08 e4 ff ff       	call   1062d0 <argptr>
  107ec8:	85 c0                	test   %eax,%eax
  107eca:	78 1f                	js     107eeb <sys_getsockname+0x5b>
  107ecc:	8d 45 f4             	lea    0xfffffff4(%ebp),%eax
  107ecf:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  107ed6:	00 
  107ed7:	89 44 24 04          	mov    %eax,0x4(%esp)
  107edb:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  107ee2:	e8 e9 e3 ff ff       	call   1062d0 <argptr>
  107ee7:	85 c0                	test   %eax,%eax
  107ee9:	79 09                	jns    107ef4 <sys_getsockname+0x64>
            (argptr(1, &name, sizeof(struct sockaddr))<0) ||
            (argptr(2, &namelen, sizeof(socklen_t))<0))
        return -1;
  107eeb:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  107ef2:	eb 1c                	jmp    107f10 <sys_getsockname+0x80>
    return lwip_getsockname(s, name, namelen);
  107ef4:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  107ef7:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  107efa:	8b 4d fc             	mov    0xfffffffc(%ebp),%ecx
  107efd:	89 44 24 08          	mov    %eax,0x8(%esp)
  107f01:	89 54 24 04          	mov    %edx,0x4(%esp)
  107f05:	89 0c 24             	mov    %ecx,(%esp)
  107f08:	e8 e3 13 01 00       	call   1192f0 <lwip_getsockname>
  107f0d:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  107f10:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  107f13:	c9                   	leave  
  107f14:	c3                   	ret    
  107f15:	90                   	nop    
  107f16:	90                   	nop    
  107f17:	90                   	nop    
  107f18:	90                   	nop    
  107f19:	90                   	nop    
  107f1a:	90                   	nop    
  107f1b:	90                   	nop    
  107f1c:	90                   	nop    
  107f1d:	90                   	nop    
  107f1e:	90                   	nop    
  107f1f:	90                   	nop    

00107f20 <timer_init>:
#define TIMER_16BIT     0x30    // r/w counter 16 bits, LSB first

void
timer_init(void)
{
  107f20:	55                   	push   %ebp
  107f21:	89 e5                	mov    %esp,%ebp
  107f23:	83 ec 08             	sub    $0x8,%esp
  // Interrupt 100 times/sec.
  outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
  107f26:	c7 44 24 04 34 00 00 	movl   $0x34,0x4(%esp)
  107f2d:	00 
  107f2e:	c7 04 24 43 00 00 00 	movl   $0x43,(%esp)
  107f35:	e8 36 00 00 00       	call   107f70 <outb>
  outb(IO_TIMER1, TIMER_DIV(100) % 256);
  107f3a:	c7 44 24 04 9c 00 00 	movl   $0x9c,0x4(%esp)
  107f41:	00 
  107f42:	c7 04 24 40 00 00 00 	movl   $0x40,(%esp)
  107f49:	e8 22 00 00 00       	call   107f70 <outb>
  outb(IO_TIMER1, TIMER_DIV(100) / 256);
  107f4e:	c7 44 24 04 2e 00 00 	movl   $0x2e,0x4(%esp)
  107f55:	00 
  107f56:	c7 04 24 40 00 00 00 	movl   $0x40,(%esp)
  107f5d:	e8 0e 00 00 00       	call   107f70 <outb>
  pic_enable(IRQ_TIMER);
  107f62:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  107f69:	e8 b2 c2 ff ff       	call   104220 <pic_enable>
}
  107f6e:	c9                   	leave  
  107f6f:	c3                   	ret    

00107f70 <outb>:
}

static inline void
outb(ushort port, uchar data)
{
  107f70:	55                   	push   %ebp
  107f71:	89 e5                	mov    %esp,%ebp
  107f73:	83 ec 08             	sub    $0x8,%esp
  107f76:	8b 45 08             	mov    0x8(%ebp),%eax
  107f79:	8b 55 0c             	mov    0xc(%ebp),%edx
  107f7c:	66 89 45 fc          	mov    %ax,0xfffffffc(%ebp)
  107f80:	88 55 f8             	mov    %dl,0xfffffff8(%ebp)
  asm volatile("out %0,%1" : : "a" (data), "d" (port));
  107f83:	0f b6 45 f8          	movzbl 0xfffffff8(%ebp),%eax
  107f87:	0f b7 55 fc          	movzwl 0xfffffffc(%ebp),%edx
  107f8b:	ee                   	out    %al,(%dx)
}
  107f8c:	c9                   	leave  
  107f8d:	c3                   	ret    
  107f8e:	89 f6                	mov    %esi,%esi

00107f90 <millitime>:

int
millitime(void)
{
  107f90:	55                   	push   %ebp
  107f91:	89 e5                	mov    %esp,%ebp
    return ticks * 10;
  107f93:	8b 15 c0 14 14 00    	mov    0x1414c0,%edx
  107f99:	89 d0                	mov    %edx,%eax
  107f9b:	c1 e0 02             	shl    $0x2,%eax
  107f9e:	01 d0                	add    %edx,%eax
  107fa0:	01 c0                	add    %eax,%eax
}
  107fa2:	5d                   	pop    %ebp
  107fa3:	c3                   	ret    

00107fa4 <alltraps>:
  107fa4:	1e                   	push   %ds
  107fa5:	06                   	push   %es
  107fa6:	60                   	pusha  
  107fa7:	b8 10 00 00 00       	mov    $0x10,%eax
  107fac:	8e d8                	mov    %eax,%ds
  107fae:	8e c0                	mov    %eax,%es
  107fb0:	54                   	push   %esp
  107fb1:	e8 ea 01 00 00       	call   1081a0 <trap>
  107fb6:	83 c4 04             	add    $0x4,%esp

00107fb9 <trapret>:
  107fb9:	61                   	popa   
  107fba:	07                   	pop    %es
  107fbb:	1f                   	pop    %ds
  107fbc:	83 c4 08             	add    $0x8,%esp
  107fbf:	cf                   	iret   

00107fc0 <forkret1>:
  107fc0:	8b 64 24 04          	mov    0x4(%esp),%esp
  107fc4:	e9 f0 ff ff ff       	jmp    107fb9 <trapret>
  107fc9:	90                   	nop    
  107fca:	90                   	nop    
  107fcb:	90                   	nop    
  107fcc:	90                   	nop    
  107fcd:	90                   	nop    
  107fce:	90                   	nop    
  107fcf:	90                   	nop    

00107fd0 <tvinit>:
int ticks;

void
tvinit(void)
{
  107fd0:	55                   	push   %ebp
  107fd1:	89 e5                	mov    %esp,%ebp
  107fd3:	83 ec 18             	sub    $0x18,%esp
  int i;

  for(i = 0; i < 256; i++)
  107fd6:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
  107fdd:	e9 bf 00 00 00       	jmp    1080a1 <tvinit+0xd1>
    SETGATE(idt[i], 0, SEG_KCODE<<3, vectors[i], 0);
  107fe2:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  107fe5:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  107fe8:	8b 04 85 b4 c6 11 00 	mov    0x11c6b4(,%eax,4),%eax
  107fef:	66 89 04 d5 c0 0c 14 	mov    %ax,0x140cc0(,%edx,8)
  107ff6:	00 
  107ff7:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  107ffa:	66 c7 04 c5 c2 0c 14 	movw   $0x8,0x140cc2(,%eax,8)
  108001:	00 08 00 
  108004:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  108007:	0f b6 04 d5 c4 0c 14 	movzbl 0x140cc4(,%edx,8),%eax
  10800e:	00 
  10800f:	83 e0 e0             	and    $0xffffffe0,%eax
  108012:	88 04 d5 c4 0c 14 00 	mov    %al,0x140cc4(,%edx,8)
  108019:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  10801c:	0f b6 04 d5 c4 0c 14 	movzbl 0x140cc4(,%edx,8),%eax
  108023:	00 
  108024:	83 e0 1f             	and    $0x1f,%eax
  108027:	88 04 d5 c4 0c 14 00 	mov    %al,0x140cc4(,%edx,8)
  10802e:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  108031:	0f b6 04 d5 c5 0c 14 	movzbl 0x140cc5(,%edx,8),%eax
  108038:	00 
  108039:	83 e0 f0             	and    $0xfffffff0,%eax
  10803c:	83 c8 0e             	or     $0xe,%eax
  10803f:	88 04 d5 c5 0c 14 00 	mov    %al,0x140cc5(,%edx,8)
  108046:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  108049:	0f b6 04 d5 c5 0c 14 	movzbl 0x140cc5(,%edx,8),%eax
  108050:	00 
  108051:	83 e0 ef             	and    $0xffffffef,%eax
  108054:	88 04 d5 c5 0c 14 00 	mov    %al,0x140cc5(,%edx,8)
  10805b:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  10805e:	0f b6 04 d5 c5 0c 14 	movzbl 0x140cc5(,%edx,8),%eax
  108065:	00 
  108066:	83 e0 9f             	and    $0xffffff9f,%eax
  108069:	88 04 d5 c5 0c 14 00 	mov    %al,0x140cc5(,%edx,8)
  108070:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  108073:	0f b6 04 d5 c5 0c 14 	movzbl 0x140cc5(,%edx,8),%eax
  10807a:	00 
  10807b:	83 c8 80             	or     $0xffffff80,%eax
  10807e:	88 04 d5 c5 0c 14 00 	mov    %al,0x140cc5(,%edx,8)
  108085:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  108088:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10808b:	8b 04 85 b4 c6 11 00 	mov    0x11c6b4(,%eax,4),%eax
  108092:	c1 e8 10             	shr    $0x10,%eax
  108095:	66 89 04 d5 c6 0c 14 	mov    %ax,0x140cc6(,%edx,8)
  10809c:	00 
  10809d:	83 45 fc 01          	addl   $0x1,0xfffffffc(%ebp)
  1080a1:	81 7d fc ff 00 00 00 	cmpl   $0xff,0xfffffffc(%ebp)
  1080a8:	0f 8e 34 ff ff ff    	jle    107fe2 <tvinit+0x12>
  SETGATE(idt[T_SYSCALL], 0, SEG_KCODE<<3, vectors[T_SYSCALL], DPL_USER);
  1080ae:	a1 74 c7 11 00       	mov    0x11c774,%eax
  1080b3:	66 a3 40 0e 14 00    	mov    %ax,0x140e40
  1080b9:	66 c7 05 42 0e 14 00 	movw   $0x8,0x140e42
  1080c0:	08 00 
  1080c2:	0f b6 05 44 0e 14 00 	movzbl 0x140e44,%eax
  1080c9:	83 e0 e0             	and    $0xffffffe0,%eax
  1080cc:	a2 44 0e 14 00       	mov    %al,0x140e44
  1080d1:	0f b6 05 44 0e 14 00 	movzbl 0x140e44,%eax
  1080d8:	83 e0 1f             	and    $0x1f,%eax
  1080db:	a2 44 0e 14 00       	mov    %al,0x140e44
  1080e0:	0f b6 05 45 0e 14 00 	movzbl 0x140e45,%eax
  1080e7:	83 e0 f0             	and    $0xfffffff0,%eax
  1080ea:	83 c8 0e             	or     $0xe,%eax
  1080ed:	a2 45 0e 14 00       	mov    %al,0x140e45
  1080f2:	0f b6 05 45 0e 14 00 	movzbl 0x140e45,%eax
  1080f9:	83 e0 ef             	and    $0xffffffef,%eax
  1080fc:	a2 45 0e 14 00       	mov    %al,0x140e45
  108101:	0f b6 05 45 0e 14 00 	movzbl 0x140e45,%eax
  108108:	83 c8 60             	or     $0x60,%eax
  10810b:	a2 45 0e 14 00       	mov    %al,0x140e45
  108110:	0f b6 05 45 0e 14 00 	movzbl 0x140e45,%eax
  108117:	83 c8 80             	or     $0xffffff80,%eax
  10811a:	a2 45 0e 14 00       	mov    %al,0x140e45
  10811f:	a1 74 c7 11 00       	mov    0x11c774,%eax
  108124:	c1 e8 10             	shr    $0x10,%eax
  108127:	66 a3 46 0e 14 00    	mov    %ax,0x140e46
  
  initlock(&tickslock, "time");
  10812d:	c7 44 24 04 90 a7 11 	movl   $0x11a790,0x4(%esp)
  108134:	00 
  108135:	c7 04 24 80 0c 14 00 	movl   $0x140c80,(%esp)
  10813c:	e8 cf d9 ff ff       	call   105b10 <initlock>
}
  108141:	c9                   	leave  
  108142:	c3                   	ret    
  108143:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  108149:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00108150 <idtinit>:

void
idtinit(void)
{
  108150:	55                   	push   %ebp
  108151:	89 e5                	mov    %esp,%ebp
  108153:	83 ec 08             	sub    $0x8,%esp
  lidt(idt, sizeof(idt));
  108156:	c7 44 24 04 00 08 00 	movl   $0x800,0x4(%esp)
  10815d:	00 
  10815e:	c7 04 24 c0 0c 14 00 	movl   $0x140cc0,(%esp)
  108165:	e8 06 00 00 00       	call   108170 <lidt>
}
  10816a:	c9                   	leave  
  10816b:	c3                   	ret    
  10816c:	8d 74 26 00          	lea    0x0(%esi),%esi

00108170 <lidt>:
struct gatedesc;

static inline void
lidt(struct gatedesc *p, int size)
{
  108170:	55                   	push   %ebp
  108171:	89 e5                	mov    %esp,%ebp
  108173:	83 ec 10             	sub    $0x10,%esp
  volatile ushort pd[3];

  pd[0] = size-1;
  108176:	8b 45 0c             	mov    0xc(%ebp),%eax
  108179:	83 e8 01             	sub    $0x1,%eax
  10817c:	66 89 45 fa          	mov    %ax,0xfffffffa(%ebp)
  pd[1] = (uint)p;
  108180:	8b 45 08             	mov    0x8(%ebp),%eax
  108183:	66 89 45 fc          	mov    %ax,0xfffffffc(%ebp)
  pd[2] = (uint)p >> 16;
  108187:	8b 45 08             	mov    0x8(%ebp),%eax
  10818a:	c1 e8 10             	shr    $0x10,%eax
  10818d:	66 89 45 fe          	mov    %ax,0xfffffffe(%ebp)

  asm volatile("lidt (%0)" : : "r" (pd));
  108191:	8d 45 fa             	lea    0xfffffffa(%ebp),%eax
  108194:	0f 01 18             	lidtl  (%eax)
}
  108197:	c9                   	leave  
  108198:	c3                   	ret    
  108199:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

001081a0 <trap>:

void
trap(struct trapframe *tf)
{
  1081a0:	55                   	push   %ebp
  1081a1:	89 e5                	mov    %esp,%ebp
  1081a3:	57                   	push   %edi
  1081a4:	56                   	push   %esi
  1081a5:	53                   	push   %ebx
  1081a6:	83 ec 2c             	sub    $0x2c,%esp
  if(tf->trapno == T_SYSCALL){
  1081a9:	8b 45 08             	mov    0x8(%ebp),%eax
  1081ac:	8b 40 28             	mov    0x28(%eax),%eax
  1081af:	83 f8 30             	cmp    $0x30,%eax
  1081b2:	75 53                	jne    108207 <trap+0x67>
    if(cp->killed)
  1081b4:	e8 07 b7 ff ff       	call   1038c0 <cpu>
  1081b9:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  1081c0:	8b 40 1c             	mov    0x1c(%eax),%eax
  1081c3:	85 c0                	test   %eax,%eax
  1081c5:	74 05                	je     1081cc <trap+0x2c>
      exit();
  1081c7:	e8 14 d5 ff ff       	call   1056e0 <exit>
    cp->tf = tf;
  1081cc:	e8 ef b6 ff ff       	call   1038c0 <cpu>
  1081d1:	8b 14 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%edx
  1081d8:	8b 45 08             	mov    0x8(%ebp),%eax
  1081db:	89 82 84 00 00 00    	mov    %eax,0x84(%edx)
    syscall();
  1081e1:	e8 da e1 ff ff       	call   1063c0 <syscall>
    if(cp->killed)
  1081e6:	e8 d5 b6 ff ff       	call   1038c0 <cpu>
  1081eb:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  1081f2:	8b 40 1c             	mov    0x1c(%eax),%eax
  1081f5:	85 c0                	test   %eax,%eax
  1081f7:	0f 84 48 02 00 00    	je     108445 <trap+0x2a5>
      exit();
  1081fd:	e8 de d4 ff ff       	call   1056e0 <exit>
    return;
  108202:	e9 3e 02 00 00       	jmp    108445 <trap+0x2a5>
  }

  // Increment nlock to make sure interrupts stay off
  // during interrupt handler.  Decrement before returning.
  cpus[cpu()].nlock++;
  108207:	e8 b4 b6 ff ff       	call   1038c0 <cpu>
  10820c:	89 c1                	mov    %eax,%ecx
  10820e:	69 c1 ec 10 00 00    	imul   $0x10ec,%ecx,%eax
  108214:	8b 80 e0 dc 13 00    	mov    0x13dce0(%eax),%eax
  10821a:	8d 50 01             	lea    0x1(%eax),%edx
  10821d:	69 c1 ec 10 00 00    	imul   $0x10ec,%ecx,%eax
  108223:	89 90 e0 dc 13 00    	mov    %edx,0x13dce0(%eax)

  switch(tf->trapno){
  108229:	8b 45 08             	mov    0x8(%ebp),%eax
  10822c:	8b 40 28             	mov    0x28(%eax),%eax
  10822f:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
  108232:	83 7d e8 20          	cmpl   $0x20,0xffffffe8(%ebp)
  108236:	74 08                	je     108240 <trap+0xa0>
  108238:	83 7d e8 3f          	cmpl   $0x3f,0xffffffe8(%ebp)
  10823c:	74 46                	je     108284 <trap+0xe4>
  10823e:	eb 6d                	jmp    1082ad <trap+0x10d>
  case IRQ_OFFSET + IRQ_TIMER:
    if(cpu() == 0){
  108240:	e8 7b b6 ff ff       	call   1038c0 <cpu>
  108245:	85 c0                	test   %eax,%eax
  108247:	75 31                	jne    10827a <trap+0xda>
      acquire(&tickslock);
  108249:	c7 04 24 80 0c 14 00 	movl   $0x140c80,(%esp)
  108250:	e8 eb d8 ff ff       	call   105b40 <acquire>
      ticks++;
  108255:	a1 c0 14 14 00       	mov    0x1414c0,%eax
  10825a:	83 c0 01             	add    $0x1,%eax
  10825d:	a3 c0 14 14 00       	mov    %eax,0x1414c0
      wakeup(&ticks);
  108262:	c7 04 24 c0 14 14 00 	movl   $0x1414c0,(%esp)
  108269:	e8 b2 d3 ff ff       	call   105620 <wakeup>
      release(&tickslock);
  10826e:	c7 04 24 80 0c 14 00 	movl   $0x140c80,(%esp)
  108275:	e8 c6 da ff ff       	call   105d40 <release>
    }
    lapic_eoi();
  10827a:	e8 71 b6 ff ff       	call   1038f0 <lapic_eoi>
    break;
  10827f:	e9 31 01 00 00       	jmp    1083b5 <trap+0x215>
/*  case IRQ_OFFSET + IRQ_IDE:
    ide_intr();
    lapic_eoi();
    break;
  case IRQ_OFFSET + IRQ_KBD:
    kbd_intr();
    lapic_eoi();
    break;*/
  case IRQ_OFFSET + IRQ_SPURIOUS:
    cprintf("spurious interrupt from cpu %d eip %x\n", cpu(), tf->eip);
  108284:	8b 45 08             	mov    0x8(%ebp),%eax
  108287:	8b 58 30             	mov    0x30(%eax),%ebx
  10828a:	e8 31 b6 ff ff       	call   1038c0 <cpu>
  10828f:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  108293:	89 44 24 04          	mov    %eax,0x4(%esp)
  108297:	c7 04 24 98 a7 11 00 	movl   $0x11a798,(%esp)
  10829e:	e8 6d 84 ff ff       	call   100710 <cprintf>
    lapic_eoi();
  1082a3:	e8 48 b6 ff ff       	call   1038f0 <lapic_eoi>
    break;
  1082a8:	e9 08 01 00 00       	jmp    1083b5 <trap+0x215>
    
  default:
//    if (tf->trapno <= 30)
//    {
    if ((tf->trapno >= IRQ_OFFSET) && (tf->trapno <= IRQ_MAX))
  1082ad:	8b 45 08             	mov    0x8(%ebp),%eax
  1082b0:	8b 40 28             	mov    0x28(%eax),%eax
  1082b3:	83 f8 1f             	cmp    $0x1f,%eax
  1082b6:	76 43                	jbe    1082fb <trap+0x15b>
  1082b8:	8b 45 08             	mov    0x8(%ebp),%eax
  1082bb:	8b 40 28             	mov    0x28(%eax),%eax
  1082be:	3d 00 01 00 00       	cmp    $0x100,%eax
  1082c3:	77 36                	ja     1082fb <trap+0x15b>
        if (irq_handler[tf->trapno - IRQ_OFFSET])
  1082c5:	8b 45 08             	mov    0x8(%ebp),%eax
  1082c8:	8b 40 28             	mov    0x28(%eax),%eax
  1082cb:	83 e8 20             	sub    $0x20,%eax
  1082ce:	8b 04 85 20 dd 13 00 	mov    0x13dd20(,%eax,4),%eax
  1082d5:	85 c0                	test   %eax,%eax
  1082d7:	74 22                	je     1082fb <trap+0x15b>
        {
//            cprintf("IRQ %d goes to handler\n", tf->trapno);
            irq_handler[tf->trapno - IRQ_OFFSET](tf);
  1082d9:	8b 45 08             	mov    0x8(%ebp),%eax
  1082dc:	8b 40 28             	mov    0x28(%eax),%eax
  1082df:	83 e8 20             	sub    $0x20,%eax
  1082e2:	8b 14 85 20 dd 13 00 	mov    0x13dd20(,%eax,4),%edx
  1082e9:	8b 45 08             	mov    0x8(%ebp),%eax
  1082ec:	89 04 24             	mov    %eax,(%esp)
  1082ef:	ff d2                	call   *%edx
            lapic_eoi();
  1082f1:	e8 fa b5 ff ff       	call   1038f0 <lapic_eoi>
            break;
  1082f6:	e9 ba 00 00 00       	jmp    1083b5 <trap+0x215>
        }
    if(cp == 0){
  1082fb:	e8 c0 b5 ff ff       	call   1038c0 <cpu>
  108300:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  108307:	85 c0                	test   %eax,%eax
  108309:	75 2d                	jne    108338 <trap+0x198>
      // Otherwise it's our mistake.
      cprintf("unexpected trap %d from cpu %d eip %x\n",
  10830b:	8b 45 08             	mov    0x8(%ebp),%eax
  10830e:	8b 58 30             	mov    0x30(%eax),%ebx
  108311:	e8 aa b5 ff ff       	call   1038c0 <cpu>
  108316:	89 c2                	mov    %eax,%edx
  108318:	8b 45 08             	mov    0x8(%ebp),%eax
  10831b:	8b 40 28             	mov    0x28(%eax),%eax
  10831e:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
  108322:	89 54 24 08          	mov    %edx,0x8(%esp)
  108326:	89 44 24 04          	mov    %eax,0x4(%esp)
  10832a:	c7 04 24 c0 a7 11 00 	movl   $0x11a7c0,(%esp)
  108331:	e8 da 83 ff ff       	call   100710 <cprintf>
  108336:	eb 7d                	jmp    1083b5 <trap+0x215>
              tf->trapno, cpu(), tf->eip);
//      panic("trap");
    }
    else
    {
        // Assume process divided by zero or dereferenced null, etc.
        cprintf("pid %d %s: trap %d err %d"
  108338:	8b 45 08             	mov    0x8(%ebp),%eax
  10833b:	8b 70 30             	mov    0x30(%eax),%esi
  10833e:	e8 7d b5 ff ff       	call   1038c0 <cpu>
  108343:	89 c7                	mov    %eax,%edi
  108345:	8b 45 08             	mov    0x8(%ebp),%eax
  108348:	8b 40 2c             	mov    0x2c(%eax),%eax
  10834b:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  10834e:	8b 45 08             	mov    0x8(%ebp),%eax
  108351:	8b 40 28             	mov    0x28(%eax),%eax
  108354:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
  108357:	e8 64 b5 ff ff       	call   1038c0 <cpu>
  10835c:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  108363:	8d 98 88 00 00 00    	lea    0x88(%eax),%ebx
  108369:	e8 52 b5 ff ff       	call   1038c0 <cpu>
  10836e:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  108375:	8b 40 10             	mov    0x10(%eax),%eax
  108378:	89 74 24 18          	mov    %esi,0x18(%esp)
  10837c:	89 7c 24 14          	mov    %edi,0x14(%esp)
  108380:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
  108383:	89 54 24 10          	mov    %edx,0x10(%esp)
  108387:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
  10838a:	89 54 24 0c          	mov    %edx,0xc(%esp)
  10838e:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  108392:	89 44 24 04          	mov    %eax,0x4(%esp)
  108396:	c7 04 24 e8 a7 11 00 	movl   $0x11a7e8,(%esp)
  10839d:	e8 6e 83 ff ff       	call   100710 <cprintf>
                "on cpu %d eip %x -- kill proc\n",
            cp->pid, cp->name, tf->trapno, tf->err, cpu(), tf->eip);
        cp->killed = 1;
  1083a2:	e8 19 b5 ff ff       	call   1038c0 <cpu>
  1083a7:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  1083ae:	c7 40 1c 01 00 00 00 	movl   $0x1,0x1c(%eax)
    }
//    }
  }
  cpus[cpu()].nlock--;
  1083b5:	e8 06 b5 ff ff       	call   1038c0 <cpu>
  1083ba:	89 c1                	mov    %eax,%ecx
  1083bc:	69 c1 ec 10 00 00    	imul   $0x10ec,%ecx,%eax
  1083c2:	8b 80 e0 dc 13 00    	mov    0x13dce0(%eax),%eax
  1083c8:	8d 50 ff             	lea    0xffffffff(%eax),%edx
  1083cb:	69 c1 ec 10 00 00    	imul   $0x10ec,%ecx,%eax
  1083d1:	89 90 e0 dc 13 00    	mov    %edx,0x13dce0(%eax)

  // Force process exit if it has been killed and is in user space.
  // (If it is still executing in the kernel, let it keep running 
  // until it gets to the regular system call return.)
  if(cp && cp->killed && (tf->cs&3) == DPL_USER)
  1083d7:	e8 e4 b4 ff ff       	call   1038c0 <cpu>
  1083dc:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  1083e3:	85 c0                	test   %eax,%eax
  1083e5:	74 2a                	je     108411 <trap+0x271>
  1083e7:	e8 d4 b4 ff ff       	call   1038c0 <cpu>
  1083ec:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  1083f3:	8b 40 1c             	mov    0x1c(%eax),%eax
  1083f6:	85 c0                	test   %eax,%eax
  1083f8:	74 17                	je     108411 <trap+0x271>
  1083fa:	8b 45 08             	mov    0x8(%ebp),%eax
  1083fd:	0f b7 40 34          	movzwl 0x34(%eax),%eax
  108401:	0f b7 c0             	movzwl %ax,%eax
  108404:	83 e0 03             	and    $0x3,%eax
  108407:	83 f8 03             	cmp    $0x3,%eax
  10840a:	75 05                	jne    108411 <trap+0x271>
    exit();
  10840c:	e8 cf d2 ff ff       	call   1056e0 <exit>

  // Force process to give up CPU on clock tick.
  // If interrupts were on while locks held, would need to check nlock.
  if(cp && cp->state == RUNNING && tf->trapno == IRQ_OFFSET+IRQ_TIMER)
  108411:	e8 aa b4 ff ff       	call   1038c0 <cpu>
  108416:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  10841d:	85 c0                	test   %eax,%eax
  10841f:	74 24                	je     108445 <trap+0x2a5>
  108421:	e8 9a b4 ff ff       	call   1038c0 <cpu>
  108426:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  10842d:	8b 40 0c             	mov    0xc(%eax),%eax
  108430:	83 f8 04             	cmp    $0x4,%eax
  108433:	75 10                	jne    108445 <trap+0x2a5>
  108435:	8b 45 08             	mov    0x8(%ebp),%eax
  108438:	8b 40 28             	mov    0x28(%eax),%eax
  10843b:	83 f8 20             	cmp    $0x20,%eax
  10843e:	75 05                	jne    108445 <trap+0x2a5>
    yield();
  108440:	e8 bb ce ff ff       	call   105300 <yield>
}
  108445:	83 c4 2c             	add    $0x2c,%esp
  108448:	5b                   	pop    %ebx
  108449:	5e                   	pop    %esi
  10844a:	5f                   	pop    %edi
  10844b:	5d                   	pop    %ebp
  10844c:	c3                   	ret    
  10844d:	90                   	nop    
  10844e:	90                   	nop    
  10844f:	90                   	nop    

00108450 <vector0>:
  108450:	6a 00                	push   $0x0
  108452:	6a 00                	push   $0x0
  108454:	e9 4b fb ff ff       	jmp    107fa4 <alltraps>

00108459 <vector1>:
  108459:	6a 00                	push   $0x0
  10845b:	6a 01                	push   $0x1
  10845d:	e9 42 fb ff ff       	jmp    107fa4 <alltraps>

00108462 <vector2>:
  108462:	6a 00                	push   $0x0
  108464:	6a 02                	push   $0x2
  108466:	e9 39 fb ff ff       	jmp    107fa4 <alltraps>

0010846b <vector3>:
  10846b:	6a 00                	push   $0x0
  10846d:	6a 03                	push   $0x3
  10846f:	e9 30 fb ff ff       	jmp    107fa4 <alltraps>

00108474 <vector4>:
  108474:	6a 00                	push   $0x0
  108476:	6a 04                	push   $0x4
  108478:	e9 27 fb ff ff       	jmp    107fa4 <alltraps>

0010847d <vector5>:
  10847d:	6a 00                	push   $0x0
  10847f:	6a 05                	push   $0x5
  108481:	e9 1e fb ff ff       	jmp    107fa4 <alltraps>

00108486 <vector6>:
  108486:	6a 00                	push   $0x0
  108488:	6a 06                	push   $0x6
  10848a:	e9 15 fb ff ff       	jmp    107fa4 <alltraps>

0010848f <vector7>:
  10848f:	6a 00                	push   $0x0
  108491:	6a 07                	push   $0x7
  108493:	e9 0c fb ff ff       	jmp    107fa4 <alltraps>

00108498 <vector8>:
  108498:	6a 08                	push   $0x8
  10849a:	e9 05 fb ff ff       	jmp    107fa4 <alltraps>

0010849f <vector9>:
  10849f:	6a 09                	push   $0x9
  1084a1:	e9 fe fa ff ff       	jmp    107fa4 <alltraps>

001084a6 <vector10>:
  1084a6:	6a 0a                	push   $0xa
  1084a8:	e9 f7 fa ff ff       	jmp    107fa4 <alltraps>

001084ad <vector11>:
  1084ad:	6a 0b                	push   $0xb
  1084af:	e9 f0 fa ff ff       	jmp    107fa4 <alltraps>

001084b4 <vector12>:
  1084b4:	6a 0c                	push   $0xc
  1084b6:	e9 e9 fa ff ff       	jmp    107fa4 <alltraps>

001084bb <vector13>:
  1084bb:	6a 0d                	push   $0xd
  1084bd:	e9 e2 fa ff ff       	jmp    107fa4 <alltraps>

001084c2 <vector14>:
  1084c2:	6a 0e                	push   $0xe
  1084c4:	e9 db fa ff ff       	jmp    107fa4 <alltraps>

001084c9 <vector15>:
  1084c9:	6a 00                	push   $0x0
  1084cb:	6a 0f                	push   $0xf
  1084cd:	e9 d2 fa ff ff       	jmp    107fa4 <alltraps>

001084d2 <vector16>:
  1084d2:	6a 00                	push   $0x0
  1084d4:	6a 10                	push   $0x10
  1084d6:	e9 c9 fa ff ff       	jmp    107fa4 <alltraps>

001084db <vector17>:
  1084db:	6a 11                	push   $0x11
  1084dd:	e9 c2 fa ff ff       	jmp    107fa4 <alltraps>

001084e2 <vector18>:
  1084e2:	6a 00                	push   $0x0
  1084e4:	6a 12                	push   $0x12
  1084e6:	e9 b9 fa ff ff       	jmp    107fa4 <alltraps>

001084eb <vector19>:
  1084eb:	6a 00                	push   $0x0
  1084ed:	6a 13                	push   $0x13
  1084ef:	e9 b0 fa ff ff       	jmp    107fa4 <alltraps>

001084f4 <vector20>:
  1084f4:	6a 00                	push   $0x0
  1084f6:	6a 14                	push   $0x14
  1084f8:	e9 a7 fa ff ff       	jmp    107fa4 <alltraps>

001084fd <vector21>:
  1084fd:	6a 00                	push   $0x0
  1084ff:	6a 15                	push   $0x15
  108501:	e9 9e fa ff ff       	jmp    107fa4 <alltraps>

00108506 <vector22>:
  108506:	6a 00                	push   $0x0
  108508:	6a 16                	push   $0x16
  10850a:	e9 95 fa ff ff       	jmp    107fa4 <alltraps>

0010850f <vector23>:
  10850f:	6a 00                	push   $0x0
  108511:	6a 17                	push   $0x17
  108513:	e9 8c fa ff ff       	jmp    107fa4 <alltraps>

00108518 <vector24>:
  108518:	6a 00                	push   $0x0
  10851a:	6a 18                	push   $0x18
  10851c:	e9 83 fa ff ff       	jmp    107fa4 <alltraps>

00108521 <vector25>:
  108521:	6a 00                	push   $0x0
  108523:	6a 19                	push   $0x19
  108525:	e9 7a fa ff ff       	jmp    107fa4 <alltraps>

0010852a <vector26>:
  10852a:	6a 00                	push   $0x0
  10852c:	6a 1a                	push   $0x1a
  10852e:	e9 71 fa ff ff       	jmp    107fa4 <alltraps>

00108533 <vector27>:
  108533:	6a 00                	push   $0x0
  108535:	6a 1b                	push   $0x1b
  108537:	e9 68 fa ff ff       	jmp    107fa4 <alltraps>

0010853c <vector28>:
  10853c:	6a 00                	push   $0x0
  10853e:	6a 1c                	push   $0x1c
  108540:	e9 5f fa ff ff       	jmp    107fa4 <alltraps>

00108545 <vector29>:
  108545:	6a 00                	push   $0x0
  108547:	6a 1d                	push   $0x1d
  108549:	e9 56 fa ff ff       	jmp    107fa4 <alltraps>

0010854e <vector30>:
  10854e:	6a 00                	push   $0x0
  108550:	6a 1e                	push   $0x1e
  108552:	e9 4d fa ff ff       	jmp    107fa4 <alltraps>

00108557 <vector31>:
  108557:	6a 00                	push   $0x0
  108559:	6a 1f                	push   $0x1f
  10855b:	e9 44 fa ff ff       	jmp    107fa4 <alltraps>

00108560 <vector32>:
  108560:	6a 00                	push   $0x0
  108562:	6a 20                	push   $0x20
  108564:	e9 3b fa ff ff       	jmp    107fa4 <alltraps>

00108569 <vector33>:
  108569:	6a 00                	push   $0x0
  10856b:	6a 21                	push   $0x21
  10856d:	e9 32 fa ff ff       	jmp    107fa4 <alltraps>

00108572 <vector34>:
  108572:	6a 00                	push   $0x0
  108574:	6a 22                	push   $0x22
  108576:	e9 29 fa ff ff       	jmp    107fa4 <alltraps>

0010857b <vector35>:
  10857b:	6a 00                	push   $0x0
  10857d:	6a 23                	push   $0x23
  10857f:	e9 20 fa ff ff       	jmp    107fa4 <alltraps>

00108584 <vector36>:
  108584:	6a 00                	push   $0x0
  108586:	6a 24                	push   $0x24
  108588:	e9 17 fa ff ff       	jmp    107fa4 <alltraps>

0010858d <vector37>:
  10858d:	6a 00                	push   $0x0
  10858f:	6a 25                	push   $0x25
  108591:	e9 0e fa ff ff       	jmp    107fa4 <alltraps>

00108596 <vector38>:
  108596:	6a 00                	push   $0x0
  108598:	6a 26                	push   $0x26
  10859a:	e9 05 fa ff ff       	jmp    107fa4 <alltraps>

0010859f <vector39>:
  10859f:	6a 00                	push   $0x0
  1085a1:	6a 27                	push   $0x27
  1085a3:	e9 fc f9 ff ff       	jmp    107fa4 <alltraps>

001085a8 <vector40>:
  1085a8:	6a 00                	push   $0x0
  1085aa:	6a 28                	push   $0x28
  1085ac:	e9 f3 f9 ff ff       	jmp    107fa4 <alltraps>

001085b1 <vector41>:
  1085b1:	6a 00                	push   $0x0
  1085b3:	6a 29                	push   $0x29
  1085b5:	e9 ea f9 ff ff       	jmp    107fa4 <alltraps>

001085ba <vector42>:
  1085ba:	6a 00                	push   $0x0
  1085bc:	6a 2a                	push   $0x2a
  1085be:	e9 e1 f9 ff ff       	jmp    107fa4 <alltraps>

001085c3 <vector43>:
  1085c3:	6a 00                	push   $0x0
  1085c5:	6a 2b                	push   $0x2b
  1085c7:	e9 d8 f9 ff ff       	jmp    107fa4 <alltraps>

001085cc <vector44>:
  1085cc:	6a 00                	push   $0x0
  1085ce:	6a 2c                	push   $0x2c
  1085d0:	e9 cf f9 ff ff       	jmp    107fa4 <alltraps>

001085d5 <vector45>:
  1085d5:	6a 00                	push   $0x0
  1085d7:	6a 2d                	push   $0x2d
  1085d9:	e9 c6 f9 ff ff       	jmp    107fa4 <alltraps>

001085de <vector46>:
  1085de:	6a 00                	push   $0x0
  1085e0:	6a 2e                	push   $0x2e
  1085e2:	e9 bd f9 ff ff       	jmp    107fa4 <alltraps>

001085e7 <vector47>:
  1085e7:	6a 00                	push   $0x0
  1085e9:	6a 2f                	push   $0x2f
  1085eb:	e9 b4 f9 ff ff       	jmp    107fa4 <alltraps>

001085f0 <vector48>:
  1085f0:	6a 00                	push   $0x0
  1085f2:	6a 30                	push   $0x30
  1085f4:	e9 ab f9 ff ff       	jmp    107fa4 <alltraps>

001085f9 <vector49>:
  1085f9:	6a 00                	push   $0x0
  1085fb:	6a 31                	push   $0x31
  1085fd:	e9 a2 f9 ff ff       	jmp    107fa4 <alltraps>

00108602 <vector50>:
  108602:	6a 00                	push   $0x0
  108604:	6a 32                	push   $0x32
  108606:	e9 99 f9 ff ff       	jmp    107fa4 <alltraps>

0010860b <vector51>:
  10860b:	6a 00                	push   $0x0
  10860d:	6a 33                	push   $0x33
  10860f:	e9 90 f9 ff ff       	jmp    107fa4 <alltraps>

00108614 <vector52>:
  108614:	6a 00                	push   $0x0
  108616:	6a 34                	push   $0x34
  108618:	e9 87 f9 ff ff       	jmp    107fa4 <alltraps>

0010861d <vector53>:
  10861d:	6a 00                	push   $0x0
  10861f:	6a 35                	push   $0x35
  108621:	e9 7e f9 ff ff       	jmp    107fa4 <alltraps>

00108626 <vector54>:
  108626:	6a 00                	push   $0x0
  108628:	6a 36                	push   $0x36
  10862a:	e9 75 f9 ff ff       	jmp    107fa4 <alltraps>

0010862f <vector55>:
  10862f:	6a 00                	push   $0x0
  108631:	6a 37                	push   $0x37
  108633:	e9 6c f9 ff ff       	jmp    107fa4 <alltraps>

00108638 <vector56>:
  108638:	6a 00                	push   $0x0
  10863a:	6a 38                	push   $0x38
  10863c:	e9 63 f9 ff ff       	jmp    107fa4 <alltraps>

00108641 <vector57>:
  108641:	6a 00                	push   $0x0
  108643:	6a 39                	push   $0x39
  108645:	e9 5a f9 ff ff       	jmp    107fa4 <alltraps>

0010864a <vector58>:
  10864a:	6a 00                	push   $0x0
  10864c:	6a 3a                	push   $0x3a
  10864e:	e9 51 f9 ff ff       	jmp    107fa4 <alltraps>

00108653 <vector59>:
  108653:	6a 00                	push   $0x0
  108655:	6a 3b                	push   $0x3b
  108657:	e9 48 f9 ff ff       	jmp    107fa4 <alltraps>

0010865c <vector60>:
  10865c:	6a 00                	push   $0x0
  10865e:	6a 3c                	push   $0x3c
  108660:	e9 3f f9 ff ff       	jmp    107fa4 <alltraps>

00108665 <vector61>:
  108665:	6a 00                	push   $0x0
  108667:	6a 3d                	push   $0x3d
  108669:	e9 36 f9 ff ff       	jmp    107fa4 <alltraps>

0010866e <vector62>:
  10866e:	6a 00                	push   $0x0
  108670:	6a 3e                	push   $0x3e
  108672:	e9 2d f9 ff ff       	jmp    107fa4 <alltraps>

00108677 <vector63>:
  108677:	6a 00                	push   $0x0
  108679:	6a 3f                	push   $0x3f
  10867b:	e9 24 f9 ff ff       	jmp    107fa4 <alltraps>

00108680 <vector64>:
  108680:	6a 00                	push   $0x0
  108682:	6a 40                	push   $0x40
  108684:	e9 1b f9 ff ff       	jmp    107fa4 <alltraps>

00108689 <vector65>:
  108689:	6a 00                	push   $0x0
  10868b:	6a 41                	push   $0x41
  10868d:	e9 12 f9 ff ff       	jmp    107fa4 <alltraps>

00108692 <vector66>:
  108692:	6a 00                	push   $0x0
  108694:	6a 42                	push   $0x42
  108696:	e9 09 f9 ff ff       	jmp    107fa4 <alltraps>

0010869b <vector67>:
  10869b:	6a 00                	push   $0x0
  10869d:	6a 43                	push   $0x43
  10869f:	e9 00 f9 ff ff       	jmp    107fa4 <alltraps>

001086a4 <vector68>:
  1086a4:	6a 00                	push   $0x0
  1086a6:	6a 44                	push   $0x44
  1086a8:	e9 f7 f8 ff ff       	jmp    107fa4 <alltraps>

001086ad <vector69>:
  1086ad:	6a 00                	push   $0x0
  1086af:	6a 45                	push   $0x45
  1086b1:	e9 ee f8 ff ff       	jmp    107fa4 <alltraps>

001086b6 <vector70>:
  1086b6:	6a 00                	push   $0x0
  1086b8:	6a 46                	push   $0x46
  1086ba:	e9 e5 f8 ff ff       	jmp    107fa4 <alltraps>

001086bf <vector71>:
  1086bf:	6a 00                	push   $0x0
  1086c1:	6a 47                	push   $0x47
  1086c3:	e9 dc f8 ff ff       	jmp    107fa4 <alltraps>

001086c8 <vector72>:
  1086c8:	6a 00                	push   $0x0
  1086ca:	6a 48                	push   $0x48
  1086cc:	e9 d3 f8 ff ff       	jmp    107fa4 <alltraps>

001086d1 <vector73>:
  1086d1:	6a 00                	push   $0x0
  1086d3:	6a 49                	push   $0x49
  1086d5:	e9 ca f8 ff ff       	jmp    107fa4 <alltraps>

001086da <vector74>:
  1086da:	6a 00                	push   $0x0
  1086dc:	6a 4a                	push   $0x4a
  1086de:	e9 c1 f8 ff ff       	jmp    107fa4 <alltraps>

001086e3 <vector75>:
  1086e3:	6a 00                	push   $0x0
  1086e5:	6a 4b                	push   $0x4b
  1086e7:	e9 b8 f8 ff ff       	jmp    107fa4 <alltraps>

001086ec <vector76>:
  1086ec:	6a 00                	push   $0x0
  1086ee:	6a 4c                	push   $0x4c
  1086f0:	e9 af f8 ff ff       	jmp    107fa4 <alltraps>

001086f5 <vector77>:
  1086f5:	6a 00                	push   $0x0
  1086f7:	6a 4d                	push   $0x4d
  1086f9:	e9 a6 f8 ff ff       	jmp    107fa4 <alltraps>

001086fe <vector78>:
  1086fe:	6a 00                	push   $0x0
  108700:	6a 4e                	push   $0x4e
  108702:	e9 9d f8 ff ff       	jmp    107fa4 <alltraps>

00108707 <vector79>:
  108707:	6a 00                	push   $0x0
  108709:	6a 4f                	push   $0x4f
  10870b:	e9 94 f8 ff ff       	jmp    107fa4 <alltraps>

00108710 <vector80>:
  108710:	6a 00                	push   $0x0
  108712:	6a 50                	push   $0x50
  108714:	e9 8b f8 ff ff       	jmp    107fa4 <alltraps>

00108719 <vector81>:
  108719:	6a 00                	push   $0x0
  10871b:	6a 51                	push   $0x51
  10871d:	e9 82 f8 ff ff       	jmp    107fa4 <alltraps>

00108722 <vector82>:
  108722:	6a 00                	push   $0x0
  108724:	6a 52                	push   $0x52
  108726:	e9 79 f8 ff ff       	jmp    107fa4 <alltraps>

0010872b <vector83>:
  10872b:	6a 00                	push   $0x0
  10872d:	6a 53                	push   $0x53
  10872f:	e9 70 f8 ff ff       	jmp    107fa4 <alltraps>

00108734 <vector84>:
  108734:	6a 00                	push   $0x0
  108736:	6a 54                	push   $0x54
  108738:	e9 67 f8 ff ff       	jmp    107fa4 <alltraps>

0010873d <vector85>:
  10873d:	6a 00                	push   $0x0
  10873f:	6a 55                	push   $0x55
  108741:	e9 5e f8 ff ff       	jmp    107fa4 <alltraps>

00108746 <vector86>:
  108746:	6a 00                	push   $0x0
  108748:	6a 56                	push   $0x56
  10874a:	e9 55 f8 ff ff       	jmp    107fa4 <alltraps>

0010874f <vector87>:
  10874f:	6a 00                	push   $0x0
  108751:	6a 57                	push   $0x57
  108753:	e9 4c f8 ff ff       	jmp    107fa4 <alltraps>

00108758 <vector88>:
  108758:	6a 00                	push   $0x0
  10875a:	6a 58                	push   $0x58
  10875c:	e9 43 f8 ff ff       	jmp    107fa4 <alltraps>

00108761 <vector89>:
  108761:	6a 00                	push   $0x0
  108763:	6a 59                	push   $0x59
  108765:	e9 3a f8 ff ff       	jmp    107fa4 <alltraps>

0010876a <vector90>:
  10876a:	6a 00                	push   $0x0
  10876c:	6a 5a                	push   $0x5a
  10876e:	e9 31 f8 ff ff       	jmp    107fa4 <alltraps>

00108773 <vector91>:
  108773:	6a 00                	push   $0x0
  108775:	6a 5b                	push   $0x5b
  108777:	e9 28 f8 ff ff       	jmp    107fa4 <alltraps>

0010877c <vector92>:
  10877c:	6a 00                	push   $0x0
  10877e:	6a 5c                	push   $0x5c
  108780:	e9 1f f8 ff ff       	jmp    107fa4 <alltraps>

00108785 <vector93>:
  108785:	6a 00                	push   $0x0
  108787:	6a 5d                	push   $0x5d
  108789:	e9 16 f8 ff ff       	jmp    107fa4 <alltraps>

0010878e <vector94>:
  10878e:	6a 00                	push   $0x0
  108790:	6a 5e                	push   $0x5e
  108792:	e9 0d f8 ff ff       	jmp    107fa4 <alltraps>

00108797 <vector95>:
  108797:	6a 00                	push   $0x0
  108799:	6a 5f                	push   $0x5f
  10879b:	e9 04 f8 ff ff       	jmp    107fa4 <alltraps>

001087a0 <vector96>:
  1087a0:	6a 00                	push   $0x0
  1087a2:	6a 60                	push   $0x60
  1087a4:	e9 fb f7 ff ff       	jmp    107fa4 <alltraps>

001087a9 <vector97>:
  1087a9:	6a 00                	push   $0x0
  1087ab:	6a 61                	push   $0x61
  1087ad:	e9 f2 f7 ff ff       	jmp    107fa4 <alltraps>

001087b2 <vector98>:
  1087b2:	6a 00                	push   $0x0
  1087b4:	6a 62                	push   $0x62
  1087b6:	e9 e9 f7 ff ff       	jmp    107fa4 <alltraps>

001087bb <vector99>:
  1087bb:	6a 00                	push   $0x0
  1087bd:	6a 63                	push   $0x63
  1087bf:	e9 e0 f7 ff ff       	jmp    107fa4 <alltraps>

001087c4 <vector100>:
  1087c4:	6a 00                	push   $0x0
  1087c6:	6a 64                	push   $0x64
  1087c8:	e9 d7 f7 ff ff       	jmp    107fa4 <alltraps>

001087cd <vector101>:
  1087cd:	6a 00                	push   $0x0
  1087cf:	6a 65                	push   $0x65
  1087d1:	e9 ce f7 ff ff       	jmp    107fa4 <alltraps>

001087d6 <vector102>:
  1087d6:	6a 00                	push   $0x0
  1087d8:	6a 66                	push   $0x66
  1087da:	e9 c5 f7 ff ff       	jmp    107fa4 <alltraps>

001087df <vector103>:
  1087df:	6a 00                	push   $0x0
  1087e1:	6a 67                	push   $0x67
  1087e3:	e9 bc f7 ff ff       	jmp    107fa4 <alltraps>

001087e8 <vector104>:
  1087e8:	6a 00                	push   $0x0
  1087ea:	6a 68                	push   $0x68
  1087ec:	e9 b3 f7 ff ff       	jmp    107fa4 <alltraps>

001087f1 <vector105>:
  1087f1:	6a 00                	push   $0x0
  1087f3:	6a 69                	push   $0x69
  1087f5:	e9 aa f7 ff ff       	jmp    107fa4 <alltraps>

001087fa <vector106>:
  1087fa:	6a 00                	push   $0x0
  1087fc:	6a 6a                	push   $0x6a
  1087fe:	e9 a1 f7 ff ff       	jmp    107fa4 <alltraps>

00108803 <vector107>:
  108803:	6a 00                	push   $0x0
  108805:	6a 6b                	push   $0x6b
  108807:	e9 98 f7 ff ff       	jmp    107fa4 <alltraps>

0010880c <vector108>:
  10880c:	6a 00                	push   $0x0
  10880e:	6a 6c                	push   $0x6c
  108810:	e9 8f f7 ff ff       	jmp    107fa4 <alltraps>

00108815 <vector109>:
  108815:	6a 00                	push   $0x0
  108817:	6a 6d                	push   $0x6d
  108819:	e9 86 f7 ff ff       	jmp    107fa4 <alltraps>

0010881e <vector110>:
  10881e:	6a 00                	push   $0x0
  108820:	6a 6e                	push   $0x6e
  108822:	e9 7d f7 ff ff       	jmp    107fa4 <alltraps>

00108827 <vector111>:
  108827:	6a 00                	push   $0x0
  108829:	6a 6f                	push   $0x6f
  10882b:	e9 74 f7 ff ff       	jmp    107fa4 <alltraps>

00108830 <vector112>:
  108830:	6a 00                	push   $0x0
  108832:	6a 70                	push   $0x70
  108834:	e9 6b f7 ff ff       	jmp    107fa4 <alltraps>

00108839 <vector113>:
  108839:	6a 00                	push   $0x0
  10883b:	6a 71                	push   $0x71
  10883d:	e9 62 f7 ff ff       	jmp    107fa4 <alltraps>

00108842 <vector114>:
  108842:	6a 00                	push   $0x0
  108844:	6a 72                	push   $0x72
  108846:	e9 59 f7 ff ff       	jmp    107fa4 <alltraps>

0010884b <vector115>:
  10884b:	6a 00                	push   $0x0
  10884d:	6a 73                	push   $0x73
  10884f:	e9 50 f7 ff ff       	jmp    107fa4 <alltraps>

00108854 <vector116>:
  108854:	6a 00                	push   $0x0
  108856:	6a 74                	push   $0x74
  108858:	e9 47 f7 ff ff       	jmp    107fa4 <alltraps>

0010885d <vector117>:
  10885d:	6a 00                	push   $0x0
  10885f:	6a 75                	push   $0x75
  108861:	e9 3e f7 ff ff       	jmp    107fa4 <alltraps>

00108866 <vector118>:
  108866:	6a 00                	push   $0x0
  108868:	6a 76                	push   $0x76
  10886a:	e9 35 f7 ff ff       	jmp    107fa4 <alltraps>

0010886f <vector119>:
  10886f:	6a 00                	push   $0x0
  108871:	6a 77                	push   $0x77
  108873:	e9 2c f7 ff ff       	jmp    107fa4 <alltraps>

00108878 <vector120>:
  108878:	6a 00                	push   $0x0
  10887a:	6a 78                	push   $0x78
  10887c:	e9 23 f7 ff ff       	jmp    107fa4 <alltraps>

00108881 <vector121>:
  108881:	6a 00                	push   $0x0
  108883:	6a 79                	push   $0x79
  108885:	e9 1a f7 ff ff       	jmp    107fa4 <alltraps>

0010888a <vector122>:
  10888a:	6a 00                	push   $0x0
  10888c:	6a 7a                	push   $0x7a
  10888e:	e9 11 f7 ff ff       	jmp    107fa4 <alltraps>

00108893 <vector123>:
  108893:	6a 00                	push   $0x0
  108895:	6a 7b                	push   $0x7b
  108897:	e9 08 f7 ff ff       	jmp    107fa4 <alltraps>

0010889c <vector124>:
  10889c:	6a 00                	push   $0x0
  10889e:	6a 7c                	push   $0x7c
  1088a0:	e9 ff f6 ff ff       	jmp    107fa4 <alltraps>

001088a5 <vector125>:
  1088a5:	6a 00                	push   $0x0
  1088a7:	6a 7d                	push   $0x7d
  1088a9:	e9 f6 f6 ff ff       	jmp    107fa4 <alltraps>

001088ae <vector126>:
  1088ae:	6a 00                	push   $0x0
  1088b0:	6a 7e                	push   $0x7e
  1088b2:	e9 ed f6 ff ff       	jmp    107fa4 <alltraps>

001088b7 <vector127>:
  1088b7:	6a 00                	push   $0x0
  1088b9:	6a 7f                	push   $0x7f
  1088bb:	e9 e4 f6 ff ff       	jmp    107fa4 <alltraps>

001088c0 <vector128>:
  1088c0:	6a 00                	push   $0x0
  1088c2:	68 80 00 00 00       	push   $0x80
  1088c7:	e9 d8 f6 ff ff       	jmp    107fa4 <alltraps>

001088cc <vector129>:
  1088cc:	6a 00                	push   $0x0
  1088ce:	68 81 00 00 00       	push   $0x81
  1088d3:	e9 cc f6 ff ff       	jmp    107fa4 <alltraps>

001088d8 <vector130>:
  1088d8:	6a 00                	push   $0x0
  1088da:	68 82 00 00 00       	push   $0x82
  1088df:	e9 c0 f6 ff ff       	jmp    107fa4 <alltraps>

001088e4 <vector131>:
  1088e4:	6a 00                	push   $0x0
  1088e6:	68 83 00 00 00       	push   $0x83
  1088eb:	e9 b4 f6 ff ff       	jmp    107fa4 <alltraps>

001088f0 <vector132>:
  1088f0:	6a 00                	push   $0x0
  1088f2:	68 84 00 00 00       	push   $0x84
  1088f7:	e9 a8 f6 ff ff       	jmp    107fa4 <alltraps>

001088fc <vector133>:
  1088fc:	6a 00                	push   $0x0
  1088fe:	68 85 00 00 00       	push   $0x85
  108903:	e9 9c f6 ff ff       	jmp    107fa4 <alltraps>

00108908 <vector134>:
  108908:	6a 00                	push   $0x0
  10890a:	68 86 00 00 00       	push   $0x86
  10890f:	e9 90 f6 ff ff       	jmp    107fa4 <alltraps>

00108914 <vector135>:
  108914:	6a 00                	push   $0x0
  108916:	68 87 00 00 00       	push   $0x87
  10891b:	e9 84 f6 ff ff       	jmp    107fa4 <alltraps>

00108920 <vector136>:
  108920:	6a 00                	push   $0x0
  108922:	68 88 00 00 00       	push   $0x88
  108927:	e9 78 f6 ff ff       	jmp    107fa4 <alltraps>

0010892c <vector137>:
  10892c:	6a 00                	push   $0x0
  10892e:	68 89 00 00 00       	push   $0x89
  108933:	e9 6c f6 ff ff       	jmp    107fa4 <alltraps>

00108938 <vector138>:
  108938:	6a 00                	push   $0x0
  10893a:	68 8a 00 00 00       	push   $0x8a
  10893f:	e9 60 f6 ff ff       	jmp    107fa4 <alltraps>

00108944 <vector139>:
  108944:	6a 00                	push   $0x0
  108946:	68 8b 00 00 00       	push   $0x8b
  10894b:	e9 54 f6 ff ff       	jmp    107fa4 <alltraps>

00108950 <vector140>:
  108950:	6a 00                	push   $0x0
  108952:	68 8c 00 00 00       	push   $0x8c
  108957:	e9 48 f6 ff ff       	jmp    107fa4 <alltraps>

0010895c <vector141>:
  10895c:	6a 00                	push   $0x0
  10895e:	68 8d 00 00 00       	push   $0x8d
  108963:	e9 3c f6 ff ff       	jmp    107fa4 <alltraps>

00108968 <vector142>:
  108968:	6a 00                	push   $0x0
  10896a:	68 8e 00 00 00       	push   $0x8e
  10896f:	e9 30 f6 ff ff       	jmp    107fa4 <alltraps>

00108974 <vector143>:
  108974:	6a 00                	push   $0x0
  108976:	68 8f 00 00 00       	push   $0x8f
  10897b:	e9 24 f6 ff ff       	jmp    107fa4 <alltraps>

00108980 <vector144>:
  108980:	6a 00                	push   $0x0
  108982:	68 90 00 00 00       	push   $0x90
  108987:	e9 18 f6 ff ff       	jmp    107fa4 <alltraps>

0010898c <vector145>:
  10898c:	6a 00                	push   $0x0
  10898e:	68 91 00 00 00       	push   $0x91
  108993:	e9 0c f6 ff ff       	jmp    107fa4 <alltraps>

00108998 <vector146>:
  108998:	6a 00                	push   $0x0
  10899a:	68 92 00 00 00       	push   $0x92
  10899f:	e9 00 f6 ff ff       	jmp    107fa4 <alltraps>

001089a4 <vector147>:
  1089a4:	6a 00                	push   $0x0
  1089a6:	68 93 00 00 00       	push   $0x93
  1089ab:	e9 f4 f5 ff ff       	jmp    107fa4 <alltraps>

001089b0 <vector148>:
  1089b0:	6a 00                	push   $0x0
  1089b2:	68 94 00 00 00       	push   $0x94
  1089b7:	e9 e8 f5 ff ff       	jmp    107fa4 <alltraps>

001089bc <vector149>:
  1089bc:	6a 00                	push   $0x0
  1089be:	68 95 00 00 00       	push   $0x95
  1089c3:	e9 dc f5 ff ff       	jmp    107fa4 <alltraps>

001089c8 <vector150>:
  1089c8:	6a 00                	push   $0x0
  1089ca:	68 96 00 00 00       	push   $0x96
  1089cf:	e9 d0 f5 ff ff       	jmp    107fa4 <alltraps>

001089d4 <vector151>:
  1089d4:	6a 00                	push   $0x0
  1089d6:	68 97 00 00 00       	push   $0x97
  1089db:	e9 c4 f5 ff ff       	jmp    107fa4 <alltraps>

001089e0 <vector152>:
  1089e0:	6a 00                	push   $0x0
  1089e2:	68 98 00 00 00       	push   $0x98
  1089e7:	e9 b8 f5 ff ff       	jmp    107fa4 <alltraps>

001089ec <vector153>:
  1089ec:	6a 00                	push   $0x0
  1089ee:	68 99 00 00 00       	push   $0x99
  1089f3:	e9 ac f5 ff ff       	jmp    107fa4 <alltraps>

001089f8 <vector154>:
  1089f8:	6a 00                	push   $0x0
  1089fa:	68 9a 00 00 00       	push   $0x9a
  1089ff:	e9 a0 f5 ff ff       	jmp    107fa4 <alltraps>

00108a04 <vector155>:
  108a04:	6a 00                	push   $0x0
  108a06:	68 9b 00 00 00       	push   $0x9b
  108a0b:	e9 94 f5 ff ff       	jmp    107fa4 <alltraps>

00108a10 <vector156>:
  108a10:	6a 00                	push   $0x0
  108a12:	68 9c 00 00 00       	push   $0x9c
  108a17:	e9 88 f5 ff ff       	jmp    107fa4 <alltraps>

00108a1c <vector157>:
  108a1c:	6a 00                	push   $0x0
  108a1e:	68 9d 00 00 00       	push   $0x9d
  108a23:	e9 7c f5 ff ff       	jmp    107fa4 <alltraps>

00108a28 <vector158>:
  108a28:	6a 00                	push   $0x0
  108a2a:	68 9e 00 00 00       	push   $0x9e
  108a2f:	e9 70 f5 ff ff       	jmp    107fa4 <alltraps>

00108a34 <vector159>:
  108a34:	6a 00                	push   $0x0
  108a36:	68 9f 00 00 00       	push   $0x9f
  108a3b:	e9 64 f5 ff ff       	jmp    107fa4 <alltraps>

00108a40 <vector160>:
  108a40:	6a 00                	push   $0x0
  108a42:	68 a0 00 00 00       	push   $0xa0
  108a47:	e9 58 f5 ff ff       	jmp    107fa4 <alltraps>

00108a4c <vector161>:
  108a4c:	6a 00                	push   $0x0
  108a4e:	68 a1 00 00 00       	push   $0xa1
  108a53:	e9 4c f5 ff ff       	jmp    107fa4 <alltraps>

00108a58 <vector162>:
  108a58:	6a 00                	push   $0x0
  108a5a:	68 a2 00 00 00       	push   $0xa2
  108a5f:	e9 40 f5 ff ff       	jmp    107fa4 <alltraps>

00108a64 <vector163>:
  108a64:	6a 00                	push   $0x0
  108a66:	68 a3 00 00 00       	push   $0xa3
  108a6b:	e9 34 f5 ff ff       	jmp    107fa4 <alltraps>

00108a70 <vector164>:
  108a70:	6a 00                	push   $0x0
  108a72:	68 a4 00 00 00       	push   $0xa4
  108a77:	e9 28 f5 ff ff       	jmp    107fa4 <alltraps>

00108a7c <vector165>:
  108a7c:	6a 00                	push   $0x0
  108a7e:	68 a5 00 00 00       	push   $0xa5
  108a83:	e9 1c f5 ff ff       	jmp    107fa4 <alltraps>

00108a88 <vector166>:
  108a88:	6a 00                	push   $0x0
  108a8a:	68 a6 00 00 00       	push   $0xa6
  108a8f:	e9 10 f5 ff ff       	jmp    107fa4 <alltraps>

00108a94 <vector167>:
  108a94:	6a 00                	push   $0x0
  108a96:	68 a7 00 00 00       	push   $0xa7
  108a9b:	e9 04 f5 ff ff       	jmp    107fa4 <alltraps>

00108aa0 <vector168>:
  108aa0:	6a 00                	push   $0x0
  108aa2:	68 a8 00 00 00       	push   $0xa8
  108aa7:	e9 f8 f4 ff ff       	jmp    107fa4 <alltraps>

00108aac <vector169>:
  108aac:	6a 00                	push   $0x0
  108aae:	68 a9 00 00 00       	push   $0xa9
  108ab3:	e9 ec f4 ff ff       	jmp    107fa4 <alltraps>

00108ab8 <vector170>:
  108ab8:	6a 00                	push   $0x0
  108aba:	68 aa 00 00 00       	push   $0xaa
  108abf:	e9 e0 f4 ff ff       	jmp    107fa4 <alltraps>

00108ac4 <vector171>:
  108ac4:	6a 00                	push   $0x0
  108ac6:	68 ab 00 00 00       	push   $0xab
  108acb:	e9 d4 f4 ff ff       	jmp    107fa4 <alltraps>

00108ad0 <vector172>:
  108ad0:	6a 00                	push   $0x0
  108ad2:	68 ac 00 00 00       	push   $0xac
  108ad7:	e9 c8 f4 ff ff       	jmp    107fa4 <alltraps>

00108adc <vector173>:
  108adc:	6a 00                	push   $0x0
  108ade:	68 ad 00 00 00       	push   $0xad
  108ae3:	e9 bc f4 ff ff       	jmp    107fa4 <alltraps>

00108ae8 <vector174>:
  108ae8:	6a 00                	push   $0x0
  108aea:	68 ae 00 00 00       	push   $0xae
  108aef:	e9 b0 f4 ff ff       	jmp    107fa4 <alltraps>

00108af4 <vector175>:
  108af4:	6a 00                	push   $0x0
  108af6:	68 af 00 00 00       	push   $0xaf
  108afb:	e9 a4 f4 ff ff       	jmp    107fa4 <alltraps>

00108b00 <vector176>:
  108b00:	6a 00                	push   $0x0
  108b02:	68 b0 00 00 00       	push   $0xb0
  108b07:	e9 98 f4 ff ff       	jmp    107fa4 <alltraps>

00108b0c <vector177>:
  108b0c:	6a 00                	push   $0x0
  108b0e:	68 b1 00 00 00       	push   $0xb1
  108b13:	e9 8c f4 ff ff       	jmp    107fa4 <alltraps>

00108b18 <vector178>:
  108b18:	6a 00                	push   $0x0
  108b1a:	68 b2 00 00 00       	push   $0xb2
  108b1f:	e9 80 f4 ff ff       	jmp    107fa4 <alltraps>

00108b24 <vector179>:
  108b24:	6a 00                	push   $0x0
  108b26:	68 b3 00 00 00       	push   $0xb3
  108b2b:	e9 74 f4 ff ff       	jmp    107fa4 <alltraps>

00108b30 <vector180>:
  108b30:	6a 00                	push   $0x0
  108b32:	68 b4 00 00 00       	push   $0xb4
  108b37:	e9 68 f4 ff ff       	jmp    107fa4 <alltraps>

00108b3c <vector181>:
  108b3c:	6a 00                	push   $0x0
  108b3e:	68 b5 00 00 00       	push   $0xb5
  108b43:	e9 5c f4 ff ff       	jmp    107fa4 <alltraps>

00108b48 <vector182>:
  108b48:	6a 00                	push   $0x0
  108b4a:	68 b6 00 00 00       	push   $0xb6
  108b4f:	e9 50 f4 ff ff       	jmp    107fa4 <alltraps>

00108b54 <vector183>:
  108b54:	6a 00                	push   $0x0
  108b56:	68 b7 00 00 00       	push   $0xb7
  108b5b:	e9 44 f4 ff ff       	jmp    107fa4 <alltraps>

00108b60 <vector184>:
  108b60:	6a 00                	push   $0x0
  108b62:	68 b8 00 00 00       	push   $0xb8
  108b67:	e9 38 f4 ff ff       	jmp    107fa4 <alltraps>

00108b6c <vector185>:
  108b6c:	6a 00                	push   $0x0
  108b6e:	68 b9 00 00 00       	push   $0xb9
  108b73:	e9 2c f4 ff ff       	jmp    107fa4 <alltraps>

00108b78 <vector186>:
  108b78:	6a 00                	push   $0x0
  108b7a:	68 ba 00 00 00       	push   $0xba
  108b7f:	e9 20 f4 ff ff       	jmp    107fa4 <alltraps>

00108b84 <vector187>:
  108b84:	6a 00                	push   $0x0
  108b86:	68 bb 00 00 00       	push   $0xbb
  108b8b:	e9 14 f4 ff ff       	jmp    107fa4 <alltraps>

00108b90 <vector188>:
  108b90:	6a 00                	push   $0x0
  108b92:	68 bc 00 00 00       	push   $0xbc
  108b97:	e9 08 f4 ff ff       	jmp    107fa4 <alltraps>

00108b9c <vector189>:
  108b9c:	6a 00                	push   $0x0
  108b9e:	68 bd 00 00 00       	push   $0xbd
  108ba3:	e9 fc f3 ff ff       	jmp    107fa4 <alltraps>

00108ba8 <vector190>:
  108ba8:	6a 00                	push   $0x0
  108baa:	68 be 00 00 00       	push   $0xbe
  108baf:	e9 f0 f3 ff ff       	jmp    107fa4 <alltraps>

00108bb4 <vector191>:
  108bb4:	6a 00                	push   $0x0
  108bb6:	68 bf 00 00 00       	push   $0xbf
  108bbb:	e9 e4 f3 ff ff       	jmp    107fa4 <alltraps>

00108bc0 <vector192>:
  108bc0:	6a 00                	push   $0x0
  108bc2:	68 c0 00 00 00       	push   $0xc0
  108bc7:	e9 d8 f3 ff ff       	jmp    107fa4 <alltraps>

00108bcc <vector193>:
  108bcc:	6a 00                	push   $0x0
  108bce:	68 c1 00 00 00       	push   $0xc1
  108bd3:	e9 cc f3 ff ff       	jmp    107fa4 <alltraps>

00108bd8 <vector194>:
  108bd8:	6a 00                	push   $0x0
  108bda:	68 c2 00 00 00       	push   $0xc2
  108bdf:	e9 c0 f3 ff ff       	jmp    107fa4 <alltraps>

00108be4 <vector195>:
  108be4:	6a 00                	push   $0x0
  108be6:	68 c3 00 00 00       	push   $0xc3
  108beb:	e9 b4 f3 ff ff       	jmp    107fa4 <alltraps>

00108bf0 <vector196>:
  108bf0:	6a 00                	push   $0x0
  108bf2:	68 c4 00 00 00       	push   $0xc4
  108bf7:	e9 a8 f3 ff ff       	jmp    107fa4 <alltraps>

00108bfc <vector197>:
  108bfc:	6a 00                	push   $0x0
  108bfe:	68 c5 00 00 00       	push   $0xc5
  108c03:	e9 9c f3 ff ff       	jmp    107fa4 <alltraps>

00108c08 <vector198>:
  108c08:	6a 00                	push   $0x0
  108c0a:	68 c6 00 00 00       	push   $0xc6
  108c0f:	e9 90 f3 ff ff       	jmp    107fa4 <alltraps>

00108c14 <vector199>:
  108c14:	6a 00                	push   $0x0
  108c16:	68 c7 00 00 00       	push   $0xc7
  108c1b:	e9 84 f3 ff ff       	jmp    107fa4 <alltraps>

00108c20 <vector200>:
  108c20:	6a 00                	push   $0x0
  108c22:	68 c8 00 00 00       	push   $0xc8
  108c27:	e9 78 f3 ff ff       	jmp    107fa4 <alltraps>

00108c2c <vector201>:
  108c2c:	6a 00                	push   $0x0
  108c2e:	68 c9 00 00 00       	push   $0xc9
  108c33:	e9 6c f3 ff ff       	jmp    107fa4 <alltraps>

00108c38 <vector202>:
  108c38:	6a 00                	push   $0x0
  108c3a:	68 ca 00 00 00       	push   $0xca
  108c3f:	e9 60 f3 ff ff       	jmp    107fa4 <alltraps>

00108c44 <vector203>:
  108c44:	6a 00                	push   $0x0
  108c46:	68 cb 00 00 00       	push   $0xcb
  108c4b:	e9 54 f3 ff ff       	jmp    107fa4 <alltraps>

00108c50 <vector204>:
  108c50:	6a 00                	push   $0x0
  108c52:	68 cc 00 00 00       	push   $0xcc
  108c57:	e9 48 f3 ff ff       	jmp    107fa4 <alltraps>

00108c5c <vector205>:
  108c5c:	6a 00                	push   $0x0
  108c5e:	68 cd 00 00 00       	push   $0xcd
  108c63:	e9 3c f3 ff ff       	jmp    107fa4 <alltraps>

00108c68 <vector206>:
  108c68:	6a 00                	push   $0x0
  108c6a:	68 ce 00 00 00       	push   $0xce
  108c6f:	e9 30 f3 ff ff       	jmp    107fa4 <alltraps>

00108c74 <vector207>:
  108c74:	6a 00                	push   $0x0
  108c76:	68 cf 00 00 00       	push   $0xcf
  108c7b:	e9 24 f3 ff ff       	jmp    107fa4 <alltraps>

00108c80 <vector208>:
  108c80:	6a 00                	push   $0x0
  108c82:	68 d0 00 00 00       	push   $0xd0
  108c87:	e9 18 f3 ff ff       	jmp    107fa4 <alltraps>

00108c8c <vector209>:
  108c8c:	6a 00                	push   $0x0
  108c8e:	68 d1 00 00 00       	push   $0xd1
  108c93:	e9 0c f3 ff ff       	jmp    107fa4 <alltraps>

00108c98 <vector210>:
  108c98:	6a 00                	push   $0x0
  108c9a:	68 d2 00 00 00       	push   $0xd2
  108c9f:	e9 00 f3 ff ff       	jmp    107fa4 <alltraps>

00108ca4 <vector211>:
  108ca4:	6a 00                	push   $0x0
  108ca6:	68 d3 00 00 00       	push   $0xd3
  108cab:	e9 f4 f2 ff ff       	jmp    107fa4 <alltraps>

00108cb0 <vector212>:
  108cb0:	6a 00                	push   $0x0
  108cb2:	68 d4 00 00 00       	push   $0xd4
  108cb7:	e9 e8 f2 ff ff       	jmp    107fa4 <alltraps>

00108cbc <vector213>:
  108cbc:	6a 00                	push   $0x0
  108cbe:	68 d5 00 00 00       	push   $0xd5
  108cc3:	e9 dc f2 ff ff       	jmp    107fa4 <alltraps>

00108cc8 <vector214>:
  108cc8:	6a 00                	push   $0x0
  108cca:	68 d6 00 00 00       	push   $0xd6
  108ccf:	e9 d0 f2 ff ff       	jmp    107fa4 <alltraps>

00108cd4 <vector215>:
  108cd4:	6a 00                	push   $0x0
  108cd6:	68 d7 00 00 00       	push   $0xd7
  108cdb:	e9 c4 f2 ff ff       	jmp    107fa4 <alltraps>

00108ce0 <vector216>:
  108ce0:	6a 00                	push   $0x0
  108ce2:	68 d8 00 00 00       	push   $0xd8
  108ce7:	e9 b8 f2 ff ff       	jmp    107fa4 <alltraps>

00108cec <vector217>:
  108cec:	6a 00                	push   $0x0
  108cee:	68 d9 00 00 00       	push   $0xd9
  108cf3:	e9 ac f2 ff ff       	jmp    107fa4 <alltraps>

00108cf8 <vector218>:
  108cf8:	6a 00                	push   $0x0
  108cfa:	68 da 00 00 00       	push   $0xda
  108cff:	e9 a0 f2 ff ff       	jmp    107fa4 <alltraps>

00108d04 <vector219>:
  108d04:	6a 00                	push   $0x0
  108d06:	68 db 00 00 00       	push   $0xdb
  108d0b:	e9 94 f2 ff ff       	jmp    107fa4 <alltraps>

00108d10 <vector220>:
  108d10:	6a 00                	push   $0x0
  108d12:	68 dc 00 00 00       	push   $0xdc
  108d17:	e9 88 f2 ff ff       	jmp    107fa4 <alltraps>

00108d1c <vector221>:
  108d1c:	6a 00                	push   $0x0
  108d1e:	68 dd 00 00 00       	push   $0xdd
  108d23:	e9 7c f2 ff ff       	jmp    107fa4 <alltraps>

00108d28 <vector222>:
  108d28:	6a 00                	push   $0x0
  108d2a:	68 de 00 00 00       	push   $0xde
  108d2f:	e9 70 f2 ff ff       	jmp    107fa4 <alltraps>

00108d34 <vector223>:
  108d34:	6a 00                	push   $0x0
  108d36:	68 df 00 00 00       	push   $0xdf
  108d3b:	e9 64 f2 ff ff       	jmp    107fa4 <alltraps>

00108d40 <vector224>:
  108d40:	6a 00                	push   $0x0
  108d42:	68 e0 00 00 00       	push   $0xe0
  108d47:	e9 58 f2 ff ff       	jmp    107fa4 <alltraps>

00108d4c <vector225>:
  108d4c:	6a 00                	push   $0x0
  108d4e:	68 e1 00 00 00       	push   $0xe1
  108d53:	e9 4c f2 ff ff       	jmp    107fa4 <alltraps>

00108d58 <vector226>:
  108d58:	6a 00                	push   $0x0
  108d5a:	68 e2 00 00 00       	push   $0xe2
  108d5f:	e9 40 f2 ff ff       	jmp    107fa4 <alltraps>

00108d64 <vector227>:
  108d64:	6a 00                	push   $0x0
  108d66:	68 e3 00 00 00       	push   $0xe3
  108d6b:	e9 34 f2 ff ff       	jmp    107fa4 <alltraps>

00108d70 <vector228>:
  108d70:	6a 00                	push   $0x0
  108d72:	68 e4 00 00 00       	push   $0xe4
  108d77:	e9 28 f2 ff ff       	jmp    107fa4 <alltraps>

00108d7c <vector229>:
  108d7c:	6a 00                	push   $0x0
  108d7e:	68 e5 00 00 00       	push   $0xe5
  108d83:	e9 1c f2 ff ff       	jmp    107fa4 <alltraps>

00108d88 <vector230>:
  108d88:	6a 00                	push   $0x0
  108d8a:	68 e6 00 00 00       	push   $0xe6
  108d8f:	e9 10 f2 ff ff       	jmp    107fa4 <alltraps>

00108d94 <vector231>:
  108d94:	6a 00                	push   $0x0
  108d96:	68 e7 00 00 00       	push   $0xe7
  108d9b:	e9 04 f2 ff ff       	jmp    107fa4 <alltraps>

00108da0 <vector232>:
  108da0:	6a 00                	push   $0x0
  108da2:	68 e8 00 00 00       	push   $0xe8
  108da7:	e9 f8 f1 ff ff       	jmp    107fa4 <alltraps>

00108dac <vector233>:
  108dac:	6a 00                	push   $0x0
  108dae:	68 e9 00 00 00       	push   $0xe9
  108db3:	e9 ec f1 ff ff       	jmp    107fa4 <alltraps>

00108db8 <vector234>:
  108db8:	6a 00                	push   $0x0
  108dba:	68 ea 00 00 00       	push   $0xea
  108dbf:	e9 e0 f1 ff ff       	jmp    107fa4 <alltraps>

00108dc4 <vector235>:
  108dc4:	6a 00                	push   $0x0
  108dc6:	68 eb 00 00 00       	push   $0xeb
  108dcb:	e9 d4 f1 ff ff       	jmp    107fa4 <alltraps>

00108dd0 <vector236>:
  108dd0:	6a 00                	push   $0x0
  108dd2:	68 ec 00 00 00       	push   $0xec
  108dd7:	e9 c8 f1 ff ff       	jmp    107fa4 <alltraps>

00108ddc <vector237>:
  108ddc:	6a 00                	push   $0x0
  108dde:	68 ed 00 00 00       	push   $0xed
  108de3:	e9 bc f1 ff ff       	jmp    107fa4 <alltraps>

00108de8 <vector238>:
  108de8:	6a 00                	push   $0x0
  108dea:	68 ee 00 00 00       	push   $0xee
  108def:	e9 b0 f1 ff ff       	jmp    107fa4 <alltraps>

00108df4 <vector239>:
  108df4:	6a 00                	push   $0x0
  108df6:	68 ef 00 00 00       	push   $0xef
  108dfb:	e9 a4 f1 ff ff       	jmp    107fa4 <alltraps>

00108e00 <vector240>:
  108e00:	6a 00                	push   $0x0
  108e02:	68 f0 00 00 00       	push   $0xf0
  108e07:	e9 98 f1 ff ff       	jmp    107fa4 <alltraps>

00108e0c <vector241>:
  108e0c:	6a 00                	push   $0x0
  108e0e:	68 f1 00 00 00       	push   $0xf1
  108e13:	e9 8c f1 ff ff       	jmp    107fa4 <alltraps>

00108e18 <vector242>:
  108e18:	6a 00                	push   $0x0
  108e1a:	68 f2 00 00 00       	push   $0xf2
  108e1f:	e9 80 f1 ff ff       	jmp    107fa4 <alltraps>

00108e24 <vector243>:
  108e24:	6a 00                	push   $0x0
  108e26:	68 f3 00 00 00       	push   $0xf3
  108e2b:	e9 74 f1 ff ff       	jmp    107fa4 <alltraps>

00108e30 <vector244>:
  108e30:	6a 00                	push   $0x0
  108e32:	68 f4 00 00 00       	push   $0xf4
  108e37:	e9 68 f1 ff ff       	jmp    107fa4 <alltraps>

00108e3c <vector245>:
  108e3c:	6a 00                	push   $0x0
  108e3e:	68 f5 00 00 00       	push   $0xf5
  108e43:	e9 5c f1 ff ff       	jmp    107fa4 <alltraps>

00108e48 <vector246>:
  108e48:	6a 00                	push   $0x0
  108e4a:	68 f6 00 00 00       	push   $0xf6
  108e4f:	e9 50 f1 ff ff       	jmp    107fa4 <alltraps>

00108e54 <vector247>:
  108e54:	6a 00                	push   $0x0
  108e56:	68 f7 00 00 00       	push   $0xf7
  108e5b:	e9 44 f1 ff ff       	jmp    107fa4 <alltraps>

00108e60 <vector248>:
  108e60:	6a 00                	push   $0x0
  108e62:	68 f8 00 00 00       	push   $0xf8
  108e67:	e9 38 f1 ff ff       	jmp    107fa4 <alltraps>

00108e6c <vector249>:
  108e6c:	6a 00                	push   $0x0
  108e6e:	68 f9 00 00 00       	push   $0xf9
  108e73:	e9 2c f1 ff ff       	jmp    107fa4 <alltraps>

00108e78 <vector250>:
  108e78:	6a 00                	push   $0x0
  108e7a:	68 fa 00 00 00       	push   $0xfa
  108e7f:	e9 20 f1 ff ff       	jmp    107fa4 <alltraps>

00108e84 <vector251>:
  108e84:	6a 00                	push   $0x0
  108e86:	68 fb 00 00 00       	push   $0xfb
  108e8b:	e9 14 f1 ff ff       	jmp    107fa4 <alltraps>

00108e90 <vector252>:
  108e90:	6a 00                	push   $0x0
  108e92:	68 fc 00 00 00       	push   $0xfc
  108e97:	e9 08 f1 ff ff       	jmp    107fa4 <alltraps>

00108e9c <vector253>:
  108e9c:	6a 00                	push   $0x0
  108e9e:	68 fd 00 00 00       	push   $0xfd
  108ea3:	e9 fc f0 ff ff       	jmp    107fa4 <alltraps>

00108ea8 <vector254>:
  108ea8:	6a 00                	push   $0x0
  108eaa:	68 fe 00 00 00       	push   $0xfe
  108eaf:	e9 f0 f0 ff ff       	jmp    107fa4 <alltraps>

00108eb4 <vector255>:
  108eb4:	6a 00                	push   $0x0
  108eb6:	68 ff 00 00 00       	push   $0xff
  108ebb:	e9 e4 f0 ff ff       	jmp    107fa4 <alltraps>

00108ec0 <pci_conf1_set_addr>:
pci_conf1_set_addr(uint32_t bus,
		   uint32_t dev,
		   uint32_t func,
		   uint32_t offset)
{
  108ec0:	55                   	push   %ebp
  108ec1:	89 e5                	mov    %esp,%ebp
  108ec3:	83 ec 28             	sub    $0x28,%esp
    assert(bus < 256);
  108ec6:	81 7d 08 ff 00 00 00 	cmpl   $0xff,0x8(%ebp)
  108ecd:	76 24                	jbe    108ef3 <pci_conf1_set_addr+0x33>
  108ecf:	c7 44 24 0c 33 a8 11 	movl   $0x11a833,0xc(%esp)
  108ed6:	00 
  108ed7:	c7 44 24 08 33 00 00 	movl   $0x33,0x8(%esp)
  108ede:	00 
  108edf:	c7 44 24 04 3d a8 11 	movl   $0x11a83d,0x4(%esp)
  108ee6:	00 
  108ee7:	c7 04 24 20 a8 11 00 	movl   $0x11a820,(%esp)
  108eee:	e8 1d 0a 00 00       	call   109910 <__assert>
    assert(dev < 32);
  108ef3:	83 7d 0c 1f          	cmpl   $0x1f,0xc(%ebp)
  108ef7:	76 24                	jbe    108f1d <pci_conf1_set_addr+0x5d>
  108ef9:	c7 44 24 0c 43 a8 11 	movl   $0x11a843,0xc(%esp)
  108f00:	00 
  108f01:	c7 44 24 08 34 00 00 	movl   $0x34,0x8(%esp)
  108f08:	00 
  108f09:	c7 44 24 04 3d a8 11 	movl   $0x11a83d,0x4(%esp)
  108f10:	00 
  108f11:	c7 04 24 20 a8 11 00 	movl   $0x11a820,(%esp)
  108f18:	e8 f3 09 00 00       	call   109910 <__assert>
    assert(func < 8);
  108f1d:	83 7d 10 07          	cmpl   $0x7,0x10(%ebp)
  108f21:	76 24                	jbe    108f47 <pci_conf1_set_addr+0x87>
  108f23:	c7 44 24 0c 4c a8 11 	movl   $0x11a84c,0xc(%esp)
  108f2a:	00 
  108f2b:	c7 44 24 08 35 00 00 	movl   $0x35,0x8(%esp)
  108f32:	00 
  108f33:	c7 44 24 04 3d a8 11 	movl   $0x11a83d,0x4(%esp)
  108f3a:	00 
  108f3b:	c7 04 24 20 a8 11 00 	movl   $0x11a820,(%esp)
  108f42:	e8 c9 09 00 00       	call   109910 <__assert>
    assert(offset < 256);
  108f47:	81 7d 14 ff 00 00 00 	cmpl   $0xff,0x14(%ebp)
  108f4e:	76 24                	jbe    108f74 <pci_conf1_set_addr+0xb4>
  108f50:	c7 44 24 0c 55 a8 11 	movl   $0x11a855,0xc(%esp)
  108f57:	00 
  108f58:	c7 44 24 08 36 00 00 	movl   $0x36,0x8(%esp)
  108f5f:	00 
  108f60:	c7 44 24 04 3d a8 11 	movl   $0x11a83d,0x4(%esp)
  108f67:	00 
  108f68:	c7 04 24 20 a8 11 00 	movl   $0x11a820,(%esp)
  108f6f:	e8 9c 09 00 00       	call   109910 <__assert>
    assert((offset & 0x3) == 0);
  108f74:	8b 45 14             	mov    0x14(%ebp),%eax
  108f77:	83 e0 03             	and    $0x3,%eax
  108f7a:	85 c0                	test   %eax,%eax
  108f7c:	74 24                	je     108fa2 <pci_conf1_set_addr+0xe2>
  108f7e:	c7 44 24 0c 62 a8 11 	movl   $0x11a862,0xc(%esp)
  108f85:	00 
  108f86:	c7 44 24 08 37 00 00 	movl   $0x37,0x8(%esp)
  108f8d:	00 
  108f8e:	c7 44 24 04 3d a8 11 	movl   $0x11a83d,0x4(%esp)
  108f95:	00 
  108f96:	c7 04 24 20 a8 11 00 	movl   $0x11a820,(%esp)
  108f9d:	e8 6e 09 00 00       	call   109910 <__assert>

    uint32_t v = (1 << 31) |		// config-space
		 (bus << 16) | (dev << 11) | (func << 8) | (offset);
  108fa2:	8b 45 08             	mov    0x8(%ebp),%eax
  108fa5:	89 c2                	mov    %eax,%edx
  108fa7:	c1 e2 10             	shl    $0x10,%edx
  108faa:	8b 45 0c             	mov    0xc(%ebp),%eax
  108fad:	c1 e0 0b             	shl    $0xb,%eax
  108fb0:	09 c2                	or     %eax,%edx
  108fb2:	8b 45 10             	mov    0x10(%ebp),%eax
  108fb5:	c1 e0 08             	shl    $0x8,%eax
  108fb8:	09 d0                	or     %edx,%eax
  108fba:	0b 45 14             	or     0x14(%ebp),%eax
  108fbd:	0d 00 00 00 80       	or     $0x80000000,%eax
  108fc2:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
    outl(pci_conf1_addr_ioport, v);
  108fc5:	a1 c8 ca 11 00       	mov    0x11cac8,%eax
  108fca:	0f b7 d0             	movzwl %ax,%edx
  108fcd:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  108fd0:	89 44 24 04          	mov    %eax,0x4(%esp)
  108fd4:	89 14 24             	mov    %edx,(%esp)
  108fd7:	e8 04 00 00 00       	call   108fe0 <outl>
}
  108fdc:	c9                   	leave  
  108fdd:	c3                   	ret    
  108fde:	89 f6                	mov    %esi,%esi

00108fe0 <outl>:
}

static inline void
outl(ushort port, uint data)
{
  108fe0:	55                   	push   %ebp
  108fe1:	89 e5                	mov    %esp,%ebp
  108fe3:	83 ec 04             	sub    $0x4,%esp
  108fe6:	8b 45 08             	mov    0x8(%ebp),%eax
  108fe9:	66 89 45 fc          	mov    %ax,0xfffffffc(%ebp)
    asm volatile("out %0,%1" : : "a" (data), "d" (port));
  108fed:	8b 45 0c             	mov    0xc(%ebp),%eax
  108ff0:	0f b7 55 fc          	movzwl 0xfffffffc(%ebp),%edx
  108ff4:	ef                   	out    %eax,(%dx)
}
  108ff5:	c9                   	leave  
  108ff6:	c3                   	ret    
  108ff7:	89 f6                	mov    %esi,%esi
  108ff9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00109000 <pci_conf_read>:

static uint32_t
pci_conf_read(struct pci_func *f, uint32_t off)
{
  109000:	55                   	push   %ebp
  109001:	89 e5                	mov    %esp,%ebp
  109003:	53                   	push   %ebx
  109004:	83 ec 14             	sub    $0x14,%esp
    pci_conf1_set_addr(f->bus->busno, f->dev, f->func, off);
  109007:	8b 45 08             	mov    0x8(%ebp),%eax
  10900a:	8b 48 08             	mov    0x8(%eax),%ecx
  10900d:	8b 45 08             	mov    0x8(%ebp),%eax
  109010:	8b 58 04             	mov    0x4(%eax),%ebx
  109013:	8b 45 08             	mov    0x8(%ebp),%eax
  109016:	8b 00                	mov    (%eax),%eax
  109018:	8b 50 04             	mov    0x4(%eax),%edx
  10901b:	8b 45 0c             	mov    0xc(%ebp),%eax
  10901e:	89 44 24 0c          	mov    %eax,0xc(%esp)
  109022:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  109026:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  10902a:	89 14 24             	mov    %edx,(%esp)
  10902d:	e8 8e fe ff ff       	call   108ec0 <pci_conf1_set_addr>
    return inl(pci_conf1_data_ioport);
  109032:	a1 cc ca 11 00       	mov    0x11cacc,%eax
  109037:	0f b7 c0             	movzwl %ax,%eax
  10903a:	89 04 24             	mov    %eax,(%esp)
  10903d:	e8 0e 00 00 00       	call   109050 <inl>
}
  109042:	83 c4 14             	add    $0x14,%esp
  109045:	5b                   	pop    %ebx
  109046:	5d                   	pop    %ebp
  109047:	c3                   	ret    
  109048:	90                   	nop    
  109049:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

00109050 <inl>:
}

static inline uint
inl(ushort port)
{
  109050:	55                   	push   %ebp
  109051:	89 e5                	mov    %esp,%ebp
  109053:	83 ec 14             	sub    $0x14,%esp
  109056:	8b 45 08             	mov    0x8(%ebp),%eax
  109059:	66 89 45 ec          	mov    %ax,0xffffffec(%ebp)
    uint data;

    asm volatile("in %1,%0" : "=a" (data) : "d" (port));
  10905d:	0f b7 55 ec          	movzwl 0xffffffec(%ebp),%edx
  109061:	ed                   	in     (%dx),%eax
  109062:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
    return data;
  109065:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
}
  109068:	c9                   	leave  
  109069:	c3                   	ret    
  10906a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

00109070 <pci_conf_write>:

static void
pci_conf_write(struct pci_func *f, uint32_t off, uint32_t v)
{
  109070:	55                   	push   %ebp
  109071:	89 e5                	mov    %esp,%ebp
  109073:	53                   	push   %ebx
  109074:	83 ec 14             	sub    $0x14,%esp
    pci_conf1_set_addr(f->bus->busno, f->dev, f->func, off);
  109077:	8b 45 08             	mov    0x8(%ebp),%eax
  10907a:	8b 48 08             	mov    0x8(%eax),%ecx
  10907d:	8b 45 08             	mov    0x8(%ebp),%eax
  109080:	8b 58 04             	mov    0x4(%eax),%ebx
  109083:	8b 45 08             	mov    0x8(%ebp),%eax
  109086:	8b 00                	mov    (%eax),%eax
  109088:	8b 50 04             	mov    0x4(%eax),%edx
  10908b:	8b 45 0c             	mov    0xc(%ebp),%eax
  10908e:	89 44 24 0c          	mov    %eax,0xc(%esp)
  109092:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  109096:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  10909a:	89 14 24             	mov    %edx,(%esp)
  10909d:	e8 1e fe ff ff       	call   108ec0 <pci_conf1_set_addr>
    outl(pci_conf1_data_ioport, v);
  1090a2:	a1 cc ca 11 00       	mov    0x11cacc,%eax
  1090a7:	0f b7 d0             	movzwl %ax,%edx
  1090aa:	8b 45 10             	mov    0x10(%ebp),%eax
  1090ad:	89 44 24 04          	mov    %eax,0x4(%esp)
  1090b1:	89 14 24             	mov    %edx,(%esp)
  1090b4:	e8 27 ff ff ff       	call   108fe0 <outl>
}
  1090b9:	83 c4 14             	add    $0x14,%esp
  1090bc:	5b                   	pop    %ebx
  1090bd:	5d                   	pop    %ebp
  1090be:	c3                   	ret    
  1090bf:	90                   	nop    

001090c0 <pci_attach_match>:

static int __attribute__((warn_unused_result))
pci_attach_match(uint32_t key1, uint32_t key2,
		 struct pci_driver *list, struct pci_func *pcif)
{
  1090c0:	55                   	push   %ebp
  1090c1:	89 e5                	mov    %esp,%ebp
  1090c3:	83 ec 28             	sub    $0x28,%esp
    uint32_t i;

    for (i = 0; list[i].attachfn; i++) {
  1090c6:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)
  1090cd:	e9 af 00 00 00       	jmp    109181 <pci_attach_match+0xc1>
	if (list[i].key1 == key1 )
  1090d2:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  1090d5:	89 d0                	mov    %edx,%eax
  1090d7:	01 c0                	add    %eax,%eax
  1090d9:	01 d0                	add    %edx,%eax
  1090db:	c1 e0 02             	shl    $0x2,%eax
  1090de:	03 45 10             	add    0x10(%ebp),%eax
  1090e1:	8b 00                	mov    (%eax),%eax
  1090e3:	3b 45 08             	cmp    0x8(%ebp),%eax
  1090e6:	0f 85 91 00 00 00    	jne    10917d <pci_attach_match+0xbd>
        if ((list[i].key2 == key2) || (list[i].key2 == 0xffff)) {
  1090ec:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  1090ef:	89 d0                	mov    %edx,%eax
  1090f1:	01 c0                	add    %eax,%eax
  1090f3:	01 d0                	add    %edx,%eax
  1090f5:	c1 e0 02             	shl    $0x2,%eax
  1090f8:	03 45 10             	add    0x10(%ebp),%eax
  1090fb:	8b 40 04             	mov    0x4(%eax),%eax
  1090fe:	3b 45 0c             	cmp    0xc(%ebp),%eax
  109101:	74 19                	je     10911c <pci_attach_match+0x5c>
  109103:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  109106:	89 d0                	mov    %edx,%eax
  109108:	01 c0                	add    %eax,%eax
  10910a:	01 d0                	add    %edx,%eax
  10910c:	c1 e0 02             	shl    $0x2,%eax
  10910f:	03 45 10             	add    0x10(%ebp),%eax
  109112:	8b 40 04             	mov    0x4(%eax),%eax
  109115:	3d ff ff 00 00       	cmp    $0xffff,%eax
  10911a:	75 61                	jne    10917d <pci_attach_match+0xbd>
	        int r = list[i].attachfn(pcif);
  10911c:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  10911f:	89 d0                	mov    %edx,%eax
  109121:	01 c0                	add    %eax,%eax
  109123:	01 d0                	add    %edx,%eax
  109125:	c1 e0 02             	shl    $0x2,%eax
  109128:	03 45 10             	add    0x10(%ebp),%eax
  10912b:	8b 50 08             	mov    0x8(%eax),%edx
  10912e:	8b 45 14             	mov    0x14(%ebp),%eax
  109131:	89 04 24             	mov    %eax,(%esp)
  109134:	ff d2                	call   *%edx
  109136:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
	        if (r > 0)
  109139:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  10913d:	7e 08                	jle    109147 <pci_attach_match+0x87>
		        return r;
  10913f:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  109142:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  109145:	eb 5b                	jmp    1091a2 <pci_attach_match+0xe2>
	        if (r < 0)
  109147:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  10914b:	79 30                	jns    10917d <pci_attach_match+0xbd>
		///cprintf("pci_attach_match: attaching %x.%x (%p): %s\n",
		//	key1, key2, list[i].attachfn, e2s(r));
		        cprintf("pci_attach_match: attaching %x.%x (%p): SOME ERROR\n",
  10914d:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  109150:	89 d0                	mov    %edx,%eax
  109152:	01 c0                	add    %eax,%eax
  109154:	01 d0                	add    %edx,%eax
  109156:	c1 e0 02             	shl    $0x2,%eax
  109159:	03 45 10             	add    0x10(%ebp),%eax
  10915c:	8b 40 08             	mov    0x8(%eax),%eax
  10915f:	89 44 24 0c          	mov    %eax,0xc(%esp)
  109163:	8b 45 0c             	mov    0xc(%ebp),%eax
  109166:	89 44 24 08          	mov    %eax,0x8(%esp)
  10916a:	8b 45 08             	mov    0x8(%ebp),%eax
  10916d:	89 44 24 04          	mov    %eax,0x4(%esp)
  109171:	c7 04 24 78 a8 11 00 	movl   $0x11a878,(%esp)
  109178:	e8 93 75 ff ff       	call   100710 <cprintf>
  10917d:	83 45 f8 01          	addl   $0x1,0xfffffff8(%ebp)
  109181:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  109184:	89 d0                	mov    %edx,%eax
  109186:	01 c0                	add    %eax,%eax
  109188:	01 d0                	add    %edx,%eax
  10918a:	c1 e0 02             	shl    $0x2,%eax
  10918d:	03 45 10             	add    0x10(%ebp),%eax
  109190:	8b 40 08             	mov    0x8(%eax),%eax
  109193:	85 c0                	test   %eax,%eax
  109195:	0f 85 37 ff ff ff    	jne    1090d2 <pci_attach_match+0x12>
			        key1, key2, list[i].attachfn);
	    }
    }

    return 0;
  10919b:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  1091a2:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  1091a5:	c9                   	leave  
  1091a6:	c3                   	ret    
  1091a7:	89 f6                	mov    %esi,%esi
  1091a9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

001091b0 <pci_attach>:

static int
pci_attach(struct pci_func *f)
{
  1091b0:	55                   	push   %ebp
  1091b1:	89 e5                	mov    %esp,%ebp
  1091b3:	83 ec 18             	sub    $0x18,%esp
    return
  1091b6:	8b 45 08             	mov    0x8(%ebp),%eax
  1091b9:	8b 40 10             	mov    0x10(%eax),%eax
  1091bc:	c1 e8 10             	shr    $0x10,%eax
  1091bf:	0f b6 c8             	movzbl %al,%ecx
  1091c2:	8b 45 08             	mov    0x8(%ebp),%eax
  1091c5:	8b 40 10             	mov    0x10(%eax),%eax
  1091c8:	c1 e8 18             	shr    $0x18,%eax
  1091cb:	0f b6 d0             	movzbl %al,%edx
  1091ce:	8b 45 08             	mov    0x8(%ebp),%eax
  1091d1:	89 44 24 0c          	mov    %eax,0xc(%esp)
  1091d5:	c7 44 24 08 e0 ca 11 	movl   $0x11cae0,0x8(%esp)
  1091dc:	00 
  1091dd:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1091e1:	89 14 24             	mov    %edx,(%esp)
  1091e4:	e8 d7 fe ff ff       	call   1090c0 <pci_attach_match>
  1091e9:	85 c0                	test   %eax,%eax
  1091eb:	75 34                	jne    109221 <pci_attach+0x71>
  1091ed:	8b 45 08             	mov    0x8(%ebp),%eax
  1091f0:	8b 40 0c             	mov    0xc(%eax),%eax
  1091f3:	c1 e8 10             	shr    $0x10,%eax
  1091f6:	0f b7 c8             	movzwl %ax,%ecx
  1091f9:	8b 45 08             	mov    0x8(%ebp),%eax
  1091fc:	8b 40 0c             	mov    0xc(%eax),%eax
  1091ff:	0f b7 d0             	movzwl %ax,%edx
  109202:	8b 45 08             	mov    0x8(%ebp),%eax
  109205:	89 44 24 0c          	mov    %eax,0xc(%esp)
  109209:	c7 44 24 08 1c cb 11 	movl   $0x11cb1c,0x8(%esp)
  109210:	00 
  109211:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  109215:	89 14 24             	mov    %edx,(%esp)
  109218:	e8 a3 fe ff ff       	call   1090c0 <pci_attach_match>
  10921d:	85 c0                	test   %eax,%eax
  10921f:	74 09                	je     10922a <pci_attach+0x7a>
  109221:	c7 45 fc 01 00 00 00 	movl   $0x1,0xfffffffc(%ebp)
  109228:	eb 07                	jmp    109231 <pci_attach+0x81>
  10922a:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
  109231:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
	pci_attach_match(PCI_CLASS(f->dev_class), PCI_SUBCLASS(f->dev_class),
			 &pci_attach_class[0], f) ||
	pci_attach_match(PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
			 &pci_attach_vendor[0], f);
}
  109234:	c9                   	leave  
  109235:	c3                   	ret    
  109236:	8d 76 00             	lea    0x0(%esi),%esi
  109239:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00109240 <pci_scan_bus>:

static int 
pci_scan_bus(struct pci_bus *bus)
{
  109240:	55                   	push   %ebp
  109241:	89 e5                	mov    %esp,%ebp
  109243:	57                   	push   %edi
  109244:	56                   	push   %esi
  109245:	53                   	push   %ebx
  109246:	81 ec 2c 01 00 00    	sub    $0x12c,%esp
    int totaldev = 0;
  10924c:	c7 45 e8 00 00 00 00 	movl   $0x0,0xffffffe8(%ebp)
    struct pci_func df;
    memset(&df, 0, sizeof(df));
  109253:	c7 44 24 08 48 00 00 	movl   $0x48,0x8(%esp)
  10925a:	00 
  10925b:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  109262:	00 
  109263:	8d 45 a0             	lea    0xffffffa0(%ebp),%eax
  109266:	89 04 24             	mov    %eax,(%esp)
  109269:	e8 92 cc ff ff       	call   105f00 <memset>
    df.bus = bus;
  10926e:	8b 45 08             	mov    0x8(%ebp),%eax
  109271:	89 45 a0             	mov    %eax,0xffffffa0(%ebp)

    for (df.dev = 0; df.dev < 32; df.dev++) {
  109274:	c7 45 a4 00 00 00 00 	movl   $0x0,0xffffffa4(%ebp)
  10927b:	e9 f1 01 00 00       	jmp    109471 <pci_scan_bus+0x231>
	uint32_t bhlc = pci_conf_read(&df, PCI_BHLC_REG);
  109280:	c7 44 24 04 0c 00 00 	movl   $0xc,0x4(%esp)
  109287:	00 
  109288:	8d 45 a0             	lea    0xffffffa0(%ebp),%eax
  10928b:	89 04 24             	mov    %eax,(%esp)
  10928e:	e8 6d fd ff ff       	call   109000 <pci_conf_read>
  109293:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
	if (PCI_HDRTYPE_TYPE(bhlc) > 1)	    // Unsupported or no device
  109296:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  109299:	c1 e8 10             	shr    $0x10,%eax
  10929c:	83 e0 7f             	and    $0x7f,%eax
  10929f:	83 f8 01             	cmp    $0x1,%eax
  1092a2:	0f 87 c0 01 00 00    	ja     109468 <pci_scan_bus+0x228>
	    continue;

	totaldev++;
  1092a8:	83 45 e8 01          	addl   $0x1,0xffffffe8(%ebp)

	struct pci_func f = df;
  1092ac:	8d 8d 58 ff ff ff    	lea    0xffffff58(%ebp),%ecx
  1092b2:	8d 55 a0             	lea    0xffffffa0(%ebp),%edx
  1092b5:	b8 48 00 00 00       	mov    $0x48,%eax
  1092ba:	89 44 24 08          	mov    %eax,0x8(%esp)
  1092be:	89 54 24 04          	mov    %edx,0x4(%esp)
  1092c2:	89 0c 24             	mov    %ecx,(%esp)
  1092c5:	e8 f6 cb ff ff       	call   105ec0 <memcpy>
	for (f.func = 0; f.func < (PCI_HDRTYPE_MULTIFN(bhlc) ? 8 : 1);
  1092ca:	c7 85 60 ff ff ff 00 	movl   $0x0,0xffffff60(%ebp)
  1092d1:	00 00 00 
  1092d4:	e9 4f 01 00 00       	jmp    109428 <pci_scan_bus+0x1e8>
			 f.func++) {
	    struct pci_func af = f;
  1092d9:	8d 8d 10 ff ff ff    	lea    0xffffff10(%ebp),%ecx
  1092df:	8d 95 58 ff ff ff    	lea    0xffffff58(%ebp),%edx
  1092e5:	b8 48 00 00 00       	mov    $0x48,%eax
  1092ea:	89 44 24 08          	mov    %eax,0x8(%esp)
  1092ee:	89 54 24 04          	mov    %edx,0x4(%esp)
  1092f2:	89 0c 24             	mov    %ecx,(%esp)
  1092f5:	e8 c6 cb ff ff       	call   105ec0 <memcpy>

	    af.dev_id = pci_conf_read(&f, PCI_ID_REG);
  1092fa:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  109301:	00 
  109302:	8d 85 58 ff ff ff    	lea    0xffffff58(%ebp),%eax
  109308:	89 04 24             	mov    %eax,(%esp)
  10930b:	e8 f0 fc ff ff       	call   109000 <pci_conf_read>
  109310:	89 85 1c ff ff ff    	mov    %eax,0xffffff1c(%ebp)
	    if (PCI_VENDOR(af.dev_id) == 0xffff)
  109316:	8b 85 1c ff ff ff    	mov    0xffffff1c(%ebp),%eax
  10931c:	25 ff ff 00 00       	and    $0xffff,%eax
  109321:	3d ff ff 00 00       	cmp    $0xffff,%eax
  109326:	0f 84 ed 00 00 00    	je     109419 <pci_scan_bus+0x1d9>
		continue;

	    uint32_t intr = pci_conf_read(&af, PCI_INTERRUPT_REG);
  10932c:	c7 44 24 04 3c 00 00 	movl   $0x3c,0x4(%esp)
  109333:	00 
  109334:	8d 85 10 ff ff ff    	lea    0xffffff10(%ebp),%eax
  10933a:	89 04 24             	mov    %eax,(%esp)
  10933d:	e8 be fc ff ff       	call   109000 <pci_conf_read>
  109342:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
	    af.irq_line = PCI_INTERRUPT_LINE(intr);
  109345:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  109348:	88 85 54 ff ff ff    	mov    %al,0xffffff54(%ebp)

	    af.dev_class = pci_conf_read(&af, PCI_CLASS_REG);
  10934e:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
  109355:	00 
  109356:	8d 85 10 ff ff ff    	lea    0xffffff10(%ebp),%eax
  10935c:	89 04 24             	mov    %eax,(%esp)
  10935f:	e8 9c fc ff ff       	call   109000 <pci_conf_read>
  109364:	89 85 20 ff ff ff    	mov    %eax,0xffffff20(%ebp)
	    if (pci_show_devs)
  10936a:	a1 c0 ca 11 00       	mov    0x11cac0,%eax
  10936f:	85 c0                	test   %eax,%eax
  109371:	0f 84 94 00 00 00    	je     10940b <pci_scan_bus+0x1cb>
		cprintf("PCI: %02x:%02x.%d: %04x:%04x: class %x.%x irq %d\n",
  109377:	0f b6 85 54 ff ff ff 	movzbl 0xffffff54(%ebp),%eax
  10937e:	0f b6 f8             	movzbl %al,%edi
  109381:	8b 85 20 ff ff ff    	mov    0xffffff20(%ebp),%eax
  109387:	c1 e8 10             	shr    $0x10,%eax
  10938a:	25 ff 00 00 00       	and    $0xff,%eax
  10938f:	89 85 f4 fe ff ff    	mov    %eax,0xfffffef4(%ebp)
  109395:	8b 85 20 ff ff ff    	mov    0xffffff20(%ebp),%eax
  10939b:	c1 e8 18             	shr    $0x18,%eax
  10939e:	25 ff 00 00 00       	and    $0xff,%eax
  1093a3:	89 85 f8 fe ff ff    	mov    %eax,0xfffffef8(%ebp)
  1093a9:	8b 85 1c ff ff ff    	mov    0xffffff1c(%ebp),%eax
  1093af:	c1 e8 10             	shr    $0x10,%eax
  1093b2:	0f b7 d0             	movzwl %ax,%edx
  1093b5:	8b 85 1c ff ff ff    	mov    0xffffff1c(%ebp),%eax
  1093bb:	0f b7 c8             	movzwl %ax,%ecx
  1093be:	8b 9d 18 ff ff ff    	mov    0xffffff18(%ebp),%ebx
  1093c4:	8b b5 14 ff ff ff    	mov    0xffffff14(%ebp),%esi
  1093ca:	8b 85 10 ff ff ff    	mov    0xffffff10(%ebp),%eax
  1093d0:	8b 40 04             	mov    0x4(%eax),%eax
  1093d3:	89 7c 24 20          	mov    %edi,0x20(%esp)
  1093d7:	8b bd f4 fe ff ff    	mov    0xfffffef4(%ebp),%edi
  1093dd:	89 7c 24 1c          	mov    %edi,0x1c(%esp)
  1093e1:	8b bd f8 fe ff ff    	mov    0xfffffef8(%ebp),%edi
  1093e7:	89 7c 24 18          	mov    %edi,0x18(%esp)
  1093eb:	89 54 24 14          	mov    %edx,0x14(%esp)
  1093ef:	89 4c 24 10          	mov    %ecx,0x10(%esp)
  1093f3:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
  1093f7:	89 74 24 08          	mov    %esi,0x8(%esp)
  1093fb:	89 44 24 04          	mov    %eax,0x4(%esp)
  1093ff:	c7 04 24 ac a8 11 00 	movl   $0x11a8ac,(%esp)
  109406:	e8 05 73 ff ff       	call   100710 <cprintf>
			af.bus->busno, af.dev, af.func,
			PCI_VENDOR(af.dev_id), PCI_PRODUCT(af.dev_id),
			PCI_CLASS(af.dev_class), PCI_SUBCLASS(af.dev_class),
			af.irq_line);

	    pci_attach(&af);
  10940b:	8d 85 10 ff ff ff    	lea    0xffffff10(%ebp),%eax
  109411:	89 04 24             	mov    %eax,(%esp)
  109414:	e8 97 fd ff ff       	call   1091b0 <pci_attach>
  109419:	8b 85 60 ff ff ff    	mov    0xffffff60(%ebp),%eax
  10941f:	83 c0 01             	add    $0x1,%eax
  109422:	89 85 60 ff ff ff    	mov    %eax,0xffffff60(%ebp)
  109428:	8b 85 60 ff ff ff    	mov    0xffffff60(%ebp),%eax
  10942e:	89 85 fc fe ff ff    	mov    %eax,0xfffffefc(%ebp)
  109434:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  109437:	25 00 00 80 00       	and    $0x800000,%eax
  10943c:	85 c0                	test   %eax,%eax
  10943e:	74 0c                	je     10944c <pci_scan_bus+0x20c>
  109440:	c7 85 00 ff ff ff 08 	movl   $0x8,0xffffff00(%ebp)
  109447:	00 00 00 
  10944a:	eb 0a                	jmp    109456 <pci_scan_bus+0x216>
  10944c:	c7 85 00 ff ff ff 01 	movl   $0x1,0xffffff00(%ebp)
  109453:	00 00 00 
  109456:	8b bd 00 ff ff ff    	mov    0xffffff00(%ebp),%edi
  10945c:	39 bd fc fe ff ff    	cmp    %edi,0xfffffefc(%ebp)
  109462:	0f 82 71 fe ff ff    	jb     1092d9 <pci_scan_bus+0x99>
  109468:	8b 45 a4             	mov    0xffffffa4(%ebp),%eax
  10946b:	83 c0 01             	add    $0x1,%eax
  10946e:	89 45 a4             	mov    %eax,0xffffffa4(%ebp)
  109471:	8b 45 a4             	mov    0xffffffa4(%ebp),%eax
  109474:	83 f8 1f             	cmp    $0x1f,%eax
  109477:	0f 86 03 fe ff ff    	jbe    109280 <pci_scan_bus+0x40>
	}
    }

    return totaldev;
  10947d:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
}
  109480:	81 c4 2c 01 00 00    	add    $0x12c,%esp
  109486:	5b                   	pop    %ebx
  109487:	5e                   	pop    %esi
  109488:	5f                   	pop    %edi
  109489:	5d                   	pop    %ebp
  10948a:	c3                   	ret    
  10948b:	90                   	nop    
  10948c:	8d 74 26 00          	lea    0x0(%esi),%esi

00109490 <pci_net_ether_attach>:

static int
pci_net_ether_attach(struct pci_func *pcif)
{	
  109490:	55                   	push   %ebp
  109491:	89 e5                	mov    %esp,%ebp
  109493:	56                   	push   %esi
  109494:	53                   	push   %ebx
  109495:	83 ec 20             	sub    $0x20,%esp
    cprintf("PCI: %02x:%02x.%d: Network (ethernet) %04x:%04x\n",
  109498:	8b 45 08             	mov    0x8(%ebp),%eax
  10949b:	8b 40 0c             	mov    0xc(%eax),%eax
  10949e:	c1 e8 10             	shr    $0x10,%eax
  1094a1:	0f b7 f0             	movzwl %ax,%esi
  1094a4:	8b 45 08             	mov    0x8(%ebp),%eax
  1094a7:	8b 40 0c             	mov    0xc(%eax),%eax
  1094aa:	0f b7 d0             	movzwl %ax,%edx
  1094ad:	8b 45 08             	mov    0x8(%ebp),%eax
  1094b0:	8b 48 08             	mov    0x8(%eax),%ecx
  1094b3:	8b 45 08             	mov    0x8(%ebp),%eax
  1094b6:	8b 58 04             	mov    0x4(%eax),%ebx
  1094b9:	8b 45 08             	mov    0x8(%ebp),%eax
  1094bc:	8b 00                	mov    (%eax),%eax
  1094be:	8b 40 04             	mov    0x4(%eax),%eax
  1094c1:	89 74 24 14          	mov    %esi,0x14(%esp)
  1094c5:	89 54 24 10          	mov    %edx,0x10(%esp)
  1094c9:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
  1094cd:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  1094d1:	89 44 24 04          	mov    %eax,0x4(%esp)
  1094d5:	c7 04 24 e0 a8 11 00 	movl   $0x11a8e0,(%esp)
  1094dc:	e8 2f 72 ff ff       	call   100710 <cprintf>
		pcif->bus->busno, pcif->dev, pcif->func,
        PCI_VENDOR(pcif->dev_id), PCI_PRODUCT(pcif->dev_id));
    return 0;
  1094e1:	b8 00 00 00 00       	mov    $0x0,%eax
}
  1094e6:	83 c4 20             	add    $0x20,%esp
  1094e9:	5b                   	pop    %ebx
  1094ea:	5e                   	pop    %esi
  1094eb:	5d                   	pop    %ebp
  1094ec:	c3                   	ret    
  1094ed:	8d 76 00             	lea    0x0(%esi),%esi

001094f0 <pci_bridge_attach>:

static int
pci_bridge_attach(struct pci_func *pcif)
{
  1094f0:	55                   	push   %ebp
  1094f1:	89 e5                	mov    %esp,%ebp
  1094f3:	56                   	push   %esi
  1094f4:	53                   	push   %ebx
  1094f5:	83 ec 20             	sub    $0x20,%esp
    cprintf("PCI: %02x:%02x.%d: Bridge %04x:%04x\n",
  1094f8:	8b 45 08             	mov    0x8(%ebp),%eax
  1094fb:	8b 40 0c             	mov    0xc(%eax),%eax
  1094fe:	c1 e8 10             	shr    $0x10,%eax
  109501:	0f b7 f0             	movzwl %ax,%esi
  109504:	8b 45 08             	mov    0x8(%ebp),%eax
  109507:	8b 40 0c             	mov    0xc(%eax),%eax
  10950a:	0f b7 d0             	movzwl %ax,%edx
  10950d:	8b 45 08             	mov    0x8(%ebp),%eax
  109510:	8b 48 08             	mov    0x8(%eax),%ecx
  109513:	8b 45 08             	mov    0x8(%ebp),%eax
  109516:	8b 58 04             	mov    0x4(%eax),%ebx
  109519:	8b 45 08             	mov    0x8(%ebp),%eax
  10951c:	8b 00                	mov    (%eax),%eax
  10951e:	8b 40 04             	mov    0x4(%eax),%eax
  109521:	89 74 24 14          	mov    %esi,0x14(%esp)
  109525:	89 54 24 10          	mov    %edx,0x10(%esp)
  109529:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
  10952d:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  109531:	89 44 24 04          	mov    %eax,0x4(%esp)
  109535:	c7 04 24 14 a9 11 00 	movl   $0x11a914,(%esp)
  10953c:	e8 cf 71 ff ff       	call   100710 <cprintf>
		pcif->bus->busno, pcif->dev, pcif->func,
        PCI_VENDOR(pcif->dev_id), PCI_PRODUCT(pcif->dev_id));
    return 0;
  109541:	b8 00 00 00 00       	mov    $0x0,%eax
}
  109546:	83 c4 20             	add    $0x20,%esp
  109549:	5b                   	pop    %ebx
  10954a:	5e                   	pop    %esi
  10954b:	5d                   	pop    %ebp
  10954c:	c3                   	ret    
  10954d:	8d 76 00             	lea    0x0(%esi),%esi

00109550 <pci_bridge_pci_attach>:

static int
pci_bridge_pci_attach(struct pci_func *pcif)
{
  109550:	55                   	push   %ebp
  109551:	89 e5                	mov    %esp,%ebp
  109553:	56                   	push   %esi
  109554:	53                   	push   %ebx
  109555:	83 ec 30             	sub    $0x30,%esp
    uint32_t ioreg  = pci_conf_read(pcif, PCI_BRIDGE_STATIO_REG);
  109558:	c7 44 24 04 1c 00 00 	movl   $0x1c,0x4(%esp)
  10955f:	00 
  109560:	8b 45 08             	mov    0x8(%ebp),%eax
  109563:	89 04 24             	mov    %eax,(%esp)
  109566:	e8 95 fa ff ff       	call   109000 <pci_conf_read>
  10956b:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
    uint32_t busreg = pci_conf_read(pcif, PCI_BRIDGE_BUS_REG);
  10956e:	c7 44 24 04 18 00 00 	movl   $0x18,0x4(%esp)
  109575:	00 
  109576:	8b 45 08             	mov    0x8(%ebp),%eax
  109579:	89 04 24             	mov    %eax,(%esp)
  10957c:	e8 7f fa ff ff       	call   109000 <pci_conf_read>
  109581:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)

    if (PCI_BRIDGE_IO_32BITS(ioreg)) {
  109584:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  109587:	83 e0 0f             	and    $0xf,%eax
  10958a:	83 f8 01             	cmp    $0x1,%eax
  10958d:	75 38                	jne    1095c7 <pci_bridge_pci_attach+0x77>
	cprintf("PCI: %02x:%02x.%d: 32-bit bridge IO not supported.\n",
  10958f:	8b 45 08             	mov    0x8(%ebp),%eax
  109592:	8b 48 08             	mov    0x8(%eax),%ecx
  109595:	8b 45 08             	mov    0x8(%ebp),%eax
  109598:	8b 50 04             	mov    0x4(%eax),%edx
  10959b:	8b 45 08             	mov    0x8(%ebp),%eax
  10959e:	8b 00                	mov    (%eax),%eax
  1095a0:	8b 40 04             	mov    0x4(%eax),%eax
  1095a3:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
  1095a7:	89 54 24 08          	mov    %edx,0x8(%esp)
  1095ab:	89 44 24 04          	mov    %eax,0x4(%esp)
  1095af:	c7 04 24 3c a9 11 00 	movl   $0x11a93c,(%esp)
  1095b6:	e8 55 71 ff ff       	call   100710 <cprintf>
		pcif->bus->busno, pcif->dev, pcif->func);
	return 0;
  1095bb:	c7 45 e4 00 00 00 00 	movl   $0x0,0xffffffe4(%ebp)
  1095c2:	e9 8a 00 00 00       	jmp    109651 <pci_bridge_pci_attach+0x101>
    }

    struct pci_bus nbus;
    memset(&nbus, 0, sizeof(nbus));
  1095c7:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  1095ce:	00 
  1095cf:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  1095d6:	00 
  1095d7:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
  1095da:	89 04 24             	mov    %eax,(%esp)
  1095dd:	e8 1e c9 ff ff       	call   105f00 <memset>
    nbus.parent_bridge = pcif;
  1095e2:	8b 45 08             	mov    0x8(%ebp),%eax
  1095e5:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
    nbus.busno = (busreg >> PCI_BRIDGE_BUS_SECONDARY_SHIFT) & 0xff;
  1095e8:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  1095eb:	c1 e8 08             	shr    $0x8,%eax
  1095ee:	25 ff 00 00 00       	and    $0xff,%eax
  1095f3:	89 45 ec             	mov    %eax,0xffffffec(%ebp)

    if (pci_show_devs)
  1095f6:	a1 c0 ca 11 00       	mov    0x11cac0,%eax
  1095fb:	85 c0                	test   %eax,%eax
  1095fd:	74 40                	je     10963f <pci_bridge_pci_attach+0xef>
	cprintf("PCI: %02x:%02x.%d: bridge to PCI bus %d--%d\n",
  1095ff:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  109602:	c1 e8 10             	shr    $0x10,%eax
  109605:	0f b6 d0             	movzbl %al,%edx
  109608:	8b 4d ec             	mov    0xffffffec(%ebp),%ecx
  10960b:	8b 45 08             	mov    0x8(%ebp),%eax
  10960e:	8b 58 08             	mov    0x8(%eax),%ebx
  109611:	8b 45 08             	mov    0x8(%ebp),%eax
  109614:	8b 70 04             	mov    0x4(%eax),%esi
  109617:	8b 45 08             	mov    0x8(%ebp),%eax
  10961a:	8b 00                	mov    (%eax),%eax
  10961c:	8b 40 04             	mov    0x4(%eax),%eax
  10961f:	89 54 24 14          	mov    %edx,0x14(%esp)
  109623:	89 4c 24 10          	mov    %ecx,0x10(%esp)
  109627:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
  10962b:	89 74 24 08          	mov    %esi,0x8(%esp)
  10962f:	89 44 24 04          	mov    %eax,0x4(%esp)
  109633:	c7 04 24 70 a9 11 00 	movl   $0x11a970,(%esp)
  10963a:	e8 d1 70 ff ff       	call   100710 <cprintf>
		pcif->bus->busno, pcif->dev, pcif->func,
		nbus.busno,
		(busreg >> PCI_BRIDGE_BUS_SUBORDINATE_SHIFT) & 0xff);

    pci_scan_bus(&nbus);
  10963f:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
  109642:	89 04 24             	mov    %eax,(%esp)
  109645:	e8 f6 fb ff ff       	call   109240 <pci_scan_bus>
    return 1;
  10964a:	c7 45 e4 01 00 00 00 	movl   $0x1,0xffffffe4(%ebp)
  109651:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
}
  109654:	83 c4 30             	add    $0x30,%esp
  109657:	5b                   	pop    %ebx
  109658:	5e                   	pop    %esi
  109659:	5d                   	pop    %ebp
  10965a:	c3                   	ret    
  10965b:	90                   	nop    
  10965c:	8d 74 26 00          	lea    0x0(%esi),%esi

00109660 <pci_display_attach>:

static int
pci_display_attach(struct pci_func *pcif)
{
  109660:	55                   	push   %ebp
  109661:	89 e5                	mov    %esp,%ebp
  109663:	56                   	push   %esi
  109664:	53                   	push   %ebx
  109665:	83 ec 20             	sub    $0x20,%esp
    cprintf("PCI: %02x:%02x.%d: Display %04x:%04x\n",
  109668:	8b 45 08             	mov    0x8(%ebp),%eax
  10966b:	8b 40 0c             	mov    0xc(%eax),%eax
  10966e:	c1 e8 10             	shr    $0x10,%eax
  109671:	0f b7 f0             	movzwl %ax,%esi
  109674:	8b 45 08             	mov    0x8(%ebp),%eax
  109677:	8b 40 0c             	mov    0xc(%eax),%eax
  10967a:	0f b7 d0             	movzwl %ax,%edx
  10967d:	8b 45 08             	mov    0x8(%ebp),%eax
  109680:	8b 48 08             	mov    0x8(%eax),%ecx
  109683:	8b 45 08             	mov    0x8(%ebp),%eax
  109686:	8b 58 04             	mov    0x4(%eax),%ebx
  109689:	8b 45 08             	mov    0x8(%ebp),%eax
  10968c:	8b 00                	mov    (%eax),%eax
  10968e:	8b 40 04             	mov    0x4(%eax),%eax
  109691:	89 74 24 14          	mov    %esi,0x14(%esp)
  109695:	89 54 24 10          	mov    %edx,0x10(%esp)
  109699:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
  10969d:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  1096a1:	89 44 24 04          	mov    %eax,0x4(%esp)
  1096a5:	c7 04 24 a0 a9 11 00 	movl   $0x11a9a0,(%esp)
  1096ac:	e8 5f 70 ff ff       	call   100710 <cprintf>
		pcif->bus->busno, pcif->dev, pcif->func,
        PCI_VENDOR(pcif->dev_id), PCI_PRODUCT(pcif->dev_id));
    return 0;
  1096b1:	b8 00 00 00 00       	mov    $0x0,%eax
}
  1096b6:	83 c4 20             	add    $0x20,%esp
  1096b9:	5b                   	pop    %ebx
  1096ba:	5e                   	pop    %esi
  1096bb:	5d                   	pop    %ebp
  1096bc:	c3                   	ret    
  1096bd:	8d 76 00             	lea    0x0(%esi),%esi

001096c0 <pci_func_enable>:

// External PCI subsystem interface

void
pci_func_enable(struct pci_func *f)
{
  1096c0:	55                   	push   %ebp
  1096c1:	89 e5                	mov    %esp,%ebp
  1096c3:	57                   	push   %edi
  1096c4:	56                   	push   %esi
  1096c5:	53                   	push   %ebx
  1096c6:	83 ec 4c             	sub    $0x4c,%esp
    pci_conf_write(f, PCI_COMMAND_STATUS_REG,
  1096c9:	c7 44 24 08 07 00 00 	movl   $0x7,0x8(%esp)
  1096d0:	00 
  1096d1:	c7 44 24 04 04 00 00 	movl   $0x4,0x4(%esp)
  1096d8:	00 
  1096d9:	8b 45 08             	mov    0x8(%ebp),%eax
  1096dc:	89 04 24             	mov    %eax,(%esp)
  1096df:	e8 8c f9 ff ff       	call   109070 <pci_conf_write>
		   PCI_COMMAND_IO_ENABLE |
		   PCI_COMMAND_MEM_ENABLE |
		   PCI_COMMAND_MASTER_ENABLE);

    uint32_t bar_width;
    uint32_t bar;
    for (bar = PCI_MAPREG_START; bar < PCI_MAPREG_END;
  1096e4:	c7 45 dc 10 00 00 00 	movl   $0x10,0xffffffdc(%ebp)
  1096eb:	e9 de 01 00 00       	jmp    1098ce <pci_func_enable+0x20e>
	 bar += bar_width)
    {
	uint32_t oldv = pci_conf_read(f, bar);
  1096f0:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  1096f3:	89 44 24 04          	mov    %eax,0x4(%esp)
  1096f7:	8b 45 08             	mov    0x8(%ebp),%eax
  1096fa:	89 04 24             	mov    %eax,(%esp)
  1096fd:	e8 fe f8 ff ff       	call   109000 <pci_conf_read>
  109702:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)

	bar_width = 4;
  109705:	c7 45 d8 04 00 00 00 	movl   $0x4,0xffffffd8(%ebp)
	pci_conf_write(f, bar, 0xffffffff);
  10970c:	c7 44 24 08 ff ff ff 	movl   $0xffffffff,0x8(%esp)
  109713:	ff 
  109714:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  109717:	89 44 24 04          	mov    %eax,0x4(%esp)
  10971b:	8b 45 08             	mov    0x8(%ebp),%eax
  10971e:	89 04 24             	mov    %eax,(%esp)
  109721:	e8 4a f9 ff ff       	call   109070 <pci_conf_write>
	uint32_t rv = pci_conf_read(f, bar);
  109726:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  109729:	89 44 24 04          	mov    %eax,0x4(%esp)
  10972d:	8b 45 08             	mov    0x8(%ebp),%eax
  109730:	89 04 24             	mov    %eax,(%esp)
  109733:	e8 c8 f8 ff ff       	call   109000 <pci_conf_read>
  109738:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)

	if (rv == 0)
  10973b:	83 7d e4 00          	cmpl   $0x0,0xffffffe4(%ebp)
  10973f:	0f 84 83 01 00 00    	je     1098c8 <pci_func_enable+0x208>
	    continue;

	int regnum = PCI_MAPREG_NUM(bar);
  109745:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  109748:	83 e8 10             	sub    $0x10,%eax
  10974b:	c1 e8 02             	shr    $0x2,%eax
  10974e:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
	uint32_t base, size;
	if (PCI_MAPREG_TYPE(rv) == PCI_MAPREG_TYPE_MEM) {
  109751:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
  109754:	83 e0 01             	and    $0x1,%eax
  109757:	85 c0                	test   %eax,%eax
  109759:	75 58                	jne    1097b3 <pci_func_enable+0xf3>
	    if (PCI_MAPREG_MEM_TYPE(rv) == PCI_MAPREG_MEM_TYPE_64BIT)
  10975b:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
  10975e:	83 e0 06             	and    $0x6,%eax
  109761:	83 f8 04             	cmp    $0x4,%eax
  109764:	75 07                	jne    10976d <pci_func_enable+0xad>
		bar_width = 8;
  109766:	c7 45 d8 08 00 00 00 	movl   $0x8,0xffffffd8(%ebp)

	    size = PCI_MAPREG_MEM_SIZE(rv);
  10976d:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
  109770:	83 e0 f0             	and    $0xfffffff0,%eax
  109773:	f7 d8                	neg    %eax
  109775:	23 45 e4             	and    0xffffffe4(%ebp),%eax
  109778:	83 e0 f0             	and    $0xfffffff0,%eax
  10977b:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
	    base = PCI_MAPREG_MEM_ADDR(oldv);
  10977e:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  109781:	83 e0 f0             	and    $0xfffffff0,%eax
  109784:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
	    if (pci_show_addrs)
  109787:	a1 c4 ca 11 00       	mov    0x11cac4,%eax
  10978c:	85 c0                	test   %eax,%eax
  10978e:	74 67                	je     1097f7 <pci_func_enable+0x137>
		cprintf("  mem region %d: %d bytes at 0x%x\n",
  109790:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  109793:	89 44 24 0c          	mov    %eax,0xc(%esp)
  109797:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10979a:	89 44 24 08          	mov    %eax,0x8(%esp)
  10979e:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  1097a1:	89 44 24 04          	mov    %eax,0x4(%esp)
  1097a5:	c7 04 24 c8 a9 11 00 	movl   $0x11a9c8,(%esp)
  1097ac:	e8 5f 6f ff ff       	call   100710 <cprintf>
  1097b1:	eb 44                	jmp    1097f7 <pci_func_enable+0x137>
			regnum, size, base);
	} else {
	    size = PCI_MAPREG_IO_SIZE(rv);
  1097b3:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
  1097b6:	83 e0 fc             	and    $0xfffffffc,%eax
  1097b9:	f7 d8                	neg    %eax
  1097bb:	23 45 e4             	and    0xffffffe4(%ebp),%eax
  1097be:	83 e0 fc             	and    $0xfffffffc,%eax
  1097c1:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
	    base = PCI_MAPREG_IO_ADDR(oldv);
  1097c4:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  1097c7:	83 e0 fc             	and    $0xfffffffc,%eax
  1097ca:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
	    if (pci_show_addrs)
  1097cd:	a1 c4 ca 11 00       	mov    0x11cac4,%eax
  1097d2:	85 c0                	test   %eax,%eax
  1097d4:	74 21                	je     1097f7 <pci_func_enable+0x137>
		cprintf("  io region %d: %d bytes at 0x%x\n",
  1097d6:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  1097d9:	89 44 24 0c          	mov    %eax,0xc(%esp)
  1097dd:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  1097e0:	89 44 24 08          	mov    %eax,0x8(%esp)
  1097e4:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  1097e7:	89 44 24 04          	mov    %eax,0x4(%esp)
  1097eb:	c7 04 24 ec a9 11 00 	movl   $0x11a9ec,(%esp)
  1097f2:	e8 19 6f ff ff       	call   100710 <cprintf>
			regnum, size, base);
	}

	pci_conf_write(f, bar, oldv);
  1097f7:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  1097fa:	89 44 24 08          	mov    %eax,0x8(%esp)
  1097fe:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  109801:	89 44 24 04          	mov    %eax,0x4(%esp)
  109805:	8b 45 08             	mov    0x8(%ebp),%eax
  109808:	89 04 24             	mov    %eax,(%esp)
  10980b:	e8 60 f8 ff ff       	call   109070 <pci_conf_write>
	f->reg_base[regnum] = base;
  109810:	8b 4d e8             	mov    0xffffffe8(%ebp),%ecx
  109813:	8b 55 08             	mov    0x8(%ebp),%edx
  109816:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  109819:	89 44 8a 14          	mov    %eax,0x14(%edx,%ecx,4)
	f->reg_size[regnum] = size;
  10981d:	8b 4d e8             	mov    0xffffffe8(%ebp),%ecx
  109820:	8b 55 08             	mov    0x8(%ebp),%edx
  109823:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  109826:	89 44 8a 2c          	mov    %eax,0x2c(%edx,%ecx,4)

	cprintf("  -> reg_base[%d] = %08x\n", regnum, base);
  10982a:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10982d:	89 44 24 08          	mov    %eax,0x8(%esp)
  109831:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  109834:	89 44 24 04          	mov    %eax,0x4(%esp)
  109838:	c7 04 24 0e aa 11 00 	movl   $0x11aa0e,(%esp)
  10983f:	e8 cc 6e ff ff       	call   100710 <cprintf>
	cprintf("  -> reg_size[%d] = %08x\n", regnum, size);
  109844:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  109847:	89 44 24 08          	mov    %eax,0x8(%esp)
  10984b:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  10984e:	89 44 24 04          	mov    %eax,0x4(%esp)
  109852:	c7 04 24 28 aa 11 00 	movl   $0x11aa28,(%esp)
  109859:	e8 b2 6e ff ff       	call   100710 <cprintf>

	if (size && !base)
  10985e:	83 7d f0 00          	cmpl   $0x0,0xfffffff0(%ebp)
  109862:	74 64                	je     1098c8 <pci_func_enable+0x208>
  109864:	83 7d ec 00          	cmpl   $0x0,0xffffffec(%ebp)
  109868:	75 5e                	jne    1098c8 <pci_func_enable+0x208>
	    cprintf("PCI device %02x:%02x.%d (%04x:%04x) may be misconfigured: "
  10986a:	8b 45 08             	mov    0x8(%ebp),%eax
  10986d:	8b 40 0c             	mov    0xc(%eax),%eax
  109870:	c1 e8 10             	shr    $0x10,%eax
  109873:	0f b7 d0             	movzwl %ax,%edx
  109876:	8b 45 08             	mov    0x8(%ebp),%eax
  109879:	8b 40 0c             	mov    0xc(%eax),%eax
  10987c:	0f b7 c8             	movzwl %ax,%ecx
  10987f:	8b 45 08             	mov    0x8(%ebp),%eax
  109882:	8b 58 08             	mov    0x8(%eax),%ebx
  109885:	8b 45 08             	mov    0x8(%ebp),%eax
  109888:	8b 70 04             	mov    0x4(%eax),%esi
  10988b:	8b 45 08             	mov    0x8(%ebp),%eax
  10988e:	8b 00                	mov    (%eax),%eax
  109890:	8b 78 04             	mov    0x4(%eax),%edi
  109893:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  109896:	89 44 24 20          	mov    %eax,0x20(%esp)
  10989a:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10989d:	89 44 24 1c          	mov    %eax,0x1c(%esp)
  1098a1:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  1098a4:	89 44 24 18          	mov    %eax,0x18(%esp)
  1098a8:	89 54 24 14          	mov    %edx,0x14(%esp)
  1098ac:	89 4c 24 10          	mov    %ecx,0x10(%esp)
  1098b0:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
  1098b4:	89 74 24 08          	mov    %esi,0x8(%esp)
  1098b8:	89 7c 24 04          	mov    %edi,0x4(%esp)
  1098bc:	c7 04 24 44 aa 11 00 	movl   $0x11aa44,(%esp)
  1098c3:	e8 48 6e ff ff       	call   100710 <cprintf>
  1098c8:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  1098cb:	01 45 dc             	add    %eax,0xffffffdc(%ebp)
  1098ce:	83 7d dc 27          	cmpl   $0x27,0xffffffdc(%ebp)
  1098d2:	0f 86 18 fe ff ff    	jbe    1096f0 <pci_func_enable+0x30>
		    "region %d: base 0x%x, size %d\n",
		    f->bus->busno, f->dev, f->func,
		    PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
		    regnum, base, size);
    }
}
  1098d8:	83 c4 4c             	add    $0x4c,%esp
  1098db:	5b                   	pop    %ebx
  1098dc:	5e                   	pop    %esi
  1098dd:	5f                   	pop    %edi
  1098de:	5d                   	pop    %ebp
  1098df:	c3                   	ret    

001098e0 <pci_init>:

int
pci_init(void)
{
  1098e0:	55                   	push   %ebp
  1098e1:	89 e5                	mov    %esp,%ebp
  1098e3:	83 ec 18             	sub    $0x18,%esp
    static struct pci_bus root_bus;
    memset(&root_bus, 0, sizeof(root_bus));
  1098e6:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  1098ed:	00 
  1098ee:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  1098f5:	00 
  1098f6:	c7 04 24 a8 cd 11 00 	movl   $0x11cda8,(%esp)
  1098fd:	e8 fe c5 ff ff       	call   105f00 <memset>

    return pci_scan_bus(&root_bus);
  109902:	c7 04 24 a8 cd 11 00 	movl   $0x11cda8,(%esp)
  109909:	e8 32 f9 ff ff       	call   109240 <pci_scan_bus>
}
  10990e:	c9                   	leave  
  10990f:	c3                   	ret    

00109910 <__assert>:
#include "defs.h"

void __assert(const char *func, const char *file, 
        int line, const char *expr)
{
  109910:	55                   	push   %ebp
  109911:	89 e5                	mov    %esp,%ebp
  109913:	83 ec 18             	sub    $0x18,%esp
    cprintf("assert failed: %s at %s:%d, expression %s\n",
  109916:	8b 45 14             	mov    0x14(%ebp),%eax
  109919:	89 44 24 10          	mov    %eax,0x10(%esp)
  10991d:	8b 45 10             	mov    0x10(%ebp),%eax
  109920:	89 44 24 0c          	mov    %eax,0xc(%esp)
  109924:	8b 45 0c             	mov    0xc(%ebp),%eax
  109927:	89 44 24 08          	mov    %eax,0x8(%esp)
  10992b:	8b 45 08             	mov    0x8(%ebp),%eax
  10992e:	89 44 24 04          	mov    %eax,0x4(%esp)
  109932:	c7 04 24 a0 aa 11 00 	movl   $0x11aaa0,(%esp)
  109939:	e8 d2 6d ff ff       	call   100710 <cprintf>
            func, file, line, expr);
}
  10993e:	c9                   	leave  
  10993f:	c3                   	ret    

00109940 <sem_init>:
    int waiters;
};

int sem_init(sem_t *sem, unsigned int value)
{
  109940:	55                   	push   %ebp
  109941:	89 e5                	mov    %esp,%ebp
  109943:	83 ec 08             	sub    $0x8,%esp
    assert(value >= 0);
    initlock(&sem->lock, "sem lock");
  109946:	8b 45 08             	mov    0x8(%ebp),%eax
  109949:	c7 44 24 04 d4 aa 11 	movl   $0x11aad4,0x4(%esp)
  109950:	00 
  109951:	89 04 24             	mov    %eax,(%esp)
  109954:	e8 b7 c1 ff ff       	call   105b10 <initlock>
    sem->val = value;
  109959:	8b 55 0c             	mov    0xc(%ebp),%edx
  10995c:	8b 45 08             	mov    0x8(%ebp),%eax
  10995f:	89 50 34             	mov    %edx,0x34(%eax)
    sem->waiters = 0;
  109962:	8b 45 08             	mov    0x8(%ebp),%eax
  109965:	c7 40 38 00 00 00 00 	movl   $0x0,0x38(%eax)
    return 0;
  10996c:	b8 00 00 00 00       	mov    $0x0,%eax
}
  109971:	c9                   	leave  
  109972:	c3                   	ret    
  109973:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  109979:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00109980 <sem_destroy>:

int sem_destroy(sem_t *sem)
{
  109980:	55                   	push   %ebp
  109981:	89 e5                	mov    %esp,%ebp
  109983:	83 ec 18             	sub    $0x18,%esp
    assert(sem->waiters == 0);
  109986:	8b 45 08             	mov    0x8(%ebp),%eax
  109989:	8b 40 38             	mov    0x38(%eax),%eax
  10998c:	85 c0                	test   %eax,%eax
  10998e:	74 24                	je     1099b4 <sem_destroy+0x34>
  109990:	c7 44 24 0c e9 aa 11 	movl   $0x11aae9,0xc(%esp)
  109997:	00 
  109998:	c7 44 24 08 18 00 00 	movl   $0x18,0x8(%esp)
  10999f:	00 
  1099a0:	c7 44 24 04 fb aa 11 	movl   $0x11aafb,0x4(%esp)
  1099a7:	00 
  1099a8:	c7 04 24 dd aa 11 00 	movl   $0x11aadd,(%esp)
  1099af:	e8 5c ff ff ff       	call   109910 <__assert>
    return 0;
  1099b4:	b8 00 00 00 00       	mov    $0x0,%eax
}
  1099b9:	c9                   	leave  
  1099ba:	c3                   	ret    
  1099bb:	90                   	nop    
  1099bc:	8d 74 26 00          	lea    0x0(%esi),%esi

001099c0 <sem_post>:

void sem_post(sem_t *sem)
{
  1099c0:	55                   	push   %ebp
  1099c1:	89 e5                	mov    %esp,%ebp
  1099c3:	83 ec 08             	sub    $0x8,%esp
    acquire(&sem->lock);
  1099c6:	8b 45 08             	mov    0x8(%ebp),%eax
  1099c9:	89 04 24             	mov    %eax,(%esp)
  1099cc:	e8 6f c1 ff ff       	call   105b40 <acquire>
    sem->val++;
  1099d1:	8b 45 08             	mov    0x8(%ebp),%eax
  1099d4:	8b 40 34             	mov    0x34(%eax),%eax
  1099d7:	8d 50 01             	lea    0x1(%eax),%edx
  1099da:	8b 45 08             	mov    0x8(%ebp),%eax
  1099dd:	89 50 34             	mov    %edx,0x34(%eax)
    if ((sem->waiters) && (sem->val > 0))
  1099e0:	8b 45 08             	mov    0x8(%ebp),%eax
  1099e3:	8b 40 38             	mov    0x38(%eax),%eax
  1099e6:	85 c0                	test   %eax,%eax
  1099e8:	74 15                	je     1099ff <sem_post+0x3f>
  1099ea:	8b 45 08             	mov    0x8(%ebp),%eax
  1099ed:	8b 40 34             	mov    0x34(%eax),%eax
  1099f0:	85 c0                	test   %eax,%eax
  1099f2:	7e 0b                	jle    1099ff <sem_post+0x3f>
    {
        wakeup_one(sem); // XXX maybe wakeup?
  1099f4:	8b 45 08             	mov    0x8(%ebp),%eax
  1099f7:	89 04 24             	mov    %eax,(%esp)
  1099fa:	e8 f1 bb ff ff       	call   1055f0 <wakeup_one>
    }
    release(&sem->lock);
  1099ff:	8b 45 08             	mov    0x8(%ebp),%eax
  109a02:	89 04 24             	mov    %eax,(%esp)
  109a05:	e8 36 c3 ff ff       	call   105d40 <release>
}
  109a0a:	c9                   	leave  
  109a0b:	c3                   	ret    
  109a0c:	8d 74 26 00          	lea    0x0(%esi),%esi

00109a10 <sem_wait>:

void sem_wait(sem_t *sem)
{
  109a10:	55                   	push   %ebp
  109a11:	89 e5                	mov    %esp,%ebp
  109a13:	83 ec 08             	sub    $0x8,%esp
    acquire(&sem->lock);
  109a16:	8b 45 08             	mov    0x8(%ebp),%eax
  109a19:	89 04 24             	mov    %eax,(%esp)
  109a1c:	e8 1f c1 ff ff       	call   105b40 <acquire>
    while (sem->val == 0)
  109a21:	eb 30                	jmp    109a53 <sem_wait+0x43>
    {
        sem->waiters++;
  109a23:	8b 45 08             	mov    0x8(%ebp),%eax
  109a26:	8b 40 38             	mov    0x38(%eax),%eax
  109a29:	8d 50 01             	lea    0x1(%eax),%edx
  109a2c:	8b 45 08             	mov    0x8(%ebp),%eax
  109a2f:	89 50 38             	mov    %edx,0x38(%eax)
        sleep(sem, &sem->lock);
  109a32:	8b 45 08             	mov    0x8(%ebp),%eax
  109a35:	89 44 24 04          	mov    %eax,0x4(%esp)
  109a39:	8b 45 08             	mov    0x8(%ebp),%eax
  109a3c:	89 04 24             	mov    %eax,(%esp)
  109a3f:	e8 4c ba ff ff       	call   105490 <sleep>
        sem->waiters--;
  109a44:	8b 45 08             	mov    0x8(%ebp),%eax
  109a47:	8b 40 38             	mov    0x38(%eax),%eax
  109a4a:	8d 50 ff             	lea    0xffffffff(%eax),%edx
  109a4d:	8b 45 08             	mov    0x8(%ebp),%eax
  109a50:	89 50 38             	mov    %edx,0x38(%eax)
  109a53:	8b 45 08             	mov    0x8(%ebp),%eax
  109a56:	8b 40 34             	mov    0x34(%eax),%eax
  109a59:	85 c0                	test   %eax,%eax
  109a5b:	74 c6                	je     109a23 <sem_wait+0x13>
    }
    sem->val--;
  109a5d:	8b 45 08             	mov    0x8(%ebp),%eax
  109a60:	8b 40 34             	mov    0x34(%eax),%eax
  109a63:	8d 50 ff             	lea    0xffffffff(%eax),%edx
  109a66:	8b 45 08             	mov    0x8(%ebp),%eax
  109a69:	89 50 34             	mov    %edx,0x34(%eax)
    release(&sem->lock);
  109a6c:	8b 45 08             	mov    0x8(%ebp),%eax
  109a6f:	89 04 24             	mov    %eax,(%esp)
  109a72:	e8 c9 c2 ff ff       	call   105d40 <release>
}
  109a77:	c9                   	leave  
  109a78:	c3                   	ret    
  109a79:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

00109a80 <sem_timedwait>:

int sem_timedwait(sem_t *sem, int timo)
{
  109a80:	55                   	push   %ebp
  109a81:	89 e5                	mov    %esp,%ebp
  109a83:	83 ec 28             	sub    $0x28,%esp
    int ret;

    acquire(&sem->lock);
  109a86:	8b 45 08             	mov    0x8(%ebp),%eax
  109a89:	89 04 24             	mov    %eax,(%esp)
  109a8c:	e8 af c0 ff ff       	call   105b40 <acquire>
    for (ret = 0; sem->val == 0 && ret == 0;)
  109a91:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
  109a98:	eb 3a                	jmp    109ad4 <sem_timedwait+0x54>
    {
        sem->waiters++;
  109a9a:	8b 45 08             	mov    0x8(%ebp),%eax
  109a9d:	8b 40 38             	mov    0x38(%eax),%eax
  109aa0:	8d 50 01             	lea    0x1(%eax),%edx
  109aa3:	8b 45 08             	mov    0x8(%ebp),%eax
  109aa6:	89 50 38             	mov    %edx,0x38(%eax)
        ret = msleep_spin(sem, &sem->lock, timo);
  109aa9:	8b 55 08             	mov    0x8(%ebp),%edx
  109aac:	8b 45 0c             	mov    0xc(%ebp),%eax
  109aaf:	89 44 24 08          	mov    %eax,0x8(%esp)
  109ab3:	89 54 24 04          	mov    %edx,0x4(%esp)
  109ab7:	8b 45 08             	mov    0x8(%ebp),%eax
  109aba:	89 04 24             	mov    %eax,(%esp)
  109abd:	e8 ae b8 ff ff       	call   105370 <msleep_spin>
  109ac2:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
        sem->waiters--;
  109ac5:	8b 45 08             	mov    0x8(%ebp),%eax
  109ac8:	8b 40 38             	mov    0x38(%eax),%eax
  109acb:	8d 50 ff             	lea    0xffffffff(%eax),%edx
  109ace:	8b 45 08             	mov    0x8(%ebp),%eax
  109ad1:	89 50 38             	mov    %edx,0x38(%eax)
  109ad4:	8b 45 08             	mov    0x8(%ebp),%eax
  109ad7:	8b 40 34             	mov    0x34(%eax),%eax
  109ada:	85 c0                	test   %eax,%eax
  109adc:	75 06                	jne    109ae4 <sem_timedwait+0x64>
  109ade:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  109ae2:	74 b6                	je     109a9a <sem_timedwait+0x1a>
    }
    if (sem->val > 0)
  109ae4:	8b 45 08             	mov    0x8(%ebp),%eax
  109ae7:	8b 40 34             	mov    0x34(%eax),%eax
  109aea:	85 c0                	test   %eax,%eax
  109aec:	7e 16                	jle    109b04 <sem_timedwait+0x84>
    {
        sem->val--;
  109aee:	8b 45 08             	mov    0x8(%ebp),%eax
  109af1:	8b 40 34             	mov    0x34(%eax),%eax
  109af4:	8d 50 ff             	lea    0xffffffff(%eax),%edx
  109af7:	8b 45 08             	mov    0x8(%ebp),%eax
  109afa:	89 50 34             	mov    %edx,0x34(%eax)
        ret = 0;
  109afd:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
    }
    release(&sem->lock);
  109b04:	8b 45 08             	mov    0x8(%ebp),%eax
  109b07:	89 04 24             	mov    %eax,(%esp)
  109b0a:	e8 31 c2 ff ff       	call   105d40 <release>

    return ret;
  109b0f:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
}
  109b12:	c9                   	leave  
  109b13:	c3                   	ret    
  109b14:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  109b1a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

00109b20 <sem_trywait>:

int sem_trywait(sem_t *sem)
{
  109b20:	55                   	push   %ebp
  109b21:	89 e5                	mov    %esp,%ebp
  109b23:	83 ec 18             	sub    $0x18,%esp
    int ret;

    acquire(&sem->lock);
  109b26:	8b 45 08             	mov    0x8(%ebp),%eax
  109b29:	89 04 24             	mov    %eax,(%esp)
  109b2c:	e8 0f c0 ff ff       	call   105b40 <acquire>
    if (sem->val > 0)
  109b31:	8b 45 08             	mov    0x8(%ebp),%eax
  109b34:	8b 40 34             	mov    0x34(%eax),%eax
  109b37:	85 c0                	test   %eax,%eax
  109b39:	7e 18                	jle    109b53 <sem_trywait+0x33>
    {
        sem->val--;
  109b3b:	8b 45 08             	mov    0x8(%ebp),%eax
  109b3e:	8b 40 34             	mov    0x34(%eax),%eax
  109b41:	8d 50 ff             	lea    0xffffffff(%eax),%edx
  109b44:	8b 45 08             	mov    0x8(%ebp),%eax
  109b47:	89 50 34             	mov    %edx,0x34(%eax)
        ret = 1;
  109b4a:	c7 45 fc 01 00 00 00 	movl   $0x1,0xfffffffc(%ebp)
  109b51:	eb 07                	jmp    109b5a <sem_trywait+0x3a>
    } else {
        ret = 0;
  109b53:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
    }
    release(&sem->lock);
  109b5a:	8b 45 08             	mov    0x8(%ebp),%eax
  109b5d:	89 04 24             	mov    %eax,(%esp)
  109b60:	e8 db c1 ff ff       	call   105d40 <release>
    return ret;
  109b65:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
}
  109b68:	c9                   	leave  
  109b69:	c3                   	ret    
  109b6a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

00109b70 <sem_value>:

int sem_value(sem_t *sem)
{
  109b70:	55                   	push   %ebp
  109b71:	89 e5                	mov    %esp,%ebp
  109b73:	83 ec 18             	sub    $0x18,%esp
    int ret;

    acquire(&sem->lock);
  109b76:	8b 45 08             	mov    0x8(%ebp),%eax
  109b79:	89 04 24             	mov    %eax,(%esp)
  109b7c:	e8 bf bf ff ff       	call   105b40 <acquire>
    ret = sem->val;
  109b81:	8b 45 08             	mov    0x8(%ebp),%eax
  109b84:	8b 40 34             	mov    0x34(%eax),%eax
  109b87:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
    release(&sem->lock);
  109b8a:	8b 45 08             	mov    0x8(%ebp),%eax
  109b8d:	89 04 24             	mov    %eax,(%esp)
  109b90:	e8 ab c1 ff ff       	call   105d40 <release>
    return ret;
  109b95:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
}
  109b98:	c9                   	leave  
  109b99:	c3                   	ret    
  109b9a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

00109ba0 <sem_size>:

int sem_size()
{
  109ba0:	55                   	push   %ebp
  109ba1:	89 e5                	mov    %esp,%ebp
    return sizeof(struct sem);
  109ba3:	b8 3c 00 00 00       	mov    $0x3c,%eax
}
  109ba8:	5d                   	pop    %ebp
  109ba9:	c3                   	ret    
  109baa:	90                   	nop    
  109bab:	90                   	nop    
  109bac:	90                   	nop    
  109bad:	90                   	nop    
  109bae:	90                   	nop    
  109baf:	90                   	nop    

00109bb0 <kproc_start>:
extern struct proc *initproc;

kproc_t kproc_start(void (* proc)(void *arg), 
        void *arg, int prio, void *data, char *name)
{
  109bb0:	55                   	push   %ebp
  109bb1:	89 e5                	mov    %esp,%ebp
  109bb3:	83 ec 28             	sub    $0x28,%esp
    kproc_t thr = (kproc_t)kmalloc(sizeof(struct thread));
  109bb6:	c7 04 24 0c 00 00 00 	movl   $0xc,(%esp)
  109bbd:	e8 be 99 ff ff       	call   103580 <kmalloc>
  109bc2:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
    if (!thr)
  109bc5:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  109bc9:	75 0c                	jne    109bd7 <kproc_start+0x27>
        return NULL;
  109bcb:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  109bd2:	e9 77 01 00 00       	jmp    109d4e <kproc_start+0x19e>
    thr->p = allocproc();
  109bd7:	e8 14 ac ff ff       	call   1047f0 <allocproc>
  109bdc:	89 c2                	mov    %eax,%edx
  109bde:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  109be1:	89 10                	mov    %edx,(%eax)
    struct proc *np = thr->p;
  109be3:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  109be6:	8b 00                	mov    (%eax),%eax
  109be8:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
    if (!np)
  109beb:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  109bef:	75 0c                	jne    109bfd <kproc_start+0x4d>
        return NULL;
  109bf1:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  109bf8:	e9 51 01 00 00       	jmp    109d4e <kproc_start+0x19e>
    if((np->kstack = kmalloc(KSTACKSIZE)) == 0){
  109bfd:	c7 04 24 00 10 00 00 	movl   $0x1000,(%esp)
  109c04:	e8 77 99 ff ff       	call   103580 <kmalloc>
  109c09:	89 c2                	mov    %eax,%edx
  109c0b:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  109c0e:	89 50 08             	mov    %edx,0x8(%eax)
  109c11:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  109c14:	8b 40 08             	mov    0x8(%eax),%eax
  109c17:	85 c0                	test   %eax,%eax
  109c19:	75 16                	jne    109c31 <kproc_start+0x81>
      np->state = UNUSED;
  109c1b:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  109c1e:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
      return NULL;
  109c25:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  109c2c:	e9 1d 01 00 00       	jmp    109d4e <kproc_start+0x19e>
    }
    np->thr = thr;
  109c31:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  109c34:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  109c37:	89 82 a8 00 00 00    	mov    %eax,0xa8(%edx)
    np->parent = initproc;
  109c3d:	8b 15 24 0c 14 00    	mov    0x140c24,%edx
  109c43:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  109c46:	89 50 14             	mov    %edx,0x14(%eax)
    np->sz = 0;
  109c49:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  109c4c:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    np->chan = 0;
  109c53:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  109c56:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
    np->killed = 0;
  109c5d:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  109c60:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
    thr->data = data;
  109c67:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  109c6a:	8b 45 14             	mov    0x14(%ebp),%eax
  109c6d:	89 42 04             	mov    %eax,0x4(%edx)
    memset(&np->context, 0, sizeof(np->context));
  109c70:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  109c73:	83 c0 64             	add    $0x64,%eax
  109c76:	c7 44 24 08 20 00 00 	movl   $0x20,0x8(%esp)
  109c7d:	00 
  109c7e:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  109c85:	00 
  109c86:	89 04 24             	mov    %eax,(%esp)
  109c89:	e8 72 c2 ff ff       	call   105f00 <memset>
    thr->timeouts.next = 0;
  109c8e:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  109c91:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    if (name == 0)
  109c98:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
  109c9c:	75 22                	jne    109cc0 <kproc_start+0x110>
        safestrcpy(np->name,"[kernel thread]",sizeof(np->name));
  109c9e:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  109ca1:	05 88 00 00 00       	add    $0x88,%eax
  109ca6:	c7 44 24 08 20 00 00 	movl   $0x20,0x8(%esp)
  109cad:	00 
  109cae:	c7 44 24 04 01 ab 11 	movl   $0x11ab01,0x4(%esp)
  109cb5:	00 
  109cb6:	89 04 24             	mov    %eax,(%esp)
  109cb9:	e8 22 c4 ff ff       	call   1060e0 <safestrcpy>
  109cbe:	eb 20                	jmp    109ce0 <kproc_start+0x130>
    else
        safestrcpy(np->name, name, sizeof(np->name));
  109cc0:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  109cc3:	81 c2 88 00 00 00    	add    $0x88,%edx
  109cc9:	c7 44 24 08 20 00 00 	movl   $0x20,0x8(%esp)
  109cd0:	00 
  109cd1:	8b 45 18             	mov    0x18(%ebp),%eax
  109cd4:	89 44 24 04          	mov    %eax,0x4(%esp)
  109cd8:	89 14 24             	mov    %edx,(%esp)
  109cdb:	e8 00 c4 ff ff       	call   1060e0 <safestrcpy>
    np->context.eip = (uint)thread_wrap;
  109ce0:	ba 90 9d 10 00       	mov    $0x109d90,%edx
  109ce5:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  109ce8:	89 50 64             	mov    %edx,0x64(%eax)
    np->context.esp = (uint)np->kstack + KSTACKSIZE - 1;
  109ceb:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  109cee:	8b 40 08             	mov    0x8(%eax),%eax
  109cf1:	05 ff 0f 00 00       	add    $0xfff,%eax
  109cf6:	89 c2                	mov    %eax,%edx
  109cf8:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  109cfb:	89 50 68             	mov    %edx,0x68(%eax)
    *(void**)(np->context.esp+8) = arg;
  109cfe:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  109d01:	8b 40 68             	mov    0x68(%eax),%eax
  109d04:	83 c0 08             	add    $0x8,%eax
  109d07:	89 c2                	mov    %eax,%edx
  109d09:	8b 45 0c             	mov    0xc(%ebp),%eax
  109d0c:	89 02                	mov    %eax,(%edx)
    *(void**)(np->context.esp+4) = proc;
  109d0e:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  109d11:	8b 40 68             	mov    0x68(%eax),%eax
  109d14:	83 c0 04             	add    $0x4,%eax
  109d17:	89 c2                	mov    %eax,%edx
  109d19:	8b 45 08             	mov    0x8(%ebp),%eax
  109d1c:	89 02                	mov    %eax,(%edx)
    *(void**)(np->context.esp) = exit;
  109d1e:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  109d21:	8b 40 68             	mov    0x68(%eax),%eax
  109d24:	c7 00 e0 56 10 00    	movl   $0x1056e0,(%eax)
    np->cwd = namei("/");
  109d2a:	c7 04 24 11 ab 11 00 	movl   $0x11ab11,(%esp)
  109d31:	e8 2a 8f ff ff       	call   102c60 <namei>
  109d36:	89 c2                	mov    %eax,%edx
  109d38:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  109d3b:	89 50 60             	mov    %edx,0x60(%eax)
    np->state = RUNNABLE;
  109d3e:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  109d41:	c7 40 0c 03 00 00 00 	movl   $0x3,0xc(%eax)
    return thr;
  109d48:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  109d4b:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  109d4e:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  109d51:	c9                   	leave  
  109d52:	c3                   	ret    
  109d53:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  109d59:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00109d60 <kproc_free>:

void kproc_free(kproc_t thread)
{
  109d60:	55                   	push   %ebp
  109d61:	89 e5                	mov    %esp,%ebp
  109d63:	83 ec 18             	sub    $0x18,%esp
    struct proc *p = thread->p;
  109d66:	8b 45 08             	mov    0x8(%ebp),%eax
  109d69:	8b 00                	mov    (%eax),%eax
  109d6b:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
    p->thr = 0;
  109d6e:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  109d71:	c7 80 a8 00 00 00 00 	movl   $0x0,0xa8(%eax)
  109d78:	00 00 00 
    kmfree(thread, sizeof(struct thread));
  109d7b:	c7 44 24 04 0c 00 00 	movl   $0xc,0x4(%esp)
  109d82:	00 
  109d83:	8b 45 08             	mov    0x8(%ebp),%eax
  109d86:	89 04 24             	mov    %eax,(%esp)
  109d89:	e8 22 98 ff ff       	call   1035b0 <kmfree>
}
  109d8e:	c9                   	leave  
  109d8f:	c3                   	ret    

00109d90 <thread_wrap>:

void thread_wrap(void (* thread)(void *arg), void *arg)
{
  109d90:	55                   	push   %ebp
  109d91:	89 e5                	mov    %esp,%ebp
  109d93:	83 ec 08             	sub    $0x8,%esp
    release(&proc_table_lock);
  109d96:	c7 04 24 40 0c 14 00 	movl   $0x140c40,(%esp)
  109d9d:	e8 9e bf ff ff       	call   105d40 <release>
    thread(arg);
  109da2:	8b 45 0c             	mov    0xc(%ebp),%eax
  109da5:	89 04 24             	mov    %eax,(%esp)
  109da8:	8b 45 08             	mov    0x8(%ebp),%eax
  109dab:	ff d0                	call   *%eax
}
  109dad:	c9                   	leave  
  109dae:	c3                   	ret    
  109daf:	90                   	nop    

00109db0 <ether_e100_attach>:
char *ru_state_name[];

int
ether_e100_attach(struct pci_func *pcif)
{	
  109db0:	55                   	push   %ebp
  109db1:	89 e5                	mov    %esp,%ebp
  109db3:	57                   	push   %edi
  109db4:	56                   	push   %esi
  109db5:	53                   	push   %ebx
  109db6:	83 ec 5c             	sub    $0x5c,%esp
    cprintf("PCI: %02x:%02x.%d: "
  109db9:	8b 45 08             	mov    0x8(%ebp),%eax
  109dbc:	8b 40 0c             	mov    0xc(%eax),%eax
  109dbf:	c1 e8 10             	shr    $0x10,%eax
  109dc2:	0f b7 f0             	movzwl %ax,%esi
  109dc5:	8b 45 08             	mov    0x8(%ebp),%eax
  109dc8:	8b 40 0c             	mov    0xc(%eax),%eax
  109dcb:	0f b7 d0             	movzwl %ax,%edx
  109dce:	8b 45 08             	mov    0x8(%ebp),%eax
  109dd1:	8b 48 08             	mov    0x8(%eax),%ecx
  109dd4:	8b 45 08             	mov    0x8(%ebp),%eax
  109dd7:	8b 58 04             	mov    0x4(%eax),%ebx
  109dda:	8b 45 08             	mov    0x8(%ebp),%eax
  109ddd:	8b 00                	mov    (%eax),%eax
  109ddf:	8b 40 04             	mov    0x4(%eax),%eax
  109de2:	89 74 24 14          	mov    %esi,0x14(%esp)
  109de6:	89 54 24 10          	mov    %edx,0x10(%esp)
  109dea:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
  109dee:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  109df2:	89 44 24 04          	mov    %eax,0x4(%esp)
  109df6:	c7 04 24 14 ab 11 00 	movl   $0x11ab14,(%esp)
  109dfd:	e8 0e 69 ff ff       	call   100710 <cprintf>
            "Intel 82559ER Fast Ethernet PCI Controller %04x:%04x\n",
		pcif->bus->busno, pcif->dev, pcif->func,
        PCI_VENDOR(pcif->dev_id), PCI_PRODUCT(pcif->dev_id));
    dev_count++;
  109e02:	a1 c0 cd 11 00       	mov    0x11cdc0,%eax
  109e07:	83 c0 01             	add    $0x1,%eax
  109e0a:	a3 c0 cd 11 00       	mov    %eax,0x11cdc0
    int index = dev_count-1;
  109e0f:	a1 c0 cd 11 00       	mov    0x11cdc0,%eax
  109e14:	83 e8 01             	sub    $0x1,%eax
  109e17:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
    e100_dev *dev = &e100_devs[index];
  109e1a:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
  109e1d:	69 c0 48 01 00 00    	imul   $0x148,%eax,%eax
  109e23:	05 e0 cd 11 00       	add    $0x11cde0,%eax
  109e28:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)

    dev->cubase = (uint32_t)kalloc(E100_CU_RING_SIZE * PAGE); // 128K
  109e2b:	c7 04 24 00 00 02 00 	movl   $0x20000,(%esp)
  109e32:	e8 69 96 ff ff       	call   1034a0 <kalloc>
  109e37:	89 c2                	mov    %eax,%edx
  109e39:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  109e3c:	89 90 9c 00 00 00    	mov    %edx,0x9c(%eax)
    if (!dev->cubase)
  109e42:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  109e45:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
  109e4b:	85 c0                	test   %eax,%eax
  109e4d:	75 25                	jne    109e74 <ether_e100_attach+0xc4>
    {
        cprintf("   Failed to allocate CU ring\n");
  109e4f:	c7 04 24 60 ab 11 00 	movl   $0x11ab60,(%esp)
  109e56:	e8 b5 68 ff ff       	call   100710 <cprintf>
        dev_count--;
  109e5b:	a1 c0 cd 11 00       	mov    0x11cdc0,%eax
  109e60:	83 e8 01             	sub    $0x1,%eax
  109e63:	a3 c0 cd 11 00       	mov    %eax,0x11cdc0
        return -1;
  109e68:	c7 45 c0 ff ff ff ff 	movl   $0xffffffff,0xffffffc0(%ebp)
  109e6f:	e9 94 03 00 00       	jmp    10a208 <ether_e100_attach+0x458>
    }
    dev->rubase = (uint32_t)kalloc(E100_RU_RING_SIZE * PAGE); // 128K
  109e74:	c7 04 24 00 00 02 00 	movl   $0x20000,(%esp)
  109e7b:	e8 20 96 ff ff       	call   1034a0 <kalloc>
  109e80:	89 c2                	mov    %eax,%edx
  109e82:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  109e85:	89 90 ec 00 00 00    	mov    %edx,0xec(%eax)
    if (!dev->rubase)
  109e8b:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  109e8e:	8b 80 ec 00 00 00    	mov    0xec(%eax),%eax
  109e94:	85 c0                	test   %eax,%eax
  109e96:	75 25                	jne    109ebd <ether_e100_attach+0x10d>
    {
        cprintf("   Failed to allocate RU ring\n");
  109e98:	c7 04 24 80 ab 11 00 	movl   $0x11ab80,(%esp)
  109e9f:	e8 6c 68 ff ff       	call   100710 <cprintf>
        dev_count--;
  109ea4:	a1 c0 cd 11 00       	mov    0x11cdc0,%eax
  109ea9:	83 e8 01             	sub    $0x1,%eax
  109eac:	a3 c0 cd 11 00       	mov    %eax,0x11cdc0
        return -1;
  109eb1:	c7 45 c0 ff ff ff ff 	movl   $0xffffffff,0xffffffc0(%ebp)
  109eb8:	e9 4b 03 00 00       	jmp    10a208 <ether_e100_attach+0x458>
    }
    dev->cusize = E100_CU_RING_SIZE * PAGE;
  109ebd:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  109ec0:	c7 80 a0 00 00 00 00 	movl   $0x20000,0xa0(%eax)
  109ec7:	00 02 00 
    dev->rusize = E100_RU_RING_SIZE * PAGE;
  109eca:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  109ecd:	c7 80 f0 00 00 00 00 	movl   $0x20000,0xf0(%eax)
  109ed4:	00 02 00 
    dev->eeprom_size = 6;
  109ed7:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  109eda:	c7 80 3c 01 00 00 06 	movl   $0x6,0x13c(%eax)
  109ee1:	00 00 00 
    ring_init(dev);
  109ee4:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  109ee7:	89 04 24             	mov    %eax,(%esp)
  109eea:	e8 81 09 00 00       	call   10a870 <ring_init>
//    dev->cuhead = 0;
//    dev->cuend = 0;

    pci_func_enable(pcif);
  109eef:	8b 45 08             	mov    0x8(%ebp),%eax
  109ef2:	89 04 24             	mov    %eax,(%esp)
  109ef5:	e8 c6 f7 ff ff       	call   1096c0 <pci_func_enable>
    initlock(&dev->culock, "e100 CU lock");
  109efa:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  109efd:	83 c0 68             	add    $0x68,%eax
  109f00:	c7 44 24 04 9f ab 11 	movl   $0x11ab9f,0x4(%esp)
  109f07:	00 
  109f08:	89 04 24             	mov    %eax,(%esp)
  109f0b:	e8 00 bc ff ff       	call   105b10 <initlock>
    initlock(&dev->rulock, "e100 RU lock");
  109f10:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  109f13:	05 b8 00 00 00       	add    $0xb8,%eax
  109f18:	c7 44 24 04 ac ab 11 	movl   $0x11abac,0x4(%esp)
  109f1f:	00 
  109f20:	89 04 24             	mov    %eax,(%esp)
  109f23:	e8 e8 bb ff ff       	call   105b10 <initlock>
    initlock(&dev->rxlock, "e100 RX lock");
  109f28:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  109f2b:	05 08 01 00 00       	add    $0x108,%eax
  109f30:	c7 44 24 04 b9 ab 11 	movl   $0x11abb9,0x4(%esp)
  109f37:	00 
  109f38:	89 04 24             	mov    %eax,(%esp)
  109f3b:	e8 d0 bb ff ff       	call   105b10 <initlock>
    dev->irq = pcif->irq_line;
  109f40:	8b 45 08             	mov    0x8(%ebp),%eax
  109f43:	0f b6 40 44          	movzbl 0x44(%eax),%eax
  109f47:	0f b6 d0             	movzbl %al,%edx
  109f4a:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  109f4d:	89 10                	mov    %edx,(%eax)
    int i;
    for (i=0; i<6; i++)
  109f4f:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  109f56:	eb 4b                	jmp    109fa3 <ether_e100_attach+0x1f3>
    {
        dev->regbase[i] = pcif->reg_base[i];
  109f58:	8b 4d ec             	mov    0xffffffec(%ebp),%ecx
  109f5b:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
  109f5e:	8b 45 08             	mov    0x8(%ebp),%eax
  109f61:	8b 54 90 14          	mov    0x14(%eax,%edx,4),%edx
  109f65:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  109f68:	89 54 88 04          	mov    %edx,0x4(%eax,%ecx,4)
        dev->regsize[i] = pcif->reg_size[i];
  109f6c:	8b 4d ec             	mov    0xffffffec(%ebp),%ecx
  109f6f:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
  109f72:	8b 45 08             	mov    0x8(%ebp),%eax
  109f75:	8b 54 90 2c          	mov    0x2c(%eax,%edx,4),%edx
  109f79:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  109f7c:	89 54 88 1c          	mov    %edx,0x1c(%eax,%ecx,4)
        if (dev->regsize[i] == E100_IOPORT_SIZE)
  109f80:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
  109f83:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  109f86:	8b 44 90 1c          	mov    0x1c(%eax,%edx,4),%eax
  109f8a:	83 f8 40             	cmp    $0x40,%eax
  109f8d:	75 10                	jne    109f9f <ether_e100_attach+0x1ef>
            dev->iobase = dev->regbase[i];
  109f8f:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
  109f92:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  109f95:	8b 54 90 04          	mov    0x4(%eax,%edx,4),%edx
  109f99:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  109f9c:	89 50 34             	mov    %edx,0x34(%eax)
  109f9f:	83 45 ec 01          	addl   $0x1,0xffffffec(%ebp)
  109fa3:	83 7d ec 05          	cmpl   $0x5,0xffffffec(%ebp)
  109fa7:	7e af                	jle    109f58 <ether_e100_attach+0x1a8>
    }
    e100_reset(dev);
  109fa9:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  109fac:	89 04 24             	mov    %eax,(%esp)
  109faf:	e8 ac 02 00 00       	call   10a260 <e100_reset>
    dev->cufirst = 1;
  109fb4:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  109fb7:	c7 80 a8 00 00 00 01 	movl   $0x1,0xa8(%eax)
  109fbe:	00 00 00 
    dev->cuidle = 1;
  109fc1:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  109fc4:	c7 80 ac 00 00 00 01 	movl   $0x1,0xac(%eax)
  109fcb:	00 00 00 
    e100_print_state(dev);
  109fce:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  109fd1:	89 04 24             	mov    %eax,(%esp)
  109fd4:	e8 b7 03 00 00       	call   10a390 <e100_print_state>

    uint16_t ma[3];
    e100_read_eeprom(dev, ma, 0, 3);
  109fd9:	c7 44 24 0c 03 00 00 	movl   $0x3,0xc(%esp)
  109fe0:	00 
  109fe1:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  109fe8:	00 
  109fe9:	8d 45 de             	lea    0xffffffde(%ebp),%eax
  109fec:	89 44 24 04          	mov    %eax,0x4(%esp)
  109ff0:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  109ff3:	89 04 24             	mov    %eax,(%esp)
  109ff6:	e8 e5 11 00 00       	call   10b1e0 <e100_read_eeprom>
    dev->macaddr[0] = ma[0] & 0xff;
  109ffb:	0f b7 45 de          	movzwl 0xffffffde(%ebp),%eax
  109fff:	89 c2                	mov    %eax,%edx
  10a001:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  10a004:	88 90 40 01 00 00    	mov    %dl,0x140(%eax)
    dev->macaddr[1] = (ma[0] >> 8) & 0xff;
  10a00a:	0f b7 45 de          	movzwl 0xffffffde(%ebp),%eax
  10a00e:	66 c1 e8 08          	shr    $0x8,%ax
  10a012:	89 c2                	mov    %eax,%edx
  10a014:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  10a017:	88 90 41 01 00 00    	mov    %dl,0x141(%eax)
    dev->macaddr[2] = ma[1] & 0xff;
  10a01d:	0f b7 45 e0          	movzwl 0xffffffe0(%ebp),%eax
  10a021:	89 c2                	mov    %eax,%edx
  10a023:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  10a026:	88 90 42 01 00 00    	mov    %dl,0x142(%eax)
    dev->macaddr[3] = (ma[1] >> 8) & 0xff;
  10a02c:	0f b7 45 e0          	movzwl 0xffffffe0(%ebp),%eax
  10a030:	66 c1 e8 08          	shr    $0x8,%ax
  10a034:	89 c2                	mov    %eax,%edx
  10a036:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  10a039:	88 90 43 01 00 00    	mov    %dl,0x143(%eax)
    dev->macaddr[4] = ma[2] & 0xff;
  10a03f:	0f b7 45 e2          	movzwl 0xffffffe2(%ebp),%eax
  10a043:	89 c2                	mov    %eax,%edx
  10a045:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  10a048:	88 90 44 01 00 00    	mov    %dl,0x144(%eax)
    dev->macaddr[5] = (ma[2] >> 8) & 0xff;
  10a04e:	0f b7 45 e2          	movzwl 0xffffffe2(%ebp),%eax
  10a052:	66 c1 e8 08          	shr    $0x8,%ax
  10a056:	89 c2                	mov    %eax,%edx
  10a058:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  10a05b:	88 90 45 01 00 00    	mov    %dl,0x145(%eax)
    cprintf("   MAC Address: %02x:%02x:%02x:%02x:%02x:%02x\n",
  10a061:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  10a064:	0f b6 80 45 01 00 00 	movzbl 0x145(%eax),%eax
  10a06b:	0f be d8             	movsbl %al,%ebx
  10a06e:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  10a071:	0f b6 80 44 01 00 00 	movzbl 0x144(%eax),%eax
  10a078:	0f be f0             	movsbl %al,%esi
  10a07b:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  10a07e:	0f b6 80 43 01 00 00 	movzbl 0x143(%eax),%eax
  10a085:	0f be f8             	movsbl %al,%edi
  10a088:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  10a08b:	0f b6 80 42 01 00 00 	movzbl 0x142(%eax),%eax
  10a092:	0f be d0             	movsbl %al,%edx
  10a095:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  10a098:	0f b6 80 41 01 00 00 	movzbl 0x141(%eax),%eax
  10a09f:	0f be c8             	movsbl %al,%ecx
  10a0a2:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  10a0a5:	0f b6 80 40 01 00 00 	movzbl 0x140(%eax),%eax
  10a0ac:	0f be c0             	movsbl %al,%eax
  10a0af:	89 5c 24 18          	mov    %ebx,0x18(%esp)
  10a0b3:	89 74 24 14          	mov    %esi,0x14(%esp)
  10a0b7:	89 7c 24 10          	mov    %edi,0x10(%esp)
  10a0bb:	89 54 24 0c          	mov    %edx,0xc(%esp)
  10a0bf:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  10a0c3:	89 44 24 04          	mov    %eax,0x4(%esp)
  10a0c7:	c7 04 24 c8 ab 11 00 	movl   $0x11abc8,(%esp)
  10a0ce:	e8 3d 66 ff ff       	call   100710 <cprintf>
            dev->macaddr[0],
            dev->macaddr[1],
            dev->macaddr[2],
            dev->macaddr[3],
            dev->macaddr[4],
            dev->macaddr[5]);

    struct ip_addr ipaddr;
    IP4_ADDR(&ipaddr, 192, 168, 1, 1);
  10a0d3:	c7 04 24 01 01 a8 c0 	movl   $0xc0a80101,(%esp)
  10a0da:	e8 e1 41 00 00       	call   10e2c0 <htonl>
  10a0df:	89 45 da             	mov    %eax,0xffffffda(%ebp)
    struct ip_addr netmask;
    IP4_ADDR(&netmask, 255, 255, 255, 0);
  10a0e2:	c7 04 24 00 ff ff ff 	movl   $0xffffff00,(%esp)
  10a0e9:	e8 d2 41 00 00       	call   10e2c0 <htonl>
  10a0ee:	89 45 d6             	mov    %eax,0xffffffd6(%ebp)
    struct ip_addr gw;
    IP4_ADDR(&gw, 192, 168, 1, 2);
  10a0f1:	c7 04 24 02 01 a8 c0 	movl   $0xc0a80102,(%esp)
  10a0f8:	e8 c3 41 00 00       	call   10e2c0 <htonl>
  10a0fd:	89 45 d2             	mov    %eax,0xffffffd2(%ebp)

    netif_add(&dev->netif, &ipaddr, &netmask, &gw, 0, ethernetif_init, ip_input);
  10a100:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
  10a103:	83 c2 38             	add    $0x38,%edx
  10a106:	c7 44 24 18 50 cb 10 	movl   $0x10cb50,0x18(%esp)
  10a10d:	00 
  10a10e:	c7 44 24 14 d0 c4 10 	movl   $0x10c4d0,0x14(%esp)
  10a115:	00 
  10a116:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  10a11d:	00 
  10a11e:	8d 45 d2             	lea    0xffffffd2(%ebp),%eax
  10a121:	89 44 24 0c          	mov    %eax,0xc(%esp)
  10a125:	8d 45 d6             	lea    0xffffffd6(%ebp),%eax
  10a128:	89 44 24 08          	mov    %eax,0x8(%esp)
  10a12c:	8d 45 da             	lea    0xffffffda(%ebp),%eax
  10a12f:	89 44 24 04          	mov    %eax,0x4(%esp)
  10a133:	89 14 24             	mov    %edx,(%esp)
  10a136:	e8 e5 49 00 00       	call   10eb20 <netif_add>
    struct ethernetif *eif = dev->netif.state;
  10a13b:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  10a13e:	8b 40 54             	mov    0x54(%eax),%eax
  10a141:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
    eif->receive = e100_receive;
  10a144:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10a147:	c7 40 08 60 ad 10 00 	movl   $0x10ad60,0x8(%eax)
    eif->send = e100_send;
  10a14e:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10a151:	c7 40 04 e0 ac 10 00 	movl   $0x10ace0,0x4(%eax)
    eif->ethaddr = dev->macaddr;
  10a158:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  10a15b:	05 40 01 00 00       	add    $0x140,%eax
  10a160:	89 c2                	mov    %eax,%edx
  10a162:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10a165:	89 10                	mov    %edx,(%eax)
    dev->netif.hwaddr_len = 6;
  10a167:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  10a16a:	c6 40 58 06          	movb   $0x6,0x58(%eax)
    memcpy(dev->netif.hwaddr, dev->macaddr, 6);
  10a16e:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  10a171:	05 40 01 00 00       	add    $0x140,%eax
  10a176:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
  10a179:	83 c2 59             	add    $0x59,%edx
  10a17c:	c7 44 24 08 06 00 00 	movl   $0x6,0x8(%esp)
  10a183:	00 
  10a184:	89 44 24 04          	mov    %eax,0x4(%esp)
  10a188:	89 14 24             	mov    %edx,(%esp)
  10a18b:	e8 30 bd ff ff       	call   105ec0 <memcpy>
    reg_irq_handler(dev->irq, e100_intr);
  10a190:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  10a193:	8b 00                	mov    (%eax),%eax
  10a195:	c7 44 24 04 f0 a5 10 	movl   $0x10a5f0,0x4(%esp)
  10a19c:	00 
  10a19d:	89 04 24             	mov    %eax,(%esp)
  10a1a0:	e8 eb 9f ff ff       	call   104190 <reg_irq_handler>
    pic_enable(dev->irq);
  10a1a5:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  10a1a8:	8b 00                	mov    (%eax),%eax
  10a1aa:	89 04 24             	mov    %eax,(%esp)
  10a1ad:	e8 6e a0 ff ff       	call   104220 <pic_enable>
    ioapic_enable(dev->irq, ncpu-1);
  10a1b2:	a1 0c dd 13 00       	mov    0x13dd0c,%eax
  10a1b7:	8d 50 ff             	lea    0xffffffff(%eax),%edx
  10a1ba:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  10a1bd:	8b 00                	mov    (%eax),%eax
  10a1bf:	89 54 24 04          	mov    %edx,0x4(%esp)
  10a1c3:	89 04 24             	mov    %eax,(%esp)
  10a1c6:	e8 a5 90 ff ff       	call   103270 <ioapic_enable>
    kproc_start(e100_rx_thread, dev, 0, 0, "[e100 rx thread]");
  10a1cb:	c7 44 24 10 f7 ab 11 	movl   $0x11abf7,0x10(%esp)
  10a1d2:	00 
  10a1d3:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  10a1da:	00 
  10a1db:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  10a1e2:	00 
  10a1e3:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  10a1e6:	89 44 24 04          	mov    %eax,0x4(%esp)
  10a1ea:	c7 04 24 50 af 10 00 	movl   $0x10af50,(%esp)
  10a1f1:	e8 ba f9 ff ff       	call   109bb0 <kproc_start>
    e100_ru_start(dev);
  10a1f6:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  10a1f9:	89 04 24             	mov    %eax,(%esp)
  10a1fc:	e8 1f 0b 00 00       	call   10ad20 <e100_ru_start>
    return 1;
  10a201:	c7 45 c0 01 00 00 00 	movl   $0x1,0xffffffc0(%ebp)
  10a208:	8b 45 c0             	mov    0xffffffc0(%ebp),%eax
}
  10a20b:	83 c4 5c             	add    $0x5c,%esp
  10a20e:	5b                   	pop    %ebx
  10a20f:	5e                   	pop    %esi
  10a210:	5f                   	pop    %edi
  10a211:	5d                   	pop    %ebp
  10a212:	c3                   	ret    
  10a213:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  10a219:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

0010a220 <delay>:

static void
delay(int n)
{
  10a220:	55                   	push   %ebp
  10a221:	89 e5                	mov    %esp,%ebp
  10a223:	83 ec 10             	sub    $0x10,%esp
    volatile int i;
    int j;
    for (j=0; j<n; j++)
  10a226:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
  10a22d:	eb 20                	jmp    10a24f <delay+0x2f>
    {
    for (i=0; i<1000; i++)
  10a22f:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)
  10a236:	eb 09                	jmp    10a241 <delay+0x21>
  10a238:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10a23b:	83 c0 01             	add    $0x1,%eax
  10a23e:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  10a241:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10a244:	3d e7 03 00 00       	cmp    $0x3e7,%eax
  10a249:	7e ed                	jle    10a238 <delay+0x18>
  10a24b:	83 45 fc 01          	addl   $0x1,0xfffffffc(%ebp)
  10a24f:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10a252:	3b 45 08             	cmp    0x8(%ebp),%eax
  10a255:	7c d8                	jl     10a22f <delay+0xf>
        ;
    }
}
  10a257:	c9                   	leave  
  10a258:	c3                   	ret    
  10a259:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

0010a260 <e100_reset>:

int
e100_reset(e100_dev *dev)
{
  10a260:	55                   	push   %ebp
  10a261:	89 e5                	mov    %esp,%ebp
  10a263:	83 ec 18             	sub    $0x18,%esp
    outl(dev->iobase + SCB_PORT, PORT_SOFT_RESET);
  10a266:	8b 45 08             	mov    0x8(%ebp),%eax
  10a269:	8b 40 34             	mov    0x34(%eax),%eax
  10a26c:	83 c0 08             	add    $0x8,%eax
  10a26f:	0f b7 c0             	movzwl %ax,%eax
  10a272:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  10a279:	00 
  10a27a:	89 04 24             	mov    %eax,(%esp)
  10a27d:	e8 4e 00 00 00       	call   10a2d0 <outl>
    delay(10);
  10a282:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
  10a289:	e8 92 ff ff ff       	call   10a220 <delay>
    scb_command_word cmd;
    cmd.word = 0;
  10a28e:	66 c7 45 fe 00 00    	movw   $0x0,0xfffffffe(%ebp)
    cmd.cmd.cu_command = CUC_DUMP_RESET;
  10a294:	0f b6 45 fe          	movzbl 0xfffffffe(%ebp),%eax
  10a298:	83 e0 0f             	and    $0xf,%eax
  10a29b:	83 c8 70             	or     $0x70,%eax
  10a29e:	88 45 fe             	mov    %al,0xfffffffe(%ebp)
    outw(dev->iobase + SCB_COMMAND, cmd.word);
  10a2a1:	0f b7 45 fe          	movzwl 0xfffffffe(%ebp),%eax
  10a2a5:	0f b7 d0             	movzwl %ax,%edx
  10a2a8:	8b 45 08             	mov    0x8(%ebp),%eax
  10a2ab:	8b 40 34             	mov    0x34(%eax),%eax
  10a2ae:	83 c0 02             	add    $0x2,%eax
  10a2b1:	0f b7 c0             	movzwl %ax,%eax
  10a2b4:	89 54 24 04          	mov    %edx,0x4(%esp)
  10a2b8:	89 04 24             	mov    %eax,(%esp)
  10a2bb:	e8 30 00 00 00       	call   10a2f0 <outw>
    return 0;
  10a2c0:	b8 00 00 00 00       	mov    $0x0,%eax
}
  10a2c5:	c9                   	leave  
  10a2c6:	c3                   	ret    
  10a2c7:	89 f6                	mov    %esi,%esi
  10a2c9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

0010a2d0 <outl>:
}

static inline void
outl(ushort port, uint data)
{
  10a2d0:	55                   	push   %ebp
  10a2d1:	89 e5                	mov    %esp,%ebp
  10a2d3:	83 ec 04             	sub    $0x4,%esp
  10a2d6:	8b 45 08             	mov    0x8(%ebp),%eax
  10a2d9:	66 89 45 fc          	mov    %ax,0xfffffffc(%ebp)
    asm volatile("out %0,%1" : : "a" (data), "d" (port));
  10a2dd:	8b 45 0c             	mov    0xc(%ebp),%eax
  10a2e0:	0f b7 55 fc          	movzwl 0xfffffffc(%ebp),%edx
  10a2e4:	ef                   	out    %eax,(%dx)
}
  10a2e5:	c9                   	leave  
  10a2e6:	c3                   	ret    
  10a2e7:	89 f6                	mov    %esi,%esi
  10a2e9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

0010a2f0 <outw>:
  10a2f0:	55                   	push   %ebp
  10a2f1:	89 e5                	mov    %esp,%ebp
  10a2f3:	83 ec 08             	sub    $0x8,%esp
  10a2f6:	8b 45 08             	mov    0x8(%ebp),%eax
  10a2f9:	8b 55 0c             	mov    0xc(%ebp),%edx
  10a2fc:	66 89 45 fc          	mov    %ax,0xfffffffc(%ebp)
  10a300:	66 89 55 f8          	mov    %dx,0xfffffff8(%ebp)
  10a304:	0f b7 45 f8          	movzwl 0xfffffff8(%ebp),%eax
  10a308:	0f b7 55 fc          	movzwl 0xfffffffc(%ebp),%edx
  10a30c:	66 ef                	out    %ax,(%dx)
  10a30e:	c9                   	leave  
  10a30f:	c3                   	ret    

0010a310 <e100_get_state>:

scb_status_word
e100_get_state(e100_dev *dev)
{
  10a310:	55                   	push   %ebp
  10a311:	89 e5                	mov    %esp,%ebp
  10a313:	83 ec 18             	sub    $0x18,%esp
    scb_status_word st;
    st.word = inw(dev->iobase + SCB_STATUS);
  10a316:	8b 45 08             	mov    0x8(%ebp),%eax
  10a319:	8b 40 34             	mov    0x34(%eax),%eax
  10a31c:	0f b7 c0             	movzwl %ax,%eax
  10a31f:	89 04 24             	mov    %eax,(%esp)
  10a322:	e8 19 00 00 00       	call   10a340 <inw>
  10a327:	66 89 45 fe          	mov    %ax,0xfffffffe(%ebp)
    return st;
  10a32b:	0f b7 45 fe          	movzwl 0xfffffffe(%ebp),%eax
}
  10a32f:	c9                   	leave  
  10a330:	c3                   	ret    
  10a331:	eb 0d                	jmp    10a340 <inw>
  10a333:	90                   	nop    
  10a334:	90                   	nop    
  10a335:	90                   	nop    
  10a336:	90                   	nop    
  10a337:	90                   	nop    
  10a338:	90                   	nop    
  10a339:	90                   	nop    
  10a33a:	90                   	nop    
  10a33b:	90                   	nop    
  10a33c:	90                   	nop    
  10a33d:	90                   	nop    
  10a33e:	90                   	nop    
  10a33f:	90                   	nop    

0010a340 <inw>:
}

static inline ushort
inw(ushort port)
{
  10a340:	55                   	push   %ebp
  10a341:	89 e5                	mov    %esp,%ebp
  10a343:	83 ec 14             	sub    $0x14,%esp
  10a346:	8b 45 08             	mov    0x8(%ebp),%eax
  10a349:	66 89 45 ec          	mov    %ax,0xffffffec(%ebp)
    ushort data;

    asm volatile("in %1,%0" : "=a" (data) : "d" (port));
  10a34d:	0f b7 55 ec          	movzwl 0xffffffec(%ebp),%edx
  10a351:	66 ed                	in     (%dx),%ax
  10a353:	66 89 45 fe          	mov    %ax,0xfffffffe(%ebp)
    return data;
  10a357:	0f b7 45 fe          	movzwl 0xfffffffe(%ebp),%eax
}
  10a35b:	c9                   	leave  
  10a35c:	c3                   	ret    
  10a35d:	8d 76 00             	lea    0x0(%esi),%esi

0010a360 <e100_put_state>:

void
e100_put_state(e100_dev *dev, scb_status_word stat)
{
  10a360:	55                   	push   %ebp
  10a361:	89 e5                	mov    %esp,%ebp
  10a363:	83 ec 08             	sub    $0x8,%esp
    outw(dev->iobase + SCB_STATUS, stat.word);
  10a366:	0f b7 45 0c          	movzwl 0xc(%ebp),%eax
  10a36a:	0f b7 d0             	movzwl %ax,%edx
  10a36d:	8b 45 08             	mov    0x8(%ebp),%eax
  10a370:	8b 40 34             	mov    0x34(%eax),%eax
  10a373:	0f b7 c0             	movzwl %ax,%eax
  10a376:	89 54 24 04          	mov    %edx,0x4(%esp)
  10a37a:	89 04 24             	mov    %eax,(%esp)
  10a37d:	e8 6e ff ff ff       	call   10a2f0 <outw>
}
  10a382:	c9                   	leave  
  10a383:	c3                   	ret    
  10a384:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  10a38a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

0010a390 <e100_print_state>:

scb_status_word
e100_print_state(e100_dev *dev)
{
  10a390:	55                   	push   %ebp
  10a391:	89 e5                	mov    %esp,%ebp
  10a393:	83 ec 18             	sub    $0x18,%esp
    scb_status_word state = e100_get_state(dev);
  10a396:	8b 45 08             	mov    0x8(%ebp),%eax
  10a399:	89 04 24             	mov    %eax,(%esp)
  10a39c:	e8 6f ff ff ff       	call   10a310 <e100_get_state>
  10a3a1:	66 89 45 fe          	mov    %ax,0xfffffffe(%ebp)
    cprintf("   RU Status: %s\n", ru_state_name[state.status.rus]);
  10a3a5:	0f b6 45 fe          	movzbl 0xfffffffe(%ebp),%eax
  10a3a9:	c1 e0 02             	shl    $0x2,%eax
  10a3ac:	c0 f8 04             	sar    $0x4,%al
  10a3af:	0f be c0             	movsbl %al,%eax
  10a3b2:	8b 04 85 60 cb 11 00 	mov    0x11cb60(,%eax,4),%eax
  10a3b9:	89 44 24 04          	mov    %eax,0x4(%esp)
  10a3bd:	c7 04 24 08 ac 11 00 	movl   $0x11ac08,(%esp)
  10a3c4:	e8 47 63 ff ff       	call   100710 <cprintf>
    cprintf("   CU Status: %s\n", cu_state_name[state.status.cus]);
  10a3c9:	0f b6 45 fe          	movzbl 0xfffffffe(%ebp),%eax
  10a3cd:	c0 f8 06             	sar    $0x6,%al
  10a3d0:	0f be c0             	movsbl %al,%eax
  10a3d3:	8b 04 85 40 cb 11 00 	mov    0x11cb40(,%eax,4),%eax
  10a3da:	89 44 24 04          	mov    %eax,0x4(%esp)
  10a3de:	c7 04 24 1a ac 11 00 	movl   $0x11ac1a,(%esp)
  10a3e5:	e8 26 63 ff ff       	call   100710 <cprintf>

    struct scb_status_word stat = state.status;
  10a3ea:	0f b7 45 fe          	movzwl 0xfffffffe(%ebp),%eax
  10a3ee:	66 89 45 fc          	mov    %ax,0xfffffffc(%ebp)
    if (stat.cx) cprintf("   CU executed\n");
  10a3f2:	0f b6 45 fd          	movzbl 0xfffffffd(%ebp),%eax
  10a3f6:	83 e0 80             	and    $0xffffff80,%eax
  10a3f9:	84 c0                	test   %al,%al
  10a3fb:	74 0c                	je     10a409 <e100_print_state+0x79>
  10a3fd:	c7 04 24 2c ac 11 00 	movl   $0x11ac2c,(%esp)
  10a404:	e8 07 63 ff ff       	call   100710 <cprintf>
    if (stat.fr)
  10a409:	0f b6 45 fd          	movzbl 0xfffffffd(%ebp),%eax
  10a40d:	83 e0 40             	and    $0x40,%eax
  10a410:	84 c0                	test   %al,%al
  10a412:	74 0c                	je     10a420 <e100_print_state+0x90>
        cprintf("   RU received\n");
  10a414:	c7 04 24 3c ac 11 00 	movl   $0x11ac3c,(%esp)
  10a41b:	e8 f0 62 ff ff       	call   100710 <cprintf>
    if (stat.cna)
  10a420:	0f b6 45 fd          	movzbl 0xfffffffd(%ebp),%eax
  10a424:	83 e0 20             	and    $0x20,%eax
  10a427:	84 c0                	test   %al,%al
  10a429:	74 0c                	je     10a437 <e100_print_state+0xa7>
        cprintf("   CU state change\n");
  10a42b:	c7 04 24 4c ac 11 00 	movl   $0x11ac4c,(%esp)
  10a432:	e8 d9 62 ff ff       	call   100710 <cprintf>
    if (stat.rnr)
  10a437:	0f b6 45 fd          	movzbl 0xfffffffd(%ebp),%eax
  10a43b:	83 e0 10             	and    $0x10,%eax
  10a43e:	84 c0                	test   %al,%al
  10a440:	74 0c                	je     10a44e <e100_print_state+0xbe>
        cprintf("   RU not ready\n");
  10a442:	c7 04 24 60 ac 11 00 	movl   $0x11ac60,(%esp)
  10a449:	e8 c2 62 ff ff       	call   100710 <cprintf>
    if (stat.mdi)
  10a44e:	0f b6 45 fd          	movzbl 0xfffffffd(%ebp),%eax
  10a452:	83 e0 08             	and    $0x8,%eax
  10a455:	84 c0                	test   %al,%al
  10a457:	74 0c                	je     10a465 <e100_print_state+0xd5>
        cprintf("   MDI operation completed\n");
  10a459:	c7 04 24 71 ac 11 00 	movl   $0x11ac71,(%esp)
  10a460:	e8 ab 62 ff ff       	call   100710 <cprintf>
    if (stat.swi)
  10a465:	0f b6 45 fd          	movzbl 0xfffffffd(%ebp),%eax
  10a469:	83 e0 04             	and    $0x4,%eax
  10a46c:	84 c0                	test   %al,%al
  10a46e:	74 0c                	je     10a47c <e100_print_state+0xec>
        cprintf("   Software Interrupt\n");
  10a470:	c7 04 24 8d ac 11 00 	movl   $0x11ac8d,(%esp)
  10a477:	e8 94 62 ff ff       	call   100710 <cprintf>
    if (stat.fcp)
  10a47c:	0f b6 45 fd          	movzbl 0xfffffffd(%ebp),%eax
  10a480:	83 e0 01             	and    $0x1,%eax
  10a483:	84 c0                	test   %al,%al
  10a485:	74 0c                	je     10a493 <e100_print_state+0x103>
        cprintf("   Flow Control Pause\n");
  10a487:	c7 04 24 a4 ac 11 00 	movl   $0x11aca4,(%esp)
  10a48e:	e8 7d 62 ff ff       	call   100710 <cprintf>

    return state;
  10a493:	0f b7 45 fe          	movzwl 0xfffffffe(%ebp),%eax
}
  10a497:	c9                   	leave  
  10a498:	c3                   	ret    
  10a499:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

0010a4a0 <e100_read_scb_command>:

char *cu_state_name[4] = {
    "Idle",
    "Suspended",
    "LPQ Active",
    "HQP Active",
};

char *ru_state_name[16] = {
    "Idle",
    "Suspended",
    "No resources",
    "Reserved",
    "Ready",
    "Reserved",
    "Reserved",
    "Reserved",
    "Reserved",
    "Reserved",
    "Reserved",
    "Reserved",
    "Reserved",
    "Reserved",
    "Reserved",
    "Reserved",
};

uint8_t
e100_read_scb_command(e100_dev *dev)
{
  10a4a0:	55                   	push   %ebp
  10a4a1:	89 e5                	mov    %esp,%ebp
  10a4a3:	83 ec 08             	sub    $0x8,%esp
    return inb(dev->iobase + SCB_COMMAND + 1);
  10a4a6:	8b 45 08             	mov    0x8(%ebp),%eax
  10a4a9:	8b 40 34             	mov    0x34(%eax),%eax
  10a4ac:	83 c0 03             	add    $0x3,%eax
  10a4af:	0f b7 c0             	movzwl %ax,%eax
  10a4b2:	89 04 24             	mov    %eax,(%esp)
  10a4b5:	e8 06 00 00 00       	call   10a4c0 <inb>
  10a4ba:	0f b6 c0             	movzbl %al,%eax
}
  10a4bd:	c9                   	leave  
  10a4be:	c3                   	ret    
  10a4bf:	90                   	nop    

0010a4c0 <inb>:
// Routines to let C code use special x86 instructions.

static inline uchar
inb(ushort port)
{
  10a4c0:	55                   	push   %ebp
  10a4c1:	89 e5                	mov    %esp,%ebp
  10a4c3:	83 ec 14             	sub    $0x14,%esp
  10a4c6:	8b 45 08             	mov    0x8(%ebp),%eax
  10a4c9:	66 89 45 ec          	mov    %ax,0xffffffec(%ebp)
  uchar data;

  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
  10a4cd:	0f b7 55 ec          	movzwl 0xffffffec(%ebp),%edx
  10a4d1:	ec                   	in     (%dx),%al
  10a4d2:	88 45 ff             	mov    %al,0xffffffff(%ebp)
  return data;
  10a4d5:	0f b6 45 ff          	movzbl 0xffffffff(%ebp),%eax
}
  10a4d9:	c9                   	leave  
  10a4da:	c3                   	ret    
  10a4db:	90                   	nop    
  10a4dc:	8d 74 26 00          	lea    0x0(%esi),%esi

0010a4e0 <e100_set_gp>:

void
e100_set_gp(e100_dev *dev, void *addr)
{
  10a4e0:	55                   	push   %ebp
  10a4e1:	89 e5                	mov    %esp,%ebp
  10a4e3:	83 ec 08             	sub    $0x8,%esp
    outl(dev->iobase + SCB_GENPTR, (uint32_t)addr);
  10a4e6:	8b 45 0c             	mov    0xc(%ebp),%eax
  10a4e9:	89 c2                	mov    %eax,%edx
  10a4eb:	8b 45 08             	mov    0x8(%ebp),%eax
  10a4ee:	8b 40 34             	mov    0x34(%eax),%eax
  10a4f1:	83 c0 04             	add    $0x4,%eax
  10a4f4:	0f b7 c0             	movzwl %ax,%eax
  10a4f7:	89 54 24 04          	mov    %edx,0x4(%esp)
  10a4fb:	89 04 24             	mov    %eax,(%esp)
  10a4fe:	e8 cd fd ff ff       	call   10a2d0 <outl>
}
  10a503:	c9                   	leave  
  10a504:	c3                   	ret    
  10a505:	8d 74 26 00          	lea    0x0(%esi),%esi
  10a509:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

0010a510 <e100_cu_command>:

void
e100_cu_command(e100_dev *dev, int command, void *cmd_addr)
{
  10a510:	55                   	push   %ebp
  10a511:	89 e5                	mov    %esp,%ebp
  10a513:	83 ec 18             	sub    $0x18,%esp
    scb_command_word cmd;
    cmd.word = 0;
  10a516:	66 c7 45 fe 00 00    	movw   $0x0,0xfffffffe(%ebp)
    cmd.cmd.cu_command = command;
  10a51c:	8b 45 0c             	mov    0xc(%ebp),%eax
  10a51f:	c1 e0 04             	shl    $0x4,%eax
  10a522:	c0 f8 04             	sar    $0x4,%al
  10a525:	89 c2                	mov    %eax,%edx
  10a527:	c1 e2 04             	shl    $0x4,%edx
  10a52a:	0f b6 45 fe          	movzbl 0xfffffffe(%ebp),%eax
  10a52e:	83 e0 0f             	and    $0xf,%eax
  10a531:	09 d0                	or     %edx,%eax
  10a533:	88 45 fe             	mov    %al,0xfffffffe(%ebp)
    e100_set_gp(dev, cmd_addr);
  10a536:	8b 45 10             	mov    0x10(%ebp),%eax
  10a539:	89 44 24 04          	mov    %eax,0x4(%esp)
  10a53d:	8b 45 08             	mov    0x8(%ebp),%eax
  10a540:	89 04 24             	mov    %eax,(%esp)
  10a543:	e8 98 ff ff ff       	call   10a4e0 <e100_set_gp>
    outw(dev->iobase + SCB_COMMAND, cmd.word);
  10a548:	0f b7 45 fe          	movzwl 0xfffffffe(%ebp),%eax
  10a54c:	0f b7 d0             	movzwl %ax,%edx
  10a54f:	8b 45 08             	mov    0x8(%ebp),%eax
  10a552:	8b 40 34             	mov    0x34(%eax),%eax
  10a555:	83 c0 02             	add    $0x2,%eax
  10a558:	0f b7 c0             	movzwl %ax,%eax
  10a55b:	89 54 24 04          	mov    %edx,0x4(%esp)
  10a55f:	89 04 24             	mov    %eax,(%esp)
  10a562:	e8 89 fd ff ff       	call   10a2f0 <outw>
    while (e100_read_scb_command(dev)) ;
  10a567:	8b 45 08             	mov    0x8(%ebp),%eax
  10a56a:	89 04 24             	mov    %eax,(%esp)
  10a56d:	e8 2e ff ff ff       	call   10a4a0 <e100_read_scb_command>
  10a572:	84 c0                	test   %al,%al
  10a574:	75 f1                	jne    10a567 <e100_cu_command+0x57>
}
  10a576:	c9                   	leave  
  10a577:	c3                   	ret    
  10a578:	90                   	nop    
  10a579:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

0010a580 <e100_ru_command>:

void
e100_ru_command(e100_dev *dev, int command, void *cmd_addr)
{
  10a580:	55                   	push   %ebp
  10a581:	89 e5                	mov    %esp,%ebp
  10a583:	83 ec 18             	sub    $0x18,%esp
    scb_command_word cmd;
    cmd.word = 0;
  10a586:	66 c7 45 fe 00 00    	movw   $0x0,0xfffffffe(%ebp)
    cmd.cmd.ru_command = command;
  10a58c:	8b 45 0c             	mov    0xc(%ebp),%eax
  10a58f:	c1 e0 05             	shl    $0x5,%eax
  10a592:	c0 f8 05             	sar    $0x5,%al
  10a595:	89 c2                	mov    %eax,%edx
  10a597:	83 e2 07             	and    $0x7,%edx
  10a59a:	0f b6 45 fe          	movzbl 0xfffffffe(%ebp),%eax
  10a59e:	83 e0 f8             	and    $0xfffffff8,%eax
  10a5a1:	09 d0                	or     %edx,%eax
  10a5a3:	88 45 fe             	mov    %al,0xfffffffe(%ebp)
    e100_set_gp(dev, cmd_addr);
  10a5a6:	8b 45 10             	mov    0x10(%ebp),%eax
  10a5a9:	89 44 24 04          	mov    %eax,0x4(%esp)
  10a5ad:	8b 45 08             	mov    0x8(%ebp),%eax
  10a5b0:	89 04 24             	mov    %eax,(%esp)
  10a5b3:	e8 28 ff ff ff       	call   10a4e0 <e100_set_gp>
    outw(dev->iobase + SCB_COMMAND, cmd.word);
  10a5b8:	0f b7 45 fe          	movzwl 0xfffffffe(%ebp),%eax
  10a5bc:	0f b7 d0             	movzwl %ax,%edx
  10a5bf:	8b 45 08             	mov    0x8(%ebp),%eax
  10a5c2:	8b 40 34             	mov    0x34(%eax),%eax
  10a5c5:	83 c0 02             	add    $0x2,%eax
  10a5c8:	0f b7 c0             	movzwl %ax,%eax
  10a5cb:	89 54 24 04          	mov    %edx,0x4(%esp)
  10a5cf:	89 04 24             	mov    %eax,(%esp)
  10a5d2:	e8 19 fd ff ff       	call   10a2f0 <outw>
    while (e100_read_scb_command(dev)) ;
  10a5d7:	8b 45 08             	mov    0x8(%ebp),%eax
  10a5da:	89 04 24             	mov    %eax,(%esp)
  10a5dd:	e8 be fe ff ff       	call   10a4a0 <e100_read_scb_command>
  10a5e2:	84 c0                	test   %al,%al
  10a5e4:	75 f1                	jne    10a5d7 <e100_ru_command+0x57>
}
  10a5e6:	c9                   	leave  
  10a5e7:	c3                   	ret    
  10a5e8:	90                   	nop    
  10a5e9:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

0010a5f0 <e100_intr>:

// Interrupt
void
e100_intr(struct trapframe *tf)
{
  10a5f0:	55                   	push   %ebp
  10a5f1:	89 e5                	mov    %esp,%ebp
  10a5f3:	83 ec 28             	sub    $0x28,%esp
//    cprintf("e100_intr\n");
    int i;
    int index = -1;
  10a5f6:	c7 45 f8 ff ff ff ff 	movl   $0xffffffff,0xfffffff8(%ebp)
    for (i=0; i< dev_count; i++)
  10a5fd:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
  10a604:	eb 28                	jmp    10a62e <e100_intr+0x3e>
    {
        if (tf->trapno == IRQ_OFFSET + e100_devs[i].irq)
  10a606:	8b 45 08             	mov    0x8(%ebp),%eax
  10a609:	8b 50 28             	mov    0x28(%eax),%edx
  10a60c:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10a60f:	69 c0 48 01 00 00    	imul   $0x148,%eax,%eax
  10a615:	8b 80 e0 cd 11 00    	mov    0x11cde0(%eax),%eax
  10a61b:	83 c0 20             	add    $0x20,%eax
  10a61e:	39 c2                	cmp    %eax,%edx
  10a620:	75 08                	jne    10a62a <e100_intr+0x3a>
        {
            index = i;
  10a622:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10a625:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
            break;
  10a628:	eb 0e                	jmp    10a638 <e100_intr+0x48>
  10a62a:	83 45 f4 01          	addl   $0x1,0xfffffff4(%ebp)
  10a62e:	a1 c0 cd 11 00       	mov    0x11cdc0,%eax
  10a633:	39 45 f4             	cmp    %eax,0xfffffff4(%ebp)
  10a636:	7c ce                	jl     10a606 <e100_intr+0x16>
        }
    }
    if (index == -1)
  10a638:	83 7d f8 ff          	cmpl   $0xffffffff,0xfffffff8(%ebp)
  10a63c:	75 11                	jne    10a64f <e100_intr+0x5f>
    {
        cprintf("e100_intr: can't find corresponding device\n");
  10a63e:	c7 04 24 fc ac 11 00 	movl   $0x11acfc,(%esp)
  10a645:	e8 c6 60 ff ff       	call   100710 <cprintf>
        return;
  10a64a:	e9 ce 01 00 00       	jmp    10a81d <e100_intr+0x22d>
    }
    e100_dev *dev = &e100_devs[index];
  10a64f:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10a652:	69 c0 48 01 00 00    	imul   $0x148,%eax,%eax
  10a658:	05 e0 cd 11 00       	add    $0x11cde0,%eax
  10a65d:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
//    e100_print_state(dev);
    scb_status_word state = e100_get_state(dev);
  10a660:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10a663:	89 04 24             	mov    %eax,(%esp)
  10a666:	e8 a5 fc ff ff       	call   10a310 <e100_get_state>
  10a66b:	66 89 45 f2          	mov    %ax,0xfffffff2(%ebp)
    struct scb_status_word stat = state.status;
  10a66f:	0f b7 45 f2          	movzwl 0xfffffff2(%ebp),%eax
  10a673:	66 89 45 f0          	mov    %ax,0xfffffff0(%ebp)
    state.word |= 0xff00;
  10a677:	0f b7 45 f2          	movzwl 0xfffffff2(%ebp),%eax
  10a67b:	66 0d 00 ff          	or     $0xff00,%ax
  10a67f:	66 89 45 f2          	mov    %ax,0xfffffff2(%ebp)
    e100_put_state(dev, state);
  10a683:	0f b7 45 f2          	movzwl 0xfffffff2(%ebp),%eax
  10a687:	66 89 44 24 04       	mov    %ax,0x4(%esp)
  10a68c:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10a68f:	89 04 24             	mov    %eax,(%esp)
  10a692:	e8 c9 fc ff ff       	call   10a360 <e100_put_state>

    if (stat.cx)
    {
//        cprintf("   CU executed\n");
    }
    if (stat.fr)
  10a697:	0f b6 45 f1          	movzbl 0xfffffff1(%ebp),%eax
  10a69b:	83 e0 40             	and    $0x40,%eax
  10a69e:	84 c0                	test   %al,%al
  10a6a0:	74 3f                	je     10a6e1 <e100_intr+0xf1>
    {
        if (!dev->ru_first)
  10a6a2:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10a6a5:	8b 80 f8 00 00 00    	mov    0xf8(%eax),%eax
  10a6ab:	85 c0                	test   %eax,%eax
  10a6ad:	75 22                	jne    10a6d1 <e100_intr+0xe1>
        {
            dev->ru_first = dev->ru_last;
  10a6af:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10a6b2:	8b 90 fc 00 00 00    	mov    0xfc(%eax),%edx
  10a6b8:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10a6bb:	89 90 f8 00 00 00    	mov    %edx,0xf8(%eax)
            wakeup(&dev->ru_first);
  10a6c1:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10a6c4:	05 f8 00 00 00       	add    $0xf8,%eax
  10a6c9:	89 04 24             	mov    %eax,(%esp)
  10a6cc:	e8 4f af ff ff       	call   105620 <wakeup>
        }
        wakeup(&dev->rxlock);
  10a6d1:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10a6d4:	05 08 01 00 00       	add    $0x108,%eax
  10a6d9:	89 04 24             	mov    %eax,(%esp)
  10a6dc:	e8 3f af ff ff       	call   105620 <wakeup>
/*        while (dev->ru_last->eof)
        {
            ethernetif_input(&dev->netif);
            dev->ru_last = (void*)dev->ru_last->head.link;
        }*/
    }
    if (stat.cna)
  10a6e1:	0f b6 45 f1          	movzbl 0xfffffff1(%ebp),%eax
  10a6e5:	83 e0 20             	and    $0x20,%eax
  10a6e8:	84 c0                	test   %al,%al
  10a6ea:	0f 84 c4 00 00 00    	je     10a7b4 <e100_intr+0x1c4>
    {
/*        if (dev->cu_next_pkt != 0)
        {
            cprintf("   finished 0x%08x\n", dev->cu_next_pkt);
            if (dev->cu_next_pkt->link != 0)
            {
                cprintf("   starting next packet: "
                        "0x%08x\n", dev->cu_next_pkt->link);
                e100_cu_command(dev, CUC_START, 
                        (void*)dev->cu_next_pkt->link);
                dev->cuhead = dev->cu_next_pkt->link - dev->cubase;
                dev->cu_next_pkt = (command_block *)dev->cu_next_pkt->link;
            }
            else
            {
                dev->cuhead = dev->cuend;
                dev->cu_last_pkt = 0;
                dev->cu_next_pkt = 0;
            }
            ring_printinfo(dev);
        }*/
        if (dev->cu_last_pkt)
  10a6f0:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10a6f3:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
  10a6f9:	85 c0                	test   %eax,%eax
  10a6fb:	0f 84 b3 00 00 00    	je     10a7b4 <e100_intr+0x1c4>
        {
            if (dev->cu_last_pkt->c)
  10a701:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10a704:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
  10a70a:	8b 00                	mov    (%eax),%eax
  10a70c:	25 00 80 00 00       	and    $0x8000,%eax
  10a711:	85 c0                	test   %eax,%eax
  10a713:	74 1f                	je     10a734 <e100_intr+0x144>
            {
                dev->cuidle = 1;
  10a715:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10a718:	c7 80 ac 00 00 00 01 	movl   $0x1,0xac(%eax)
  10a71f:	00 00 00 
//                dev->cuhead = dev->cuend;
                dev->cu_next_pkt = 0;
  10a722:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10a725:	c7 80 b4 00 00 00 00 	movl   $0x0,0xb4(%eax)
  10a72c:	00 00 00 
  10a72f:	e9 80 00 00 00       	jmp    10a7b4 <e100_intr+0x1c4>
//                dev->cu_last_pkt = 0;
            } else {
                dev->cuidle = 0;
  10a734:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10a737:	c7 80 ac 00 00 00 00 	movl   $0x0,0xac(%eax)
  10a73e:	00 00 00 
                while (dev->cu_next_pkt->c)
  10a741:	eb 42                	jmp    10a785 <e100_intr+0x195>
                {
                    if (!dev->cu_next_pkt->ok)
  10a743:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10a746:	8b 80 b4 00 00 00    	mov    0xb4(%eax),%eax
  10a74c:	8b 00                	mov    (%eax),%eax
  10a74e:	25 00 20 00 00       	and    $0x2000,%eax
  10a753:	85 c0                	test   %eax,%eax
  10a755:	75 19                	jne    10a770 <e100_intr+0x180>
                        cprintf("send error 0x%08x\n", dev->cu_next_pkt);
  10a757:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10a75a:	8b 80 b4 00 00 00    	mov    0xb4(%eax),%eax
  10a760:	89 44 24 04          	mov    %eax,0x4(%esp)
  10a764:	c7 04 24 28 ad 11 00 	movl   $0x11ad28,(%esp)
  10a76b:	e8 a0 5f ff ff       	call   100710 <cprintf>
                    dev->cu_next_pkt = (void*)dev->cu_next_pkt->link;
  10a770:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10a773:	8b 80 b4 00 00 00    	mov    0xb4(%eax),%eax
  10a779:	8b 50 04             	mov    0x4(%eax),%edx
  10a77c:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10a77f:	89 90 b4 00 00 00    	mov    %edx,0xb4(%eax)
  10a785:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10a788:	8b 80 b4 00 00 00    	mov    0xb4(%eax),%eax
  10a78e:	8b 00                	mov    (%eax),%eax
  10a790:	25 00 80 00 00       	and    $0x8000,%eax
  10a795:	85 c0                	test   %eax,%eax
  10a797:	75 aa                	jne    10a743 <e100_intr+0x153>
                }
                e100_cu_command(dev, CUC_RESUME, 0);
  10a799:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  10a7a0:	00 
  10a7a1:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
  10a7a8:	00 
  10a7a9:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10a7ac:	89 04 24             	mov    %eax,(%esp)
  10a7af:	e8 5c fd ff ff       	call   10a510 <e100_cu_command>
//                dev->cuhead = (uint32_t)dev->cu_next_pkt - dev->cubase;
            }
        }
//        ring_printinfo(dev);
    }
    if (stat.rnr)
  10a7b4:	0f b6 45 f1          	movzbl 0xfffffff1(%ebp),%eax
  10a7b8:	83 e0 10             	and    $0x10,%eax
  10a7bb:	84 c0                	test   %al,%al
  10a7bd:	74 19                	je     10a7d8 <e100_intr+0x1e8>
    {
        cprintf("e100: RU overrun!\n");
  10a7bf:	c7 04 24 3b ad 11 00 	movl   $0x11ad3b,(%esp)
  10a7c6:	e8 45 5f ff ff       	call   100710 <cprintf>
        dev->ru_full = 1;
  10a7cb:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10a7ce:	c7 80 04 01 00 00 01 	movl   $0x1,0x104(%eax)
  10a7d5:	00 00 00 
    }
    if (stat.mdi)
  10a7d8:	0f b6 45 f1          	movzbl 0xfffffff1(%ebp),%eax
  10a7dc:	83 e0 08             	and    $0x8,%eax
  10a7df:	84 c0                	test   %al,%al
  10a7e1:	74 0c                	je     10a7ef <e100_intr+0x1ff>
        cprintf("   MDI operation completed\n");
  10a7e3:	c7 04 24 71 ac 11 00 	movl   $0x11ac71,(%esp)
  10a7ea:	e8 21 5f ff ff       	call   100710 <cprintf>
    if (stat.swi)
  10a7ef:	0f b6 45 f1          	movzbl 0xfffffff1(%ebp),%eax
  10a7f3:	83 e0 04             	and    $0x4,%eax
  10a7f6:	84 c0                	test   %al,%al
  10a7f8:	74 0c                	je     10a806 <e100_intr+0x216>
        cprintf("   Software Interrupt\n");
  10a7fa:	c7 04 24 8d ac 11 00 	movl   $0x11ac8d,(%esp)
  10a801:	e8 0a 5f ff ff       	call   100710 <cprintf>
    if (stat.fcp)
  10a806:	0f b6 45 f1          	movzbl 0xfffffff1(%ebp),%eax
  10a80a:	83 e0 01             	and    $0x1,%eax
  10a80d:	84 c0                	test   %al,%al
  10a80f:	74 0c                	je     10a81d <e100_intr+0x22d>
        cprintf("   Flow Control Pause\n");
  10a811:	c7 04 24 a4 ac 11 00 	movl   $0x11aca4,(%esp)
  10a818:	e8 f3 5e ff ff       	call   100710 <cprintf>

}
  10a81d:	c9                   	leave  
  10a81e:	c3                   	ret    
  10a81f:	90                   	nop    

0010a820 <ring_printinfo>:

// Ring management
void
ring_printinfo(e100_dev *dev)
{
  10a820:	55                   	push   %ebp
  10a821:	89 e5                	mov    %esp,%ebp
  10a823:	83 ec 08             	sub    $0x8,%esp
    cprintf("Ring Info:   ");
  10a826:	c7 04 24 4e ad 11 00 	movl   $0x11ad4e,(%esp)
  10a82d:	e8 de 5e ff ff       	call   100710 <cprintf>
    cprintf("head: 0x%08x  ", dev->cu_next_pkt);
  10a832:	8b 45 08             	mov    0x8(%ebp),%eax
  10a835:	8b 80 b4 00 00 00    	mov    0xb4(%eax),%eax
  10a83b:	89 44 24 04          	mov    %eax,0x4(%esp)
  10a83f:	c7 04 24 5c ad 11 00 	movl   $0x11ad5c,(%esp)
  10a846:	e8 c5 5e ff ff       	call   100710 <cprintf>
    cprintf("end:  0x%08x\n", dev->cu_last_pkt);
  10a84b:	8b 45 08             	mov    0x8(%ebp),%eax
  10a84e:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
  10a854:	89 44 24 04          	mov    %eax,0x4(%esp)
  10a858:	c7 04 24 6b ad 11 00 	movl   $0x11ad6b,(%esp)
  10a85f:	e8 ac 5e ff ff       	call   100710 <cprintf>
}
  10a864:	c9                   	leave  
  10a865:	c3                   	ret    
  10a866:	8d 76 00             	lea    0x0(%esi),%esi
  10a869:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

0010a870 <ring_init>:

void
ring_init(e100_dev *dev)
{
  10a870:	55                   	push   %ebp
  10a871:	89 e5                	mov    %esp,%ebp
  10a873:	83 ec 10             	sub    $0x10,%esp
    int i;
    dev->cucount = dev->cusize / E100_CB_SIZE;
  10a876:	8b 45 08             	mov    0x8(%ebp),%eax
  10a879:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
  10a87f:	89 c2                	mov    %eax,%edx
  10a881:	c1 ea 0b             	shr    $0xb,%edx
  10a884:	8b 45 08             	mov    0x8(%ebp),%eax
  10a887:	89 90 a4 00 00 00    	mov    %edx,0xa4(%eax)
    dev->cu_next_pkt = 0;
  10a88d:	8b 45 08             	mov    0x8(%ebp),%eax
  10a890:	c7 80 b4 00 00 00 00 	movl   $0x0,0xb4(%eax)
  10a897:	00 00 00 
    for (i=0; i<dev->cucount ; i++)
  10a89a:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
  10a8a1:	e9 83 00 00 00       	jmp    10a929 <ring_init+0xb9>
    {
        command_block *cmd = (void*)(dev->cubase + i * E100_CB_SIZE);
  10a8a6:	8b 45 08             	mov    0x8(%ebp),%eax
  10a8a9:	8b 90 9c 00 00 00    	mov    0x9c(%eax),%edx
  10a8af:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10a8b2:	c1 e0 0b             	shl    $0xb,%eax
  10a8b5:	8d 04 02             	lea    (%edx,%eax,1),%eax
  10a8b8:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
        cmd->cmd_word = 0;
  10a8bb:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10a8be:	66 c7 40 02 00 00    	movw   $0x0,0x2(%eax)
        cmd->status_word = 0;
  10a8c4:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10a8c7:	66 c7 00 00 00       	movw   $0x0,(%eax)
        cmd->c = 1;
  10a8cc:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  10a8cf:	8b 02                	mov    (%edx),%eax
  10a8d1:	80 cc 80             	or     $0x80,%ah
  10a8d4:	89 02                	mov    %eax,(%edx)
        cmd->el = 1;
  10a8d6:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  10a8d9:	0f b6 42 03          	movzbl 0x3(%edx),%eax
  10a8dd:	83 c8 80             	or     $0xffffff80,%eax
  10a8e0:	88 42 03             	mov    %al,0x3(%edx)
        if (i == dev->cucount - 1)
  10a8e3:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
  10a8e6:	8b 45 08             	mov    0x8(%ebp),%eax
  10a8e9:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
  10a8ef:	83 e8 01             	sub    $0x1,%eax
  10a8f2:	39 c2                	cmp    %eax,%edx
  10a8f4:	75 1f                	jne    10a915 <ring_init+0xa5>
        {
            cmd->link = (void*)dev->cubase;
  10a8f6:	8b 45 08             	mov    0x8(%ebp),%eax
  10a8f9:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
  10a8ff:	89 c2                	mov    %eax,%edx
  10a901:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10a904:	89 50 04             	mov    %edx,0x4(%eax)
            dev->cu_last_pkt = cmd;
  10a907:	8b 55 08             	mov    0x8(%ebp),%edx
  10a90a:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10a90d:	89 82 b0 00 00 00    	mov    %eax,0xb0(%edx)
  10a913:	eb 10                	jmp    10a925 <ring_init+0xb5>
        }
        else
        {
            cmd->link = (void*)((uint32_t)cmd + E100_CB_SIZE);
  10a915:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10a918:	05 00 08 00 00       	add    $0x800,%eax
  10a91d:	89 c2                	mov    %eax,%edx
  10a91f:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10a922:	89 50 04             	mov    %edx,0x4(%eax)
  10a925:	83 45 f4 01          	addl   $0x1,0xfffffff4(%ebp)
  10a929:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10a92c:	8b 55 08             	mov    0x8(%ebp),%edx
  10a92f:	8b 92 a4 00 00 00    	mov    0xa4(%edx),%edx
  10a935:	39 d0                	cmp    %edx,%eax
  10a937:	0f 82 69 ff ff ff    	jb     10a8a6 <ring_init+0x36>
        }
//        cprintf("CB %d: start 0x%08x next 0x%08x\n", i, cmd, cmd->link);
    }
    dev->rucount = dev->rusize / E100_RFD_SIZE;
  10a93d:	8b 45 08             	mov    0x8(%ebp),%eax
  10a940:	8b 80 f0 00 00 00    	mov    0xf0(%eax),%eax
  10a946:	89 c2                	mov    %eax,%edx
  10a948:	c1 ea 0b             	shr    $0xb,%edx
  10a94b:	8b 45 08             	mov    0x8(%ebp),%eax
  10a94e:	89 90 f4 00 00 00    	mov    %edx,0xf4(%eax)
    for (i=0; i<dev->rucount; i++)
  10a954:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
  10a95b:	e9 eb 00 00 00       	jmp    10aa4b <ring_init+0x1db>
    {
        rf_desc *rfd = (void*)(dev->rubase + i * E100_RFD_SIZE);
  10a960:	8b 45 08             	mov    0x8(%ebp),%eax
  10a963:	8b 90 ec 00 00 00    	mov    0xec(%eax),%edx
  10a969:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10a96c:	c1 e0 0b             	shl    $0xb,%eax
  10a96f:	8d 04 02             	lea    (%edx,%eax,1),%eax
  10a972:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
        rfd->head.cmd_word = 0;
  10a975:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10a978:	66 c7 40 02 00 00    	movw   $0x0,0x2(%eax)
        rfd->head.status_word = 0;
  10a97e:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10a981:	66 c7 00 00 00       	movw   $0x0,(%eax)
        rfd->size = E100_RFD_SIZE - sizeof(rf_desc);
  10a986:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  10a989:	8b 42 0c             	mov    0xc(%edx),%eax
  10a98c:	25 ff ff 00 c0       	and    $0xc000ffff,%eax
  10a991:	0d 00 00 f0 07       	or     $0x7f00000,%eax
  10a996:	89 42 0c             	mov    %eax,0xc(%edx)
        if (rfd->size & 1)
  10a999:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10a99c:	8b 40 0c             	mov    0xc(%eax),%eax
  10a99f:	c1 e8 10             	shr    $0x10,%eax
  10a9a2:	66 25 ff 3f          	and    $0x3fff,%ax
  10a9a6:	0f b7 c0             	movzwl %ax,%eax
  10a9a9:	83 e0 01             	and    $0x1,%eax
  10a9ac:	84 c0                	test   %al,%al
  10a9ae:	74 31                	je     10a9e1 <ring_init+0x171>
            rfd->size--;
  10a9b0:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10a9b3:	8b 40 0c             	mov    0xc(%eax),%eax
  10a9b6:	c1 e8 10             	shr    $0x10,%eax
  10a9b9:	66 25 ff 3f          	and    $0x3fff,%ax
  10a9bd:	83 e8 01             	sub    $0x1,%eax
  10a9c0:	66 25 ff 3f          	and    $0x3fff,%ax
  10a9c4:	8b 4d fc             	mov    0xfffffffc(%ebp),%ecx
  10a9c7:	0f b7 c0             	movzwl %ax,%eax
  10a9ca:	25 ff 3f 00 00       	and    $0x3fff,%eax
  10a9cf:	89 c2                	mov    %eax,%edx
  10a9d1:	c1 e2 10             	shl    $0x10,%edx
  10a9d4:	8b 41 0c             	mov    0xc(%ecx),%eax
  10a9d7:	25 ff ff 00 c0       	and    $0xc000ffff,%eax
  10a9dc:	09 d0                	or     %edx,%eax
  10a9de:	89 41 0c             	mov    %eax,0xc(%ecx)
        rfd->eof = 0;
  10a9e1:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  10a9e4:	8b 42 0c             	mov    0xc(%edx),%eax
  10a9e7:	80 e4 7f             	and    $0x7f,%ah
  10a9ea:	89 42 0c             	mov    %eax,0xc(%edx)
        rfd->f = 0;
  10a9ed:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  10a9f0:	8b 42 0c             	mov    0xc(%edx),%eax
  10a9f3:	80 e4 bf             	and    $0xbf,%ah
  10a9f6:	89 42 0c             	mov    %eax,0xc(%edx)
        if (i == dev->rucount - 1)
  10a9f9:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
  10a9fc:	8b 45 08             	mov    0x8(%ebp),%eax
  10a9ff:	8b 80 f4 00 00 00    	mov    0xf4(%eax),%eax
  10aa05:	83 e8 01             	sub    $0x1,%eax
  10aa08:	39 c2                	cmp    %eax,%edx
  10aa0a:	75 2b                	jne    10aa37 <ring_init+0x1c7>
        {
            rfd->head.link = (void*)dev->rubase;
  10aa0c:	8b 45 08             	mov    0x8(%ebp),%eax
  10aa0f:	8b 80 ec 00 00 00    	mov    0xec(%eax),%eax
  10aa15:	89 c2                	mov    %eax,%edx
  10aa17:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10aa1a:	89 50 04             	mov    %edx,0x4(%eax)
            rfd->head.el = 1;
  10aa1d:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  10aa20:	8b 02                	mov    (%edx),%eax
  10aa22:	0d 00 00 00 80       	or     $0x80000000,%eax
  10aa27:	89 02                	mov    %eax,(%edx)
            dev->ru_prev = rfd;
  10aa29:	8b 55 08             	mov    0x8(%ebp),%edx
  10aa2c:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10aa2f:	89 82 00 01 00 00    	mov    %eax,0x100(%edx)
  10aa35:	eb 10                	jmp    10aa47 <ring_init+0x1d7>
        }
        else
        {
            rfd->head.link = (void*)((uint32_t)rfd + E100_RFD_SIZE);
  10aa37:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10aa3a:	05 00 08 00 00       	add    $0x800,%eax
  10aa3f:	89 c2                	mov    %eax,%edx
  10aa41:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10aa44:	89 50 04             	mov    %edx,0x4(%eax)
  10aa47:	83 45 f4 01          	addl   $0x1,0xfffffff4(%ebp)
  10aa4b:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10aa4e:	8b 55 08             	mov    0x8(%ebp),%edx
  10aa51:	8b 92 f4 00 00 00    	mov    0xf4(%edx),%edx
  10aa57:	39 d0                	cmp    %edx,%eax
  10aa59:	0f 82 01 ff ff ff    	jb     10a960 <ring_init+0xf0>
        }
    }
    dev->ru_first = 0;
  10aa5f:	8b 45 08             	mov    0x8(%ebp),%eax
  10aa62:	c7 80 f8 00 00 00 00 	movl   $0x0,0xf8(%eax)
  10aa69:	00 00 00 
    dev->ru_last = (void*)dev->rubase;
  10aa6c:	8b 45 08             	mov    0x8(%ebp),%eax
  10aa6f:	8b 80 ec 00 00 00    	mov    0xec(%eax),%eax
  10aa75:	89 c2                	mov    %eax,%edx
  10aa77:	8b 45 08             	mov    0x8(%ebp),%eax
  10aa7a:	89 90 fc 00 00 00    	mov    %edx,0xfc(%eax)
    
}
  10aa80:	c9                   	leave  
  10aa81:	c3                   	ret    
  10aa82:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi
  10aa89:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

0010aa90 <ring_alloc>:

void *
ring_alloc(e100_dev *dev, uint32_t len)
{
  10aa90:	55                   	push   %ebp
  10aa91:	89 e5                	mov    %esp,%ebp
  10aa93:	83 ec 04             	sub    $0x4,%esp
    if (len > E100_CB_SIZE)
  10aa96:	81 7d 0c 00 08 00 00 	cmpl   $0x800,0xc(%ebp)
  10aa9d:	76 09                	jbe    10aaa8 <ring_alloc+0x18>
        return (void*) 0;
  10aa9f:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
  10aaa6:	eb 4f                	jmp    10aaf7 <ring_alloc+0x67>
    if (dev->cu_next_pkt)
  10aaa8:	8b 45 08             	mov    0x8(%ebp),%eax
  10aaab:	8b 80 b4 00 00 00    	mov    0xb4(%eax),%eax
  10aab1:	85 c0                	test   %eax,%eax
  10aab3:	74 33                	je     10aae8 <ring_alloc+0x58>
    {
        if ((void*)dev->cu_last_pkt->link == dev->cu_next_pkt)
  10aab5:	8b 45 08             	mov    0x8(%ebp),%eax
  10aab8:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
  10aabe:	8b 50 04             	mov    0x4(%eax),%edx
  10aac1:	8b 45 08             	mov    0x8(%ebp),%eax
  10aac4:	8b 80 b4 00 00 00    	mov    0xb4(%eax),%eax
  10aaca:	39 c2                	cmp    %eax,%edx
  10aacc:	75 09                	jne    10aad7 <ring_alloc+0x47>
            return (void*) 0;
  10aace:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
  10aad5:	eb 20                	jmp    10aaf7 <ring_alloc+0x67>
        return (void*)dev->cu_last_pkt->link;
  10aad7:	8b 45 08             	mov    0x8(%ebp),%eax
  10aada:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
  10aae0:	8b 40 04             	mov    0x4(%eax),%eax
  10aae3:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  10aae6:	eb 0f                	jmp    10aaf7 <ring_alloc+0x67>
    } else {
        return (void*)dev->cu_last_pkt->link;
  10aae8:	8b 45 08             	mov    0x8(%ebp),%eax
  10aaeb:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
  10aaf1:	8b 40 04             	mov    0x4(%eax),%eax
  10aaf4:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  10aaf7:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    }
/*    
    len = E100_CB_SIZE;
    if (dev->cuhead <= dev->cuend)
    {
        uint32_t newend = dev->cuend + len;
        uint32_t oldend = dev->cuend;
        if (newend >= dev->cusize)
        {
            newend = len; // Start from base
            if (newend < dev->cuhead)
            {
                dev->cuend = newend;
                return (void*)dev->cubase;
            }
            else
                return (void*)0;
        }
        else
        {
            dev->cuend = newend;
            return (void*)(oldend + dev->cubase);
        }
    }
    else
    {
        uint32_t newend = dev->cuend + len;
        uint32_t oldend = dev->cuend;
        if (newend < dev->cuhead)
        {
            dev->cuend = newend;
            return (void*)(oldend + dev->cubase);
        }
        else
            return (void*)0;
    }*/
}
  10aafa:	c9                   	leave  
  10aafb:	c3                   	ret    
  10aafc:	8d 74 26 00          	lea    0x0(%esi),%esi

0010ab00 <e100_send_dev>:

// Send
int
e100_send_dev(e100_dev *dev, void *buffer, uint32_t len)
{
  10ab00:	55                   	push   %ebp
  10ab01:	89 e5                	mov    %esp,%ebp
  10ab03:	83 ec 28             	sub    $0x28,%esp
//    cprintf("e100_send_dev\n");
    if (len > TBD_DATA_LIMIT)
  10ab06:	81 7d 10 40 06 00 00 	cmpl   $0x640,0x10(%ebp)
  10ab0d:	76 0c                	jbe    10ab1b <e100_send_dev+0x1b>
        return -1; // ETOOBIG
  10ab0f:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  10ab16:	e9 b2 01 00 00       	jmp    10accd <e100_send_dev+0x1cd>
    acquire(&dev->culock);
  10ab1b:	8b 45 08             	mov    0x8(%ebp),%eax
  10ab1e:	83 c0 68             	add    $0x68,%eax
  10ab21:	89 04 24             	mov    %eax,(%esp)
  10ab24:	e8 17 b0 ff ff       	call   105b40 <acquire>
    op_transmit_cmd *start = 
        ring_alloc(dev, sizeof(op_transmit_cmd) + len);
  10ab29:	8b 45 10             	mov    0x10(%ebp),%eax
  10ab2c:	83 c0 10             	add    $0x10,%eax
  10ab2f:	89 44 24 04          	mov    %eax,0x4(%esp)
  10ab33:	8b 45 08             	mov    0x8(%ebp),%eax
  10ab36:	89 04 24             	mov    %eax,(%esp)
  10ab39:	e8 52 ff ff ff       	call   10aa90 <ring_alloc>
  10ab3e:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
//    cprintf("   start: 0x%08x\n", start);
    if (!start)
  10ab41:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  10ab45:	75 1a                	jne    10ab61 <e100_send_dev+0x61>
    {
        release(&dev->culock);
  10ab47:	8b 45 08             	mov    0x8(%ebp),%eax
  10ab4a:	83 c0 68             	add    $0x68,%eax
  10ab4d:	89 04 24             	mov    %eax,(%esp)
  10ab50:	e8 eb b1 ff ff       	call   105d40 <release>
        return -1; // No space in buffer
  10ab55:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  10ab5c:	e9 6c 01 00 00       	jmp    10accd <e100_send_dev+0x1cd>
    }
    op_transmit_cmd_cmd cmd_word;
    cmd_word.word = 0;
  10ab61:	66 c7 45 fa 00 00    	movw   $0x0,0xfffffffa(%ebp)
    cmd_word.cmd = OP_TRANSMIT;
  10ab67:	0f b6 45 fa          	movzbl 0xfffffffa(%ebp),%eax
  10ab6b:	83 e0 f8             	and    $0xfffffff8,%eax
  10ab6e:	83 c8 04             	or     $0x4,%eax
  10ab71:	88 45 fa             	mov    %al,0xfffffffa(%ebp)
//    cmd_word.el = 0;
    cmd_word.cid = 0xe;
  10ab74:	0f b6 45 fb          	movzbl 0xfffffffb(%ebp),%eax
  10ab78:	83 e0 e0             	and    $0xffffffe0,%eax
  10ab7b:	83 c8 0e             	or     $0xe,%eax
  10ab7e:	88 45 fb             	mov    %al,0xfffffffb(%ebp)
    cmd_word.i = 1;
  10ab81:	0f b6 45 fb          	movzbl 0xfffffffb(%ebp),%eax
  10ab85:	83 c8 20             	or     $0x20,%eax
  10ab88:	88 45 fb             	mov    %al,0xfffffffb(%ebp)
    cmd_word.s = 1;
  10ab8b:	0f b6 45 fb          	movzbl 0xfffffffb(%ebp),%eax
  10ab8f:	83 c8 40             	or     $0x40,%eax
  10ab92:	88 45 fb             	mov    %al,0xfffffffb(%ebp)
    if (!dev->cuidle)
  10ab95:	8b 45 08             	mov    0x8(%ebp),%eax
  10ab98:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
  10ab9e:	85 c0                	test   %eax,%eax
  10aba0:	75 13                	jne    10abb5 <e100_send_dev+0xb5>
        dev->cu_last_pkt->s = 0;
  10aba2:	8b 45 08             	mov    0x8(%ebp),%eax
  10aba5:	8b 90 b0 00 00 00    	mov    0xb0(%eax),%edx
  10abab:	0f b6 42 03          	movzbl 0x3(%edx),%eax
  10abaf:	83 e0 bf             	and    $0xffffffbf,%eax
  10abb2:	88 42 03             	mov    %al,0x3(%edx)
    start->base_cmd.cmd_word = cmd_word.word;
  10abb5:	0f b7 55 fa          	movzwl 0xfffffffa(%ebp),%edx
  10abb9:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10abbc:	66 89 50 02          	mov    %dx,0x2(%eax)
    start->base_cmd.status_word = 0;
  10abc0:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10abc3:	66 c7 00 00 00       	movw   $0x0,(%eax)
//    start->base_cmd.link = 0;
    start->tbd_addr = 0xffffffff;
  10abc8:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10abcb:	c7 40 08 ff ff ff ff 	movl   $0xffffffff,0x8(%eax)
    start->byte_count = len;
  10abd2:	8b 45 10             	mov    0x10(%ebp),%eax
  10abd5:	c1 e0 02             	shl    $0x2,%eax
  10abd8:	66 c1 f8 02          	sar    $0x2,%ax
  10abdc:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  10abdf:	89 c1                	mov    %eax,%ecx
  10abe1:	66 81 e1 ff 3f       	and    $0x3fff,%cx
  10abe6:	0f b7 42 0c          	movzwl 0xc(%edx),%eax
  10abea:	66 25 00 c0          	and    $0xc000,%ax
  10abee:	09 c8                	or     %ecx,%eax
  10abf0:	66 89 42 0c          	mov    %ax,0xc(%edx)
    start->eof = 1;
  10abf4:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  10abf7:	0f b6 42 0d          	movzbl 0xd(%edx),%eax
  10abfb:	83 c8 80             	or     $0xffffff80,%eax
  10abfe:	88 42 0d             	mov    %al,0xd(%edx)
    start->trans_thres = 0xE0;
  10ac01:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10ac04:	c6 40 0e e0          	movb   $0xe0,0xe(%eax)
    start->tbd_num = 0;
  10ac08:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10ac0b:	c6 40 0f 00          	movb   $0x0,0xf(%eax)
    memcpy((void*)(start+1), buffer, len);
  10ac0f:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  10ac12:	83 c2 10             	add    $0x10,%edx
  10ac15:	8b 45 10             	mov    0x10(%ebp),%eax
  10ac18:	89 44 24 08          	mov    %eax,0x8(%esp)
  10ac1c:	8b 45 0c             	mov    0xc(%ebp),%eax
  10ac1f:	89 44 24 04          	mov    %eax,0x4(%esp)
  10ac23:	89 14 24             	mov    %edx,(%esp)
  10ac26:	e8 95 b2 ff ff       	call   105ec0 <memcpy>
//    e100_print_state(dev);
//    if (e100_get_state(dev).status.cus == CUS_IDLE)
//    if (dev->cu_next_pkt == 0)
//    This test would fail in real i82559er
//    But it passed in qemu
/*    if ((!dev->cufirst) && (!dev->cuidle))
        if (start->base_cmd.link == dev->cu_next_pkt)
            e100_cu_command(dev, CUC_RESUME, start);*/
    if (dev->cufirst)
  10ac2b:	8b 45 08             	mov    0x8(%ebp),%eax
  10ac2e:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
  10ac34:	85 c0                	test   %eax,%eax
  10ac36:	74 35                	je     10ac6d <e100_send_dev+0x16d>
    {
        dev->cufirst = 0;
  10ac38:	8b 45 08             	mov    0x8(%ebp),%eax
  10ac3b:	c7 80 a8 00 00 00 00 	movl   $0x0,0xa8(%eax)
  10ac42:	00 00 00 
        dev->cu_next_pkt = &start->base_cmd;
  10ac45:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  10ac48:	8b 45 08             	mov    0x8(%ebp),%eax
  10ac4b:	89 90 b4 00 00 00    	mov    %edx,0xb4(%eax)
        e100_cu_command(dev, CUC_START, start);
  10ac51:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10ac54:	89 44 24 08          	mov    %eax,0x8(%esp)
  10ac58:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  10ac5f:	00 
  10ac60:	8b 45 08             	mov    0x8(%ebp),%eax
  10ac63:	89 04 24             	mov    %eax,(%esp)
  10ac66:	e8 a5 f8 ff ff       	call   10a510 <e100_cu_command>
  10ac6b:	eb 40                	jmp    10acad <e100_send_dev+0x1ad>
    }
    else if (dev->cuidle)
  10ac6d:	8b 45 08             	mov    0x8(%ebp),%eax
  10ac70:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
  10ac76:	85 c0                	test   %eax,%eax
  10ac78:	74 33                	je     10acad <e100_send_dev+0x1ad>
    {
        dev->cuidle = 0;
  10ac7a:	8b 45 08             	mov    0x8(%ebp),%eax
  10ac7d:	c7 80 ac 00 00 00 00 	movl   $0x0,0xac(%eax)
  10ac84:	00 00 00 
        dev->cu_next_pkt = &start->base_cmd;
  10ac87:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  10ac8a:	8b 45 08             	mov    0x8(%ebp),%eax
  10ac8d:	89 90 b4 00 00 00    	mov    %edx,0xb4(%eax)
        e100_cu_command(dev, CUC_RESUME, start); // the GENPTR is nonsense
  10ac93:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10ac96:	89 44 24 08          	mov    %eax,0x8(%esp)
  10ac9a:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
  10aca1:	00 
  10aca2:	8b 45 08             	mov    0x8(%ebp),%eax
  10aca5:	89 04 24             	mov    %eax,(%esp)
  10aca8:	e8 63 f8 ff ff       	call   10a510 <e100_cu_command>
    }
    dev->cu_last_pkt = &start->base_cmd;
  10acad:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10acb0:	8b 55 08             	mov    0x8(%ebp),%edx
  10acb3:	89 82 b0 00 00 00    	mov    %eax,0xb0(%edx)
    release(&dev->culock);
  10acb9:	8b 45 08             	mov    0x8(%ebp),%eax
  10acbc:	83 c0 68             	add    $0x68,%eax
  10acbf:	89 04 24             	mov    %eax,(%esp)
  10acc2:	e8 79 b0 ff ff       	call   105d40 <release>
    return len;
  10acc7:	8b 45 10             	mov    0x10(%ebp),%eax
  10acca:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  10accd:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  10acd0:	c9                   	leave  
  10acd1:	c3                   	ret    
  10acd2:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi
  10acd9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

0010ace0 <e100_send>:

int
e100_send(void *buffer, uint32_t len)
{
  10ace0:	55                   	push   %ebp
  10ace1:	89 e5                	mov    %esp,%ebp
  10ace3:	83 ec 18             	sub    $0x18,%esp
    if (dev_count == 0)
  10ace6:	a1 c0 cd 11 00       	mov    0x11cdc0,%eax
  10aceb:	85 c0                	test   %eax,%eax
  10aced:	75 09                	jne    10acf8 <e100_send+0x18>
        return -2; // Device not found
  10acef:	c7 45 fc fe ff ff ff 	movl   $0xfffffffe,0xfffffffc(%ebp)
  10acf6:	eb 1d                	jmp    10ad15 <e100_send+0x35>
    return e100_send_dev(&e100_devs[0], buffer,len);
  10acf8:	8b 45 0c             	mov    0xc(%ebp),%eax
  10acfb:	89 44 24 08          	mov    %eax,0x8(%esp)
  10acff:	8b 45 08             	mov    0x8(%ebp),%eax
  10ad02:	89 44 24 04          	mov    %eax,0x4(%esp)
  10ad06:	c7 04 24 e0 cd 11 00 	movl   $0x11cde0,(%esp)
  10ad0d:	e8 ee fd ff ff       	call   10ab00 <e100_send_dev>
  10ad12:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  10ad15:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
}
  10ad18:	c9                   	leave  
  10ad19:	c3                   	ret    
  10ad1a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

0010ad20 <e100_ru_start>:

// Receive
void
e100_ru_start(e100_dev *dev)
{
  10ad20:	55                   	push   %ebp
  10ad21:	89 e5                	mov    %esp,%ebp
  10ad23:	83 ec 18             	sub    $0x18,%esp
    dev->ru_full = 0;
  10ad26:	8b 45 08             	mov    0x8(%ebp),%eax
  10ad29:	c7 80 04 01 00 00 00 	movl   $0x0,0x104(%eax)
  10ad30:	00 00 00 
    e100_ru_command(dev, RUC_START, (void*)dev->rubase);
  10ad33:	8b 45 08             	mov    0x8(%ebp),%eax
  10ad36:	8b 80 ec 00 00 00    	mov    0xec(%eax),%eax
  10ad3c:	89 44 24 08          	mov    %eax,0x8(%esp)
  10ad40:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  10ad47:	00 
  10ad48:	8b 45 08             	mov    0x8(%ebp),%eax
  10ad4b:	89 04 24             	mov    %eax,(%esp)
  10ad4e:	e8 2d f8 ff ff       	call   10a580 <e100_ru_command>
}
  10ad53:	c9                   	leave  
  10ad54:	c3                   	ret    
  10ad55:	8d 74 26 00          	lea    0x0(%esi),%esi
  10ad59:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

0010ad60 <e100_receive>:
 
int
e100_receive(void *buffer, uint32_t len)
{
  10ad60:	55                   	push   %ebp
  10ad61:	89 e5                	mov    %esp,%ebp
  10ad63:	83 ec 18             	sub    $0x18,%esp
    if (dev_count == 0)
  10ad66:	a1 c0 cd 11 00       	mov    0x11cdc0,%eax
  10ad6b:	85 c0                	test   %eax,%eax
  10ad6d:	75 09                	jne    10ad78 <e100_receive+0x18>
        return -2; // Device not found
  10ad6f:	c7 45 fc fe ff ff ff 	movl   $0xfffffffe,0xfffffffc(%ebp)
  10ad76:	eb 1d                	jmp    10ad95 <e100_receive+0x35>
    return e100_receive_dev(&e100_devs[0], buffer, len);
  10ad78:	8b 45 0c             	mov    0xc(%ebp),%eax
  10ad7b:	89 44 24 08          	mov    %eax,0x8(%esp)
  10ad7f:	8b 45 08             	mov    0x8(%ebp),%eax
  10ad82:	89 44 24 04          	mov    %eax,0x4(%esp)
  10ad86:	c7 04 24 e0 cd 11 00 	movl   $0x11cde0,(%esp)
  10ad8d:	e8 0e 00 00 00       	call   10ada0 <e100_receive_dev>
  10ad92:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  10ad95:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
}
  10ad98:	c9                   	leave  
  10ad99:	c3                   	ret    
  10ad9a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

0010ada0 <e100_receive_dev>:

int
e100_receive_dev(e100_dev *dev, void *buffer, int len)
{
  10ada0:	55                   	push   %ebp
  10ada1:	89 e5                	mov    %esp,%ebp
  10ada3:	83 ec 28             	sub    $0x28,%esp
    int count;
//    cprintf("e100_receive_dev\n");
    acquire(&dev->rulock);
  10ada6:	8b 45 08             	mov    0x8(%ebp),%eax
  10ada9:	05 b8 00 00 00       	add    $0xb8,%eax
  10adae:	89 04 24             	mov    %eax,(%esp)
  10adb1:	e8 8a ad ff ff       	call   105b40 <acquire>
    while (dev->ru_first == 0)
  10adb6:	eb 1d                	jmp    10add5 <e100_receive_dev+0x35>
        sleep(&dev->rulock, &dev->rulock);
  10adb8:	8b 45 08             	mov    0x8(%ebp),%eax
  10adbb:	05 b8 00 00 00       	add    $0xb8,%eax
  10adc0:	8b 55 08             	mov    0x8(%ebp),%edx
  10adc3:	81 c2 b8 00 00 00    	add    $0xb8,%edx
  10adc9:	89 44 24 04          	mov    %eax,0x4(%esp)
  10adcd:	89 14 24             	mov    %edx,(%esp)
  10add0:	e8 bb a6 ff ff       	call   105490 <sleep>
  10add5:	8b 45 08             	mov    0x8(%ebp),%eax
  10add8:	8b 80 f8 00 00 00    	mov    0xf8(%eax),%eax
  10adde:	85 c0                	test   %eax,%eax
  10ade0:	74 d6                	je     10adb8 <e100_receive_dev+0x18>
    if (len < dev->ru_first->count)
  10ade2:	8b 45 08             	mov    0x8(%ebp),%eax
  10ade5:	8b 80 f8 00 00 00    	mov    0xf8(%eax),%eax
  10adeb:	8b 40 0c             	mov    0xc(%eax),%eax
  10adee:	66 25 ff 3f          	and    $0x3fff,%ax
  10adf2:	0f b7 c0             	movzwl %ax,%eax
  10adf5:	3b 45 10             	cmp    0x10(%ebp),%eax
  10adf8:	7e 1c                	jle    10ae16 <e100_receive_dev+0x76>
    {
        release(&dev->rulock);
  10adfa:	8b 45 08             	mov    0x8(%ebp),%eax
  10adfd:	05 b8 00 00 00       	add    $0xb8,%eax
  10ae02:	89 04 24             	mov    %eax,(%esp)
  10ae05:	e8 36 af ff ff       	call   105d40 <release>
        return -1; // ETOOBIG
  10ae0a:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  10ae11:	e9 2c 01 00 00       	jmp    10af42 <e100_receive_dev+0x1a2>
    }
    memcpy(buffer, dev->ru_first + 1, dev->ru_first->count);
  10ae16:	8b 45 08             	mov    0x8(%ebp),%eax
  10ae19:	8b 80 f8 00 00 00    	mov    0xf8(%eax),%eax
  10ae1f:	8b 40 0c             	mov    0xc(%eax),%eax
  10ae22:	66 25 ff 3f          	and    $0x3fff,%ax
  10ae26:	0f b7 d0             	movzwl %ax,%edx
  10ae29:	8b 45 08             	mov    0x8(%ebp),%eax
  10ae2c:	8b 80 f8 00 00 00    	mov    0xf8(%eax),%eax
  10ae32:	83 c0 10             	add    $0x10,%eax
  10ae35:	89 54 24 08          	mov    %edx,0x8(%esp)
  10ae39:	89 44 24 04          	mov    %eax,0x4(%esp)
  10ae3d:	8b 45 0c             	mov    0xc(%ebp),%eax
  10ae40:	89 04 24             	mov    %eax,(%esp)
  10ae43:	e8 78 b0 ff ff       	call   105ec0 <memcpy>
//    cprintf("received %d bytes into 0x%08x\n", dev->ru_first->count, buffer);
    count = dev->ru_first->count;
  10ae48:	8b 45 08             	mov    0x8(%ebp),%eax
  10ae4b:	8b 80 f8 00 00 00    	mov    0xf8(%eax),%eax
  10ae51:	8b 40 0c             	mov    0xc(%eax),%eax
  10ae54:	66 25 ff 3f          	and    $0x3fff,%ax
  10ae58:	0f b7 c0             	movzwl %ax,%eax
  10ae5b:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
    dev->ru_first->eof = 0;
  10ae5e:	8b 45 08             	mov    0x8(%ebp),%eax
  10ae61:	8b 90 f8 00 00 00    	mov    0xf8(%eax),%edx
  10ae67:	8b 42 0c             	mov    0xc(%edx),%eax
  10ae6a:	80 e4 7f             	and    $0x7f,%ah
  10ae6d:	89 42 0c             	mov    %eax,0xc(%edx)
    dev->ru_first->f = 0;
  10ae70:	8b 45 08             	mov    0x8(%ebp),%eax
  10ae73:	8b 90 f8 00 00 00    	mov    0xf8(%eax),%edx
  10ae79:	8b 42 0c             	mov    0xc(%edx),%eax
  10ae7c:	80 e4 bf             	and    $0xbf,%ah
  10ae7f:	89 42 0c             	mov    %eax,0xc(%edx)
    dev->ru_prev->head.el = 0;
  10ae82:	8b 45 08             	mov    0x8(%ebp),%eax
  10ae85:	8b 90 00 01 00 00    	mov    0x100(%eax),%edx
  10ae8b:	8b 02                	mov    (%edx),%eax
  10ae8d:	25 ff ff ff 7f       	and    $0x7fffffff,%eax
  10ae92:	89 02                	mov    %eax,(%edx)
    dev->ru_first->head.el = 1;
  10ae94:	8b 45 08             	mov    0x8(%ebp),%eax
  10ae97:	8b 90 f8 00 00 00    	mov    0xf8(%eax),%edx
  10ae9d:	8b 02                	mov    (%edx),%eax
  10ae9f:	0d 00 00 00 80       	or     $0x80000000,%eax
  10aea4:	89 02                	mov    %eax,(%edx)
    dev->ru_prev = dev->ru_first;
  10aea6:	8b 45 08             	mov    0x8(%ebp),%eax
  10aea9:	8b 90 f8 00 00 00    	mov    0xf8(%eax),%edx
  10aeaf:	8b 45 08             	mov    0x8(%ebp),%eax
  10aeb2:	89 90 00 01 00 00    	mov    %edx,0x100(%eax)
    dev->ru_first = (void*)dev->ru_first->head.link;
  10aeb8:	8b 45 08             	mov    0x8(%ebp),%eax
  10aebb:	8b 80 f8 00 00 00    	mov    0xf8(%eax),%eax
  10aec1:	8b 40 04             	mov    0x4(%eax),%eax
  10aec4:	89 c2                	mov    %eax,%edx
  10aec6:	8b 45 08             	mov    0x8(%ebp),%eax
  10aec9:	89 90 f8 00 00 00    	mov    %edx,0xf8(%eax)
    if (dev->ru_full)
  10aecf:	8b 45 08             	mov    0x8(%ebp),%eax
  10aed2:	8b 80 04 01 00 00    	mov    0x104(%eax),%eax
  10aed8:	85 c0                	test   %eax,%eax
  10aeda:	74 2d                	je     10af09 <e100_receive_dev+0x169>
    {
        // RU full, in No Resource state
        dev->ru_full = 0;
  10aedc:	8b 45 08             	mov    0x8(%ebp),%eax
  10aedf:	c7 80 04 01 00 00 00 	movl   $0x0,0x104(%eax)
  10aee6:	00 00 00 
        e100_ru_command(dev, RUC_START, dev->ru_prev);
  10aee9:	8b 45 08             	mov    0x8(%ebp),%eax
  10aeec:	8b 80 00 01 00 00    	mov    0x100(%eax),%eax
  10aef2:	89 44 24 08          	mov    %eax,0x8(%esp)
  10aef6:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  10aefd:	00 
  10aefe:	8b 45 08             	mov    0x8(%ebp),%eax
  10af01:	89 04 24             	mov    %eax,(%esp)
  10af04:	e8 77 f6 ff ff       	call   10a580 <e100_ru_command>
    }
    if (dev->ru_first == dev->ru_last)
  10af09:	8b 45 08             	mov    0x8(%ebp),%eax
  10af0c:	8b 90 f8 00 00 00    	mov    0xf8(%eax),%edx
  10af12:	8b 45 08             	mov    0x8(%ebp),%eax
  10af15:	8b 80 fc 00 00 00    	mov    0xfc(%eax),%eax
  10af1b:	39 c2                	cmp    %eax,%edx
  10af1d:	75 0d                	jne    10af2c <e100_receive_dev+0x18c>
        dev->ru_first = 0;
  10af1f:	8b 45 08             	mov    0x8(%ebp),%eax
  10af22:	c7 80 f8 00 00 00 00 	movl   $0x0,0xf8(%eax)
  10af29:	00 00 00 
    release(&dev->rulock);
  10af2c:	8b 45 08             	mov    0x8(%ebp),%eax
  10af2f:	05 b8 00 00 00       	add    $0xb8,%eax
  10af34:	89 04 24             	mov    %eax,(%esp)
  10af37:	e8 04 ae ff ff       	call   105d40 <release>
    return count;
  10af3c:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10af3f:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  10af42:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  10af45:	c9                   	leave  
  10af46:	c3                   	ret    
  10af47:	89 f6                	mov    %esi,%esi
  10af49:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

0010af50 <e100_rx_thread>:

void
e100_rx_thread(void *arg)
{
  10af50:	55                   	push   %ebp
  10af51:	89 e5                	mov    %esp,%ebp
  10af53:	83 ec 18             	sub    $0x18,%esp
    e100_dev *dev = arg;
  10af56:	8b 45 08             	mov    0x8(%ebp),%eax
  10af59:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
    acquire(&dev->rxlock);
  10af5c:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10af5f:	05 08 01 00 00       	add    $0x108,%eax
  10af64:	89 04 24             	mov    %eax,(%esp)
  10af67:	e8 d4 ab ff ff       	call   105b40 <acquire>
    while(1)
    {
        sleep(&dev->rxlock, &dev->rxlock);
  10af6c:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10af6f:	05 08 01 00 00       	add    $0x108,%eax
  10af74:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  10af77:	81 c2 08 01 00 00    	add    $0x108,%edx
  10af7d:	89 44 24 04          	mov    %eax,0x4(%esp)
  10af81:	89 14 24             	mov    %edx,(%esp)
  10af84:	e8 07 a5 ff ff       	call   105490 <sleep>
        while (dev->ru_last->eof)
  10af89:	eb 25                	jmp    10afb0 <e100_rx_thread+0x60>
        {
            ethernetif_input(&dev->netif);
  10af8b:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10af8e:	83 c0 38             	add    $0x38,%eax
  10af91:	89 04 24             	mov    %eax,(%esp)
  10af94:	e8 f7 13 00 00       	call   10c390 <ethernetif_input>
            dev->ru_last = (void*)dev->ru_last->head.link;
  10af99:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10af9c:	8b 80 fc 00 00 00    	mov    0xfc(%eax),%eax
  10afa2:	8b 40 04             	mov    0x4(%eax),%eax
  10afa5:	89 c2                	mov    %eax,%edx
  10afa7:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10afaa:	89 90 fc 00 00 00    	mov    %edx,0xfc(%eax)
  10afb0:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10afb3:	8b 80 fc 00 00 00    	mov    0xfc(%eax),%eax
  10afb9:	8b 40 0c             	mov    0xc(%eax),%eax
  10afbc:	25 00 80 00 00       	and    $0x8000,%eax
  10afc1:	85 c0                	test   %eax,%eax
  10afc3:	75 c6                	jne    10af8b <e100_rx_thread+0x3b>
        }
    }
  10afc5:	eb a5                	jmp    10af6c <e100_rx_thread+0x1c>
  10afc7:	89 f6                	mov    %esi,%esi
  10afc9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

0010afd0 <e100_eeprom_out>:
    release(&dev->rxlock);
}

// EEPROM
void
e100_eeprom_out(e100_dev *dev, uint16_t val)
{
  10afd0:	55                   	push   %ebp
  10afd1:	89 e5                	mov    %esp,%ebp
  10afd3:	83 ec 0c             	sub    $0xc,%esp
  10afd6:	8b 45 0c             	mov    0xc(%ebp),%eax
  10afd9:	66 89 45 fc          	mov    %ax,0xfffffffc(%ebp)
    outw(dev->iobase + SCB_EEPROM_CTL, val);
  10afdd:	0f b7 55 fc          	movzwl 0xfffffffc(%ebp),%edx
  10afe1:	8b 45 08             	mov    0x8(%ebp),%eax
  10afe4:	8b 40 34             	mov    0x34(%eax),%eax
  10afe7:	83 c0 0e             	add    $0xe,%eax
  10afea:	0f b7 c0             	movzwl %ax,%eax
  10afed:	89 54 24 04          	mov    %edx,0x4(%esp)
  10aff1:	89 04 24             	mov    %eax,(%esp)
  10aff4:	e8 f7 f2 ff ff       	call   10a2f0 <outw>
}
  10aff9:	c9                   	leave  
  10affa:	c3                   	ret    
  10affb:	90                   	nop    
  10affc:	8d 74 26 00          	lea    0x0(%esi),%esi

0010b000 <e100_eeprom_in>:

uint16_t
e100_eeprom_in(e100_dev *dev)
{
  10b000:	55                   	push   %ebp
  10b001:	89 e5                	mov    %esp,%ebp
  10b003:	83 ec 04             	sub    $0x4,%esp
    return inw(dev->iobase + SCB_EEPROM_CTL);
  10b006:	8b 45 08             	mov    0x8(%ebp),%eax
  10b009:	8b 40 34             	mov    0x34(%eax),%eax
  10b00c:	83 c0 0e             	add    $0xe,%eax
  10b00f:	0f b7 c0             	movzwl %ax,%eax
  10b012:	89 04 24             	mov    %eax,(%esp)
  10b015:	e8 26 f3 ff ff       	call   10a340 <inw>
  10b01a:	0f b7 c0             	movzwl %ax,%eax
}
  10b01d:	c9                   	leave  
  10b01e:	c3                   	ret    
  10b01f:	90                   	nop    

0010b020 <e100_eeprom_shiftin>:

void
e100_eeprom_shiftin(e100_dev *dev, int data, int len)
{
  10b020:	55                   	push   %ebp
  10b021:	89 e5                	mov    %esp,%ebp
  10b023:	83 ec 18             	sub    $0x18,%esp
    int val;
    int x;
    for (x = 1 << (len - 1); x > 0; x >>= 1)
  10b026:	8b 4d 10             	mov    0x10(%ebp),%ecx
  10b029:	83 e9 01             	sub    $0x1,%ecx
  10b02c:	b8 01 00 00 00       	mov    $0x1,%eax
  10b031:	d3 e0                	shl    %cl,%eax
  10b033:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  10b036:	e9 83 00 00 00       	jmp    10b0be <e100_eeprom_shiftin+0x9e>
    {
        if (data & x)
  10b03b:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10b03e:	23 45 0c             	and    0xc(%ebp),%eax
  10b041:	85 c0                	test   %eax,%eax
  10b043:	74 09                	je     10b04e <e100_eeprom_shiftin+0x2e>
            val = EEPROM_EEDI | EEPROM_EECS;
  10b045:	c7 45 f8 06 00 00 00 	movl   $0x6,0xfffffff8(%ebp)
  10b04c:	eb 07                	jmp    10b055 <e100_eeprom_shiftin+0x35>
        else
            val = EEPROM_EECS;
  10b04e:	c7 45 f8 02 00 00 00 	movl   $0x2,0xfffffff8(%ebp)
        e100_eeprom_out(dev, val);
  10b055:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10b058:	0f b7 c0             	movzwl %ax,%eax
  10b05b:	89 44 24 04          	mov    %eax,0x4(%esp)
  10b05f:	8b 45 08             	mov    0x8(%ebp),%eax
  10b062:	89 04 24             	mov    %eax,(%esp)
  10b065:	e8 66 ff ff ff       	call   10afd0 <e100_eeprom_out>
        delay(1);
  10b06a:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  10b071:	e8 aa f1 ff ff       	call   10a220 <delay>
        e100_eeprom_out(dev, val | EEPROM_EESK);
  10b076:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10b079:	83 c8 01             	or     $0x1,%eax
  10b07c:	0f b7 c0             	movzwl %ax,%eax
  10b07f:	89 44 24 04          	mov    %eax,0x4(%esp)
  10b083:	8b 45 08             	mov    0x8(%ebp),%eax
  10b086:	89 04 24             	mov    %eax,(%esp)
  10b089:	e8 42 ff ff ff       	call   10afd0 <e100_eeprom_out>
        delay(1);
  10b08e:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  10b095:	e8 86 f1 ff ff       	call   10a220 <delay>
        e100_eeprom_out(dev, val);
  10b09a:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10b09d:	0f b7 c0             	movzwl %ax,%eax
  10b0a0:	89 44 24 04          	mov    %eax,0x4(%esp)
  10b0a4:	8b 45 08             	mov    0x8(%ebp),%eax
  10b0a7:	89 04 24             	mov    %eax,(%esp)
  10b0aa:	e8 21 ff ff ff       	call   10afd0 <e100_eeprom_out>
        delay(1);
  10b0af:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  10b0b6:	e8 65 f1 ff ff       	call   10a220 <delay>
  10b0bb:	d1 7d fc             	sarl   0xfffffffc(%ebp)
  10b0be:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  10b0c2:	0f 8f 73 ff ff ff    	jg     10b03b <e100_eeprom_shiftin+0x1b>
    }
}
  10b0c8:	c9                   	leave  
  10b0c9:	c3                   	ret    
  10b0ca:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

0010b0d0 <e100_eeprom_shiftout>:

uint16_t
e100_eeprom_shiftout(e100_dev *dev)
{
  10b0d0:	55                   	push   %ebp
  10b0d1:	89 e5                	mov    %esp,%ebp
  10b0d3:	83 ec 18             	sub    $0x18,%esp
    int val;
    int data = 0;
  10b0d6:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)
    val = EEPROM_EECS;
  10b0dd:	c7 45 f4 02 00 00 00 	movl   $0x2,0xfffffff4(%ebp)
    int x;
    for (x = 1 << 15; x > 0; x >>= 1)
  10b0e4:	c7 45 fc 00 80 00 00 	movl   $0x8000,0xfffffffc(%ebp)
  10b0eb:	eb 63                	jmp    10b150 <e100_eeprom_shiftout+0x80>
    {
        e100_eeprom_out(dev, val | EEPROM_EESK);
  10b0ed:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10b0f0:	83 c8 01             	or     $0x1,%eax
  10b0f3:	0f b7 c0             	movzwl %ax,%eax
  10b0f6:	89 44 24 04          	mov    %eax,0x4(%esp)
  10b0fa:	8b 45 08             	mov    0x8(%ebp),%eax
  10b0fd:	89 04 24             	mov    %eax,(%esp)
  10b100:	e8 cb fe ff ff       	call   10afd0 <e100_eeprom_out>
        delay(1);
  10b105:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  10b10c:	e8 0f f1 ff ff       	call   10a220 <delay>
        if (e100_eeprom_in(dev) & EEPROM_EEDO)
  10b111:	8b 45 08             	mov    0x8(%ebp),%eax
  10b114:	89 04 24             	mov    %eax,(%esp)
  10b117:	e8 e4 fe ff ff       	call   10b000 <e100_eeprom_in>
  10b11c:	0f b7 c0             	movzwl %ax,%eax
  10b11f:	83 e0 08             	and    $0x8,%eax
  10b122:	85 c0                	test   %eax,%eax
  10b124:	74 06                	je     10b12c <e100_eeprom_shiftout+0x5c>
            data |= x;
  10b126:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10b129:	09 45 f8             	or     %eax,0xfffffff8(%ebp)
        e100_eeprom_out(dev, val);
  10b12c:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10b12f:	0f b7 c0             	movzwl %ax,%eax
  10b132:	89 44 24 04          	mov    %eax,0x4(%esp)
  10b136:	8b 45 08             	mov    0x8(%ebp),%eax
  10b139:	89 04 24             	mov    %eax,(%esp)
  10b13c:	e8 8f fe ff ff       	call   10afd0 <e100_eeprom_out>
        delay(1);
  10b141:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  10b148:	e8 d3 f0 ff ff       	call   10a220 <delay>
  10b14d:	d1 7d fc             	sarl   0xfffffffc(%ebp)
  10b150:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  10b154:	7f 97                	jg     10b0ed <e100_eeprom_shiftout+0x1d>
    }
    return data;
  10b156:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10b159:	0f b7 c0             	movzwl %ax,%eax
}
  10b15c:	c9                   	leave  
  10b15d:	c3                   	ret    
  10b15e:	89 f6                	mov    %esi,%esi

0010b160 <e100_eeprom_getword>:

uint16_t
e100_eeprom_getword(e100_dev *dev, int offset)
{
  10b160:	55                   	push   %ebp
  10b161:	89 e5                	mov    %esp,%ebp
  10b163:	83 ec 1c             	sub    $0x1c,%esp
    uint16_t data;
    e100_eeprom_out(dev, EEPROM_EECS);
  10b166:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
  10b16d:	00 
  10b16e:	8b 45 08             	mov    0x8(%ebp),%eax
  10b171:	89 04 24             	mov    %eax,(%esp)
  10b174:	e8 57 fe ff ff       	call   10afd0 <e100_eeprom_out>
    e100_eeprom_shiftin(dev, EEPROM_OP_READ, 3);
  10b179:	c7 44 24 08 03 00 00 	movl   $0x3,0x8(%esp)
  10b180:	00 
  10b181:	c7 44 24 04 06 00 00 	movl   $0x6,0x4(%esp)
  10b188:	00 
  10b189:	8b 45 08             	mov    0x8(%ebp),%eax
  10b18c:	89 04 24             	mov    %eax,(%esp)
  10b18f:	e8 8c fe ff ff       	call   10b020 <e100_eeprom_shiftin>
    e100_eeprom_shiftin(dev, offset, dev->eeprom_size);
  10b194:	8b 45 08             	mov    0x8(%ebp),%eax
  10b197:	8b 80 3c 01 00 00    	mov    0x13c(%eax),%eax
  10b19d:	89 44 24 08          	mov    %eax,0x8(%esp)
  10b1a1:	8b 45 0c             	mov    0xc(%ebp),%eax
  10b1a4:	89 44 24 04          	mov    %eax,0x4(%esp)
  10b1a8:	8b 45 08             	mov    0x8(%ebp),%eax
  10b1ab:	89 04 24             	mov    %eax,(%esp)
  10b1ae:	e8 6d fe ff ff       	call   10b020 <e100_eeprom_shiftin>
    data = e100_eeprom_shiftout(dev);
  10b1b3:	8b 45 08             	mov    0x8(%ebp),%eax
  10b1b6:	89 04 24             	mov    %eax,(%esp)
  10b1b9:	e8 12 ff ff ff       	call   10b0d0 <e100_eeprom_shiftout>
  10b1be:	66 89 45 fe          	mov    %ax,0xfffffffe(%ebp)
    e100_eeprom_out(dev, 0);
  10b1c2:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  10b1c9:	00 
  10b1ca:	8b 45 08             	mov    0x8(%ebp),%eax
  10b1cd:	89 04 24             	mov    %eax,(%esp)
  10b1d0:	e8 fb fd ff ff       	call   10afd0 <e100_eeprom_out>
    return data;
  10b1d5:	0f b7 45 fe          	movzwl 0xfffffffe(%ebp),%eax
}
  10b1d9:	c9                   	leave  
  10b1da:	c3                   	ret    
  10b1db:	90                   	nop    
  10b1dc:	8d 74 26 00          	lea    0x0(%esi),%esi

0010b1e0 <e100_read_eeprom>:

void
e100_read_eeprom(e100_dev *dev, uint16_t *data, int offset, int len)
{
  10b1e0:	55                   	push   %ebp
  10b1e1:	89 e5                	mov    %esp,%ebp
  10b1e3:	53                   	push   %ebx
  10b1e4:	83 ec 18             	sub    $0x18,%esp
    int i;

    for (i=0; i<len; i++)
  10b1e7:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)
  10b1ee:	eb 26                	jmp    10b216 <e100_read_eeprom+0x36>
        data[i] = e100_eeprom_getword(dev, offset+i);
  10b1f0:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10b1f3:	01 c0                	add    %eax,%eax
  10b1f5:	89 c3                	mov    %eax,%ebx
  10b1f7:	03 5d 0c             	add    0xc(%ebp),%ebx
  10b1fa:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10b1fd:	03 45 10             	add    0x10(%ebp),%eax
  10b200:	89 44 24 04          	mov    %eax,0x4(%esp)
  10b204:	8b 45 08             	mov    0x8(%ebp),%eax
  10b207:	89 04 24             	mov    %eax,(%esp)
  10b20a:	e8 51 ff ff ff       	call   10b160 <e100_eeprom_getword>
  10b20f:	66 89 03             	mov    %ax,(%ebx)
  10b212:	83 45 f8 01          	addl   $0x1,0xfffffff8(%ebp)
  10b216:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10b219:	3b 45 14             	cmp    0x14(%ebp),%eax
  10b21c:	7c d2                	jl     10b1f0 <e100_read_eeprom+0x10>
}
  10b21e:	83 c4 18             	add    $0x18,%esp
  10b221:	5b                   	pop    %ebx
  10b222:	5d                   	pop    %ebp
  10b223:	c3                   	ret    
  10b224:	90                   	nop    
  10b225:	90                   	nop    
  10b226:	90                   	nop    
  10b227:	90                   	nop    
  10b228:	90                   	nop    
  10b229:	90                   	nop    
  10b22a:	90                   	nop    
  10b22b:	90                   	nop    
  10b22c:	90                   	nop    
  10b22d:	90                   	nop    
  10b22e:	90                   	nop    
  10b22f:	90                   	nop    

0010b230 <etharp_init>:
 * Initializes ARP module.
 */
void
etharp_init(void)
{
  10b230:	55                   	push   %ebp
  10b231:	89 e5                	mov    %esp,%ebp
  10b233:	83 ec 10             	sub    $0x10,%esp
  s8_t i;
  /* clear ARP entries */
  for(i = 0; i < ARP_TABLE_SIZE; ++i) {
  10b236:	c6 45 ff 00          	movb   $0x0,0xffffffff(%ebp)
  10b23a:	eb 46                	jmp    10b282 <etharp_init+0x52>
    arp_table[i].state = ETHARP_STATE_EMPTY;
  10b23c:	0f be 55 ff          	movsbl 0xffffffff(%ebp),%edx
  10b240:	89 d0                	mov    %edx,%eax
  10b242:	01 c0                	add    %eax,%eax
  10b244:	01 d0                	add    %edx,%eax
  10b246:	c1 e0 03             	shl    $0x3,%eax
  10b249:	c7 80 cc da 11 00 00 	movl   $0x0,0x11dacc(%eax)
  10b250:	00 00 00 
#if ARP_QUEUEING
    arp_table[i].p = NULL;
  10b253:	0f be 55 ff          	movsbl 0xffffffff(%ebp),%edx
  10b257:	89 d0                	mov    %edx,%eax
  10b259:	01 c0                	add    %eax,%eax
  10b25b:	01 d0                	add    %edx,%eax
  10b25d:	c1 e0 03             	shl    $0x3,%eax
  10b260:	c7 80 d0 da 11 00 00 	movl   $0x0,0x11dad0(%eax)
  10b267:	00 00 00 
#endif
    arp_table[i].ctime = 0;
  10b26a:	0f be 55 ff          	movsbl 0xffffffff(%ebp),%edx
  10b26e:	89 d0                	mov    %edx,%eax
  10b270:	01 c0                	add    %eax,%eax
  10b272:	01 d0                	add    %edx,%eax
  10b274:	c1 e0 03             	shl    $0x3,%eax
  10b277:	c6 80 d4 da 11 00 00 	movb   $0x0,0x11dad4(%eax)
  10b27e:	80 45 ff 01          	addb   $0x1,0xffffffff(%ebp)
  10b282:	80 7d ff 09          	cmpb   $0x9,0xffffffff(%ebp)
  10b286:	7e b4                	jle    10b23c <etharp_init+0xc>
  }
}
  10b288:	c9                   	leave  
  10b289:	c3                   	ret    
  10b28a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

0010b290 <etharp_tmr>:

/**
 * Clears expired entries in the ARP table.
 *
 * This function should be called every ETHARP_TMR_INTERVAL microseconds (10 seconds),
 * in order to expire entries in the ARP table.
 */
void
etharp_tmr(void)
{
  10b290:	55                   	push   %ebp
  10b291:	89 e5                	mov    %esp,%ebp
  10b293:	83 ec 18             	sub    $0x18,%esp
  s8_t i;

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  10b296:	c6 45 ff 00          	movb   $0x0,0xffffffff(%ebp)
  10b29a:	e9 ec 00 00 00       	jmp    10b38b <etharp_tmr+0xfb>
    arp_table[i].ctime++;
  10b29f:	0f be 55 ff          	movsbl 0xffffffff(%ebp),%edx
  10b2a3:	89 d0                	mov    %edx,%eax
  10b2a5:	01 c0                	add    %eax,%eax
  10b2a7:	01 d0                	add    %edx,%eax
  10b2a9:	c1 e0 03             	shl    $0x3,%eax
  10b2ac:	0f b6 80 d4 da 11 00 	movzbl 0x11dad4(%eax),%eax
  10b2b3:	8d 48 01             	lea    0x1(%eax),%ecx
  10b2b6:	89 d0                	mov    %edx,%eax
  10b2b8:	01 c0                	add    %eax,%eax
  10b2ba:	01 d0                	add    %edx,%eax
  10b2bc:	c1 e0 03             	shl    $0x3,%eax
  10b2bf:	88 88 d4 da 11 00    	mov    %cl,0x11dad4(%eax)
    /* a resolved/stable entry? */
    if ((arp_table[i].state == ETHARP_STATE_STABLE) &&
  10b2c5:	0f be 55 ff          	movsbl 0xffffffff(%ebp),%edx
  10b2c9:	89 d0                	mov    %edx,%eax
  10b2cb:	01 c0                	add    %eax,%eax
  10b2cd:	01 d0                	add    %edx,%eax
  10b2cf:	c1 e0 03             	shl    $0x3,%eax
  10b2d2:	8b 80 cc da 11 00    	mov    0x11dacc(%eax),%eax
  10b2d8:	83 f8 02             	cmp    $0x2,%eax
  10b2db:	75 1a                	jne    10b2f7 <etharp_tmr+0x67>
  10b2dd:	0f be 55 ff          	movsbl 0xffffffff(%ebp),%edx
  10b2e1:	89 d0                	mov    %edx,%eax
  10b2e3:	01 c0                	add    %eax,%eax
  10b2e5:	01 d0                	add    %edx,%eax
  10b2e7:	c1 e0 03             	shl    $0x3,%eax
  10b2ea:	0f b6 80 d4 da 11 00 	movzbl 0x11dad4(%eax),%eax
  10b2f1:	3c 77                	cmp    $0x77,%al
  10b2f3:	76 02                	jbe    10b2f7 <etharp_tmr+0x67>
         /* entry has become old? */
        (arp_table[i].ctime >= ARP_MAXAGE)) {
      LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer: expired stable entry %u.\n", i));
      goto empty;
  10b2f5:	eb 30                	jmp    10b327 <etharp_tmr+0x97>
    /* an unresolved/pending entry? */
    } else if ((arp_table[i].state == ETHARP_STATE_PENDING) &&
  10b2f7:	0f be 55 ff          	movsbl 0xffffffff(%ebp),%edx
  10b2fb:	89 d0                	mov    %edx,%eax
  10b2fd:	01 c0                	add    %eax,%eax
  10b2ff:	01 d0                	add    %edx,%eax
  10b301:	c1 e0 03             	shl    $0x3,%eax
  10b304:	8b 80 cc da 11 00    	mov    0x11dacc(%eax),%eax
  10b30a:	83 f8 01             	cmp    $0x1,%eax
  10b30d:	75 78                	jne    10b387 <etharp_tmr+0xf7>
  10b30f:	0f be 55 ff          	movsbl 0xffffffff(%ebp),%edx
  10b313:	89 d0                	mov    %edx,%eax
  10b315:	01 c0                	add    %eax,%eax
  10b317:	01 d0                	add    %edx,%eax
  10b319:	c1 e0 03             	shl    $0x3,%eax
  10b31c:	0f b6 80 d4 da 11 00 	movzbl 0x11dad4(%eax),%eax
  10b323:	3c 01                	cmp    $0x1,%al
  10b325:	76 60                	jbe    10b387 <etharp_tmr+0xf7>
         /* entry unresolved/pending for too long? */
        (arp_table[i].ctime >= ARP_MAXPENDING)) {
      LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer: expired pending entry %u.\n", i));
  empty:
      /* empty old entry */      
      arp_table[i].state = ETHARP_STATE_EMPTY;
  10b327:	0f be 55 ff          	movsbl 0xffffffff(%ebp),%edx
  10b32b:	89 d0                	mov    %edx,%eax
  10b32d:	01 c0                	add    %eax,%eax
  10b32f:	01 d0                	add    %edx,%eax
  10b331:	c1 e0 03             	shl    $0x3,%eax
  10b334:	c7 80 cc da 11 00 00 	movl   $0x0,0x11dacc(%eax)
  10b33b:	00 00 00 
#if ARP_QUEUEING
      /* and empty packet queue */
      if (arp_table[i].p != NULL) {
  10b33e:	0f be 55 ff          	movsbl 0xffffffff(%ebp),%edx
  10b342:	89 d0                	mov    %edx,%eax
  10b344:	01 c0                	add    %eax,%eax
  10b346:	01 d0                	add    %edx,%eax
  10b348:	c1 e0 03             	shl    $0x3,%eax
  10b34b:	8b 80 d0 da 11 00    	mov    0x11dad0(%eax),%eax
  10b351:	85 c0                	test   %eax,%eax
  10b353:	74 32                	je     10b387 <etharp_tmr+0xf7>
        /* remove any queued packet */
        LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer: freeing entry %u, packet queue %p.\n", i, (void *)(arp_table[i].p)));
        pbuf_free(arp_table[i].p);
  10b355:	0f be 55 ff          	movsbl 0xffffffff(%ebp),%edx
  10b359:	89 d0                	mov    %edx,%eax
  10b35b:	01 c0                	add    %eax,%eax
  10b35d:	01 d0                	add    %edx,%eax
  10b35f:	c1 e0 03             	shl    $0x3,%eax
  10b362:	8b 80 d0 da 11 00    	mov    0x11dad0(%eax),%eax
  10b368:	89 04 24             	mov    %eax,(%esp)
  10b36b:	e8 40 41 00 00       	call   10f4b0 <pbuf_free>
        arp_table[i].p = NULL;
  10b370:	0f be 55 ff          	movsbl 0xffffffff(%ebp),%edx
  10b374:	89 d0                	mov    %edx,%eax
  10b376:	01 c0                	add    %eax,%eax
  10b378:	01 d0                	add    %edx,%eax
  10b37a:	c1 e0 03             	shl    $0x3,%eax
  10b37d:	c7 80 d0 da 11 00 00 	movl   $0x0,0x11dad0(%eax)
  10b384:	00 00 00 
  10b387:	80 45 ff 01          	addb   $0x1,0xffffffff(%ebp)
  10b38b:	80 7d ff 09          	cmpb   $0x9,0xffffffff(%ebp)
  10b38f:	0f 8e 0a ff ff ff    	jle    10b29f <etharp_tmr+0xf>
      }
#endif
    }
  }
}
  10b395:	c9                   	leave  
  10b396:	c3                   	ret    
  10b397:	89 f6                	mov    %esi,%esi
  10b399:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

0010b3a0 <find_arp_entry>:

/**
 * Return an empty ARP entry (possibly recycling the oldest stable entry).
 *
 * @return The ARP entry index that is available, ERR_MEM if no usable
 * entry is found.
 */
static s8_t
find_arp_entry(void)
{
  10b3a0:	55                   	push   %ebp
  10b3a1:	89 e5                	mov    %esp,%ebp
  10b3a3:	83 ec 18             	sub    $0x18,%esp
  s8_t i, j;
  u8_t maxtime = 0;
  10b3a6:	c6 45 ff 00          	movb   $0x0,0xffffffff(%ebp)

  j = ARP_TABLE_SIZE;
  10b3aa:	c6 45 fe 0a          	movb   $0xa,0xfffffffe(%ebp)
  /* search ARP table for an unused or old entry */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  10b3ae:	c6 45 fd 00          	movb   $0x0,0xfffffffd(%ebp)
  10b3b2:	eb 76                	jmp    10b42a <find_arp_entry+0x8a>
  	/* empty entry? */
    if (arp_table[i].state == ETHARP_STATE_EMPTY) {
  10b3b4:	0f be 55 fd          	movsbl 0xfffffffd(%ebp),%edx
  10b3b8:	89 d0                	mov    %edx,%eax
  10b3ba:	01 c0                	add    %eax,%eax
  10b3bc:	01 d0                	add    %edx,%eax
  10b3be:	c1 e0 03             	shl    $0x3,%eax
  10b3c1:	8b 80 cc da 11 00    	mov    0x11dacc(%eax),%eax
  10b3c7:	85 c0                	test   %eax,%eax
  10b3c9:	75 0c                	jne    10b3d7 <find_arp_entry+0x37>
      LWIP_DEBUGF(ETHARP_DEBUG, ("find_arp_entry: returning empty entry %u\n", i));
      return i;
  10b3cb:	0f be 45 fd          	movsbl 0xfffffffd(%ebp),%eax
  10b3cf:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  10b3d2:	e9 cb 00 00 00       	jmp    10b4a2 <find_arp_entry+0x102>
  	/* stable entry? */
    } else if (arp_table[i].state == ETHARP_STATE_STABLE) {
  10b3d7:	0f be 55 fd          	movsbl 0xfffffffd(%ebp),%edx
  10b3db:	89 d0                	mov    %edx,%eax
  10b3dd:	01 c0                	add    %eax,%eax
  10b3df:	01 d0                	add    %edx,%eax
  10b3e1:	c1 e0 03             	shl    $0x3,%eax
  10b3e4:	8b 80 cc da 11 00    	mov    0x11dacc(%eax),%eax
  10b3ea:	83 f8 02             	cmp    $0x2,%eax
  10b3ed:	75 37                	jne    10b426 <find_arp_entry+0x86>
      /* remember entry with oldest stable entry in j */
      if (arp_table[i].ctime >= maxtime) maxtime = arp_table[j = i].ctime;
  10b3ef:	0f be 55 fd          	movsbl 0xfffffffd(%ebp),%edx
  10b3f3:	89 d0                	mov    %edx,%eax
  10b3f5:	01 c0                	add    %eax,%eax
  10b3f7:	01 d0                	add    %edx,%eax
  10b3f9:	c1 e0 03             	shl    $0x3,%eax
  10b3fc:	0f b6 80 d4 da 11 00 	movzbl 0x11dad4(%eax),%eax
  10b403:	3a 45 ff             	cmp    0xffffffff(%ebp),%al
  10b406:	72 1e                	jb     10b426 <find_arp_entry+0x86>
  10b408:	0f b6 45 fd          	movzbl 0xfffffffd(%ebp),%eax
  10b40c:	88 45 fe             	mov    %al,0xfffffffe(%ebp)
  10b40f:	0f be 55 fe          	movsbl 0xfffffffe(%ebp),%edx
  10b413:	89 d0                	mov    %edx,%eax
  10b415:	01 c0                	add    %eax,%eax
  10b417:	01 d0                	add    %edx,%eax
  10b419:	c1 e0 03             	shl    $0x3,%eax
  10b41c:	0f b6 80 d4 da 11 00 	movzbl 0x11dad4(%eax),%eax
  10b423:	88 45 ff             	mov    %al,0xffffffff(%ebp)
  10b426:	80 45 fd 01          	addb   $0x1,0xfffffffd(%ebp)
  10b42a:	80 7d fd 09          	cmpb   $0x9,0xfffffffd(%ebp)
  10b42e:	7e 84                	jle    10b3b4 <find_arp_entry+0x14>
    }
  }
  /* no empty entry found? */
  if (i == ARP_TABLE_SIZE) {
  10b430:	80 7d fd 0a          	cmpb   $0xa,0xfffffffd(%ebp)
  10b434:	75 07                	jne    10b43d <find_arp_entry+0x9d>
  	LWIP_DEBUGF(ETHARP_DEBUG, ("find_arp_entry: found oldest stable entry %u\n", j));
    /* fall-back to oldest stable */
  	i = j;
  10b436:	0f b6 45 fe          	movzbl 0xfffffffe(%ebp),%eax
  10b43a:	88 45 fd             	mov    %al,0xfffffffd(%ebp)
  }
  /* no available entry found? */
  if (i == ARP_TABLE_SIZE) {
  10b43d:	80 7d fd 0a          	cmpb   $0xa,0xfffffffd(%ebp)
  10b441:	75 09                	jne    10b44c <find_arp_entry+0xac>
    LWIP_DEBUGF(ETHARP_DEBUG, ("find_arp_entry: no replacable entry could be found\n"));
    /* return failure */
    return ERR_MEM;
  10b443:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  10b44a:	eb 56                	jmp    10b4a2 <find_arp_entry+0x102>
  }

  /* clean up the recycled stable entry */
  if (arp_table[i].state == ETHARP_STATE_STABLE) {
  10b44c:	0f be 55 fd          	movsbl 0xfffffffd(%ebp),%edx
  10b450:	89 d0                	mov    %edx,%eax
  10b452:	01 c0                	add    %eax,%eax
  10b454:	01 d0                	add    %edx,%eax
  10b456:	c1 e0 03             	shl    $0x3,%eax
  10b459:	8b 80 cc da 11 00    	mov    0x11dacc(%eax),%eax
  10b45f:	83 f8 02             	cmp    $0x2,%eax
  10b462:	75 37                	jne    10b49b <find_arp_entry+0xfb>
#if ARP_QUEUEING
    /* free packets on queue */
    etharp_dequeue(i);
  10b464:	0f be 45 fd          	movsbl 0xfffffffd(%ebp),%eax
  10b468:	89 04 24             	mov    %eax,(%esp)
  10b46b:	e8 c0 00 00 00       	call   10b530 <etharp_dequeue>
#endif
    LWIP_DEBUGF(ETHARP_DEBUG | DBG_TRACE, ("find_arp_entry: recycling oldest stable entry %u\n", i));
    arp_table[i].state = ETHARP_STATE_EMPTY;
  10b470:	0f be 55 fd          	movsbl 0xfffffffd(%ebp),%edx
  10b474:	89 d0                	mov    %edx,%eax
  10b476:	01 c0                	add    %eax,%eax
  10b478:	01 d0                	add    %edx,%eax
  10b47a:	c1 e0 03             	shl    $0x3,%eax
  10b47d:	c7 80 cc da 11 00 00 	movl   $0x0,0x11dacc(%eax)
  10b484:	00 00 00 
    arp_table[i].ctime = 0;
  10b487:	0f be 55 fd          	movsbl 0xfffffffd(%ebp),%edx
  10b48b:	89 d0                	mov    %edx,%eax
  10b48d:	01 c0                	add    %eax,%eax
  10b48f:	01 d0                	add    %edx,%eax
  10b491:	c1 e0 03             	shl    $0x3,%eax
  10b494:	c6 80 d4 da 11 00 00 	movb   $0x0,0x11dad4(%eax)
  }
  LWIP_DEBUGF(ETHARP_DEBUG, ("find_arp_entry: returning %u\n", i));
  return i;
  10b49b:	0f be 45 fd          	movsbl 0xfffffffd(%ebp),%eax
  10b49f:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  10b4a2:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  10b4a5:	c9                   	leave  
  10b4a6:	c3                   	ret    
  10b4a7:	89 f6                	mov    %esi,%esi
  10b4a9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

0010b4b0 <etharp_enqueue>:

#if ARP_QUEUEING
/*
 * Enqueues a pbuf (chain) on an ARP entry.
 * 
 * Places the pbuf (chain) on the queue (if space allows). The
 * caller may safely free the pbuf (chain) afterwards, as the
 * pbufs will be referenced by the queue and copies are made of
 * pbufs referencing external payloads.
 * 
 * @ i the ARP entry index
 * @arg q the pbuf (chain) to be queued on the ARP entry
 * 
 * @return Returns the new head of queue of the ARP entry.
 * 
 */
static struct pbuf *
etharp_enqueue(s8_t i, struct pbuf *q)
{
  10b4b0:	55                   	push   %ebp
  10b4b1:	89 e5                	mov    %esp,%ebp
  10b4b3:	83 ec 18             	sub    $0x18,%esp
  10b4b6:	8b 45 08             	mov    0x8(%ebp),%eax
  10b4b9:	88 45 ec             	mov    %al,0xffffffec(%ebp)
  /* any pbuf to queue? */
  if (q != NULL) {
  10b4bc:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  10b4c0:	74 59                	je     10b51b <etharp_enqueue+0x6b>
/* queue later packet over earliers? TODO: Implement multiple pbuf queue */
#if ARP_QUEUE_FIRST == 0
    /* remove any pbufs on queue */
    u8_t deq = etharp_dequeue(i);
  10b4c2:	0f be 45 ec          	movsbl 0xffffffec(%ebp),%eax
  10b4c6:	89 04 24             	mov    %eax,(%esp)
  10b4c9:	e8 62 00 00 00       	call   10b530 <etharp_dequeue>
  10b4ce:	88 45 ff             	mov    %al,0xffffffff(%ebp)
    if (deq > 0) LWIP_DEBUGF(ETHARP_DEBUG | DBG_TRACE | 3, ("etharp_query: dequeued %u pbufs from ARP entry %u. Should not occur.\n", deq, i));
#endif
    /* packet can be queued? TODO: Implement multiple pbuf queue */
    if (arp_table[i].p == NULL) {
  10b4d1:	0f be 55 ec          	movsbl 0xffffffec(%ebp),%edx
  10b4d5:	89 d0                	mov    %edx,%eax
  10b4d7:	01 c0                	add    %eax,%eax
  10b4d9:	01 d0                	add    %edx,%eax
  10b4db:	c1 e0 03             	shl    $0x3,%eax
  10b4de:	8b 80 d0 da 11 00    	mov    0x11dad0(%eax),%eax
  10b4e4:	85 c0                	test   %eax,%eax
  10b4e6:	75 33                	jne    10b51b <etharp_enqueue+0x6b>
      /* copy any PBUF_REF referenced payloads into PBUF_RAM */
      q = pbuf_take(q);
  10b4e8:	8b 45 0c             	mov    0xc(%ebp),%eax
  10b4eb:	89 04 24             	mov    %eax,(%esp)
  10b4ee:	e8 7d 42 00 00       	call   10f770 <pbuf_take>
  10b4f3:	89 45 0c             	mov    %eax,0xc(%ebp)
      /* add pbuf to queue */
      arp_table[i].p = q;
  10b4f6:	0f be 55 ec          	movsbl 0xffffffec(%ebp),%edx
  10b4fa:	89 d0                	mov    %edx,%eax
  10b4fc:	01 c0                	add    %eax,%eax
  10b4fe:	01 d0                	add    %edx,%eax
  10b500:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
  10b507:	8b 45 0c             	mov    0xc(%ebp),%eax
  10b50a:	89 82 d0 da 11 00    	mov    %eax,0x11dad0(%edx)
      /* pbuf (chain) now queued, increase the reference count */
      pbuf_ref(q);
  10b510:	8b 45 0c             	mov    0xc(%ebp),%eax
  10b513:	89 04 24             	mov    %eax,(%esp)
  10b516:	e8 05 41 00 00       	call   10f620 <pbuf_ref>
      LWIP_DEBUGF(ETHARP_DEBUG | DBG_TRACE | DBG_STATE, ("etharp_query: queued packet %p on ARP entry %u.\n", (void *)q, i));
    }
  }
  return arp_table[i].p;
  10b51b:	0f be 55 ec          	movsbl 0xffffffec(%ebp),%edx
  10b51f:	89 d0                	mov    %edx,%eax
  10b521:	01 c0                	add    %eax,%eax
  10b523:	01 d0                	add    %edx,%eax
  10b525:	c1 e0 03             	shl    $0x3,%eax
  10b528:	8b 80 d0 da 11 00    	mov    0x11dad0(%eax),%eax
}
  10b52e:	c9                   	leave  
  10b52f:	c3                   	ret    

0010b530 <etharp_dequeue>:

/**
 * Dequeues any pbufs queued on an ARP entry
 * 
 * @return number of pbufs removed from the queue
 * 
 * TODO: decide what is a sensible return value?
 */
static u8_t
etharp_dequeue(s8_t i)
{
  10b530:	55                   	push   %ebp
  10b531:	89 e5                	mov    %esp,%ebp
  10b533:	83 ec 18             	sub    $0x18,%esp
  10b536:	8b 45 08             	mov    0x8(%ebp),%eax
  10b539:	88 45 fc             	mov    %al,0xfffffffc(%ebp)
  /* queued packets on a stable entry (work in progress) */
  if (arp_table[i].p != NULL) {
  10b53c:	0f be 55 fc          	movsbl 0xfffffffc(%ebp),%edx
  10b540:	89 d0                	mov    %edx,%eax
  10b542:	01 c0                	add    %eax,%eax
  10b544:	01 d0                	add    %edx,%eax
  10b546:	c1 e0 03             	shl    $0x3,%eax
  10b549:	8b 80 d0 da 11 00    	mov    0x11dad0(%eax),%eax
  10b54f:	85 c0                	test   %eax,%eax
  10b551:	74 3b                	je     10b58e <etharp_dequeue+0x5e>
  	/* queue no longer references pbuf */
  	pbuf_free(arp_table[i].p);
  10b553:	0f be 55 fc          	movsbl 0xfffffffc(%ebp),%edx
  10b557:	89 d0                	mov    %edx,%eax
  10b559:	01 c0                	add    %eax,%eax
  10b55b:	01 d0                	add    %edx,%eax
  10b55d:	c1 e0 03             	shl    $0x3,%eax
  10b560:	8b 80 d0 da 11 00    	mov    0x11dad0(%eax),%eax
  10b566:	89 04 24             	mov    %eax,(%esp)
  10b569:	e8 42 3f 00 00       	call   10f4b0 <pbuf_free>
    arp_table[i].p = NULL;
  10b56e:	0f be 55 fc          	movsbl 0xfffffffc(%ebp),%edx
  10b572:	89 d0                	mov    %edx,%eax
  10b574:	01 c0                	add    %eax,%eax
  10b576:	01 d0                	add    %edx,%eax
  10b578:	c1 e0 03             	shl    $0x3,%eax
  10b57b:	c7 80 d0 da 11 00 00 	movl   $0x0,0x11dad0(%eax)
  10b582:	00 00 00 
    return 1;
  10b585:	c7 45 f8 01 00 00 00 	movl   $0x1,0xfffffff8(%ebp)
  10b58c:	eb 07                	jmp    10b595 <etharp_dequeue+0x65>
  } else {
    return 0;
  10b58e:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)
  10b595:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  }
}
  10b598:	c9                   	leave  
  10b599:	c3                   	ret    
  10b59a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

0010b5a0 <update_arp_entry>:
#endif

/**
 * Update (or insert) a IP/MAC address pair in the ARP cache.
 *
 * If a pending entry is resolved, any queued packets will be sent
 * at this point.
 * 
 * @param ipaddr IP address of the inserted ARP entry.
 * @param ethaddr Ethernet address of the inserted ARP entry.
 * @param flags Defines behaviour:
 * - ARP_INSERT_FLAG Allows ARP to insert this as a new item. If not specified,
 * only existing ARP entries will be updated.
 *
 * @return pbuf If non-NULL, a packet that was queued on a pending entry.
 * You should sent it and must call pbuf_free() afterwards.
 *
 * @see pbuf_free()
 */
static struct pbuf *
update_arp_entry(struct netif *netif, struct ip_addr *ipaddr, struct eth_addr *ethaddr, u8_t flags)
{
  10b5a0:	55                   	push   %ebp
  10b5a1:	89 e5                	mov    %esp,%ebp
  10b5a3:	53                   	push   %ebx
  10b5a4:	83 ec 44             	sub    $0x44,%esp
  10b5a7:	8b 45 14             	mov    0x14(%ebp),%eax
  10b5aa:	88 45 d8             	mov    %al,0xffffffd8(%ebp)
  s8_t i, k;
  LWIP_DEBUGF(ETHARP_DEBUG | DBG_TRACE | 3, ("update_arp_entry()\n"));
  LWIP_ASSERT("netif->hwaddr_len != 0", netif->hwaddr_len != 0);
  LWIP_DEBUGF(ETHARP_DEBUG | DBG_TRACE, ("update_arp_entry: %u.%u.%u.%u - %02x:%02x:%02x:%02x:%02x:%02x\n", ip4_addr1(ipaddr), ip4_addr2(ipaddr), ip4_addr3(ipaddr), ip4_addr4(ipaddr),
  ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2], ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* do not update for 0.0.0.0 addresses */
  if (ipaddr->addr == 0) {
  10b5ad:	8b 45 0c             	mov    0xc(%ebp),%eax
  10b5b0:	8b 00                	mov    (%eax),%eax
  10b5b2:	85 c0                	test   %eax,%eax
  10b5b4:	75 0c                	jne    10b5c2 <update_arp_entry+0x22>
    LWIP_DEBUGF(ETHARP_DEBUG | DBG_TRACE, ("update_arp_entry: will not add 0.0.0.0 to ARP cache\n"));
    return NULL;
  10b5b6:	c7 45 cc 00 00 00 00 	movl   $0x0,0xffffffcc(%ebp)
  10b5bd:	e9 bf 02 00 00       	jmp    10b881 <update_arp_entry+0x2e1>
  }
  /* Walk through the ARP mapping table and try to find an entry to
  update. If none is found, the IP -> MAC address mapping is
  inserted in the ARP table. */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  10b5c2:	c6 45 ea 00          	movb   $0x0,0xffffffea(%ebp)
  10b5c6:	e9 d5 01 00 00       	jmp    10b7a0 <update_arp_entry+0x200>
    /* Check if the source IP address of the incoming packet matches
    the IP address in this ARP table entry. */
    if (ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
  10b5cb:	8b 45 0c             	mov    0xc(%ebp),%eax
  10b5ce:	8b 08                	mov    (%eax),%ecx
  10b5d0:	0f be 55 ea          	movsbl 0xffffffea(%ebp),%edx
  10b5d4:	89 d0                	mov    %edx,%eax
  10b5d6:	01 c0                	add    %eax,%eax
  10b5d8:	01 d0                	add    %edx,%eax
  10b5da:	c1 e0 03             	shl    $0x3,%eax
  10b5dd:	8b 80 c0 da 11 00    	mov    0x11dac0(%eax),%eax
  10b5e3:	39 c1                	cmp    %eax,%ecx
  10b5e5:	0f 85 b1 01 00 00    	jne    10b79c <update_arp_entry+0x1fc>
      /* pending entry? */
      if (arp_table[i].state == ETHARP_STATE_PENDING) {
  10b5eb:	0f be 55 ea          	movsbl 0xffffffea(%ebp),%edx
  10b5ef:	89 d0                	mov    %edx,%eax
  10b5f1:	01 c0                	add    %eax,%eax
  10b5f3:	01 d0                	add    %edx,%eax
  10b5f5:	c1 e0 03             	shl    $0x3,%eax
  10b5f8:	8b 80 cc da 11 00    	mov    0x11dacc(%eax),%eax
  10b5fe:	83 f8 01             	cmp    $0x1,%eax
  10b601:	75 1b                	jne    10b61e <update_arp_entry+0x7e>
        LWIP_DEBUGF(ETHARP_DEBUG | DBG_TRACE, ("update_arp_entry: pending entry %u goes stable\n", i));
        /* A pending entry was found, mark it stable */
        arp_table[i].state = ETHARP_STATE_STABLE;
  10b603:	0f be 45 ea          	movsbl 0xffffffea(%ebp),%eax
  10b607:	89 c2                	mov    %eax,%edx
  10b609:	01 d2                	add    %edx,%edx
  10b60b:	01 c2                	add    %eax,%edx
  10b60d:	8d 04 d5 00 00 00 00 	lea    0x0(,%edx,8),%eax
  10b614:	c7 80 cc da 11 00 02 	movl   $0x2,0x11dacc(%eax)
  10b61b:	00 00 00 
        /* fall-through to next if */
      }
      /* stable entry? (possibly just marked to become stable) */
      if (arp_table[i].state == ETHARP_STATE_STABLE) {
  10b61e:	0f be 55 ea          	movsbl 0xffffffea(%ebp),%edx
  10b622:	89 d0                	mov    %edx,%eax
  10b624:	01 c0                	add    %eax,%eax
  10b626:	01 d0                	add    %edx,%eax
  10b628:	c1 e0 03             	shl    $0x3,%eax
  10b62b:	8b 80 cc da 11 00    	mov    0x11dacc(%eax),%eax
  10b631:	83 f8 02             	cmp    $0x2,%eax
  10b634:	0f 85 62 01 00 00    	jne    10b79c <update_arp_entry+0x1fc>
#if ARP_QUEUEING
        struct pbuf *p;
        struct eth_hdr *ethhdr;
#endif
        LWIP_DEBUGF(ETHARP_DEBUG | DBG_TRACE, ("update_arp_entry: updating stable entry %u\n", i));
        /* An old entry found, update this and return. */
        for (k = 0; k < netif->hwaddr_len; ++k) {
  10b63a:	c6 45 eb 00          	movb   $0x0,0xffffffeb(%ebp)
  10b63e:	eb 2a                	jmp    10b66a <update_arp_entry+0xca>
          arp_table[i].ethaddr.addr[k] = ethaddr->addr[k];
  10b640:	0f be 4d ea          	movsbl 0xffffffea(%ebp),%ecx
  10b644:	0f be 5d eb          	movsbl 0xffffffeb(%ebp),%ebx
  10b648:	0f be 55 eb          	movsbl 0xffffffeb(%ebp),%edx
  10b64c:	8b 45 10             	mov    0x10(%ebp),%eax
  10b64f:	0f b6 14 10          	movzbl (%eax,%edx,1),%edx
  10b653:	89 c8                	mov    %ecx,%eax
  10b655:	01 c0                	add    %eax,%eax
  10b657:	01 c8                	add    %ecx,%eax
  10b659:	c1 e0 03             	shl    $0x3,%eax
  10b65c:	01 d8                	add    %ebx,%eax
  10b65e:	05 c0 da 11 00       	add    $0x11dac0,%eax
  10b663:	88 50 04             	mov    %dl,0x4(%eax)
  10b666:	80 45 eb 01          	addb   $0x1,0xffffffeb(%ebp)
  10b66a:	0f be 55 eb          	movsbl 0xffffffeb(%ebp),%edx
  10b66e:	8b 45 08             	mov    0x8(%ebp),%eax
  10b671:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  10b675:	0f b6 c0             	movzbl %al,%eax
  10b678:	39 c2                	cmp    %eax,%edx
  10b67a:	7c c4                	jl     10b640 <update_arp_entry+0xa0>
        }
        /* reset time stamp */
        arp_table[i].ctime = 0;
  10b67c:	0f be 55 ea          	movsbl 0xffffffea(%ebp),%edx
  10b680:	89 d0                	mov    %edx,%eax
  10b682:	01 c0                	add    %eax,%eax
  10b684:	01 d0                	add    %edx,%eax
  10b686:	c1 e0 03             	shl    $0x3,%eax
  10b689:	c6 80 d4 da 11 00 00 	movb   $0x0,0x11dad4(%eax)
/* this is where we will send out queued packets! */
#if ARP_QUEUEING
        /* get the first packet on the queue (if any) */
        p = arp_table[i].p;
  10b690:	0f be 55 ea          	movsbl 0xffffffea(%ebp),%edx
  10b694:	89 d0                	mov    %edx,%eax
  10b696:	01 c0                	add    %eax,%eax
  10b698:	01 d0                	add    %edx,%eax
  10b69a:	c1 e0 03             	shl    $0x3,%eax
  10b69d:	8b 80 d0 da 11 00    	mov    0x11dad0(%eax),%eax
  10b6a3:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
        /* (another) queued packet present? */
        while (p != NULL) {
  10b6a6:	e9 c0 00 00 00       	jmp    10b76b <update_arp_entry+0x1cb>
          struct pbuf *q, *n;
          /* search for second packet on queue (n) */
          q = p;
  10b6ab:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10b6ae:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
          while (q->tot_len > q->len) {
  10b6b1:	eb 08                	jmp    10b6bb <update_arp_entry+0x11b>
            LWIP_ASSERT("q->next != NULL (while q->tot_len > q->len)", q->next != NULL);
            /* proceed to next pbuf of this packet */
            q = q->next;
  10b6b3:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10b6b6:	8b 00                	mov    (%eax),%eax
  10b6b8:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  10b6bb:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10b6be:	0f b7 50 08          	movzwl 0x8(%eax),%edx
  10b6c2:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10b6c5:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  10b6c9:	66 39 c2             	cmp    %ax,%dx
  10b6cc:	77 e5                	ja     10b6b3 <update_arp_entry+0x113>
          }
          /* { q = last pbuf of this packet, q->tot_len == q->len } */
          LWIP_ASSERT("q->tot_len == q->len", q->tot_len == q->len);
          /* remember next packet on queue */
          n = q->next;
  10b6ce:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10b6d1:	8b 00                	mov    (%eax),%eax
  10b6d3:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
          /* { n = first pbuf of next packet, or NULL if no next packet } */
          /* terminate this packet pbuf chain */
          q->next = NULL;
  10b6d6:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10b6d9:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
          /* fill-in Ethernet header */
          ethhdr = p->payload;
  10b6df:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10b6e2:	8b 40 04             	mov    0x4(%eax),%eax
  10b6e5:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
          for (k = 0; k < netif->hwaddr_len; ++k) {
  10b6e8:	c6 45 eb 00          	movb   $0x0,0xffffffeb(%ebp)
  10b6ec:	eb 30                	jmp    10b71e <update_arp_entry+0x17e>
            ethhdr->dest.addr[k] = ethaddr->addr[k];
  10b6ee:	0f be 4d eb          	movsbl 0xffffffeb(%ebp),%ecx
  10b6f2:	0f be 55 eb          	movsbl 0xffffffeb(%ebp),%edx
  10b6f6:	8b 45 10             	mov    0x10(%ebp),%eax
  10b6f9:	0f b6 14 10          	movzbl (%eax,%edx,1),%edx
  10b6fd:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10b700:	88 14 08             	mov    %dl,(%eax,%ecx,1)
            ethhdr->src.addr[k] = netif->hwaddr[k];
  10b703:	0f be 4d eb          	movsbl 0xffffffeb(%ebp),%ecx
  10b707:	0f be 55 eb          	movsbl 0xffffffeb(%ebp),%edx
  10b70b:	8b 45 08             	mov    0x8(%ebp),%eax
  10b70e:	0f b6 54 02 21       	movzbl 0x21(%edx,%eax,1),%edx
  10b713:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10b716:	88 54 01 06          	mov    %dl,0x6(%ecx,%eax,1)
  10b71a:	80 45 eb 01          	addb   $0x1,0xffffffeb(%ebp)
  10b71e:	0f be 55 eb          	movsbl 0xffffffeb(%ebp),%edx
  10b722:	8b 45 08             	mov    0x8(%ebp),%eax
  10b725:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  10b729:	0f b6 c0             	movzbl %al,%eax
  10b72c:	39 c2                	cmp    %eax,%edx
  10b72e:	7c be                	jl     10b6ee <update_arp_entry+0x14e>
          }
          ethhdr->type = htons(ETHTYPE_IP);
  10b730:	c7 04 24 00 08 00 00 	movl   $0x800,(%esp)
  10b737:	e8 34 2b 00 00       	call   10e270 <htons>
  10b73c:	89 c2                	mov    %eax,%edx
  10b73e:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10b741:	66 89 50 0c          	mov    %dx,0xc(%eax)
          LWIP_DEBUGF(ETHARP_DEBUG | DBG_TRACE, ("update_arp_entry: sending queued IP packet %p.\n", (void *)p));
          /* send the queued IP packet */
          netif->linkoutput(netif, p);
  10b745:	8b 45 08             	mov    0x8(%ebp),%eax
  10b748:	8b 50 18             	mov    0x18(%eax),%edx
  10b74b:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10b74e:	89 44 24 04          	mov    %eax,0x4(%esp)
  10b752:	8b 45 08             	mov    0x8(%ebp),%eax
  10b755:	89 04 24             	mov    %eax,(%esp)
  10b758:	ff d2                	call   *%edx
          /* free the queued IP packet */
          pbuf_free(p);
  10b75a:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10b75d:	89 04 24             	mov    %eax,(%esp)
  10b760:	e8 4b 3d 00 00       	call   10f4b0 <pbuf_free>
          /* proceed to next packet on queue */
          p = n;
  10b765:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10b768:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  10b76b:	83 7d ec 00          	cmpl   $0x0,0xffffffec(%ebp)
  10b76f:	0f 85 36 ff ff ff    	jne    10b6ab <update_arp_entry+0x10b>
        }
        /* NULL attached buffer*/
        arp_table[i].p = NULL;
  10b775:	0f be 45 ea          	movsbl 0xffffffea(%ebp),%eax
  10b779:	89 c2                	mov    %eax,%edx
  10b77b:	01 d2                	add    %edx,%edx
  10b77d:	01 c2                	add    %eax,%edx
  10b77f:	8d 04 d5 00 00 00 00 	lea    0x0(,%edx,8),%eax
  10b786:	c7 80 d0 da 11 00 00 	movl   $0x0,0x11dad0(%eax)
  10b78d:	00 00 00 
#endif
        /* IP addresses should only occur once in the ARP entry, we are done */
        return NULL;
  10b790:	c7 45 cc 00 00 00 00 	movl   $0x0,0xffffffcc(%ebp)
  10b797:	e9 e5 00 00 00       	jmp    10b881 <update_arp_entry+0x2e1>
  10b79c:	80 45 ea 01          	addb   $0x1,0xffffffea(%ebp)
  10b7a0:	80 7d ea 09          	cmpb   $0x9,0xffffffea(%ebp)
  10b7a4:	0f 8e 21 fe ff ff    	jle    10b5cb <update_arp_entry+0x2b>
      }
    } /* if STABLE */
  } /* for all ARP entries */

  /* no matching ARP entry was found */
  LWIP_ASSERT("update_arp_entry: i == ARP_TABLE_SIZE", i == ARP_TABLE_SIZE);

  LWIP_DEBUGF(ETHARP_DEBUG | DBG_TRACE, ("update_arp_entry: IP address not yet in table\n"));
  /* allowed to insert an entry? */
  if ((ETHARP_ALWAYS_INSERT) || (flags & ARP_INSERT_FLAG))
  {
    LWIP_DEBUGF(ETHARP_DEBUG | DBG_TRACE, ("update_arp_entry: adding entry to table\n"));
    /* find an empty or old entry. */
    i = find_arp_entry();
  10b7aa:	e8 f1 fb ff ff       	call   10b3a0 <find_arp_entry>
  10b7af:	88 45 ea             	mov    %al,0xffffffea(%ebp)
    if (i == ERR_MEM) {
  10b7b2:	80 7d ea ff          	cmpb   $0xff,0xffffffea(%ebp)
  10b7b6:	75 0c                	jne    10b7c4 <update_arp_entry+0x224>
      LWIP_DEBUGF(ETHARP_DEBUG | DBG_TRACE, ("update_arp_entry: no available entry found\n"));
      return NULL;
  10b7b8:	c7 45 cc 00 00 00 00 	movl   $0x0,0xffffffcc(%ebp)
  10b7bf:	e9 bd 00 00 00       	jmp    10b881 <update_arp_entry+0x2e1>
    }
    /* set IP address */
    ip_addr_set(&arp_table[i].ipaddr, ipaddr);
  10b7c4:	0f be 45 ea          	movsbl 0xffffffea(%ebp),%eax
  10b7c8:	89 45 d0             	mov    %eax,0xffffffd0(%ebp)
  10b7cb:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  10b7cf:	74 0a                	je     10b7db <update_arp_entry+0x23b>
  10b7d1:	8b 45 0c             	mov    0xc(%ebp),%eax
  10b7d4:	8b 00                	mov    (%eax),%eax
  10b7d6:	89 45 d4             	mov    %eax,0xffffffd4(%ebp)
  10b7d9:	eb 07                	jmp    10b7e2 <update_arp_entry+0x242>
  10b7db:	c7 45 d4 00 00 00 00 	movl   $0x0,0xffffffd4(%ebp)
  10b7e2:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
  10b7e5:	01 c0                	add    %eax,%eax
  10b7e7:	03 45 d0             	add    0xffffffd0(%ebp),%eax
  10b7ea:	c1 e0 03             	shl    $0x3,%eax
  10b7ed:	8b 55 d4             	mov    0xffffffd4(%ebp),%edx
  10b7f0:	89 90 c0 da 11 00    	mov    %edx,0x11dac0(%eax)
    /* set Ethernet hardware address */
    for (k = 0; k < netif->hwaddr_len; ++k) {
  10b7f6:	c6 45 eb 00          	movb   $0x0,0xffffffeb(%ebp)
  10b7fa:	eb 2a                	jmp    10b826 <update_arp_entry+0x286>
      arp_table[i].ethaddr.addr[k] = ethaddr->addr[k];
  10b7fc:	0f be 4d ea          	movsbl 0xffffffea(%ebp),%ecx
  10b800:	0f be 5d eb          	movsbl 0xffffffeb(%ebp),%ebx
  10b804:	0f be 55 eb          	movsbl 0xffffffeb(%ebp),%edx
  10b808:	8b 45 10             	mov    0x10(%ebp),%eax
  10b80b:	0f b6 14 10          	movzbl (%eax,%edx,1),%edx
  10b80f:	89 c8                	mov    %ecx,%eax
  10b811:	01 c0                	add    %eax,%eax
  10b813:	01 c8                	add    %ecx,%eax
  10b815:	c1 e0 03             	shl    $0x3,%eax
  10b818:	01 d8                	add    %ebx,%eax
  10b81a:	05 c0 da 11 00       	add    $0x11dac0,%eax
  10b81f:	88 50 04             	mov    %dl,0x4(%eax)
  10b822:	80 45 eb 01          	addb   $0x1,0xffffffeb(%ebp)
  10b826:	0f be 55 eb          	movsbl 0xffffffeb(%ebp),%edx
  10b82a:	8b 45 08             	mov    0x8(%ebp),%eax
  10b82d:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  10b831:	0f b6 c0             	movzbl %al,%eax
  10b834:	39 c2                	cmp    %eax,%edx
  10b836:	7c c4                	jl     10b7fc <update_arp_entry+0x25c>
    }
    /* reset time-stamp */
    arp_table[i].ctime = 0;
  10b838:	0f be 55 ea          	movsbl 0xffffffea(%ebp),%edx
  10b83c:	89 d0                	mov    %edx,%eax
  10b83e:	01 c0                	add    %eax,%eax
  10b840:	01 d0                	add    %edx,%eax
  10b842:	c1 e0 03             	shl    $0x3,%eax
  10b845:	c6 80 d4 da 11 00 00 	movb   $0x0,0x11dad4(%eax)
    /* mark as stable */
    arp_table[i].state = ETHARP_STATE_STABLE;
  10b84c:	0f be 55 ea          	movsbl 0xffffffea(%ebp),%edx
  10b850:	89 d0                	mov    %edx,%eax
  10b852:	01 c0                	add    %eax,%eax
  10b854:	01 d0                	add    %edx,%eax
  10b856:	c1 e0 03             	shl    $0x3,%eax
  10b859:	c7 80 cc da 11 00 02 	movl   $0x2,0x11dacc(%eax)
  10b860:	00 00 00 
    /* no queued packet */
#if ARP_QUEUEING
    arp_table[i].p = NULL;
  10b863:	0f be 55 ea          	movsbl 0xffffffea(%ebp),%edx
  10b867:	89 d0                	mov    %edx,%eax
  10b869:	01 c0                	add    %eax,%eax
  10b86b:	01 d0                	add    %edx,%eax
  10b86d:	c1 e0 03             	shl    $0x3,%eax
  10b870:	c7 80 d0 da 11 00 00 	movl   $0x0,0x11dad0(%eax)
  10b877:	00 00 00 
#endif
  }
  else
  {
    LWIP_DEBUGF(ETHARP_DEBUG | DBG_TRACE, ("update_arp_entry: no matching stable entry to update\n"));
  }
  return NULL;
  10b87a:	c7 45 cc 00 00 00 00 	movl   $0x0,0xffffffcc(%ebp)
  10b881:	8b 45 cc             	mov    0xffffffcc(%ebp),%eax
}
  10b884:	83 c4 44             	add    $0x44,%esp
  10b887:	5b                   	pop    %ebx
  10b888:	5d                   	pop    %ebp
  10b889:	c3                   	ret    
  10b88a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

0010b890 <etharp_ip_input>:

/**
 * Updates the ARP table using the given IP packet.
 *
 * Uses the incoming IP packet's source address to update the
 * ARP cache for the local network. The function does not alter
 * or free the packet. This function must be called before the
 * packet p is passed to the IP layer.
 *
 * @param netif The lwIP network interface on which the IP packet pbuf arrived.
 * @param pbuf The IP packet that arrived on netif.
 *
 * @return NULL
 *
 * @see pbuf_free()
 */
struct pbuf *
etharp_ip_input(struct netif *netif, struct pbuf *p)
{
  10b890:	55                   	push   %ebp
  10b891:	89 e5                	mov    %esp,%ebp
  10b893:	83 ec 28             	sub    $0x28,%esp
  struct ethip_hdr *hdr;

  /* Only insert an entry if the source IP address of the
     incoming IP packet comes from a host on the local network. */
  hdr = p->payload;
  10b896:	8b 45 0c             	mov    0xc(%ebp),%eax
  10b899:	8b 40 04             	mov    0x4(%eax),%eax
  10b89c:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  /* source is on local network? */
  if (!ip_addr_maskcmp(&(hdr->ip.src), &(netif->ip_addr), &(netif->netmask))) {
  10b89f:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10b8a2:	8b 50 1a             	mov    0x1a(%eax),%edx
  10b8a5:	8b 45 08             	mov    0x8(%ebp),%eax
  10b8a8:	8b 40 08             	mov    0x8(%eax),%eax
  10b8ab:	89 d1                	mov    %edx,%ecx
  10b8ad:	21 c1                	and    %eax,%ecx
  10b8af:	8b 45 08             	mov    0x8(%ebp),%eax
  10b8b2:	8b 50 04             	mov    0x4(%eax),%edx
  10b8b5:	8b 45 08             	mov    0x8(%ebp),%eax
  10b8b8:	8b 40 08             	mov    0x8(%eax),%eax
  10b8bb:	21 d0                	and    %edx,%eax
  10b8bd:	39 c1                	cmp    %eax,%ecx
  10b8bf:	74 09                	je     10b8ca <etharp_ip_input+0x3a>
    /* do nothing */
    return NULL;
  10b8c1:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  10b8c8:	eb 2e                	jmp    10b8f8 <etharp_ip_input+0x68>
  }

  LWIP_DEBUGF(ETHARP_DEBUG | DBG_TRACE, ("etharp_ip_input: updating ETHARP table.\n"));
  /* update ARP table, ask to insert entry */
  update_arp_entry(netif, &(hdr->ip.src), &(hdr->eth.src), ARP_INSERT_FLAG);
  10b8ca:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10b8cd:	83 c0 06             	add    $0x6,%eax
  10b8d0:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  10b8d3:	83 c2 1a             	add    $0x1a,%edx
  10b8d6:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
  10b8dd:	00 
  10b8de:	89 44 24 08          	mov    %eax,0x8(%esp)
  10b8e2:	89 54 24 04          	mov    %edx,0x4(%esp)
  10b8e6:	8b 45 08             	mov    0x8(%ebp),%eax
  10b8e9:	89 04 24             	mov    %eax,(%esp)
  10b8ec:	e8 af fc ff ff       	call   10b5a0 <update_arp_entry>
  return NULL;
  10b8f1:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  10b8f8:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  10b8fb:	c9                   	leave  
  10b8fc:	c3                   	ret    
  10b8fd:	8d 76 00             	lea    0x0(%esi),%esi

0010b900 <etharp_arp_input>:


/**
 * Responds to ARP requests to us. Upon ARP replies to us, add entry to cache  
 * send out queued IP packets. Updates cache with snooped address pairs.
 *
 * Should be called for incoming ARP packets. The pbuf in the argument
 * is freed by this function.
 *
 * @param netif The lwIP network interface on which the ARP packet pbuf arrived.
 * @param pbuf The ARP packet that arrived on netif. Is freed by this function.
 * @param ethaddr Ethernet address of netif.
 *
 * @return NULL
 *
 * @see pbuf_free()
 */
struct pbuf *
etharp_arp_input(struct netif *netif, struct eth_addr *ethaddr, struct pbuf *p)
{
  10b900:	55                   	push   %ebp
  10b901:	89 e5                	mov    %esp,%ebp
  10b903:	83 ec 38             	sub    $0x38,%esp
  struct etharp_hdr *hdr;
  u8_t i;
  u8_t for_us;

  /* drop short ARP packets */
  if (p->tot_len < sizeof(struct etharp_hdr)) {
  10b906:	8b 45 10             	mov    0x10(%ebp),%eax
  10b909:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  10b90d:	66 83 f8 29          	cmp    $0x29,%ax
  10b911:	77 17                	ja     10b92a <etharp_arp_input+0x2a>
    LWIP_DEBUGF(ETHARP_DEBUG | DBG_TRACE | 1, ("etharp_arp_input: packet dropped, too short (%d/%d)\n", p->tot_len, sizeof(struct etharp_hdr)));
    pbuf_free(p);
  10b913:	8b 45 10             	mov    0x10(%ebp),%eax
  10b916:	89 04 24             	mov    %eax,(%esp)
  10b919:	e8 92 3b 00 00       	call   10f4b0 <pbuf_free>
    return NULL;
  10b91e:	c7 45 e4 00 00 00 00 	movl   $0x0,0xffffffe4(%ebp)
  10b925:	e9 69 02 00 00       	jmp    10bb93 <etharp_arp_input+0x293>
  }

  hdr = p->payload;
  10b92a:	8b 45 10             	mov    0x10(%ebp),%eax
  10b92d:	8b 40 04             	mov    0x4(%eax),%eax
  10b930:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
 
  /* this interface is not configured? */
  if (netif->ip_addr.addr == 0) {
  10b933:	8b 45 08             	mov    0x8(%ebp),%eax
  10b936:	8b 40 04             	mov    0x4(%eax),%eax
  10b939:	85 c0                	test   %eax,%eax
  10b93b:	75 06                	jne    10b943 <etharp_arp_input+0x43>
    for_us = 0;
  10b93d:	c6 45 ff 00          	movb   $0x0,0xffffffff(%ebp)
  10b941:	eb 14                	jmp    10b957 <etharp_arp_input+0x57>
  } else {
    /* ARP packet directed to us? */
    for_us = ip_addr_cmp(&(hdr->dipaddr), &(netif->ip_addr));
  10b943:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10b946:	8b 50 26             	mov    0x26(%eax),%edx
  10b949:	8b 45 08             	mov    0x8(%ebp),%eax
  10b94c:	8b 40 04             	mov    0x4(%eax),%eax
  10b94f:	39 c2                	cmp    %eax,%edx
  10b951:	0f 94 c0             	sete   %al
  10b954:	88 45 ff             	mov    %al,0xffffffff(%ebp)
  }

  /* add or update entries in the ARP cache */
  if (for_us) {
  10b957:	80 7d ff 00          	cmpb   $0x0,0xffffffff(%ebp)
  10b95b:	74 29                	je     10b986 <etharp_arp_input+0x86>
    /* insert IP address in ARP cache (assume requester wants to talk to us)
     * we might even send out a queued packet to this host */
    update_arp_entry(netif, &(hdr->sipaddr), &(hdr->shwaddr), ARP_INSERT_FLAG);
  10b95d:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10b960:	83 c0 16             	add    $0x16,%eax
  10b963:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  10b966:	83 c2 1c             	add    $0x1c,%edx
  10b969:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
  10b970:	00 
  10b971:	89 44 24 08          	mov    %eax,0x8(%esp)
  10b975:	89 54 24 04          	mov    %edx,0x4(%esp)
  10b979:	8b 45 08             	mov    0x8(%ebp),%eax
  10b97c:	89 04 24             	mov    %eax,(%esp)
  10b97f:	e8 1c fc ff ff       	call   10b5a0 <update_arp_entry>
  10b984:	eb 27                	jmp    10b9ad <etharp_arp_input+0xad>
  /* request was not directed to us, but snoop anyway */
  } else {
    /* update the source IP address in the cache */
    update_arp_entry(netif, &(hdr->sipaddr), &(hdr->shwaddr), 0);
  10b986:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10b989:	83 c0 16             	add    $0x16,%eax
  10b98c:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  10b98f:	83 c2 1c             	add    $0x1c,%edx
  10b992:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  10b999:	00 
  10b99a:	89 44 24 08          	mov    %eax,0x8(%esp)
  10b99e:	89 54 24 04          	mov    %edx,0x4(%esp)
  10b9a2:	8b 45 08             	mov    0x8(%ebp),%eax
  10b9a5:	89 04 24             	mov    %eax,(%esp)
  10b9a8:	e8 f3 fb ff ff       	call   10b5a0 <update_arp_entry>
  }

  switch (htons(hdr->opcode)) {
  10b9ad:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10b9b0:	0f b7 40 14          	movzwl 0x14(%eax),%eax
  10b9b4:	0f b7 c0             	movzwl %ax,%eax
  10b9b7:	89 04 24             	mov    %eax,(%esp)
  10b9ba:	e8 b1 28 00 00       	call   10e270 <htons>
  10b9bf:	0f b7 c0             	movzwl %ax,%eax
  10b9c2:	83 f8 01             	cmp    $0x1,%eax
  10b9c5:	74 05                	je     10b9cc <etharp_arp_input+0xcc>
  10b9c7:	e9 ae 01 00 00       	jmp    10bb7a <etharp_arp_input+0x27a>
  /* ARP request? */
  case ARP_REQUEST:
    /* ARP request. If it asked for our address, we send out a
    reply. In any case, we time-stamp any existing ARP entry,
    and possiby send out an IP packet that was queued on it. */

    LWIP_DEBUGF (ETHARP_DEBUG | DBG_TRACE, ("etharp_arp_input: incoming ARP request\n"));
    /* we are not configured? */
    if (netif->ip_addr.addr == 0) {
  10b9cc:	8b 45 08             	mov    0x8(%ebp),%eax
  10b9cf:	8b 40 04             	mov    0x4(%eax),%eax
  10b9d2:	85 c0                	test   %eax,%eax
  10b9d4:	75 17                	jne    10b9ed <etharp_arp_input+0xed>
      LWIP_DEBUGF(ETHARP_DEBUG | DBG_TRACE, ("etharp_arp_input: we are unconfigured, ARP request ignored.\n"));
      pbuf_free(p);
  10b9d6:	8b 45 10             	mov    0x10(%ebp),%eax
  10b9d9:	89 04 24             	mov    %eax,(%esp)
  10b9dc:	e8 cf 3a 00 00       	call   10f4b0 <pbuf_free>
      return NULL;
  10b9e1:	c7 45 e4 00 00 00 00 	movl   $0x0,0xffffffe4(%ebp)
  10b9e8:	e9 a6 01 00 00       	jmp    10bb93 <etharp_arp_input+0x293>
    }
    /* ARP request for our address? */
    if (for_us) {
  10b9ed:	80 7d ff 00          	cmpb   $0x0,0xffffffff(%ebp)
  10b9f1:	0f 84 83 01 00 00    	je     10bb7a <etharp_arp_input+0x27a>

      LWIP_DEBUGF(ETHARP_DEBUG | DBG_TRACE, ("etharp_arp_input: replying to ARP request for our IP address\n"));
      /* re-use pbuf to send ARP reply */
      hdr->opcode = htons(ARP_REPLY);
  10b9f7:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  10b9fe:	e8 6d 28 00 00       	call   10e270 <htons>
  10ba03:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  10ba06:	66 89 42 14          	mov    %ax,0x14(%edx)

      ip_addr_set(&(hdr->dipaddr), &(hdr->sipaddr));
  10ba0a:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10ba0d:	83 c0 1c             	add    $0x1c,%eax
  10ba10:	85 c0                	test   %eax,%eax
  10ba12:	74 0b                	je     10ba1f <etharp_arp_input+0x11f>
  10ba14:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10ba17:	8b 40 1c             	mov    0x1c(%eax),%eax
  10ba1a:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
  10ba1d:	eb 07                	jmp    10ba26 <etharp_arp_input+0x126>
  10ba1f:	c7 45 e8 00 00 00 00 	movl   $0x0,0xffffffe8(%ebp)
  10ba26:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10ba29:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
  10ba2c:	89 50 26             	mov    %edx,0x26(%eax)
      ip_addr_set(&(hdr->sipaddr), &(netif->ip_addr));
  10ba2f:	8b 45 08             	mov    0x8(%ebp),%eax
  10ba32:	83 c0 04             	add    $0x4,%eax
  10ba35:	85 c0                	test   %eax,%eax
  10ba37:	74 0b                	je     10ba44 <etharp_arp_input+0x144>
  10ba39:	8b 45 08             	mov    0x8(%ebp),%eax
  10ba3c:	8b 40 04             	mov    0x4(%eax),%eax
  10ba3f:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  10ba42:	eb 07                	jmp    10ba4b <etharp_arp_input+0x14b>
  10ba44:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  10ba4b:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10ba4e:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
  10ba51:	89 50 1c             	mov    %edx,0x1c(%eax)

      for(i = 0; i < netif->hwaddr_len; ++i) {
  10ba54:	c6 45 fe 00          	movb   $0x0,0xfffffffe(%ebp)
  10ba58:	eb 5d                	jmp    10bab7 <etharp_arp_input+0x1b7>
        hdr->dhwaddr.addr[i] = hdr->shwaddr.addr[i];
  10ba5a:	0f b6 4d fe          	movzbl 0xfffffffe(%ebp),%ecx
  10ba5e:	0f b6 55 fe          	movzbl 0xfffffffe(%ebp),%edx
  10ba62:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10ba65:	0f b6 54 02 16       	movzbl 0x16(%edx,%eax,1),%edx
  10ba6a:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10ba6d:	88 54 01 20          	mov    %dl,0x20(%ecx,%eax,1)
        hdr->shwaddr.addr[i] = ethaddr->addr[i];
  10ba71:	0f b6 4d fe          	movzbl 0xfffffffe(%ebp),%ecx
  10ba75:	0f b6 55 fe          	movzbl 0xfffffffe(%ebp),%edx
  10ba79:	8b 45 0c             	mov    0xc(%ebp),%eax
  10ba7c:	0f b6 14 10          	movzbl (%eax,%edx,1),%edx
  10ba80:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10ba83:	88 54 01 16          	mov    %dl,0x16(%ecx,%eax,1)
        hdr->ethhdr.dest.addr[i] = hdr->dhwaddr.addr[i];
  10ba87:	0f b6 4d fe          	movzbl 0xfffffffe(%ebp),%ecx
  10ba8b:	0f b6 55 fe          	movzbl 0xfffffffe(%ebp),%edx
  10ba8f:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10ba92:	0f b6 54 02 20       	movzbl 0x20(%edx,%eax,1),%edx
  10ba97:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10ba9a:	88 14 08             	mov    %dl,(%eax,%ecx,1)
        hdr->ethhdr.src.addr[i] = ethaddr->addr[i];
  10ba9d:	0f b6 4d fe          	movzbl 0xfffffffe(%ebp),%ecx
  10baa1:	0f b6 55 fe          	movzbl 0xfffffffe(%ebp),%edx
  10baa5:	8b 45 0c             	mov    0xc(%ebp),%eax
  10baa8:	0f b6 14 10          	movzbl (%eax,%edx,1),%edx
  10baac:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10baaf:	88 54 01 06          	mov    %dl,0x6(%ecx,%eax,1)
  10bab3:	80 45 fe 01          	addb   $0x1,0xfffffffe(%ebp)
  10bab7:	8b 45 08             	mov    0x8(%ebp),%eax
  10baba:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  10babe:	3a 45 fe             	cmp    0xfffffffe(%ebp),%al
  10bac1:	77 97                	ja     10ba5a <etharp_arp_input+0x15a>
      }

      hdr->hwtype = htons(HWTYPE_ETHERNET);
  10bac3:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  10baca:	e8 a1 27 00 00       	call   10e270 <htons>
  10bacf:	89 c2                	mov    %eax,%edx
  10bad1:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10bad4:	66 89 50 0e          	mov    %dx,0xe(%eax)
      ARPH_HWLEN_SET(hdr, netif->hwaddr_len);
  10bad8:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10badb:	0f b7 40 12          	movzwl 0x12(%eax),%eax
  10badf:	0f b7 c0             	movzwl %ax,%eax
  10bae2:	89 04 24             	mov    %eax,(%esp)
  10bae5:	e8 b6 27 00 00       	call   10e2a0 <ntohs>
  10baea:	0f b6 d0             	movzbl %al,%edx
  10baed:	8b 45 08             	mov    0x8(%ebp),%eax
  10baf0:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  10baf4:	0f b6 c0             	movzbl %al,%eax
  10baf7:	c1 e0 08             	shl    $0x8,%eax
  10bafa:	09 d0                	or     %edx,%eax
  10bafc:	0f b7 c0             	movzwl %ax,%eax
  10baff:	89 04 24             	mov    %eax,(%esp)
  10bb02:	e8 69 27 00 00       	call   10e270 <htons>
  10bb07:	89 c2                	mov    %eax,%edx
  10bb09:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10bb0c:	66 89 50 12          	mov    %dx,0x12(%eax)

      hdr->proto = htons(ETHTYPE_IP);
  10bb10:	c7 04 24 00 08 00 00 	movl   $0x800,(%esp)
  10bb17:	e8 54 27 00 00       	call   10e270 <htons>
  10bb1c:	89 c2                	mov    %eax,%edx
  10bb1e:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10bb21:	66 89 50 10          	mov    %dx,0x10(%eax)
      ARPH_PROTOLEN_SET(hdr, sizeof(struct ip_addr));
  10bb25:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10bb28:	0f b7 40 12          	movzwl 0x12(%eax),%eax
  10bb2c:	0f b7 c0             	movzwl %ax,%eax
  10bb2f:	89 04 24             	mov    %eax,(%esp)
  10bb32:	e8 69 27 00 00       	call   10e2a0 <ntohs>
  10bb37:	b0 00                	mov    $0x0,%al
  10bb39:	83 c8 04             	or     $0x4,%eax
  10bb3c:	0f b7 c0             	movzwl %ax,%eax
  10bb3f:	89 04 24             	mov    %eax,(%esp)
  10bb42:	e8 29 27 00 00       	call   10e270 <htons>
  10bb47:	89 c2                	mov    %eax,%edx
  10bb49:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10bb4c:	66 89 50 12          	mov    %dx,0x12(%eax)

      hdr->ethhdr.type = htons(ETHTYPE_ARP);
  10bb50:	c7 04 24 06 08 00 00 	movl   $0x806,(%esp)
  10bb57:	e8 14 27 00 00       	call   10e270 <htons>
  10bb5c:	89 c2                	mov    %eax,%edx
  10bb5e:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10bb61:	66 89 50 0c          	mov    %dx,0xc(%eax)
      /* return ARP reply */
      netif->linkoutput(netif, p);
  10bb65:	8b 45 08             	mov    0x8(%ebp),%eax
  10bb68:	8b 50 18             	mov    0x18(%eax),%edx
  10bb6b:	8b 45 10             	mov    0x10(%ebp),%eax
  10bb6e:	89 44 24 04          	mov    %eax,0x4(%esp)
  10bb72:	8b 45 08             	mov    0x8(%ebp),%eax
  10bb75:	89 04 24             	mov    %eax,(%esp)
  10bb78:	ff d2                	call   *%edx

    /* request was not directed to us */
    } else {
      LWIP_DEBUGF(ETHARP_DEBUG | DBG_TRACE, ("etharp_arp_input: incoming ARP request was not for us.\n"));
    }
    break;
  case ARP_REPLY:
    /* ARP reply. We insert or update the ARP table later. */
    LWIP_DEBUGF(ETHARP_DEBUG | DBG_TRACE, ("etharp_arp_input: incoming ARP reply\n"));
#if (LWIP_DHCP && DHCP_DOES_ARP_CHECK)
    /* DHCP wants to know about ARP replies to our wanna-have-address */
    if (for_us) dhcp_arp_reply(netif, &hdr->sipaddr);
#endif
    break;
  default:
    LWIP_DEBUGF(ETHARP_DEBUG | DBG_TRACE, ("etharp_arp_input: ARP unknown opcode type %d\n", htons(hdr->opcode)));
    break;
  }
  /* free ARP packet */
  pbuf_free(p);
  10bb7a:	8b 45 10             	mov    0x10(%ebp),%eax
  10bb7d:	89 04 24             	mov    %eax,(%esp)
  10bb80:	e8 2b 39 00 00       	call   10f4b0 <pbuf_free>
  p = NULL;
  10bb85:	c7 45 10 00 00 00 00 	movl   $0x0,0x10(%ebp)
  /* nothing to send, we did it! */
  return NULL;
  10bb8c:	c7 45 e4 00 00 00 00 	movl   $0x0,0xffffffe4(%ebp)
  10bb93:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
}
  10bb96:	c9                   	leave  
  10bb97:	c3                   	ret    
  10bb98:	90                   	nop    
  10bb99:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

0010bba0 <etharp_output>:

/**
 * Resolve and fill-in Ethernet address header for outgoing packet.
 *
 * If ARP has the Ethernet address in cache, the given packet is
 * returned, ready to be sent.
 *
 * If ARP does not have the Ethernet address in cache the packet is
 * queued (if enabled and space available) and a ARP request is sent.
 * This ARP request is returned as a pbuf, which should be sent by
 * the caller.
 *
 * A returned non-NULL packet should be sent by the caller.
 *
 * If ARP failed to allocate resources, NULL is returned.
 *
 * @param netif The lwIP network interface which the IP packet will be sent on.
 * @param ipaddr The IP address of the packet destination.
 * @param pbuf The pbuf(s) containing the IP packet to be sent.
 *
 * @return If non-NULL, a packet ready to be sent by caller.
 *
 */
struct pbuf *
etharp_output(struct netif *netif, struct ip_addr *ipaddr, struct pbuf *q)
{
  10bba0:	55                   	push   %ebp
  10bba1:	89 e5                	mov    %esp,%ebp
  10bba3:	53                   	push   %ebx
  10bba4:	83 ec 34             	sub    $0x34,%esp
  struct eth_addr *dest, *srcaddr, mcastaddr;
  struct eth_hdr *ethhdr;
  s8_t i;

  /* make room for Ethernet header */
  if (pbuf_header(q, sizeof(struct eth_hdr)) != 0) {
  10bba7:	c7 44 24 04 0e 00 00 	movl   $0xe,0x4(%esp)
  10bbae:	00 
  10bbaf:	8b 45 10             	mov    0x10(%ebp),%eax
  10bbb2:	89 04 24             	mov    %eax,(%esp)
  10bbb5:	e8 f6 37 00 00       	call   10f3b0 <pbuf_header>
  10bbba:	84 c0                	test   %al,%al
  10bbbc:	74 1c                	je     10bbda <etharp_output+0x3a>
    /* The pbuf_header() call shouldn't fail, and we'll just bail
    out if it does.. */
    LWIP_DEBUGF(ETHARP_DEBUG | DBG_TRACE | 2, ("etharp_output: could not allocate room for header.\n"));
    LINK_STATS_INC(link.lenerr);
  10bbbe:	0f b7 05 ec 14 14 00 	movzwl 0x1414ec,%eax
  10bbc5:	83 c0 01             	add    $0x1,%eax
  10bbc8:	66 a3 ec 14 14 00    	mov    %ax,0x1414ec
    return NULL;
  10bbce:	c7 45 d8 00 00 00 00 	movl   $0x0,0xffffffd8(%ebp)
  10bbd5:	e9 11 02 00 00       	jmp    10bdeb <etharp_output+0x24b>
  }

  /* assume unresolved Ethernet address */
  dest = NULL;
  10bbda:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  /* Construct Ethernet header. Start with looking up deciding which
     MAC address to use as a destination address. Broadcasts and
     multicasts are special, all other addresses are looked up in the
     ARP table. */

  /* destination IP address is an IP broadcast address? */
  if (ip_addr_isany(ipaddr) ||
  10bbe1:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  10bbe5:	74 37                	je     10bc1e <etharp_output+0x7e>
  10bbe7:	8b 45 0c             	mov    0xc(%ebp),%eax
  10bbea:	8b 00                	mov    (%eax),%eax
  10bbec:	85 c0                	test   %eax,%eax
  10bbee:	74 2e                	je     10bc1e <etharp_output+0x7e>
  10bbf0:	8b 45 0c             	mov    0xc(%ebp),%eax
  10bbf3:	8b 10                	mov    (%eax),%edx
  10bbf5:	8b 45 08             	mov    0x8(%ebp),%eax
  10bbf8:	8b 40 08             	mov    0x8(%eax),%eax
  10bbfb:	f7 d0                	not    %eax
  10bbfd:	21 c2                	and    %eax,%edx
  10bbff:	8b 45 08             	mov    0x8(%ebp),%eax
  10bc02:	8b 40 08             	mov    0x8(%eax),%eax
  10bc05:	f7 d0                	not    %eax
  10bc07:	39 c2                	cmp    %eax,%edx
  10bc09:	74 13                	je     10bc1e <etharp_output+0x7e>
  10bc0b:	8b 45 0c             	mov    0xc(%ebp),%eax
  10bc0e:	8b 00                	mov    (%eax),%eax
  10bc10:	83 f8 ff             	cmp    $0xffffffff,%eax
  10bc13:	74 09                	je     10bc1e <etharp_output+0x7e>
  10bc15:	8b 45 0c             	mov    0xc(%ebp),%eax
  10bc18:	8b 00                	mov    (%eax),%eax
  10bc1a:	85 c0                	test   %eax,%eax
  10bc1c:	75 0c                	jne    10bc2a <etharp_output+0x8a>
    ip_addr_isbroadcast(ipaddr, &(netif->netmask))) {
    /* broadcast on Ethernet also */
    dest = (struct eth_addr *)&ethbroadcast;
  10bc1e:	c7 45 ec 79 ad 11 00 	movl   $0x11ad79,0xffffffec(%ebp)
  10bc25:	e9 3e 01 00 00       	jmp    10bd68 <etharp_output+0x1c8>
  }
  /* destination IP address is an IP multicast address? */
  else if (ip_addr_ismulticast(ipaddr)) {
  10bc2a:	8b 45 0c             	mov    0xc(%ebp),%eax
  10bc2d:	8b 18                	mov    (%eax),%ebx
  10bc2f:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  10bc36:	e8 c5 26 00 00       	call   10e300 <ntohl>
  10bc3b:	21 c3                	and    %eax,%ebx
  10bc3d:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  10bc44:	e8 b7 26 00 00       	call   10e300 <ntohl>
  10bc49:	39 c3                	cmp    %eax,%ebx
  10bc4b:	75 50                	jne    10bc9d <etharp_output+0xfd>
    /* Hash IP multicast address to MAC address. */
    mcastaddr.addr[0] = 0x01;
  10bc4d:	c6 45 e6 01          	movb   $0x1,0xffffffe6(%ebp)
    mcastaddr.addr[1] = 0x00;
  10bc51:	c6 45 e7 00          	movb   $0x0,0xffffffe7(%ebp)
    mcastaddr.addr[2] = 0x5e;
  10bc55:	c6 45 e8 5e          	movb   $0x5e,0xffffffe8(%ebp)
    mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
  10bc59:	8b 45 0c             	mov    0xc(%ebp),%eax
  10bc5c:	8b 00                	mov    (%eax),%eax
  10bc5e:	89 04 24             	mov    %eax,(%esp)
  10bc61:	e8 9a 26 00 00       	call   10e300 <ntohl>
  10bc66:	c1 e8 10             	shr    $0x10,%eax
  10bc69:	83 e0 7f             	and    $0x7f,%eax
  10bc6c:	88 45 e9             	mov    %al,0xffffffe9(%ebp)
    mcastaddr.addr[4] = ip4_addr3(ipaddr);
  10bc6f:	8b 45 0c             	mov    0xc(%ebp),%eax
  10bc72:	8b 00                	mov    (%eax),%eax
  10bc74:	89 04 24             	mov    %eax,(%esp)
  10bc77:	e8 84 26 00 00       	call   10e300 <ntohl>
  10bc7c:	c1 e8 08             	shr    $0x8,%eax
  10bc7f:	88 45 ea             	mov    %al,0xffffffea(%ebp)
    mcastaddr.addr[5] = ip4_addr4(ipaddr);
  10bc82:	8b 45 0c             	mov    0xc(%ebp),%eax
  10bc85:	8b 00                	mov    (%eax),%eax
  10bc87:	89 04 24             	mov    %eax,(%esp)
  10bc8a:	e8 71 26 00 00       	call   10e300 <ntohl>
  10bc8f:	88 45 eb             	mov    %al,0xffffffeb(%ebp)
    /* destination Ethernet address is multicast */
    dest = &mcastaddr;
  10bc92:	8d 45 e6             	lea    0xffffffe6(%ebp),%eax
  10bc95:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  10bc98:	e9 cb 00 00 00       	jmp    10bd68 <etharp_output+0x1c8>
  }
  /* destination IP address is an IP unicast address */
  else {
    /* destination IP network address not on local network?
     * IP layer wants us to forward to the default gateway */
    if (!ip_addr_maskcmp(ipaddr, &(netif->ip_addr), &(netif->netmask))) {
  10bc9d:	8b 45 0c             	mov    0xc(%ebp),%eax
  10bca0:	8b 10                	mov    (%eax),%edx
  10bca2:	8b 45 08             	mov    0x8(%ebp),%eax
  10bca5:	8b 40 08             	mov    0x8(%eax),%eax
  10bca8:	89 d1                	mov    %edx,%ecx
  10bcaa:	21 c1                	and    %eax,%ecx
  10bcac:	8b 45 08             	mov    0x8(%ebp),%eax
  10bcaf:	8b 50 04             	mov    0x4(%eax),%edx
  10bcb2:	8b 45 08             	mov    0x8(%ebp),%eax
  10bcb5:	8b 40 08             	mov    0x8(%eax),%eax
  10bcb8:	21 d0                	and    %edx,%eax
  10bcba:	39 c1                	cmp    %eax,%ecx
  10bcbc:	74 21                	je     10bcdf <etharp_output+0x13f>
      /* interface has default gateway? */
      if (netif->gw.addr != 0)
  10bcbe:	8b 45 08             	mov    0x8(%ebp),%eax
  10bcc1:	8b 40 0c             	mov    0xc(%eax),%eax
  10bcc4:	85 c0                	test   %eax,%eax
  10bcc6:	74 0b                	je     10bcd3 <etharp_output+0x133>
      {
        /* route to default gateway IP address */
        ipaddr = &(netif->gw);
  10bcc8:	8b 45 08             	mov    0x8(%ebp),%eax
  10bccb:	83 c0 0c             	add    $0xc,%eax
  10bcce:	89 45 0c             	mov    %eax,0xc(%ebp)
  10bcd1:	eb 0c                	jmp    10bcdf <etharp_output+0x13f>
      }
      /* no gateway available? */
      else
      {
        /* IP destination address outside local network, but no gateway available */
        /* { packet is discarded } */
        return NULL;
  10bcd3:	c7 45 d8 00 00 00 00 	movl   $0x0,0xffffffd8(%ebp)
  10bcda:	e9 0c 01 00 00       	jmp    10bdeb <etharp_output+0x24b>
      }
    }

    /* Ethernet address for IP destination address is in ARP cache? */
    for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  10bcdf:	c6 45 fb 00          	movb   $0x0,0xfffffffb(%ebp)
  10bce3:	eb 52                	jmp    10bd37 <etharp_output+0x197>
      /* match found? */
      if (arp_table[i].state == ETHARP_STATE_STABLE &&
  10bce5:	0f be 55 fb          	movsbl 0xfffffffb(%ebp),%edx
  10bce9:	89 d0                	mov    %edx,%eax
  10bceb:	01 c0                	add    %eax,%eax
  10bced:	01 d0                	add    %edx,%eax
  10bcef:	c1 e0 03             	shl    $0x3,%eax
  10bcf2:	8b 80 cc da 11 00    	mov    0x11dacc(%eax),%eax
  10bcf8:	83 f8 02             	cmp    $0x2,%eax
  10bcfb:	75 36                	jne    10bd33 <etharp_output+0x193>
  10bcfd:	8b 45 0c             	mov    0xc(%ebp),%eax
  10bd00:	8b 08                	mov    (%eax),%ecx
  10bd02:	0f be 55 fb          	movsbl 0xfffffffb(%ebp),%edx
  10bd06:	89 d0                	mov    %edx,%eax
  10bd08:	01 c0                	add    %eax,%eax
  10bd0a:	01 d0                	add    %edx,%eax
  10bd0c:	c1 e0 03             	shl    $0x3,%eax
  10bd0f:	8b 80 c0 da 11 00    	mov    0x11dac0(%eax),%eax
  10bd15:	39 c1                	cmp    %eax,%ecx
  10bd17:	75 1a                	jne    10bd33 <etharp_output+0x193>
        ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
        dest = &arp_table[i].ethaddr;
  10bd19:	0f be 55 fb          	movsbl 0xfffffffb(%ebp),%edx
  10bd1d:	89 d0                	mov    %edx,%eax
  10bd1f:	01 c0                	add    %eax,%eax
  10bd21:	01 d0                	add    %edx,%eax
  10bd23:	c1 e0 03             	shl    $0x3,%eax
  10bd26:	05 c0 da 11 00       	add    $0x11dac0,%eax
  10bd2b:	83 c0 04             	add    $0x4,%eax
  10bd2e:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
        break;
  10bd31:	eb 0a                	jmp    10bd3d <etharp_output+0x19d>
  10bd33:	80 45 fb 01          	addb   $0x1,0xfffffffb(%ebp)
  10bd37:	80 7d fb 09          	cmpb   $0x9,0xfffffffb(%ebp)
  10bd3b:	7e a8                	jle    10bce5 <etharp_output+0x145>
      }
    }
    /* could not find the destination Ethernet address in ARP cache? */
    if (dest == NULL) {
  10bd3d:	83 7d ec 00          	cmpl   $0x0,0xffffffec(%ebp)
  10bd41:	75 25                	jne    10bd68 <etharp_output+0x1c8>
      /* ARP query for the IP address, submit this IP packet for queueing */
      /* TODO: How do we handle netif->ipaddr == ipaddr? */
      etharp_query(netif, ipaddr, q);
  10bd43:	8b 45 10             	mov    0x10(%ebp),%eax
  10bd46:	89 44 24 08          	mov    %eax,0x8(%esp)
  10bd4a:	8b 45 0c             	mov    0xc(%ebp),%eax
  10bd4d:	89 44 24 04          	mov    %eax,0x4(%esp)
  10bd51:	8b 45 08             	mov    0x8(%ebp),%eax
  10bd54:	89 04 24             	mov    %eax,(%esp)
  10bd57:	e8 a4 00 00 00       	call   10be00 <etharp_query>
      /* { packet was queued (ERR_OK), or discarded } */
      /* return nothing */
      return NULL;
  10bd5c:	c7 45 d8 00 00 00 00 	movl   $0x0,0xffffffd8(%ebp)
  10bd63:	e9 83 00 00 00       	jmp    10bdeb <etharp_output+0x24b>
    }
    /* destination Ethernet address resolved from ARP cache */
    else
    {
      /* fallthrough */
    }
  }

  /* destination Ethernet address known */
  if (dest != NULL) {
  10bd68:	83 7d ec 00          	cmpl   $0x0,0xffffffec(%ebp)
  10bd6c:	74 76                	je     10bde4 <etharp_output+0x244>
    /* obtain source Ethernet address of the given interface */
    srcaddr = (struct eth_addr *)netif->hwaddr;
  10bd6e:	8b 45 08             	mov    0x8(%ebp),%eax
  10bd71:	83 c0 21             	add    $0x21,%eax
  10bd74:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)

    /* A valid IP->MAC address mapping was found, fill in the
     * Ethernet header for the outgoing packet */
    ethhdr = q->payload;
  10bd77:	8b 45 10             	mov    0x10(%ebp),%eax
  10bd7a:	8b 40 04             	mov    0x4(%eax),%eax
  10bd7d:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)

    for(i = 0; i < netif->hwaddr_len; i++) {
  10bd80:	c6 45 fb 00          	movb   $0x0,0xfffffffb(%ebp)
  10bd84:	eb 2f                	jmp    10bdb5 <etharp_output+0x215>
      ethhdr->dest.addr[i] = dest->addr[i];
  10bd86:	0f be 4d fb          	movsbl 0xfffffffb(%ebp),%ecx
  10bd8a:	0f be 55 fb          	movsbl 0xfffffffb(%ebp),%edx
  10bd8e:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10bd91:	0f b6 14 10          	movzbl (%eax,%edx,1),%edx
  10bd95:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10bd98:	88 14 08             	mov    %dl,(%eax,%ecx,1)
      ethhdr->src.addr[i] = srcaddr->addr[i];
  10bd9b:	0f be 4d fb          	movsbl 0xfffffffb(%ebp),%ecx
  10bd9f:	0f be 55 fb          	movsbl 0xfffffffb(%ebp),%edx
  10bda3:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10bda6:	0f b6 14 10          	movzbl (%eax,%edx,1),%edx
  10bdaa:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10bdad:	88 54 01 06          	mov    %dl,0x6(%ecx,%eax,1)
  10bdb1:	80 45 fb 01          	addb   $0x1,0xfffffffb(%ebp)
  10bdb5:	0f be 55 fb          	movsbl 0xfffffffb(%ebp),%edx
  10bdb9:	8b 45 08             	mov    0x8(%ebp),%eax
  10bdbc:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  10bdc0:	0f b6 c0             	movzbl %al,%eax
  10bdc3:	39 c2                	cmp    %eax,%edx
  10bdc5:	7c bf                	jl     10bd86 <etharp_output+0x1e6>
    }

    ethhdr->type = htons(ETHTYPE_IP);
  10bdc7:	c7 04 24 00 08 00 00 	movl   $0x800,(%esp)
  10bdce:	e8 9d 24 00 00       	call   10e270 <htons>
  10bdd3:	89 c2                	mov    %eax,%edx
  10bdd5:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10bdd8:	66 89 50 0c          	mov    %dx,0xc(%eax)
    /* return the outgoing packet */
    return q;
  10bddc:	8b 45 10             	mov    0x10(%ebp),%eax
  10bddf:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
  10bde2:	eb 07                	jmp    10bdeb <etharp_output+0x24b>
  }
  /* never reached; here for safety */
  return NULL;
  10bde4:	c7 45 d8 00 00 00 00 	movl   $0x0,0xffffffd8(%ebp)
  10bdeb:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
}
  10bdee:	83 c4 34             	add    $0x34,%esp
  10bdf1:	5b                   	pop    %ebx
  10bdf2:	5d                   	pop    %ebp
  10bdf3:	c3                   	ret    
  10bdf4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  10bdfa:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

0010be00 <etharp_query>:

/**
 * Send an ARP request for the given IP address.
 *
 * Sends an ARP request for the given IP address, unless
 * a request for this address is already pending. Optionally
 * queues an outgoing packet on the resulting ARP entry.
 *
 * @param netif The lwIP network interface where ipaddr
 * must be queried for.
 * @param ipaddr The IP address to be resolved.
 * @param q If non-NULL, a pbuf that must be queued on the
 * ARP entry for the ipaddr IP address.
 *
 * @return NULL.
 *
 * @note Might be used in the future by manual IP configuration
 * as well.
 *
 * TODO: use the ctime field to see how long ago an ARP request was sent,
 * possibly retry.
 */
err_t etharp_query(struct netif *netif, struct ip_addr *ipaddr, struct pbuf *q)
{
  10be00:	55                   	push   %ebp
  10be01:	89 e5                	mov    %esp,%ebp
  10be03:	83 ec 48             	sub    $0x48,%esp
  struct eth_addr *srcaddr;
  struct etharp_hdr *hdr;
  err_t result = ERR_OK;
  10be06:	c6 45 f5 00          	movb   $0x0,0xfffffff5(%ebp)
  s8_t i;
  u8_t perform_arp_request = 1;
  10be0a:	c6 45 f7 01          	movb   $0x1,0xfffffff7(%ebp)
  /* prevent 'unused argument' warning if ARP_QUEUEING == 0 */
  (void)q;
  srcaddr = (struct eth_addr *)netif->hwaddr;
  10be0e:	8b 45 08             	mov    0x8(%ebp),%eax
  10be11:	83 c0 21             	add    $0x21,%eax
  10be14:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  /* bail out if this IP address is pending */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  10be17:	c6 45 f6 00          	movb   $0x0,0xfffffff6(%ebp)
  10be1b:	eb 5e                	jmp    10be7b <etharp_query+0x7b>
    if (ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
  10be1d:	8b 45 0c             	mov    0xc(%ebp),%eax
  10be20:	8b 08                	mov    (%eax),%ecx
  10be22:	0f be 55 f6          	movsbl 0xfffffff6(%ebp),%edx
  10be26:	89 d0                	mov    %edx,%eax
  10be28:	01 c0                	add    %eax,%eax
  10be2a:	01 d0                	add    %edx,%eax
  10be2c:	c1 e0 03             	shl    $0x3,%eax
  10be2f:	8b 80 c0 da 11 00    	mov    0x11dac0(%eax),%eax
  10be35:	39 c1                	cmp    %eax,%ecx
  10be37:	75 3e                	jne    10be77 <etharp_query+0x77>
      if (arp_table[i].state == ETHARP_STATE_PENDING) {
  10be39:	0f be 55 f6          	movsbl 0xfffffff6(%ebp),%edx
  10be3d:	89 d0                	mov    %edx,%eax
  10be3f:	01 c0                	add    %eax,%eax
  10be41:	01 d0                	add    %edx,%eax
  10be43:	c1 e0 03             	shl    $0x3,%eax
  10be46:	8b 80 cc da 11 00    	mov    0x11dacc(%eax),%eax
  10be4c:	83 f8 01             	cmp    $0x1,%eax
  10be4f:	75 02                	jne    10be53 <etharp_query+0x53>
        LWIP_DEBUGF(ETHARP_DEBUG | DBG_TRACE | DBG_STATE, ("etharp_query: requested IP already pending as entry %u\n", i));
        /* break out of for-loop, user may wish to queue a packet on a pending entry */
        /* TODO: we will issue a new ARP request, which should not occur too often */
        /* we might want to run a faster timer on ARP to limit this */
        break;
  10be51:	eb 2e                	jmp    10be81 <etharp_query+0x81>
      }
      else if (arp_table[i].state == ETHARP_STATE_STABLE) {
  10be53:	0f be 55 f6          	movsbl 0xfffffff6(%ebp),%edx
  10be57:	89 d0                	mov    %edx,%eax
  10be59:	01 c0                	add    %eax,%eax
  10be5b:	01 d0                	add    %edx,%eax
  10be5d:	c1 e0 03             	shl    $0x3,%eax
  10be60:	8b 80 cc da 11 00    	mov    0x11dacc(%eax),%eax
  10be66:	83 f8 02             	cmp    $0x2,%eax
  10be69:	75 0c                	jne    10be77 <etharp_query+0x77>
        LWIP_DEBUGF(ETHARP_DEBUG | DBG_TRACE | DBG_STATE, ("etharp_query: requested IP already stable as entry %u\n", i));
        /* User wishes to queue a packet on a stable entry (or does she want to send
         * out the packet immediately, we will not know), so we force an ARP request.
         * Upon response we will send out the queued packet in etharp_update().
         * 
         * Alternatively, we could accept the stable entry, and just send out the packet
         * immediately. I chose to implement the former approach.
         */
        perform_arp_request = (q?1:0);
  10be6b:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  10be6f:	0f 95 c0             	setne  %al
  10be72:	88 45 f7             	mov    %al,0xfffffff7(%ebp)
        break;
  10be75:	eb 0a                	jmp    10be81 <etharp_query+0x81>
  10be77:	80 45 f6 01          	addb   $0x1,0xfffffff6(%ebp)
  10be7b:	80 7d f6 09          	cmpb   $0x9,0xfffffff6(%ebp)
  10be7f:	7e 9c                	jle    10be1d <etharp_query+0x1d>
      }
    }
  }
  /* queried address not yet in ARP table? */
  if (i == ARP_TABLE_SIZE) {
  10be81:	80 7d f6 0a          	cmpb   $0xa,0xfffffff6(%ebp)
  10be85:	75 67                	jne    10beee <etharp_query+0xee>
    LWIP_DEBUGF(ETHARP_DEBUG | DBG_TRACE, ("etharp_query: IP address not found in ARP table\n"));
    /* find an available (unused or old) entry */
    i = find_arp_entry();
  10be87:	e8 14 f5 ff ff       	call   10b3a0 <find_arp_entry>
  10be8c:	88 45 f6             	mov    %al,0xfffffff6(%ebp)
    /* bail out if no ARP entries are available */
    if (i == ERR_MEM) {
  10be8f:	80 7d f6 ff          	cmpb   $0xff,0xfffffff6(%ebp)
  10be93:	75 0c                	jne    10bea1 <etharp_query+0xa1>
      LWIP_DEBUGF(ETHARP_DEBUG | 2, ("etharp_query: no more ARP entries available. Should seldom occur.\n"));
      return ERR_MEM;
  10be95:	c7 45 cc ff ff ff ff 	movl   $0xffffffff,0xffffffcc(%ebp)
  10be9c:	e9 3e 02 00 00       	jmp    10c0df <etharp_query+0x2df>
    }
    /* i is available, create ARP entry */
    arp_table[i].state = ETHARP_STATE_PENDING;
  10bea1:	0f be 45 f6          	movsbl 0xfffffff6(%ebp),%eax
  10bea5:	89 c2                	mov    %eax,%edx
  10bea7:	01 d2                	add    %edx,%edx
  10bea9:	01 c2                	add    %eax,%edx
  10beab:	8d 04 d5 00 00 00 00 	lea    0x0(,%edx,8),%eax
  10beb2:	c7 80 cc da 11 00 01 	movl   $0x1,0x11dacc(%eax)
  10beb9:	00 00 00 
    ip_addr_set(&arp_table[i].ipaddr, ipaddr);
  10bebc:	0f be 45 f6          	movsbl 0xfffffff6(%ebp),%eax
  10bec0:	89 45 d0             	mov    %eax,0xffffffd0(%ebp)
  10bec3:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  10bec7:	74 0a                	je     10bed3 <etharp_query+0xd3>
  10bec9:	8b 45 0c             	mov    0xc(%ebp),%eax
  10becc:	8b 00                	mov    (%eax),%eax
  10bece:	89 45 d4             	mov    %eax,0xffffffd4(%ebp)
  10bed1:	eb 07                	jmp    10beda <etharp_query+0xda>
  10bed3:	c7 45 d4 00 00 00 00 	movl   $0x0,0xffffffd4(%ebp)
  10beda:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
  10bedd:	01 c0                	add    %eax,%eax
  10bedf:	03 45 d0             	add    0xffffffd0(%ebp),%eax
  10bee2:	c1 e0 03             	shl    $0x3,%eax
  10bee5:	8b 55 d4             	mov    0xffffffd4(%ebp),%edx
  10bee8:	89 90 c0 da 11 00    	mov    %edx,0x11dac0(%eax)
  }
  /* { i is now valid } */
#if ARP_QUEUEING /* queue packet (even on a stable entry, see above) */
  etharp_enqueue(i, q);
  10beee:	0f be 55 f6          	movsbl 0xfffffff6(%ebp),%edx
  10bef2:	8b 45 10             	mov    0x10(%ebp),%eax
  10bef5:	89 44 24 04          	mov    %eax,0x4(%esp)
  10bef9:	89 14 24             	mov    %edx,(%esp)
  10befc:	e8 af f5 ff ff       	call   10b4b0 <etharp_enqueue>
#endif
  /* ARP request? */
  if (perform_arp_request)
  10bf01:	80 7d f7 00          	cmpb   $0x0,0xfffffff7(%ebp)
  10bf05:	0f 84 cd 01 00 00    	je     10c0d8 <etharp_query+0x2d8>
  {
    struct pbuf *p;
    /* allocate a pbuf for the outgoing ARP request packet */
    p = pbuf_alloc(PBUF_LINK, sizeof(struct etharp_hdr), PBUF_RAM);
  10bf0b:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  10bf12:	00 
  10bf13:	c7 44 24 04 2a 00 00 	movl   $0x2a,0x4(%esp)
  10bf1a:	00 
  10bf1b:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  10bf22:	e8 a9 30 00 00       	call   10efd0 <pbuf_alloc>
  10bf27:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
    /* could allocate pbuf? */
    if (p != NULL) {
  10bf2a:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  10bf2e:	0f 84 a0 01 00 00    	je     10c0d4 <etharp_query+0x2d4>
      u8_t j;
      LWIP_DEBUGF(ETHARP_DEBUG | DBG_TRACE, ("etharp_query: sending ARP request.\n"));
      hdr = p->payload;
  10bf34:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10bf37:	8b 40 04             	mov    0x4(%eax),%eax
  10bf3a:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
      hdr->opcode = htons(ARP_REQUEST);
  10bf3d:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  10bf44:	e8 27 23 00 00       	call   10e270 <htons>
  10bf49:	89 c2                	mov    %eax,%edx
  10bf4b:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10bf4e:	66 89 50 14          	mov    %dx,0x14(%eax)
      for (j = 0; j < netif->hwaddr_len; ++j)
  10bf52:	c6 45 ff 00          	movb   $0x0,0xffffffff(%ebp)
  10bf56:	eb 26                	jmp    10bf7e <etharp_query+0x17e>
      {
        hdr->shwaddr.addr[j] = srcaddr->addr[j];
  10bf58:	0f b6 4d ff          	movzbl 0xffffffff(%ebp),%ecx
  10bf5c:	0f b6 55 ff          	movzbl 0xffffffff(%ebp),%edx
  10bf60:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10bf63:	0f b6 14 10          	movzbl (%eax,%edx,1),%edx
  10bf67:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10bf6a:	88 54 01 16          	mov    %dl,0x16(%ecx,%eax,1)
        /* the hardware address is what we ask for, in
         * a request it is a don't-care, we use 0's */
        hdr->dhwaddr.addr[j] = 0x00;
  10bf6e:	0f b6 55 ff          	movzbl 0xffffffff(%ebp),%edx
  10bf72:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10bf75:	c6 44 02 20 00       	movb   $0x0,0x20(%edx,%eax,1)
  10bf7a:	80 45 ff 01          	addb   $0x1,0xffffffff(%ebp)
  10bf7e:	8b 45 08             	mov    0x8(%ebp),%eax
  10bf81:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  10bf85:	3a 45 ff             	cmp    0xffffffff(%ebp),%al
  10bf88:	77 ce                	ja     10bf58 <etharp_query+0x158>
      }
      ip_addr_set(&(hdr->dipaddr), ipaddr);
  10bf8a:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  10bf8e:	74 0a                	je     10bf9a <etharp_query+0x19a>
  10bf90:	8b 45 0c             	mov    0xc(%ebp),%eax
  10bf93:	8b 00                	mov    (%eax),%eax
  10bf95:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
  10bf98:	eb 07                	jmp    10bfa1 <etharp_query+0x1a1>
  10bf9a:	c7 45 d8 00 00 00 00 	movl   $0x0,0xffffffd8(%ebp)
  10bfa1:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10bfa4:	8b 55 d8             	mov    0xffffffd8(%ebp),%edx
  10bfa7:	89 50 26             	mov    %edx,0x26(%eax)
      ip_addr_set(&(hdr->sipaddr), &(netif->ip_addr));
  10bfaa:	8b 45 08             	mov    0x8(%ebp),%eax
  10bfad:	83 c0 04             	add    $0x4,%eax
  10bfb0:	85 c0                	test   %eax,%eax
  10bfb2:	74 0b                	je     10bfbf <etharp_query+0x1bf>
  10bfb4:	8b 45 08             	mov    0x8(%ebp),%eax
  10bfb7:	8b 40 04             	mov    0x4(%eax),%eax
  10bfba:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
  10bfbd:	eb 07                	jmp    10bfc6 <etharp_query+0x1c6>
  10bfbf:	c7 45 dc 00 00 00 00 	movl   $0x0,0xffffffdc(%ebp)
  10bfc6:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10bfc9:	8b 55 dc             	mov    0xffffffdc(%ebp),%edx
  10bfcc:	89 50 1c             	mov    %edx,0x1c(%eax)

      hdr->hwtype = htons(HWTYPE_ETHERNET);
  10bfcf:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  10bfd6:	e8 95 22 00 00       	call   10e270 <htons>
  10bfdb:	89 c2                	mov    %eax,%edx
  10bfdd:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10bfe0:	66 89 50 0e          	mov    %dx,0xe(%eax)
      ARPH_HWLEN_SET(hdr, netif->hwaddr_len);
  10bfe4:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10bfe7:	0f b7 40 12          	movzwl 0x12(%eax),%eax
  10bfeb:	0f b7 c0             	movzwl %ax,%eax
  10bfee:	89 04 24             	mov    %eax,(%esp)
  10bff1:	e8 aa 22 00 00       	call   10e2a0 <ntohs>
  10bff6:	0f b6 d0             	movzbl %al,%edx
  10bff9:	8b 45 08             	mov    0x8(%ebp),%eax
  10bffc:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  10c000:	0f b6 c0             	movzbl %al,%eax
  10c003:	c1 e0 08             	shl    $0x8,%eax
  10c006:	09 d0                	or     %edx,%eax
  10c008:	0f b7 c0             	movzwl %ax,%eax
  10c00b:	89 04 24             	mov    %eax,(%esp)
  10c00e:	e8 5d 22 00 00       	call   10e270 <htons>
  10c013:	89 c2                	mov    %eax,%edx
  10c015:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10c018:	66 89 50 12          	mov    %dx,0x12(%eax)

      hdr->proto = htons(ETHTYPE_IP);
  10c01c:	c7 04 24 00 08 00 00 	movl   $0x800,(%esp)
  10c023:	e8 48 22 00 00       	call   10e270 <htons>
  10c028:	89 c2                	mov    %eax,%edx
  10c02a:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10c02d:	66 89 50 10          	mov    %dx,0x10(%eax)
      ARPH_PROTOLEN_SET(hdr, sizeof(struct ip_addr));
  10c031:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10c034:	0f b7 40 12          	movzwl 0x12(%eax),%eax
  10c038:	0f b7 c0             	movzwl %ax,%eax
  10c03b:	89 04 24             	mov    %eax,(%esp)
  10c03e:	e8 5d 22 00 00       	call   10e2a0 <ntohs>
  10c043:	b0 00                	mov    $0x0,%al
  10c045:	83 c8 04             	or     $0x4,%eax
  10c048:	0f b7 c0             	movzwl %ax,%eax
  10c04b:	89 04 24             	mov    %eax,(%esp)
  10c04e:	e8 1d 22 00 00       	call   10e270 <htons>
  10c053:	89 c2                	mov    %eax,%edx
  10c055:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10c058:	66 89 50 12          	mov    %dx,0x12(%eax)
      for (j = 0; j < netif->hwaddr_len; ++j)
  10c05c:	c6 45 ff 00          	movb   $0x0,0xffffffff(%ebp)
  10c060:	eb 25                	jmp    10c087 <etharp_query+0x287>
      {
        hdr->ethhdr.dest.addr[j] = 0xff;
  10c062:	0f b6 55 ff          	movzbl 0xffffffff(%ebp),%edx
  10c066:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10c069:	c6 04 10 ff          	movb   $0xff,(%eax,%edx,1)
        hdr->ethhdr.src.addr[j] = srcaddr->addr[j];
  10c06d:	0f b6 4d ff          	movzbl 0xffffffff(%ebp),%ecx
  10c071:	0f b6 55 ff          	movzbl 0xffffffff(%ebp),%edx
  10c075:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10c078:	0f b6 14 10          	movzbl (%eax,%edx,1),%edx
  10c07c:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10c07f:	88 54 01 06          	mov    %dl,0x6(%ecx,%eax,1)
  10c083:	80 45 ff 01          	addb   $0x1,0xffffffff(%ebp)
  10c087:	8b 45 08             	mov    0x8(%ebp),%eax
  10c08a:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  10c08e:	3a 45 ff             	cmp    0xffffffff(%ebp),%al
  10c091:	77 cf                	ja     10c062 <etharp_query+0x262>
      }
      hdr->ethhdr.type = htons(ETHTYPE_ARP);
  10c093:	c7 04 24 06 08 00 00 	movl   $0x806,(%esp)
  10c09a:	e8 d1 21 00 00       	call   10e270 <htons>
  10c09f:	89 c2                	mov    %eax,%edx
  10c0a1:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10c0a4:	66 89 50 0c          	mov    %dx,0xc(%eax)
      /* send ARP query */
      result = netif->linkoutput(netif, p);
  10c0a8:	8b 45 08             	mov    0x8(%ebp),%eax
  10c0ab:	8b 50 18             	mov    0x18(%eax),%edx
  10c0ae:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10c0b1:	89 44 24 04          	mov    %eax,0x4(%esp)
  10c0b5:	8b 45 08             	mov    0x8(%ebp),%eax
  10c0b8:	89 04 24             	mov    %eax,(%esp)
  10c0bb:	ff d2                	call   *%edx
  10c0bd:	88 45 f5             	mov    %al,0xfffffff5(%ebp)
      /* free ARP query packet */
      pbuf_free(p);
  10c0c0:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10c0c3:	89 04 24             	mov    %eax,(%esp)
  10c0c6:	e8 e5 33 00 00       	call   10f4b0 <pbuf_free>
      p = NULL;
  10c0cb:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)
  10c0d2:	eb 04                	jmp    10c0d8 <etharp_query+0x2d8>
    } else {
      result = ERR_MEM;
  10c0d4:	c6 45 f5 ff          	movb   $0xff,0xfffffff5(%ebp)
      LWIP_DEBUGF(ETHARP_DEBUG | DBG_TRACE | 2, ("etharp_query: could not allocate pbuf for ARP request.\n"));
    }
  }
  return result;
  10c0d8:	0f be 45 f5          	movsbl 0xfffffff5(%ebp),%eax
  10c0dc:	89 45 cc             	mov    %eax,0xffffffcc(%ebp)
  10c0df:	8b 45 cc             	mov    0xffffffcc(%ebp),%eax
}
  10c0e2:	c9                   	leave  
  10c0e3:	c3                   	ret    
  10c0e4:	90                   	nop    
  10c0e5:	90                   	nop    
  10c0e6:	90                   	nop    
  10c0e7:	90                   	nop    
  10c0e8:	90                   	nop    
  10c0e9:	90                   	nop    
  10c0ea:	90                   	nop    
  10c0eb:	90                   	nop    
  10c0ec:	90                   	nop    
  10c0ed:	90                   	nop    
  10c0ee:	90                   	nop    
  10c0ef:	90                   	nop    

0010c0f0 <low_level_init>:


static void
low_level_init(struct netif *netif)
{
  10c0f0:	55                   	push   %ebp
  10c0f1:	89 e5                	mov    %esp,%ebp
  10c0f3:	83 ec 10             	sub    $0x10,%esp
  struct ethernetif *ethernetif;

  ethernetif = netif->state;
  10c0f6:	8b 45 08             	mov    0x8(%ebp),%eax
  10c0f9:	8b 40 1c             	mov    0x1c(%eax),%eax
  10c0fc:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  
  /* set MAC hardware address length */
//  netif->hwaddr_len = 6;

  /* set MAC hardware address */
//  char ethaddr[6];

/*  netif->hwaddr[0] = 0x52;
  netif->hwaddr[1] = 0x54;
  netif->hwaddr[2] = 0x00;
  netif->hwaddr[3] = 0x12;
  netif->hwaddr[4] = 0x34;
  netif->hwaddr[5] = 0x56;*/

  /* maximum transfer unit */
  netif->mtu = 1500;
  10c0ff:	8b 45 08             	mov    0x8(%ebp),%eax
  10c102:	66 c7 40 28 dc 05    	movw   $0x5dc,0x28(%eax)
  
  /* broadcast capability */
  netif->flags = NETIF_FLAG_BROADCAST;
  10c108:	8b 45 08             	mov    0x8(%ebp),%eax
  10c10b:	c6 40 2d 02          	movb   $0x2,0x2d(%eax)
 
  /* Do whatever else is needed to initialize interface. */  
}
  10c10f:	c9                   	leave  
  10c110:	c3                   	ret    
  10c111:	eb 0d                	jmp    10c120 <low_level_output>
  10c113:	90                   	nop    
  10c114:	90                   	nop    
  10c115:	90                   	nop    
  10c116:	90                   	nop    
  10c117:	90                   	nop    
  10c118:	90                   	nop    
  10c119:	90                   	nop    
  10c11a:	90                   	nop    
  10c11b:	90                   	nop    
  10c11c:	90                   	nop    
  10c11d:	90                   	nop    
  10c11e:	90                   	nop    
  10c11f:	90                   	nop    

0010c120 <low_level_output>:

/*
 * low_level_output():
 *
 * Should do the actual transmission of the packet. The packet is
 * contained in the pbuf that is passed to the function. This pbuf
 * might be chained.
 *
 */

static err_t
low_level_output(struct ethernetif *ethernetif, struct pbuf *p)
{
  10c120:	55                   	push   %ebp
  10c121:	89 e5                	mov    %esp,%ebp
  10c123:	53                   	push   %ebx
  10c124:	81 ec 64 06 00 00    	sub    $0x664,%esp
  struct pbuf *q;
  int totlen = 0;
  10c12a:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)
  unsigned char data[1600];
//  initiate transfer();
  
  if (!ethernetif->send)
  10c131:	8b 45 08             	mov    0x8(%ebp),%eax
  10c134:	8b 40 04             	mov    0x4(%eax),%eax
  10c137:	85 c0                	test   %eax,%eax
  10c139:	75 0f                	jne    10c14a <low_level_output+0x2a>
      return -2;
  10c13b:	c7 85 a8 f9 ff ff fe 	movl   $0xfffffffe,0xfffff9a8(%ebp)
  10c142:	ff ff ff 
  10c145:	e9 82 00 00 00       	jmp    10c1cc <low_level_output+0xac>
  for(q = p; q != NULL; q = q->next) {
  10c14a:	8b 45 0c             	mov    0xc(%ebp),%eax
  10c14d:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  10c150:	eb 42                	jmp    10c194 <low_level_output+0x74>
    /* Send the data from the pbuf to the interface, one pbuf at a
       time. The size of the data in each pbuf is kept in the ->len
       variable. */
//    send data from(q->payload, q->len);
    memcpy(data + totlen, q->payload, q->len);
  10c152:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10c155:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  10c159:	0f b7 c8             	movzwl %ax,%ecx
  10c15c:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10c15f:	8b 58 04             	mov    0x4(%eax),%ebx
  10c162:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10c165:	89 c2                	mov    %eax,%edx
  10c167:	8d 85 b4 f9 ff ff    	lea    0xfffff9b4(%ebp),%eax
  10c16d:	01 d0                	add    %edx,%eax
  10c16f:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  10c173:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  10c177:	89 04 24             	mov    %eax,(%esp)
  10c17a:	e8 41 9d ff ff       	call   105ec0 <memcpy>
    totlen += q->len;
  10c17f:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10c182:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  10c186:	0f b7 c0             	movzwl %ax,%eax
  10c189:	01 45 f8             	add    %eax,0xfffffff8(%ebp)
  10c18c:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10c18f:	8b 00                	mov    (%eax),%eax
  10c191:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  10c194:	83 7d f4 00          	cmpl   $0x0,0xfffffff4(%ebp)
  10c198:	75 b8                	jne    10c152 <low_level_output+0x32>
  }

  ethernetif->send(data, totlen);
  10c19a:	8b 45 08             	mov    0x8(%ebp),%eax
  10c19d:	8b 50 04             	mov    0x4(%eax),%edx
  10c1a0:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10c1a3:	89 44 24 04          	mov    %eax,0x4(%esp)
  10c1a7:	8d 85 b4 f9 ff ff    	lea    0xfffff9b4(%ebp),%eax
  10c1ad:	89 04 24             	mov    %eax,(%esp)
  10c1b0:	ff d2                	call   *%edx
//  signal that packet should be sent();
  
#ifdef LINK_STATS
  lwip_stats.link.xmit++;
  10c1b2:	0f b7 05 e0 14 14 00 	movzwl 0x1414e0,%eax
  10c1b9:	83 c0 01             	add    $0x1,%eax
  10c1bc:	66 a3 e0 14 14 00    	mov    %ax,0x1414e0
#endif /* LINK_STATS */      

  return ERR_OK;
  10c1c2:	c7 85 a8 f9 ff ff 00 	movl   $0x0,0xfffff9a8(%ebp)
  10c1c9:	00 00 00 
  10c1cc:	8b 85 a8 f9 ff ff    	mov    0xfffff9a8(%ebp),%eax
}
  10c1d2:	81 c4 64 06 00 00    	add    $0x664,%esp
  10c1d8:	5b                   	pop    %ebx
  10c1d9:	5d                   	pop    %ebp
  10c1da:	c3                   	ret    
  10c1db:	90                   	nop    
  10c1dc:	8d 74 26 00          	lea    0x0(%esi),%esi

0010c1e0 <low_level_output_wrap>:

static err_t
low_level_output_wrap(struct netif *netif, struct pbuf *p)
{
  10c1e0:	55                   	push   %ebp
  10c1e1:	89 e5                	mov    %esp,%ebp
  10c1e3:	83 ec 08             	sub    $0x8,%esp
    return low_level_output(netif->state, p);
  10c1e6:	8b 45 08             	mov    0x8(%ebp),%eax
  10c1e9:	8b 40 1c             	mov    0x1c(%eax),%eax
  10c1ec:	89 c2                	mov    %eax,%edx
  10c1ee:	8b 45 0c             	mov    0xc(%ebp),%eax
  10c1f1:	89 44 24 04          	mov    %eax,0x4(%esp)
  10c1f5:	89 14 24             	mov    %edx,(%esp)
  10c1f8:	e8 23 ff ff ff       	call   10c120 <low_level_output>
  10c1fd:	0f be c0             	movsbl %al,%eax
}
  10c200:	c9                   	leave  
  10c201:	c3                   	ret    
  10c202:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi
  10c209:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

0010c210 <low_level_input>:

/*
 * low_level_input():
 *
 * Should allocate a pbuf and transfer the bytes of the incoming
 * packet from the interface into the pbuf.
 *
 */

static struct pbuf *
low_level_input(struct ethernetif *ethernetif)
{
  10c210:	55                   	push   %ebp
  10c211:	89 e5                	mov    %esp,%ebp
  10c213:	53                   	push   %ebx
  10c214:	81 ec 64 06 00 00    	sub    $0x664,%esp
  struct pbuf *p, *q;
  u16_t len;
  unsigned char data[1600];
  u16_t curpos = 0;
  10c21a:	66 c7 45 f8 00 00    	movw   $0x0,0xfffffff8(%ebp)
  u16_t left;
//  int i;

//  cprintf("lwip :: low_level_input\n");
  /* Obtain the size of the packet and put it into the "len"
     variable. */
  len = ethernetif->receive(data, sizeof(data));
  10c220:	8b 45 08             	mov    0x8(%ebp),%eax
  10c223:	8b 50 08             	mov    0x8(%eax),%edx
  10c226:	c7 44 24 04 40 06 00 	movl   $0x640,0x4(%esp)
  10c22d:	00 
  10c22e:	8d 85 ac f9 ff ff    	lea    0xfffff9ac(%ebp),%eax
  10c234:	89 04 24             	mov    %eax,(%esp)
  10c237:	ff d2                	call   *%edx
  10c239:	66 89 45 f6          	mov    %ax,0xfffffff6(%ebp)
/*  cprintf(" read %d bytes\n", len);
  for (left = 0; left < len; left ++)
  {
      cprintf("%02x ", data[left]);
      if ((left + 1) % 16 == 0)
          cprintf("\n");
  }
  cprintf("\n");*/


  /* We allocate a pbuf chain of pbufs from the pool. */
  p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
  10c23d:	0f b7 45 f6          	movzwl 0xfffffff6(%ebp),%eax
  10c241:	c7 44 24 08 03 00 00 	movl   $0x3,0x8(%esp)
  10c248:	00 
  10c249:	89 44 24 04          	mov    %eax,0x4(%esp)
  10c24d:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  10c254:	e8 77 2d 00 00       	call   10efd0 <pbuf_alloc>
  10c259:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  
  if (p != NULL) {
  10c25c:	83 7d ec 00          	cmpl   $0x0,0xffffffec(%ebp)
  10c260:	0f 84 92 00 00 00    	je     10c2f8 <low_level_input+0xe8>
    /* We iterate over the pbuf chain until we have read the entire
       packet into the pbuf. */
    for(q = p; q != NULL; q = q->next) {
  10c266:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10c269:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
  10c26c:	eb 72                	jmp    10c2e0 <low_level_input+0xd0>
      /* Read enough bytes to fill this pbuf in the chain. The
         available data in the pbuf is given by the q->len
         variable. */
//      read data into(q->payload, q->len);
//        len = ether_receive(q->payload, q->len);
        if (q->len > len - curpos)
  10c26e:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10c271:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  10c275:	0f b7 c8             	movzwl %ax,%ecx
  10c278:	0f b7 55 f6          	movzwl 0xfffffff6(%ebp),%edx
  10c27c:	0f b7 45 f8          	movzwl 0xfffffff8(%ebp),%eax
  10c280:	89 d3                	mov    %edx,%ebx
  10c282:	29 c3                	sub    %eax,%ebx
  10c284:	89 d8                	mov    %ebx,%eax
  10c286:	39 c1                	cmp    %eax,%ecx
  10c288:	7e 15                	jle    10c29f <low_level_input+0x8f>
            left = len - curpos;
  10c28a:	0f b7 45 f8          	movzwl 0xfffffff8(%ebp),%eax
  10c28e:	0f b7 55 f6          	movzwl 0xfffffff6(%ebp),%edx
  10c292:	89 d1                	mov    %edx,%ecx
  10c294:	66 29 c1             	sub    %ax,%cx
  10c297:	89 c8                	mov    %ecx,%eax
  10c299:	66 89 45 fa          	mov    %ax,0xfffffffa(%ebp)
  10c29d:	eb 0b                	jmp    10c2aa <low_level_input+0x9a>
        else
            left = q->len;
  10c29f:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10c2a2:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  10c2a6:	66 89 45 fa          	mov    %ax,0xfffffffa(%ebp)
        memcpy(q->payload, data + curpos, left);
  10c2aa:	0f b7 4d fa          	movzwl 0xfffffffa(%ebp),%ecx
  10c2ae:	0f b7 45 f8          	movzwl 0xfffffff8(%ebp),%eax
  10c2b2:	8d 95 ac f9 ff ff    	lea    0xfffff9ac(%ebp),%edx
  10c2b8:	01 c2                	add    %eax,%edx
  10c2ba:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10c2bd:	8b 40 04             	mov    0x4(%eax),%eax
  10c2c0:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  10c2c4:	89 54 24 04          	mov    %edx,0x4(%esp)
  10c2c8:	89 04 24             	mov    %eax,(%esp)
  10c2cb:	e8 f0 9b ff ff       	call   105ec0 <memcpy>
        curpos += left;
  10c2d0:	0f b7 45 fa          	movzwl 0xfffffffa(%ebp),%eax
  10c2d4:	66 01 45 f8          	add    %ax,0xfffffff8(%ebp)
  10c2d8:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10c2db:	8b 00                	mov    (%eax),%eax
  10c2dd:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
  10c2e0:	83 7d f0 00          	cmpl   $0x0,0xfffffff0(%ebp)
  10c2e4:	75 88                	jne    10c26e <low_level_input+0x5e>
    }
//    acknowledge that packet has been read();
#ifdef LINK_STATS
    lwip_stats.link.recv++;
  10c2e6:	0f b7 05 e4 14 14 00 	movzwl 0x1414e4,%eax
  10c2ed:	83 c0 01             	add    $0x1,%eax
  10c2f0:	66 a3 e4 14 14 00    	mov    %ax,0x1414e4
  10c2f6:	eb 2c                	jmp    10c324 <low_level_input+0x114>
#endif /* LINK_STATS */      
  } else {
//    drop packet();
#ifdef LINK_STATS
    lwip_stats.link.memerr++;
  10c2f8:	0f b7 05 ee 14 14 00 	movzwl 0x1414ee,%eax
  10c2ff:	83 c0 01             	add    $0x1,%eax
  10c302:	66 a3 ee 14 14 00    	mov    %ax,0x1414ee
    lwip_stats.link.drop++;
  10c308:	0f b7 05 e8 14 14 00 	movzwl 0x1414e8,%eax
  10c30f:	83 c0 01             	add    $0x1,%eax
  10c312:	66 a3 e8 14 14 00    	mov    %ax,0x1414e8
    cprintf("low_level_input: no mem\n");
  10c318:	c7 04 24 96 ad 11 00 	movl   $0x11ad96,(%esp)
  10c31f:	e8 ec 43 ff ff       	call   100710 <cprintf>
#endif /* LINK_STATS */      
  }

  return p;  
  10c324:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  10c327:	81 c4 64 06 00 00    	add    $0x664,%esp
  10c32d:	5b                   	pop    %ebx
  10c32e:	5d                   	pop    %ebp
  10c32f:	c3                   	ret    

0010c330 <ethernetif_output>:

/*
 * ethernetif_output():
 *
 * This function is called by the TCP/IP stack when an IP packet
 * should be sent. It calls the function called low_level_output() to
 * do the actual transmission of the packet.
 *
 */

static err_t
ethernetif_output(struct netif *netif, struct pbuf *p,
      struct ip_addr *ipaddr)
{
  10c330:	55                   	push   %ebp
  10c331:	89 e5                	mov    %esp,%ebp
  10c333:	83 ec 28             	sub    $0x28,%esp
  struct ethernetif *ethernetif;
//  struct pbuf *q;
//  struct eth_hdr *ethhdr;
//  struct eth_addr *dest, mcastaddr;
//  struct ip_addr *queryaddr;
//  err_t err;
//  u8_t i;
  
  ethernetif = netif->state;
  10c336:	8b 45 08             	mov    0x8(%ebp),%eax
  10c339:	8b 40 1c             	mov    0x1c(%eax),%eax
  10c33c:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)

  /* resolve the link destination hardware address */
  p = etharp_output(netif, ipaddr, p);
  10c33f:	8b 45 0c             	mov    0xc(%ebp),%eax
  10c342:	89 44 24 08          	mov    %eax,0x8(%esp)
  10c346:	8b 45 10             	mov    0x10(%ebp),%eax
  10c349:	89 44 24 04          	mov    %eax,0x4(%esp)
  10c34d:	8b 45 08             	mov    0x8(%ebp),%eax
  10c350:	89 04 24             	mov    %eax,(%esp)
  10c353:	e8 48 f8 ff ff       	call   10bba0 <etharp_output>
  10c358:	89 45 0c             	mov    %eax,0xc(%ebp)
  
  /* network hardware address obtained? */
  if (p == NULL)
  10c35b:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  10c35f:	75 09                	jne    10c36a <ethernetif_output+0x3a>
  {
    /* we cannot tell if the packet was sent: the packet could */
    /* have been queued on an ARP entry that was already pending. */
  	return ERR_OK;
  10c361:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  10c368:	eb 18                	jmp    10c382 <ethernetif_output+0x52>
  }
  	
  /* send out the packet */
  return low_level_output(ethernetif, p);
  10c36a:	8b 45 0c             	mov    0xc(%ebp),%eax
  10c36d:	89 44 24 04          	mov    %eax,0x4(%esp)
  10c371:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10c374:	89 04 24             	mov    %eax,(%esp)
  10c377:	e8 a4 fd ff ff       	call   10c120 <low_level_output>
  10c37c:	0f be c0             	movsbl %al,%eax
  10c37f:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  10c382:	8b 45 ec             	mov    0xffffffec(%ebp),%eax

}
  10c385:	c9                   	leave  
  10c386:	c3                   	ret    
  10c387:	89 f6                	mov    %esi,%esi
  10c389:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

0010c390 <ethernetif_input>:

/*
 * ethernetif_input():
 *
 * This function should be called when a packet is ready to be read
 * from the interface. It uses the function low_level_input() that
 * should handle the actual reception of bytes from the network
 * interface.
 *
 */

void
ethernetif_input(struct netif *netif)
{
  10c390:	55                   	push   %ebp
  10c391:	89 e5                	mov    %esp,%ebp
  10c393:	83 ec 28             	sub    $0x28,%esp
  struct ethernetif *ethernetif;
  struct eth_hdr *ethhdr;
  struct pbuf *p, *q;

  ethernetif = netif->state;
  10c396:	8b 45 08             	mov    0x8(%ebp),%eax
  10c399:	8b 40 1c             	mov    0x1c(%eax),%eax
  10c39c:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
  
  p = low_level_input(ethernetif);
  10c39f:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10c3a2:	89 04 24             	mov    %eax,(%esp)
  10c3a5:	e8 66 fe ff ff       	call   10c210 <low_level_input>
  10c3aa:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)

  if (p == NULL)
  10c3ad:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  10c3b1:	0f 84 e7 00 00 00    	je     10c49e <ethernetif_input+0x10e>
    return;

#ifdef LINK_STATS
  lwip_stats.link.recv++;
  10c3b7:	0f b7 05 e4 14 14 00 	movzwl 0x1414e4,%eax
  10c3be:	83 c0 01             	add    $0x1,%eax
  10c3c1:	66 a3 e4 14 14 00    	mov    %ax,0x1414e4
#endif /* LINK_STATS */

  ethhdr = p->payload;
  10c3c7:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10c3ca:	8b 40 04             	mov    0x4(%eax),%eax
  10c3cd:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  q = NULL;
  10c3d0:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)

  switch (htons(ethhdr->type)) {
  10c3d7:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10c3da:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  10c3de:	0f b7 c0             	movzwl %ax,%eax
  10c3e1:	89 04 24             	mov    %eax,(%esp)
  10c3e4:	e8 87 1e 00 00       	call   10e270 <htons>
  10c3e9:	0f b7 c0             	movzwl %ax,%eax
  10c3ec:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  10c3ef:	81 7d ec 00 08 00 00 	cmpl   $0x800,0xffffffec(%ebp)
  10c3f6:	74 0b                	je     10c403 <ethernetif_input+0x73>
  10c3f8:	81 7d ec 06 08 00 00 	cmpl   $0x806,0xffffffec(%ebp)
  10c3ff:	74 41                	je     10c442 <ethernetif_input+0xb2>
  10c401:	eb 5f                	jmp    10c462 <ethernetif_input+0xd2>
    case ETHTYPE_IP:
      q = etharp_ip_input(netif, p);
  10c403:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10c406:	89 44 24 04          	mov    %eax,0x4(%esp)
  10c40a:	8b 45 08             	mov    0x8(%ebp),%eax
  10c40d:	89 04 24             	mov    %eax,(%esp)
  10c410:	e8 7b f4 ff ff       	call   10b890 <etharp_ip_input>
  10c415:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
      pbuf_header(p, -14);
  10c418:	c7 44 24 04 f2 ff ff 	movl   $0xfffffff2,0x4(%esp)
  10c41f:	ff 
  10c420:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10c423:	89 04 24             	mov    %eax,(%esp)
  10c426:	e8 85 2f 00 00       	call   10f3b0 <pbuf_header>
      netif->input(p, netif);
  10c42b:	8b 45 08             	mov    0x8(%ebp),%eax
  10c42e:	8b 50 10             	mov    0x10(%eax),%edx
  10c431:	8b 45 08             	mov    0x8(%ebp),%eax
  10c434:	89 44 24 04          	mov    %eax,0x4(%esp)
  10c438:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10c43b:	89 04 24             	mov    %eax,(%esp)
  10c43e:	ff d2                	call   *%edx
      break;
  10c440:	eb 32                	jmp    10c474 <ethernetif_input+0xe4>
      
    case ETHTYPE_ARP:
      q = etharp_arp_input(netif, ethernetif->ethaddr, p);
  10c442:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10c445:	8b 10                	mov    (%eax),%edx
  10c447:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10c44a:	89 44 24 08          	mov    %eax,0x8(%esp)
  10c44e:	89 54 24 04          	mov    %edx,0x4(%esp)
  10c452:	8b 45 08             	mov    0x8(%ebp),%eax
  10c455:	89 04 24             	mov    %eax,(%esp)
  10c458:	e8 a3 f4 ff ff       	call   10b900 <etharp_arp_input>
  10c45d:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
      break;
  10c460:	eb 12                	jmp    10c474 <ethernetif_input+0xe4>
    default:
      pbuf_free(p);
  10c462:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10c465:	89 04 24             	mov    %eax,(%esp)
  10c468:	e8 43 30 00 00       	call   10f4b0 <pbuf_free>
      p = NULL;
  10c46d:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)
      break;
  }
  if (q != NULL) {
  10c474:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  10c478:	74 24                	je     10c49e <ethernetif_input+0x10e>
    low_level_output(ethernetif, q);
  10c47a:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10c47d:	89 44 24 04          	mov    %eax,0x4(%esp)
  10c481:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10c484:	89 04 24             	mov    %eax,(%esp)
  10c487:	e8 94 fc ff ff       	call   10c120 <low_level_output>
    pbuf_free(q);
  10c48c:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10c48f:	89 04 24             	mov    %eax,(%esp)
  10c492:	e8 19 30 00 00       	call   10f4b0 <pbuf_free>
    q = NULL;
  10c497:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
  }
}
  10c49e:	c9                   	leave  
  10c49f:	c3                   	ret    

0010c4a0 <arp_timer>:

static void
arp_timer(void *arg)
{
  10c4a0:	55                   	push   %ebp
  10c4a1:	89 e5                	mov    %esp,%ebp
  10c4a3:	83 ec 18             	sub    $0x18,%esp
  etharp_tmr();
  10c4a6:	e8 e5 ed ff ff       	call   10b290 <etharp_tmr>
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
  10c4ab:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  10c4b2:	00 
  10c4b3:	c7 44 24 04 a0 c4 10 	movl   $0x10c4a0,0x4(%esp)
  10c4ba:	00 
  10c4bb:	c7 04 24 10 27 00 00 	movl   $0x2710,(%esp)
  10c4c2:	e8 29 3a 00 00       	call   10fef0 <sys_timeout>
}
  10c4c7:	c9                   	leave  
  10c4c8:	c3                   	ret    
  10c4c9:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

0010c4d0 <ethernetif_init>:

/*
 * ethernetif_init():
 *
 * Should be called at the beginning of the program to set up the
 * network interface. It calls the function low_level_init() to do the
 * actual setup of the hardware.
 *
 */

err_t
ethernetif_init(struct netif *netif)
{
  10c4d0:	55                   	push   %ebp
  10c4d1:	89 e5                	mov    %esp,%ebp
  10c4d3:	83 ec 28             	sub    $0x28,%esp
  struct ethernetif *ethernetif;
    
  ethernetif = mem_malloc(sizeof(struct ethernetif));
  10c4d6:	c7 04 24 0c 00 00 00 	movl   $0xc,(%esp)
  10c4dd:	e8 de 21 00 00       	call   10e6c0 <mem_malloc>
  10c4e2:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  
  if (ethernetif == NULL)
  10c4e5:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  10c4e9:	75 09                	jne    10c4f4 <ethernetif_init+0x24>
  {
  	LWIP_DEBUGF(NETIF_DEBUG, ("ethernetif_init: out of memory\n"));
  	return ERR_MEM;
  10c4eb:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  10c4f2:	eb 6b                	jmp    10c55f <ethernetif_init+0x8f>
  }
  
  netif->state = ethernetif;
  10c4f4:	8b 55 08             	mov    0x8(%ebp),%edx
  10c4f7:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10c4fa:	89 42 1c             	mov    %eax,0x1c(%edx)
  netif->name[0] = IFNAME0;
  10c4fd:	8b 45 08             	mov    0x8(%ebp),%eax
  10c500:	c6 40 2a 65          	movb   $0x65,0x2a(%eax)
  netif->name[1] = IFNAME1;
  10c504:	8b 45 08             	mov    0x8(%ebp),%eax
  10c507:	c6 40 2b 6e          	movb   $0x6e,0x2b(%eax)
  netif->output = ethernetif_output;
  10c50b:	8b 45 08             	mov    0x8(%ebp),%eax
  10c50e:	c7 40 14 30 c3 10 00 	movl   $0x10c330,0x14(%eax)
  netif->linkoutput = low_level_output_wrap;
  10c515:	8b 45 08             	mov    0x8(%ebp),%eax
  10c518:	c7 40 18 e0 c1 10 00 	movl   $0x10c1e0,0x18(%eax)
  
  ethernetif->ethaddr = (struct eth_addr *)&(netif->hwaddr[0]);
  10c51f:	8b 45 08             	mov    0x8(%ebp),%eax
  10c522:	83 c0 21             	add    $0x21,%eax
  10c525:	89 c2                	mov    %eax,%edx
  10c527:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10c52a:	89 10                	mov    %edx,(%eax)
  
  low_level_init(netif);
  10c52c:	8b 45 08             	mov    0x8(%ebp),%eax
  10c52f:	89 04 24             	mov    %eax,(%esp)
  10c532:	e8 b9 fb ff ff       	call   10c0f0 <low_level_init>

  etharp_init();
  10c537:	e8 f4 ec ff ff       	call   10b230 <etharp_init>

  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
  10c53c:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  10c543:	00 
  10c544:	c7 44 24 04 a0 c4 10 	movl   $0x10c4a0,0x4(%esp)
  10c54b:	00 
  10c54c:	c7 04 24 10 27 00 00 	movl   $0x2710,(%esp)
  10c553:	e8 98 39 00 00       	call   10fef0 <sys_timeout>
  return 0;
  10c558:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  10c55f:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  10c562:	c9                   	leave  
  10c563:	c3                   	ret    
  10c564:	90                   	nop    
  10c565:	90                   	nop    
  10c566:	90                   	nop    
  10c567:	90                   	nop    
  10c568:	90                   	nop    
  10c569:	90                   	nop    
  10c56a:	90                   	nop    
  10c56b:	90                   	nop    
  10c56c:	90                   	nop    
  10c56d:	90                   	nop    
  10c56e:	90                   	nop    
  10c56f:	90                   	nop    

0010c570 <loopif_input>:
#include "lwip/ip.h"

static void
loopif_input( void * arg )
{
  10c570:	55                   	push   %ebp
  10c571:	89 e5                	mov    %esp,%ebp
  10c573:	83 ec 18             	sub    $0x18,%esp
	struct netif *netif = (struct netif *)( ((void **)arg)[ 0 ] );
  10c576:	8b 45 08             	mov    0x8(%ebp),%eax
  10c579:	8b 00                	mov    (%eax),%eax
  10c57b:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
	struct pbuf *r = (struct pbuf *)( ((void **)arg)[ 1 ] );
  10c57e:	8b 45 08             	mov    0x8(%ebp),%eax
  10c581:	83 c0 04             	add    $0x4,%eax
  10c584:	8b 00                	mov    (%eax),%eax
  10c586:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)

	mem_free( arg );
  10c589:	8b 45 08             	mov    0x8(%ebp),%eax
  10c58c:	89 04 24             	mov    %eax,(%esp)
  10c58f:	e8 fc 1e 00 00       	call   10e490 <mem_free>
	netif -> input( r, netif );
  10c594:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10c597:	8b 50 10             	mov    0x10(%eax),%edx
  10c59a:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10c59d:	89 44 24 04          	mov    %eax,0x4(%esp)
  10c5a1:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10c5a4:	89 04 24             	mov    %eax,(%esp)
  10c5a7:	ff d2                	call   *%edx
}
  10c5a9:	c9                   	leave  
  10c5aa:	c3                   	ret    
  10c5ab:	90                   	nop    
  10c5ac:	8d 74 26 00          	lea    0x0(%esi),%esi

0010c5b0 <loopif_output>:

static err_t
loopif_output(struct netif *netif, struct pbuf *p,
       struct ip_addr *ipaddr)
{
  10c5b0:	55                   	push   %ebp
  10c5b1:	89 e5                	mov    %esp,%ebp
  10c5b3:	83 ec 28             	sub    $0x28,%esp
  struct pbuf *q, *r;
  char *ptr;
  void **arg;

#if defined(LWIP_DEBUG) && defined(LWIP_TCPDUMP)
  tcpdump(p);
#endif /* LWIP_DEBUG && LWIP_TCPDUMP */
  
  r = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
  10c5b6:	8b 45 0c             	mov    0xc(%ebp),%eax
  10c5b9:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  10c5bd:	0f b7 c0             	movzwl %ax,%eax
  10c5c0:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  10c5c7:	00 
  10c5c8:	89 44 24 04          	mov    %eax,0x4(%esp)
  10c5cc:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  10c5d3:	e8 f8 29 00 00       	call   10efd0 <pbuf_alloc>
  10c5d8:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  if (r != NULL) {
  10c5db:	83 7d f4 00          	cmpl   $0x0,0xfffffff4(%ebp)
  10c5df:	0f 84 a4 00 00 00    	je     10c689 <loopif_output+0xd9>
    ptr = r->payload;
  10c5e5:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10c5e8:	8b 40 04             	mov    0x4(%eax),%eax
  10c5eb:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
    
    for(q = p; q != NULL; q = q->next) {
  10c5ee:	8b 45 0c             	mov    0xc(%ebp),%eax
  10c5f1:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
  10c5f4:	eb 38                	jmp    10c62e <loopif_output+0x7e>
      memcpy(ptr, q->payload, q->len);
  10c5f6:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10c5f9:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  10c5fd:	0f b7 d0             	movzwl %ax,%edx
  10c600:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10c603:	8b 40 04             	mov    0x4(%eax),%eax
  10c606:	89 54 24 08          	mov    %edx,0x8(%esp)
  10c60a:	89 44 24 04          	mov    %eax,0x4(%esp)
  10c60e:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10c611:	89 04 24             	mov    %eax,(%esp)
  10c614:	e8 a7 98 ff ff       	call   105ec0 <memcpy>
      ptr += q->len;
  10c619:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10c61c:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  10c620:	0f b7 c0             	movzwl %ax,%eax
  10c623:	01 45 f8             	add    %eax,0xfffffff8(%ebp)
  10c626:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10c629:	8b 00                	mov    (%eax),%eax
  10c62b:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
  10c62e:	83 7d f0 00          	cmpl   $0x0,0xfffffff0(%ebp)
  10c632:	75 c2                	jne    10c5f6 <loopif_output+0x46>
    }

    arg = mem_malloc( sizeof( void *[2]));
  10c634:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  10c63b:	e8 80 20 00 00       	call   10e6c0 <mem_malloc>
  10c640:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
	if( NULL == arg ) {
  10c643:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  10c647:	75 09                	jne    10c652 <loopif_output+0xa2>
		return ERR_MEM;
  10c649:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  10c650:	eb 3e                	jmp    10c690 <loopif_output+0xe0>
	}
	
	arg[0] = netif;
  10c652:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  10c655:	8b 45 08             	mov    0x8(%ebp),%eax
  10c658:	89 02                	mov    %eax,(%edx)
	arg[1] = r;
  10c65a:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  10c65d:	83 c2 04             	add    $0x4,%edx
  10c660:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10c663:	89 02                	mov    %eax,(%edx)
	/**
	 * workaround (patch #1779) to try to prevent bug #2595:
	 * When connecting to "localhost" with the loopif interface,
	 * tcp_output doesn't get the opportunity to finnish sending the
	 * segment before tcp_process gets it, resulting in tcp_process
	 * referencing pcb->unacked-> which still is NULL.
	 * 
	 * TODO: Is there still a race condition here? Leon
	 */
	sys_timeout( 1, loopif_input, arg );
  10c665:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10c668:	89 44 24 08          	mov    %eax,0x8(%esp)
  10c66c:	c7 44 24 04 70 c5 10 	movl   $0x10c570,0x4(%esp)
  10c673:	00 
  10c674:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  10c67b:	e8 70 38 00 00       	call   10fef0 <sys_timeout>
	
    return ERR_OK;    
  10c680:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  10c687:	eb 07                	jmp    10c690 <loopif_output+0xe0>
  }
  return ERR_MEM;
  10c689:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  10c690:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  10c693:	c9                   	leave  
  10c694:	c3                   	ret    
  10c695:	8d 74 26 00          	lea    0x0(%esi),%esi
  10c699:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

0010c6a0 <loopif_init>:

err_t
loopif_init(struct netif *netif)
{
  10c6a0:	55                   	push   %ebp
  10c6a1:	89 e5                	mov    %esp,%ebp
  netif->name[0] = 'l';
  10c6a3:	8b 45 08             	mov    0x8(%ebp),%eax
  10c6a6:	c6 40 2a 6c          	movb   $0x6c,0x2a(%eax)
  netif->name[1] = 'o';
  10c6aa:	8b 45 08             	mov    0x8(%ebp),%eax
  10c6ad:	c6 40 2b 6f          	movb   $0x6f,0x2b(%eax)
#if 0 /** TODO: I think this should be enabled, or not? Leon */
  netif->input = loopif_input;
#endif
  netif->output = loopif_output;
  10c6b1:	8b 45 08             	mov    0x8(%ebp),%eax
  10c6b4:	c7 40 14 b0 c5 10 00 	movl   $0x10c5b0,0x14(%eax)
  return ERR_OK;
  10c6bb:	b8 00 00 00 00       	mov    $0x0,%eax
}
  10c6c0:	5d                   	pop    %ebp
  10c6c1:	c3                   	ret    
  10c6c2:	90                   	nop    
  10c6c3:	90                   	nop    
  10c6c4:	90                   	nop    
  10c6c5:	90                   	nop    
  10c6c6:	90                   	nop    
  10c6c7:	90                   	nop    
  10c6c8:	90                   	nop    
  10c6c9:	90                   	nop    
  10c6ca:	90                   	nop    
  10c6cb:	90                   	nop    
  10c6cc:	90                   	nop    
  10c6cd:	90                   	nop    
  10c6ce:	90                   	nop    
  10c6cf:	90                   	nop    

0010c6d0 <icmp_input>:
#include "lwip/snmp.h"

void
icmp_input(struct pbuf *p, struct netif *inp)
{
  10c6d0:	55                   	push   %ebp
  10c6d1:	89 e5                	mov    %esp,%ebp
  10c6d3:	53                   	push   %ebx
  10c6d4:	83 ec 44             	sub    $0x44,%esp
  unsigned char type;
  unsigned char code;
  struct icmp_echo_hdr *iecho;
  struct ip_hdr *iphdr;
  struct ip_addr tmpaddr;
  u16_t hlen;

  ICMP_STATS_INC(icmp.recv);
  10c6d7:	0f b7 05 32 15 14 00 	movzwl 0x141532,%eax
  10c6de:	83 c0 01             	add    $0x1,%eax
  10c6e1:	66 a3 32 15 14 00    	mov    %ax,0x141532
  snmp_inc_icmpinmsgs();


  iphdr = p->payload;
  10c6e7:	8b 45 08             	mov    0x8(%ebp),%eax
  10c6ea:	8b 40 04             	mov    0x4(%eax),%eax
  10c6ed:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  hlen = IPH_HL(iphdr) * 4;
  10c6f0:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10c6f3:	0f b7 00             	movzwl (%eax),%eax
  10c6f6:	0f b7 c0             	movzwl %ax,%eax
  10c6f9:	89 04 24             	mov    %eax,(%esp)
  10c6fc:	e8 9f 1b 00 00       	call   10e2a0 <ntohs>
  10c701:	66 c1 e8 08          	shr    $0x8,%ax
  10c705:	0f b7 c0             	movzwl %ax,%eax
  10c708:	83 e0 0f             	and    $0xf,%eax
  10c70b:	c1 e0 02             	shl    $0x2,%eax
  10c70e:	66 89 45 fa          	mov    %ax,0xfffffffa(%ebp)
  if (pbuf_header(p, -((s16_t)hlen)) || (p->tot_len < sizeof(u16_t)*2)) {
  10c712:	0f b7 45 fa          	movzwl 0xfffffffa(%ebp),%eax
  10c716:	f7 d8                	neg    %eax
  10c718:	98                   	cwtl   
  10c719:	89 44 24 04          	mov    %eax,0x4(%esp)
  10c71d:	8b 45 08             	mov    0x8(%ebp),%eax
  10c720:	89 04 24             	mov    %eax,(%esp)
  10c723:	e8 88 2c 00 00       	call   10f3b0 <pbuf_header>
  10c728:	84 c0                	test   %al,%al
  10c72a:	75 0d                	jne    10c739 <icmp_input+0x69>
  10c72c:	8b 45 08             	mov    0x8(%ebp),%eax
  10c72f:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  10c733:	66 83 f8 03          	cmp    $0x3,%ax
  10c737:	77 20                	ja     10c759 <icmp_input+0x89>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: short ICMP (%u bytes) received\n", p->tot_len));
    pbuf_free(p);
  10c739:	8b 45 08             	mov    0x8(%ebp),%eax
  10c73c:	89 04 24             	mov    %eax,(%esp)
  10c73f:	e8 6c 2d 00 00       	call   10f4b0 <pbuf_free>
    ICMP_STATS_INC(icmp.lenerr);
  10c744:	0f b7 05 3a 15 14 00 	movzwl 0x14153a,%eax
  10c74b:	83 c0 01             	add    $0x1,%eax
  10c74e:	66 a3 3a 15 14 00    	mov    %ax,0x14153a
    snmp_inc_icmpinerrors();
    return;
  10c754:	e9 44 02 00 00       	jmp    10c99d <icmp_input+0x2cd>
  }

  type = *((u8_t *)p->payload);
  10c759:	8b 45 08             	mov    0x8(%ebp),%eax
  10c75c:	8b 40 04             	mov    0x4(%eax),%eax
  10c75f:	0f b6 00             	movzbl (%eax),%eax
  10c762:	88 45 ee             	mov    %al,0xffffffee(%ebp)
  code = *(((u8_t *)p->payload)+1);
  10c765:	8b 45 08             	mov    0x8(%ebp),%eax
  10c768:	8b 40 04             	mov    0x4(%eax),%eax
  10c76b:	83 c0 01             	add    $0x1,%eax
  10c76e:	0f b6 00             	movzbl (%eax),%eax
  10c771:	88 45 ef             	mov    %al,0xffffffef(%ebp)
  switch (type) {
  10c774:	0f b6 45 ee          	movzbl 0xffffffee(%ebp),%eax
  10c778:	83 f8 08             	cmp    $0x8,%eax
  10c77b:	74 05                	je     10c782 <icmp_input+0xb2>
  10c77d:	e9 f0 01 00 00       	jmp    10c972 <icmp_input+0x2a2>
  case ICMP_ECHO:
    if (ip_addr_isbroadcast(&iphdr->dest, &inp->netmask) ||
  10c782:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10c785:	8b 50 10             	mov    0x10(%eax),%edx
  10c788:	8b 45 0c             	mov    0xc(%ebp),%eax
  10c78b:	8b 40 08             	mov    0x8(%eax),%eax
  10c78e:	f7 d0                	not    %eax
  10c790:	21 c2                	and    %eax,%edx
  10c792:	8b 45 0c             	mov    0xc(%ebp),%eax
  10c795:	8b 40 08             	mov    0x8(%eax),%eax
  10c798:	f7 d0                	not    %eax
  10c79a:	39 c2                	cmp    %eax,%edx
  10c79c:	74 39                	je     10c7d7 <icmp_input+0x107>
  10c79e:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10c7a1:	8b 40 10             	mov    0x10(%eax),%eax
  10c7a4:	83 f8 ff             	cmp    $0xffffffff,%eax
  10c7a7:	74 2e                	je     10c7d7 <icmp_input+0x107>
  10c7a9:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10c7ac:	8b 40 10             	mov    0x10(%eax),%eax
  10c7af:	85 c0                	test   %eax,%eax
  10c7b1:	74 24                	je     10c7d7 <icmp_input+0x107>
  10c7b3:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10c7b6:	8b 58 10             	mov    0x10(%eax),%ebx
  10c7b9:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  10c7c0:	e8 3b 1b 00 00       	call   10e300 <ntohl>
  10c7c5:	21 c3                	and    %eax,%ebx
  10c7c7:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  10c7ce:	e8 2d 1b 00 00       	call   10e300 <ntohl>
  10c7d3:	39 c3                	cmp    %eax,%ebx
  10c7d5:	75 20                	jne    10c7f7 <icmp_input+0x127>
       ip_addr_ismulticast(&iphdr->dest)) {
      LWIP_DEBUGF(ICMP_DEBUG, ("Smurf.\n"));
      ICMP_STATS_INC(icmp.err);
  10c7d7:	0f b7 05 44 15 14 00 	movzwl 0x141544,%eax
  10c7de:	83 c0 01             	add    $0x1,%eax
  10c7e1:	66 a3 44 15 14 00    	mov    %ax,0x141544
      pbuf_free(p);
  10c7e7:	8b 45 08             	mov    0x8(%ebp),%eax
  10c7ea:	89 04 24             	mov    %eax,(%esp)
  10c7ed:	e8 be 2c 00 00       	call   10f4b0 <pbuf_free>
      return;
  10c7f2:	e9 a6 01 00 00       	jmp    10c99d <icmp_input+0x2cd>
    }
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ping\n"));
    if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
  10c7f7:	8b 45 08             	mov    0x8(%ebp),%eax
  10c7fa:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  10c7fe:	66 83 f8 07          	cmp    $0x7,%ax
  10c802:	77 20                	ja     10c824 <icmp_input+0x154>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: bad ICMP echo received\n"));
      pbuf_free(p);
  10c804:	8b 45 08             	mov    0x8(%ebp),%eax
  10c807:	89 04 24             	mov    %eax,(%esp)
  10c80a:	e8 a1 2c 00 00       	call   10f4b0 <pbuf_free>
      ICMP_STATS_INC(icmp.lenerr);
  10c80f:	0f b7 05 3a 15 14 00 	movzwl 0x14153a,%eax
  10c816:	83 c0 01             	add    $0x1,%eax
  10c819:	66 a3 3a 15 14 00    	mov    %ax,0x14153a
      snmp_inc_icmpinerrors();

      return;
  10c81f:	e9 79 01 00 00       	jmp    10c99d <icmp_input+0x2cd>
    }
    iecho = p->payload;
  10c824:	8b 45 08             	mov    0x8(%ebp),%eax
  10c827:	8b 40 04             	mov    0x4(%eax),%eax
  10c82a:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
    if (inet_chksum_pbuf(p) != 0) {
  10c82d:	8b 45 08             	mov    0x8(%ebp),%eax
  10c830:	89 04 24             	mov    %eax,(%esp)
  10c833:	e8 98 15 00 00       	call   10ddd0 <inet_chksum_pbuf>
  10c838:	66 85 c0             	test   %ax,%ax
  10c83b:	74 20                	je     10c85d <icmp_input+0x18d>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: checksum failed for received ICMP echo\n"));
      pbuf_free(p);
  10c83d:	8b 45 08             	mov    0x8(%ebp),%eax
  10c840:	89 04 24             	mov    %eax,(%esp)
  10c843:	e8 68 2c 00 00       	call   10f4b0 <pbuf_free>
      ICMP_STATS_INC(icmp.chkerr);
  10c848:	0f b7 05 38 15 14 00 	movzwl 0x141538,%eax
  10c84f:	83 c0 01             	add    $0x1,%eax
  10c852:	66 a3 38 15 14 00    	mov    %ax,0x141538
      snmp_inc_icmpinerrors();
      return;
  10c858:	e9 40 01 00 00       	jmp    10c99d <icmp_input+0x2cd>
    }
    tmpaddr.addr = iphdr->src.addr;
  10c85d:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10c860:	8b 40 0c             	mov    0xc(%eax),%eax
  10c863:	89 45 ea             	mov    %eax,0xffffffea(%ebp)
    iphdr->src.addr = iphdr->dest.addr;
  10c866:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10c869:	8b 50 10             	mov    0x10(%eax),%edx
  10c86c:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10c86f:	89 50 0c             	mov    %edx,0xc(%eax)
    iphdr->dest.addr = tmpaddr.addr;
  10c872:	8b 55 ea             	mov    0xffffffea(%ebp),%edx
  10c875:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10c878:	89 50 10             	mov    %edx,0x10(%eax)
    ICMPH_TYPE_SET(iecho, ICMP_ER);
  10c87b:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10c87e:	0f b7 00             	movzwl (%eax),%eax
  10c881:	0f b7 c0             	movzwl %ax,%eax
  10c884:	89 04 24             	mov    %eax,(%esp)
  10c887:	e8 14 1a 00 00       	call   10e2a0 <ntohs>
  10c88c:	0f b7 c0             	movzwl %ax,%eax
  10c88f:	25 ff 00 00 00       	and    $0xff,%eax
  10c894:	89 04 24             	mov    %eax,(%esp)
  10c897:	e8 d4 19 00 00       	call   10e270 <htons>
  10c89c:	89 c2                	mov    %eax,%edx
  10c89e:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10c8a1:	66 89 10             	mov    %dx,(%eax)
    /* adjust the checksum */
    if (iecho->chksum >= htons(0xffff - (ICMP_ECHO << 8))) {
  10c8a4:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10c8a7:	0f b7 58 02          	movzwl 0x2(%eax),%ebx
  10c8ab:	c7 04 24 ff f7 00 00 	movl   $0xf7ff,(%esp)
  10c8b2:	e8 b9 19 00 00       	call   10e270 <htons>
  10c8b7:	66 39 c3             	cmp    %ax,%bx
  10c8ba:	72 22                	jb     10c8de <icmp_input+0x20e>
      iecho->chksum += htons(ICMP_ECHO << 8) + 1;
  10c8bc:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10c8bf:	0f b7 58 02          	movzwl 0x2(%eax),%ebx
  10c8c3:	c7 04 24 00 08 00 00 	movl   $0x800,(%esp)
  10c8ca:	e8 a1 19 00 00       	call   10e270 <htons>
  10c8cf:	8d 04 03             	lea    (%ebx,%eax,1),%eax
  10c8d2:	8d 50 01             	lea    0x1(%eax),%edx
  10c8d5:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10c8d8:	66 89 50 02          	mov    %dx,0x2(%eax)
  10c8dc:	eb 1d                	jmp    10c8fb <icmp_input+0x22b>
    } else {
      iecho->chksum += htons(ICMP_ECHO << 8);
  10c8de:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10c8e1:	0f b7 58 02          	movzwl 0x2(%eax),%ebx
  10c8e5:	c7 04 24 00 08 00 00 	movl   $0x800,(%esp)
  10c8ec:	e8 7f 19 00 00       	call   10e270 <htons>
  10c8f1:	8d 14 03             	lea    (%ebx,%eax,1),%edx
  10c8f4:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10c8f7:	66 89 50 02          	mov    %dx,0x2(%eax)
    }
    ICMP_STATS_INC(icmp.xmit);
  10c8fb:	0f b7 05 2e 15 14 00 	movzwl 0x14152e,%eax
  10c902:	83 c0 01             	add    $0x1,%eax
  10c905:	66 a3 2e 15 14 00    	mov    %ax,0x14152e
    /* increase number of messages attempted to send */
    snmp_inc_icmpoutmsgs();
    /* increase number of echo replies attempted to send */
    snmp_inc_icmpoutechoreps();

    pbuf_header(p, hlen);
  10c90b:	0f b7 45 fa          	movzwl 0xfffffffa(%ebp),%eax
  10c90f:	98                   	cwtl   
  10c910:	89 44 24 04          	mov    %eax,0x4(%esp)
  10c914:	8b 45 08             	mov    0x8(%ebp),%eax
  10c917:	89 04 24             	mov    %eax,(%esp)
  10c91a:	e8 91 2a 00 00       	call   10f3b0 <pbuf_header>
    ip_output_if(p, &(iphdr->src), IP_HDRINCL,
  10c91f:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10c922:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  10c926:	0f b7 c0             	movzwl %ax,%eax
  10c929:	89 04 24             	mov    %eax,(%esp)
  10c92c:	e8 6f 19 00 00       	call   10e2a0 <ntohs>
  10c931:	66 c1 e8 08          	shr    $0x8,%ax
  10c935:	0f b6 d0             	movzbl %al,%edx
  10c938:	8b 4d f4             	mov    0xfffffff4(%ebp),%ecx
  10c93b:	83 c1 0c             	add    $0xc,%ecx
  10c93e:	8b 45 0c             	mov    0xc(%ebp),%eax
  10c941:	89 44 24 18          	mov    %eax,0x18(%esp)
  10c945:	c7 44 24 14 01 00 00 	movl   $0x1,0x14(%esp)
  10c94c:	00 
  10c94d:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  10c954:	00 
  10c955:	89 54 24 0c          	mov    %edx,0xc(%esp)
  10c959:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  10c960:	00 
  10c961:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10c965:	8b 45 08             	mov    0x8(%ebp),%eax
  10c968:	89 04 24             	mov    %eax,(%esp)
  10c96b:	e8 f0 05 00 00       	call   10cf60 <ip_output_if>
		 IPH_TTL(iphdr), 0, IP_PROTO_ICMP, inp);
    break;
  10c970:	eb 20                	jmp    10c992 <icmp_input+0x2c2>
  default:
  LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ICMP type %d code %d not supported.\n", (int)type, (int)code));
    ICMP_STATS_INC(icmp.proterr);
  10c972:	0f b7 05 40 15 14 00 	movzwl 0x141540,%eax
  10c979:	83 c0 01             	add    $0x1,%eax
  10c97c:	66 a3 40 15 14 00    	mov    %ax,0x141540
    ICMP_STATS_INC(icmp.drop);
  10c982:	0f b7 05 36 15 14 00 	movzwl 0x141536,%eax
  10c989:	83 c0 01             	add    $0x1,%eax
  10c98c:	66 a3 36 15 14 00    	mov    %ax,0x141536
  }
  pbuf_free(p);
  10c992:	8b 45 08             	mov    0x8(%ebp),%eax
  10c995:	89 04 24             	mov    %eax,(%esp)
  10c998:	e8 13 2b 00 00       	call   10f4b0 <pbuf_free>
}
  10c99d:	83 c4 44             	add    $0x44,%esp
  10c9a0:	5b                   	pop    %ebx
  10c9a1:	5d                   	pop    %ebp
  10c9a2:	c3                   	ret    
  10c9a3:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  10c9a9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

0010c9b0 <icmp_dest_unreach>:

void
icmp_dest_unreach(struct pbuf *p, enum icmp_dur_type t)
{
  10c9b0:	55                   	push   %ebp
  10c9b1:	89 e5                	mov    %esp,%ebp
  10c9b3:	83 ec 28             	sub    $0x28,%esp
  struct pbuf *q;
  struct ip_hdr *iphdr;
  struct icmp_dur_hdr *idur;

  q = pbuf_alloc(PBUF_IP, 8 + IP_HLEN + 8, PBUF_RAM);
  10c9b6:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  10c9bd:	00 
  10c9be:	c7 44 24 04 24 00 00 	movl   $0x24,0x4(%esp)
  10c9c5:	00 
  10c9c6:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  10c9cd:	e8 fe 25 00 00       	call   10efd0 <pbuf_alloc>
  10c9d2:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  /* ICMP header + IP header + 8 bytes of data */

  iphdr = p->payload;
  10c9d5:	8b 45 08             	mov    0x8(%ebp),%eax
  10c9d8:	8b 40 04             	mov    0x4(%eax),%eax
  10c9db:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)

  idur = q->payload;
  10c9de:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10c9e1:	8b 40 04             	mov    0x4(%eax),%eax
  10c9e4:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  ICMPH_TYPE_SET(idur, ICMP_DUR);
  10c9e7:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10c9ea:	0f b7 00             	movzwl (%eax),%eax
  10c9ed:	0f b7 c0             	movzwl %ax,%eax
  10c9f0:	89 04 24             	mov    %eax,(%esp)
  10c9f3:	e8 a8 18 00 00       	call   10e2a0 <ntohs>
  10c9f8:	66 25 ff 00          	and    $0xff,%ax
  10c9fc:	80 cc 03             	or     $0x3,%ah
  10c9ff:	0f b7 c0             	movzwl %ax,%eax
  10ca02:	89 04 24             	mov    %eax,(%esp)
  10ca05:	e8 66 18 00 00       	call   10e270 <htons>
  10ca0a:	89 c2                	mov    %eax,%edx
  10ca0c:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10ca0f:	66 89 10             	mov    %dx,(%eax)
  ICMPH_CODE_SET(idur, t);
  10ca12:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10ca15:	0f b7 00             	movzwl (%eax),%eax
  10ca18:	0f b7 c0             	movzwl %ax,%eax
  10ca1b:	89 04 24             	mov    %eax,(%esp)
  10ca1e:	e8 7d 18 00 00       	call   10e2a0 <ntohs>
  10ca23:	89 c2                	mov    %eax,%edx
  10ca25:	b2 00                	mov    $0x0,%dl
  10ca27:	8b 45 0c             	mov    0xc(%ebp),%eax
  10ca2a:	09 d0                	or     %edx,%eax
  10ca2c:	0f b7 c0             	movzwl %ax,%eax
  10ca2f:	89 04 24             	mov    %eax,(%esp)
  10ca32:	e8 39 18 00 00       	call   10e270 <htons>
  10ca37:	89 c2                	mov    %eax,%edx
  10ca39:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10ca3c:	66 89 10             	mov    %dx,(%eax)

  memcpy((char *)q->payload + 8, p->payload, IP_HLEN + 8);
  10ca3f:	8b 45 08             	mov    0x8(%ebp),%eax
  10ca42:	8b 50 04             	mov    0x4(%eax),%edx
  10ca45:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10ca48:	8b 40 04             	mov    0x4(%eax),%eax
  10ca4b:	83 c0 08             	add    $0x8,%eax
  10ca4e:	c7 44 24 08 1c 00 00 	movl   $0x1c,0x8(%esp)
  10ca55:	00 
  10ca56:	89 54 24 04          	mov    %edx,0x4(%esp)
  10ca5a:	89 04 24             	mov    %eax,(%esp)
  10ca5d:	e8 5e 94 ff ff       	call   105ec0 <memcpy>

  /* calculate checksum */
  idur->chksum = 0;
  10ca62:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10ca65:	66 c7 40 02 00 00    	movw   $0x0,0x2(%eax)
  idur->chksum = inet_chksum(idur, q->len);
  10ca6b:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10ca6e:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  10ca72:	0f b7 c0             	movzwl %ax,%eax
  10ca75:	89 44 24 04          	mov    %eax,0x4(%esp)
  10ca79:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10ca7c:	89 04 24             	mov    %eax,(%esp)
  10ca7f:	e8 fc 12 00 00       	call   10dd80 <inet_chksum>
  10ca84:	89 c2                	mov    %eax,%edx
  10ca86:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10ca89:	66 89 50 02          	mov    %dx,0x2(%eax)
  ICMP_STATS_INC(icmp.xmit);
  10ca8d:	0f b7 05 2e 15 14 00 	movzwl 0x14152e,%eax
  10ca94:	83 c0 01             	add    $0x1,%eax
  10ca97:	66 a3 2e 15 14 00    	mov    %ax,0x14152e
  /* increase number of messages attempted to send */
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpoutdestunreachs();

  ip_output(q, NULL, &(iphdr->src),
  10ca9d:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10caa0:	83 c0 0c             	add    $0xc,%eax
  10caa3:	c7 44 24 14 01 00 00 	movl   $0x1,0x14(%esp)
  10caaa:	00 
  10caab:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  10cab2:	00 
  10cab3:	c7 44 24 0c ff 00 00 	movl   $0xff,0xc(%esp)
  10caba:	00 
  10cabb:	89 44 24 08          	mov    %eax,0x8(%esp)
  10cabf:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  10cac6:	00 
  10cac7:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10caca:	89 04 24             	mov    %eax,(%esp)
  10cacd:	e8 2e 07 00 00       	call   10d200 <ip_output>
	    ICMP_TTL, 0, IP_PROTO_ICMP);
  pbuf_free(q);
  10cad2:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10cad5:	89 04 24             	mov    %eax,(%esp)
  10cad8:	e8 d3 29 00 00       	call   10f4b0 <pbuf_free>
}
  10cadd:	c9                   	leave  
  10cade:	c3                   	ret    
  10cadf:	90                   	nop    

0010cae0 <ip_init>:
 */

void
ip_init(void)
{
  10cae0:	55                   	push   %ebp
  10cae1:	89 e5                	mov    %esp,%ebp
}
  10cae3:	5d                   	pop    %ebp
  10cae4:	c3                   	ret    
  10cae5:	8d 74 26 00          	lea    0x0(%esi),%esi
  10cae9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

0010caf0 <ip_route>:

/* ip_route:
 *
 * Finds the appropriate network interface for a given IP address. It
 * searches the list of network interfaces linearly. A match is found
 * if the masked IP address of the network interface equals the masked
 * IP address given to the function.
 */

struct netif *
ip_route(struct ip_addr *dest)
{
  10caf0:	55                   	push   %ebp
  10caf1:	89 e5                	mov    %esp,%ebp
  10caf3:	83 ec 14             	sub    $0x14,%esp
  struct netif *netif;

  /* iterate through netifs */
  for(netif = netif_list; netif != NULL; netif = netif->next) {
  10caf6:	a1 98 08 13 00       	mov    0x130898,%eax
  10cafb:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  10cafe:	eb 31                	jmp    10cb31 <ip_route+0x41>
    /* network mask matches? */
    if (ip_addr_maskcmp(dest, &(netif->ip_addr), &(netif->netmask))) {
  10cb00:	8b 45 08             	mov    0x8(%ebp),%eax
  10cb03:	8b 10                	mov    (%eax),%edx
  10cb05:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10cb08:	8b 40 08             	mov    0x8(%eax),%eax
  10cb0b:	89 d1                	mov    %edx,%ecx
  10cb0d:	21 c1                	and    %eax,%ecx
  10cb0f:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10cb12:	8b 50 04             	mov    0x4(%eax),%edx
  10cb15:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10cb18:	8b 40 08             	mov    0x8(%eax),%eax
  10cb1b:	21 d0                	and    %edx,%eax
  10cb1d:	39 c1                	cmp    %eax,%ecx
  10cb1f:	75 08                	jne    10cb29 <ip_route+0x39>
      /* return netif on which to forward IP packet */
      return netif;
  10cb21:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10cb24:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  10cb27:	eb 16                	jmp    10cb3f <ip_route+0x4f>
  10cb29:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10cb2c:	8b 00                	mov    (%eax),%eax
  10cb2e:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  10cb31:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  10cb35:	75 c9                	jne    10cb00 <ip_route+0x10>
    }
  }
  /* no matching netif found, use default netif */
  return netif_default;
  10cb37:	a1 9c 08 13 00       	mov    0x13089c,%eax
  10cb3c:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  10cb3f:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  10cb42:	c9                   	leave  
  10cb43:	c3                   	ret    
  10cb44:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  10cb4a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

0010cb50 <ip_input>:
#if IP_FORWARD

/* ip_forward:
 *
 * Forwards an IP packet. It finds an appropriate route for the
 * packet, decrements the TTL value of the packet, adjusts the
 * checksum and outputs the packet on the appropriate interface.
 */

static void
ip_forward(struct pbuf *p, struct ip_hdr *iphdr, struct netif *inp)
{
  struct netif *netif;

  PERF_START;
  /* Find network interface where to forward this IP packet to. */
  netif = ip_route((struct ip_addr *)&(iphdr->dest));
  if (netif == NULL) {
    LWIP_DEBUGF(IP_DEBUG, ("ip_forward: no forwarding route for 0x%lx found\n",
                      iphdr->dest.addr));
    snmp_inc_ipnoroutes();
    return;
  }
  /* Do not forward packets onto the same network interface on which
     they arrived. */
  if (netif == inp) {
    LWIP_DEBUGF(IP_DEBUG, ("ip_forward: not bouncing packets back on incoming interface.\n"));
    snmp_inc_ipnoroutes();
    return;
  }

  /* decrement TTL */
  IPH_TTL_SET(iphdr, IPH_TTL(iphdr) - 1);
  /* send ICMP if TTL == 0 */
  if (IPH_TTL(iphdr) == 0) {
    /* Don't send ICMP messages in response to ICMP messages */
    if (IPH_PROTO(iphdr) != IP_PROTO_ICMP) {
      icmp_time_exceeded(p, ICMP_TE_TTL);
      snmp_inc_icmpouttimeexcds();
    }
    return;
  }

  /* Incrementally update the IP checksum. */
  if (IPH_CHKSUM(iphdr) >= htons(0xffff - 0x100)) {
    IPH_CHKSUM_SET(iphdr, IPH_CHKSUM(iphdr) + htons(0x100) + 1);
  } else {
    IPH_CHKSUM_SET(iphdr, IPH_CHKSUM(iphdr) + htons(0x100));
  }

  LWIP_DEBUGF(IP_DEBUG, ("ip_forward: forwarding packet to 0x%lx\n",
                    iphdr->dest.addr));

  IP_STATS_INC(ip.fw);
  IP_STATS_INC(ip.xmit);
    snmp_inc_ipforwdatagrams();

  PERF_STOP("ip_forward");
  /* transmit pbuf on chosen interface */
  netif->output(netif, p, (struct ip_addr *)&(iphdr->dest));
}
#endif /* IP_FORWARD */

/* ip_input:
 *
 * This function is called by the network interface device driver when
 * an IP packet is received. The function does the basic checks of the
 * IP header such as packet size being at least larger than the header
 * size etc. If the packet was not destined for us, the packet is
 * forwarded (using ip_forward). The IP checksum is always checked.
 *
 * Finally, the packet is sent to the upper layer protocol input function.
 */

err_t
ip_input(struct pbuf *p, struct netif *inp) {
  10cb50:	55                   	push   %ebp
  10cb51:	89 e5                	mov    %esp,%ebp
  10cb53:	53                   	push   %ebx
  10cb54:	83 ec 14             	sub    $0x14,%esp
  static struct ip_hdr *iphdr;
  static struct netif *netif;
  static u16_t iphdrlen;

  IP_STATS_INC(ip.recv);
  10cb57:	0f b7 05 18 15 14 00 	movzwl 0x141518,%eax
  10cb5e:	83 c0 01             	add    $0x1,%eax
  10cb61:	66 a3 18 15 14 00    	mov    %ax,0x141518
  snmp_inc_ipinreceives();

  /* identify the IP header */
  iphdr = p->payload;
  10cb67:	8b 45 08             	mov    0x8(%ebp),%eax
  10cb6a:	8b 40 04             	mov    0x4(%eax),%eax
  10cb6d:	a3 b8 db 11 00       	mov    %eax,0x11dbb8
  if (IPH_V(iphdr) != 4) {
  10cb72:	a1 b8 db 11 00       	mov    0x11dbb8,%eax
  10cb77:	0f b7 00             	movzwl (%eax),%eax
  10cb7a:	0f b7 c0             	movzwl %ax,%eax
  10cb7d:	89 04 24             	mov    %eax,(%esp)
  10cb80:	e8 1b 17 00 00       	call   10e2a0 <ntohs>
  10cb85:	66 c1 e8 0c          	shr    $0xc,%ax
  10cb89:	66 83 f8 04          	cmp    $0x4,%ax
  10cb8d:	74 37                	je     10cbc6 <ip_input+0x76>
    LWIP_DEBUGF(IP_DEBUG | 1, ("IP packet dropped due to bad version number %u\n", IPH_V(iphdr)));
    ip_debug_print(p);
    pbuf_free(p);
  10cb8f:	8b 45 08             	mov    0x8(%ebp),%eax
  10cb92:	89 04 24             	mov    %eax,(%esp)
  10cb95:	e8 16 29 00 00       	call   10f4b0 <pbuf_free>
    IP_STATS_INC(ip.err);
  10cb9a:	0f b7 05 2a 15 14 00 	movzwl 0x14152a,%eax
  10cba1:	83 c0 01             	add    $0x1,%eax
  10cba4:	66 a3 2a 15 14 00    	mov    %ax,0x14152a
    IP_STATS_INC(ip.drop);
  10cbaa:	0f b7 05 1c 15 14 00 	movzwl 0x14151c,%eax
  10cbb1:	83 c0 01             	add    $0x1,%eax
  10cbb4:	66 a3 1c 15 14 00    	mov    %ax,0x14151c
    snmp_inc_ipunknownprotos();
    return ERR_OK;
  10cbba:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
  10cbc1:	e9 8c 03 00 00       	jmp    10cf52 <ip_input+0x402>
  }
  /* obtain IP header length in number of 32-bit words */
  iphdrlen = IPH_HL(iphdr);
  10cbc6:	a1 b8 db 11 00       	mov    0x11dbb8,%eax
  10cbcb:	0f b7 00             	movzwl (%eax),%eax
  10cbce:	0f b7 c0             	movzwl %ax,%eax
  10cbd1:	89 04 24             	mov    %eax,(%esp)
  10cbd4:	e8 c7 16 00 00       	call   10e2a0 <ntohs>
  10cbd9:	66 c1 e8 08          	shr    $0x8,%ax
  10cbdd:	83 e0 0f             	and    $0xf,%eax
  10cbe0:	66 a3 b0 db 11 00    	mov    %ax,0x11dbb0
  /* calculate IP header length in bytes */
  iphdrlen *= 4;
  10cbe6:	0f b7 05 b0 db 11 00 	movzwl 0x11dbb0,%eax
  10cbed:	0f b7 c0             	movzwl %ax,%eax
  10cbf0:	c1 e0 02             	shl    $0x2,%eax
  10cbf3:	66 a3 b0 db 11 00    	mov    %ax,0x11dbb0

  /* header length exceeds first pbuf length? */
  if (iphdrlen > p->len) {
  10cbf9:	8b 45 08             	mov    0x8(%ebp),%eax
  10cbfc:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
  10cc00:	0f b7 05 b0 db 11 00 	movzwl 0x11dbb0,%eax
  10cc07:	66 39 c2             	cmp    %ax,%dx
  10cc0a:	73 37                	jae    10cc43 <ip_input+0xf3>
    LWIP_DEBUGF(IP_DEBUG | 2, ("IP header (len %u) does not fit in first pbuf (len %u), IP packet droppped.\n",
      iphdrlen, p->len));
    /* free (drop) packet pbufs */
    pbuf_free(p);
  10cc0c:	8b 45 08             	mov    0x8(%ebp),%eax
  10cc0f:	89 04 24             	mov    %eax,(%esp)
  10cc12:	e8 99 28 00 00       	call   10f4b0 <pbuf_free>
    IP_STATS_INC(ip.lenerr);
  10cc17:	0f b7 05 20 15 14 00 	movzwl 0x141520,%eax
  10cc1e:	83 c0 01             	add    $0x1,%eax
  10cc21:	66 a3 20 15 14 00    	mov    %ax,0x141520
    IP_STATS_INC(ip.drop);
  10cc27:	0f b7 05 1c 15 14 00 	movzwl 0x14151c,%eax
  10cc2e:	83 c0 01             	add    $0x1,%eax
  10cc31:	66 a3 1c 15 14 00    	mov    %ax,0x14151c
    snmp_inc_ipindiscards();
    return ERR_OK;
  10cc37:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
  10cc3e:	e9 0f 03 00 00       	jmp    10cf52 <ip_input+0x402>
  }

  /* verify checksum */
  if (inet_chksum(iphdr, iphdrlen) != 0) {
  10cc43:	0f b7 05 b0 db 11 00 	movzwl 0x11dbb0,%eax
  10cc4a:	0f b7 c0             	movzwl %ax,%eax
  10cc4d:	8b 15 b8 db 11 00    	mov    0x11dbb8,%edx
  10cc53:	89 44 24 04          	mov    %eax,0x4(%esp)
  10cc57:	89 14 24             	mov    %edx,(%esp)
  10cc5a:	e8 21 11 00 00       	call   10dd80 <inet_chksum>
  10cc5f:	66 85 c0             	test   %ax,%ax
  10cc62:	74 37                	je     10cc9b <ip_input+0x14b>

    LWIP_DEBUGF(IP_DEBUG | 2, ("Checksum (0x%x) failed, IP packet dropped.\n", inet_chksum(iphdr, iphdrlen)));
    ip_debug_print(p);
    pbuf_free(p);
  10cc64:	8b 45 08             	mov    0x8(%ebp),%eax
  10cc67:	89 04 24             	mov    %eax,(%esp)
  10cc6a:	e8 41 28 00 00       	call   10f4b0 <pbuf_free>
    IP_STATS_INC(ip.chkerr);
  10cc6f:	0f b7 05 1e 15 14 00 	movzwl 0x14151e,%eax
  10cc76:	83 c0 01             	add    $0x1,%eax
  10cc79:	66 a3 1e 15 14 00    	mov    %ax,0x14151e
    IP_STATS_INC(ip.drop);
  10cc7f:	0f b7 05 1c 15 14 00 	movzwl 0x14151c,%eax
  10cc86:	83 c0 01             	add    $0x1,%eax
  10cc89:	66 a3 1c 15 14 00    	mov    %ax,0x14151c
    snmp_inc_ipindiscards();
    return ERR_OK;
  10cc8f:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
  10cc96:	e9 b7 02 00 00       	jmp    10cf52 <ip_input+0x402>
  }

  /* Trim pbuf. This should have been done at the netif layer,
     but we'll do it anyway just to be sure that its done. */
  pbuf_realloc(p, ntohs(IPH_LEN(iphdr)));
  10cc9b:	a1 b8 db 11 00       	mov    0x11dbb8,%eax
  10cca0:	0f b7 40 02          	movzwl 0x2(%eax),%eax
  10cca4:	0f b7 c0             	movzwl %ax,%eax
  10cca7:	89 04 24             	mov    %eax,(%esp)
  10ccaa:	e8 f1 15 00 00       	call   10e2a0 <ntohs>
  10ccaf:	0f b7 c0             	movzwl %ax,%eax
  10ccb2:	89 44 24 04          	mov    %eax,0x4(%esp)
  10ccb6:	8b 45 08             	mov    0x8(%ebp),%eax
  10ccb9:	89 04 24             	mov    %eax,(%esp)
  10ccbc:	e8 df 25 00 00       	call   10f2a0 <pbuf_realloc>

  /* is this packet for us? */
  for(netif = netif_list; netif != NULL; netif = netif->next) {
  10ccc1:	a1 98 08 13 00       	mov    0x130898,%eax
  10ccc6:	a3 b4 db 11 00       	mov    %eax,0x11dbb4
  10cccb:	e9 be 00 00 00       	jmp    10cd8e <ip_input+0x23e>

    LWIP_DEBUGF(IP_DEBUG, ("ip_input: iphdr->dest 0x%lx netif->ip_addr 0x%lx (0x%lx, 0x%lx, 0x%lx)\n",
                      iphdr->dest.addr, netif->ip_addr.addr,
                      iphdr->dest.addr & netif->netmask.addr,
                      netif->ip_addr.addr & netif->netmask.addr,
                      iphdr->dest.addr & ~(netif->netmask.addr)));

    /* interface configured? */
    if (!ip_addr_isany(&(netif->ip_addr)))
  10ccd0:	a1 b4 db 11 00       	mov    0x11dbb4,%eax
  10ccd5:	83 c0 04             	add    $0x4,%eax
  10ccd8:	85 c0                	test   %eax,%eax
  10ccda:	0f 84 a2 00 00 00    	je     10cd82 <ip_input+0x232>
  10cce0:	a1 b4 db 11 00       	mov    0x11dbb4,%eax
  10cce5:	8b 40 04             	mov    0x4(%eax),%eax
  10cce8:	85 c0                	test   %eax,%eax
  10ccea:	0f 84 92 00 00 00    	je     10cd82 <ip_input+0x232>
    {
      /* unicast to this interface address? */
      if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
  10ccf0:	a1 b8 db 11 00       	mov    0x11dbb8,%eax
  10ccf5:	8b 50 10             	mov    0x10(%eax),%edx
  10ccf8:	a1 b4 db 11 00       	mov    0x11dbb4,%eax
  10ccfd:	8b 40 04             	mov    0x4(%eax),%eax
  10cd00:	39 c2                	cmp    %eax,%edx
  10cd02:	0f 84 93 00 00 00    	je     10cd9b <ip_input+0x24b>
  10cd08:	a1 b8 db 11 00       	mov    0x11dbb8,%eax
  10cd0d:	8b 50 10             	mov    0x10(%eax),%edx
  10cd10:	a1 b4 db 11 00       	mov    0x11dbb4,%eax
  10cd15:	8b 40 08             	mov    0x8(%eax),%eax
  10cd18:	f7 d0                	not    %eax
  10cd1a:	21 c2                	and    %eax,%edx
  10cd1c:	a1 b4 db 11 00       	mov    0x11dbb4,%eax
  10cd21:	8b 40 08             	mov    0x8(%eax),%eax
  10cd24:	f7 d0                	not    %eax
  10cd26:	39 c2                	cmp    %eax,%edx
  10cd28:	74 19                	je     10cd43 <ip_input+0x1f3>
  10cd2a:	a1 b8 db 11 00       	mov    0x11dbb8,%eax
  10cd2f:	8b 40 10             	mov    0x10(%eax),%eax
  10cd32:	83 f8 ff             	cmp    $0xffffffff,%eax
  10cd35:	74 0c                	je     10cd43 <ip_input+0x1f3>
  10cd37:	a1 b8 db 11 00       	mov    0x11dbb8,%eax
  10cd3c:	8b 40 10             	mov    0x10(%eax),%eax
  10cd3f:	85 c0                	test   %eax,%eax
  10cd41:	75 2a                	jne    10cd6d <ip_input+0x21d>
  10cd43:	a1 b8 db 11 00       	mov    0x11dbb8,%eax
  10cd48:	8b 50 10             	mov    0x10(%eax),%edx
  10cd4b:	a1 b4 db 11 00       	mov    0x11dbb4,%eax
  10cd50:	8b 40 08             	mov    0x8(%eax),%eax
  10cd53:	89 d1                	mov    %edx,%ecx
  10cd55:	21 c1                	and    %eax,%ecx
  10cd57:	a1 b4 db 11 00       	mov    0x11dbb4,%eax
  10cd5c:	8b 50 04             	mov    0x4(%eax),%edx
  10cd5f:	a1 b4 db 11 00       	mov    0x11dbb4,%eax
  10cd64:	8b 40 08             	mov    0x8(%eax),%eax
  10cd67:	21 d0                	and    %edx,%eax
  10cd69:	39 c1                	cmp    %eax,%ecx
  10cd6b:	74 2e                	je     10cd9b <ip_input+0x24b>
  10cd6d:	a1 b8 db 11 00       	mov    0x11dbb8,%eax
  10cd72:	8b 50 10             	mov    0x10(%eax),%edx
  10cd75:	b8 b3 ad 11 00       	mov    $0x11adb3,%eax
  10cd7a:	8b 00                	mov    (%eax),%eax
  10cd7c:	39 c2                	cmp    %eax,%edx
  10cd7e:	75 02                	jne    10cd82 <ip_input+0x232>
        /* or broadcast matching this interface network address? */
        (ip_addr_isbroadcast(&(iphdr->dest), &(netif->netmask)) &&
         ip_addr_maskcmp(&(iphdr->dest), &(netif->ip_addr), &(netif->netmask))) ||
         /* or restricted broadcast? */
         ip_addr_cmp(&(iphdr->dest), IP_ADDR_BROADCAST)) {
         LWIP_DEBUGF(IP_DEBUG, ("ip_input: packet accepted on interface %c%c\n",
                       netif->name[0], netif->name[1]));
         /* break out of for loop */
         break;
  10cd80:	eb 19                	jmp    10cd9b <ip_input+0x24b>
  10cd82:	a1 b4 db 11 00       	mov    0x11dbb4,%eax
  10cd87:	8b 00                	mov    (%eax),%eax
  10cd89:	a3 b4 db 11 00       	mov    %eax,0x11dbb4
  10cd8e:	a1 b4 db 11 00       	mov    0x11dbb4,%eax
  10cd93:	85 c0                	test   %eax,%eax
  10cd95:	0f 85 35 ff ff ff    	jne    10ccd0 <ip_input+0x180>
      }
    }
  }
#if LWIP_DHCP
  /* Pass DHCP messages regardless of destination address. DHCP traffic is addressed
     using link layer addressing (such as Ethernet MAC) so we must not filter on IP.
     According to RFC 1542 section 3.1.1, referred by RFC 2131). */
  if (netif == NULL) {
    /* remote port is DHCP server? */
    if (IPH_PROTO(iphdr) == IP_PROTO_UDP) {
      LWIP_DEBUGF(IP_DEBUG | DBG_TRACE | 1, ("ip_input: UDP packet to DHCP client port %u\n",
        ntohs(((struct udp_hdr *)((u8_t *)iphdr + iphdrlen))->dest)));
      if (ntohs(((struct udp_hdr *)((u8_t *)iphdr + iphdrlen))->dest) == DHCP_CLIENT_PORT) {
        LWIP_DEBUGF(IP_DEBUG | DBG_TRACE | 1, ("ip_input: DHCP packet accepted.\n"));
        netif = inp;
      }
    }
  }
#endif /* LWIP_DHCP */
        /* packet not for us? */
  if (netif == NULL) {
  10cd9b:	a1 b4 db 11 00       	mov    0x11dbb4,%eax
  10cda0:	85 c0                	test   %eax,%eax
  10cda2:	75 17                	jne    10cdbb <ip_input+0x26b>
    /* packet not for us, route or discard */
    LWIP_DEBUGF(IP_DEBUG | DBG_TRACE | 1, ("ip_input: packet not for us.\n"));
#if IP_FORWARD
    /* non-broadcast packet? */
    if (!ip_addr_isbroadcast(&(iphdr->dest), &(inp->netmask))) {
      /* try to forward IP packet on (other) interfaces */
      ip_forward(p, iphdr, inp);
    }
    else
#endif /* IP_FORWARD */
    {
      snmp_inc_ipindiscards();
    }
    pbuf_free(p);
  10cda4:	8b 45 08             	mov    0x8(%ebp),%eax
  10cda7:	89 04 24             	mov    %eax,(%esp)
  10cdaa:	e8 01 27 00 00       	call   10f4b0 <pbuf_free>
    return ERR_OK;
  10cdaf:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
  10cdb6:	e9 97 01 00 00       	jmp    10cf52 <ip_input+0x402>
  }

#if IP_REASSEMBLY
  if ((IPH_OFFSET(iphdr) & htons(IP_OFFMASK | IP_MF)) != 0) {
  10cdbb:	a1 b8 db 11 00       	mov    0x11dbb8,%eax
  10cdc0:	0f b7 58 06          	movzwl 0x6(%eax),%ebx
  10cdc4:	c7 04 24 ff 3f 00 00 	movl   $0x3fff,(%esp)
  10cdcb:	e8 a0 14 00 00       	call   10e270 <htons>
  10cdd0:	21 d8                	and    %ebx,%eax
  10cdd2:	66 85 c0             	test   %ax,%ax
  10cdd5:	74 2b                	je     10ce02 <ip_input+0x2b2>
    LWIP_DEBUGF(IP_DEBUG, ("IP packet is a fragment (id=0x%04x tot_len=%u len=%u MF=%u offset=%u), calling ip_reass()\n",
      ntohs(IPH_ID(iphdr)), p->tot_len, ntohs(IPH_LEN(iphdr)), !!(IPH_OFFSET(iphdr) & htons(IP_MF)), (ntohs(IPH_OFFSET(iphdr)) & IP_OFFMASK)*8));
    p = ip_reass(p);
  10cdd7:	8b 45 08             	mov    0x8(%ebp),%eax
  10cdda:	89 04 24             	mov    %eax,(%esp)
  10cddd:	e8 ce 05 00 00       	call   10d3b0 <ip_reass>
  10cde2:	89 45 08             	mov    %eax,0x8(%ebp)
    if (p == NULL) {
  10cde5:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  10cde9:	75 0c                	jne    10cdf7 <ip_input+0x2a7>
      return ERR_OK;
  10cdeb:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
  10cdf2:	e9 5b 01 00 00       	jmp    10cf52 <ip_input+0x402>
    }
    iphdr = p->payload;
  10cdf7:	8b 45 08             	mov    0x8(%ebp),%eax
  10cdfa:	8b 40 04             	mov    0x4(%eax),%eax
  10cdfd:	a3 b8 db 11 00       	mov    %eax,0x11dbb8
  }
#else /* IP_REASSEMBLY */
  if ((IPH_OFFSET(iphdr) & htons(IP_OFFMASK | IP_MF)) != 0) {
    pbuf_free(p);
    LWIP_DEBUGF(IP_DEBUG | 2, ("IP packet dropped since it was fragmented (0x%x) (while IP_REASSEMBLY == 0).\n",
                  ntohs(IPH_OFFSET(iphdr))));
    IP_STATS_INC(ip.opterr);
    IP_STATS_INC(ip.drop);
    snmp_inc_ipunknownprotos();
    return ERR_OK;
  }
#endif /* IP_REASSEMBLY */

#if IP_OPTIONS == 0
  if (iphdrlen > IP_HLEN) {
    LWIP_DEBUGF(IP_DEBUG | 2, ("IP packet dropped since there were IP options (while IP_OPTIONS == 0).\n"));
    pbuf_free(p);
    IP_STATS_INC(ip.opterr);
    IP_STATS_INC(ip.drop);
    snmp_inc_ipunknownprotos();
    return ERR_OK;
  }
#endif /* IP_OPTIONS == 0 */

  /* send to upper layers */
  LWIP_DEBUGF(IP_DEBUG, ("ip_input: \n"));
  ip_debug_print(p);
  LWIP_DEBUGF(IP_DEBUG, ("ip_input: p->len %d p->tot_len %d\n", p->len, p->tot_len));

#if LWIP_RAW
  if (!raw_input(p, inp)) {
  10ce02:	8b 45 0c             	mov    0xc(%ebp),%eax
  10ce05:	89 44 24 04          	mov    %eax,0x4(%esp)
  10ce09:	8b 45 08             	mov    0x8(%ebp),%eax
  10ce0c:	89 04 24             	mov    %eax,(%esp)
  10ce0f:	e8 2c 2b 00 00       	call   10f940 <raw_input>
  10ce14:	85 c0                	test   %eax,%eax
  10ce16:	0f 85 2f 01 00 00    	jne    10cf4b <ip_input+0x3fb>
#endif /* LWIP_RAW */

  switch (IPH_PROTO(iphdr)) {
  10ce1c:	a1 b8 db 11 00       	mov    0x11dbb8,%eax
  10ce21:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  10ce25:	0f b7 c0             	movzwl %ax,%eax
  10ce28:	89 04 24             	mov    %eax,(%esp)
  10ce2b:	e8 70 14 00 00       	call   10e2a0 <ntohs>
  10ce30:	0f b7 c0             	movzwl %ax,%eax
  10ce33:	25 ff 00 00 00       	and    $0xff,%eax
  10ce38:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  10ce3b:	83 7d f8 06          	cmpl   $0x6,0xfffffff8(%ebp)
  10ce3f:	74 36                	je     10ce77 <ip_input+0x327>
  10ce41:	83 7d f8 06          	cmpl   $0x6,0xfffffff8(%ebp)
  10ce45:	7f 08                	jg     10ce4f <ip_input+0x2ff>
  10ce47:	83 7d f8 01          	cmpl   $0x1,0xfffffff8(%ebp)
  10ce4b:	74 41                	je     10ce8e <ip_input+0x33e>
  10ce4d:	eb 56                	jmp    10cea5 <ip_input+0x355>
  10ce4f:	83 7d f8 11          	cmpl   $0x11,0xfffffff8(%ebp)
  10ce53:	74 0b                	je     10ce60 <ip_input+0x310>
  10ce55:	81 7d f8 aa 00 00 00 	cmpl   $0xaa,0xfffffff8(%ebp)
  10ce5c:	74 02                	je     10ce60 <ip_input+0x310>
  10ce5e:	eb 45                	jmp    10cea5 <ip_input+0x355>
#if LWIP_UDP
  case IP_PROTO_UDP:
  case IP_PROTO_UDPLITE:
    snmp_inc_ipindelivers();
    udp_input(p, inp);
  10ce60:	8b 45 0c             	mov    0xc(%ebp),%eax
  10ce63:	89 44 24 04          	mov    %eax,0x4(%esp)
  10ce67:	8b 45 08             	mov    0x8(%ebp),%eax
  10ce6a:	89 04 24             	mov    %eax,(%esp)
  10ce6d:	e8 7e 7d 00 00       	call   114bf0 <udp_input>
    break;
  10ce72:	e9 d4 00 00 00       	jmp    10cf4b <ip_input+0x3fb>
#endif /* LWIP_UDP */
#if LWIP_TCP
  case IP_PROTO_TCP:
    snmp_inc_ipindelivers();
    tcp_input(p, inp);
  10ce77:	8b 45 0c             	mov    0xc(%ebp),%eax
  10ce7a:	89 44 24 04          	mov    %eax,0x4(%esp)
  10ce7e:	8b 45 08             	mov    0x8(%ebp),%eax
  10ce81:	89 04 24             	mov    %eax,(%esp)
  10ce84:	e8 f7 59 00 00       	call   112880 <tcp_input>
    break;
  10ce89:	e9 bd 00 00 00       	jmp    10cf4b <ip_input+0x3fb>
#endif /* LWIP_TCP */
  case IP_PROTO_ICMP:
    snmp_inc_ipindelivers();
    icmp_input(p, inp);
  10ce8e:	8b 45 0c             	mov    0xc(%ebp),%eax
  10ce91:	89 44 24 04          	mov    %eax,0x4(%esp)
  10ce95:	8b 45 08             	mov    0x8(%ebp),%eax
  10ce98:	89 04 24             	mov    %eax,(%esp)
  10ce9b:	e8 30 f8 ff ff       	call   10c6d0 <icmp_input>
    break;
  10cea0:	e9 a6 00 00 00       	jmp    10cf4b <ip_input+0x3fb>
  default:
    /* send ICMP destination protocol unreachable unless is was a broadcast */
    if (!ip_addr_isbroadcast(&(iphdr->dest), &(inp->netmask)) &&
  10cea5:	a1 b8 db 11 00       	mov    0x11dbb8,%eax
  10ceaa:	8b 50 10             	mov    0x10(%eax),%edx
  10cead:	8b 45 0c             	mov    0xc(%ebp),%eax
  10ceb0:	8b 40 08             	mov    0x8(%eax),%eax
  10ceb3:	f7 d0                	not    %eax
  10ceb5:	21 c2                	and    %eax,%edx
  10ceb7:	8b 45 0c             	mov    0xc(%ebp),%eax
  10ceba:	8b 40 08             	mov    0x8(%eax),%eax
  10cebd:	f7 d0                	not    %eax
  10cebf:	39 c2                	cmp    %eax,%edx
  10cec1:	74 5d                	je     10cf20 <ip_input+0x3d0>
  10cec3:	a1 b8 db 11 00       	mov    0x11dbb8,%eax
  10cec8:	8b 40 10             	mov    0x10(%eax),%eax
  10cecb:	83 f8 ff             	cmp    $0xffffffff,%eax
  10cece:	74 50                	je     10cf20 <ip_input+0x3d0>
  10ced0:	a1 b8 db 11 00       	mov    0x11dbb8,%eax
  10ced5:	8b 40 10             	mov    0x10(%eax),%eax
  10ced8:	85 c0                	test   %eax,%eax
  10ceda:	74 44                	je     10cf20 <ip_input+0x3d0>
  10cedc:	a1 b8 db 11 00       	mov    0x11dbb8,%eax
  10cee1:	8b 58 10             	mov    0x10(%eax),%ebx
  10cee4:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  10ceeb:	e8 10 14 00 00       	call   10e300 <ntohl>
  10cef0:	21 c3                	and    %eax,%ebx
  10cef2:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  10cef9:	e8 02 14 00 00       	call   10e300 <ntohl>
  10cefe:	39 c3                	cmp    %eax,%ebx
  10cf00:	74 1e                	je     10cf20 <ip_input+0x3d0>
       !ip_addr_ismulticast(&(iphdr->dest))) {
      p->payload = iphdr;
  10cf02:	a1 b8 db 11 00       	mov    0x11dbb8,%eax
  10cf07:	8b 55 08             	mov    0x8(%ebp),%edx
  10cf0a:	89 42 04             	mov    %eax,0x4(%edx)
      icmp_dest_unreach(p, ICMP_DUR_PROTO);
  10cf0d:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
  10cf14:	00 
  10cf15:	8b 45 08             	mov    0x8(%ebp),%eax
  10cf18:	89 04 24             	mov    %eax,(%esp)
  10cf1b:	e8 90 fa ff ff       	call   10c9b0 <icmp_dest_unreach>
    }
    pbuf_free(p);
  10cf20:	8b 45 08             	mov    0x8(%ebp),%eax
  10cf23:	89 04 24             	mov    %eax,(%esp)
  10cf26:	e8 85 25 00 00       	call   10f4b0 <pbuf_free>

    LWIP_DEBUGF(IP_DEBUG | 2, ("Unsupported transport protocol %d\n", IPH_PROTO(iphdr)));

    IP_STATS_INC(ip.proterr);
  10cf2b:	0f b7 05 26 15 14 00 	movzwl 0x141526,%eax
  10cf32:	83 c0 01             	add    $0x1,%eax
  10cf35:	66 a3 26 15 14 00    	mov    %ax,0x141526
    IP_STATS_INC(ip.drop);
  10cf3b:	0f b7 05 1c 15 14 00 	movzwl 0x14151c,%eax
  10cf42:	83 c0 01             	add    $0x1,%eax
  10cf45:	66 a3 1c 15 14 00    	mov    %ax,0x14151c
    snmp_inc_ipunknownprotos();

  }
#if LWIP_RAW
  } /* LWIP_RAW */
#endif
  return ERR_OK;
  10cf4b:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
  10cf52:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
}
  10cf55:	83 c4 14             	add    $0x14,%esp
  10cf58:	5b                   	pop    %ebx
  10cf59:	5d                   	pop    %ebp
  10cf5a:	c3                   	ret    
  10cf5b:	90                   	nop    
  10cf5c:	8d 74 26 00          	lea    0x0(%esi),%esi

0010cf60 <ip_output_if>:


/* ip_output_if:
 *
 * Sends an IP packet on a network interface. This function constructs
 * the IP header and calculates the IP header checksum. If the source
 * IP address is NULL, the IP address of the outgoing network
 * interface is filled in as source address.
 */

err_t
ip_output_if(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,
             u8_t ttl, u8_t tos,
             u8_t proto, struct netif *netif)
{
  10cf60:	55                   	push   %ebp
  10cf61:	89 e5                	mov    %esp,%ebp
  10cf63:	56                   	push   %esi
  10cf64:	53                   	push   %ebx
  10cf65:	83 ec 40             	sub    $0x40,%esp
  10cf68:	8b 45 14             	mov    0x14(%ebp),%eax
  10cf6b:	8b 55 18             	mov    0x18(%ebp),%edx
  10cf6e:	8b 4d 1c             	mov    0x1c(%ebp),%ecx
  10cf71:	88 45 f4             	mov    %al,0xfffffff4(%ebp)
  10cf74:	88 55 f0             	mov    %dl,0xfffffff0(%ebp)
  10cf77:	88 4d ec             	mov    %cl,0xffffffec(%ebp)
  static struct ip_hdr *iphdr;
  static u16_t ip_id = 0;

  snmp_inc_ipoutrequests();

  if (dest != IP_HDRINCL) {
  10cf7a:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  10cf7e:	0f 84 e0 01 00 00    	je     10d164 <ip_output_if+0x204>
    if (pbuf_header(p, IP_HLEN)) {
  10cf84:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  10cf8b:	00 
  10cf8c:	8b 45 08             	mov    0x8(%ebp),%eax
  10cf8f:	89 04 24             	mov    %eax,(%esp)
  10cf92:	e8 19 24 00 00       	call   10f3b0 <pbuf_header>
  10cf97:	84 c0                	test   %al,%al
  10cf99:	74 1c                	je     10cfb7 <ip_output_if+0x57>
      LWIP_DEBUGF(IP_DEBUG | 2, ("ip_output: not enough room for IP header in pbuf\n"));

      IP_STATS_INC(ip.err);
  10cf9b:	0f b7 05 2a 15 14 00 	movzwl 0x14152a,%eax
  10cfa2:	83 c0 01             	add    $0x1,%eax
  10cfa5:	66 a3 2a 15 14 00    	mov    %ax,0x14152a
      snmp_inc_ipoutdiscards();
      return ERR_BUF;
  10cfab:	c7 45 d0 fe ff ff ff 	movl   $0xfffffffe,0xffffffd0(%ebp)
  10cfb2:	e9 35 02 00 00       	jmp    10d1ec <ip_output_if+0x28c>
    }

    iphdr = p->payload;
  10cfb7:	8b 45 08             	mov    0x8(%ebp),%eax
  10cfba:	8b 40 04             	mov    0x4(%eax),%eax
  10cfbd:	a3 c0 db 11 00       	mov    %eax,0x11dbc0

    IPH_TTL_SET(iphdr, ttl);
  10cfc2:	8b 1d c0 db 11 00    	mov    0x11dbc0,%ebx
  10cfc8:	a1 c0 db 11 00       	mov    0x11dbc0,%eax
  10cfcd:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  10cfd1:	0f b7 c0             	movzwl %ax,%eax
  10cfd4:	89 04 24             	mov    %eax,(%esp)
  10cfd7:	e8 c4 12 00 00       	call   10e2a0 <ntohs>
  10cfdc:	0f b6 d0             	movzbl %al,%edx
  10cfdf:	0f b6 45 f4          	movzbl 0xfffffff4(%ebp),%eax
  10cfe3:	c1 e0 08             	shl    $0x8,%eax
  10cfe6:	09 d0                	or     %edx,%eax
  10cfe8:	0f b7 c0             	movzwl %ax,%eax
  10cfeb:	89 04 24             	mov    %eax,(%esp)
  10cfee:	e8 7d 12 00 00       	call   10e270 <htons>
  10cff3:	66 89 43 08          	mov    %ax,0x8(%ebx)
    IPH_PROTO_SET(iphdr, proto);
  10cff7:	8b 1d c0 db 11 00    	mov    0x11dbc0,%ebx
  10cffd:	0f b6 75 ec          	movzbl 0xffffffec(%ebp),%esi
  10d001:	a1 c0 db 11 00       	mov    0x11dbc0,%eax
  10d006:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  10d00a:	0f b7 c0             	movzwl %ax,%eax
  10d00d:	89 04 24             	mov    %eax,(%esp)
  10d010:	e8 8b 12 00 00       	call   10e2a0 <ntohs>
  10d015:	66 c1 e8 08          	shr    $0x8,%ax
  10d019:	0f b7 c0             	movzwl %ax,%eax
  10d01c:	c1 e0 08             	shl    $0x8,%eax
  10d01f:	09 f0                	or     %esi,%eax
  10d021:	0f b7 c0             	movzwl %ax,%eax
  10d024:	89 04 24             	mov    %eax,(%esp)
  10d027:	e8 44 12 00 00       	call   10e270 <htons>
  10d02c:	66 89 43 08          	mov    %ax,0x8(%ebx)

    ip_addr_set(&(iphdr->dest), dest);
  10d030:	a1 c0 db 11 00       	mov    0x11dbc0,%eax
  10d035:	89 45 d4             	mov    %eax,0xffffffd4(%ebp)
  10d038:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  10d03c:	74 0a                	je     10d048 <ip_output_if+0xe8>
  10d03e:	8b 45 10             	mov    0x10(%ebp),%eax
  10d041:	8b 00                	mov    (%eax),%eax
  10d043:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
  10d046:	eb 07                	jmp    10d04f <ip_output_if+0xef>
  10d048:	c7 45 d8 00 00 00 00 	movl   $0x0,0xffffffd8(%ebp)
  10d04f:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  10d052:	8b 55 d4             	mov    0xffffffd4(%ebp),%edx
  10d055:	89 42 10             	mov    %eax,0x10(%edx)

    IPH_VHLTOS_SET(iphdr, 4, IP_HLEN / 4, tos);
  10d058:	8b 1d c0 db 11 00    	mov    0x11dbc0,%ebx
  10d05e:	0f b6 45 f0          	movzbl 0xfffffff0(%ebp),%eax
  10d062:	80 cc 45             	or     $0x45,%ah
  10d065:	0f b7 c0             	movzwl %ax,%eax
  10d068:	89 04 24             	mov    %eax,(%esp)
  10d06b:	e8 00 12 00 00       	call   10e270 <htons>
  10d070:	66 89 03             	mov    %ax,(%ebx)
    IPH_LEN_SET(iphdr, htons(p->tot_len));
  10d073:	8b 1d c0 db 11 00    	mov    0x11dbc0,%ebx
  10d079:	8b 45 08             	mov    0x8(%ebp),%eax
  10d07c:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  10d080:	0f b7 c0             	movzwl %ax,%eax
  10d083:	89 04 24             	mov    %eax,(%esp)
  10d086:	e8 e5 11 00 00       	call   10e270 <htons>
  10d08b:	66 89 43 02          	mov    %ax,0x2(%ebx)
    IPH_OFFSET_SET(iphdr, htons(IP_DF));
  10d08f:	8b 1d c0 db 11 00    	mov    0x11dbc0,%ebx
  10d095:	c7 04 24 00 40 00 00 	movl   $0x4000,(%esp)
  10d09c:	e8 cf 11 00 00       	call   10e270 <htons>
  10d0a1:	66 89 43 06          	mov    %ax,0x6(%ebx)
    IPH_ID_SET(iphdr, htons(ip_id));
  10d0a5:	8b 1d c0 db 11 00    	mov    0x11dbc0,%ebx
  10d0ab:	0f b7 05 bc db 11 00 	movzwl 0x11dbbc,%eax
  10d0b2:	0f b7 c0             	movzwl %ax,%eax
  10d0b5:	89 04 24             	mov    %eax,(%esp)
  10d0b8:	e8 b3 11 00 00       	call   10e270 <htons>
  10d0bd:	66 89 43 04          	mov    %ax,0x4(%ebx)
    ++ip_id;
  10d0c1:	0f b7 05 bc db 11 00 	movzwl 0x11dbbc,%eax
  10d0c8:	83 c0 01             	add    $0x1,%eax
  10d0cb:	66 a3 bc db 11 00    	mov    %ax,0x11dbbc

    if (ip_addr_isany(src)) {
  10d0d1:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  10d0d5:	74 09                	je     10d0e0 <ip_output_if+0x180>
  10d0d7:	8b 45 0c             	mov    0xc(%ebp),%eax
  10d0da:	8b 00                	mov    (%eax),%eax
  10d0dc:	85 c0                	test   %eax,%eax
  10d0de:	75 30                	jne    10d110 <ip_output_if+0x1b0>
      ip_addr_set(&(iphdr->src), &(netif->ip_addr));
  10d0e0:	8b 15 c0 db 11 00    	mov    0x11dbc0,%edx
  10d0e6:	89 55 dc             	mov    %edx,0xffffffdc(%ebp)
  10d0e9:	8b 45 20             	mov    0x20(%ebp),%eax
  10d0ec:	83 c0 04             	add    $0x4,%eax
  10d0ef:	85 c0                	test   %eax,%eax
  10d0f1:	74 0b                	je     10d0fe <ip_output_if+0x19e>
  10d0f3:	8b 45 20             	mov    0x20(%ebp),%eax
  10d0f6:	8b 40 04             	mov    0x4(%eax),%eax
  10d0f9:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
  10d0fc:	eb 07                	jmp    10d105 <ip_output_if+0x1a5>
  10d0fe:	c7 45 e0 00 00 00 00 	movl   $0x0,0xffffffe0(%ebp)
  10d105:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
  10d108:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  10d10b:	89 50 0c             	mov    %edx,0xc(%eax)
  10d10e:	eb 28                	jmp    10d138 <ip_output_if+0x1d8>
    } else {
      ip_addr_set(&(iphdr->src), src);
  10d110:	a1 c0 db 11 00       	mov    0x11dbc0,%eax
  10d115:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
  10d118:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  10d11c:	74 0a                	je     10d128 <ip_output_if+0x1c8>
  10d11e:	8b 45 0c             	mov    0xc(%ebp),%eax
  10d121:	8b 00                	mov    (%eax),%eax
  10d123:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
  10d126:	eb 07                	jmp    10d12f <ip_output_if+0x1cf>
  10d128:	c7 45 e8 00 00 00 00 	movl   $0x0,0xffffffe8(%ebp)
  10d12f:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  10d132:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
  10d135:	89 42 0c             	mov    %eax,0xc(%edx)
    }

    IPH_CHKSUM_SET(iphdr, 0);
  10d138:	a1 c0 db 11 00       	mov    0x11dbc0,%eax
  10d13d:	66 c7 40 0a 00 00    	movw   $0x0,0xa(%eax)
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  10d143:	8b 1d c0 db 11 00    	mov    0x11dbc0,%ebx
  10d149:	a1 c0 db 11 00       	mov    0x11dbc0,%eax
  10d14e:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  10d155:	00 
  10d156:	89 04 24             	mov    %eax,(%esp)
  10d159:	e8 22 0c 00 00       	call   10dd80 <inet_chksum>
  10d15e:	66 89 43 0a          	mov    %ax,0xa(%ebx)
  10d162:	eb 16                	jmp    10d17a <ip_output_if+0x21a>
  } else {
    iphdr = p->payload;
  10d164:	8b 45 08             	mov    0x8(%ebp),%eax
  10d167:	8b 40 04             	mov    0x4(%eax),%eax
  10d16a:	a3 c0 db 11 00       	mov    %eax,0x11dbc0
    dest = &(iphdr->dest);
  10d16f:	a1 c0 db 11 00       	mov    0x11dbc0,%eax
  10d174:	83 c0 10             	add    $0x10,%eax
  10d177:	89 45 10             	mov    %eax,0x10(%ebp)
  }

#if IP_FRAG
  /* don't fragment if interface has mtu set to 0 [loopif] */
  if (netif->mtu && (p->tot_len > netif->mtu))
  10d17a:	8b 45 20             	mov    0x20(%ebp),%eax
  10d17d:	0f b7 40 28          	movzwl 0x28(%eax),%eax
  10d181:	66 85 c0             	test   %ax,%ax
  10d184:	74 34                	je     10d1ba <ip_output_if+0x25a>
  10d186:	8b 45 08             	mov    0x8(%ebp),%eax
  10d189:	0f b7 50 08          	movzwl 0x8(%eax),%edx
  10d18d:	8b 45 20             	mov    0x20(%ebp),%eax
  10d190:	0f b7 40 28          	movzwl 0x28(%eax),%eax
  10d194:	66 39 c2             	cmp    %ax,%dx
  10d197:	76 21                	jbe    10d1ba <ip_output_if+0x25a>
    return ip_frag(p,netif,dest);
  10d199:	8b 45 10             	mov    0x10(%ebp),%eax
  10d19c:	89 44 24 08          	mov    %eax,0x8(%esp)
  10d1a0:	8b 45 20             	mov    0x20(%ebp),%eax
  10d1a3:	89 44 24 04          	mov    %eax,0x4(%esp)
  10d1a7:	8b 45 08             	mov    0x8(%ebp),%eax
  10d1aa:	89 04 24             	mov    %eax,(%esp)
  10d1ad:	e8 7e 07 00 00       	call   10d930 <ip_frag>
  10d1b2:	0f be c0             	movsbl %al,%eax
  10d1b5:	89 45 d0             	mov    %eax,0xffffffd0(%ebp)
  10d1b8:	eb 32                	jmp    10d1ec <ip_output_if+0x28c>
#endif

  IP_STATS_INC(ip.xmit);
  10d1ba:	0f b7 05 14 15 14 00 	movzwl 0x141514,%eax
  10d1c1:	83 c0 01             	add    $0x1,%eax
  10d1c4:	66 a3 14 15 14 00    	mov    %ax,0x141514

  LWIP_DEBUGF(IP_DEBUG, ("ip_output_if: %c%c%u\n", netif->name[0], netif->name[1], netif->num));
  ip_debug_print(p);

  LWIP_DEBUGF(IP_DEBUG, ("netif->output()"));

  return netif->output(netif, p, dest);
  10d1ca:	8b 45 20             	mov    0x20(%ebp),%eax
  10d1cd:	8b 50 14             	mov    0x14(%eax),%edx
  10d1d0:	8b 45 10             	mov    0x10(%ebp),%eax
  10d1d3:	89 44 24 08          	mov    %eax,0x8(%esp)
  10d1d7:	8b 45 08             	mov    0x8(%ebp),%eax
  10d1da:	89 44 24 04          	mov    %eax,0x4(%esp)
  10d1de:	8b 45 20             	mov    0x20(%ebp),%eax
  10d1e1:	89 04 24             	mov    %eax,(%esp)
  10d1e4:	ff d2                	call   *%edx
  10d1e6:	0f be c0             	movsbl %al,%eax
  10d1e9:	89 45 d0             	mov    %eax,0xffffffd0(%ebp)
  10d1ec:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
}
  10d1ef:	83 c4 40             	add    $0x40,%esp
  10d1f2:	5b                   	pop    %ebx
  10d1f3:	5e                   	pop    %esi
  10d1f4:	5d                   	pop    %ebp
  10d1f5:	c3                   	ret    
  10d1f6:	8d 76 00             	lea    0x0(%esi),%esi
  10d1f9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

0010d200 <ip_output>:

/* ip_output:
 *
 * Simple interface to ip_output_if. It finds the outgoing network
 * interface and calls upon ip_output_if to do the actual work.
 */

err_t
ip_output(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,
          u8_t ttl, u8_t tos, u8_t proto)
{
  10d200:	55                   	push   %ebp
  10d201:	89 e5                	mov    %esp,%ebp
  10d203:	53                   	push   %ebx
  10d204:	83 ec 44             	sub    $0x44,%esp
  10d207:	8b 45 14             	mov    0x14(%ebp),%eax
  10d20a:	8b 55 18             	mov    0x18(%ebp),%edx
  10d20d:	8b 4d 1c             	mov    0x1c(%ebp),%ecx
  10d210:	88 45 e8             	mov    %al,0xffffffe8(%ebp)
  10d213:	88 55 e4             	mov    %dl,0xffffffe4(%ebp)
  10d216:	88 4d e0             	mov    %cl,0xffffffe0(%ebp)
  struct netif *netif;

  if ((netif = ip_route(dest)) == NULL) {
  10d219:	8b 45 10             	mov    0x10(%ebp),%eax
  10d21c:	89 04 24             	mov    %eax,(%esp)
  10d21f:	e8 cc f8 ff ff       	call   10caf0 <ip_route>
  10d224:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  10d227:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  10d22b:	75 19                	jne    10d246 <ip_output+0x46>
    LWIP_DEBUGF(IP_DEBUG | 2, ("ip_output: No route to 0x%lx\n", dest->addr));

    IP_STATS_INC(ip.rterr);
  10d22d:	0f b7 05 24 15 14 00 	movzwl 0x141524,%eax
  10d234:	83 c0 01             	add    $0x1,%eax
  10d237:	66 a3 24 15 14 00    	mov    %ax,0x141524
    snmp_inc_ipoutdiscards();
    return ERR_RTE;
  10d23d:	c7 45 dc f7 ff ff ff 	movl   $0xfffffff7,0xffffffdc(%ebp)
  10d244:	eb 3e                	jmp    10d284 <ip_output+0x84>
  }

  return ip_output_if(p, src, dest, ttl, tos, proto, netif);
  10d246:	0f b6 55 e0          	movzbl 0xffffffe0(%ebp),%edx
  10d24a:	0f b6 4d e4          	movzbl 0xffffffe4(%ebp),%ecx
  10d24e:	0f b6 5d e8          	movzbl 0xffffffe8(%ebp),%ebx
  10d252:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10d255:	89 44 24 18          	mov    %eax,0x18(%esp)
  10d259:	89 54 24 14          	mov    %edx,0x14(%esp)
  10d25d:	89 4c 24 10          	mov    %ecx,0x10(%esp)
  10d261:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
  10d265:	8b 45 10             	mov    0x10(%ebp),%eax
  10d268:	89 44 24 08          	mov    %eax,0x8(%esp)
  10d26c:	8b 45 0c             	mov    0xc(%ebp),%eax
  10d26f:	89 44 24 04          	mov    %eax,0x4(%esp)
  10d273:	8b 45 08             	mov    0x8(%ebp),%eax
  10d276:	89 04 24             	mov    %eax,(%esp)
  10d279:	e8 e2 fc ff ff       	call   10cf60 <ip_output_if>
  10d27e:	0f be c0             	movsbl %al,%eax
  10d281:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
  10d284:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
}
  10d287:	83 c4 44             	add    $0x44,%esp
  10d28a:	5b                   	pop    %ebx
  10d28b:	5d                   	pop    %ebp
  10d28c:	c3                   	ret    
  10d28d:	90                   	nop    
  10d28e:	90                   	nop    
  10d28f:	90                   	nop    

0010d290 <copy_from_pbuf>:
 */
static struct pbuf *
copy_from_pbuf(struct pbuf *p, u16_t * offset,
           u8_t * buffer, u16_t len)
{
  10d290:	55                   	push   %ebp
  10d291:	89 e5                	mov    %esp,%ebp
  10d293:	83 ec 28             	sub    $0x28,%esp
  10d296:	8b 45 14             	mov    0x14(%ebp),%eax
  10d299:	66 89 45 ec          	mov    %ax,0xffffffec(%ebp)
  u16_t l;

  p->payload = (u8_t *)p->payload + *offset;
  10d29d:	8b 45 08             	mov    0x8(%ebp),%eax
  10d2a0:	8b 40 04             	mov    0x4(%eax),%eax
  10d2a3:	89 c2                	mov    %eax,%edx
  10d2a5:	8b 45 0c             	mov    0xc(%ebp),%eax
  10d2a8:	0f b7 00             	movzwl (%eax),%eax
  10d2ab:	0f b7 c0             	movzwl %ax,%eax
  10d2ae:	01 c2                	add    %eax,%edx
  10d2b0:	8b 45 08             	mov    0x8(%ebp),%eax
  10d2b3:	89 50 04             	mov    %edx,0x4(%eax)
  p->len -= *offset;
  10d2b6:	8b 45 08             	mov    0x8(%ebp),%eax
  10d2b9:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
  10d2bd:	8b 45 0c             	mov    0xc(%ebp),%eax
  10d2c0:	0f b7 00             	movzwl (%eax),%eax
  10d2c3:	66 29 c2             	sub    %ax,%dx
  10d2c6:	8b 45 08             	mov    0x8(%ebp),%eax
  10d2c9:	66 89 50 0a          	mov    %dx,0xa(%eax)
  while (len) {
  10d2cd:	eb 74                	jmp    10d343 <copy_from_pbuf+0xb3>
    l = len < p->len ? len : p->len;
  10d2cf:	8b 45 08             	mov    0x8(%ebp),%eax
  10d2d2:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  10d2d6:	0f b7 55 ec          	movzwl 0xffffffec(%ebp),%edx
  10d2da:	66 89 55 e8          	mov    %dx,0xffffffe8(%ebp)
  10d2de:	66 89 45 ea          	mov    %ax,0xffffffea(%ebp)
  10d2e2:	0f b7 45 e8          	movzwl 0xffffffe8(%ebp),%eax
  10d2e6:	66 39 45 ea          	cmp    %ax,0xffffffea(%ebp)
  10d2ea:	76 08                	jbe    10d2f4 <copy_from_pbuf+0x64>
  10d2ec:	0f b7 55 e8          	movzwl 0xffffffe8(%ebp),%edx
  10d2f0:	66 89 55 ea          	mov    %dx,0xffffffea(%ebp)
  10d2f4:	0f b7 45 ea          	movzwl 0xffffffea(%ebp),%eax
  10d2f8:	66 89 45 fe          	mov    %ax,0xfffffffe(%ebp)
    memcpy(buffer, p->payload, l);
  10d2fc:	0f b7 55 fe          	movzwl 0xfffffffe(%ebp),%edx
  10d300:	8b 45 08             	mov    0x8(%ebp),%eax
  10d303:	8b 40 04             	mov    0x4(%eax),%eax
  10d306:	89 54 24 08          	mov    %edx,0x8(%esp)
  10d30a:	89 44 24 04          	mov    %eax,0x4(%esp)
  10d30e:	8b 45 10             	mov    0x10(%ebp),%eax
  10d311:	89 04 24             	mov    %eax,(%esp)
  10d314:	e8 a7 8b ff ff       	call   105ec0 <memcpy>
    buffer += l;
  10d319:	0f b7 45 fe          	movzwl 0xfffffffe(%ebp),%eax
  10d31d:	01 45 10             	add    %eax,0x10(%ebp)
    len -= l;
  10d320:	0f b7 45 fe          	movzwl 0xfffffffe(%ebp),%eax
  10d324:	66 29 45 ec          	sub    %ax,0xffffffec(%ebp)
    if (len)
  10d328:	66 83 7d ec 00       	cmpw   $0x0,0xffffffec(%ebp)
  10d32d:	74 0a                	je     10d339 <copy_from_pbuf+0xa9>
      p = p->next;
  10d32f:	8b 45 08             	mov    0x8(%ebp),%eax
  10d332:	8b 00                	mov    (%eax),%eax
  10d334:	89 45 08             	mov    %eax,0x8(%ebp)
  10d337:	eb 0a                	jmp    10d343 <copy_from_pbuf+0xb3>
    else
      *offset = l;
  10d339:	8b 55 0c             	mov    0xc(%ebp),%edx
  10d33c:	0f b7 45 fe          	movzwl 0xfffffffe(%ebp),%eax
  10d340:	66 89 02             	mov    %ax,(%edx)
  10d343:	66 83 7d ec 00       	cmpw   $0x0,0xffffffec(%ebp)
  10d348:	75 85                	jne    10d2cf <copy_from_pbuf+0x3f>
  }
  return p;
  10d34a:	8b 45 08             	mov    0x8(%ebp),%eax
}
  10d34d:	c9                   	leave  
  10d34e:	c3                   	ret    
  10d34f:	90                   	nop    

0010d350 <ip_reass_timer>:

#define IP_REASS_BUFSIZE 5760
#define IP_REASS_MAXAGE 30
#define IP_REASS_TMO 1000

static u8_t ip_reassbuf[IP_HLEN + IP_REASS_BUFSIZE];
static u8_t ip_reassbitmap[IP_REASS_BUFSIZE / (8 * 8)];
static const u8_t bitmap_bits[8] = { 0xff, 0x7f, 0x3f, 0x1f,
  0x0f, 0x07, 0x03, 0x01
};
static u16_t ip_reasslen;
static u8_t ip_reassflags;
#define IP_REASS_FLAG_LASTFRAG 0x01

static u8_t ip_reasstmr;

/* Reassembly timer */ 
static void 
ip_reass_timer(void *arg)
{
  10d350:	55                   	push   %ebp
  10d351:	89 e5                	mov    %esp,%ebp
  10d353:	83 ec 18             	sub    $0x18,%esp
  (void)arg;
  if (ip_reasstmr > 1) {
  10d356:	0f b6 05 dd f2 11 00 	movzbl 0x11f2dd,%eax
  10d35d:	3c 01                	cmp    $0x1,%al
  10d35f:	76 2d                	jbe    10d38e <ip_reass_timer+0x3e>
    ip_reasstmr--;
  10d361:	0f b6 05 dd f2 11 00 	movzbl 0x11f2dd,%eax
  10d368:	83 e8 01             	sub    $0x1,%eax
  10d36b:	a2 dd f2 11 00       	mov    %al,0x11f2dd
    sys_timeout(IP_REASS_TMO, ip_reass_timer, NULL);
  10d370:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  10d377:	00 
  10d378:	c7 44 24 04 50 d3 10 	movl   $0x10d350,0x4(%esp)
  10d37f:	00 
  10d380:	c7 04 24 e8 03 00 00 	movl   $0x3e8,(%esp)
  10d387:	e8 64 2b 00 00       	call   10fef0 <sys_timeout>
  10d38c:	eb 12                	jmp    10d3a0 <ip_reass_timer+0x50>
  } else if (ip_reasstmr == 1)
  10d38e:	0f b6 05 dd f2 11 00 	movzbl 0x11f2dd,%eax
  10d395:	3c 01                	cmp    $0x1,%al
  10d397:	75 07                	jne    10d3a0 <ip_reass_timer+0x50>
  ip_reasstmr = 0;
  10d399:	c6 05 dd f2 11 00 00 	movb   $0x0,0x11f2dd
}
  10d3a0:	c9                   	leave  
  10d3a1:	c3                   	ret    
  10d3a2:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi
  10d3a9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

0010d3b0 <ip_reass>:

struct pbuf *
ip_reass(struct pbuf *p)
{
  10d3b0:	55                   	push   %ebp
  10d3b1:	89 e5                	mov    %esp,%ebp
  10d3b3:	56                   	push   %esi
  10d3b4:	53                   	push   %ebx
  10d3b5:	83 ec 40             	sub    $0x40,%esp
  struct pbuf *q;
  struct ip_hdr *fraghdr, *iphdr;
  u16_t offset, len;
  u16_t i;

  IPFRAG_STATS_INC(ip_frag.recv);
  10d3b8:	0f b7 05 fe 14 14 00 	movzwl 0x1414fe,%eax
  10d3bf:	83 c0 01             	add    $0x1,%eax
  10d3c2:	66 a3 fe 14 14 00    	mov    %ax,0x1414fe

  iphdr = (struct ip_hdr *) ip_reassbuf;
  10d3c8:	c7 45 f0 e0 db 11 00 	movl   $0x11dbe0,0xfffffff0(%ebp)
  fraghdr = (struct ip_hdr *) p->payload;
  10d3cf:	8b 45 08             	mov    0x8(%ebp),%eax
  10d3d2:	8b 40 04             	mov    0x4(%eax),%eax
  10d3d5:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  /* If ip_reasstmr is zero, no packet is present in the buffer, so we
     write the IP header of the fragment into the reassembly
     buffer. The timer is updated with the maximum age. */
  if (ip_reasstmr == 0) {
  10d3d8:	0f b6 05 dd f2 11 00 	movzbl 0x11f2dd,%eax
  10d3df:	84 c0                	test   %al,%al
  10d3e1:	75 60                	jne    10d443 <ip_reass+0x93>
    LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass: new packet\n"));
    memcpy(iphdr, fraghdr, IP_HLEN);
  10d3e3:	c7 44 24 08 14 00 00 	movl   $0x14,0x8(%esp)
  10d3ea:	00 
  10d3eb:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10d3ee:	89 44 24 04          	mov    %eax,0x4(%esp)
  10d3f2:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10d3f5:	89 04 24             	mov    %eax,(%esp)
  10d3f8:	e8 c3 8a ff ff       	call   105ec0 <memcpy>
    ip_reasstmr = IP_REASS_MAXAGE;
  10d3fd:	c6 05 dd f2 11 00 1e 	movb   $0x1e,0x11f2dd
    sys_timeout(IP_REASS_TMO, ip_reass_timer, NULL);
  10d404:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  10d40b:	00 
  10d40c:	c7 44 24 04 50 d3 10 	movl   $0x10d350,0x4(%esp)
  10d413:	00 
  10d414:	c7 04 24 e8 03 00 00 	movl   $0x3e8,(%esp)
  10d41b:	e8 d0 2a 00 00       	call   10fef0 <sys_timeout>
    ip_reassflags = 0;
  10d420:	c6 05 dc f2 11 00 00 	movb   $0x0,0x11f2dc
    /* Clear the bitmap. */
    memset(ip_reassbitmap, 0, sizeof(ip_reassbitmap));
  10d427:	c7 44 24 08 5a 00 00 	movl   $0x5a,0x8(%esp)
  10d42e:	00 
  10d42f:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  10d436:	00 
  10d437:	c7 04 24 80 f2 11 00 	movl   $0x11f280,(%esp)
  10d43e:	e8 bd 8a ff ff       	call   105f00 <memset>
  }

  /* Check if the incoming fragment matches the one currently present
     in the reasembly buffer. If so, we proceed with copying the
     fragment into the buffer. */
  if (ip_addr_cmp(&iphdr->src, &fraghdr->src) &&
  10d443:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10d446:	8b 50 0c             	mov    0xc(%eax),%edx
  10d449:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10d44c:	8b 40 0c             	mov    0xc(%eax),%eax
  10d44f:	39 c2                	cmp    %eax,%edx
  10d451:	0f 85 9e 04 00 00    	jne    10d8f5 <ip_reass+0x545>
  10d457:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10d45a:	8b 50 10             	mov    0x10(%eax),%edx
  10d45d:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10d460:	8b 40 10             	mov    0x10(%eax),%eax
  10d463:	39 c2                	cmp    %eax,%edx
  10d465:	0f 85 8a 04 00 00    	jne    10d8f5 <ip_reass+0x545>
  10d46b:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10d46e:	0f b7 50 04          	movzwl 0x4(%eax),%edx
  10d472:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10d475:	0f b7 40 04          	movzwl 0x4(%eax),%eax
  10d479:	66 39 c2             	cmp    %ax,%dx
  10d47c:	0f 85 73 04 00 00    	jne    10d8f5 <ip_reass+0x545>
      ip_addr_cmp(&iphdr->dest, &fraghdr->dest) &&
      IPH_ID(iphdr) == IPH_ID(fraghdr)) {
    LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass: matching old packet\n"));
    IPFRAG_STATS_INC(ip_frag.cachehit);
  10d482:	0f b7 05 12 15 14 00 	movzwl 0x141512,%eax
  10d489:	83 c0 01             	add    $0x1,%eax
  10d48c:	66 a3 12 15 14 00    	mov    %ax,0x141512
    /* Find out the offset in the reassembly buffer where we should
       copy the fragment. */
    len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  10d492:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10d495:	0f b7 40 02          	movzwl 0x2(%eax),%eax
  10d499:	0f b7 c0             	movzwl %ax,%eax
  10d49c:	89 04 24             	mov    %eax,(%esp)
  10d49f:	e8 fc 0d 00 00       	call   10e2a0 <ntohs>
  10d4a4:	89 c3                	mov    %eax,%ebx
  10d4a6:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10d4a9:	0f b7 00             	movzwl (%eax),%eax
  10d4ac:	0f b7 c0             	movzwl %ax,%eax
  10d4af:	89 04 24             	mov    %eax,(%esp)
  10d4b2:	e8 e9 0d 00 00       	call   10e2a0 <ntohs>
  10d4b7:	66 c1 e8 08          	shr    $0x8,%ax
  10d4bb:	0f b7 c0             	movzwl %ax,%eax
  10d4be:	83 e0 0f             	and    $0xf,%eax
  10d4c1:	c1 e0 02             	shl    $0x2,%eax
  10d4c4:	89 da                	mov    %ebx,%edx
  10d4c6:	66 29 c2             	sub    %ax,%dx
  10d4c9:	89 d0                	mov    %edx,%eax
  10d4cb:	66 89 45 f6          	mov    %ax,0xfffffff6(%ebp)
    offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
  10d4cf:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10d4d2:	0f b7 40 06          	movzwl 0x6(%eax),%eax
  10d4d6:	0f b7 c0             	movzwl %ax,%eax
  10d4d9:	89 04 24             	mov    %eax,(%esp)
  10d4dc:	e8 bf 0d 00 00       	call   10e2a0 <ntohs>
  10d4e1:	0f b7 c0             	movzwl %ax,%eax
  10d4e4:	25 ff 1f 00 00       	and    $0x1fff,%eax
  10d4e9:	c1 e0 03             	shl    $0x3,%eax
  10d4ec:	66 89 45 f4          	mov    %ax,0xfffffff4(%ebp)

    /* If the offset or the offset + fragment length overflows the
       reassembly buffer, we discard the entire packet. */
    if (offset > IP_REASS_BUFSIZE || offset + len > IP_REASS_BUFSIZE) {
  10d4f0:	66 81 7d f4 80 16    	cmpw   $0x1680,0xfffffff4(%ebp)
  10d4f6:	77 11                	ja     10d509 <ip_reass+0x159>
  10d4f8:	0f b7 45 f4          	movzwl 0xfffffff4(%ebp),%eax
  10d4fc:	0f b7 55 f6          	movzwl 0xfffffff6(%ebp),%edx
  10d500:	01 d0                	add    %edx,%eax
  10d502:	3d 80 16 00 00       	cmp    $0x1680,%eax
  10d507:	7e 20                	jle    10d529 <ip_reass+0x179>
      LWIP_DEBUGF(IP_REASS_DEBUG,
       ("ip_reass: fragment outside of buffer (%d:%d/%d).\n", offset,
        offset + len, IP_REASS_BUFSIZE));
      sys_untimeout(ip_reass_timer, NULL);
  10d509:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  10d510:	00 
  10d511:	c7 04 24 50 d3 10 00 	movl   $0x10d350,(%esp)
  10d518:	e8 03 2b 00 00       	call   110020 <sys_untimeout>
      ip_reasstmr = 0;
  10d51d:	c6 05 dd f2 11 00 00 	movb   $0x0,0x11f2dd
      goto nullreturn;
  10d524:	e9 cc 03 00 00       	jmp    10d8f5 <ip_reass+0x545>
    }

    /* Copy the fragment into the reassembly buffer, at the right
       offset. */
    LWIP_DEBUGF(IP_REASS_DEBUG,
     ("ip_reass: copying with offset %d into %d:%d\n", offset,
      IP_HLEN + offset, IP_HLEN + offset + len));
    i = IPH_HL(fraghdr) * 4;
  10d529:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10d52c:	0f b7 00             	movzwl (%eax),%eax
  10d52f:	0f b7 c0             	movzwl %ax,%eax
  10d532:	89 04 24             	mov    %eax,(%esp)
  10d535:	e8 66 0d 00 00       	call   10e2a0 <ntohs>
  10d53a:	66 c1 e8 08          	shr    $0x8,%ax
  10d53e:	0f b7 c0             	movzwl %ax,%eax
  10d541:	83 e0 0f             	and    $0xf,%eax
  10d544:	c1 e0 02             	shl    $0x2,%eax
  10d547:	66 89 45 e6          	mov    %ax,0xffffffe6(%ebp)
    copy_from_pbuf(p, &i, &ip_reassbuf[IP_HLEN + offset], len);
  10d54b:	0f b7 4d f6          	movzwl 0xfffffff6(%ebp),%ecx
  10d54f:	0f b7 45 f4          	movzwl 0xfffffff4(%ebp),%eax
  10d553:	89 c2                	mov    %eax,%edx
  10d555:	b8 f4 db 11 00       	mov    $0x11dbf4,%eax
  10d55a:	8d 04 02             	lea    (%edx,%eax,1),%eax
  10d55d:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
  10d561:	89 44 24 08          	mov    %eax,0x8(%esp)
  10d565:	8d 45 e6             	lea    0xffffffe6(%ebp),%eax
  10d568:	89 44 24 04          	mov    %eax,0x4(%esp)
  10d56c:	8b 45 08             	mov    0x8(%ebp),%eax
  10d56f:	89 04 24             	mov    %eax,(%esp)
  10d572:	e8 19 fd ff ff       	call   10d290 <copy_from_pbuf>

    /* Update the bitmap. */
    if (offset / (8 * 8) == (offset + len) / (8 * 8)) {
  10d577:	0f b7 45 f4          	movzwl 0xfffffff4(%ebp),%eax
  10d57b:	66 c1 e8 06          	shr    $0x6,%ax
  10d57f:	0f b7 c8             	movzwl %ax,%ecx
  10d582:	0f b7 55 f4          	movzwl 0xfffffff4(%ebp),%edx
  10d586:	0f b7 45 f6          	movzwl 0xfffffff6(%ebp),%eax
  10d58a:	01 c2                	add    %eax,%edx
  10d58c:	89 d0                	mov    %edx,%eax
  10d58e:	c1 f8 1f             	sar    $0x1f,%eax
  10d591:	c1 e8 1a             	shr    $0x1a,%eax
  10d594:	01 d0                	add    %edx,%eax
  10d596:	c1 f8 06             	sar    $0x6,%eax
  10d599:	39 c1                	cmp    %eax,%ecx
  10d59b:	75 60                	jne    10d5fd <ip_reass+0x24d>
      LWIP_DEBUGF(IP_REASS_DEBUG,
       ("ip_reass: updating single byte in bitmap.\n"));
      /* If the two endpoints are in the same byte, we only update
         that byte. */
      ip_reassbitmap[offset / (8 * 8)] |=
  10d59d:	0f b7 45 f4          	movzwl 0xfffffff4(%ebp),%eax
  10d5a1:	66 c1 e8 06          	shr    $0x6,%ax
  10d5a5:	0f b7 c8             	movzwl %ax,%ecx
  10d5a8:	0f b7 c0             	movzwl %ax,%eax
  10d5ab:	0f b6 80 80 f2 11 00 	movzbl 0x11f280(%eax),%eax
  10d5b2:	89 c3                	mov    %eax,%ebx
  10d5b4:	0f b7 45 f4          	movzwl 0xfffffff4(%ebp),%eax
  10d5b8:	66 c1 e8 03          	shr    $0x3,%ax
  10d5bc:	0f b7 c0             	movzwl %ax,%eax
  10d5bf:	83 e0 07             	and    $0x7,%eax
  10d5c2:	0f b6 80 b7 ad 11 00 	movzbl 0x11adb7(%eax),%eax
  10d5c9:	89 c6                	mov    %eax,%esi
  10d5cb:	0f b7 55 f4          	movzwl 0xfffffff4(%ebp),%edx
  10d5cf:	0f b7 45 f6          	movzwl 0xfffffff6(%ebp),%eax
  10d5d3:	01 c2                	add    %eax,%edx
  10d5d5:	89 d0                	mov    %edx,%eax
  10d5d7:	c1 f8 1f             	sar    $0x1f,%eax
  10d5da:	c1 e8 1d             	shr    $0x1d,%eax
  10d5dd:	01 d0                	add    %edx,%eax
  10d5df:	c1 f8 03             	sar    $0x3,%eax
  10d5e2:	83 e0 07             	and    $0x7,%eax
  10d5e5:	0f b6 80 b7 ad 11 00 	movzbl 0x11adb7(%eax),%eax
  10d5ec:	f7 d0                	not    %eax
  10d5ee:	21 f0                	and    %esi,%eax
  10d5f0:	09 d8                	or     %ebx,%eax
  10d5f2:	88 81 80 f2 11 00    	mov    %al,0x11f280(%ecx)
  10d5f8:	e9 cb 00 00 00       	jmp    10d6c8 <ip_reass+0x318>
    bitmap_bits[(offset / 8) & 7] &
    ~bitmap_bits[((offset + len) / 8) & 7];
    } else {
      /* If the two endpoints are in different bytes, we update the
         bytes in the endpoints and fill the stuff inbetween with
         0xff. */
      ip_reassbitmap[offset / (8 * 8)] |= bitmap_bits[(offset / 8) & 7];
  10d5fd:	0f b7 45 f4          	movzwl 0xfffffff4(%ebp),%eax
  10d601:	66 c1 e8 06          	shr    $0x6,%ax
  10d605:	0f b7 d0             	movzwl %ax,%edx
  10d608:	0f b7 c0             	movzwl %ax,%eax
  10d60b:	0f b6 88 80 f2 11 00 	movzbl 0x11f280(%eax),%ecx
  10d612:	0f b7 45 f4          	movzwl 0xfffffff4(%ebp),%eax
  10d616:	66 c1 e8 03          	shr    $0x3,%ax
  10d61a:	0f b7 c0             	movzwl %ax,%eax
  10d61d:	83 e0 07             	and    $0x7,%eax
  10d620:	0f b6 80 b7 ad 11 00 	movzbl 0x11adb7(%eax),%eax
  10d627:	09 c8                	or     %ecx,%eax
  10d629:	88 82 80 f2 11 00    	mov    %al,0x11f280(%edx)
      LWIP_DEBUGF(IP_REASS_DEBUG,
       ("ip_reass: updating many bytes in bitmap (%d:%d).\n",
        1 + offset / (8 * 8), (offset + len) / (8 * 8)));
      for (i = 1 + offset / (8 * 8); i < (offset + len) / (8 * 8); ++i) {
  10d62f:	0f b7 45 f4          	movzwl 0xfffffff4(%ebp),%eax
  10d633:	66 c1 e8 06          	shr    $0x6,%ax
  10d637:	83 c0 01             	add    $0x1,%eax
  10d63a:	66 89 45 e6          	mov    %ax,0xffffffe6(%ebp)
  10d63e:	eb 19                	jmp    10d659 <ip_reass+0x2a9>
  ip_reassbitmap[i] = 0xff;
  10d640:	0f b7 45 e6          	movzwl 0xffffffe6(%ebp),%eax
  10d644:	0f b7 c0             	movzwl %ax,%eax
  10d647:	c6 80 80 f2 11 00 ff 	movb   $0xff,0x11f280(%eax)
  10d64e:	0f b7 45 e6          	movzwl 0xffffffe6(%ebp),%eax
  10d652:	83 c0 01             	add    $0x1,%eax
  10d655:	66 89 45 e6          	mov    %ax,0xffffffe6(%ebp)
  10d659:	0f b7 45 e6          	movzwl 0xffffffe6(%ebp),%eax
  10d65d:	0f b7 c8             	movzwl %ax,%ecx
  10d660:	0f b7 55 f4          	movzwl 0xfffffff4(%ebp),%edx
  10d664:	0f b7 45 f6          	movzwl 0xfffffff6(%ebp),%eax
  10d668:	01 c2                	add    %eax,%edx
  10d66a:	89 d0                	mov    %edx,%eax
  10d66c:	c1 f8 1f             	sar    $0x1f,%eax
  10d66f:	c1 e8 1a             	shr    $0x1a,%eax
  10d672:	01 d0                	add    %edx,%eax
  10d674:	c1 f8 06             	sar    $0x6,%eax
  10d677:	39 c1                	cmp    %eax,%ecx
  10d679:	7c c5                	jl     10d640 <ip_reass+0x290>
      }
      ip_reassbitmap[(offset + len) / (8 * 8)] |=
  10d67b:	0f b7 55 f4          	movzwl 0xfffffff4(%ebp),%edx
  10d67f:	0f b7 45 f6          	movzwl 0xfffffff6(%ebp),%eax
  10d683:	01 c2                	add    %eax,%edx
  10d685:	89 d0                	mov    %edx,%eax
  10d687:	c1 f8 1f             	sar    $0x1f,%eax
  10d68a:	c1 e8 1a             	shr    $0x1a,%eax
  10d68d:	01 d0                	add    %edx,%eax
  10d68f:	c1 f8 06             	sar    $0x6,%eax
  10d692:	89 c1                	mov    %eax,%ecx
  10d694:	0f b6 80 80 f2 11 00 	movzbl 0x11f280(%eax),%eax
  10d69b:	89 c3                	mov    %eax,%ebx
  10d69d:	0f b7 55 f4          	movzwl 0xfffffff4(%ebp),%edx
  10d6a1:	0f b7 45 f6          	movzwl 0xfffffff6(%ebp),%eax
  10d6a5:	01 c2                	add    %eax,%edx
  10d6a7:	89 d0                	mov    %edx,%eax
  10d6a9:	c1 f8 1f             	sar    $0x1f,%eax
  10d6ac:	c1 e8 1d             	shr    $0x1d,%eax
  10d6af:	01 d0                	add    %edx,%eax
  10d6b1:	c1 f8 03             	sar    $0x3,%eax
  10d6b4:	83 e0 07             	and    $0x7,%eax
  10d6b7:	0f b6 80 b7 ad 11 00 	movzbl 0x11adb7(%eax),%eax
  10d6be:	f7 d0                	not    %eax
  10d6c0:	09 d8                	or     %ebx,%eax
  10d6c2:	88 81 80 f2 11 00    	mov    %al,0x11f280(%ecx)
    ~bitmap_bits[((offset + len) / 8) & 7];
    }

    /* If this fragment has the More Fragments flag set to zero, we
       know that this is the last fragment, so we can calculate the
       size of the entire packet. We also set the
       IP_REASS_FLAG_LASTFRAG flag to indicate that we have received
       the final fragment. */

    if ((ntohs(IPH_OFFSET(fraghdr)) & IP_MF) == 0) {
  10d6c8:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10d6cb:	0f b7 40 06          	movzwl 0x6(%eax),%eax
  10d6cf:	0f b7 c0             	movzwl %ax,%eax
  10d6d2:	89 04 24             	mov    %eax,(%esp)
  10d6d5:	e8 c6 0b 00 00       	call   10e2a0 <ntohs>
  10d6da:	0f b7 c0             	movzwl %ax,%eax
  10d6dd:	25 00 20 00 00       	and    $0x2000,%eax
  10d6e2:	85 c0                	test   %eax,%eax
  10d6e4:	75 1d                	jne    10d703 <ip_reass+0x353>
      ip_reassflags |= IP_REASS_FLAG_LASTFRAG;
  10d6e6:	0f b6 05 dc f2 11 00 	movzbl 0x11f2dc,%eax
  10d6ed:	83 c8 01             	or     $0x1,%eax
  10d6f0:	a2 dc f2 11 00       	mov    %al,0x11f2dc
      ip_reasslen = offset + len;
  10d6f5:	0f b7 45 f6          	movzwl 0xfffffff6(%ebp),%eax
  10d6f9:	66 03 45 f4          	add    0xfffffff4(%ebp),%ax
  10d6fd:	66 a3 da f2 11 00    	mov    %ax,0x11f2da
      LWIP_DEBUGF(IP_REASS_DEBUG,
       ("ip_reass: last fragment seen, total len %d\n",
        ip_reasslen));
    }

    /* Finally, we check if we have a full packet in the buffer. We do
       this by checking if we have the last fragment and if all bits
       in the bitmap are set. */
    if (ip_reassflags & IP_REASS_FLAG_LASTFRAG) {
  10d703:	0f b6 05 dc f2 11 00 	movzbl 0x11f2dc,%eax
  10d70a:	0f b6 c0             	movzbl %al,%eax
  10d70d:	83 e0 01             	and    $0x1,%eax
  10d710:	84 c0                	test   %al,%al
  10d712:	0f 84 dd 01 00 00    	je     10d8f5 <ip_reass+0x545>
      /* Check all bytes up to and including all but the last byte in
         the bitmap. */
      for (i = 0; i < ip_reasslen / (8 * 8) - 1; ++i) {
  10d718:	66 c7 45 e6 00 00    	movw   $0x0,0xffffffe6(%ebp)
  10d71e:	eb 22                	jmp    10d742 <ip_reass+0x392>
  if (ip_reassbitmap[i] != 0xff) {
  10d720:	0f b7 45 e6          	movzwl 0xffffffe6(%ebp),%eax
  10d724:	0f b7 c0             	movzwl %ax,%eax
  10d727:	0f b6 80 80 f2 11 00 	movzbl 0x11f280(%eax),%eax
  10d72e:	3c ff                	cmp    $0xff,%al
  10d730:	74 05                	je     10d737 <ip_reass+0x387>
    LWIP_DEBUGF(IP_REASS_DEBUG,
     ("ip_reass: last fragment seen, bitmap %d/%d failed (%x)\n",
      i, ip_reasslen / (8 * 8) - 1, ip_reassbitmap[i]));
    goto nullreturn;
  10d732:	e9 be 01 00 00       	jmp    10d8f5 <ip_reass+0x545>
  10d737:	0f b7 45 e6          	movzwl 0xffffffe6(%ebp),%eax
  10d73b:	83 c0 01             	add    $0x1,%eax
  10d73e:	66 89 45 e6          	mov    %ax,0xffffffe6(%ebp)
  10d742:	0f b7 45 e6          	movzwl 0xffffffe6(%ebp),%eax
  10d746:	0f b7 d0             	movzwl %ax,%edx
  10d749:	0f b7 05 da f2 11 00 	movzwl 0x11f2da,%eax
  10d750:	66 c1 e8 06          	shr    $0x6,%ax
  10d754:	0f b7 c0             	movzwl %ax,%eax
  10d757:	83 e8 01             	sub    $0x1,%eax
  10d75a:	39 c2                	cmp    %eax,%edx
  10d75c:	7c c2                	jl     10d720 <ip_reass+0x370>
  }
      }
      /* Check the last byte in the bitmap. It should contain just the
         right amount of bits. */
      if (ip_reassbitmap[ip_reasslen / (8 * 8)] !=
  10d75e:	0f b7 05 da f2 11 00 	movzwl 0x11f2da,%eax
  10d765:	66 c1 e8 06          	shr    $0x6,%ax
  10d769:	0f b7 c0             	movzwl %ax,%eax
  10d76c:	0f b6 90 80 f2 11 00 	movzbl 0x11f280(%eax),%edx
  10d773:	0f b7 05 da f2 11 00 	movzwl 0x11f2da,%eax
  10d77a:	66 c1 e8 03          	shr    $0x3,%ax
  10d77e:	0f b7 c0             	movzwl %ax,%eax
  10d781:	83 e0 07             	and    $0x7,%eax
  10d784:	0f b6 80 b7 ad 11 00 	movzbl 0x11adb7(%eax),%eax
  10d78b:	f7 d0                	not    %eax
  10d78d:	38 c2                	cmp    %al,%dl
  10d78f:	74 05                	je     10d796 <ip_reass+0x3e6>
    (u8_t) ~ bitmap_bits[ip_reasslen / 8 & 7]) {
  LWIP_DEBUGF(IP_REASS_DEBUG,
         ("ip_reass: last fragment seen, bitmap %d didn't contain %x (%x)\n",
    ip_reasslen / (8 * 8), ~bitmap_bits[ip_reasslen / 8 & 7],
    ip_reassbitmap[ip_reasslen / (8 * 8)]));
  goto nullreturn;
  10d791:	e9 5f 01 00 00       	jmp    10d8f5 <ip_reass+0x545>
      }

      /* Pretend to be a "normal" (i.e., not fragmented) IP packet
         from now on. */
      ip_reasslen += IP_HLEN;
  10d796:	0f b7 05 da f2 11 00 	movzwl 0x11f2da,%eax
  10d79d:	83 c0 14             	add    $0x14,%eax
  10d7a0:	66 a3 da f2 11 00    	mov    %ax,0x11f2da

      IPH_LEN_SET(iphdr, htons(ip_reasslen));
  10d7a6:	0f b7 05 da f2 11 00 	movzwl 0x11f2da,%eax
  10d7ad:	0f b7 c0             	movzwl %ax,%eax
  10d7b0:	89 04 24             	mov    %eax,(%esp)
  10d7b3:	e8 b8 0a 00 00       	call   10e270 <htons>
  10d7b8:	89 c2                	mov    %eax,%edx
  10d7ba:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10d7bd:	66 89 50 02          	mov    %dx,0x2(%eax)
      IPH_OFFSET_SET(iphdr, 0);
  10d7c1:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10d7c4:	66 c7 40 06 00 00    	movw   $0x0,0x6(%eax)
      IPH_CHKSUM_SET(iphdr, 0);
  10d7ca:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10d7cd:	66 c7 40 0a 00 00    	movw   $0x0,0xa(%eax)
      IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  10d7d3:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  10d7da:	00 
  10d7db:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10d7de:	89 04 24             	mov    %eax,(%esp)
  10d7e1:	e8 9a 05 00 00       	call   10dd80 <inet_chksum>
  10d7e6:	89 c2                	mov    %eax,%edx
  10d7e8:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10d7eb:	66 89 50 0a          	mov    %dx,0xa(%eax)

      /* If we have come this far, we have a full packet in the
         buffer, so we allocate a pbuf and copy the packet into it. We
         also reset the timer. */
      sys_untimeout(ip_reass_timer, NULL);
  10d7ef:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  10d7f6:	00 
  10d7f7:	c7 04 24 50 d3 10 00 	movl   $0x10d350,(%esp)
  10d7fe:	e8 1d 28 00 00       	call   110020 <sys_untimeout>
      ip_reasstmr = 0;
  10d803:	c6 05 dd f2 11 00 00 	movb   $0x0,0x11f2dd
      pbuf_free(p);
  10d80a:	8b 45 08             	mov    0x8(%ebp),%eax
  10d80d:	89 04 24             	mov    %eax,(%esp)
  10d810:	e8 9b 1c 00 00       	call   10f4b0 <pbuf_free>
      p = pbuf_alloc(PBUF_LINK, ip_reasslen, PBUF_POOL);
  10d815:	0f b7 05 da f2 11 00 	movzwl 0x11f2da,%eax
  10d81c:	0f b7 c0             	movzwl %ax,%eax
  10d81f:	c7 44 24 08 03 00 00 	movl   $0x3,0x8(%esp)
  10d826:	00 
  10d827:	89 44 24 04          	mov    %eax,0x4(%esp)
  10d82b:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  10d832:	e8 99 17 00 00       	call   10efd0 <pbuf_alloc>
  10d837:	89 45 08             	mov    %eax,0x8(%ebp)
      if (p != NULL) {
  10d83a:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  10d83e:	0f 84 99 00 00 00    	je     10d8dd <ip_reass+0x52d>
  i = 0;
  10d844:	66 c7 45 e6 00 00    	movw   $0x0,0xffffffe6(%ebp)
  for (q = p; q != NULL; q = q->next) {
  10d84a:	8b 45 08             	mov    0x8(%ebp),%eax
  10d84d:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
  10d850:	eb 73                	jmp    10d8c5 <ip_reass+0x515>
    /* Copy enough bytes to fill this pbuf in the chain. The
       available data in the pbuf is given by the q->len
       variable. */
    LWIP_DEBUGF(IP_REASS_DEBUG,
     ("ip_reass: memcpy from %p (%d) to %p, %d bytes\n",
      &ip_reassbuf[i], i, q->payload,
      q->len > ip_reasslen - i ? ip_reasslen - i : q->len));
    memcpy(q->payload, &ip_reassbuf[i],
  10d852:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  10d855:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  10d859:	0f b7 c8             	movzwl %ax,%ecx
  10d85c:	0f b7 05 da f2 11 00 	movzwl 0x11f2da,%eax
  10d863:	0f b7 d0             	movzwl %ax,%edx
  10d866:	0f b7 45 e6          	movzwl 0xffffffe6(%ebp),%eax
  10d86a:	0f b7 c0             	movzwl %ax,%eax
  10d86d:	89 d3                	mov    %edx,%ebx
  10d86f:	29 c3                	sub    %eax,%ebx
  10d871:	89 5d cc             	mov    %ebx,0xffffffcc(%ebp)
  10d874:	89 4d d0             	mov    %ecx,0xffffffd0(%ebp)
  10d877:	8b 45 cc             	mov    0xffffffcc(%ebp),%eax
  10d87a:	39 45 d0             	cmp    %eax,0xffffffd0(%ebp)
  10d87d:	7e 06                	jle    10d885 <ip_reass+0x4d5>
  10d87f:	8b 55 cc             	mov    0xffffffcc(%ebp),%edx
  10d882:	89 55 d0             	mov    %edx,0xffffffd0(%ebp)
  10d885:	0f b7 45 e6          	movzwl 0xffffffe6(%ebp),%eax
  10d889:	0f b7 c0             	movzwl %ax,%eax
  10d88c:	8d 90 e0 db 11 00    	lea    0x11dbe0(%eax),%edx
  10d892:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  10d895:	8b 40 04             	mov    0x4(%eax),%eax
  10d898:	8b 4d d0             	mov    0xffffffd0(%ebp),%ecx
  10d89b:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  10d89f:	89 54 24 04          	mov    %edx,0x4(%esp)
  10d8a3:	89 04 24             	mov    %eax,(%esp)
  10d8a6:	e8 15 86 ff ff       	call   105ec0 <memcpy>
    q->len > ip_reasslen - i ? ip_reasslen - i : q->len);
    i += q->len;
  10d8ab:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  10d8ae:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
  10d8b2:	0f b7 45 e6          	movzwl 0xffffffe6(%ebp),%eax
  10d8b6:	8d 04 02             	lea    (%edx,%eax,1),%eax
  10d8b9:	66 89 45 e6          	mov    %ax,0xffffffe6(%ebp)
  10d8bd:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  10d8c0:	8b 00                	mov    (%eax),%eax
  10d8c2:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
  10d8c5:	83 7d e8 00          	cmpl   $0x0,0xffffffe8(%ebp)
  10d8c9:	75 87                	jne    10d852 <ip_reass+0x4a2>
  }
  IPFRAG_STATS_INC(ip_frag.fw);
  10d8cb:	0f b7 05 00 15 14 00 	movzwl 0x141500,%eax
  10d8d2:	83 c0 01             	add    $0x1,%eax
  10d8d5:	66 a3 00 15 14 00    	mov    %ax,0x141500
  10d8db:	eb 10                	jmp    10d8ed <ip_reass+0x53d>
      } else {
  IPFRAG_STATS_INC(ip_frag.memerr);
  10d8dd:	0f b7 05 08 15 14 00 	movzwl 0x141508,%eax
  10d8e4:	83 c0 01             	add    $0x1,%eax
  10d8e7:	66 a3 08 15 14 00    	mov    %ax,0x141508
      }
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass: p %p\n", (void*)p));
      return p;
  10d8ed:	8b 5d 08             	mov    0x8(%ebp),%ebx
  10d8f0:	89 5d d4             	mov    %ebx,0xffffffd4(%ebp)
  10d8f3:	eb 22                	jmp    10d917 <ip_reass+0x567>
    }
  }

nullreturn:
  IPFRAG_STATS_INC(ip_frag.drop);
  10d8f5:	0f b7 05 02 15 14 00 	movzwl 0x141502,%eax
  10d8fc:	83 c0 01             	add    $0x1,%eax
  10d8ff:	66 a3 02 15 14 00    	mov    %ax,0x141502
  pbuf_free(p);
  10d905:	8b 45 08             	mov    0x8(%ebp),%eax
  10d908:	89 04 24             	mov    %eax,(%esp)
  10d90b:	e8 a0 1b 00 00       	call   10f4b0 <pbuf_free>
  return NULL;
  10d910:	c7 45 d4 00 00 00 00 	movl   $0x0,0xffffffd4(%ebp)
  10d917:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
}
  10d91a:	83 c4 40             	add    $0x40,%esp
  10d91d:	5b                   	pop    %ebx
  10d91e:	5e                   	pop    %esi
  10d91f:	5d                   	pop    %ebp
  10d920:	c3                   	ret    
  10d921:	eb 0d                	jmp    10d930 <ip_frag>
  10d923:	90                   	nop    
  10d924:	90                   	nop    
  10d925:	90                   	nop    
  10d926:	90                   	nop    
  10d927:	90                   	nop    
  10d928:	90                   	nop    
  10d929:	90                   	nop    
  10d92a:	90                   	nop    
  10d92b:	90                   	nop    
  10d92c:	90                   	nop    
  10d92d:	90                   	nop    
  10d92e:	90                   	nop    
  10d92f:	90                   	nop    

0010d930 <ip_frag>:

#define MAX_MTU 1500
static u8_t buf[MEM_ALIGN_SIZE(MAX_MTU)];

/**
 * Fragment an IP packet if too large
 *
 * Chop the packet in mtu sized chunks and send them in order
 * by using a fixed size static memory buffer (PBUF_ROM)
 */
err_t 
ip_frag(struct pbuf *p, struct netif *netif, struct ip_addr *dest)
{
  10d930:	55                   	push   %ebp
  10d931:	89 e5                	mov    %esp,%ebp
  10d933:	83 ec 38             	sub    $0x38,%esp
  struct pbuf *rambuf;
  struct pbuf *header;
  struct ip_hdr *iphdr;
  u16_t nfb = 0;
  10d936:	66 c7 45 f0 00 00    	movw   $0x0,0xfffffff0(%ebp)
  u16_t left, cop;
  u16_t mtu = netif->mtu;
  10d93c:	8b 45 0c             	mov    0xc(%ebp),%eax
  10d93f:	0f b7 40 28          	movzwl 0x28(%eax),%eax
  10d943:	66 89 45 f6          	mov    %ax,0xfffffff6(%ebp)
  u16_t ofo, omf;
  u16_t last;
  u16_t poff = IP_HLEN;
  10d947:	66 c7 45 e2 14 00    	movw   $0x14,0xffffffe2(%ebp)
  u16_t tmp;

  /* Get a RAM based MTU sized pbuf */
  rambuf = pbuf_alloc(PBUF_LINK, 0, PBUF_REF);
  10d94d:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
  10d954:	00 
  10d955:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  10d95c:	00 
  10d95d:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  10d964:	e8 67 16 00 00       	call   10efd0 <pbuf_alloc>
  10d969:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
  rambuf->tot_len = rambuf->len = mtu;
  10d96c:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
  10d96f:	0f b7 45 f6          	movzwl 0xfffffff6(%ebp),%eax
  10d973:	66 89 42 0a          	mov    %ax,0xa(%edx)
  10d977:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
  10d97a:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
  10d97e:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
  10d981:	66 89 50 08          	mov    %dx,0x8(%eax)
  rambuf->payload = MEM_ALIGN((void *)buf);
  10d985:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
  10d988:	c7 40 04 e0 f2 11 00 	movl   $0x11f2e0,0x4(%eax)


  /* Copy the IP header in it */
  iphdr = rambuf->payload;
  10d98f:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
  10d992:	8b 40 04             	mov    0x4(%eax),%eax
  10d995:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  memcpy(iphdr, p->payload, IP_HLEN);
  10d998:	8b 45 08             	mov    0x8(%ebp),%eax
  10d99b:	8b 40 04             	mov    0x4(%eax),%eax
  10d99e:	c7 44 24 08 14 00 00 	movl   $0x14,0x8(%esp)
  10d9a5:	00 
  10d9a6:	89 44 24 04          	mov    %eax,0x4(%esp)
  10d9aa:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10d9ad:	89 04 24             	mov    %eax,(%esp)
  10d9b0:	e8 0b 85 ff ff       	call   105ec0 <memcpy>

  /* Save original offset */
  tmp = ntohs(IPH_OFFSET(iphdr));
  10d9b5:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10d9b8:	0f b7 40 06          	movzwl 0x6(%eax),%eax
  10d9bc:	0f b7 c0             	movzwl %ax,%eax
  10d9bf:	89 04 24             	mov    %eax,(%esp)
  10d9c2:	e8 d9 08 00 00       	call   10e2a0 <ntohs>
  10d9c7:	66 89 45 fe          	mov    %ax,0xfffffffe(%ebp)
  ofo = tmp & IP_OFFMASK;
  10d9cb:	0f b7 45 fe          	movzwl 0xfffffffe(%ebp),%eax
  10d9cf:	66 25 ff 1f          	and    $0x1fff,%ax
  10d9d3:	66 89 45 f8          	mov    %ax,0xfffffff8(%ebp)
  omf = tmp & IP_MF;
  10d9d7:	0f b7 45 fe          	movzwl 0xfffffffe(%ebp),%eax
  10d9db:	66 25 00 20          	and    $0x2000,%ax
  10d9df:	66 89 45 fa          	mov    %ax,0xfffffffa(%ebp)

  left = p->tot_len - IP_HLEN;
  10d9e3:	8b 45 08             	mov    0x8(%ebp),%eax
  10d9e6:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  10d9ea:	83 e8 14             	sub    $0x14,%eax
  10d9ed:	66 89 45 f2          	mov    %ax,0xfffffff2(%ebp)

  while (left) {
  10d9f1:	e9 89 01 00 00       	jmp    10db7f <ip_frag+0x24f>
    last = (left <= mtu - IP_HLEN);
  10d9f6:	0f b7 55 f2          	movzwl 0xfffffff2(%ebp),%edx
  10d9fa:	0f b7 45 f6          	movzwl 0xfffffff6(%ebp),%eax
  10d9fe:	83 e8 14             	sub    $0x14,%eax
  10da01:	39 c2                	cmp    %eax,%edx
  10da03:	0f 9e c0             	setle  %al
  10da06:	0f b6 c0             	movzbl %al,%eax
  10da09:	66 89 45 fc          	mov    %ax,0xfffffffc(%ebp)

    /* Set new offset and MF flag */
    ofo += nfb;
  10da0d:	0f b7 45 f0          	movzwl 0xfffffff0(%ebp),%eax
  10da11:	66 01 45 f8          	add    %ax,0xfffffff8(%ebp)
    tmp = omf | (IP_OFFMASK & (ofo));
  10da15:	0f b7 45 f8          	movzwl 0xfffffff8(%ebp),%eax
  10da19:	89 c2                	mov    %eax,%edx
  10da1b:	66 81 e2 ff 1f       	and    $0x1fff,%dx
  10da20:	0f b7 45 fa          	movzwl 0xfffffffa(%ebp),%eax
  10da24:	09 d0                	or     %edx,%eax
  10da26:	66 89 45 fe          	mov    %ax,0xfffffffe(%ebp)
    if (!last)
  10da2a:	66 83 7d fc 00       	cmpw   $0x0,0xfffffffc(%ebp)
  10da2f:	75 06                	jne    10da37 <ip_frag+0x107>
      tmp = tmp | IP_MF;
  10da31:	66 81 4d fe 00 20    	orw    $0x2000,0xfffffffe(%ebp)
    IPH_OFFSET_SET(iphdr, htons(tmp));
  10da37:	0f b7 45 fe          	movzwl 0xfffffffe(%ebp),%eax
  10da3b:	89 04 24             	mov    %eax,(%esp)
  10da3e:	e8 2d 08 00 00       	call   10e270 <htons>
  10da43:	89 c2                	mov    %eax,%edx
  10da45:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10da48:	66 89 50 06          	mov    %dx,0x6(%eax)

    /* Fill this fragment */
    nfb = (mtu - IP_HLEN) / 8;
  10da4c:	0f b7 45 f6          	movzwl 0xfffffff6(%ebp),%eax
  10da50:	8d 50 ec             	lea    0xffffffec(%eax),%edx
  10da53:	89 d0                	mov    %edx,%eax
  10da55:	c1 f8 1f             	sar    $0x1f,%eax
  10da58:	c1 e8 1d             	shr    $0x1d,%eax
  10da5b:	01 d0                	add    %edx,%eax
  10da5d:	c1 f8 03             	sar    $0x3,%eax
  10da60:	66 89 45 f0          	mov    %ax,0xfffffff0(%ebp)
    cop = last ? left : nfb * 8;
  10da64:	66 83 7d fc 00       	cmpw   $0x0,0xfffffffc(%ebp)
  10da69:	75 0d                	jne    10da78 <ip_frag+0x148>
  10da6b:	0f b7 45 f0          	movzwl 0xfffffff0(%ebp),%eax
  10da6f:	c1 e0 03             	shl    $0x3,%eax
  10da72:	66 89 45 de          	mov    %ax,0xffffffde(%ebp)
  10da76:	eb 08                	jmp    10da80 <ip_frag+0x150>
  10da78:	0f b7 45 f2          	movzwl 0xfffffff2(%ebp),%eax
  10da7c:	66 89 45 de          	mov    %ax,0xffffffde(%ebp)
  10da80:	0f b7 45 de          	movzwl 0xffffffde(%ebp),%eax
  10da84:	66 89 45 f4          	mov    %ax,0xfffffff4(%ebp)

    p = copy_from_pbuf(p, &poff, (u8_t *) iphdr + IP_HLEN, cop);
  10da88:	0f b7 55 f4          	movzwl 0xfffffff4(%ebp),%edx
  10da8c:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10da8f:	83 c0 14             	add    $0x14,%eax
  10da92:	89 54 24 0c          	mov    %edx,0xc(%esp)
  10da96:	89 44 24 08          	mov    %eax,0x8(%esp)
  10da9a:	8d 45 e2             	lea    0xffffffe2(%ebp),%eax
  10da9d:	89 44 24 04          	mov    %eax,0x4(%esp)
  10daa1:	8b 45 08             	mov    0x8(%ebp),%eax
  10daa4:	89 04 24             	mov    %eax,(%esp)
  10daa7:	e8 e4 f7 ff ff       	call   10d290 <copy_from_pbuf>
  10daac:	89 45 08             	mov    %eax,0x8(%ebp)

    /* Correct header */
    IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
  10daaf:	0f b7 45 f4          	movzwl 0xfffffff4(%ebp),%eax
  10dab3:	83 c0 14             	add    $0x14,%eax
  10dab6:	0f b7 c0             	movzwl %ax,%eax
  10dab9:	89 04 24             	mov    %eax,(%esp)
  10dabc:	e8 af 07 00 00       	call   10e270 <htons>
  10dac1:	89 c2                	mov    %eax,%edx
  10dac3:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10dac6:	66 89 50 02          	mov    %dx,0x2(%eax)
    IPH_CHKSUM_SET(iphdr, 0);
  10daca:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10dacd:	66 c7 40 0a 00 00    	movw   $0x0,0xa(%eax)
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  10dad3:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  10dada:	00 
  10dadb:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10dade:	89 04 24             	mov    %eax,(%esp)
  10dae1:	e8 9a 02 00 00       	call   10dd80 <inet_chksum>
  10dae6:	89 c2                	mov    %eax,%edx
  10dae8:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10daeb:	66 89 50 0a          	mov    %dx,0xa(%eax)

    if (last)
  10daef:	66 83 7d fc 00       	cmpw   $0x0,0xfffffffc(%ebp)
  10daf4:	74 19                	je     10db0f <ip_frag+0x1df>
      pbuf_realloc(rambuf, left + IP_HLEN);
  10daf6:	0f b7 45 f2          	movzwl 0xfffffff2(%ebp),%eax
  10dafa:	83 c0 14             	add    $0x14,%eax
  10dafd:	0f b7 c0             	movzwl %ax,%eax
  10db00:	89 44 24 04          	mov    %eax,0x4(%esp)
  10db04:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
  10db07:	89 04 24             	mov    %eax,(%esp)
  10db0a:	e8 91 17 00 00       	call   10f2a0 <pbuf_realloc>
    /* This part is ugly: we alloc a RAM based pbuf for 
     * the link level header for each chunk and then 
     * free it.A PBUF_ROM style pbuf for which pbuf_header
     * worked would make things simpler.
     */
    header = pbuf_alloc(PBUF_LINK, 0, PBUF_RAM);
  10db0f:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  10db16:	00 
  10db17:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  10db1e:	00 
  10db1f:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  10db26:	e8 a5 14 00 00       	call   10efd0 <pbuf_alloc>
  10db2b:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
    pbuf_chain(header, rambuf);
  10db2e:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
  10db31:	89 44 24 04          	mov    %eax,0x4(%esp)
  10db35:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  10db38:	89 04 24             	mov    %eax,(%esp)
  10db3b:	e8 70 1b 00 00       	call   10f6b0 <pbuf_chain>
    netif->output(netif, header, dest);
  10db40:	8b 45 0c             	mov    0xc(%ebp),%eax
  10db43:	8b 50 14             	mov    0x14(%eax),%edx
  10db46:	8b 45 10             	mov    0x10(%ebp),%eax
  10db49:	89 44 24 08          	mov    %eax,0x8(%esp)
  10db4d:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  10db50:	89 44 24 04          	mov    %eax,0x4(%esp)
  10db54:	8b 45 0c             	mov    0xc(%ebp),%eax
  10db57:	89 04 24             	mov    %eax,(%esp)
  10db5a:	ff d2                	call   *%edx
    IPFRAG_STATS_INC(ip_frag.xmit);
  10db5c:	0f b7 05 fa 14 14 00 	movzwl 0x1414fa,%eax
  10db63:	83 c0 01             	add    $0x1,%eax
  10db66:	66 a3 fa 14 14 00    	mov    %ax,0x1414fa
    pbuf_free(header);
  10db6c:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  10db6f:	89 04 24             	mov    %eax,(%esp)
  10db72:	e8 39 19 00 00       	call   10f4b0 <pbuf_free>

    left -= cop;
  10db77:	0f b7 45 f4          	movzwl 0xfffffff4(%ebp),%eax
  10db7b:	66 29 45 f2          	sub    %ax,0xfffffff2(%ebp)
  10db7f:	66 83 7d f2 00       	cmpw   $0x0,0xfffffff2(%ebp)
  10db84:	0f 85 6c fe ff ff    	jne    10d9f6 <ip_frag+0xc6>
  }
  pbuf_free(rambuf);
  10db8a:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
  10db8d:	89 04 24             	mov    %eax,(%esp)
  10db90:	e8 1b 19 00 00       	call   10f4b0 <pbuf_free>
  return ERR_OK;
  10db95:	b8 00 00 00 00       	mov    $0x0,%eax
}
  10db9a:	c9                   	leave  
  10db9b:	c3                   	ret    
  10db9c:	90                   	nop    
  10db9d:	90                   	nop    
  10db9e:	90                   	nop    
  10db9f:	90                   	nop    

0010dba0 <lwip_chksum>:


static u16_t
lwip_chksum(void *dataptr, int len)
{
  10dba0:	55                   	push   %ebp
  10dba1:	89 e5                	mov    %esp,%ebp
  10dba3:	83 ec 18             	sub    $0x18,%esp
  u32_t acc;

  LWIP_DEBUGF(INET_DEBUG, ("lwip_chksum(%p, %d)\n", (void *)dataptr, len));
  for(acc = 0; len > 1; len -= 2) {
  10dba6:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
  10dbad:	eb 19                	jmp    10dbc8 <lwip_chksum+0x28>
      /*    acc = acc + *((u16_t *)dataptr)++;*/
    acc += *(u16_t *)dataptr;
  10dbaf:	8b 45 08             	mov    0x8(%ebp),%eax
  10dbb2:	0f b7 00             	movzwl (%eax),%eax
  10dbb5:	0f b7 c0             	movzwl %ax,%eax
  10dbb8:	01 45 fc             	add    %eax,0xfffffffc(%ebp)
    dataptr = (void *)((u16_t *)dataptr + 1);
  10dbbb:	8b 45 08             	mov    0x8(%ebp),%eax
  10dbbe:	83 c0 02             	add    $0x2,%eax
  10dbc1:	89 45 08             	mov    %eax,0x8(%ebp)
  10dbc4:	83 6d 0c 02          	subl   $0x2,0xc(%ebp)
  10dbc8:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
  10dbcc:	7f e1                	jg     10dbaf <lwip_chksum+0xf>
  }

  /* add up any odd byte */
  if (len == 1) {
  10dbce:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
  10dbd2:	75 1d                	jne    10dbf1 <lwip_chksum+0x51>
    acc += htons((u16_t)((*(u8_t *)dataptr) & 0xff) << 8);
  10dbd4:	8b 45 08             	mov    0x8(%ebp),%eax
  10dbd7:	0f b6 00             	movzbl (%eax),%eax
  10dbda:	0f b6 c0             	movzbl %al,%eax
  10dbdd:	c1 e0 08             	shl    $0x8,%eax
  10dbe0:	0f b7 c0             	movzwl %ax,%eax
  10dbe3:	89 04 24             	mov    %eax,(%esp)
  10dbe6:	e8 85 06 00 00       	call   10e270 <htons>
  10dbeb:	0f b7 c0             	movzwl %ax,%eax
  10dbee:	01 45 fc             	add    %eax,0xfffffffc(%ebp)
    LWIP_DEBUGF(INET_DEBUG, ("inet: chksum: odd byte %d\n", (unsigned int)(*(u8_t *)dataptr)));
  } else {
    LWIP_DEBUGF(INET_DEBUG, ("inet: chksum: no odd byte\n"));
  }
  acc = (acc >> 16) + (acc & 0xffffUL);
  10dbf1:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10dbf4:	89 c2                	mov    %eax,%edx
  10dbf6:	c1 ea 10             	shr    $0x10,%edx
  10dbf9:	0f b7 45 fc          	movzwl 0xfffffffc(%ebp),%eax
  10dbfd:	8d 04 02             	lea    (%edx,%eax,1),%eax
  10dc00:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)

  if ((acc & 0xffff0000) != 0) {
  10dc03:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10dc06:	66 b8 00 00          	mov    $0x0,%ax
  10dc0a:	85 c0                	test   %eax,%eax
  10dc0c:	74 12                	je     10dc20 <lwip_chksum+0x80>
    acc = (acc >> 16) + (acc & 0xffffUL);
  10dc0e:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10dc11:	89 c2                	mov    %eax,%edx
  10dc13:	c1 ea 10             	shr    $0x10,%edx
  10dc16:	0f b7 45 fc          	movzwl 0xfffffffc(%ebp),%eax
  10dc1a:	8d 04 02             	lea    (%edx,%eax,1),%eax
  10dc1d:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  }

  return (u16_t)acc;
  10dc20:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10dc23:	0f b7 c0             	movzwl %ax,%eax
}
  10dc26:	c9                   	leave  
  10dc27:	c3                   	ret    
  10dc28:	90                   	nop    
  10dc29:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

0010dc30 <inet_chksum_pseudo>:

/* inet_chksum_pseudo:
 *
 * Calculates the pseudo Internet checksum used by TCP and UDP for a pbuf chain.
 */

u16_t
inet_chksum_pseudo(struct pbuf *p,
       struct ip_addr *src, struct ip_addr *dest,
       u8_t proto, u16_t proto_len)
{
  10dc30:	55                   	push   %ebp
  10dc31:	89 e5                	mov    %esp,%ebp
  10dc33:	83 ec 28             	sub    $0x28,%esp
  10dc36:	8b 45 14             	mov    0x14(%ebp),%eax
  10dc39:	8b 55 18             	mov    0x18(%ebp),%edx
  10dc3c:	88 45 ec             	mov    %al,0xffffffec(%ebp)
  10dc3f:	66 89 55 e8          	mov    %dx,0xffffffe8(%ebp)
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  10dc43:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
  swapped = 0;
  10dc4a:	c6 45 ff 00          	movb   $0x0,0xffffffff(%ebp)
  /* iterate through all pbuf in chain */
  for(q = p; q != NULL; q = q->next) {
  10dc4e:	8b 45 08             	mov    0x8(%ebp),%eax
  10dc51:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  10dc54:	eb 7b                	jmp    10dcd1 <inet_chksum_pseudo+0xa1>
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
      (void *)q, (void *)q->next));
    acc += lwip_chksum(q->payload, q->len);
  10dc56:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10dc59:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  10dc5d:	0f b7 d0             	movzwl %ax,%edx
  10dc60:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10dc63:	8b 40 04             	mov    0x4(%eax),%eax
  10dc66:	89 54 24 04          	mov    %edx,0x4(%esp)
  10dc6a:	89 04 24             	mov    %eax,(%esp)
  10dc6d:	e8 2e ff ff ff       	call   10dba0 <lwip_chksum>
  10dc72:	0f b7 c0             	movzwl %ax,%eax
  10dc75:	01 45 f4             	add    %eax,0xfffffff4(%ebp)
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%lx \n", acc));*/
    while (acc >> 16) {
  10dc78:	eb 10                	jmp    10dc8a <inet_chksum_pseudo+0x5a>
      acc = (acc & 0xffffUL) + (acc >> 16);
  10dc7a:	0f b7 55 f4          	movzwl 0xfffffff4(%ebp),%edx
  10dc7e:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10dc81:	c1 e8 10             	shr    $0x10,%eax
  10dc84:	8d 04 02             	lea    (%edx,%eax,1),%eax
  10dc87:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  10dc8a:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10dc8d:	c1 e8 10             	shr    $0x10,%eax
  10dc90:	85 c0                	test   %eax,%eax
  10dc92:	75 e6                	jne    10dc7a <inet_chksum_pseudo+0x4a>
    }
    if (q->len % 2 != 0) {
  10dc94:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10dc97:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  10dc9b:	0f b7 c0             	movzwl %ax,%eax
  10dc9e:	83 e0 01             	and    $0x1,%eax
  10dca1:	84 c0                	test   %al,%al
  10dca3:	74 24                	je     10dcc9 <inet_chksum_pseudo+0x99>
      swapped = 1 - swapped;
  10dca5:	b8 01 00 00 00       	mov    $0x1,%eax
  10dcaa:	2a 45 ff             	sub    0xffffffff(%ebp),%al
  10dcad:	88 45 ff             	mov    %al,0xffffffff(%ebp)
      acc = ((acc & 0xff) << 8) | ((acc & 0xff00UL) >> 8);
  10dcb0:	0f b6 45 f4          	movzbl 0xfffffff4(%ebp),%eax
  10dcb4:	89 c2                	mov    %eax,%edx
  10dcb6:	c1 e2 08             	shl    $0x8,%edx
  10dcb9:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10dcbc:	25 00 ff 00 00       	and    $0xff00,%eax
  10dcc1:	c1 e8 08             	shr    $0x8,%eax
  10dcc4:	09 d0                	or     %edx,%eax
  10dcc6:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  10dcc9:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10dccc:	8b 00                	mov    (%eax),%eax
  10dcce:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  10dcd1:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  10dcd5:	0f 85 7b ff ff ff    	jne    10dc56 <inet_chksum_pseudo+0x26>
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%lx \n", acc));*/
  }

  if (swapped) {
  10dcdb:	80 7d ff 00          	cmpb   $0x0,0xffffffff(%ebp)
  10dcdf:	74 19                	je     10dcfa <inet_chksum_pseudo+0xca>
    acc = ((acc & 0xff) << 8) | ((acc & 0xff00UL) >> 8);
  10dce1:	0f b6 45 f4          	movzbl 0xfffffff4(%ebp),%eax
  10dce5:	89 c2                	mov    %eax,%edx
  10dce7:	c1 e2 08             	shl    $0x8,%edx
  10dcea:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10dced:	25 00 ff 00 00       	and    $0xff00,%eax
  10dcf2:	c1 e8 08             	shr    $0x8,%eax
  10dcf5:	09 d0                	or     %edx,%eax
  10dcf7:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  }
  acc += (src->addr & 0xffffUL);
  10dcfa:	8b 45 0c             	mov    0xc(%ebp),%eax
  10dcfd:	8b 00                	mov    (%eax),%eax
  10dcff:	25 ff ff 00 00       	and    $0xffff,%eax
  10dd04:	01 45 f4             	add    %eax,0xfffffff4(%ebp)
  acc += ((src->addr >> 16) & 0xffffUL);
  10dd07:	8b 45 0c             	mov    0xc(%ebp),%eax
  10dd0a:	8b 00                	mov    (%eax),%eax
  10dd0c:	c1 e8 10             	shr    $0x10,%eax
  10dd0f:	25 ff ff 00 00       	and    $0xffff,%eax
  10dd14:	01 45 f4             	add    %eax,0xfffffff4(%ebp)
  acc += (dest->addr & 0xffffUL);
  10dd17:	8b 45 10             	mov    0x10(%ebp),%eax
  10dd1a:	8b 00                	mov    (%eax),%eax
  10dd1c:	25 ff ff 00 00       	and    $0xffff,%eax
  10dd21:	01 45 f4             	add    %eax,0xfffffff4(%ebp)
  acc += ((dest->addr >> 16) & 0xffffUL);
  10dd24:	8b 45 10             	mov    0x10(%ebp),%eax
  10dd27:	8b 00                	mov    (%eax),%eax
  10dd29:	c1 e8 10             	shr    $0x10,%eax
  10dd2c:	25 ff ff 00 00       	and    $0xffff,%eax
  10dd31:	01 45 f4             	add    %eax,0xfffffff4(%ebp)
  acc += (u32_t)htons((u16_t)proto);
  10dd34:	0f b6 45 ec          	movzbl 0xffffffec(%ebp),%eax
  10dd38:	89 04 24             	mov    %eax,(%esp)
  10dd3b:	e8 30 05 00 00       	call   10e270 <htons>
  10dd40:	0f b7 c0             	movzwl %ax,%eax
  10dd43:	01 45 f4             	add    %eax,0xfffffff4(%ebp)
  acc += (u32_t)htons(proto_len);
  10dd46:	0f b7 45 e8          	movzwl 0xffffffe8(%ebp),%eax
  10dd4a:	89 04 24             	mov    %eax,(%esp)
  10dd4d:	e8 1e 05 00 00       	call   10e270 <htons>
  10dd52:	0f b7 c0             	movzwl %ax,%eax
  10dd55:	01 45 f4             	add    %eax,0xfffffff4(%ebp)

  while (acc >> 16) {
  10dd58:	eb 10                	jmp    10dd6a <inet_chksum_pseudo+0x13a>
    acc = (acc & 0xffffUL) + (acc >> 16);
  10dd5a:	0f b7 55 f4          	movzwl 0xfffffff4(%ebp),%edx
  10dd5e:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10dd61:	c1 e8 10             	shr    $0x10,%eax
  10dd64:	8d 04 02             	lea    (%edx,%eax,1),%eax
  10dd67:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  10dd6a:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10dd6d:	c1 e8 10             	shr    $0x10,%eax
  10dd70:	85 c0                	test   %eax,%eax
  10dd72:	75 e6                	jne    10dd5a <inet_chksum_pseudo+0x12a>
  }
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%lx\n", acc));
  return ~(acc & 0xffffUL);
  10dd74:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10dd77:	f7 d0                	not    %eax
  10dd79:	0f b7 c0             	movzwl %ax,%eax
}
  10dd7c:	c9                   	leave  
  10dd7d:	c3                   	ret    
  10dd7e:	89 f6                	mov    %esi,%esi

0010dd80 <inet_chksum>:

/* inet_chksum:
 *
 * Calculates the Internet checksum over a portion of memory. Used primarely for IP
 * and ICMP.
 */

u16_t
inet_chksum(void *dataptr, u16_t len)
{
  10dd80:	55                   	push   %ebp
  10dd81:	89 e5                	mov    %esp,%ebp
  10dd83:	83 ec 28             	sub    $0x28,%esp
  10dd86:	8b 45 0c             	mov    0xc(%ebp),%eax
  10dd89:	66 89 45 ec          	mov    %ax,0xffffffec(%ebp)
  u32_t acc;

  acc = lwip_chksum(dataptr, len);
  10dd8d:	0f b7 45 ec          	movzwl 0xffffffec(%ebp),%eax
  10dd91:	89 44 24 04          	mov    %eax,0x4(%esp)
  10dd95:	8b 45 08             	mov    0x8(%ebp),%eax
  10dd98:	89 04 24             	mov    %eax,(%esp)
  10dd9b:	e8 00 fe ff ff       	call   10dba0 <lwip_chksum>
  10dda0:	0f b7 c0             	movzwl %ax,%eax
  10dda3:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  while (acc >> 16) {
  10dda6:	eb 10                	jmp    10ddb8 <inet_chksum+0x38>
    acc = (acc & 0xffff) + (acc >> 16);
  10dda8:	0f b7 55 fc          	movzwl 0xfffffffc(%ebp),%edx
  10ddac:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10ddaf:	c1 e8 10             	shr    $0x10,%eax
  10ddb2:	8d 04 02             	lea    (%edx,%eax,1),%eax
  10ddb5:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  10ddb8:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10ddbb:	c1 e8 10             	shr    $0x10,%eax
  10ddbe:	85 c0                	test   %eax,%eax
  10ddc0:	75 e6                	jne    10dda8 <inet_chksum+0x28>
  }
  return ~(acc & 0xffff);
  10ddc2:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10ddc5:	f7 d0                	not    %eax
  10ddc7:	0f b7 c0             	movzwl %ax,%eax
}
  10ddca:	c9                   	leave  
  10ddcb:	c3                   	ret    
  10ddcc:	8d 74 26 00          	lea    0x0(%esi),%esi

0010ddd0 <inet_chksum_pbuf>:

u16_t
inet_chksum_pbuf(struct pbuf *p)
{
  10ddd0:	55                   	push   %ebp
  10ddd1:	89 e5                	mov    %esp,%ebp
  10ddd3:	83 ec 18             	sub    $0x18,%esp
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  10ddd6:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
  swapped = 0;
  10dddd:	c6 45 ff 00          	movb   $0x0,0xffffffff(%ebp)
  for(q = p; q != NULL; q = q->next) {
  10dde1:	8b 45 08             	mov    0x8(%ebp),%eax
  10dde4:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  10dde7:	eb 69                	jmp    10de52 <inet_chksum_pbuf+0x82>
    acc += lwip_chksum(q->payload, q->len);
  10dde9:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10ddec:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  10ddf0:	0f b7 d0             	movzwl %ax,%edx
  10ddf3:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10ddf6:	8b 40 04             	mov    0x4(%eax),%eax
  10ddf9:	89 54 24 04          	mov    %edx,0x4(%esp)
  10ddfd:	89 04 24             	mov    %eax,(%esp)
  10de00:	e8 9b fd ff ff       	call   10dba0 <lwip_chksum>
  10de05:	0f b7 c0             	movzwl %ax,%eax
  10de08:	01 45 f4             	add    %eax,0xfffffff4(%ebp)
    while (acc >> 16) {
  10de0b:	eb 10                	jmp    10de1d <inet_chksum_pbuf+0x4d>
      acc = (acc & 0xffffUL) + (acc >> 16);
  10de0d:	0f b7 55 f4          	movzwl 0xfffffff4(%ebp),%edx
  10de11:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10de14:	c1 e8 10             	shr    $0x10,%eax
  10de17:	8d 04 02             	lea    (%edx,%eax,1),%eax
  10de1a:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  10de1d:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10de20:	c1 e8 10             	shr    $0x10,%eax
  10de23:	85 c0                	test   %eax,%eax
  10de25:	75 e6                	jne    10de0d <inet_chksum_pbuf+0x3d>
    }
    if (q->len % 2 != 0) {
  10de27:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10de2a:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  10de2e:	0f b7 c0             	movzwl %ax,%eax
  10de31:	83 e0 01             	and    $0x1,%eax
  10de34:	84 c0                	test   %al,%al
  10de36:	74 12                	je     10de4a <inet_chksum_pbuf+0x7a>
      swapped = 1 - swapped;
  10de38:	b8 01 00 00 00       	mov    $0x1,%eax
  10de3d:	2a 45 ff             	sub    0xffffffff(%ebp),%al
  10de40:	88 45 ff             	mov    %al,0xffffffff(%ebp)
      acc = (acc & 0x00ffUL << 8) | (acc & 0xff00UL >> 8);
  10de43:	81 65 f4 ff ff 00 00 	andl   $0xffff,0xfffffff4(%ebp)
  10de4a:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10de4d:	8b 00                	mov    (%eax),%eax
  10de4f:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  10de52:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  10de56:	75 91                	jne    10dde9 <inet_chksum_pbuf+0x19>
    }
  }

  if (swapped) {
  10de58:	80 7d ff 00          	cmpb   $0x0,0xffffffff(%ebp)
  10de5c:	74 19                	je     10de77 <inet_chksum_pbuf+0xa7>
    acc = ((acc & 0x00ffUL) << 8) | ((acc & 0xff00UL) >> 8);
  10de5e:	0f b6 45 f4          	movzbl 0xfffffff4(%ebp),%eax
  10de62:	89 c2                	mov    %eax,%edx
  10de64:	c1 e2 08             	shl    $0x8,%edx
  10de67:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10de6a:	25 00 ff 00 00       	and    $0xff00,%eax
  10de6f:	c1 e8 08             	shr    $0x8,%eax
  10de72:	09 d0                	or     %edx,%eax
  10de74:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  }
  return ~(acc & 0xffffUL);
  10de77:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10de7a:	f7 d0                	not    %eax
  10de7c:	0f b7 c0             	movzwl %ax,%eax
}
  10de7f:	c9                   	leave  
  10de80:	c3                   	ret    
  10de81:	eb 0d                	jmp    10de90 <inet_addr>
  10de83:	90                   	nop    
  10de84:	90                   	nop    
  10de85:	90                   	nop    
  10de86:	90                   	nop    
  10de87:	90                   	nop    
  10de88:	90                   	nop    
  10de89:	90                   	nop    
  10de8a:	90                   	nop    
  10de8b:	90                   	nop    
  10de8c:	90                   	nop    
  10de8d:	90                   	nop    
  10de8e:	90                   	nop    
  10de8f:	90                   	nop    

0010de90 <inet_addr>:

/* Here for now until needed in other places in lwIP */
#ifndef isascii
#define in_range(c, lo, up)  ((u8_t)c >= lo && (u8_t)c <= up)
#define isascii(c)           in_range(c, 0x20, 0x7f)
#define isdigit(c)           in_range(c, '0', '9')
#define isxdigit(c)          (isdigit(c) || in_range(c, 'a', 'f') || in_range(c, 'A', 'F'))
#define islower(c)           in_range(c, 'a', 'z')
#define isspace(c)           (c == ' ' || c == '\f' || c == '\n' || c == '\r' || c == '\t' || c == '\v')
#endif		
		

 /*
  * Ascii internet address interpretation routine.
  * The value returned is in network order.
  */

 /*  */
 /* inet_addr */
 u32_t inet_addr(const char *cp)
 {
  10de90:	55                   	push   %ebp
  10de91:	89 e5                	mov    %esp,%ebp
  10de93:	83 ec 28             	sub    $0x28,%esp
     struct in_addr val;

     if (inet_aton(cp, &val)) {
  10de96:	8d 45 fc             	lea    0xfffffffc(%ebp),%eax
  10de99:	89 44 24 04          	mov    %eax,0x4(%esp)
  10de9d:	8b 45 08             	mov    0x8(%ebp),%eax
  10dea0:	89 04 24             	mov    %eax,(%esp)
  10dea3:	e8 18 00 00 00       	call   10dec0 <inet_aton>
  10dea8:	85 c0                	test   %eax,%eax
  10deaa:	74 08                	je     10deb4 <inet_addr+0x24>
         return (val.s_addr);
  10deac:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10deaf:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  10deb2:	eb 07                	jmp    10debb <inet_addr+0x2b>
     }
     return (INADDR_NONE);
  10deb4:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  10debb:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
 }
  10debe:	c9                   	leave  
  10debf:	c3                   	ret    

0010dec0 <inet_aton>:

 /*
  * Check whether "cp" is a valid ascii representation
  * of an Internet address and convert to a binary address.
  * Returns 1 if the address is valid, 0 if not.
  * This replaces inet_addr, the return value from which
  * cannot distinguish between failure and a local broadcast address.
  */
 /*  */
 /* inet_aton */
 int inet_aton(const char *cp, struct in_addr *addr)
 {
  10dec0:	55                   	push   %ebp
  10dec1:	89 e5                	mov    %esp,%ebp
  10dec3:	83 ec 48             	sub    $0x48,%esp
     u32_t val;
     int base, n;
     char c;
     u32_t parts[4];
     u32_t* pp = parts;
  10dec6:	8d 45 dc             	lea    0xffffffdc(%ebp),%eax
  10dec9:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)

     c = *cp;
  10decc:	8b 45 08             	mov    0x8(%ebp),%eax
  10decf:	0f b6 00             	movzbl (%eax),%eax
  10ded2:	88 45 fb             	mov    %al,0xfffffffb(%ebp)
     for (;;) {
         /*
          * Collect number up to ``.''.
          * Values are specified as for C:
          * 0x=hex, 0=octal, isdigit=decimal.
          */
         if (!isdigit(c))
  10ded5:	0f b6 45 fb          	movzbl 0xfffffffb(%ebp),%eax
  10ded9:	3c 2f                	cmp    $0x2f,%al
  10dedb:	76 08                	jbe    10dee5 <inet_aton+0x25>
  10dedd:	0f b6 45 fb          	movzbl 0xfffffffb(%ebp),%eax
  10dee1:	3c 39                	cmp    $0x39,%al
  10dee3:	76 0c                	jbe    10def1 <inet_aton+0x31>
             return (0);
  10dee5:	c7 45 c0 00 00 00 00 	movl   $0x0,0xffffffc0(%ebp)
  10deec:	e9 78 02 00 00       	jmp    10e169 <inet_aton+0x2a9>
         val = 0; base = 10;
  10def1:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  10def8:	c7 45 f0 0a 00 00 00 	movl   $0xa,0xfffffff0(%ebp)
         if (c == '0') {
  10deff:	80 7d fb 30          	cmpb   $0x30,0xfffffffb(%ebp)
  10df03:	75 36                	jne    10df3b <inet_aton+0x7b>
             c = *++cp;
  10df05:	83 45 08 01          	addl   $0x1,0x8(%ebp)
  10df09:	8b 45 08             	mov    0x8(%ebp),%eax
  10df0c:	0f b6 00             	movzbl (%eax),%eax
  10df0f:	88 45 fb             	mov    %al,0xfffffffb(%ebp)
             if (c == 'x' || c == 'X')
  10df12:	80 7d fb 78          	cmpb   $0x78,0xfffffffb(%ebp)
  10df16:	74 06                	je     10df1e <inet_aton+0x5e>
  10df18:	80 7d fb 58          	cmpb   $0x58,0xfffffffb(%ebp)
  10df1c:	75 16                	jne    10df34 <inet_aton+0x74>
                 base = 16, c = *++cp;
  10df1e:	c7 45 f0 10 00 00 00 	movl   $0x10,0xfffffff0(%ebp)
  10df25:	83 45 08 01          	addl   $0x1,0x8(%ebp)
  10df29:	8b 45 08             	mov    0x8(%ebp),%eax
  10df2c:	0f b6 00             	movzbl (%eax),%eax
  10df2f:	88 45 fb             	mov    %al,0xfffffffb(%ebp)
  10df32:	eb 07                	jmp    10df3b <inet_aton+0x7b>
             else
                 base = 8;
  10df34:	c7 45 f0 08 00 00 00 	movl   $0x8,0xfffffff0(%ebp)
         }
         for (;;) {
             if (isascii(c) && isdigit(c)) {
  10df3b:	0f b6 45 fb          	movzbl 0xfffffffb(%ebp),%eax
  10df3f:	3c 1f                	cmp    $0x1f,%al
  10df41:	76 3b                	jbe    10df7e <inet_aton+0xbe>
  10df43:	80 7d fb 00          	cmpb   $0x0,0xfffffffb(%ebp)
  10df47:	78 35                	js     10df7e <inet_aton+0xbe>
  10df49:	0f b6 45 fb          	movzbl 0xfffffffb(%ebp),%eax
  10df4d:	3c 2f                	cmp    $0x2f,%al
  10df4f:	76 2d                	jbe    10df7e <inet_aton+0xbe>
  10df51:	0f b6 45 fb          	movzbl 0xfffffffb(%ebp),%eax
  10df55:	3c 39                	cmp    $0x39,%al
  10df57:	77 25                	ja     10df7e <inet_aton+0xbe>
                 val = (val * base) + (c - '0');
  10df59:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10df5c:	89 c2                	mov    %eax,%edx
  10df5e:	0f af 55 ec          	imul   0xffffffec(%ebp),%edx
  10df62:	0f be 45 fb          	movsbl 0xfffffffb(%ebp),%eax
  10df66:	8d 04 02             	lea    (%edx,%eax,1),%eax
  10df69:	83 e8 30             	sub    $0x30,%eax
  10df6c:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
                 c = *++cp;
  10df6f:	83 45 08 01          	addl   $0x1,0x8(%ebp)
  10df73:	8b 45 08             	mov    0x8(%ebp),%eax
  10df76:	0f b6 00             	movzbl (%eax),%eax
  10df79:	88 45 fb             	mov    %al,0xfffffffb(%ebp)
  10df7c:	eb bd                	jmp    10df3b <inet_aton+0x7b>
             } else if (base == 16 && isascii(c) && isxdigit(c)) {
  10df7e:	83 7d f0 10          	cmpl   $0x10,0xfffffff0(%ebp)
  10df82:	0f 85 99 00 00 00    	jne    10e021 <inet_aton+0x161>
  10df88:	0f b6 45 fb          	movzbl 0xfffffffb(%ebp),%eax
  10df8c:	3c 1f                	cmp    $0x1f,%al
  10df8e:	0f 86 8d 00 00 00    	jbe    10e021 <inet_aton+0x161>
  10df94:	80 7d fb 00          	cmpb   $0x0,0xfffffffb(%ebp)
  10df98:	0f 88 83 00 00 00    	js     10e021 <inet_aton+0x161>
  10df9e:	0f b6 45 fb          	movzbl 0xfffffffb(%ebp),%eax
  10dfa2:	3c 2f                	cmp    $0x2f,%al
  10dfa4:	76 08                	jbe    10dfae <inet_aton+0xee>
  10dfa6:	0f b6 45 fb          	movzbl 0xfffffffb(%ebp),%eax
  10dfaa:	3c 39                	cmp    $0x39,%al
  10dfac:	76 20                	jbe    10dfce <inet_aton+0x10e>
  10dfae:	0f b6 45 fb          	movzbl 0xfffffffb(%ebp),%eax
  10dfb2:	3c 60                	cmp    $0x60,%al
  10dfb4:	76 08                	jbe    10dfbe <inet_aton+0xfe>
  10dfb6:	0f b6 45 fb          	movzbl 0xfffffffb(%ebp),%eax
  10dfba:	3c 66                	cmp    $0x66,%al
  10dfbc:	76 10                	jbe    10dfce <inet_aton+0x10e>
  10dfbe:	0f b6 45 fb          	movzbl 0xfffffffb(%ebp),%eax
  10dfc2:	3c 40                	cmp    $0x40,%al
  10dfc4:	76 5b                	jbe    10e021 <inet_aton+0x161>
  10dfc6:	0f b6 45 fb          	movzbl 0xfffffffb(%ebp),%eax
  10dfca:	3c 46                	cmp    $0x46,%al
  10dfcc:	77 53                	ja     10e021 <inet_aton+0x161>
                 val = (val << 4) |
  10dfce:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10dfd1:	89 c2                	mov    %eax,%edx
  10dfd3:	c1 e2 04             	shl    $0x4,%edx
  10dfd6:	89 55 c4             	mov    %edx,0xffffffc4(%ebp)
  10dfd9:	0f be 45 fb          	movsbl 0xfffffffb(%ebp),%eax
  10dfdd:	83 c0 0a             	add    $0xa,%eax
  10dfe0:	89 45 c8             	mov    %eax,0xffffffc8(%ebp)
  10dfe3:	0f b6 45 fb          	movzbl 0xfffffffb(%ebp),%eax
  10dfe7:	3c 60                	cmp    $0x60,%al
  10dfe9:	76 11                	jbe    10dffc <inet_aton+0x13c>
  10dfeb:	0f b6 45 fb          	movzbl 0xfffffffb(%ebp),%eax
  10dfef:	3c 7a                	cmp    $0x7a,%al
  10dff1:	77 09                	ja     10dffc <inet_aton+0x13c>
  10dff3:	c7 45 cc 61 00 00 00 	movl   $0x61,0xffffffcc(%ebp)
  10dffa:	eb 07                	jmp    10e003 <inet_aton+0x143>
  10dffc:	c7 45 cc 41 00 00 00 	movl   $0x41,0xffffffcc(%ebp)
  10e003:	8b 45 c8             	mov    0xffffffc8(%ebp),%eax
  10e006:	2b 45 cc             	sub    0xffffffcc(%ebp),%eax
  10e009:	0b 45 c4             	or     0xffffffc4(%ebp),%eax
  10e00c:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
                     (c + 10 - (islower(c) ? 'a' : 'A'));
                 c = *++cp;
  10e00f:	83 45 08 01          	addl   $0x1,0x8(%ebp)
  10e013:	8b 45 08             	mov    0x8(%ebp),%eax
  10e016:	0f b6 00             	movzbl (%eax),%eax
  10e019:	88 45 fb             	mov    %al,0xfffffffb(%ebp)
             } else
             break;
         }
  10e01c:	e9 1a ff ff ff       	jmp    10df3b <inet_aton+0x7b>
         if (c == '.') {
  10e021:	80 7d fb 2e          	cmpb   $0x2e,0xfffffffb(%ebp)
  10e025:	75 35                	jne    10e05c <inet_aton+0x19c>
             /*
              * Internet format:
              *  a.b.c.d
              *  a.b.c   (with c treated as 16 bits)
              *  a.b (with b treated as 24 bits)
              */
             if (pp >= parts + 3)
  10e027:	8d 45 dc             	lea    0xffffffdc(%ebp),%eax
  10e02a:	83 c0 0c             	add    $0xc,%eax
  10e02d:	3b 45 fc             	cmp    0xfffffffc(%ebp),%eax
  10e030:	77 0c                	ja     10e03e <inet_aton+0x17e>
                 return (0);
  10e032:	c7 45 c0 00 00 00 00 	movl   $0x0,0xffffffc0(%ebp)
  10e039:	e9 2b 01 00 00       	jmp    10e169 <inet_aton+0x2a9>
             *pp++ = val;
  10e03e:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  10e041:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10e044:	89 02                	mov    %eax,(%edx)
  10e046:	83 45 fc 04          	addl   $0x4,0xfffffffc(%ebp)
             c = *++cp;
  10e04a:	83 45 08 01          	addl   $0x1,0x8(%ebp)
  10e04e:	8b 45 08             	mov    0x8(%ebp),%eax
  10e051:	0f b6 00             	movzbl (%eax),%eax
  10e054:	88 45 fb             	mov    %al,0xfffffffb(%ebp)
         } else
             break;
     }
  10e057:	e9 79 fe ff ff       	jmp    10ded5 <inet_aton+0x15>
     /*
      * Check for trailing characters.
      */
     if (c != '\0' && (!isascii(c) || !isspace(c)))
  10e05c:	80 7d fb 00          	cmpb   $0x0,0xfffffffb(%ebp)
  10e060:	74 3e                	je     10e0a0 <inet_aton+0x1e0>
  10e062:	0f b6 45 fb          	movzbl 0xfffffffb(%ebp),%eax
  10e066:	3c 1f                	cmp    $0x1f,%al
  10e068:	76 2a                	jbe    10e094 <inet_aton+0x1d4>
  10e06a:	80 7d fb 00          	cmpb   $0x0,0xfffffffb(%ebp)
  10e06e:	78 24                	js     10e094 <inet_aton+0x1d4>
  10e070:	80 7d fb 20          	cmpb   $0x20,0xfffffffb(%ebp)
  10e074:	74 2a                	je     10e0a0 <inet_aton+0x1e0>
  10e076:	80 7d fb 0c          	cmpb   $0xc,0xfffffffb(%ebp)
  10e07a:	74 24                	je     10e0a0 <inet_aton+0x1e0>
  10e07c:	80 7d fb 0a          	cmpb   $0xa,0xfffffffb(%ebp)
  10e080:	74 1e                	je     10e0a0 <inet_aton+0x1e0>
  10e082:	80 7d fb 0d          	cmpb   $0xd,0xfffffffb(%ebp)
  10e086:	74 18                	je     10e0a0 <inet_aton+0x1e0>
  10e088:	80 7d fb 09          	cmpb   $0x9,0xfffffffb(%ebp)
  10e08c:	74 12                	je     10e0a0 <inet_aton+0x1e0>
  10e08e:	80 7d fb 0b          	cmpb   $0xb,0xfffffffb(%ebp)
  10e092:	74 0c                	je     10e0a0 <inet_aton+0x1e0>
         return (0);
  10e094:	c7 45 c0 00 00 00 00 	movl   $0x0,0xffffffc0(%ebp)
  10e09b:	e9 c9 00 00 00       	jmp    10e169 <inet_aton+0x2a9>
     /*
      * Concoct the address according to
      * the number of parts specified.
      */
     n = pp - parts + 1;
  10e0a0:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  10e0a3:	8d 45 dc             	lea    0xffffffdc(%ebp),%eax
  10e0a6:	89 d1                	mov    %edx,%ecx
  10e0a8:	29 c1                	sub    %eax,%ecx
  10e0aa:	89 c8                	mov    %ecx,%eax
  10e0ac:	c1 f8 02             	sar    $0x2,%eax
  10e0af:	83 c0 01             	add    $0x1,%eax
  10e0b2:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
     switch (n) {
  10e0b5:	83 7d f4 04          	cmpl   $0x4,0xfffffff4(%ebp)
  10e0b9:	0f 87 8b 00 00 00    	ja     10e14a <inet_aton+0x28a>
  10e0bf:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10e0c2:	c1 e0 02             	shl    $0x2,%eax
  10e0c5:	8b 80 c0 ad 11 00    	mov    0x11adc0(%eax),%eax
  10e0cb:	ff e0                	jmp    *%eax

     case 0:
         return (0);     /* initial nondigit */
  10e0cd:	c7 45 c0 00 00 00 00 	movl   $0x0,0xffffffc0(%ebp)
  10e0d4:	e9 90 00 00 00       	jmp    10e169 <inet_aton+0x2a9>

     case 1:             /* a -- 32 bits */
         break;

     case 2:             /* a.b -- 8.24 bits */
         if (val > 0xffffff)
  10e0d9:	81 7d ec ff ff ff 00 	cmpl   $0xffffff,0xffffffec(%ebp)
  10e0e0:	76 09                	jbe    10e0eb <inet_aton+0x22b>
             return (0);
  10e0e2:	c7 45 c0 00 00 00 00 	movl   $0x0,0xffffffc0(%ebp)
  10e0e9:	eb 7e                	jmp    10e169 <inet_aton+0x2a9>
         val |= parts[0] << 24;
  10e0eb:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  10e0ee:	c1 e0 18             	shl    $0x18,%eax
  10e0f1:	09 45 ec             	or     %eax,0xffffffec(%ebp)
         break;
  10e0f4:	eb 54                	jmp    10e14a <inet_aton+0x28a>

     case 3:             /* a.b.c -- 8.8.16 bits */
         if (val > 0xffff)
  10e0f6:	81 7d ec ff ff 00 00 	cmpl   $0xffff,0xffffffec(%ebp)
  10e0fd:	76 09                	jbe    10e108 <inet_aton+0x248>
             return (0);
  10e0ff:	c7 45 c0 00 00 00 00 	movl   $0x0,0xffffffc0(%ebp)
  10e106:	eb 61                	jmp    10e169 <inet_aton+0x2a9>
         val |= (parts[0] << 24) | (parts[1] << 16);
  10e108:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  10e10b:	89 c2                	mov    %eax,%edx
  10e10d:	c1 e2 18             	shl    $0x18,%edx
  10e110:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  10e113:	c1 e0 10             	shl    $0x10,%eax
  10e116:	09 d0                	or     %edx,%eax
  10e118:	09 45 ec             	or     %eax,0xffffffec(%ebp)
         break;
  10e11b:	eb 2d                	jmp    10e14a <inet_aton+0x28a>

     case 4:             /* a.b.c.d -- 8.8.8.8 bits */
         if (val > 0xff)
  10e11d:	81 7d ec ff 00 00 00 	cmpl   $0xff,0xffffffec(%ebp)
  10e124:	76 09                	jbe    10e12f <inet_aton+0x26f>
             return (0);
  10e126:	c7 45 c0 00 00 00 00 	movl   $0x0,0xffffffc0(%ebp)
  10e12d:	eb 3a                	jmp    10e169 <inet_aton+0x2a9>
         val |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);
  10e12f:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  10e132:	89 c2                	mov    %eax,%edx
  10e134:	c1 e2 18             	shl    $0x18,%edx
  10e137:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  10e13a:	c1 e0 10             	shl    $0x10,%eax
  10e13d:	09 c2                	or     %eax,%edx
  10e13f:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
  10e142:	c1 e0 08             	shl    $0x8,%eax
  10e145:	09 d0                	or     %edx,%eax
  10e147:	09 45 ec             	or     %eax,0xffffffec(%ebp)
         break;
     }
     if (addr)
  10e14a:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  10e14e:	74 12                	je     10e162 <inet_aton+0x2a2>
         addr->s_addr = htonl(val);
  10e150:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10e153:	89 04 24             	mov    %eax,(%esp)
  10e156:	e8 65 01 00 00       	call   10e2c0 <htonl>
  10e15b:	89 c2                	mov    %eax,%edx
  10e15d:	8b 45 0c             	mov    0xc(%ebp),%eax
  10e160:	89 10                	mov    %edx,(%eax)
     return (1);
  10e162:	c7 45 c0 01 00 00 00 	movl   $0x1,0xffffffc0(%ebp)
  10e169:	8b 45 c0             	mov    0xffffffc0(%ebp),%eax
 }
  10e16c:	c9                   	leave  
  10e16d:	c3                   	ret    
  10e16e:	89 f6                	mov    %esi,%esi

0010e170 <inet_ntoa>:

/* Convert numeric IP address into decimal dotted ASCII representation.
 * returns ptr to static buffer; not reentrant!
 */
char *inet_ntoa(struct in_addr addr)
{
  10e170:	55                   	push   %ebp
  10e171:	89 e5                	mov    %esp,%ebp
  10e173:	53                   	push   %ebx
  10e174:	83 ec 24             	sub    $0x24,%esp
  static char str[16];
  u32_t s_addr = addr.s_addr;
  10e177:	8b 45 08             	mov    0x8(%ebp),%eax
  10e17a:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  char inv[3];
  char *rp;
  char *ap;
  u8_t rem;
  u8_t n;
  u8_t i;

  rp = str;
  10e17d:	c7 45 f0 bc f8 11 00 	movl   $0x11f8bc,0xfffffff0(%ebp)
  ap = (u8_t *)&s_addr;
  10e184:	8d 45 ec             	lea    0xffffffec(%ebp),%eax
  10e187:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  for(n = 0; n < 4; n++) {
  10e18a:	c6 45 fa 00          	movb   $0x0,0xfffffffa(%ebp)
  10e18e:	e9 af 00 00 00       	jmp    10e242 <inet_ntoa+0xd2>
    i = 0;
  10e193:	c6 45 fb 00          	movb   $0x0,0xfffffffb(%ebp)
    do {
      rem = *ap % (u8_t)10;
  10e197:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10e19a:	0f b6 08             	movzbl (%eax),%ecx
  10e19d:	b8 67 00 00 00       	mov    $0x67,%eax
  10e1a2:	f6 e9                	imul   %cl
  10e1a4:	66 c1 e8 08          	shr    $0x8,%ax
  10e1a8:	89 c2                	mov    %eax,%edx
  10e1aa:	c0 fa 02             	sar    $0x2,%dl
  10e1ad:	89 c8                	mov    %ecx,%eax
  10e1af:	c0 f8 07             	sar    $0x7,%al
  10e1b2:	89 d3                	mov    %edx,%ebx
  10e1b4:	28 c3                	sub    %al,%bl
  10e1b6:	88 5d db             	mov    %bl,0xffffffdb(%ebp)
  10e1b9:	0f b6 45 db          	movzbl 0xffffffdb(%ebp),%eax
  10e1bd:	c1 e0 02             	shl    $0x2,%eax
  10e1c0:	02 45 db             	add    0xffffffdb(%ebp),%al
  10e1c3:	01 c0                	add    %eax,%eax
  10e1c5:	89 ca                	mov    %ecx,%edx
  10e1c7:	28 c2                	sub    %al,%dl
  10e1c9:	88 55 db             	mov    %dl,0xffffffdb(%ebp)
  10e1cc:	0f b6 5d db          	movzbl 0xffffffdb(%ebp),%ebx
  10e1d0:	88 5d f9             	mov    %bl,0xfffffff9(%ebp)
      *ap /= (u8_t)10;
  10e1d3:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10e1d6:	0f b6 08             	movzbl (%eax),%ecx
  10e1d9:	b8 67 00 00 00       	mov    $0x67,%eax
  10e1de:	f6 e9                	imul   %cl
  10e1e0:	66 c1 e8 08          	shr    $0x8,%ax
  10e1e4:	89 c2                	mov    %eax,%edx
  10e1e6:	c0 fa 02             	sar    $0x2,%dl
  10e1e9:	89 c8                	mov    %ecx,%eax
  10e1eb:	c0 f8 07             	sar    $0x7,%al
  10e1ee:	28 c2                	sub    %al,%dl
  10e1f0:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10e1f3:	88 10                	mov    %dl,(%eax)
      inv[i++] = '0' + rem;
  10e1f5:	0f b6 55 fb          	movzbl 0xfffffffb(%ebp),%edx
  10e1f9:	0f b6 45 f9          	movzbl 0xfffffff9(%ebp),%eax
  10e1fd:	83 c0 30             	add    $0x30,%eax
  10e200:	88 44 15 e9          	mov    %al,0xffffffe9(%ebp,%edx,1)
  10e204:	80 45 fb 01          	addb   $0x1,0xfffffffb(%ebp)
    } while(*ap);
  10e208:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10e20b:	0f b6 00             	movzbl (%eax),%eax
  10e20e:	84 c0                	test   %al,%al
  10e210:	75 85                	jne    10e197 <inet_ntoa+0x27>
    while(i--)
  10e212:	eb 12                	jmp    10e226 <inet_ntoa+0xb6>
      *rp++ = inv[i];
  10e214:	0f b6 45 fb          	movzbl 0xfffffffb(%ebp),%eax
  10e218:	0f b6 54 05 e9       	movzbl 0xffffffe9(%ebp,%eax,1),%edx
  10e21d:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10e220:	88 10                	mov    %dl,(%eax)
  10e222:	83 45 f0 01          	addl   $0x1,0xfffffff0(%ebp)
  10e226:	80 6d fb 01          	subb   $0x1,0xfffffffb(%ebp)
  10e22a:	80 7d fb ff          	cmpb   $0xff,0xfffffffb(%ebp)
  10e22e:	75 e4                	jne    10e214 <inet_ntoa+0xa4>
    *rp++ = '.';
  10e230:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10e233:	c6 00 2e             	movb   $0x2e,(%eax)
  10e236:	83 45 f0 01          	addl   $0x1,0xfffffff0(%ebp)
    ap++;
  10e23a:	83 45 f4 01          	addl   $0x1,0xfffffff4(%ebp)
  10e23e:	80 45 fa 01          	addb   $0x1,0xfffffffa(%ebp)
  10e242:	80 7d fa 03          	cmpb   $0x3,0xfffffffa(%ebp)
  10e246:	0f 86 47 ff ff ff    	jbe    10e193 <inet_ntoa+0x23>
  }
  *--rp = 0;
  10e24c:	83 6d f0 01          	subl   $0x1,0xfffffff0(%ebp)
  10e250:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10e253:	c6 00 00             	movb   $0x0,(%eax)
  return str;
  10e256:	b8 bc f8 11 00       	mov    $0x11f8bc,%eax
}
  10e25b:	83 c4 24             	add    $0x24,%esp
  10e25e:	5b                   	pop    %ebx
  10e25f:	5d                   	pop    %ebp
  10e260:	c3                   	ret    
  10e261:	eb 0d                	jmp    10e270 <htons>
  10e263:	90                   	nop    
  10e264:	90                   	nop    
  10e265:	90                   	nop    
  10e266:	90                   	nop    
  10e267:	90                   	nop    
  10e268:	90                   	nop    
  10e269:	90                   	nop    
  10e26a:	90                   	nop    
  10e26b:	90                   	nop    
  10e26c:	90                   	nop    
  10e26d:	90                   	nop    
  10e26e:	90                   	nop    
  10e26f:	90                   	nop    

0010e270 <htons>:


#ifndef BYTE_ORDER
#error BYTE_ORDER is not defined
#endif
#if BYTE_ORDER == LITTLE_ENDIAN

u16_t
htons(u16_t n)
{
  10e270:	55                   	push   %ebp
  10e271:	89 e5                	mov    %esp,%ebp
  10e273:	83 ec 04             	sub    $0x4,%esp
  10e276:	8b 45 08             	mov    0x8(%ebp),%eax
  10e279:	66 89 45 fc          	mov    %ax,0xfffffffc(%ebp)
  return ((n & 0xff) << 8) | ((n & 0xff00) >> 8);
  10e27d:	0f b7 45 fc          	movzwl 0xfffffffc(%ebp),%eax
  10e281:	25 ff 00 00 00       	and    $0xff,%eax
  10e286:	c1 e0 08             	shl    $0x8,%eax
  10e289:	89 c2                	mov    %eax,%edx
  10e28b:	0f b7 45 fc          	movzwl 0xfffffffc(%ebp),%eax
  10e28f:	25 00 ff 00 00       	and    $0xff00,%eax
  10e294:	c1 f8 08             	sar    $0x8,%eax
  10e297:	09 d0                	or     %edx,%eax
  10e299:	0f b7 c0             	movzwl %ax,%eax
}
  10e29c:	c9                   	leave  
  10e29d:	c3                   	ret    
  10e29e:	89 f6                	mov    %esi,%esi

0010e2a0 <ntohs>:

u16_t
ntohs(u16_t n)
{
  10e2a0:	55                   	push   %ebp
  10e2a1:	89 e5                	mov    %esp,%ebp
  10e2a3:	83 ec 08             	sub    $0x8,%esp
  10e2a6:	8b 45 08             	mov    0x8(%ebp),%eax
  10e2a9:	66 89 45 fc          	mov    %ax,0xfffffffc(%ebp)
  return htons(n);
  10e2ad:	0f b7 45 fc          	movzwl 0xfffffffc(%ebp),%eax
  10e2b1:	89 04 24             	mov    %eax,(%esp)
  10e2b4:	e8 b7 ff ff ff       	call   10e270 <htons>
  10e2b9:	0f b7 c0             	movzwl %ax,%eax
}
  10e2bc:	c9                   	leave  
  10e2bd:	c3                   	ret    
  10e2be:	89 f6                	mov    %esi,%esi

0010e2c0 <htonl>:

u32_t
htonl(u32_t n)
{
  10e2c0:	55                   	push   %ebp
  10e2c1:	89 e5                	mov    %esp,%ebp
  return ((n & 0xff) << 24) |
  10e2c3:	0f b6 45 08          	movzbl 0x8(%ebp),%eax
  10e2c7:	89 c2                	mov    %eax,%edx
  10e2c9:	c1 e2 18             	shl    $0x18,%edx
  10e2cc:	8b 45 08             	mov    0x8(%ebp),%eax
  10e2cf:	25 00 ff 00 00       	and    $0xff00,%eax
  10e2d4:	c1 e0 08             	shl    $0x8,%eax
  10e2d7:	09 c2                	or     %eax,%edx
  10e2d9:	8b 45 08             	mov    0x8(%ebp),%eax
  10e2dc:	25 00 00 ff 00       	and    $0xff0000,%eax
  10e2e1:	c1 e8 08             	shr    $0x8,%eax
  10e2e4:	09 c2                	or     %eax,%edx
  10e2e6:	8b 45 08             	mov    0x8(%ebp),%eax
  10e2e9:	25 00 00 00 ff       	and    $0xff000000,%eax
  10e2ee:	c1 e8 18             	shr    $0x18,%eax
  10e2f1:	09 d0                	or     %edx,%eax
    ((n & 0xff00) << 8) |
    ((n & 0xff0000) >> 8) |
    ((n & 0xff000000) >> 24);
}
  10e2f3:	5d                   	pop    %ebp
  10e2f4:	c3                   	ret    
  10e2f5:	8d 74 26 00          	lea    0x0(%esi),%esi
  10e2f9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

0010e300 <ntohl>:

u32_t
ntohl(u32_t n)
{
  10e300:	55                   	push   %ebp
  10e301:	89 e5                	mov    %esp,%ebp
  10e303:	83 ec 04             	sub    $0x4,%esp
  return htonl(n);
  10e306:	8b 45 08             	mov    0x8(%ebp),%eax
  10e309:	89 04 24             	mov    %eax,(%esp)
  10e30c:	e8 af ff ff ff       	call   10e2c0 <htonl>
}
  10e311:	c9                   	leave  
  10e312:	c3                   	ret    
  10e313:	90                   	nop    
  10e314:	90                   	nop    
  10e315:	90                   	nop    
  10e316:	90                   	nop    
  10e317:	90                   	nop    
  10e318:	90                   	nop    
  10e319:	90                   	nop    
  10e31a:	90                   	nop    
  10e31b:	90                   	nop    
  10e31c:	90                   	nop    
  10e31d:	90                   	nop    
  10e31e:	90                   	nop    
  10e31f:	90                   	nop    

0010e320 <plug_holes>:
static sys_sem_t mem_sem;

static void
plug_holes(struct mem *mem)
{
  10e320:	55                   	push   %ebp
  10e321:	89 e5                	mov    %esp,%ebp
  10e323:	53                   	push   %ebx
  10e324:	83 ec 10             	sub    $0x10,%esp
  struct mem *nmem;
  struct mem *pmem;

  LWIP_ASSERT("plug_holes: mem >= ram", (u8_t *)mem >= ram);
  LWIP_ASSERT("plug_holes: mem < ram_end", (u8_t *)mem < (u8_t *)ram_end);
  LWIP_ASSERT("plug_holes: mem->used == 0", mem->used == 0);
  
  /* plug hole forward */
  LWIP_ASSERT("plug_holes: mem->next <= MEM_SIZE", mem->next <= MEM_SIZE);
  
  nmem = (struct mem *)&ram[mem->next];
  10e327:	8b 45 08             	mov    0x8(%ebp),%eax
  10e32a:	8b 00                	mov    (%eax),%eax
  10e32c:	05 00 f9 11 00       	add    $0x11f900,%eax
  10e331:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  if (mem != nmem && nmem->used == 0 && (u8_t *)nmem != (u8_t *)ram_end) {
  10e334:	8b 45 08             	mov    0x8(%ebp),%eax
  10e337:	3b 45 f4             	cmp    0xfffffff4(%ebp),%eax
  10e33a:	74 51                	je     10e38d <plug_holes+0x6d>
  10e33c:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10e33f:	0f b6 40 08          	movzbl 0x8(%eax),%eax
  10e343:	84 c0                	test   %al,%al
  10e345:	75 46                	jne    10e38d <plug_holes+0x6d>
  10e347:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10e34a:	8b 15 e0 f8 11 00    	mov    0x11f8e0,%edx
  10e350:	39 d0                	cmp    %edx,%eax
  10e352:	74 39                	je     10e38d <plug_holes+0x6d>
    if (lfree == nmem) {
  10e354:	a1 10 f9 12 00       	mov    0x12f910,%eax
  10e359:	3b 45 f4             	cmp    0xfffffff4(%ebp),%eax
  10e35c:	75 08                	jne    10e366 <plug_holes+0x46>
      lfree = mem;
  10e35e:	8b 45 08             	mov    0x8(%ebp),%eax
  10e361:	a3 10 f9 12 00       	mov    %eax,0x12f910
    }
    mem->next = nmem->next;
  10e366:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10e369:	8b 10                	mov    (%eax),%edx
  10e36b:	8b 45 08             	mov    0x8(%ebp),%eax
  10e36e:	89 10                	mov    %edx,(%eax)
    ((struct mem *)&ram[nmem->next])->prev = (u8_t *)mem - ram;
  10e370:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10e373:	8b 00                	mov    (%eax),%eax
  10e375:	05 00 f9 11 00       	add    $0x11f900,%eax
  10e37a:	89 c1                	mov    %eax,%ecx
  10e37c:	8b 55 08             	mov    0x8(%ebp),%edx
  10e37f:	b8 00 f9 11 00       	mov    $0x11f900,%eax
  10e384:	89 d3                	mov    %edx,%ebx
  10e386:	29 c3                	sub    %eax,%ebx
  10e388:	89 d8                	mov    %ebx,%eax
  10e38a:	89 41 04             	mov    %eax,0x4(%ecx)
  }

  /* plug hole backward */
  pmem = (struct mem *)&ram[mem->prev];
  10e38d:	8b 45 08             	mov    0x8(%ebp),%eax
  10e390:	8b 40 04             	mov    0x4(%eax),%eax
  10e393:	05 00 f9 11 00       	add    $0x11f900,%eax
  10e398:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  if (pmem != mem && pmem->used == 0) {
  10e39b:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10e39e:	3b 45 08             	cmp    0x8(%ebp),%eax
  10e3a1:	74 44                	je     10e3e7 <plug_holes+0xc7>
  10e3a3:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10e3a6:	0f b6 40 08          	movzbl 0x8(%eax),%eax
  10e3aa:	84 c0                	test   %al,%al
  10e3ac:	75 39                	jne    10e3e7 <plug_holes+0xc7>
    if (lfree == mem) {
  10e3ae:	a1 10 f9 12 00       	mov    0x12f910,%eax
  10e3b3:	3b 45 08             	cmp    0x8(%ebp),%eax
  10e3b6:	75 08                	jne    10e3c0 <plug_holes+0xa0>
      lfree = pmem;
  10e3b8:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10e3bb:	a3 10 f9 12 00       	mov    %eax,0x12f910
    }
    pmem->next = mem->next;
  10e3c0:	8b 45 08             	mov    0x8(%ebp),%eax
  10e3c3:	8b 10                	mov    (%eax),%edx
  10e3c5:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10e3c8:	89 10                	mov    %edx,(%eax)
    ((struct mem *)&ram[mem->next])->prev = (u8_t *)pmem - ram;
  10e3ca:	8b 45 08             	mov    0x8(%ebp),%eax
  10e3cd:	8b 00                	mov    (%eax),%eax
  10e3cf:	05 00 f9 11 00       	add    $0x11f900,%eax
  10e3d4:	89 c1                	mov    %eax,%ecx
  10e3d6:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  10e3d9:	b8 00 f9 11 00       	mov    $0x11f900,%eax
  10e3de:	89 d3                	mov    %edx,%ebx
  10e3e0:	29 c3                	sub    %eax,%ebx
  10e3e2:	89 d8                	mov    %ebx,%eax
  10e3e4:	89 41 04             	mov    %eax,0x4(%ecx)
  }

}
  10e3e7:	83 c4 10             	add    $0x10,%esp
  10e3ea:	5b                   	pop    %ebx
  10e3eb:	5d                   	pop    %ebp
  10e3ec:	c3                   	ret    
  10e3ed:	8d 76 00             	lea    0x0(%esi),%esi

0010e3f0 <mem_init>:
void
mem_init(void)
{
  10e3f0:	55                   	push   %ebp
  10e3f1:	89 e5                	mov    %esp,%ebp
  10e3f3:	83 ec 28             	sub    $0x28,%esp
  struct mem *mem;

  memset(ram, 0, MEM_SIZE);
  10e3f6:	c7 44 24 08 00 00 01 	movl   $0x10000,0x8(%esp)
  10e3fd:	00 
  10e3fe:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  10e405:	00 
  10e406:	c7 04 24 00 f9 11 00 	movl   $0x11f900,(%esp)
  10e40d:	e8 ee 7a ff ff       	call   105f00 <memset>
  mem = (struct mem *)ram;
  10e412:	c7 45 fc 00 f9 11 00 	movl   $0x11f900,0xfffffffc(%ebp)
  mem->next = MEM_SIZE;
  10e419:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10e41c:	c7 00 00 00 01 00    	movl   $0x10000,(%eax)
  mem->prev = 0;
  10e422:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10e425:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  mem->used = 0;
  10e42c:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10e42f:	c6 40 08 00          	movb   $0x0,0x8(%eax)
  ram_end = (struct mem *)&ram[MEM_SIZE];
  10e433:	b8 00 f9 12 00       	mov    $0x12f900,%eax
  10e438:	a3 e0 f8 11 00       	mov    %eax,0x11f8e0
  ram_end->used = 1;
  10e43d:	a1 e0 f8 11 00       	mov    0x11f8e0,%eax
  10e442:	c6 40 08 01          	movb   $0x1,0x8(%eax)
  ram_end->next = MEM_SIZE;
  10e446:	a1 e0 f8 11 00       	mov    0x11f8e0,%eax
  10e44b:	c7 00 00 00 01 00    	movl   $0x10000,(%eax)
  ram_end->prev = MEM_SIZE;
  10e451:	a1 e0 f8 11 00       	mov    0x11f8e0,%eax
  10e456:	c7 40 04 00 00 01 00 	movl   $0x10000,0x4(%eax)

  mem_sem = sys_sem_new(1);
  10e45d:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  10e464:	e8 d7 b8 00 00       	call   119d40 <sys_sem_new>
  10e469:	a3 14 f9 12 00       	mov    %eax,0x12f914

  lfree = (struct mem *)ram;
  10e46e:	b8 00 f9 11 00       	mov    $0x11f900,%eax
  10e473:	a3 10 f9 12 00       	mov    %eax,0x12f910

#if MEM_STATS
  lwip_stats.mem.avail = MEM_SIZE;
  10e478:	c7 05 88 15 14 00 00 	movl   $0x10000,0x141588
  10e47f:	00 01 00 
#endif /* MEM_STATS */
}
  10e482:	c9                   	leave  
  10e483:	c3                   	ret    
  10e484:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  10e48a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

0010e490 <mem_free>:
void
mem_free(void *rmem)
{
  10e490:	55                   	push   %ebp
  10e491:	89 e5                	mov    %esp,%ebp
  10e493:	53                   	push   %ebx
  10e494:	83 ec 14             	sub    $0x14,%esp
  struct mem *mem;

  if (rmem == NULL) {
  10e497:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  10e49b:	75 05                	jne    10e4a2 <mem_free+0x12>
    LWIP_DEBUGF(MEM_DEBUG | DBG_TRACE | 2, ("mem_free(p == NULL) was called.\n"));
    return;
  10e49d:	e9 a3 00 00 00       	jmp    10e545 <mem_free+0xb5>
  }
  
  sys_sem_wait(mem_sem);
  10e4a2:	a1 14 f9 12 00       	mov    0x12f914,%eax
  10e4a7:	89 04 24             	mov    %eax,(%esp)
  10e4aa:	e8 51 19 00 00       	call   10fe00 <sys_sem_wait>

  LWIP_ASSERT("mem_free: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
    (u8_t *)rmem < (u8_t *)ram_end);
  
  if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
  10e4af:	8b 45 08             	mov    0x8(%ebp),%eax
  10e4b2:	3d 00 f9 11 00       	cmp    $0x11f900,%eax
  10e4b7:	72 0d                	jb     10e4c6 <mem_free+0x36>
  10e4b9:	8b 45 08             	mov    0x8(%ebp),%eax
  10e4bc:	8b 15 e0 f8 11 00    	mov    0x11f8e0,%edx
  10e4c2:	39 d0                	cmp    %edx,%eax
  10e4c4:	72 1c                	jb     10e4e2 <mem_free+0x52>
    LWIP_DEBUGF(MEM_DEBUG | 3, ("mem_free: illegal memory\n"));
#if MEM_STATS
    ++lwip_stats.mem.err;
  10e4c6:	a1 94 15 14 00       	mov    0x141594,%eax
  10e4cb:	83 c0 01             	add    $0x1,%eax
  10e4ce:	a3 94 15 14 00       	mov    %eax,0x141594
#endif /* MEM_STATS */
    sys_sem_signal(mem_sem);
  10e4d3:	a1 14 f9 12 00       	mov    0x12f914,%eax
  10e4d8:	89 04 24             	mov    %eax,(%esp)
  10e4db:	e8 e0 b8 00 00       	call   119dc0 <sys_sem_signal>
    return;
  10e4e0:	eb 63                	jmp    10e545 <mem_free+0xb5>
  }
  mem = (struct mem *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  10e4e2:	8b 45 08             	mov    0x8(%ebp),%eax
  10e4e5:	83 e8 0c             	sub    $0xc,%eax
  10e4e8:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)

  LWIP_ASSERT("mem_free: mem->used", mem->used);
  
  mem->used = 0;
  10e4eb:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10e4ee:	c6 40 08 00          	movb   $0x0,0x8(%eax)

  if (mem < lfree) {
  10e4f2:	a1 10 f9 12 00       	mov    0x12f910,%eax
  10e4f7:	39 45 f8             	cmp    %eax,0xfffffff8(%ebp)
  10e4fa:	73 08                	jae    10e504 <mem_free+0x74>
    lfree = mem;
  10e4fc:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10e4ff:	a3 10 f9 12 00       	mov    %eax,0x12f910
  }
  
#if MEM_STATS
  lwip_stats.mem.used -= mem->next - ((u8_t *)mem - ram);
  10e504:	8b 0d 8c 15 14 00    	mov    0x14158c,%ecx
  10e50a:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10e50d:	89 c2                	mov    %eax,%edx
  10e50f:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10e512:	8b 00                	mov    (%eax),%eax
  10e514:	89 d3                	mov    %edx,%ebx
  10e516:	29 c3                	sub    %eax,%ebx
  10e518:	89 d8                	mov    %ebx,%eax
  10e51a:	8d 14 01             	lea    (%ecx,%eax,1),%edx
  10e51d:	b8 00 f9 11 00       	mov    $0x11f900,%eax
  10e522:	89 d1                	mov    %edx,%ecx
  10e524:	29 c1                	sub    %eax,%ecx
  10e526:	89 c8                	mov    %ecx,%eax
  10e528:	a3 8c 15 14 00       	mov    %eax,0x14158c
  
#endif /* MEM_STATS */
  plug_holes(mem);
  10e52d:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10e530:	89 04 24             	mov    %eax,(%esp)
  10e533:	e8 e8 fd ff ff       	call   10e320 <plug_holes>
  sys_sem_signal(mem_sem);
  10e538:	a1 14 f9 12 00       	mov    0x12f914,%eax
  10e53d:	89 04 24             	mov    %eax,(%esp)
  10e540:	e8 7b b8 00 00       	call   119dc0 <sys_sem_signal>
}
  10e545:	83 c4 14             	add    $0x14,%esp
  10e548:	5b                   	pop    %ebx
  10e549:	5d                   	pop    %ebp
  10e54a:	c3                   	ret    
  10e54b:	90                   	nop    
  10e54c:	8d 74 26 00          	lea    0x0(%esi),%esi

0010e550 <mem_reallocm>:
void *
mem_reallocm(void *rmem, mem_size_t newsize)
{
  10e550:	55                   	push   %ebp
  10e551:	89 e5                	mov    %esp,%ebp
  10e553:	83 ec 28             	sub    $0x28,%esp
  void *nmem;
  nmem = mem_malloc(newsize);
  10e556:	8b 45 0c             	mov    0xc(%ebp),%eax
  10e559:	89 04 24             	mov    %eax,(%esp)
  10e55c:	e8 5f 01 00 00       	call   10e6c0 <mem_malloc>
  10e561:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  if (nmem == NULL) {
  10e564:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  10e568:	75 17                	jne    10e581 <mem_reallocm+0x31>
    return mem_realloc(rmem, newsize);
  10e56a:	8b 45 0c             	mov    0xc(%ebp),%eax
  10e56d:	89 44 24 04          	mov    %eax,0x4(%esp)
  10e571:	8b 45 08             	mov    0x8(%ebp),%eax
  10e574:	89 04 24             	mov    %eax,(%esp)
  10e577:	e8 34 00 00 00       	call   10e5b0 <mem_realloc>
  10e57c:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  10e57f:	eb 2a                	jmp    10e5ab <mem_reallocm+0x5b>
  }
  memcpy(nmem, rmem, newsize);
  10e581:	8b 45 0c             	mov    0xc(%ebp),%eax
  10e584:	89 44 24 08          	mov    %eax,0x8(%esp)
  10e588:	8b 45 08             	mov    0x8(%ebp),%eax
  10e58b:	89 44 24 04          	mov    %eax,0x4(%esp)
  10e58f:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10e592:	89 04 24             	mov    %eax,(%esp)
  10e595:	e8 26 79 ff ff       	call   105ec0 <memcpy>
  mem_free(rmem);
  10e59a:	8b 45 08             	mov    0x8(%ebp),%eax
  10e59d:	89 04 24             	mov    %eax,(%esp)
  10e5a0:	e8 eb fe ff ff       	call   10e490 <mem_free>
  return nmem;
  10e5a5:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10e5a8:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  10e5ab:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  10e5ae:	c9                   	leave  
  10e5af:	c3                   	ret    

0010e5b0 <mem_realloc>:

void *
mem_realloc(void *rmem, mem_size_t newsize)
{
  10e5b0:	55                   	push   %ebp
  10e5b1:	89 e5                	mov    %esp,%ebp
  10e5b3:	83 ec 28             	sub    $0x28,%esp
  mem_size_t size;
  mem_size_t ptr, ptr2;
  struct mem *mem, *mem2;

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  if ((newsize % MEM_ALIGNMENT) != 0) {
   newsize += MEM_ALIGNMENT - ((newsize + SIZEOF_STRUCT_MEM) % MEM_ALIGNMENT);
  }
  
  if (newsize > MEM_SIZE) {
  10e5b6:	81 7d 0c 00 00 01 00 	cmpl   $0x10000,0xc(%ebp)
  10e5bd:	76 0c                	jbe    10e5cb <mem_realloc+0x1b>
    return NULL;
  10e5bf:	c7 45 dc 00 00 00 00 	movl   $0x0,0xffffffdc(%ebp)
  10e5c6:	e9 f0 00 00 00       	jmp    10e6bb <mem_realloc+0x10b>
  }
  
  sys_sem_wait(mem_sem);
  10e5cb:	a1 14 f9 12 00       	mov    0x12f914,%eax
  10e5d0:	89 04 24             	mov    %eax,(%esp)
  10e5d3:	e8 28 18 00 00       	call   10fe00 <sys_sem_wait>
  
  LWIP_ASSERT("mem_realloc: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
   (u8_t *)rmem < (u8_t *)ram_end);
  
  if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
  10e5d8:	8b 45 08             	mov    0x8(%ebp),%eax
  10e5db:	3d 00 f9 11 00       	cmp    $0x11f900,%eax
  10e5e0:	72 0d                	jb     10e5ef <mem_realloc+0x3f>
  10e5e2:	8b 45 08             	mov    0x8(%ebp),%eax
  10e5e5:	8b 15 e0 f8 11 00    	mov    0x11f8e0,%edx
  10e5eb:	39 d0                	cmp    %edx,%eax
  10e5ed:	72 0b                	jb     10e5fa <mem_realloc+0x4a>
    LWIP_DEBUGF(MEM_DEBUG | 3, ("mem_realloc: illegal memory\n"));
    return rmem;
  10e5ef:	8b 45 08             	mov    0x8(%ebp),%eax
  10e5f2:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
  10e5f5:	e9 c1 00 00 00       	jmp    10e6bb <mem_realloc+0x10b>
  }
  mem = (struct mem *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  10e5fa:	8b 45 08             	mov    0x8(%ebp),%eax
  10e5fd:	83 e8 0c             	sub    $0xc,%eax
  10e600:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)

  ptr = (u8_t *)mem - ram;
  10e603:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  10e606:	b8 00 f9 11 00       	mov    $0x11f900,%eax
  10e60b:	89 d1                	mov    %edx,%ecx
  10e60d:	29 c1                	sub    %eax,%ecx
  10e60f:	89 c8                	mov    %ecx,%eax
  10e611:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)

  size = mem->next - ptr - SIZEOF_STRUCT_MEM;
  10e614:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10e617:	8b 00                	mov    (%eax),%eax
  10e619:	2b 45 f0             	sub    0xfffffff0(%ebp),%eax
  10e61c:	83 e8 0c             	sub    $0xc,%eax
  10e61f:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
#if MEM_STATS
  lwip_stats.mem.used -= (size - newsize);
  10e622:	8b 0d 8c 15 14 00    	mov    0x14158c,%ecx
  10e628:	8b 55 0c             	mov    0xc(%ebp),%edx
  10e62b:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10e62e:	29 d0                	sub    %edx,%eax
  10e630:	89 ca                	mov    %ecx,%edx
  10e632:	29 c2                	sub    %eax,%edx
  10e634:	89 d0                	mov    %edx,%eax
  10e636:	a3 8c 15 14 00       	mov    %eax,0x14158c
#endif /* MEM_STATS */
  
  if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE < size) {
  10e63b:	8b 45 0c             	mov    0xc(%ebp),%eax
  10e63e:	83 c0 18             	add    $0x18,%eax
  10e641:	3b 45 ec             	cmp    0xffffffec(%ebp),%eax
  10e644:	73 62                	jae    10e6a8 <mem_realloc+0xf8>
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
  10e646:	8b 45 0c             	mov    0xc(%ebp),%eax
  10e649:	03 45 f0             	add    0xfffffff0(%ebp),%eax
  10e64c:	83 c0 0c             	add    $0xc,%eax
  10e64f:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
    mem2 = (struct mem *)&ram[ptr2];
  10e652:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10e655:	05 00 f9 11 00       	add    $0x11f900,%eax
  10e65a:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
    mem2->used = 0;
  10e65d:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10e660:	c6 40 08 00          	movb   $0x0,0x8(%eax)
    mem2->next = mem->next;
  10e664:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10e667:	8b 10                	mov    (%eax),%edx
  10e669:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10e66c:	89 10                	mov    %edx,(%eax)
    mem2->prev = ptr;
  10e66e:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  10e671:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10e674:	89 42 04             	mov    %eax,0x4(%edx)
    mem->next = ptr2;
  10e677:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  10e67a:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10e67d:	89 02                	mov    %eax,(%edx)
    if (mem2->next != MEM_SIZE) {
  10e67f:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10e682:	8b 00                	mov    (%eax),%eax
  10e684:	3d 00 00 01 00       	cmp    $0x10000,%eax
  10e689:	74 12                	je     10e69d <mem_realloc+0xed>
      ((struct mem *)&ram[mem2->next])->prev = ptr2;
  10e68b:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10e68e:	8b 00                	mov    (%eax),%eax
  10e690:	05 00 f9 11 00       	add    $0x11f900,%eax
  10e695:	89 c2                	mov    %eax,%edx
  10e697:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10e69a:	89 42 04             	mov    %eax,0x4(%edx)
    }

    plug_holes(mem2);
  10e69d:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10e6a0:	89 04 24             	mov    %eax,(%esp)
  10e6a3:	e8 78 fc ff ff       	call   10e320 <plug_holes>
  }
  sys_sem_signal(mem_sem);  
  10e6a8:	a1 14 f9 12 00       	mov    0x12f914,%eax
  10e6ad:	89 04 24             	mov    %eax,(%esp)
  10e6b0:	e8 0b b7 00 00       	call   119dc0 <sys_sem_signal>
  return rmem;
  10e6b5:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10e6b8:	89 4d dc             	mov    %ecx,0xffffffdc(%ebp)
  10e6bb:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
}
  10e6be:	c9                   	leave  
  10e6bf:	c3                   	ret    

0010e6c0 <mem_malloc>:
void *
mem_malloc(mem_size_t size)
{
  10e6c0:	55                   	push   %ebp
  10e6c1:	89 e5                	mov    %esp,%ebp
  10e6c3:	83 ec 18             	sub    $0x18,%esp
  mem_size_t ptr, ptr2;
  struct mem *mem, *mem2;

  if (size == 0) {
  10e6c6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  10e6ca:	75 0c                	jne    10e6d8 <mem_malloc+0x18>
    return NULL;
  10e6cc:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  10e6d3:	e9 7b 01 00 00       	jmp    10e853 <mem_malloc+0x193>
  }

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  if ((size % MEM_ALIGNMENT) != 0) {
    size += MEM_ALIGNMENT - ((size + SIZEOF_STRUCT_MEM) % MEM_ALIGNMENT);
  }
  
  if (size > MEM_SIZE) {
  10e6d8:	81 7d 08 00 00 01 00 	cmpl   $0x10000,0x8(%ebp)
  10e6df:	76 0c                	jbe    10e6ed <mem_malloc+0x2d>
    return NULL;
  10e6e1:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  10e6e8:	e9 66 01 00 00       	jmp    10e853 <mem_malloc+0x193>
  }
  
  sys_sem_wait(mem_sem);
  10e6ed:	a1 14 f9 12 00       	mov    0x12f914,%eax
  10e6f2:	89 04 24             	mov    %eax,(%esp)
  10e6f5:	e8 06 17 00 00       	call   10fe00 <sys_sem_wait>

  for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE; ptr = ((struct mem *)&ram[ptr])->next) {
  10e6fa:	a1 10 f9 12 00       	mov    0x12f910,%eax
  10e6ff:	89 c2                	mov    %eax,%edx
  10e701:	b8 00 f9 11 00       	mov    $0x11f900,%eax
  10e706:	89 d1                	mov    %edx,%ecx
  10e708:	29 c1                	sub    %eax,%ecx
  10e70a:	89 c8                	mov    %ecx,%eax
  10e70c:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
  10e70f:	e9 11 01 00 00       	jmp    10e825 <mem_malloc+0x165>
    mem = (struct mem *)&ram[ptr];
  10e714:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10e717:	05 00 f9 11 00       	add    $0x11f900,%eax
  10e71c:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
    if (!mem->used &&
  10e71f:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10e722:	0f b6 40 08          	movzbl 0x8(%eax),%eax
  10e726:	84 c0                	test   %al,%al
  10e728:	0f 85 ea 00 00 00    	jne    10e818 <mem_malloc+0x158>
  10e72e:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10e731:	8b 00                	mov    (%eax),%eax
  10e733:	2b 45 f0             	sub    0xfffffff0(%ebp),%eax
  10e736:	8d 50 f4             	lea    0xfffffff4(%eax),%edx
  10e739:	8b 45 08             	mov    0x8(%ebp),%eax
  10e73c:	83 c0 0c             	add    $0xc,%eax
  10e73f:	39 c2                	cmp    %eax,%edx
  10e741:	0f 82 d1 00 00 00    	jb     10e818 <mem_malloc+0x158>
       mem->next - (ptr + SIZEOF_STRUCT_MEM) >= size + SIZEOF_STRUCT_MEM) {
      ptr2 = ptr + SIZEOF_STRUCT_MEM + size;
  10e747:	8b 45 08             	mov    0x8(%ebp),%eax
  10e74a:	03 45 f0             	add    0xfffffff0(%ebp),%eax
  10e74d:	83 c0 0c             	add    $0xc,%eax
  10e750:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
      mem2 = (struct mem *)&ram[ptr2];
  10e753:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10e756:	05 00 f9 11 00       	add    $0x11f900,%eax
  10e75b:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)

      mem2->prev = ptr;      
  10e75e:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  10e761:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10e764:	89 42 04             	mov    %eax,0x4(%edx)
      mem2->next = mem->next;
  10e767:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10e76a:	8b 10                	mov    (%eax),%edx
  10e76c:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10e76f:	89 10                	mov    %edx,(%eax)
      mem->next = ptr2;      
  10e771:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  10e774:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10e777:	89 02                	mov    %eax,(%edx)
      if (mem2->next != MEM_SIZE) {
  10e779:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10e77c:	8b 00                	mov    (%eax),%eax
  10e77e:	3d 00 00 01 00       	cmp    $0x10000,%eax
  10e783:	74 12                	je     10e797 <mem_malloc+0xd7>
        ((struct mem *)&ram[mem2->next])->prev = ptr2;
  10e785:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10e788:	8b 00                	mov    (%eax),%eax
  10e78a:	05 00 f9 11 00       	add    $0x11f900,%eax
  10e78f:	89 c2                	mov    %eax,%edx
  10e791:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10e794:	89 42 04             	mov    %eax,0x4(%edx)
      }
      
      mem2->used = 0;      
  10e797:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10e79a:	c6 40 08 00          	movb   $0x0,0x8(%eax)
      mem->used = 1;
  10e79e:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10e7a1:	c6 40 08 01          	movb   $0x1,0x8(%eax)
#if MEM_STATS
      lwip_stats.mem.used += (size + SIZEOF_STRUCT_MEM);
  10e7a5:	a1 8c 15 14 00       	mov    0x14158c,%eax
  10e7aa:	03 45 08             	add    0x8(%ebp),%eax
  10e7ad:	83 c0 0c             	add    $0xc,%eax
  10e7b0:	a3 8c 15 14 00       	mov    %eax,0x14158c
      /*      if (lwip_stats.mem.max < lwip_stats.mem.used) {
        lwip_stats.mem.max = lwip_stats.mem.used;
  } */
      if (lwip_stats.mem.max < ptr2) {
  10e7b5:	a1 90 15 14 00       	mov    0x141590,%eax
  10e7ba:	3b 45 f4             	cmp    0xfffffff4(%ebp),%eax
  10e7bd:	73 08                	jae    10e7c7 <mem_malloc+0x107>
        lwip_stats.mem.max = ptr2;
  10e7bf:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10e7c2:	a3 90 15 14 00       	mov    %eax,0x141590
      }      
#endif /* MEM_STATS */

      if (mem == lfree) {
  10e7c7:	a1 10 f9 12 00       	mov    0x12f910,%eax
  10e7cc:	39 45 f8             	cmp    %eax,0xfffffff8(%ebp)
  10e7cf:	75 2f                	jne    10e800 <mem_malloc+0x140>
  /* Find next free block after mem */
        while (lfree->used && lfree != ram_end) {
  10e7d1:	eb 11                	jmp    10e7e4 <mem_malloc+0x124>
    lfree = (struct mem *)&ram[lfree->next];
  10e7d3:	a1 10 f9 12 00       	mov    0x12f910,%eax
  10e7d8:	8b 00                	mov    (%eax),%eax
  10e7da:	05 00 f9 11 00       	add    $0x11f900,%eax
  10e7df:	a3 10 f9 12 00       	mov    %eax,0x12f910
  10e7e4:	a1 10 f9 12 00       	mov    0x12f910,%eax
  10e7e9:	0f b6 40 08          	movzbl 0x8(%eax),%eax
  10e7ed:	84 c0                	test   %al,%al
  10e7ef:	74 0f                	je     10e800 <mem_malloc+0x140>
  10e7f1:	8b 15 10 f9 12 00    	mov    0x12f910,%edx
  10e7f7:	a1 e0 f8 11 00       	mov    0x11f8e0,%eax
  10e7fc:	39 c2                	cmp    %eax,%edx
  10e7fe:	75 d3                	jne    10e7d3 <mem_malloc+0x113>
        }
        LWIP_ASSERT("mem_malloc: !lfree->used", !lfree->used);
      }
      sys_sem_signal(mem_sem);
  10e800:	a1 14 f9 12 00       	mov    0x12f914,%eax
  10e805:	89 04 24             	mov    %eax,(%esp)
  10e808:	e8 b3 b5 00 00       	call   119dc0 <sys_sem_signal>
      LWIP_ASSERT("mem_malloc: allocated memory not above ram_end.",
       (mem_ptr_t)mem + SIZEOF_STRUCT_MEM + size <= (mem_ptr_t)ram_end);
      LWIP_ASSERT("mem_malloc: allocated memory properly aligned.",
       (unsigned long)((u8_t *)mem + SIZEOF_STRUCT_MEM) % MEM_ALIGNMENT == 0);
      return (u8_t *)mem + SIZEOF_STRUCT_MEM;
  10e80d:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10e810:	83 c0 0c             	add    $0xc,%eax
  10e813:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  10e816:	eb 3b                	jmp    10e853 <mem_malloc+0x193>
  10e818:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10e81b:	05 00 f9 11 00       	add    $0x11f900,%eax
  10e820:	8b 00                	mov    (%eax),%eax
  10e822:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
  10e825:	81 7d f0 ff ff 00 00 	cmpl   $0xffff,0xfffffff0(%ebp)
  10e82c:	0f 86 e2 fe ff ff    	jbe    10e714 <mem_malloc+0x54>
    }    
  }
  LWIP_DEBUGF(MEM_DEBUG | 2, ("mem_malloc: could not allocate %d bytes\n", (int)size));
#if MEM_STATS
  ++lwip_stats.mem.err;
  10e832:	a1 94 15 14 00       	mov    0x141594,%eax
  10e837:	83 c0 01             	add    $0x1,%eax
  10e83a:	a3 94 15 14 00       	mov    %eax,0x141594
#endif /* MEM_STATS */  
  sys_sem_signal(mem_sem);
  10e83f:	a1 14 f9 12 00       	mov    0x12f914,%eax
  10e844:	89 04 24             	mov    %eax,(%esp)
  10e847:	e8 74 b5 00 00       	call   119dc0 <sys_sem_signal>
  return NULL;
  10e84c:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  10e853:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  10e856:	c9                   	leave  
  10e857:	c3                   	ret    
  10e858:	90                   	nop    
  10e859:	90                   	nop    
  10e85a:	90                   	nop    
  10e85b:	90                   	nop    
  10e85c:	90                   	nop    
  10e85d:	90                   	nop    
  10e85e:	90                   	nop    
  10e85f:	90                   	nop    

0010e860 <memp_init>:
#endif /* MEMP_SANITY_CHECK*/

void
memp_init(void)
{
  10e860:	55                   	push   %ebp
  10e861:	89 e5                	mov    %esp,%ebp
  10e863:	53                   	push   %ebx
  10e864:	83 ec 14             	sub    $0x14,%esp
  struct memp *m, *memp;
  u16_t i, j;
  u16_t size;
      
#if MEMP_STATS
  for(i = 0; i < MEMP_MAX; ++i) {
  10e867:	66 c7 45 f6 00 00    	movw   $0x0,0xfffffff6(%ebp)
  10e86d:	eb 6a                	jmp    10e8d9 <memp_init+0x79>
    lwip_stats.memp[i].used = lwip_stats.memp[i].max =
  10e86f:	0f b7 5d f6          	movzwl 0xfffffff6(%ebp),%ebx
  10e873:	0f b7 4d f6          	movzwl 0xfffffff6(%ebp),%ecx
  10e877:	0f b7 55 f6          	movzwl 0xfffffff6(%ebp),%edx
  10e87b:	89 d0                	mov    %edx,%eax
  10e87d:	c1 e0 04             	shl    $0x4,%eax
  10e880:	c7 80 a4 15 14 00 00 	movl   $0x0,0x1415a4(%eax)
  10e887:	00 00 00 
  10e88a:	89 d0                	mov    %edx,%eax
  10e88c:	c1 e0 04             	shl    $0x4,%eax
  10e88f:	8b 90 a4 15 14 00    	mov    0x1415a4(%eax),%edx
  10e895:	89 c8                	mov    %ecx,%eax
  10e897:	c1 e0 04             	shl    $0x4,%eax
  10e89a:	89 90 a0 15 14 00    	mov    %edx,0x1415a0(%eax)
  10e8a0:	89 c8                	mov    %ecx,%eax
  10e8a2:	c1 e0 04             	shl    $0x4,%eax
  10e8a5:	8b 90 a0 15 14 00    	mov    0x1415a0(%eax),%edx
  10e8ab:	89 d8                	mov    %ebx,%eax
  10e8ad:	c1 e0 04             	shl    $0x4,%eax
  10e8b0:	89 90 9c 15 14 00    	mov    %edx,0x14159c(%eax)
      lwip_stats.memp[i].err = 0;
    lwip_stats.memp[i].avail = memp_num[i];
  10e8b6:	0f b7 4d f6          	movzwl 0xfffffff6(%ebp),%ecx
  10e8ba:	0f b7 45 f6          	movzwl 0xfffffff6(%ebp),%eax
  10e8be:	0f b7 84 00 16 ae 11 	movzwl 0x11ae16(%eax,%eax,1),%eax
  10e8c5:	00 
  10e8c6:	0f b7 d0             	movzwl %ax,%edx
  10e8c9:	89 c8                	mov    %ecx,%eax
  10e8cb:	c1 e0 04             	shl    $0x4,%eax
  10e8ce:	89 90 98 15 14 00    	mov    %edx,0x141598(%eax)
  10e8d4:	66 83 45 f6 01       	addw   $0x1,0xfffffff6(%ebp)
  10e8d9:	66 83 7d f6 0a       	cmpw   $0xa,0xfffffff6(%ebp)
  10e8de:	76 8f                	jbe    10e86f <memp_init+0xf>
  }
#endif /* MEMP_STATS */

  memp = (struct memp *)&memp_memory[0];
  10e8e0:	c7 45 f0 60 f9 12 00 	movl   $0x12f960,0xfffffff0(%ebp)
  for(i = 0; i < MEMP_MAX; ++i) {
  10e8e7:	66 c7 45 f6 00 00    	movw   $0x0,0xfffffff6(%ebp)
  10e8ed:	e9 9d 00 00 00       	jmp    10e98f <memp_init+0x12f>
    size = MEM_ALIGN_SIZE(memp_sizes[i] + sizeof(struct memp));
  10e8f2:	0f b7 45 f6          	movzwl 0xfffffff6(%ebp),%eax
  10e8f6:	0f b7 84 00 00 ae 11 	movzwl 0x11ae00(%eax,%eax,1),%eax
  10e8fd:	00 
  10e8fe:	83 c0 04             	add    $0x4,%eax
  10e901:	66 89 45 fa          	mov    %ax,0xfffffffa(%ebp)
    if (memp_num[i] > 0) {
  10e905:	0f b7 45 f6          	movzwl 0xfffffff6(%ebp),%eax
  10e909:	0f b7 84 00 16 ae 11 	movzwl 0x11ae16(%eax,%eax,1),%eax
  10e910:	00 
  10e911:	66 85 c0             	test   %ax,%ax
  10e914:	74 65                	je     10e97b <memp_init+0x11b>
      memp_tab[i] = memp;
  10e916:	0f b7 45 f6          	movzwl 0xfffffff6(%ebp),%eax
  10e91a:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
  10e91d:	89 14 85 20 f9 12 00 	mov    %edx,0x12f920(,%eax,4)
      m = memp;
  10e924:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10e927:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
      
      for(j = 0; j < memp_num[i]; ++j) {
  10e92a:	66 c7 45 f8 00 00    	movw   $0x0,0xfffffff8(%ebp)
  10e930:	eb 26                	jmp    10e958 <memp_init+0xf8>
  m->next = (struct memp *)MEM_ALIGN((u8_t *)m + size);
  10e932:	0f b7 45 fa          	movzwl 0xfffffffa(%ebp),%eax
  10e936:	89 c2                	mov    %eax,%edx
  10e938:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10e93b:	8d 04 02             	lea    (%edx,%eax,1),%eax
  10e93e:	89 c2                	mov    %eax,%edx
  10e940:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10e943:	89 10                	mov    %edx,(%eax)
  memp = m;
  10e945:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10e948:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
  m = m->next;
  10e94b:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10e94e:	8b 00                	mov    (%eax),%eax
  10e950:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  10e953:	66 83 45 f8 01       	addw   $0x1,0xfffffff8(%ebp)
  10e958:	0f b7 45 f6          	movzwl 0xfffffff6(%ebp),%eax
  10e95c:	0f b7 84 00 16 ae 11 	movzwl 0x11ae16(%eax,%eax,1),%eax
  10e963:	00 
  10e964:	66 3b 45 f8          	cmp    0xfffffff8(%ebp),%ax
  10e968:	77 c8                	ja     10e932 <memp_init+0xd2>
      }
      memp->next = NULL;
  10e96a:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10e96d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
      memp = m;
  10e973:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10e976:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
  10e979:	eb 0f                	jmp    10e98a <memp_init+0x12a>
    } else {
      memp_tab[i] = NULL;
  10e97b:	0f b7 45 f6          	movzwl 0xfffffff6(%ebp),%eax
  10e97f:	c7 04 85 20 f9 12 00 	movl   $0x0,0x12f920(,%eax,4)
  10e986:	00 00 00 00 
  10e98a:	66 83 45 f6 01       	addw   $0x1,0xfffffff6(%ebp)
  10e98f:	66 83 7d f6 0a       	cmpw   $0xa,0xfffffff6(%ebp)
  10e994:	0f 86 58 ff ff ff    	jbe    10e8f2 <memp_init+0x92>
    }
  }

#if !SYS_LIGHTWEIGHT_PROT
  mutex = sys_sem_new(1);
  10e99a:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  10e9a1:	e8 9a b3 00 00       	call   119d40 <sys_sem_new>
  10e9a6:	a3 94 08 13 00       	mov    %eax,0x130894
#endif

  
}
  10e9ab:	83 c4 14             	add    $0x14,%esp
  10e9ae:	5b                   	pop    %ebx
  10e9af:	5d                   	pop    %ebp
  10e9b0:	c3                   	ret    
  10e9b1:	eb 0d                	jmp    10e9c0 <memp_malloc>
  10e9b3:	90                   	nop    
  10e9b4:	90                   	nop    
  10e9b5:	90                   	nop    
  10e9b6:	90                   	nop    
  10e9b7:	90                   	nop    
  10e9b8:	90                   	nop    
  10e9b9:	90                   	nop    
  10e9ba:	90                   	nop    
  10e9bb:	90                   	nop    
  10e9bc:	90                   	nop    
  10e9bd:	90                   	nop    
  10e9be:	90                   	nop    
  10e9bf:	90                   	nop    

0010e9c0 <memp_malloc>:

void *
memp_malloc(memp_t type)
{
  10e9c0:	55                   	push   %ebp
  10e9c1:	89 e5                	mov    %esp,%ebp
  10e9c3:	83 ec 18             	sub    $0x18,%esp
  struct memp *memp;
  void *mem;
#if SYS_LIGHTWEIGHT_PROT
  SYS_ARCH_DECL_PROTECT(old_level);
#endif
 
  LWIP_ASSERT("memp_malloc: type < MEMP_MAX", type < MEMP_MAX);

#if SYS_LIGHTWEIGHT_PROT
  SYS_ARCH_PROTECT(old_level);
#else /* SYS_LIGHTWEIGHT_PROT */  
  sys_sem_wait(mutex);
  10e9c6:	a1 94 08 13 00       	mov    0x130894,%eax
  10e9cb:	89 04 24             	mov    %eax,(%esp)
  10e9ce:	e8 2d 14 00 00       	call   10fe00 <sys_sem_wait>
#endif /* SYS_LIGHTWEIGHT_PROT */  

  memp = memp_tab[type];
  10e9d3:	8b 45 08             	mov    0x8(%ebp),%eax
  10e9d6:	8b 04 85 20 f9 12 00 	mov    0x12f920(,%eax,4),%eax
  10e9dd:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  
  if (memp != NULL) {    
  10e9e0:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  10e9e4:	0f 84 88 00 00 00    	je     10ea72 <memp_malloc+0xb2>
    memp_tab[type] = memp->next;    
  10e9ea:	8b 55 08             	mov    0x8(%ebp),%edx
  10e9ed:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10e9f0:	8b 00                	mov    (%eax),%eax
  10e9f2:	89 04 95 20 f9 12 00 	mov    %eax,0x12f920(,%edx,4)
    memp->next = NULL;
  10e9f9:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10e9fc:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
#if MEMP_STATS
    ++lwip_stats.memp[type].used;
  10ea02:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10ea05:	89 c8                	mov    %ecx,%eax
  10ea07:	c1 e0 04             	shl    $0x4,%eax
  10ea0a:	8b 80 9c 15 14 00    	mov    0x14159c(%eax),%eax
  10ea10:	8d 50 01             	lea    0x1(%eax),%edx
  10ea13:	89 c8                	mov    %ecx,%eax
  10ea15:	c1 e0 04             	shl    $0x4,%eax
  10ea18:	89 90 9c 15 14 00    	mov    %edx,0x14159c(%eax)
    if (lwip_stats.memp[type].used > lwip_stats.memp[type].max) {
  10ea1e:	8b 45 08             	mov    0x8(%ebp),%eax
  10ea21:	c1 e0 04             	shl    $0x4,%eax
  10ea24:	8b 90 9c 15 14 00    	mov    0x14159c(%eax),%edx
  10ea2a:	8b 45 08             	mov    0x8(%ebp),%eax
  10ea2d:	c1 e0 04             	shl    $0x4,%eax
  10ea30:	8b 80 a0 15 14 00    	mov    0x1415a0(%eax),%eax
  10ea36:	39 c2                	cmp    %eax,%edx
  10ea38:	76 1a                	jbe    10ea54 <memp_malloc+0x94>
      lwip_stats.memp[type].max = lwip_stats.memp[type].used;
  10ea3a:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10ea3d:	8b 45 08             	mov    0x8(%ebp),%eax
  10ea40:	c1 e0 04             	shl    $0x4,%eax
  10ea43:	8b 90 9c 15 14 00    	mov    0x14159c(%eax),%edx
  10ea49:	89 c8                	mov    %ecx,%eax
  10ea4b:	c1 e0 04             	shl    $0x4,%eax
  10ea4e:	89 90 a0 15 14 00    	mov    %edx,0x1415a0(%eax)
    }
#endif /* MEMP_STATS */
#if SYS_LIGHTWEIGHT_PROT
    SYS_ARCH_UNPROTECT(old_level);
#else /* SYS_LIGHTWEIGHT_PROT */
    sys_sem_signal(mutex);
  10ea54:	a1 94 08 13 00       	mov    0x130894,%eax
  10ea59:	89 04 24             	mov    %eax,(%esp)
  10ea5c:	e8 5f b3 00 00       	call   119dc0 <sys_sem_signal>
#endif /* SYS_LIGHTWEIGHT_PROT */  
    LWIP_ASSERT("memp_malloc: memp properly aligned",
     ((mem_ptr_t)MEM_ALIGN((u8_t *)memp + sizeof(struct memp)) % MEM_ALIGNMENT) == 0);

    mem = MEM_ALIGN((u8_t *)memp + sizeof(struct memp));
  10ea61:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10ea64:	83 c0 04             	add    $0x4,%eax
  10ea67:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
    return mem;
  10ea6a:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10ea6d:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  10ea70:	eb 30                	jmp    10eaa2 <memp_malloc+0xe2>
  } else {
    LWIP_DEBUGF(MEMP_DEBUG | 2, ("memp_malloc: out of memory in pool %d\n", type));
#if MEMP_STATS
    ++lwip_stats.memp[type].err;
  10ea72:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10ea75:	89 c8                	mov    %ecx,%eax
  10ea77:	c1 e0 04             	shl    $0x4,%eax
  10ea7a:	8b 80 a4 15 14 00    	mov    0x1415a4(%eax),%eax
  10ea80:	8d 50 01             	lea    0x1(%eax),%edx
  10ea83:	89 c8                	mov    %ecx,%eax
  10ea85:	c1 e0 04             	shl    $0x4,%eax
  10ea88:	89 90 a4 15 14 00    	mov    %edx,0x1415a4(%eax)
#endif /* MEMP_STATS */
#if SYS_LIGHTWEIGHT_PROT
  SYS_ARCH_UNPROTECT(old_level);
#else /* SYS_LIGHTWEIGHT_PROT */
  sys_sem_signal(mutex);
  10ea8e:	a1 94 08 13 00       	mov    0x130894,%eax
  10ea93:	89 04 24             	mov    %eax,(%esp)
  10ea96:	e8 25 b3 00 00       	call   119dc0 <sys_sem_signal>
#endif /* SYS_LIGHTWEIGHT_PROT */  
    return NULL;
  10ea9b:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  10eaa2:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  }
}
  10eaa5:	c9                   	leave  
  10eaa6:	c3                   	ret    
  10eaa7:	89 f6                	mov    %esi,%esi
  10eaa9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

0010eab0 <memp_free>:

void
memp_free(memp_t type, void *mem)
{
  10eab0:	55                   	push   %ebp
  10eab1:	89 e5                	mov    %esp,%ebp
  10eab3:	83 ec 18             	sub    $0x18,%esp
  struct memp *memp;
#if SYS_LIGHTWEIGHT_PROT
  SYS_ARCH_DECL_PROTECT(old_level);
#endif /* SYS_LIGHTWEIGHT_PROT */  

  if (mem == NULL) {
  10eab6:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  10eaba:	74 5b                	je     10eb17 <memp_free+0x67>
    return;
  }
  memp = (struct memp *)((u8_t *)mem - sizeof(struct memp));
  10eabc:	8b 45 0c             	mov    0xc(%ebp),%eax
  10eabf:	83 e8 04             	sub    $0x4,%eax
  10eac2:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)

#if SYS_LIGHTWEIGHT_PROT
    SYS_ARCH_PROTECT(old_level);
#else /* SYS_LIGHTWEIGHT_PROT */  
  sys_sem_wait(mutex);
  10eac5:	a1 94 08 13 00       	mov    0x130894,%eax
  10eaca:	89 04 24             	mov    %eax,(%esp)
  10eacd:	e8 2e 13 00 00       	call   10fe00 <sys_sem_wait>
#endif /* SYS_LIGHTWEIGHT_PROT */  

#if MEMP_STATS
  lwip_stats.memp[type].used--; 
  10ead2:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10ead5:	89 c8                	mov    %ecx,%eax
  10ead7:	c1 e0 04             	shl    $0x4,%eax
  10eada:	8b 80 9c 15 14 00    	mov    0x14159c(%eax),%eax
  10eae0:	8d 50 ff             	lea    0xffffffff(%eax),%edx
  10eae3:	89 c8                	mov    %ecx,%eax
  10eae5:	c1 e0 04             	shl    $0x4,%eax
  10eae8:	89 90 9c 15 14 00    	mov    %edx,0x14159c(%eax)
#endif /* MEMP_STATS */
  
  memp->next = memp_tab[type]; 
  10eaee:	8b 45 08             	mov    0x8(%ebp),%eax
  10eaf1:	8b 14 85 20 f9 12 00 	mov    0x12f920(,%eax,4),%edx
  10eaf8:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10eafb:	89 10                	mov    %edx,(%eax)
  memp_tab[type] = memp;
  10eafd:	8b 55 08             	mov    0x8(%ebp),%edx
  10eb00:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10eb03:	89 04 95 20 f9 12 00 	mov    %eax,0x12f920(,%edx,4)

#if MEMP_SANITY_CHECK
  LWIP_ASSERT("memp sanity", memp_sanity());
#endif  

#if SYS_LIGHTWEIGHT_PROT
  SYS_ARCH_UNPROTECT(old_level);
#else /* SYS_LIGHTWEIGHT_PROT */
  sys_sem_signal(mutex);
  10eb0a:	a1 94 08 13 00       	mov    0x130894,%eax
  10eb0f:	89 04 24             	mov    %eax,(%esp)
  10eb12:	e8 a9 b2 00 00       	call   119dc0 <sys_sem_signal>
#endif /* SYS_LIGHTWEIGHT_PROT */  
}
  10eb17:	c9                   	leave  
  10eb18:	c3                   	ret    
  10eb19:	90                   	nop    
  10eb1a:	90                   	nop    
  10eb1b:	90                   	nop    
  10eb1c:	90                   	nop    
  10eb1d:	90                   	nop    
  10eb1e:	90                   	nop    
  10eb1f:	90                   	nop    

0010eb20 <netif_add>:
  struct ip_addr *gw,
  void *state,
  err_t (* init)(struct netif *netif),
  err_t (* input)(struct pbuf *p, struct netif *netif))
{
  10eb20:	55                   	push   %ebp
  10eb21:	89 e5                	mov    %esp,%ebp
  10eb23:	83 ec 18             	sub    $0x18,%esp
  static int netifnum = 0;

  
#if LWIP_DHCP
  /* netif not under DHCP control by default */
  netif->dhcp = NULL;
#endif
  /* remember netif specific state information data */
  netif->state = state;
  10eb26:	8b 55 08             	mov    0x8(%ebp),%edx
  10eb29:	8b 45 18             	mov    0x18(%ebp),%eax
  10eb2c:	89 42 1c             	mov    %eax,0x1c(%edx)
  netif->num = netifnum++;
  10eb2f:	8b 0d a0 08 13 00    	mov    0x1308a0,%ecx
  10eb35:	89 ca                	mov    %ecx,%edx
  10eb37:	8b 45 08             	mov    0x8(%ebp),%eax
  10eb3a:	88 50 2c             	mov    %dl,0x2c(%eax)
  10eb3d:	8d 41 01             	lea    0x1(%ecx),%eax
  10eb40:	a3 a0 08 13 00       	mov    %eax,0x1308a0
  netif->input = input;
  10eb45:	8b 55 08             	mov    0x8(%ebp),%edx
  10eb48:	8b 45 20             	mov    0x20(%ebp),%eax
  10eb4b:	89 42 10             	mov    %eax,0x10(%edx)

  netif_set_addr(netif, ipaddr, netmask, gw);
  10eb4e:	8b 45 14             	mov    0x14(%ebp),%eax
  10eb51:	89 44 24 0c          	mov    %eax,0xc(%esp)
  10eb55:	8b 45 10             	mov    0x10(%ebp),%eax
  10eb58:	89 44 24 08          	mov    %eax,0x8(%esp)
  10eb5c:	8b 45 0c             	mov    0xc(%ebp),%eax
  10eb5f:	89 44 24 04          	mov    %eax,0x4(%esp)
  10eb63:	8b 45 08             	mov    0x8(%ebp),%eax
  10eb66:	89 04 24             	mov    %eax,(%esp)
  10eb69:	e8 42 00 00 00       	call   10ebb0 <netif_set_addr>

  /* call user specified initialization function for netif */
  if (init(netif) != ERR_OK) {
  10eb6e:	8b 45 08             	mov    0x8(%ebp),%eax
  10eb71:	89 04 24             	mov    %eax,(%esp)
  10eb74:	8b 45 1c             	mov    0x1c(%ebp),%eax
  10eb77:	ff d0                	call   *%eax
  10eb79:	84 c0                	test   %al,%al
  10eb7b:	74 09                	je     10eb86 <netif_add+0x66>
    return NULL;
  10eb7d:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
  10eb84:	eb 18                	jmp    10eb9e <netif_add+0x7e>
  }

  /* add this netif to the list */
  netif->next = netif_list;
  10eb86:	a1 98 08 13 00       	mov    0x130898,%eax
  10eb8b:	8b 55 08             	mov    0x8(%ebp),%edx
  10eb8e:	89 02                	mov    %eax,(%edx)
  netif_list = netif;
  10eb90:	8b 45 08             	mov    0x8(%ebp),%eax
  10eb93:	a3 98 08 13 00       	mov    %eax,0x130898
  LWIP_DEBUGF(NETIF_DEBUG, ("netif: added interface %c%c IP addr ",
    netif->name[0], netif->name[1]));
  ip_addr_debug_print(NETIF_DEBUG, ipaddr);
  LWIP_DEBUGF(NETIF_DEBUG, (" netmask "));
  ip_addr_debug_print(NETIF_DEBUG, netmask);
  LWIP_DEBUGF(NETIF_DEBUG, (" gw "));
  ip_addr_debug_print(NETIF_DEBUG, gw);
  LWIP_DEBUGF(NETIF_DEBUG, ("\n"));
  return netif;
  10eb98:	8b 45 08             	mov    0x8(%ebp),%eax
  10eb9b:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  10eb9e:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
}
  10eba1:	c9                   	leave  
  10eba2:	c3                   	ret    
  10eba3:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  10eba9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

0010ebb0 <netif_set_addr>:

void
netif_set_addr(struct netif *netif,struct ip_addr *ipaddr, struct ip_addr *netmask,
    struct ip_addr *gw)
{
  10ebb0:	55                   	push   %ebp
  10ebb1:	89 e5                	mov    %esp,%ebp
  10ebb3:	83 ec 08             	sub    $0x8,%esp
  netif_set_ipaddr(netif, ipaddr);
  10ebb6:	8b 45 0c             	mov    0xc(%ebp),%eax
  10ebb9:	89 44 24 04          	mov    %eax,0x4(%esp)
  10ebbd:	8b 45 08             	mov    0x8(%ebp),%eax
  10ebc0:	89 04 24             	mov    %eax,(%esp)
  10ebc3:	e8 28 01 00 00       	call   10ecf0 <netif_set_ipaddr>
  netif_set_netmask(netif, netmask);
  10ebc8:	8b 45 10             	mov    0x10(%ebp),%eax
  10ebcb:	89 44 24 04          	mov    %eax,0x4(%esp)
  10ebcf:	8b 45 08             	mov    0x8(%ebp),%eax
  10ebd2:	89 04 24             	mov    %eax,(%esp)
  10ebd5:	e8 16 02 00 00       	call   10edf0 <netif_set_netmask>
  netif_set_gw(netif, gw);
  10ebda:	8b 45 14             	mov    0x14(%ebp),%eax
  10ebdd:	89 44 24 04          	mov    %eax,0x4(%esp)
  10ebe1:	8b 45 08             	mov    0x8(%ebp),%eax
  10ebe4:	89 04 24             	mov    %eax,(%esp)
  10ebe7:	e8 d4 01 00 00       	call   10edc0 <netif_set_gw>
}
  10ebec:	c9                   	leave  
  10ebed:	c3                   	ret    
  10ebee:	89 f6                	mov    %esi,%esi

0010ebf0 <netif_remove>:

void netif_remove(struct netif * netif)
{
  10ebf0:	55                   	push   %ebp
  10ebf1:	89 e5                	mov    %esp,%ebp
  10ebf3:	83 ec 10             	sub    $0x10,%esp
  if ( netif == NULL ) return;
  10ebf6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  10ebfa:	74 5e                	je     10ec5a <netif_remove+0x6a>

  /*  is it the first netif? */
  if (netif_list == netif) {
  10ebfc:	a1 98 08 13 00       	mov    0x130898,%eax
  10ec01:	3b 45 08             	cmp    0x8(%ebp),%eax
  10ec04:	75 0c                	jne    10ec12 <netif_remove+0x22>
    netif_list = netif->next;
  10ec06:	8b 45 08             	mov    0x8(%ebp),%eax
  10ec09:	8b 00                	mov    (%eax),%eax
  10ec0b:	a3 98 08 13 00       	mov    %eax,0x130898
  10ec10:	eb 34                	jmp    10ec46 <netif_remove+0x56>
  }
  else {
    /*  look for netif further down the list */
    struct netif * tmpNetif;
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
  10ec12:	a1 98 08 13 00       	mov    0x130898,%eax
  10ec17:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  10ec1a:	eb 1e                	jmp    10ec3a <netif_remove+0x4a>
      if (tmpNetif->next == netif) {
  10ec1c:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10ec1f:	8b 00                	mov    (%eax),%eax
  10ec21:	3b 45 08             	cmp    0x8(%ebp),%eax
  10ec24:	75 0c                	jne    10ec32 <netif_remove+0x42>
        tmpNetif->next = netif->next;
  10ec26:	8b 45 08             	mov    0x8(%ebp),%eax
  10ec29:	8b 10                	mov    (%eax),%edx
  10ec2b:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10ec2e:	89 10                	mov    %edx,(%eax)
        break;
  10ec30:	eb 0e                	jmp    10ec40 <netif_remove+0x50>
  10ec32:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10ec35:	8b 00                	mov    (%eax),%eax
  10ec37:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  10ec3a:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  10ec3e:	75 dc                	jne    10ec1c <netif_remove+0x2c>
        }
    }
    if (tmpNetif == NULL)
  10ec40:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  10ec44:	74 14                	je     10ec5a <netif_remove+0x6a>
      return; /*  we didn't find any netif today */
  }
  /* this netif is default? */
  if (netif_default == netif)
  10ec46:	a1 9c 08 13 00       	mov    0x13089c,%eax
  10ec4b:	3b 45 08             	cmp    0x8(%ebp),%eax
  10ec4e:	75 0a                	jne    10ec5a <netif_remove+0x6a>
    /* reset default netif */
    netif_default = NULL;
  10ec50:	c7 05 9c 08 13 00 00 	movl   $0x0,0x13089c
  10ec57:	00 00 00 
  LWIP_DEBUGF( NETIF_DEBUG, ("netif_remove: removed netif\n") );
}
  10ec5a:	c9                   	leave  
  10ec5b:	c3                   	ret    
  10ec5c:	8d 74 26 00          	lea    0x0(%esi),%esi

0010ec60 <netif_find>:

struct netif *
netif_find(char *name)
{
  10ec60:	55                   	push   %ebp
  10ec61:	89 e5                	mov    %esp,%ebp
  10ec63:	83 ec 14             	sub    $0x14,%esp
  struct netif *netif;
  u8_t num;

  if (name == NULL) {
  10ec66:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  10ec6a:	75 09                	jne    10ec75 <netif_find+0x15>
    return NULL;
  10ec6c:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  10ec73:	eb 67                	jmp    10ecdc <netif_find+0x7c>
  }

  num = name[2] - '0';
  10ec75:	8b 45 08             	mov    0x8(%ebp),%eax
  10ec78:	83 c0 02             	add    $0x2,%eax
  10ec7b:	0f b6 00             	movzbl (%eax),%eax
  10ec7e:	83 e8 30             	sub    $0x30,%eax
  10ec81:	88 45 ff             	mov    %al,0xffffffff(%ebp)

  for(netif = netif_list; netif != NULL; netif = netif->next) {
  10ec84:	a1 98 08 13 00       	mov    0x130898,%eax
  10ec89:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  10ec8c:	eb 41                	jmp    10eccf <netif_find+0x6f>
    if (num == netif->num &&
  10ec8e:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10ec91:	0f b6 40 2c          	movzbl 0x2c(%eax),%eax
  10ec95:	3a 45 ff             	cmp    0xffffffff(%ebp),%al
  10ec98:	75 2d                	jne    10ecc7 <netif_find+0x67>
  10ec9a:	8b 45 08             	mov    0x8(%ebp),%eax
  10ec9d:	0f b6 10             	movzbl (%eax),%edx
  10eca0:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10eca3:	0f b6 40 2a          	movzbl 0x2a(%eax),%eax
  10eca7:	38 c2                	cmp    %al,%dl
  10eca9:	75 1c                	jne    10ecc7 <netif_find+0x67>
  10ecab:	8b 45 08             	mov    0x8(%ebp),%eax
  10ecae:	83 c0 01             	add    $0x1,%eax
  10ecb1:	0f b6 10             	movzbl (%eax),%edx
  10ecb4:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10ecb7:	0f b6 40 2b          	movzbl 0x2b(%eax),%eax
  10ecbb:	38 c2                	cmp    %al,%dl
  10ecbd:	75 08                	jne    10ecc7 <netif_find+0x67>
       name[0] == netif->name[0] &&
       name[1] == netif->name[1]) {
      LWIP_DEBUGF(NETIF_DEBUG, ("netif_find: found %c%c\n", name[0], name[1]));
      return netif;
  10ecbf:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10ecc2:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  10ecc5:	eb 15                	jmp    10ecdc <netif_find+0x7c>
  10ecc7:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10ecca:	8b 00                	mov    (%eax),%eax
  10eccc:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  10eccf:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  10ecd3:	75 b9                	jne    10ec8e <netif_find+0x2e>
    }
  }
  LWIP_DEBUGF(NETIF_DEBUG, ("netif_find: didn't find %c%c\n", name[0], name[1]));
  return NULL;
  10ecd5:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  10ecdc:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  10ecdf:	c9                   	leave  
  10ece0:	c3                   	ret    
  10ece1:	eb 0d                	jmp    10ecf0 <netif_set_ipaddr>
  10ece3:	90                   	nop    
  10ece4:	90                   	nop    
  10ece5:	90                   	nop    
  10ece6:	90                   	nop    
  10ece7:	90                   	nop    
  10ece8:	90                   	nop    
  10ece9:	90                   	nop    
  10ecea:	90                   	nop    
  10eceb:	90                   	nop    
  10ecec:	90                   	nop    
  10eced:	90                   	nop    
  10ecee:	90                   	nop    
  10ecef:	90                   	nop    

0010ecf0 <netif_set_ipaddr>:

void
netif_set_ipaddr(struct netif *netif, struct ip_addr *ipaddr)
{
  10ecf0:	55                   	push   %ebp
  10ecf1:	89 e5                	mov    %esp,%ebp
  10ecf3:	83 ec 28             	sub    $0x28,%esp
  /* TODO: Handling of obsolete pcbs */
  /* See:  http://mail.gnu.org/archive/html/lwip-users/2003-03/msg00118.html */
#if LWIP_TCP
  struct tcp_pcb *pcb;
  struct tcp_pcb_listen *lpcb;

  /* address is actually being changed? */
  if ((ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0)
  10ecf6:	8b 45 0c             	mov    0xc(%ebp),%eax
  10ecf9:	8b 10                	mov    (%eax),%edx
  10ecfb:	8b 45 08             	mov    0x8(%ebp),%eax
  10ecfe:	8b 40 04             	mov    0x4(%eax),%eax
  10ed01:	39 c2                	cmp    %eax,%edx
  10ed03:	0f 84 8b 00 00 00    	je     10ed94 <netif_set_ipaddr+0xa4>
  {
    /* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
    LWIP_DEBUGF(NETIF_DEBUG | 1, ("netif_set_ipaddr: netif address being changed\n"));
    pcb = tcp_active_pcbs;
  10ed09:	a1 54 16 14 00       	mov    0x141654,%eax
  10ed0e:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
    while (pcb != NULL) {
  10ed11:	eb 34                	jmp    10ed47 <netif_set_ipaddr+0x57>
      /* PCB bound to current local interface address? */
      if (ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
  10ed13:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10ed16:	8b 10                	mov    (%eax),%edx
  10ed18:	8b 45 08             	mov    0x8(%ebp),%eax
  10ed1b:	8b 40 04             	mov    0x4(%eax),%eax
  10ed1e:	39 c2                	cmp    %eax,%edx
  10ed20:	75 1c                	jne    10ed3e <netif_set_ipaddr+0x4e>
        /* this connection must be aborted */
        struct tcp_pcb *next = pcb->next;
  10ed22:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10ed25:	8b 40 0c             	mov    0xc(%eax),%eax
  10ed28:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
        LWIP_DEBUGF(NETIF_DEBUG | 1, ("netif_set_ipaddr: aborting TCP pcb %p\n", (void *)pcb));
        tcp_abort(pcb);
  10ed2b:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10ed2e:	89 04 24             	mov    %eax,(%esp)
  10ed31:	e8 0a 16 00 00       	call   110340 <tcp_abort>
        pcb = next;
  10ed36:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10ed39:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  10ed3c:	eb 09                	jmp    10ed47 <netif_set_ipaddr+0x57>
      } else {
        pcb = pcb->next;
  10ed3e:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10ed41:	8b 40 0c             	mov    0xc(%eax),%eax
  10ed44:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  10ed47:	83 7d f4 00          	cmpl   $0x0,0xfffffff4(%ebp)
  10ed4b:	75 c6                	jne    10ed13 <netif_set_ipaddr+0x23>
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  10ed4d:	a1 5c 16 14 00       	mov    0x14165c,%eax
  10ed52:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  10ed55:	eb 37                	jmp    10ed8e <netif_set_ipaddr+0x9e>
      /* PCB bound to current local interface address? */
      if (ip_addr_cmp(&(lpcb->local_ip), &(netif->ip_addr))) {
  10ed57:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10ed5a:	8b 10                	mov    (%eax),%edx
  10ed5c:	8b 45 08             	mov    0x8(%ebp),%eax
  10ed5f:	8b 40 04             	mov    0x4(%eax),%eax
  10ed62:	39 c2                	cmp    %eax,%edx
  10ed64:	75 1f                	jne    10ed85 <netif_set_ipaddr+0x95>
        /* The PCB is listening to the old ipaddr and
         * is set to listen to the new one instead */
        ip_addr_set(&(lpcb->local_ip), ipaddr);
  10ed66:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  10ed6a:	74 0a                	je     10ed76 <netif_set_ipaddr+0x86>
  10ed6c:	8b 45 0c             	mov    0xc(%ebp),%eax
  10ed6f:	8b 00                	mov    (%eax),%eax
  10ed71:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
  10ed74:	eb 07                	jmp    10ed7d <netif_set_ipaddr+0x8d>
  10ed76:	c7 45 e8 00 00 00 00 	movl   $0x0,0xffffffe8(%ebp)
  10ed7d:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10ed80:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
  10ed83:	89 10                	mov    %edx,(%eax)
  10ed85:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10ed88:	8b 40 0c             	mov    0xc(%eax),%eax
  10ed8b:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  10ed8e:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  10ed92:	75 c3                	jne    10ed57 <netif_set_ipaddr+0x67>
      }
    }
  }
#endif
  ip_addr_set(&(netif->ip_addr), ipaddr);
  10ed94:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  10ed98:	74 0a                	je     10eda4 <netif_set_ipaddr+0xb4>
  10ed9a:	8b 45 0c             	mov    0xc(%ebp),%eax
  10ed9d:	8b 00                	mov    (%eax),%eax
  10ed9f:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  10eda2:	eb 07                	jmp    10edab <netif_set_ipaddr+0xbb>
  10eda4:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  10edab:	8b 45 08             	mov    0x8(%ebp),%eax
  10edae:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
  10edb1:	89 50 04             	mov    %edx,0x4(%eax)
  LWIP_DEBUGF(NETIF_DEBUG | DBG_TRACE | DBG_STATE | 3, ("netif: IP address of interface %c%c set to %u.%u.%u.%u\n",
    netif->name[0], netif->name[1],
    (unsigned int)(ntohl(netif->ip_addr.addr) >> 24 & 0xff),
    (unsigned int)(ntohl(netif->ip_addr.addr) >> 16 & 0xff),
    (unsigned int)(ntohl(netif->ip_addr.addr) >> 8 & 0xff),
    (unsigned int)(ntohl(netif->ip_addr.addr) & 0xff)));
}
  10edb4:	c9                   	leave  
  10edb5:	c3                   	ret    
  10edb6:	8d 76 00             	lea    0x0(%esi),%esi
  10edb9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

0010edc0 <netif_set_gw>:

void
netif_set_gw(struct netif *netif, struct ip_addr *gw)
{
  10edc0:	55                   	push   %ebp
  10edc1:	89 e5                	mov    %esp,%ebp
  10edc3:	83 ec 04             	sub    $0x4,%esp
  ip_addr_set(&(netif->gw), gw);
  10edc6:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  10edca:	74 0a                	je     10edd6 <netif_set_gw+0x16>
  10edcc:	8b 45 0c             	mov    0xc(%ebp),%eax
  10edcf:	8b 00                	mov    (%eax),%eax
  10edd1:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  10edd4:	eb 07                	jmp    10eddd <netif_set_gw+0x1d>
  10edd6:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
  10eddd:	8b 45 08             	mov    0x8(%ebp),%eax
  10ede0:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  10ede3:	89 50 0c             	mov    %edx,0xc(%eax)
  LWIP_DEBUGF(NETIF_DEBUG | DBG_TRACE | DBG_STATE | 3, ("netif: GW address of interface %c%c set to %u.%u.%u.%u\n",
           netif->name[0], netif->name[1],
           (unsigned int)(ntohl(netif->gw.addr) >> 24 & 0xff),
           (unsigned int)(ntohl(netif->gw.addr) >> 16 & 0xff),
           (unsigned int)(ntohl(netif->gw.addr) >> 8 & 0xff),
           (unsigned int)(ntohl(netif->gw.addr) & 0xff)));
}
  10ede6:	c9                   	leave  
  10ede7:	c3                   	ret    
  10ede8:	90                   	nop    
  10ede9:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

0010edf0 <netif_set_netmask>:

void
netif_set_netmask(struct netif *netif, struct ip_addr *netmask)
{
  10edf0:	55                   	push   %ebp
  10edf1:	89 e5                	mov    %esp,%ebp
  10edf3:	83 ec 04             	sub    $0x4,%esp
  ip_addr_set(&(netif->netmask), netmask);
  10edf6:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  10edfa:	74 0a                	je     10ee06 <netif_set_netmask+0x16>
  10edfc:	8b 45 0c             	mov    0xc(%ebp),%eax
  10edff:	8b 00                	mov    (%eax),%eax
  10ee01:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  10ee04:	eb 07                	jmp    10ee0d <netif_set_netmask+0x1d>
  10ee06:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
  10ee0d:	8b 45 08             	mov    0x8(%ebp),%eax
  10ee10:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  10ee13:	89 50 08             	mov    %edx,0x8(%eax)
  LWIP_DEBUGF(NETIF_DEBUG | DBG_TRACE | DBG_STATE | 3, ("netif: netmask of interface %c%c set to %u.%u.%u.%u\n",
           netif->name[0], netif->name[1],
           (unsigned int)(ntohl(netif->netmask.addr) >> 24 & 0xff),
           (unsigned int)(ntohl(netif->netmask.addr) >> 16 & 0xff),
           (unsigned int)(ntohl(netif->netmask.addr) >> 8 & 0xff),
           (unsigned int)(ntohl(netif->netmask.addr) & 0xff)));
}
  10ee16:	c9                   	leave  
  10ee17:	c3                   	ret    
  10ee18:	90                   	nop    
  10ee19:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

0010ee20 <netif_set_default>:

void
netif_set_default(struct netif *netif)
{
  10ee20:	55                   	push   %ebp
  10ee21:	89 e5                	mov    %esp,%ebp
  netif_default = netif;
  10ee23:	8b 45 08             	mov    0x8(%ebp),%eax
  10ee26:	a3 9c 08 13 00       	mov    %eax,0x13089c
  LWIP_DEBUGF(NETIF_DEBUG, ("netif: setting default interface %c%c\n",
           netif ? netif->name[0] : '\'', netif ? netif->name[1] : '\''));
}
  10ee2b:	5d                   	pop    %ebp
  10ee2c:	c3                   	ret    
  10ee2d:	8d 76 00             	lea    0x0(%esi),%esi

0010ee30 <netif_init>:

void
netif_init(void)
{
  10ee30:	55                   	push   %ebp
  10ee31:	89 e5                	mov    %esp,%ebp
  netif_list = netif_default = NULL;
  10ee33:	c7 05 9c 08 13 00 00 	movl   $0x0,0x13089c
  10ee3a:	00 00 00 
  10ee3d:	a1 9c 08 13 00       	mov    0x13089c,%eax
  10ee42:	a3 98 08 13 00       	mov    %eax,0x130898
}
  10ee47:	5d                   	pop    %ebp
  10ee48:	c3                   	ret    
  10ee49:	90                   	nop    
  10ee4a:	90                   	nop    
  10ee4b:	90                   	nop    
  10ee4c:	90                   	nop    
  10ee4d:	90                   	nop    
  10ee4e:	90                   	nop    
  10ee4f:	90                   	nop    

0010ee50 <pbuf_init>:
 *
 */
void
pbuf_init(void)
{
  10ee50:	55                   	push   %ebp
  10ee51:	89 e5                	mov    %esp,%ebp
  10ee53:	83 ec 18             	sub    $0x18,%esp
  struct pbuf *p, *q = NULL;
  10ee56:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)
  u16_t i;

  pbuf_pool = (struct pbuf *)&pbuf_pool_memory[0];
  10ee5d:	b8 e0 08 13 00       	mov    $0x1308e0,%eax
  10ee62:	a3 c0 08 13 00       	mov    %eax,0x1308c0
  LWIP_ASSERT("pbuf_init: pool aligned", (mem_ptr_t)pbuf_pool % MEM_ALIGNMENT == 0);

#if PBUF_STATS
  lwip_stats.pbuf.avail = PBUF_POOL_SIZE;
  10ee67:	66 c7 05 7c 15 14 00 	movw   $0x100,0x14157c
  10ee6e:	00 01 
#endif /* PBUF_STATS */

  /* Set up ->next pointers to link the pbufs of the pool together */
  p = pbuf_pool;
  10ee70:	a1 c0 08 13 00       	mov    0x1308c0,%eax
  10ee75:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)

  for(i = 0; i < PBUF_POOL_SIZE; ++i) {
  10ee78:	66 c7 45 fe 00 00    	movw   $0x0,0xfffffffe(%ebp)
  10ee7e:	eb 50                	jmp    10eed0 <pbuf_init+0x80>
    p->next = (struct pbuf *)((u8_t *)p + PBUF_POOL_BUFSIZE + sizeof(struct pbuf));
  10ee80:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10ee83:	05 90 00 00 00       	add    $0x90,%eax
  10ee88:	89 c2                	mov    %eax,%edx
  10ee8a:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10ee8d:	89 10                	mov    %edx,(%eax)
    p->len = p->tot_len = PBUF_POOL_BUFSIZE;
  10ee8f:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10ee92:	66 c7 40 08 80 00    	movw   $0x80,0x8(%eax)
  10ee98:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10ee9b:	0f b7 50 08          	movzwl 0x8(%eax),%edx
  10ee9f:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10eea2:	66 89 50 0a          	mov    %dx,0xa(%eax)
    p->payload = MEM_ALIGN((void *)((u8_t *)p + sizeof(struct pbuf)));
  10eea6:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10eea9:	83 c0 10             	add    $0x10,%eax
  10eeac:	89 c2                	mov    %eax,%edx
  10eeae:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10eeb1:	89 50 04             	mov    %edx,0x4(%eax)
    p->flags = PBUF_FLAG_POOL;
  10eeb4:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10eeb7:	66 c7 40 0c 02 00    	movw   $0x2,0xc(%eax)
    q = p;
  10eebd:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10eec0:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
    p = p->next;
  10eec3:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10eec6:	8b 00                	mov    (%eax),%eax
  10eec8:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  10eecb:	66 83 45 fe 01       	addw   $0x1,0xfffffffe(%ebp)
  10eed0:	66 81 7d fe ff 00    	cmpw   $0xff,0xfffffffe(%ebp)
  10eed6:	76 a8                	jbe    10ee80 <pbuf_init+0x30>
  }

  /* The ->next pointer of last pbuf is NULL to indicate that there
     are no more pbufs in the pool */
  q->next = NULL;
  10eed8:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10eedb:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

#if !SYS_LIGHTWEIGHT_PROT
  pbuf_pool_alloc_lock = 0;
  10eee1:	c6 05 e1 98 13 00 00 	movb   $0x0,0x1398e1
  pbuf_pool_free_lock = 0;
  10eee8:	c6 05 e0 98 13 00 00 	movb   $0x0,0x1398e0
  pbuf_pool_free_sem = sys_sem_new(1);
  10eeef:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  10eef6:	e8 45 ae 00 00       	call   119d40 <sys_sem_new>
  10eefb:	a3 e4 98 13 00       	mov    %eax,0x1398e4
#endif
}
  10ef00:	c9                   	leave  
  10ef01:	c3                   	ret    
  10ef02:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi
  10ef09:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

0010ef10 <pbuf_pool_alloc>:

/**
 * @internal only called from pbuf_alloc()
 */
static struct pbuf *
pbuf_pool_alloc(void)
{
  10ef10:	55                   	push   %ebp
  10ef11:	89 e5                	mov    %esp,%ebp
  10ef13:	83 ec 14             	sub    $0x14,%esp
  struct pbuf *p = NULL;
  10ef16:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)

  SYS_ARCH_DECL_PROTECT(old_level);
  SYS_ARCH_PROTECT(old_level);

#if !SYS_LIGHTWEIGHT_PROT
  /* Next, check the actual pbuf pool, but if the pool is locked, we
     pretend to be out of buffers and return NULL. */
  if (pbuf_pool_free_lock) {
  10ef1d:	0f b6 05 e0 98 13 00 	movzbl 0x1398e0,%eax
  10ef24:	84 c0                	test   %al,%al
  10ef26:	74 19                	je     10ef41 <pbuf_pool_alloc+0x31>
#if PBUF_STATS
    ++lwip_stats.pbuf.alloc_locked;
  10ef28:	0f b7 05 84 15 14 00 	movzwl 0x141584,%eax
  10ef2f:	83 c0 01             	add    $0x1,%eax
  10ef32:	66 a3 84 15 14 00    	mov    %ax,0x141584
#endif /* PBUF_STATS */
    return NULL;
  10ef38:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  10ef3f:	eb 7f                	jmp    10efc0 <pbuf_pool_alloc+0xb0>
  }
  pbuf_pool_alloc_lock = 1;
  10ef41:	c6 05 e1 98 13 00 01 	movb   $0x1,0x1398e1
  if (!pbuf_pool_free_lock) {
  10ef48:	0f b6 05 e0 98 13 00 	movzbl 0x1398e0,%eax
  10ef4f:	84 c0                	test   %al,%al
  10ef51:	75 1a                	jne    10ef6d <pbuf_pool_alloc+0x5d>
#endif /* SYS_LIGHTWEIGHT_PROT */
    p = pbuf_pool;
  10ef53:	a1 c0 08 13 00       	mov    0x1308c0,%eax
  10ef58:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
    if (p) {
  10ef5b:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  10ef5f:	74 1c                	je     10ef7d <pbuf_pool_alloc+0x6d>
      pbuf_pool = p->next;
  10ef61:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10ef64:	8b 00                	mov    (%eax),%eax
  10ef66:	a3 c0 08 13 00       	mov    %eax,0x1308c0
  10ef6b:	eb 10                	jmp    10ef7d <pbuf_pool_alloc+0x6d>
    }
#if !SYS_LIGHTWEIGHT_PROT
#if PBUF_STATS
  } else {
    ++lwip_stats.pbuf.alloc_locked;
  10ef6d:	0f b7 05 84 15 14 00 	movzwl 0x141584,%eax
  10ef74:	83 c0 01             	add    $0x1,%eax
  10ef77:	66 a3 84 15 14 00    	mov    %ax,0x141584
#endif /* PBUF_STATS */
  }
  pbuf_pool_alloc_lock = 0;
  10ef7d:	c6 05 e1 98 13 00 00 	movb   $0x0,0x1398e1
#endif /* SYS_LIGHTWEIGHT_PROT */

#if PBUF_STATS
  if (p != NULL) {
  10ef84:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  10ef88:	74 30                	je     10efba <pbuf_pool_alloc+0xaa>
    ++lwip_stats.pbuf.used;
  10ef8a:	0f b7 05 7e 15 14 00 	movzwl 0x14157e,%eax
  10ef91:	83 c0 01             	add    $0x1,%eax
  10ef94:	66 a3 7e 15 14 00    	mov    %ax,0x14157e
    if (lwip_stats.pbuf.used > lwip_stats.pbuf.max) {
  10ef9a:	0f b7 15 7e 15 14 00 	movzwl 0x14157e,%edx
  10efa1:	0f b7 05 80 15 14 00 	movzwl 0x141580,%eax
  10efa8:	66 39 c2             	cmp    %ax,%dx
  10efab:	76 0d                	jbe    10efba <pbuf_pool_alloc+0xaa>
      lwip_stats.pbuf.max = lwip_stats.pbuf.used;
  10efad:	0f b7 05 7e 15 14 00 	movzwl 0x14157e,%eax
  10efb4:	66 a3 80 15 14 00    	mov    %ax,0x141580
    }
  }
#endif /* PBUF_STATS */

  SYS_ARCH_UNPROTECT(old_level);
  return p;
  10efba:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10efbd:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  10efc0:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  10efc3:	c9                   	leave  
  10efc4:	c3                   	ret    
  10efc5:	8d 74 26 00          	lea    0x0(%esi),%esi
  10efc9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

0010efd0 <pbuf_alloc>:


/**
 * Allocates a pbuf.
 *
 * The actual memory allocated for the pbuf is determined by the
 * layer at which the pbuf is allocated and the requested size
 * (from the size parameter).
 *
 * @param flag this parameter decides how and where the pbuf
 * should be allocated as follows:
 *
 * - PBUF_RAM: buffer memory for pbuf is allocated as one large
 *             chunk. This includes protocol headers as well.
 * - PBUF_ROM: no buffer memory is allocated for the pbuf, even for
 *             protocol headers. Additional headers must be prepended
 *             by allocating another pbuf and chain in to the front of
 *             the ROM pbuf. It is assumed that the memory used is really
 *             similar to ROM in that it is immutable and will not be
 *             changed. Memory which is dynamic should generally not
 *             be attached to PBUF_ROM pbufs. Use PBUF_REF instead.
 * - PBUF_REF: no buffer memory is allocated for the pbuf, even for
 *             protocol headers. It is assumed that the pbuf is only
 *             being used in a single thread. If the pbuf gets queued,
 *             then pbuf_take should be called to copy the buffer.
 * - PBUF_POOL: the pbuf is allocated as a pbuf chain, with pbufs from
 *              the pbuf pool that is allocated during pbuf_init().
 *
 * @return the allocated pbuf. If multiple pbufs where allocated, this
 * is the first pbuf of a pbuf chain.
 */
struct pbuf *
pbuf_alloc(pbuf_layer l, u16_t length, pbuf_flag flag)
{
  10efd0:	55                   	push   %ebp
  10efd1:	89 e5                	mov    %esp,%ebp
  10efd3:	53                   	push   %ebx
  10efd4:	83 ec 34             	sub    $0x34,%esp
  10efd7:	8b 45 0c             	mov    0xc(%ebp),%eax
  10efda:	66 89 45 e8          	mov    %ax,0xffffffe8(%ebp)
  struct pbuf *p, *q, *r;
  u16_t offset;
  s32_t rem_len; /* remaining length */
  LWIP_DEBUGF(PBUF_DEBUG | DBG_TRACE | 3, ("pbuf_alloc(length=%u)\n", length));

  /* determine header offset */
  offset = 0;
  10efde:	66 c7 45 f8 00 00    	movw   $0x0,0xfffffff8(%ebp)
  switch (l) {
  10efe4:	8b 45 08             	mov    0x8(%ebp),%eax
  10efe7:	89 45 d4             	mov    %eax,0xffffffd4(%ebp)
  10efea:	83 7d d4 01          	cmpl   $0x1,0xffffffd4(%ebp)
  10efee:	74 19                	je     10f009 <pbuf_alloc+0x39>
  10eff0:	83 7d d4 01          	cmpl   $0x1,0xffffffd4(%ebp)
  10eff4:	72 0e                	jb     10f004 <pbuf_alloc+0x34>
  10eff6:	83 7d d4 02          	cmpl   $0x2,0xffffffd4(%ebp)
  10effa:	74 12                	je     10f00e <pbuf_alloc+0x3e>
  10effc:	83 7d d4 03          	cmpl   $0x3,0xffffffd4(%ebp)
  10f000:	74 1f                	je     10f021 <pbuf_alloc+0x51>
  10f002:	eb 11                	jmp    10f015 <pbuf_alloc+0x45>
  case PBUF_TRANSPORT:
    /* add room for transport (often TCP) layer header */
    offset += PBUF_TRANSPORT_HLEN;
  10f004:	66 83 45 f8 14       	addw   $0x14,0xfffffff8(%ebp)
    /* FALLTHROUGH */
  case PBUF_IP:
    /* add room for IP layer header */
    offset += PBUF_IP_HLEN;
  10f009:	66 83 45 f8 14       	addw   $0x14,0xfffffff8(%ebp)
    /* FALLTHROUGH */
  case PBUF_LINK:
    /* add room for link layer header */
    offset += PBUF_LINK_HLEN;
  10f00e:	66 83 45 f8 0e       	addw   $0xe,0xfffffff8(%ebp)
    break;
  10f013:	eb 0c                	jmp    10f021 <pbuf_alloc+0x51>
  case PBUF_RAW:
    break;
  default:
    LWIP_ASSERT("pbuf_alloc: bad pbuf layer", 0);
    return NULL;
  10f015:	c7 45 d8 00 00 00 00 	movl   $0x0,0xffffffd8(%ebp)
  10f01c:	e9 6e 02 00 00       	jmp    10f28f <pbuf_alloc+0x2bf>
  }

  switch (flag) {
  10f021:	8b 55 10             	mov    0x10(%ebp),%edx
  10f024:	89 55 d0             	mov    %edx,0xffffffd0(%ebp)
  10f027:	83 7d d0 02          	cmpl   $0x2,0xffffffd0(%ebp)
  10f02b:	77 0f                	ja     10f03c <pbuf_alloc+0x6c>
  10f02d:	83 7d d0 01          	cmpl   $0x1,0xffffffd0(%ebp)
  10f031:	0f 83 d5 01 00 00    	jae    10f20c <pbuf_alloc+0x23c>
  10f037:	e9 66 01 00 00       	jmp    10f1a2 <pbuf_alloc+0x1d2>
  10f03c:	83 7d d0 03          	cmpl   $0x3,0xffffffd0(%ebp)
  10f040:	74 05                	je     10f047 <pbuf_alloc+0x77>
  10f042:	e9 30 02 00 00       	jmp    10f277 <pbuf_alloc+0x2a7>
  case PBUF_POOL:
    /* allocate head of pbuf chain into p */
    p = pbuf_pool_alloc();
  10f047:	e8 c4 fe ff ff       	call   10ef10 <pbuf_pool_alloc>
  10f04c:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
    LWIP_DEBUGF(PBUF_DEBUG | DBG_TRACE | 3, ("pbuf_alloc: allocated pbuf %p offset %p\n", (void *)p, offset));
    if (p == NULL) {
  10f04f:	83 7d ec 00          	cmpl   $0x0,0xffffffec(%ebp)
  10f053:	75 1c                	jne    10f071 <pbuf_alloc+0xa1>
#if PBUF_STATS
      ++lwip_stats.pbuf.err;
  10f055:	0f b7 05 82 15 14 00 	movzwl 0x141582,%eax
  10f05c:	83 c0 01             	add    $0x1,%eax
  10f05f:	66 a3 82 15 14 00    	mov    %ax,0x141582
#endif /* PBUF_STATS */
      return NULL;
  10f065:	c7 45 d8 00 00 00 00 	movl   $0x0,0xffffffd8(%ebp)
  10f06c:	e9 1e 02 00 00       	jmp    10f28f <pbuf_alloc+0x2bf>
    }
    p->next = NULL;
  10f071:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10f074:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

    /* make the payload pointer point 'offset' bytes into pbuf data memory */
    p->payload = MEM_ALIGN((void *)((u8_t *)p + (sizeof(struct pbuf) + offset)));
  10f07a:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10f07d:	8d 50 10             	lea    0x10(%eax),%edx
  10f080:	0f b7 45 f8          	movzwl 0xfffffff8(%ebp),%eax
  10f084:	01 c2                	add    %eax,%edx
  10f086:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10f089:	89 50 04             	mov    %edx,0x4(%eax)
    LWIP_ASSERT("pbuf_alloc: pbuf p->payload properly aligned",
            ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
    /* the total length of the pbuf chain is the requested size */
    p->tot_len = length;
  10f08c:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
  10f08f:	0f b7 45 e8          	movzwl 0xffffffe8(%ebp),%eax
  10f093:	66 89 42 08          	mov    %ax,0x8(%edx)
    /* set the length of the first pbuf in the chain */
    p->len = length > PBUF_POOL_BUFSIZE - offset? PBUF_POOL_BUFSIZE - offset: length;
  10f097:	0f b7 4d e8          	movzwl 0xffffffe8(%ebp),%ecx
  10f09b:	0f b7 55 f8          	movzwl 0xfffffff8(%ebp),%edx
  10f09f:	b8 80 00 00 00       	mov    $0x80,%eax
  10f0a4:	89 c3                	mov    %eax,%ebx
  10f0a6:	29 d3                	sub    %edx,%ebx
  10f0a8:	89 5d dc             	mov    %ebx,0xffffffdc(%ebp)
  10f0ab:	89 4d e0             	mov    %ecx,0xffffffe0(%ebp)
  10f0ae:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  10f0b1:	39 45 e0             	cmp    %eax,0xffffffe0(%ebp)
  10f0b4:	7e 06                	jle    10f0bc <pbuf_alloc+0xec>
  10f0b6:	8b 55 dc             	mov    0xffffffdc(%ebp),%edx
  10f0b9:	89 55 e0             	mov    %edx,0xffffffe0(%ebp)
  10f0bc:	0f b7 55 e0          	movzwl 0xffffffe0(%ebp),%edx
  10f0c0:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10f0c3:	66 89 50 0a          	mov    %dx,0xa(%eax)
    /* set reference count (needed here in case we fail) */
    p->ref = 1;
  10f0c7:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10f0ca:	66 c7 40 0e 01 00    	movw   $0x1,0xe(%eax)

    /* now allocate the tail of the pbuf chain */

    /* remember first pbuf for linkage in next iteration */
    r = p;
  10f0d0:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10f0d3:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
    /* remaining length to be allocated */
    rem_len = length - p->len;
  10f0d6:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10f0d9:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
  10f0dd:	0f b7 45 e8          	movzwl 0xffffffe8(%ebp),%eax
  10f0e1:	66 29 d0             	sub    %dx,%ax
  10f0e4:	66 89 45 fa          	mov    %ax,0xfffffffa(%ebp)
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
  10f0e8:	e9 a5 00 00 00       	jmp    10f192 <pbuf_alloc+0x1c2>
      q = pbuf_pool_alloc();
  10f0ed:	e8 1e fe ff ff       	call   10ef10 <pbuf_pool_alloc>
  10f0f2:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
      if (q == NULL) {
  10f0f5:	83 7d f0 00          	cmpl   $0x0,0xfffffff0(%ebp)
  10f0f9:	75 27                	jne    10f122 <pbuf_alloc+0x152>
       LWIP_DEBUGF(PBUF_DEBUG | 2, ("pbuf_alloc: Out of pbufs in pool.\n"));
#if PBUF_STATS
        ++lwip_stats.pbuf.err;
  10f0fb:	0f b7 05 82 15 14 00 	movzwl 0x141582,%eax
  10f102:	83 c0 01             	add    $0x1,%eax
  10f105:	66 a3 82 15 14 00    	mov    %ax,0x141582
#endif /* PBUF_STATS */
        /* free chain so far allocated */
        pbuf_free(p);
  10f10b:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10f10e:	89 04 24             	mov    %eax,(%esp)
  10f111:	e8 9a 03 00 00       	call   10f4b0 <pbuf_free>
        /* bail out unsuccesfully */
        return NULL;
  10f116:	c7 45 d8 00 00 00 00 	movl   $0x0,0xffffffd8(%ebp)
  10f11d:	e9 6d 01 00 00       	jmp    10f28f <pbuf_alloc+0x2bf>
      }
      q->next = NULL;
  10f122:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10f125:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
      /* make previous pbuf point to this pbuf */
      r->next = q;
  10f12b:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
  10f12e:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10f131:	89 02                	mov    %eax,(%edx)
      /* set total length of this pbuf and next in chain */
      q->tot_len = rem_len;
  10f133:	0f b7 55 fa          	movzwl 0xfffffffa(%ebp),%edx
  10f137:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10f13a:	66 89 50 08          	mov    %dx,0x8(%eax)
      /* this pbuf length is pool size, unless smaller sized tail */
      q->len = rem_len > PBUF_POOL_BUFSIZE? PBUF_POOL_BUFSIZE: rem_len;
  10f13e:	66 81 7d fa 80 00    	cmpw   $0x80,0xfffffffa(%ebp)
  10f144:	7f 0a                	jg     10f150 <pbuf_alloc+0x180>
  10f146:	0f b7 4d fa          	movzwl 0xfffffffa(%ebp),%ecx
  10f14a:	66 89 4d e4          	mov    %cx,0xffffffe4(%ebp)
  10f14e:	eb 06                	jmp    10f156 <pbuf_alloc+0x186>
  10f150:	66 c7 45 e4 80 00    	movw   $0x80,0xffffffe4(%ebp)
  10f156:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10f159:	0f b7 5d e4          	movzwl 0xffffffe4(%ebp),%ebx
  10f15d:	66 89 58 0a          	mov    %bx,0xa(%eax)
      q->payload = (void *)((u8_t *)q + sizeof(struct pbuf));
  10f161:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10f164:	8d 50 10             	lea    0x10(%eax),%edx
  10f167:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10f16a:	89 50 04             	mov    %edx,0x4(%eax)
      LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
              ((mem_ptr_t)q->payload % MEM_ALIGNMENT) == 0);
      q->ref = 1;
  10f16d:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10f170:	66 c7 40 0e 01 00    	movw   $0x1,0xe(%eax)
      /* calculate remaining length to be allocated */
      rem_len -= q->len;
  10f176:	0f b7 55 fa          	movzwl 0xfffffffa(%ebp),%edx
  10f17a:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10f17d:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  10f181:	89 d1                	mov    %edx,%ecx
  10f183:	66 29 c1             	sub    %ax,%cx
  10f186:	89 c8                	mov    %ecx,%eax
  10f188:	66 89 45 fa          	mov    %ax,0xfffffffa(%ebp)
      /* remember this pbuf for linkage in next iteration */
      r = q;
  10f18c:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10f18f:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  10f192:	66 83 7d fa 00       	cmpw   $0x0,0xfffffffa(%ebp)
  10f197:	0f 8f 50 ff ff ff    	jg     10f0ed <pbuf_alloc+0x11d>
    }
    /* end of chain */
    /*r->next = NULL;*/

    break;
  10f19d:	e9 de 00 00 00       	jmp    10f280 <pbuf_alloc+0x2b0>
  case PBUF_RAM:
    /* If pbuf is to be allocated in RAM, allocate memory for it. */
    p = mem_malloc(MEM_ALIGN_SIZE(sizeof(struct pbuf) + length + offset));
  10f1a2:	0f b7 55 e8          	movzwl 0xffffffe8(%ebp),%edx
  10f1a6:	0f b7 45 f8          	movzwl 0xfffffff8(%ebp),%eax
  10f1aa:	8d 04 02             	lea    (%edx,%eax,1),%eax
  10f1ad:	83 c0 10             	add    $0x10,%eax
  10f1b0:	89 04 24             	mov    %eax,(%esp)
  10f1b3:	e8 08 f5 ff ff       	call   10e6c0 <mem_malloc>
  10f1b8:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
    if (p == NULL) {
  10f1bb:	83 7d ec 00          	cmpl   $0x0,0xffffffec(%ebp)
  10f1bf:	75 0c                	jne    10f1cd <pbuf_alloc+0x1fd>
      return NULL;
  10f1c1:	c7 45 d8 00 00 00 00 	movl   $0x0,0xffffffd8(%ebp)
  10f1c8:	e9 c2 00 00 00       	jmp    10f28f <pbuf_alloc+0x2bf>
    }
    /* Set up internal structure of the pbuf. */
    p->payload = MEM_ALIGN((void *)((u8_t *)p + sizeof(struct pbuf) + offset));
  10f1cd:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10f1d0:	8d 50 10             	lea    0x10(%eax),%edx
  10f1d3:	0f b7 45 f8          	movzwl 0xfffffff8(%ebp),%eax
  10f1d7:	01 c2                	add    %eax,%edx
  10f1d9:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10f1dc:	89 50 04             	mov    %edx,0x4(%eax)
    p->len = p->tot_len = length;
  10f1df:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
  10f1e2:	0f b7 45 e8          	movzwl 0xffffffe8(%ebp),%eax
  10f1e6:	66 89 42 08          	mov    %ax,0x8(%edx)
  10f1ea:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10f1ed:	0f b7 50 08          	movzwl 0x8(%eax),%edx
  10f1f1:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10f1f4:	66 89 50 0a          	mov    %dx,0xa(%eax)
    p->next = NULL;
  10f1f8:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10f1fb:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    p->flags = PBUF_FLAG_RAM;
  10f201:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10f204:	66 c7 40 0c 00 00    	movw   $0x0,0xc(%eax)

    LWIP_ASSERT("pbuf_alloc: pbuf->payload properly aligned",
           ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
    break;
  10f20a:	eb 74                	jmp    10f280 <pbuf_alloc+0x2b0>
  /* pbuf references existing (static constant) ROM payload? */
  case PBUF_ROM:
  /* pbuf references existing (externally allocated) RAM payload? */
  case PBUF_REF:
    /* only allocate memory for the pbuf structure */
    p = memp_malloc(MEMP_PBUF);
  10f20c:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  10f213:	e8 a8 f7 ff ff       	call   10e9c0 <memp_malloc>
  10f218:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
    if (p == NULL) {
  10f21b:	83 7d ec 00          	cmpl   $0x0,0xffffffec(%ebp)
  10f21f:	75 09                	jne    10f22a <pbuf_alloc+0x25a>
      LWIP_DEBUGF(PBUF_DEBUG | DBG_TRACE | 2, ("pbuf_alloc: Could not allocate MEMP_PBUF for PBUF_%s.\n", flag == PBUF_ROM?"ROM":"REF"));
      return NULL;
  10f221:	c7 45 d8 00 00 00 00 	movl   $0x0,0xffffffd8(%ebp)
  10f228:	eb 65                	jmp    10f28f <pbuf_alloc+0x2bf>
    }
    /* caller must set this field properly, afterwards */
    p->payload = NULL;
  10f22a:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10f22d:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    p->len = p->tot_len = length;
  10f234:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
  10f237:	0f b7 45 e8          	movzwl 0xffffffe8(%ebp),%eax
  10f23b:	66 89 42 08          	mov    %ax,0x8(%edx)
  10f23f:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10f242:	0f b7 50 08          	movzwl 0x8(%eax),%edx
  10f246:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10f249:	66 89 50 0a          	mov    %dx,0xa(%eax)
    p->next = NULL;
  10f24d:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10f250:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    p->flags = (flag == PBUF_ROM? PBUF_FLAG_ROM: PBUF_FLAG_REF);
  10f256:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
  10f25a:	75 08                	jne    10f264 <pbuf_alloc+0x294>
  10f25c:	66 c7 45 e6 01 00    	movw   $0x1,0xffffffe6(%ebp)
  10f262:	eb 06                	jmp    10f26a <pbuf_alloc+0x29a>
  10f264:	66 c7 45 e6 04 00    	movw   $0x4,0xffffffe6(%ebp)
  10f26a:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10f26d:	0f b7 5d e6          	movzwl 0xffffffe6(%ebp),%ebx
  10f271:	66 89 58 0c          	mov    %bx,0xc(%eax)
    break;
  10f275:	eb 09                	jmp    10f280 <pbuf_alloc+0x2b0>
  default:
    LWIP_ASSERT("pbuf_alloc: erroneous flag", 0);
    return NULL;
  10f277:	c7 45 d8 00 00 00 00 	movl   $0x0,0xffffffd8(%ebp)
  10f27e:	eb 0f                	jmp    10f28f <pbuf_alloc+0x2bf>
  }
  /* set reference count */
  p->ref = 1;
  10f280:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10f283:	66 c7 40 0e 01 00    	movw   $0x1,0xe(%eax)
  LWIP_DEBUGF(PBUF_DEBUG | DBG_TRACE | 3, ("pbuf_alloc(length=%u) == %p (%d)\n", length, (void *)p, offset));
  return p;
  10f289:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10f28c:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
  10f28f:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
}
  10f292:	83 c4 34             	add    $0x34,%esp
  10f295:	5b                   	pop    %ebx
  10f296:	5d                   	pop    %ebp
  10f297:	c3                   	ret    
  10f298:	90                   	nop    
  10f299:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

0010f2a0 <pbuf_realloc>:


#if PBUF_STATS
#define DEC_PBUF_STATS do { --lwip_stats.pbuf.used; } while (0)
#else /* PBUF_STATS */
#define DEC_PBUF_STATS
#endif /* PBUF_STATS */

#define PBUF_POOL_FAST_FREE(p)  do {                                    \
                                  p->next = pbuf_pool;                  \
                                  pbuf_pool = p;                        \
                                  DEC_PBUF_STATS;                       \
                                } while (0)

#if SYS_LIGHTWEIGHT_PROT
#define PBUF_POOL_FREE(p)  do {                                         \
                                SYS_ARCH_DECL_PROTECT(old_level);       \
                                SYS_ARCH_PROTECT(old_level);            \
                                PBUF_POOL_FAST_FREE(p);                 \
                                SYS_ARCH_UNPROTECT(old_level);          \
                               } while (0)
#else /* SYS_LIGHTWEIGHT_PROT */
#define PBUF_POOL_FREE(p)  do {                                         \
                             sys_sem_wait(pbuf_pool_free_sem);          \
                             PBUF_POOL_FAST_FREE(p);                    \
                             sys_sem_signal(pbuf_pool_free_sem);        \
                           } while (0)
#endif /* SYS_LIGHTWEIGHT_PROT */

/**
 * Shrink a pbuf chain to a desired length.
 *
 * @param p pbuf to shrink.
 * @param new_len desired new length of pbuf chain
 *
 * Depending on the desired length, the first few pbufs in a chain might
 * be skipped and left unchanged. The new last pbuf in the chain will be
 * resized, and any remaining pbufs will be freed.
 *
 * @note If the pbuf is ROM/REF, only the ->tot_len and ->len fields are adjusted.
 * @note May not be called on a packet queue.
 *
 * @bug Cannot grow the size of a pbuf (chain) (yet).
 */
void
pbuf_realloc(struct pbuf *p, u16_t new_len)
{
  10f2a0:	55                   	push   %ebp
  10f2a1:	89 e5                	mov    %esp,%ebp
  10f2a3:	83 ec 28             	sub    $0x28,%esp
  10f2a6:	8b 45 0c             	mov    0xc(%ebp),%eax
  10f2a9:	66 89 45 ec          	mov    %ax,0xffffffec(%ebp)
  struct pbuf *q;
  u16_t rem_len; /* remaining length */
  s16_t grow;

  LWIP_ASSERT("pbuf_realloc: sane p->flags", p->flags == PBUF_FLAG_POOL ||
  10f2ad:	8b 45 08             	mov    0x8(%ebp),%eax
  10f2b0:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  10f2b4:	66 83 f8 02          	cmp    $0x2,%ax
  10f2b8:	74 0d                	je     10f2c7 <pbuf_realloc+0x27>
  10f2ba:	8b 45 08             	mov    0x8(%ebp),%eax
  10f2bd:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  10f2c1:	66 83 f8 01          	cmp    $0x1,%ax
  10f2c5:	74 00                	je     10f2c7 <pbuf_realloc+0x27>
              p->flags == PBUF_FLAG_ROM ||
              p->flags == PBUF_FLAG_RAM ||
              p->flags == PBUF_FLAG_REF);

  /* desired length larger than current length? */
  if (new_len >= p->tot_len) {
  10f2c7:	8b 45 08             	mov    0x8(%ebp),%eax
  10f2ca:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  10f2ce:	66 3b 45 ec          	cmp    0xffffffec(%ebp),%ax
  10f2d2:	0f 86 ca 00 00 00    	jbe    10f3a2 <pbuf_realloc+0x102>
    /* enlarging not yet supported */
    return;
  }

  /* the pbuf chain grows by (new_len - p->tot_len) bytes
   * (which may be negative in case of shrinking) */
  grow = new_len - p->tot_len;
  10f2d8:	8b 45 08             	mov    0x8(%ebp),%eax
  10f2db:	0f b7 50 08          	movzwl 0x8(%eax),%edx
  10f2df:	0f b7 45 ec          	movzwl 0xffffffec(%ebp),%eax
  10f2e3:	66 29 d0             	sub    %dx,%ax
  10f2e6:	66 89 45 fe          	mov    %ax,0xfffffffe(%ebp)

  /* first, step over any pbufs that should remain in the chain */
  rem_len = new_len;
  10f2ea:	0f b7 45 ec          	movzwl 0xffffffec(%ebp),%eax
  10f2ee:	66 89 45 fc          	mov    %ax,0xfffffffc(%ebp)
  q = p;
  10f2f2:	8b 45 08             	mov    0x8(%ebp),%eax
  10f2f5:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
  10f2f8:	eb 27                	jmp    10f321 <pbuf_realloc+0x81>
    /* decrease remaining length by pbuf length */
    rem_len -= q->len;
  10f2fa:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10f2fd:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  10f301:	66 29 45 fc          	sub    %ax,0xfffffffc(%ebp)
    /* decrease total length indicator */
    q->tot_len += grow;
  10f305:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10f308:	0f b7 50 08          	movzwl 0x8(%eax),%edx
  10f30c:	0f b7 45 fe          	movzwl 0xfffffffe(%ebp),%eax
  10f310:	01 c2                	add    %eax,%edx
  10f312:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10f315:	66 89 50 08          	mov    %dx,0x8(%eax)
    /* proceed to next pbuf in chain */
    q = q->next;
  10f319:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10f31c:	8b 00                	mov    (%eax),%eax
  10f31e:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  10f321:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10f324:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  10f328:	66 3b 45 fc          	cmp    0xfffffffc(%ebp),%ax
  10f32c:	72 cc                	jb     10f2fa <pbuf_realloc+0x5a>
  }
  /* we have now reached the new last pbuf (in q) */
  /* rem_len == desired length for pbuf q */

  /* shrink allocated memory for PBUF_RAM */
  /* (other types merely adjust their length fields */
  if ((q->flags == PBUF_FLAG_RAM) && (rem_len != q->len)) {
  10f32e:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10f331:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  10f335:	66 85 c0             	test   %ax,%ax
  10f338:	75 30                	jne    10f36a <pbuf_realloc+0xca>
  10f33a:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10f33d:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  10f341:	66 3b 45 fc          	cmp    0xfffffffc(%ebp),%ax
  10f345:	74 23                	je     10f36a <pbuf_realloc+0xca>
    /* reallocate and adjust the length of the pbuf that will be split */
    mem_realloc(q, (u8_t *)q->payload - (u8_t *)q + rem_len);
  10f347:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10f34a:	8b 40 04             	mov    0x4(%eax),%eax
  10f34d:	89 c2                	mov    %eax,%edx
  10f34f:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10f352:	29 c2                	sub    %eax,%edx
  10f354:	0f b7 45 fc          	movzwl 0xfffffffc(%ebp),%eax
  10f358:	8d 04 02             	lea    (%edx,%eax,1),%eax
  10f35b:	89 44 24 04          	mov    %eax,0x4(%esp)
  10f35f:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10f362:	89 04 24             	mov    %eax,(%esp)
  10f365:	e8 46 f2 ff ff       	call   10e5b0 <mem_realloc>
  }
  /* adjust length fields for new last pbuf */
  q->len = rem_len;
  10f36a:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  10f36d:	0f b7 45 fc          	movzwl 0xfffffffc(%ebp),%eax
  10f371:	66 89 42 0a          	mov    %ax,0xa(%edx)
  q->tot_len = q->len;
  10f375:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10f378:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
  10f37c:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10f37f:	66 89 50 08          	mov    %dx,0x8(%eax)

  /* any remaining pbufs in chain? */
  if (q->next != NULL) {
  10f383:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10f386:	8b 00                	mov    (%eax),%eax
  10f388:	85 c0                	test   %eax,%eax
  10f38a:	74 0d                	je     10f399 <pbuf_realloc+0xf9>
    /* free remaining pbufs in chain */
    pbuf_free(q->next);
  10f38c:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10f38f:	8b 00                	mov    (%eax),%eax
  10f391:	89 04 24             	mov    %eax,(%esp)
  10f394:	e8 17 01 00 00       	call   10f4b0 <pbuf_free>
  }
  /* q is last packet in chain */
  q->next = NULL;
  10f399:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10f39c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

}
  10f3a2:	c9                   	leave  
  10f3a3:	c3                   	ret    
  10f3a4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  10f3aa:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

0010f3b0 <pbuf_header>:

/**
 * Adjusts the payload pointer to hide or reveal headers in the payload.
 *
 * Adjusts the ->payload pointer so that space for a header
 * (dis)appears in the pbuf payload.
 *
 * The ->payload, ->tot_len and ->len fields are adjusted.
 *
 * @param hdr_size Number of bytes to increment header size which
 * increases the size of the pbuf. New space is on the front.
 * (Using a negative value decreases the header size.)
 *
 * PBUF_ROM and PBUF_REF type buffers cannot have their sizes increased, so
 * the call will fail. A check is made that the increase in header size does
 * not move the payload pointer in front of the start of the buffer.
 * @return 1 on failure, 0 on success.
 *
 * @note May not be called on a packet queue.
 */
u8_t
pbuf_header(struct pbuf *p, s16_t header_size)
{
  10f3b0:	55                   	push   %ebp
  10f3b1:	89 e5                	mov    %esp,%ebp
  10f3b3:	83 ec 18             	sub    $0x18,%esp
  10f3b6:	8b 45 0c             	mov    0xc(%ebp),%eax
  10f3b9:	66 89 45 ec          	mov    %ax,0xffffffec(%ebp)
  void *payload;

  /* remember current payload pointer */
  payload = p->payload;
  10f3bd:	8b 45 08             	mov    0x8(%ebp),%eax
  10f3c0:	8b 40 04             	mov    0x4(%eax),%eax
  10f3c3:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)

  /* pbuf types containing payloads? */
  if (p->flags == PBUF_FLAG_RAM || p->flags == PBUF_FLAG_POOL) {
  10f3c6:	8b 45 08             	mov    0x8(%ebp),%eax
  10f3c9:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  10f3cd:	66 85 c0             	test   %ax,%ax
  10f3d0:	74 0d                	je     10f3df <pbuf_header+0x2f>
  10f3d2:	8b 45 08             	mov    0x8(%ebp),%eax
  10f3d5:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  10f3d9:	66 83 f8 02          	cmp    $0x2,%ax
  10f3dd:	75 3b                	jne    10f41a <pbuf_header+0x6a>
    /* set new payload pointer */
    p->payload = (u8_t *)p->payload - header_size;
  10f3df:	8b 45 08             	mov    0x8(%ebp),%eax
  10f3e2:	8b 40 04             	mov    0x4(%eax),%eax
  10f3e5:	89 c2                	mov    %eax,%edx
  10f3e7:	0f bf 45 ec          	movswl 0xffffffec(%ebp),%eax
  10f3eb:	29 c2                	sub    %eax,%edx
  10f3ed:	8b 45 08             	mov    0x8(%ebp),%eax
  10f3f0:	89 50 04             	mov    %edx,0x4(%eax)
    /* boundary check fails? */
    if ((u8_t *)p->payload < (u8_t *)p + sizeof(struct pbuf)) {
  10f3f3:	8b 45 08             	mov    0x8(%ebp),%eax
  10f3f6:	8b 40 04             	mov    0x4(%eax),%eax
  10f3f9:	89 c2                	mov    %eax,%edx
  10f3fb:	8b 45 08             	mov    0x8(%ebp),%eax
  10f3fe:	83 c0 10             	add    $0x10,%eax
  10f401:	39 c2                	cmp    %eax,%edx
  10f403:	73 6d                	jae    10f472 <pbuf_header+0xc2>
      LWIP_DEBUGF( PBUF_DEBUG | 2, ("pbuf_header: failed as %p < %p\n",
        (u8_t *)p->payload,
        (u8_t *)((u32_t)p + sizeof(struct pbuf))) );\
      /* restore old payload pointer */
      p->payload = payload;
  10f405:	8b 55 08             	mov    0x8(%ebp),%edx
  10f408:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10f40b:	89 42 04             	mov    %eax,0x4(%edx)
      /* bail out unsuccesfully */
      return 1;
  10f40e:	c7 45 e8 01 00 00 00 	movl   $0x1,0xffffffe8(%ebp)
  10f415:	e9 87 00 00 00       	jmp    10f4a1 <pbuf_header+0xf1>
    }
  /* pbuf types refering to payloads? */
  } else if (p->flags == PBUF_FLAG_REF || p->flags == PBUF_FLAG_ROM) {
  10f41a:	8b 45 08             	mov    0x8(%ebp),%eax
  10f41d:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  10f421:	66 83 f8 04          	cmp    $0x4,%ax
  10f425:	74 0d                	je     10f434 <pbuf_header+0x84>
  10f427:	8b 45 08             	mov    0x8(%ebp),%eax
  10f42a:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  10f42e:	66 83 f8 01          	cmp    $0x1,%ax
  10f432:	75 3e                	jne    10f472 <pbuf_header+0xc2>
    /* hide a header in the payload? */
    if ((header_size < 0) && (header_size - p->len <= 0)) {
  10f434:	66 83 7d ec 00       	cmpw   $0x0,0xffffffec(%ebp)
  10f439:	79 2e                	jns    10f469 <pbuf_header+0xb9>
  10f43b:	0f bf 55 ec          	movswl 0xffffffec(%ebp),%edx
  10f43f:	8b 45 08             	mov    0x8(%ebp),%eax
  10f442:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  10f446:	0f b7 c0             	movzwl %ax,%eax
  10f449:	89 d1                	mov    %edx,%ecx
  10f44b:	29 c1                	sub    %eax,%ecx
  10f44d:	89 c8                	mov    %ecx,%eax
  10f44f:	85 c0                	test   %eax,%eax
  10f451:	7f 16                	jg     10f469 <pbuf_header+0xb9>
      /* increase payload pointer */
      p->payload = (u8_t *)p->payload - header_size;
  10f453:	8b 45 08             	mov    0x8(%ebp),%eax
  10f456:	8b 40 04             	mov    0x4(%eax),%eax
  10f459:	89 c2                	mov    %eax,%edx
  10f45b:	0f bf 45 ec          	movswl 0xffffffec(%ebp),%eax
  10f45f:	29 c2                	sub    %eax,%edx
  10f461:	8b 45 08             	mov    0x8(%ebp),%eax
  10f464:	89 50 04             	mov    %edx,0x4(%eax)
  10f467:	eb 09                	jmp    10f472 <pbuf_header+0xc2>
    } else {
      /* cannot expand payload to front (yet!)
       * bail out unsuccesfully */
      return 1;
  10f469:	c7 45 e8 01 00 00 00 	movl   $0x1,0xffffffe8(%ebp)
  10f470:	eb 2f                	jmp    10f4a1 <pbuf_header+0xf1>
    }
  }
  LWIP_DEBUGF( PBUF_DEBUG, ("pbuf_header: old %p new %p (%d)\n", (void *)payload, (void *)p->payload, header_size) );
  /* modify pbuf length fields */
  p->len += header_size;
  10f472:	8b 45 08             	mov    0x8(%ebp),%eax
  10f475:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
  10f479:	0f b7 45 ec          	movzwl 0xffffffec(%ebp),%eax
  10f47d:	01 c2                	add    %eax,%edx
  10f47f:	8b 45 08             	mov    0x8(%ebp),%eax
  10f482:	66 89 50 0a          	mov    %dx,0xa(%eax)
  p->tot_len += header_size;
  10f486:	8b 45 08             	mov    0x8(%ebp),%eax
  10f489:	0f b7 50 08          	movzwl 0x8(%eax),%edx
  10f48d:	0f b7 45 ec          	movzwl 0xffffffec(%ebp),%eax
  10f491:	01 c2                	add    %eax,%edx
  10f493:	8b 45 08             	mov    0x8(%ebp),%eax
  10f496:	66 89 50 08          	mov    %dx,0x8(%eax)

  return 0;
  10f49a:	c7 45 e8 00 00 00 00 	movl   $0x0,0xffffffe8(%ebp)
  10f4a1:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
}
  10f4a4:	c9                   	leave  
  10f4a5:	c3                   	ret    
  10f4a6:	8d 76 00             	lea    0x0(%esi),%esi
  10f4a9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

0010f4b0 <pbuf_free>:

/**
 * Dereference a pbuf (chain) and deallocate any no-longer-used
 * pbufs at the head of this chain.
 *
 * Decrements the pbuf reference count. If it reaches
 * zero, the pbuf is deallocated.
 *
 * For a pbuf chain, this is repeated for each pbuf in the chain,
 * up to a pbuf which has a non-zero reference count after
 * decrementing. (This might de-allocate the whole chain.)
 *
 * @param pbuf The pbuf (chain) to be dereferenced.
 *
 * @return the number of pbufs that were de-allocated
 * from the head of the chain.
 *
 * @note MUST NOT be called on a packet queue.
 * @note the reference counter of a pbuf equals the number of pointers
 * that refer to the pbuf (or into the pbuf).
 *
 * @internal examples:
 *
 * Assuming existing chains a->b->c with the following reference
 * counts, calling pbuf_free(a) results in:
 * 
 * 1->2->3 becomes ...1->3
 * 3->3->3 becomes 2->3->3
 * 1->1->2 becomes ......1
 * 2->1->1 becomes 1->1->1
 * 1->1->1 becomes .......
 *
 */
u8_t
pbuf_free(struct pbuf *p)
{
  10f4b0:	55                   	push   %ebp
  10f4b1:	89 e5                	mov    %esp,%ebp
  10f4b3:	83 ec 28             	sub    $0x28,%esp
  struct pbuf *q;
  u8_t count;
  SYS_ARCH_DECL_PROTECT(old_level);

  if (p == NULL) {
  10f4b6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  10f4ba:	75 0c                	jne    10f4c8 <pbuf_free+0x18>
    LWIP_DEBUGF(PBUF_DEBUG | DBG_TRACE | 2, ("pbuf_free(p == NULL) was called.\n"));
    return 0;
  10f4bc:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  10f4c3:	e9 18 01 00 00       	jmp    10f5e0 <pbuf_free+0x130>
  }
  LWIP_DEBUGF(PBUF_DEBUG | DBG_TRACE | 3, ("pbuf_free(%p)\n", (void *)p));

  PERF_START;

  LWIP_ASSERT("pbuf_free: sane flags",
  10f4c8:	8b 45 08             	mov    0x8(%ebp),%eax
  10f4cb:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  10f4cf:	66 85 c0             	test   %ax,%ax
  10f4d2:	74 0d                	je     10f4e1 <pbuf_free+0x31>
  10f4d4:	8b 45 08             	mov    0x8(%ebp),%eax
  10f4d7:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  10f4db:	66 83 f8 01          	cmp    $0x1,%ax
  10f4df:	74 00                	je     10f4e1 <pbuf_free+0x31>
    p->flags == PBUF_FLAG_RAM || p->flags == PBUF_FLAG_ROM ||
    p->flags == PBUF_FLAG_REF || p->flags == PBUF_FLAG_POOL);

  count = 0;
  10f4e1:	c6 45 ff 00          	movb   $0x0,0xffffffff(%ebp)
  /* Since decrementing ref cannot be guaranteed to be a single machine operation
   * we must protect it. Also, the later test of ref must be protected.
   */
  SYS_ARCH_PROTECT(old_level);
  /* de-allocate all consecutive pbufs from the head of the chain that
   * obtain a zero reference count after decrementing*/
  while (p != NULL) {
  10f4e5:	e9 e5 00 00 00       	jmp    10f5cf <pbuf_free+0x11f>
    /* all pbufs in a chain are referenced at least once */
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
    /* decrease reference count (number of pointers to pbuf) */
    p->ref--;
  10f4ea:	8b 45 08             	mov    0x8(%ebp),%eax
  10f4ed:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
  10f4f1:	8d 50 ff             	lea    0xffffffff(%eax),%edx
  10f4f4:	8b 45 08             	mov    0x8(%ebp),%eax
  10f4f7:	66 89 50 0e          	mov    %dx,0xe(%eax)
    /* this pbuf is no longer referenced to? */
    if (p->ref == 0) {
  10f4fb:	8b 45 08             	mov    0x8(%ebp),%eax
  10f4fe:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
  10f502:	66 85 c0             	test   %ax,%ax
  10f505:	0f 85 bd 00 00 00    	jne    10f5c8 <pbuf_free+0x118>
      /* remember next pbuf in chain for next iteration */
      q = p->next;
  10f50b:	8b 45 08             	mov    0x8(%ebp),%eax
  10f50e:	8b 00                	mov    (%eax),%eax
  10f510:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
      LWIP_DEBUGF( PBUF_DEBUG | 2, ("pbuf_free: deallocating %p\n", (void *)p));
      /* is this a pbuf from the pool? */
      if (p->flags == PBUF_FLAG_POOL) {
  10f513:	8b 45 08             	mov    0x8(%ebp),%eax
  10f516:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  10f51a:	66 83 f8 02          	cmp    $0x2,%ax
  10f51e:	75 62                	jne    10f582 <pbuf_free+0xd2>
        p->len = p->tot_len = PBUF_POOL_BUFSIZE;
  10f520:	8b 45 08             	mov    0x8(%ebp),%eax
  10f523:	66 c7 40 08 80 00    	movw   $0x80,0x8(%eax)
  10f529:	8b 45 08             	mov    0x8(%ebp),%eax
  10f52c:	0f b7 50 08          	movzwl 0x8(%eax),%edx
  10f530:	8b 45 08             	mov    0x8(%ebp),%eax
  10f533:	66 89 50 0a          	mov    %dx,0xa(%eax)
        p->payload = (void *)((u8_t *)p + sizeof(struct pbuf));
  10f537:	8b 45 08             	mov    0x8(%ebp),%eax
  10f53a:	8d 50 10             	lea    0x10(%eax),%edx
  10f53d:	8b 45 08             	mov    0x8(%ebp),%eax
  10f540:	89 50 04             	mov    %edx,0x4(%eax)
        PBUF_POOL_FREE(p);
  10f543:	a1 e4 98 13 00       	mov    0x1398e4,%eax
  10f548:	89 04 24             	mov    %eax,(%esp)
  10f54b:	e8 b0 08 00 00       	call   10fe00 <sys_sem_wait>
  10f550:	8b 15 c0 08 13 00    	mov    0x1308c0,%edx
  10f556:	8b 45 08             	mov    0x8(%ebp),%eax
  10f559:	89 10                	mov    %edx,(%eax)
  10f55b:	8b 45 08             	mov    0x8(%ebp),%eax
  10f55e:	a3 c0 08 13 00       	mov    %eax,0x1308c0
  10f563:	0f b7 05 7e 15 14 00 	movzwl 0x14157e,%eax
  10f56a:	83 e8 01             	sub    $0x1,%eax
  10f56d:	66 a3 7e 15 14 00    	mov    %ax,0x14157e
  10f573:	a1 e4 98 13 00       	mov    0x1398e4,%eax
  10f578:	89 04 24             	mov    %eax,(%esp)
  10f57b:	e8 40 a8 00 00       	call   119dc0 <sys_sem_signal>
  10f580:	eb 3a                	jmp    10f5bc <pbuf_free+0x10c>
      /* a ROM or RAM referencing pbuf */
      } else if (p->flags == PBUF_FLAG_ROM || p->flags == PBUF_FLAG_REF) {
  10f582:	8b 45 08             	mov    0x8(%ebp),%eax
  10f585:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  10f589:	66 83 f8 01          	cmp    $0x1,%ax
  10f58d:	74 0d                	je     10f59c <pbuf_free+0xec>
  10f58f:	8b 45 08             	mov    0x8(%ebp),%eax
  10f592:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  10f596:	66 83 f8 04          	cmp    $0x4,%ax
  10f59a:	75 15                	jne    10f5b1 <pbuf_free+0x101>
        memp_free(MEMP_PBUF, p);
  10f59c:	8b 45 08             	mov    0x8(%ebp),%eax
  10f59f:	89 44 24 04          	mov    %eax,0x4(%esp)
  10f5a3:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  10f5aa:	e8 01 f5 ff ff       	call   10eab0 <memp_free>
  10f5af:	eb 0b                	jmp    10f5bc <pbuf_free+0x10c>
      /* p->flags == PBUF_FLAG_RAM */
      } else {
        mem_free(p);
  10f5b1:	8b 45 08             	mov    0x8(%ebp),%eax
  10f5b4:	89 04 24             	mov    %eax,(%esp)
  10f5b7:	e8 d4 ee ff ff       	call   10e490 <mem_free>
      }
      count++;
  10f5bc:	80 45 ff 01          	addb   $0x1,0xffffffff(%ebp)
      /* proceed to next pbuf */
      p = q;
  10f5c0:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10f5c3:	89 45 08             	mov    %eax,0x8(%ebp)
  10f5c6:	eb 07                	jmp    10f5cf <pbuf_free+0x11f>
    /* p->ref > 0, this pbuf is still referenced to */
    /* (and so the remaining pbufs in chain as well) */
    } else {
      LWIP_DEBUGF( PBUF_DEBUG | 2, ("pbuf_free: %p has ref %u, ending here.\n", (void *)p, (unsigned int)p->ref));
      /* stop walking through chain */
      p = NULL;
  10f5c8:	c7 45 08 00 00 00 00 	movl   $0x0,0x8(%ebp)
  10f5cf:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  10f5d3:	0f 85 11 ff ff ff    	jne    10f4ea <pbuf_free+0x3a>
    }
  }
  SYS_ARCH_UNPROTECT(old_level);
  PERF_STOP("pbuf_free");
  /* return number of de-allocated pbufs */
  return count;
  10f5d9:	0f b6 45 ff          	movzbl 0xffffffff(%ebp),%eax
  10f5dd:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  10f5e0:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  10f5e3:	c9                   	leave  
  10f5e4:	c3                   	ret    
  10f5e5:	8d 74 26 00          	lea    0x0(%esi),%esi
  10f5e9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

0010f5f0 <pbuf_clen>:

/**
 * Count number of pbufs in a chain
 *
 * @param p first pbuf of chain
 * @return the number of pbufs in a chain
 */

u8_t
pbuf_clen(struct pbuf *p)
{
  10f5f0:	55                   	push   %ebp
  10f5f1:	89 e5                	mov    %esp,%ebp
  10f5f3:	83 ec 10             	sub    $0x10,%esp
  u8_t len;

  len = 0;
  10f5f6:	c6 45 ff 00          	movb   $0x0,0xffffffff(%ebp)
  while (p != NULL) {
  10f5fa:	eb 0c                	jmp    10f608 <pbuf_clen+0x18>
    ++len;
  10f5fc:	80 45 ff 01          	addb   $0x1,0xffffffff(%ebp)
    p = p->next;
  10f600:	8b 45 08             	mov    0x8(%ebp),%eax
  10f603:	8b 00                	mov    (%eax),%eax
  10f605:	89 45 08             	mov    %eax,0x8(%ebp)
  10f608:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  10f60c:	75 ee                	jne    10f5fc <pbuf_clen+0xc>
  }
  return len;
  10f60e:	0f b6 45 ff          	movzbl 0xffffffff(%ebp),%eax
}
  10f612:	c9                   	leave  
  10f613:	c3                   	ret    
  10f614:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  10f61a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

0010f620 <pbuf_ref>:

/**
 * Increment the reference count of the pbuf.
 *
 * @param p pbuf to increase reference counter of
 *
 */
void
pbuf_ref(struct pbuf *p)
{
  10f620:	55                   	push   %ebp
  10f621:	89 e5                	mov    %esp,%ebp
  SYS_ARCH_DECL_PROTECT(old_level);
  /* pbuf given? */
  if (p != NULL) {
  10f623:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  10f627:	74 11                	je     10f63a <pbuf_ref+0x1a>
    SYS_ARCH_PROTECT(old_level);
    ++(p->ref);
  10f629:	8b 45 08             	mov    0x8(%ebp),%eax
  10f62c:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
  10f630:	8d 50 01             	lea    0x1(%eax),%edx
  10f633:	8b 45 08             	mov    0x8(%ebp),%eax
  10f636:	66 89 50 0e          	mov    %dx,0xe(%eax)
    SYS_ARCH_UNPROTECT(old_level);
  }
}
  10f63a:	5d                   	pop    %ebp
  10f63b:	c3                   	ret    
  10f63c:	8d 74 26 00          	lea    0x0(%esi),%esi

0010f640 <pbuf_cat>:

/**
 * Concatenate two pbufs (each may be a pbuf chain) and take over
 * the caller's reference of the tail pbuf.
 * 
 * @note The caller MAY NOT reference the tail pbuf afterwards.
 * Use pbuf_chain() for that purpose.
 * 
 * @see pbuf_chain()
 */

void
pbuf_cat(struct pbuf *h, struct pbuf *t)
{
  10f640:	55                   	push   %ebp
  10f641:	89 e5                	mov    %esp,%ebp
  10f643:	83 ec 10             	sub    $0x10,%esp
  struct pbuf *p;

  LWIP_ASSERT("h != NULL", h != NULL);
  LWIP_ASSERT("t != NULL", t != NULL);
  if ((h == NULL) || (t == NULL)) return;
  10f646:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  10f64a:	74 57                	je     10f6a3 <pbuf_cat+0x63>
  10f64c:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  10f650:	75 02                	jne    10f654 <pbuf_cat+0x14>
  10f652:	eb 4f                	jmp    10f6a3 <pbuf_cat+0x63>

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
  10f654:	8b 45 08             	mov    0x8(%ebp),%eax
  10f657:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  10f65a:	eb 1f                	jmp    10f67b <pbuf_cat+0x3b>
    /* add total length of second chain to all totals of first chain */
    p->tot_len += t->tot_len;
  10f65c:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10f65f:	0f b7 50 08          	movzwl 0x8(%eax),%edx
  10f663:	8b 45 0c             	mov    0xc(%ebp),%eax
  10f666:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  10f66a:	01 c2                	add    %eax,%edx
  10f66c:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10f66f:	66 89 50 08          	mov    %dx,0x8(%eax)
  10f673:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10f676:	8b 00                	mov    (%eax),%eax
  10f678:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  10f67b:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10f67e:	8b 00                	mov    (%eax),%eax
  10f680:	85 c0                	test   %eax,%eax
  10f682:	75 d8                	jne    10f65c <pbuf_cat+0x1c>
  }
  /* { p is last pbuf of first h chain, p->next == NULL } */
  LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
  /* add total length of second chain to last pbuf total of first chain */
  p->tot_len += t->tot_len;
  10f684:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10f687:	0f b7 50 08          	movzwl 0x8(%eax),%edx
  10f68b:	8b 45 0c             	mov    0xc(%ebp),%eax
  10f68e:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  10f692:	01 c2                	add    %eax,%edx
  10f694:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10f697:	66 89 50 08          	mov    %dx,0x8(%eax)
  /* chain last pbuf of head (p) with first of tail (t) */
  p->next = t;
  10f69b:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  10f69e:	8b 45 0c             	mov    0xc(%ebp),%eax
  10f6a1:	89 02                	mov    %eax,(%edx)
}
  10f6a3:	c9                   	leave  
  10f6a4:	c3                   	ret    
  10f6a5:	8d 74 26 00          	lea    0x0(%esi),%esi
  10f6a9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

0010f6b0 <pbuf_chain>:

/**
 * Chain two pbufs (or pbuf chains) together.
 * 
 * The caller MUST call pbuf_free(t) once it has stopped
 * using it. Use pbuf_cat() instead if you no longer use t.
 * 
 * @param h head pbuf (chain)
 * @param t tail pbuf (chain)
 * @note The pbufs MUST belong to the same packet.
 * @note MAY NOT be called on a packet queue.
 *
 * The ->tot_len fields of all pbufs of the head chain are adjusted.
 * The ->next field of the last pbuf of the head chain is adjusted.
 * The ->ref field of the first pbuf of the tail chain is adjusted.
 *
 */
void
pbuf_chain(struct pbuf *h, struct pbuf *t)
{
  10f6b0:	55                   	push   %ebp
  10f6b1:	89 e5                	mov    %esp,%ebp
  10f6b3:	83 ec 08             	sub    $0x8,%esp
  pbuf_cat(h, t);
  10f6b6:	8b 45 0c             	mov    0xc(%ebp),%eax
  10f6b9:	89 44 24 04          	mov    %eax,0x4(%esp)
  10f6bd:	8b 45 08             	mov    0x8(%ebp),%eax
  10f6c0:	89 04 24             	mov    %eax,(%esp)
  10f6c3:	e8 78 ff ff ff       	call   10f640 <pbuf_cat>
  /* t is now referenced by h */
  pbuf_ref(t);
  10f6c8:	8b 45 0c             	mov    0xc(%ebp),%eax
  10f6cb:	89 04 24             	mov    %eax,(%esp)
  10f6ce:	e8 4d ff ff ff       	call   10f620 <pbuf_ref>
  LWIP_DEBUGF(PBUF_DEBUG | DBG_FRESH | 2, ("pbuf_chain: %p references %p\n", (void *)h, (void *)t));
}
  10f6d3:	c9                   	leave  
  10f6d4:	c3                   	ret    
  10f6d5:	8d 74 26 00          	lea    0x0(%esi),%esi
  10f6d9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

0010f6e0 <pbuf_queue>:

/* For packet queueing. Note that queued packets must be dequeued first
 * before calling any pbuf functions. */
#if ARP_QUEUEING
/**
 * Add a packet to the end of a queue.
 *
 * @param q pointer to first packet on the queue
 * @param n packet to be queued
 *
 */
void
pbuf_queue(struct pbuf *p, struct pbuf *n)
{
  10f6e0:	55                   	push   %ebp
  10f6e1:	89 e5                	mov    %esp,%ebp
  10f6e3:	83 ec 04             	sub    $0x4,%esp
  LWIP_ASSERT("p != NULL", p != NULL);
  LWIP_ASSERT("n != NULL", n != NULL);

  if ((p == NULL) || (n == NULL))
  10f6e6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  10f6ea:	74 2c                	je     10f718 <pbuf_queue+0x38>
  10f6ec:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  10f6f0:	75 0a                	jne    10f6fc <pbuf_queue+0x1c>
    return;
  10f6f2:	eb 24                	jmp    10f718 <pbuf_queue+0x38>

  /* iterate through all packets on queue */
  while (p->next != NULL) {
/* be very picky about pbuf chain correctness */
#if PBUF_DEBUG
    /* iterate through all pbufs in packet */
    while (p->tot_len != p->len) {
      /* make sure each packet is complete */
      LWIP_ASSERT("p->next != NULL", p->next != NULL);
      p = p->next;
    }
#endif
    /* now p->tot_len == p->len */
    /* proceed to next packet on queue */
    p = p->next;
  10f6f4:	8b 45 08             	mov    0x8(%ebp),%eax
  10f6f7:	8b 00                	mov    (%eax),%eax
  10f6f9:	89 45 08             	mov    %eax,0x8(%ebp)
  10f6fc:	8b 45 08             	mov    0x8(%ebp),%eax
  10f6ff:	8b 00                	mov    (%eax),%eax
  10f701:	85 c0                	test   %eax,%eax
  10f703:	75 ef                	jne    10f6f4 <pbuf_queue+0x14>
  }
  /* chain last pbuf of queue with n */
  p->next = n;
  10f705:	8b 45 08             	mov    0x8(%ebp),%eax
  10f708:	8b 55 0c             	mov    0xc(%ebp),%edx
  10f70b:	89 10                	mov    %edx,(%eax)
  /* n is now referenced to one more time */
  pbuf_ref(n);
  10f70d:	8b 45 0c             	mov    0xc(%ebp),%eax
  10f710:	89 04 24             	mov    %eax,(%esp)
  10f713:	e8 08 ff ff ff       	call   10f620 <pbuf_ref>
  LWIP_DEBUGF(PBUF_DEBUG | DBG_FRESH | 2, ("pbuf_queue: referencing queued packet %p\n", (void *)n));
}
  10f718:	c9                   	leave  
  10f719:	c3                   	ret    
  10f71a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

0010f720 <pbuf_dequeue>:

/**
 * Remove a packet from the head of a queue.
 *
 * @param p pointer to first packet on the queue which will be dequeued.
 * @return first packet on the remaining queue (NULL if no further packets).
 *
 */
struct pbuf *
pbuf_dequeue(struct pbuf *p)
{
  10f720:	55                   	push   %ebp
  10f721:	89 e5                	mov    %esp,%ebp
  10f723:	83 ec 18             	sub    $0x18,%esp
  struct pbuf *q;
  LWIP_ASSERT("p != NULL", p != NULL);

  /* iterate through all pbufs in packet */
  while (p->tot_len != p->len) {
  10f726:	eb 08                	jmp    10f730 <pbuf_dequeue+0x10>
    /* make sure each packet is complete */
    LWIP_ASSERT("p->next != NULL", p->next != NULL);
    p = p->next;
  10f728:	8b 45 08             	mov    0x8(%ebp),%eax
  10f72b:	8b 00                	mov    (%eax),%eax
  10f72d:	89 45 08             	mov    %eax,0x8(%ebp)
  10f730:	8b 45 08             	mov    0x8(%ebp),%eax
  10f733:	0f b7 50 08          	movzwl 0x8(%eax),%edx
  10f737:	8b 45 08             	mov    0x8(%ebp),%eax
  10f73a:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  10f73e:	66 39 c2             	cmp    %ax,%dx
  10f741:	75 e5                	jne    10f728 <pbuf_dequeue+0x8>
  }
  /* remember next packet on queue */
  q = p->next;
  10f743:	8b 45 08             	mov    0x8(%ebp),%eax
  10f746:	8b 00                	mov    (%eax),%eax
  10f748:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  /* dequeue p from queue */
  p->next = NULL;
  10f74b:	8b 45 08             	mov    0x8(%ebp),%eax
  10f74e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  /* q is now referenced to one less time */
  pbuf_free(q);
  10f754:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10f757:	89 04 24             	mov    %eax,(%esp)
  10f75a:	e8 51 fd ff ff       	call   10f4b0 <pbuf_free>
  LWIP_DEBUGF(PBUF_DEBUG | DBG_FRESH | 2, ("pbuf_dequeue: dereferencing remaining queue %p\n", (void *)q));
  return q;
  10f75f:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
}
  10f762:	c9                   	leave  
  10f763:	c3                   	ret    
  10f764:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  10f76a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

0010f770 <pbuf_take>:
#endif

/**
 *
 * Create PBUF_POOL (or PBUF_RAM) copies of PBUF_REF pbufs.
 *
 * Used to queue packets on behalf of the lwIP stack, such as
 * ARP based queueing.
 *
 * Go through a pbuf chain and replace any PBUF_REF buffers
 * with PBUF_POOL (or PBUF_RAM) pbufs, each taking a copy of
 * the referenced data.
 *
 * @note You MUST explicitly use p = pbuf_take(p);
 * The pbuf you give as argument, may have been replaced
 * by pbuf_take()!
 *
 * @note Any replaced pbufs will be freed through pbuf_free().
 * This may deallocate them if they become no longer referenced.
 *
 * @param p Head of pbuf chain to process
 *
 * @return Pointer to head of pbuf chain
 */
struct pbuf *
pbuf_take(struct pbuf *p)
{
  10f770:	55                   	push   %ebp
  10f771:	89 e5                	mov    %esp,%ebp
  10f773:	83 ec 28             	sub    $0x28,%esp
  struct pbuf *q , *prev, *head;
  LWIP_ASSERT("pbuf_take: p != NULL\n", p != NULL);
  LWIP_DEBUGF(PBUF_DEBUG | DBG_TRACE | 3, ("pbuf_take(%p)\n", (void*)p));

  prev = NULL;
  10f776:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)
  head = p;
  10f77d:	8b 45 08             	mov    0x8(%ebp),%eax
  10f780:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  /* iterate through pbuf chain */
  do
  {
    /* pbuf is of type PBUF_REF? */
    if (p->flags == PBUF_FLAG_REF) {
  10f783:	8b 45 08             	mov    0x8(%ebp),%eax
  10f786:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  10f78a:	66 83 f8 04          	cmp    $0x4,%ax
  10f78e:	0f 85 fe 00 00 00    	jne    10f892 <pbuf_take+0x122>
      LWIP_DEBUGF(PBUF_DEBUG | DBG_TRACE, ("pbuf_take: encountered PBUF_REF %p\n", (void *)p));
      /* allocate a pbuf (w/ payload) fully in RAM */
      /* PBUF_POOL buffers are faster if we can use them */
      if (p->len <= PBUF_POOL_BUFSIZE) {
  10f794:	8b 45 08             	mov    0x8(%ebp),%eax
  10f797:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  10f79b:	66 3d 80 00          	cmp    $0x80,%ax
  10f79f:	77 27                	ja     10f7c8 <pbuf_take+0x58>
        q = pbuf_alloc(PBUF_RAW, p->len, PBUF_POOL);
  10f7a1:	8b 45 08             	mov    0x8(%ebp),%eax
  10f7a4:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  10f7a8:	0f b7 c0             	movzwl %ax,%eax
  10f7ab:	c7 44 24 08 03 00 00 	movl   $0x3,0x8(%esp)
  10f7b2:	00 
  10f7b3:	89 44 24 04          	mov    %eax,0x4(%esp)
  10f7b7:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  10f7be:	e8 0d f8 ff ff       	call   10efd0 <pbuf_alloc>
  10f7c3:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  10f7c6:	eb 07                	jmp    10f7cf <pbuf_take+0x5f>
        if (q == NULL) LWIP_DEBUGF(PBUF_DEBUG | DBG_TRACE | 2, ("pbuf_take: Could not allocate PBUF_POOL\n"));
      } else {
        /* no replacement pbuf yet */
        q = NULL;
  10f7c8:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
        LWIP_DEBUGF(PBUF_DEBUG | DBG_TRACE | 2, ("pbuf_take: PBUF_POOL too small to replace PBUF_REF\n"));
      }
      /* no (large enough) PBUF_POOL was available? retry with PBUF_RAM */
      if (q == NULL) {
  10f7cf:	83 7d f4 00          	cmpl   $0x0,0xfffffff4(%ebp)
  10f7d3:	75 25                	jne    10f7fa <pbuf_take+0x8a>
        q = pbuf_alloc(PBUF_RAW, p->len, PBUF_RAM);
  10f7d5:	8b 45 08             	mov    0x8(%ebp),%eax
  10f7d8:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  10f7dc:	0f b7 c0             	movzwl %ax,%eax
  10f7df:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  10f7e6:	00 
  10f7e7:	89 44 24 04          	mov    %eax,0x4(%esp)
  10f7eb:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  10f7f2:	e8 d9 f7 ff ff       	call   10efd0 <pbuf_alloc>
  10f7f7:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
        if (q == NULL) LWIP_DEBUGF(PBUF_DEBUG | DBG_TRACE | 2, ("pbuf_take: Could not allocate PBUF_RAM\n"));
      }
      /* replacement pbuf could be allocated? */
      if (q != NULL)
  10f7fa:	83 7d f4 00          	cmpl   $0x0,0xfffffff4(%ebp)
  10f7fe:	74 7e                	je     10f87e <pbuf_take+0x10e>
      {
        /* copy p to q */
        /* copy successor */
        q->next = p->next;
  10f800:	8b 45 08             	mov    0x8(%ebp),%eax
  10f803:	8b 10                	mov    (%eax),%edx
  10f805:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10f808:	89 10                	mov    %edx,(%eax)
        /* remove linkage from original pbuf */
        p->next = NULL;
  10f80a:	8b 45 08             	mov    0x8(%ebp),%eax
  10f80d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
        /* remove linkage to original pbuf */
        if (prev != NULL) {
  10f813:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  10f817:	74 0a                	je     10f823 <pbuf_take+0xb3>
          /* prev->next == p at this point */
          LWIP_ASSERT("prev->next == p", prev->next == p);
          /* break chain and insert new pbuf instead */
          prev->next = q;
  10f819:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  10f81c:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10f81f:	89 02                	mov    %eax,(%edx)
  10f821:	eb 06                	jmp    10f829 <pbuf_take+0xb9>
        /* prev == NULL, so we replaced the head pbuf of the chain */
        } else {
          head = q;
  10f823:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10f826:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
        }
        /* copy pbuf payload */
        memcpy(q->payload, p->payload, p->len);
  10f829:	8b 45 08             	mov    0x8(%ebp),%eax
  10f82c:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  10f830:	0f b7 d0             	movzwl %ax,%edx
  10f833:	8b 45 08             	mov    0x8(%ebp),%eax
  10f836:	8b 48 04             	mov    0x4(%eax),%ecx
  10f839:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10f83c:	8b 40 04             	mov    0x4(%eax),%eax
  10f83f:	89 54 24 08          	mov    %edx,0x8(%esp)
  10f843:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10f847:	89 04 24             	mov    %eax,(%esp)
  10f84a:	e8 71 66 ff ff       	call   105ec0 <memcpy>
        q->tot_len = p->tot_len;
  10f84f:	8b 45 08             	mov    0x8(%ebp),%eax
  10f852:	0f b7 50 08          	movzwl 0x8(%eax),%edx
  10f856:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10f859:	66 89 50 08          	mov    %dx,0x8(%eax)
        q->len = p->len;
  10f85d:	8b 45 08             	mov    0x8(%ebp),%eax
  10f860:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
  10f864:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10f867:	66 89 50 0a          	mov    %dx,0xa(%eax)
        /* in case p was the first pbuf, it is no longer refered to by
         * our caller, as the caller MUST do p = pbuf_take(p);
         * in case p was not the first pbuf, it is no longer refered to
         * by prev. we can safely free the pbuf here.
         * (note that we have set p->next to NULL already so that
         * we will not free the rest of the chain by accident.)
         */
        pbuf_free(p);
  10f86b:	8b 45 08             	mov    0x8(%ebp),%eax
  10f86e:	89 04 24             	mov    %eax,(%esp)
  10f871:	e8 3a fc ff ff       	call   10f4b0 <pbuf_free>
        /* do not copy ref, since someone else might be using the old buffer */
        LWIP_DEBUGF(PBUF_DEBUG, ("pbuf_take: replaced PBUF_REF %p with %p\n", (void *)p, (void *)q));
        p = q;
  10f876:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10f879:	89 45 08             	mov    %eax,0x8(%ebp)
  10f87c:	eb 14                	jmp    10f892 <pbuf_take+0x122>
      } else {
        /* deallocate chain */
        pbuf_free(head);
  10f87e:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10f881:	89 04 24             	mov    %eax,(%esp)
  10f884:	e8 27 fc ff ff       	call   10f4b0 <pbuf_free>
        LWIP_DEBUGF(PBUF_DEBUG | 2, ("pbuf_take: failed to allocate replacement pbuf for %p\n", (void *)p));
        return NULL;
  10f889:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  10f890:	eb 1e                	jmp    10f8b0 <pbuf_take+0x140>
      }
    /* p->flags != PBUF_FLAG_REF */
    } else {
      LWIP_DEBUGF(PBUF_DEBUG | DBG_TRACE | 1, ("pbuf_take: skipping pbuf not of type PBUF_REF\n"));
    }
    /* remember this pbuf */
    prev = p;
  10f892:	8b 45 08             	mov    0x8(%ebp),%eax
  10f895:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
    /* proceed to next pbuf in original chain */
    p = p->next;
  10f898:	8b 45 08             	mov    0x8(%ebp),%eax
  10f89b:	8b 00                	mov    (%eax),%eax
  10f89d:	89 45 08             	mov    %eax,0x8(%ebp)
  } while (p);
  10f8a0:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  10f8a4:	0f 85 d9 fe ff ff    	jne    10f783 <pbuf_take+0x13>
  LWIP_DEBUGF(PBUF_DEBUG | DBG_TRACE | 1, ("pbuf_take: end of chain reached.\n"));

  return head;
  10f8aa:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10f8ad:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  10f8b0:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  10f8b3:	c9                   	leave  
  10f8b4:	c3                   	ret    
  10f8b5:	8d 74 26 00          	lea    0x0(%esi),%esi
  10f8b9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

0010f8c0 <pbuf_dechain>:

/**
 * Dechains the first pbuf from its succeeding pbufs in the chain.
 *
 * Makes p->tot_len field equal to p->len.
 * @param p pbuf to dechain
 * @return remainder of the pbuf chain, or NULL if it was de-allocated.
 * @note May not be called on a packet queue.
 */
struct pbuf *
pbuf_dechain(struct pbuf *p)
{
  10f8c0:	55                   	push   %ebp
  10f8c1:	89 e5                	mov    %esp,%ebp
  10f8c3:	83 ec 18             	sub    $0x18,%esp
  struct pbuf *q;
  u8_t tail_gone = 1;
  10f8c6:	c6 45 ff 01          	movb   $0x1,0xffffffff(%ebp)
  /* tail */
  q = p->next;
  10f8ca:	8b 45 08             	mov    0x8(%ebp),%eax
  10f8cd:	8b 00                	mov    (%eax),%eax
  10f8cf:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  /* pbuf has successor in chain? */
  if (q != NULL) {
  10f8d2:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  10f8d6:	74 3d                	je     10f915 <pbuf_dechain+0x55>
    /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
    LWIP_ASSERT("p->tot_len == p->len + q->tot_len", q->tot_len == p->tot_len - p->len);
    /* enforce invariant if assertion is disabled */
    q->tot_len = p->tot_len - p->len;
  10f8d8:	8b 45 08             	mov    0x8(%ebp),%eax
  10f8db:	0f b7 50 08          	movzwl 0x8(%eax),%edx
  10f8df:	8b 45 08             	mov    0x8(%ebp),%eax
  10f8e2:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  10f8e6:	66 29 c2             	sub    %ax,%dx
  10f8e9:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10f8ec:	66 89 50 08          	mov    %dx,0x8(%eax)
    /* decouple pbuf from remainder */
    p->next = NULL;
  10f8f0:	8b 45 08             	mov    0x8(%ebp),%eax
  10f8f3:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    /* total length of pbuf p is its own length only */
    p->tot_len = p->len;
  10f8f9:	8b 45 08             	mov    0x8(%ebp),%eax
  10f8fc:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
  10f900:	8b 45 08             	mov    0x8(%ebp),%eax
  10f903:	66 89 50 08          	mov    %dx,0x8(%eax)
    /* q is no longer referenced by p, free it */
    LWIP_DEBUGF(PBUF_DEBUG | DBG_STATE, ("pbuf_dechain: unreferencing %p\n", (void *)q));
    tail_gone = pbuf_free(q);
  10f907:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10f90a:	89 04 24             	mov    %eax,(%esp)
  10f90d:	e8 9e fb ff ff       	call   10f4b0 <pbuf_free>
  10f912:	88 45 ff             	mov    %al,0xffffffff(%ebp)
    if (tail_gone > 0) LWIP_DEBUGF(PBUF_DEBUG | DBG_STATE,
      ("pbuf_dechain: deallocated %p (as it is no longer referenced)\n", (void *)q));
    /* return remaining tail or NULL if deallocated */
  }
  /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
  LWIP_ASSERT("p->tot_len == p->len", p->tot_len == p->len);
  return (tail_gone > 0? NULL: q);
  10f915:	80 7d ff 00          	cmpb   $0x0,0xffffffff(%ebp)
  10f919:	75 08                	jne    10f923 <pbuf_dechain+0x63>
  10f91b:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10f91e:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  10f921:	eb 07                	jmp    10f92a <pbuf_dechain+0x6a>
  10f923:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  10f92a:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  10f92d:	c9                   	leave  
  10f92e:	c3                   	ret    
  10f92f:	90                   	nop    

0010f930 <raw_init>:


void
raw_init(void)
{
  10f930:	55                   	push   %ebp
  10f931:	89 e5                	mov    %esp,%ebp
  raw_pcbs = NULL;
  10f933:	c7 05 e8 98 13 00 00 	movl   $0x0,0x1398e8
  10f93a:	00 00 00 
}
  10f93d:	5d                   	pop    %ebp
  10f93e:	c3                   	ret    
  10f93f:	90                   	nop    

0010f940 <raw_input>:

/**
 * Determine if in incoming IP packet is covered by a RAW pcb and
 * and process it if possible
 *
 * Given an incoming IP datagram (as a chain of pbufs) this function
 * finds a corresponding RAW PCB and
 *
 * @param pbuf pbuf to be demultiplexed to a RAW PCB.
 * @param netif network interface on which the datagram was received.
 * @return 0 if packet is not eated (pbuf needs to be freed then)
 *         or 1 if the packet has been eaten (pbuf needs not to be freed
 *         then)
 *
 */
int
raw_input(struct pbuf *p, struct netif *inp)
{
  10f940:	55                   	push   %ebp
  10f941:	89 e5                	mov    %esp,%ebp
  10f943:	53                   	push   %ebx
  10f944:	83 ec 24             	sub    $0x24,%esp
  struct raw_pcb *pcb;
  struct ip_hdr *iphdr;
  int proto;
  int rc = 0;
  10f947:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)

  iphdr = p->payload;
  10f94e:	8b 45 08             	mov    0x8(%ebp),%eax
  10f951:	8b 40 04             	mov    0x4(%eax),%eax
  10f954:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
  proto = IPH_PROTO(iphdr);
  10f957:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10f95a:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  10f95e:	0f b7 c0             	movzwl %ax,%eax
  10f961:	89 04 24             	mov    %eax,(%esp)
  10f964:	e8 37 e9 ff ff       	call   10e2a0 <ntohs>
  10f969:	0f b7 c0             	movzwl %ax,%eax
  10f96c:	25 ff 00 00 00       	and    $0xff,%eax
  10f971:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)

  for(pcb = raw_pcbs; pcb != NULL; pcb = pcb->next) {
  10f974:	a1 e8 98 13 00       	mov    0x1398e8,%eax
  10f979:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  10f97c:	eb 6c                	jmp    10f9ea <raw_input+0xaa>
    if (pcb->protocol == proto) {
  10f97e:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10f981:	0f b7 40 10          	movzwl 0x10(%eax),%eax
  10f985:	0f b7 c0             	movzwl %ax,%eax
  10f988:	3b 45 f4             	cmp    0xfffffff4(%ebp),%eax
  10f98b:	75 54                	jne    10f9e1 <raw_input+0xa1>
      if (pcb->recv) {
  10f98d:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10f990:	8b 40 14             	mov    0x14(%eax),%eax
  10f993:	85 c0                	test   %eax,%eax
  10f995:	74 36                	je     10f9cd <raw_input+0x8d>
        if (!pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src)))
  10f997:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10f99a:	8b 48 14             	mov    0x14(%eax),%ecx
  10f99d:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
  10f9a0:	83 c2 0c             	add    $0xc,%edx
  10f9a3:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10f9a6:	8b 58 18             	mov    0x18(%eax),%ebx
  10f9a9:	89 54 24 0c          	mov    %edx,0xc(%esp)
  10f9ad:	8b 45 08             	mov    0x8(%ebp),%eax
  10f9b0:	89 44 24 08          	mov    %eax,0x8(%esp)
  10f9b4:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10f9b7:	89 44 24 04          	mov    %eax,0x4(%esp)
  10f9bb:	89 1c 24             	mov    %ebx,(%esp)
  10f9be:	ff d1                	call   *%ecx
  10f9c0:	85 c0                	test   %eax,%eax
  10f9c2:	75 09                	jne    10f9cd <raw_input+0x8d>
          return 0;
  10f9c4:	c7 45 e8 00 00 00 00 	movl   $0x0,0xffffffe8(%ebp)
  10f9cb:	eb 29                	jmp    10f9f6 <raw_input+0xb6>
      }
      pbuf_free(p);
  10f9cd:	8b 45 08             	mov    0x8(%ebp),%eax
  10f9d0:	89 04 24             	mov    %eax,(%esp)
  10f9d3:	e8 d8 fa ff ff       	call   10f4b0 <pbuf_free>
      rc = 1;
  10f9d8:	c7 45 f8 01 00 00 00 	movl   $0x1,0xfffffff8(%ebp)
      break;
  10f9df:	eb 0f                	jmp    10f9f0 <raw_input+0xb0>
  10f9e1:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10f9e4:	8b 40 0c             	mov    0xc(%eax),%eax
  10f9e7:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  10f9ea:	83 7d ec 00          	cmpl   $0x0,0xffffffec(%ebp)
  10f9ee:	75 8e                	jne    10f97e <raw_input+0x3e>
    }
  }
  return rc;
  10f9f0:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10f9f3:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
  10f9f6:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
}
  10f9f9:	83 c4 24             	add    $0x24,%esp
  10f9fc:	5b                   	pop    %ebx
  10f9fd:	5d                   	pop    %ebp
  10f9fe:	c3                   	ret    
  10f9ff:	90                   	nop    

0010fa00 <raw_bind>:

/**
 * Bind a RAW PCB.
 *
 * @param pcb RAW PCB to be bound with a local address ipaddr.
 * @param ipaddr local IP address to bind with. Use IP_ADDR_ANY to
 * bind to all local interfaces.
 *
 * @return lwIP error code.
 * - ERR_OK. Successful. No error occured.
 * - ERR_USE. The specified ipaddr is already bound to by
 * another RAW PCB.
 *
 * @see raw_disconnect()
 */
err_t
raw_bind(struct raw_pcb *pcb, struct ip_addr *ipaddr)
{
  10fa00:	55                   	push   %ebp
  10fa01:	89 e5                	mov    %esp,%ebp
  10fa03:	83 ec 04             	sub    $0x4,%esp
  ip_addr_set(&pcb->local_ip, ipaddr);
  10fa06:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  10fa0a:	74 0a                	je     10fa16 <raw_bind+0x16>
  10fa0c:	8b 45 0c             	mov    0xc(%ebp),%eax
  10fa0f:	8b 00                	mov    (%eax),%eax
  10fa11:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  10fa14:	eb 07                	jmp    10fa1d <raw_bind+0x1d>
  10fa16:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
  10fa1d:	8b 45 08             	mov    0x8(%ebp),%eax
  10fa20:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  10fa23:	89 10                	mov    %edx,(%eax)
  return ERR_OK;
  10fa25:	b8 00 00 00 00       	mov    $0x0,%eax
}
  10fa2a:	c9                   	leave  
  10fa2b:	c3                   	ret    
  10fa2c:	8d 74 26 00          	lea    0x0(%esi),%esi

0010fa30 <raw_connect>:

/**
 * Connect an RAW PCB. This function is required by upper layers
 * of lwip. Using the raw api you could use raw_send_to() instead
 *
 * This will associate the RAW PCB with the remote address.
 *
 * @param pcb RAW PCB to be connected with remote address ipaddr and port.
 * @param ipaddr remote IP address to connect with.
 *
 * @return lwIP error code
 *
 * @see raw_disconnect() and raw_send_to()
 */
err_t
raw_connect(struct raw_pcb *pcb, struct ip_addr *ipaddr)
{
  10fa30:	55                   	push   %ebp
  10fa31:	89 e5                	mov    %esp,%ebp
  10fa33:	83 ec 04             	sub    $0x4,%esp
  ip_addr_set(&pcb->remote_ip, ipaddr);
  10fa36:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  10fa3a:	74 0a                	je     10fa46 <raw_connect+0x16>
  10fa3c:	8b 45 0c             	mov    0xc(%ebp),%eax
  10fa3f:	8b 00                	mov    (%eax),%eax
  10fa41:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  10fa44:	eb 07                	jmp    10fa4d <raw_connect+0x1d>
  10fa46:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
  10fa4d:	8b 45 08             	mov    0x8(%ebp),%eax
  10fa50:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  10fa53:	89 50 04             	mov    %edx,0x4(%eax)
  return ERR_OK;
  10fa56:	b8 00 00 00 00       	mov    $0x0,%eax
}
  10fa5b:	c9                   	leave  
  10fa5c:	c3                   	ret    
  10fa5d:	8d 76 00             	lea    0x0(%esi),%esi

0010fa60 <raw_recv>:


/**
 * Set the callback function if a RAW packet with the pcb's protocol
 * is received. If the callback function returns a value unequal 0
 * the raw packet is "eaten" and not forwarded to any other raw pcb
 * including lwip itself
 */
void
raw_recv(struct raw_pcb *pcb,
         int (* recv)(void *arg, struct raw_pcb *upcb, struct pbuf *p,
                      struct ip_addr *addr),
         void *recv_arg)
{
  10fa60:	55                   	push   %ebp
  10fa61:	89 e5                	mov    %esp,%ebp
  /* remember recv() callback and user data */
  pcb->recv = recv;
  10fa63:	8b 55 08             	mov    0x8(%ebp),%edx
  10fa66:	8b 45 0c             	mov    0xc(%ebp),%eax
  10fa69:	89 42 14             	mov    %eax,0x14(%edx)
  pcb->recv_arg = recv_arg;
  10fa6c:	8b 55 08             	mov    0x8(%ebp),%edx
  10fa6f:	8b 45 10             	mov    0x10(%ebp),%eax
  10fa72:	89 42 18             	mov    %eax,0x18(%edx)
}
  10fa75:	5d                   	pop    %ebp
  10fa76:	c3                   	ret    
  10fa77:	89 f6                	mov    %esi,%esi
  10fa79:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

0010fa80 <raw_send_to>:

/**
 * Send the raw IP packet to the given address. Note that actually you cannot
 * modify the IP headers (this is inconsitent with the receive callback where
 * you actually get the IP headers), you can only specifiy the ip payload here.
 * It requires some more changes in LWIP. (there will be a raw_send() function
 * then)
 *
 * @param pcb the raw pcb which to send
 * @param p the ip payload to send
 * @param ipaddr the destination address of the whole IP packet
 *
 */
err_t
raw_send_to(struct raw_pcb *pcb, struct pbuf *p, struct ip_addr *ipaddr)
{
  10fa80:	55                   	push   %ebp
  10fa81:	89 e5                	mov    %esp,%ebp
  10fa83:	53                   	push   %ebx
  10fa84:	83 ec 34             	sub    $0x34,%esp
  err_t err;
  struct netif *netif;
  struct ip_addr *src_ip;
  struct pbuf *q; /* q will be sent down the stack */
  
  LWIP_DEBUGF(RAW_DEBUG | DBG_TRACE | 3, ("raw_send_to\n"));
  
  /* not enough space to add an IP header to first pbuf in given p chain? */
  if (pbuf_header(p, IP_HLEN)) {
  10fa87:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  10fa8e:	00 
  10fa8f:	8b 45 0c             	mov    0xc(%ebp),%eax
  10fa92:	89 04 24             	mov    %eax,(%esp)
  10fa95:	e8 16 f9 ff ff       	call   10f3b0 <pbuf_header>
  10fa9a:	84 c0                	test   %al,%al
  10fa9c:	74 45                	je     10fae3 <raw_send_to+0x63>
    /* allocate header in new pbuf */
    q = pbuf_alloc(PBUF_IP, 0, PBUF_RAM);
  10fa9e:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  10faa5:	00 
  10faa6:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  10faad:	00 
  10faae:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  10fab5:	e8 16 f5 ff ff       	call   10efd0 <pbuf_alloc>
  10faba:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
  10fabd:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  10fac1:	75 0c                	jne    10facf <raw_send_to+0x4f>
      LWIP_DEBUGF(RAW_DEBUG | DBG_TRACE | 2, ("raw_send_to: could not allocate header\n"));
      return ERR_MEM;
  10fac3:	c7 45 e8 ff ff ff ff 	movl   $0xffffffff,0xffffffe8(%ebp)
  10faca:	e9 e8 00 00 00       	jmp    10fbb7 <raw_send_to+0x137>
    }
    /* chain header q in front of given pbuf p */
    pbuf_chain(q, p);
  10facf:	8b 45 0c             	mov    0xc(%ebp),%eax
  10fad2:	89 44 24 04          	mov    %eax,0x4(%esp)
  10fad6:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10fad9:	89 04 24             	mov    %eax,(%esp)
  10fadc:	e8 cf fb ff ff       	call   10f6b0 <pbuf_chain>
  10fae1:	eb 19                	jmp    10fafc <raw_send_to+0x7c>
    /* { first pbuf q points to header pbuf } */
    LWIP_DEBUGF(RAW_DEBUG, ("raw_send_to: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
  }  else {
    /* first pbuf q equals given pbuf */
    q = p;
  10fae3:	8b 45 0c             	mov    0xc(%ebp),%eax
  10fae6:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
    pbuf_header(q, -IP_HLEN);
  10fae9:	c7 44 24 04 ec ff ff 	movl   $0xffffffec,0x4(%esp)
  10faf0:	ff 
  10faf1:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10faf4:	89 04 24             	mov    %eax,(%esp)
  10faf7:	e8 b4 f8 ff ff       	call   10f3b0 <pbuf_header>
  }
  
  if ((netif = ip_route(ipaddr)) == NULL) {
  10fafc:	8b 45 10             	mov    0x10(%ebp),%eax
  10faff:	89 04 24             	mov    %eax,(%esp)
  10fb02:	e8 e9 cf ff ff       	call   10caf0 <ip_route>
  10fb07:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
  10fb0a:	83 7d f0 00          	cmpl   $0x0,0xfffffff0(%ebp)
  10fb0e:	75 1f                	jne    10fb2f <raw_send_to+0xaf>
    LWIP_DEBUGF(RAW_DEBUG | 1, ("raw_send_to: No route to 0x%lx\n", ipaddr->addr));
#if RAW_STATS
    /*    ++lwip_stats.raw.rterr;*/
#endif /* RAW_STATS */
    if (q != p) {
  10fb10:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10fb13:	3b 45 0c             	cmp    0xc(%ebp),%eax
  10fb16:	74 0b                	je     10fb23 <raw_send_to+0xa3>
      pbuf_free(q);
  10fb18:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10fb1b:	89 04 24             	mov    %eax,(%esp)
  10fb1e:	e8 8d f9 ff ff       	call   10f4b0 <pbuf_free>
    }
    return ERR_RTE;
  10fb23:	c7 45 e8 f7 ff ff ff 	movl   $0xfffffff7,0xffffffe8(%ebp)
  10fb2a:	e9 88 00 00 00       	jmp    10fbb7 <raw_send_to+0x137>
  }

  if (ip_addr_isany(&pcb->local_ip)) {
  10fb2f:	8b 45 08             	mov    0x8(%ebp),%eax
  10fb32:	85 c0                	test   %eax,%eax
  10fb34:	74 09                	je     10fb3f <raw_send_to+0xbf>
  10fb36:	8b 45 08             	mov    0x8(%ebp),%eax
  10fb39:	8b 00                	mov    (%eax),%eax
  10fb3b:	85 c0                	test   %eax,%eax
  10fb3d:	75 0b                	jne    10fb4a <raw_send_to+0xca>
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
  10fb3f:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10fb42:	83 c0 04             	add    $0x4,%eax
  10fb45:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  10fb48:	eb 06                	jmp    10fb50 <raw_send_to+0xd0>
  } else {
    /* use RAW PCB local IP address as source address */
    src_ip = &(pcb->local_ip);
  10fb4a:	8b 45 08             	mov    0x8(%ebp),%eax
  10fb4d:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  }

  err = ip_output_if (q, src_ip, ipaddr, pcb->ttl, pcb->tos, pcb->protocol, netif);
  10fb50:	8b 45 08             	mov    0x8(%ebp),%eax
  10fb53:	0f b7 40 10          	movzwl 0x10(%eax),%eax
  10fb57:	0f b6 c8             	movzbl %al,%ecx
  10fb5a:	8b 45 08             	mov    0x8(%ebp),%eax
  10fb5d:	0f b6 40 0a          	movzbl 0xa(%eax),%eax
  10fb61:	0f b6 d8             	movzbl %al,%ebx
  10fb64:	8b 45 08             	mov    0x8(%ebp),%eax
  10fb67:	0f b6 40 0b          	movzbl 0xb(%eax),%eax
  10fb6b:	0f b6 d0             	movzbl %al,%edx
  10fb6e:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10fb71:	89 44 24 18          	mov    %eax,0x18(%esp)
  10fb75:	89 4c 24 14          	mov    %ecx,0x14(%esp)
  10fb79:	89 5c 24 10          	mov    %ebx,0x10(%esp)
  10fb7d:	89 54 24 0c          	mov    %edx,0xc(%esp)
  10fb81:	8b 45 10             	mov    0x10(%ebp),%eax
  10fb84:	89 44 24 08          	mov    %eax,0x8(%esp)
  10fb88:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10fb8b:	89 44 24 04          	mov    %eax,0x4(%esp)
  10fb8f:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10fb92:	89 04 24             	mov    %eax,(%esp)
  10fb95:	e8 c6 d3 ff ff       	call   10cf60 <ip_output_if>
  10fb9a:	88 45 ef             	mov    %al,0xffffffef(%ebp)

  /* did we chain a header earlier? */
  if (q != p) {
  10fb9d:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10fba0:	3b 45 0c             	cmp    0xc(%ebp),%eax
  10fba3:	74 0b                	je     10fbb0 <raw_send_to+0x130>
    /* free the header */
    pbuf_free(q);
  10fba5:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10fba8:	89 04 24             	mov    %eax,(%esp)
  10fbab:	e8 00 f9 ff ff       	call   10f4b0 <pbuf_free>
  }
  return err;
  10fbb0:	0f be 45 ef          	movsbl 0xffffffef(%ebp),%eax
  10fbb4:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
  10fbb7:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
}
  10fbba:	83 c4 34             	add    $0x34,%esp
  10fbbd:	5b                   	pop    %ebx
  10fbbe:	5d                   	pop    %ebp
  10fbbf:	c3                   	ret    

0010fbc0 <raw_send>:

/**
 * Send the raw IP packet to the address given by raw_connect()
 *
 * @param pcb the raw pcb which to send
 * @param p the ip payload to send
 * @param ipaddr the destination address of the whole IP packet
 *
 */
err_t
raw_send(struct raw_pcb *pcb, struct pbuf *p)
{
  10fbc0:	55                   	push   %ebp
  10fbc1:	89 e5                	mov    %esp,%ebp
  10fbc3:	83 ec 18             	sub    $0x18,%esp
  return raw_send_to(pcb,p,&pcb->remote_ip);
  10fbc6:	8b 45 08             	mov    0x8(%ebp),%eax
  10fbc9:	83 c0 04             	add    $0x4,%eax
  10fbcc:	89 44 24 08          	mov    %eax,0x8(%esp)
  10fbd0:	8b 45 0c             	mov    0xc(%ebp),%eax
  10fbd3:	89 44 24 04          	mov    %eax,0x4(%esp)
  10fbd7:	8b 45 08             	mov    0x8(%ebp),%eax
  10fbda:	89 04 24             	mov    %eax,(%esp)
  10fbdd:	e8 9e fe ff ff       	call   10fa80 <raw_send_to>
  10fbe2:	0f be c0             	movsbl %al,%eax
}
  10fbe5:	c9                   	leave  
  10fbe6:	c3                   	ret    
  10fbe7:	89 f6                	mov    %esi,%esi
  10fbe9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

0010fbf0 <raw_remove>:

/**
 * Remove an RAW PCB.
 *
 * @param pcb RAW PCB to be removed. The PCB is removed from the list of
 * RAW PCB's and the data structure is freed from memory.
 *
 * @see raw_new()
 */
void
raw_remove(struct raw_pcb *pcb)
{
  10fbf0:	55                   	push   %ebp
  10fbf1:	89 e5                	mov    %esp,%ebp
  10fbf3:	83 ec 18             	sub    $0x18,%esp
  struct raw_pcb *pcb2;
  /* pcb to be removed is first in list? */
  if (raw_pcbs == pcb) {
  10fbf6:	a1 e8 98 13 00       	mov    0x1398e8,%eax
  10fbfb:	3b 45 08             	cmp    0x8(%ebp),%eax
  10fbfe:	75 0f                	jne    10fc0f <raw_remove+0x1f>
    /* make list start at 2nd pcb */
    raw_pcbs = raw_pcbs->next;
  10fc00:	a1 e8 98 13 00       	mov    0x1398e8,%eax
  10fc05:	8b 40 0c             	mov    0xc(%eax),%eax
  10fc08:	a3 e8 98 13 00       	mov    %eax,0x1398e8
  10fc0d:	eb 3a                	jmp    10fc49 <raw_remove+0x59>
  /* pcb not 1st in list */
  } else for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  10fc0f:	a1 e8 98 13 00       	mov    0x1398e8,%eax
  10fc14:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  10fc17:	eb 2a                	jmp    10fc43 <raw_remove+0x53>
    /* find pcb in raw_pcbs list */
    if (pcb2->next != NULL && pcb2->next == pcb) {
  10fc19:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10fc1c:	8b 40 0c             	mov    0xc(%eax),%eax
  10fc1f:	85 c0                	test   %eax,%eax
  10fc21:	74 17                	je     10fc3a <raw_remove+0x4a>
  10fc23:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10fc26:	8b 40 0c             	mov    0xc(%eax),%eax
  10fc29:	3b 45 08             	cmp    0x8(%ebp),%eax
  10fc2c:	75 0c                	jne    10fc3a <raw_remove+0x4a>
      /* remove pcb from list */
      pcb2->next = pcb->next;
  10fc2e:	8b 45 08             	mov    0x8(%ebp),%eax
  10fc31:	8b 50 0c             	mov    0xc(%eax),%edx
  10fc34:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10fc37:	89 50 0c             	mov    %edx,0xc(%eax)
  10fc3a:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10fc3d:	8b 40 0c             	mov    0xc(%eax),%eax
  10fc40:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  10fc43:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  10fc47:	75 d0                	jne    10fc19 <raw_remove+0x29>
    }
  }
  memp_free(MEMP_RAW_PCB, pcb);
  10fc49:	8b 45 08             	mov    0x8(%ebp),%eax
  10fc4c:	89 44 24 04          	mov    %eax,0x4(%esp)
  10fc50:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  10fc57:	e8 54 ee ff ff       	call   10eab0 <memp_free>
}
  10fc5c:	c9                   	leave  
  10fc5d:	c3                   	ret    
  10fc5e:	89 f6                	mov    %esi,%esi

0010fc60 <raw_new>:

/**
 * Create a RAW PCB.
 *
 * @return The RAW PCB which was created. NULL if the PCB data structure
 * could not be allocated.
 *
 * @param proto the protocol number of the IPs payload (e.g. IP_PROTO_ICMP)
 *
 * @see raw_remove()
 */
struct raw_pcb *
raw_new(u16_t proto) {
  10fc60:	55                   	push   %ebp
  10fc61:	89 e5                	mov    %esp,%ebp
  10fc63:	83 ec 28             	sub    $0x28,%esp
  10fc66:	8b 45 08             	mov    0x8(%ebp),%eax
  10fc69:	66 89 45 ec          	mov    %ax,0xffffffec(%ebp)
  struct raw_pcb *pcb;

  LWIP_DEBUGF(RAW_DEBUG | DBG_TRACE | 3, ("raw_new\n"));

  pcb = memp_malloc(MEMP_RAW_PCB);
  10fc6d:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  10fc74:	e8 47 ed ff ff       	call   10e9c0 <memp_malloc>
  10fc79:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  /* could allocate RAW PCB? */
  if (pcb != NULL) {
  10fc7c:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  10fc80:	74 41                	je     10fcc3 <raw_new+0x63>
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct raw_pcb));
  10fc82:	c7 44 24 08 1c 00 00 	movl   $0x1c,0x8(%esp)
  10fc89:	00 
  10fc8a:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  10fc91:	00 
  10fc92:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10fc95:	89 04 24             	mov    %eax,(%esp)
  10fc98:	e8 63 62 ff ff       	call   105f00 <memset>
    pcb->protocol = proto;
  10fc9d:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  10fca0:	0f b7 45 ec          	movzwl 0xffffffec(%ebp),%eax
  10fca4:	66 89 42 10          	mov    %ax,0x10(%edx)
    pcb->ttl = RAW_TTL;
  10fca8:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10fcab:	c6 40 0b ff          	movb   $0xff,0xb(%eax)
    pcb->next = raw_pcbs;
  10fcaf:	8b 15 e8 98 13 00    	mov    0x1398e8,%edx
  10fcb5:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10fcb8:	89 50 0c             	mov    %edx,0xc(%eax)
    raw_pcbs = pcb;
  10fcbb:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10fcbe:	a3 e8 98 13 00       	mov    %eax,0x1398e8
  }

  return pcb;
  10fcc3:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
}
  10fcc6:	c9                   	leave  
  10fcc7:	c3                   	ret    
  10fcc8:	90                   	nop    
  10fcc9:	90                   	nop    
  10fcca:	90                   	nop    
  10fccb:	90                   	nop    
  10fccc:	90                   	nop    
  10fccd:	90                   	nop    
  10fcce:	90                   	nop    
  10fccf:	90                   	nop    

0010fcd0 <stats_init>:
struct stats_ lwip_stats;

void
stats_init(void)
{
  10fcd0:	55                   	push   %ebp
  10fcd1:	89 e5                	mov    %esp,%ebp
  10fcd3:	83 ec 18             	sub    $0x18,%esp
  memset(&lwip_stats, 0, sizeof(struct stats_));
  10fcd6:	c7 44 24 08 74 01 00 	movl   $0x174,0x8(%esp)
  10fcdd:	00 
  10fcde:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  10fce5:	00 
  10fce6:	c7 04 24 e0 14 14 00 	movl   $0x1414e0,(%esp)
  10fced:	e8 0e 62 ff ff       	call   105f00 <memset>
}
  10fcf2:	c9                   	leave  
  10fcf3:	c3                   	ret    
  10fcf4:	90                   	nop    
  10fcf5:	90                   	nop    
  10fcf6:	90                   	nop    
  10fcf7:	90                   	nop    
  10fcf8:	90                   	nop    
  10fcf9:	90                   	nop    
  10fcfa:	90                   	nop    
  10fcfb:	90                   	nop    
  10fcfc:	90                   	nop    
  10fcfd:	90                   	nop    
  10fcfe:	90                   	nop    
  10fcff:	90                   	nop    

0010fd00 <sys_mbox_fetch>:


void
sys_mbox_fetch(sys_mbox_t mbox, void **msg)
{
  10fd00:	55                   	push   %ebp
  10fd01:	89 e5                	mov    %esp,%ebp
  10fd03:	83 ec 38             	sub    $0x38,%esp
  u32_t time;
  struct sys_timeouts *timeouts;
  struct sys_timeout *tmptimeout;
  sys_timeout_handler h;
  void *arg;


 again:
  timeouts = sys_arch_timeouts();
  10fd06:	e8 65 a4 00 00       	call   11a170 <sys_arch_timeouts>
  10fd0b:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)

  if (!timeouts || !timeouts->next) {
  10fd0e:	83 7d f0 00          	cmpl   $0x0,0xfffffff0(%ebp)
  10fd12:	74 09                	je     10fd1d <sys_mbox_fetch+0x1d>
  10fd14:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10fd17:	8b 00                	mov    (%eax),%eax
  10fd19:	85 c0                	test   %eax,%eax
  10fd1b:	75 1f                	jne    10fd3c <sys_mbox_fetch+0x3c>
    sys_arch_mbox_fetch(mbox, msg, 0);
  10fd1d:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  10fd24:	00 
  10fd25:	8b 45 0c             	mov    0xc(%ebp),%eax
  10fd28:	89 44 24 04          	mov    %eax,0x4(%esp)
  10fd2c:	8b 45 08             	mov    0x8(%ebp),%eax
  10fd2f:	89 04 24             	mov    %eax,(%esp)
  10fd32:	e8 f9 a2 00 00       	call   11a030 <sys_arch_mbox_fetch>
  10fd37:	e9 bb 00 00 00       	jmp    10fdf7 <sys_mbox_fetch+0xf7>
  } else {
    if (timeouts->next->time > 0) {
  10fd3c:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10fd3f:	8b 00                	mov    (%eax),%eax
  10fd41:	8b 40 04             	mov    0x4(%eax),%eax
  10fd44:	85 c0                	test   %eax,%eax
  10fd46:	74 23                	je     10fd6b <sys_mbox_fetch+0x6b>
      time = sys_arch_mbox_fetch(mbox, msg, timeouts->next->time);
  10fd48:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10fd4b:	8b 00                	mov    (%eax),%eax
  10fd4d:	8b 40 04             	mov    0x4(%eax),%eax
  10fd50:	89 44 24 08          	mov    %eax,0x8(%esp)
  10fd54:	8b 45 0c             	mov    0xc(%ebp),%eax
  10fd57:	89 44 24 04          	mov    %eax,0x4(%esp)
  10fd5b:	8b 45 08             	mov    0x8(%ebp),%eax
  10fd5e:	89 04 24             	mov    %eax,(%esp)
  10fd61:	e8 ca a2 00 00       	call   11a030 <sys_arch_mbox_fetch>
  10fd66:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  10fd69:	eb 07                	jmp    10fd72 <sys_mbox_fetch+0x72>
    } else {
      time = SYS_ARCH_TIMEOUT;
  10fd6b:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
    }

    if (time == SYS_ARCH_TIMEOUT) {
  10fd72:	83 7d ec ff          	cmpl   $0xffffffff,0xffffffec(%ebp)
  10fd76:	75 51                	jne    10fdc9 <sys_mbox_fetch+0xc9>
      /* If time == SYS_ARCH_TIMEOUT, a timeout occured before a message
   could be fetched. We should now call the timeout handler and
   deallocate the memory allocated for the timeout. */
      tmptimeout = timeouts->next;
  10fd78:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10fd7b:	8b 00                	mov    (%eax),%eax
  10fd7d:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
      timeouts->next = tmptimeout->next;
  10fd80:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10fd83:	8b 10                	mov    (%eax),%edx
  10fd85:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10fd88:	89 10                	mov    %edx,(%eax)
      h = tmptimeout->h;
  10fd8a:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10fd8d:	8b 40 08             	mov    0x8(%eax),%eax
  10fd90:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
      arg = tmptimeout->arg;
  10fd93:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10fd96:	8b 40 0c             	mov    0xc(%eax),%eax
  10fd99:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
      memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
  10fd9c:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10fd9f:	89 44 24 04          	mov    %eax,0x4(%esp)
  10fda3:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
  10fdaa:	e8 01 ed ff ff       	call   10eab0 <memp_free>
      if (h != NULL) {
  10fdaf:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  10fdb3:	0f 84 4d ff ff ff    	je     10fd06 <sys_mbox_fetch+0x6>
        LWIP_DEBUGF(SYS_DEBUG, ("smf calling h=%p(%p)\n", (void *)h, (void *)arg));
      	h(arg);
  10fdb9:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10fdbc:	89 04 24             	mov    %eax,(%esp)
  10fdbf:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10fdc2:	ff d0                	call   *%eax
      }

      /* We try again to fetch a message from the mbox. */
      goto again;
  10fdc4:	e9 3d ff ff ff       	jmp    10fd06 <sys_mbox_fetch+0x6>
    } else {
      /* If time != SYS_ARCH_TIMEOUT, a message was received before the timeout
   occured. The time variable is set to the number of
   milliseconds we waited for the message. */
      if (time <= timeouts->next->time) {
  10fdc9:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10fdcc:	8b 00                	mov    (%eax),%eax
  10fdce:	8b 40 04             	mov    0x4(%eax),%eax
  10fdd1:	3b 45 ec             	cmp    0xffffffec(%ebp),%eax
  10fdd4:	72 15                	jb     10fdeb <sys_mbox_fetch+0xeb>
  timeouts->next->time -= time;
  10fdd6:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10fdd9:	8b 10                	mov    (%eax),%edx
  10fddb:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10fdde:	8b 00                	mov    (%eax),%eax
  10fde0:	8b 40 04             	mov    0x4(%eax),%eax
  10fde3:	2b 45 ec             	sub    0xffffffec(%ebp),%eax
  10fde6:	89 42 04             	mov    %eax,0x4(%edx)
  10fde9:	eb 0c                	jmp    10fdf7 <sys_mbox_fetch+0xf7>
      } else {
  timeouts->next->time = 0;
  10fdeb:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10fdee:	8b 00                	mov    (%eax),%eax
  10fdf0:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
      }
    }

  }
}
  10fdf7:	c9                   	leave  
  10fdf8:	c3                   	ret    
  10fdf9:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

0010fe00 <sys_sem_wait>:

void
sys_sem_wait(sys_sem_t sem)
{
  10fe00:	55                   	push   %ebp
  10fe01:	89 e5                	mov    %esp,%ebp
  10fe03:	83 ec 28             	sub    $0x28,%esp
  u32_t time;
  struct sys_timeouts *timeouts;
  struct sys_timeout *tmptimeout;
  sys_timeout_handler h;
  void *arg;

  /*  while (sys_arch_sem_wait(sem, 1000) == 0);
      return;*/

 again:

  timeouts = sys_arch_timeouts();
  10fe06:	e8 65 a3 00 00       	call   11a170 <sys_arch_timeouts>
  10fe0b:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)

  if (!timeouts || !timeouts->next) {
  10fe0e:	83 7d f0 00          	cmpl   $0x0,0xfffffff0(%ebp)
  10fe12:	74 09                	je     10fe1d <sys_sem_wait+0x1d>
  10fe14:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10fe17:	8b 00                	mov    (%eax),%eax
  10fe19:	85 c0                	test   %eax,%eax
  10fe1b:	75 18                	jne    10fe35 <sys_sem_wait+0x35>
    sys_arch_sem_wait(sem, 0);
  10fe1d:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  10fe24:	00 
  10fe25:	8b 45 08             	mov    0x8(%ebp),%eax
  10fe28:	89 04 24             	mov    %eax,(%esp)
  10fe2b:	e8 b0 9f 00 00       	call   119de0 <sys_arch_sem_wait>
  10fe30:	e9 b4 00 00 00       	jmp    10fee9 <sys_sem_wait+0xe9>
  } else {
    if (timeouts->next->time > 0) {
  10fe35:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10fe38:	8b 00                	mov    (%eax),%eax
  10fe3a:	8b 40 04             	mov    0x4(%eax),%eax
  10fe3d:	85 c0                	test   %eax,%eax
  10fe3f:	74 1c                	je     10fe5d <sys_sem_wait+0x5d>
      time = sys_arch_sem_wait(sem, timeouts->next->time);
  10fe41:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10fe44:	8b 00                	mov    (%eax),%eax
  10fe46:	8b 40 04             	mov    0x4(%eax),%eax
  10fe49:	89 44 24 04          	mov    %eax,0x4(%esp)
  10fe4d:	8b 45 08             	mov    0x8(%ebp),%eax
  10fe50:	89 04 24             	mov    %eax,(%esp)
  10fe53:	e8 88 9f 00 00       	call   119de0 <sys_arch_sem_wait>
  10fe58:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  10fe5b:	eb 07                	jmp    10fe64 <sys_sem_wait+0x64>
    } else {
      time = SYS_ARCH_TIMEOUT;
  10fe5d:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
    }

    if (time == SYS_ARCH_TIMEOUT) {
  10fe64:	83 7d ec ff          	cmpl   $0xffffffff,0xffffffec(%ebp)
  10fe68:	75 51                	jne    10febb <sys_sem_wait+0xbb>
      /* If time == SYS_ARCH_TIMEOUT, a timeout occured before a message
   could be fetched. We should now call the timeout handler and
   deallocate the memory allocated for the timeout. */
      tmptimeout = timeouts->next;
  10fe6a:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10fe6d:	8b 00                	mov    (%eax),%eax
  10fe6f:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
      timeouts->next = tmptimeout->next;
  10fe72:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10fe75:	8b 10                	mov    (%eax),%edx
  10fe77:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10fe7a:	89 10                	mov    %edx,(%eax)
      h = tmptimeout->h;
  10fe7c:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10fe7f:	8b 40 08             	mov    0x8(%eax),%eax
  10fe82:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
      arg = tmptimeout->arg;
  10fe85:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10fe88:	8b 40 0c             	mov    0xc(%eax),%eax
  10fe8b:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
      memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
  10fe8e:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10fe91:	89 44 24 04          	mov    %eax,0x4(%esp)
  10fe95:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
  10fe9c:	e8 0f ec ff ff       	call   10eab0 <memp_free>
      if (h != NULL) {
  10fea1:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  10fea5:	0f 84 5b ff ff ff    	je     10fe06 <sys_sem_wait+0x6>
        LWIP_DEBUGF(SYS_DEBUG, ("ssw h=%p(%p)\n", (void *)h, (void *)arg));
        h(arg);
  10feab:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10feae:	89 04 24             	mov    %eax,(%esp)
  10feb1:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10feb4:	ff d0                	call   *%eax
      }


      /* We try again to fetch a message from the mbox. */
      goto again;
  10feb6:	e9 4b ff ff ff       	jmp    10fe06 <sys_sem_wait+0x6>
    } else {
      /* If time != SYS_ARCH_TIMEOUT, a message was received before the timeout
   occured. The time variable is set to the number of
   milliseconds we waited for the message. */
      if (time <= timeouts->next->time) {
  10febb:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10febe:	8b 00                	mov    (%eax),%eax
  10fec0:	8b 40 04             	mov    0x4(%eax),%eax
  10fec3:	3b 45 ec             	cmp    0xffffffec(%ebp),%eax
  10fec6:	72 15                	jb     10fedd <sys_sem_wait+0xdd>
  timeouts->next->time -= time;
  10fec8:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10fecb:	8b 10                	mov    (%eax),%edx
  10fecd:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10fed0:	8b 00                	mov    (%eax),%eax
  10fed2:	8b 40 04             	mov    0x4(%eax),%eax
  10fed5:	2b 45 ec             	sub    0xffffffec(%ebp),%eax
  10fed8:	89 42 04             	mov    %eax,0x4(%edx)
  10fedb:	eb 0c                	jmp    10fee9 <sys_sem_wait+0xe9>
      } else {
  timeouts->next->time = 0;
  10fedd:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10fee0:	8b 00                	mov    (%eax),%eax
  10fee2:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
      }
    }

  }
}
  10fee9:	c9                   	leave  
  10feea:	c3                   	ret    
  10feeb:	90                   	nop    
  10feec:	8d 74 26 00          	lea    0x0(%esi),%esi

0010fef0 <sys_timeout>:

void
sys_timeout(u32_t msecs, sys_timeout_handler h, void *arg)
{
  10fef0:	55                   	push   %ebp
  10fef1:	89 e5                	mov    %esp,%ebp
  10fef3:	53                   	push   %ebx
  10fef4:	83 ec 14             	sub    $0x14,%esp
  struct sys_timeouts *timeouts;
  struct sys_timeout *timeout, *t;
  sys_timeout_handler y = h;
  10fef7:	8b 45 0c             	mov    0xc(%ebp),%eax
  10fefa:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)

  timeout = memp_malloc(MEMP_SYS_TIMEOUT);
  10fefd:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
  10ff04:	e8 b7 ea ff ff       	call   10e9c0 <memp_malloc>
  10ff09:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
  if (timeout == NULL) {
  10ff0c:	83 7d f0 00          	cmpl   $0x0,0xfffffff0(%ebp)
  10ff10:	0f 84 f9 00 00 00    	je     11000f <sys_timeout+0x11f>
    return;
  }
  timeout->next = NULL;
  10ff16:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10ff19:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  timeout->h = h;
  10ff1f:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
  10ff22:	8b 45 0c             	mov    0xc(%ebp),%eax
  10ff25:	89 42 08             	mov    %eax,0x8(%edx)
  timeout->arg = arg;
  10ff28:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
  10ff2b:	8b 45 10             	mov    0x10(%ebp),%eax
  10ff2e:	89 42 0c             	mov    %eax,0xc(%edx)
  timeout->time = msecs;
  10ff31:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
  10ff34:	8b 45 08             	mov    0x8(%ebp),%eax
  10ff37:	89 42 04             	mov    %eax,0x4(%edx)

  timeouts = sys_arch_timeouts();
  10ff3a:	e8 31 a2 00 00       	call   11a170 <sys_arch_timeouts>
  10ff3f:	89 45 ec             	mov    %eax,0xffffffec(%ebp)

  LWIP_DEBUGF(SYS_DEBUG, ("sys_timeout: %p msecs=%lu h=%p arg=%p\n",
    (void *)timeout, msecs, (void *)h, (void *)arg));

  LWIP_ASSERT("sys_timeout: timeouts != NULL", timeouts != NULL);

  if (timeouts->next == NULL) {
  10ff42:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10ff45:	8b 00                	mov    (%eax),%eax
  10ff47:	85 c0                	test   %eax,%eax
  10ff49:	75 0d                	jne    10ff58 <sys_timeout+0x68>
    timeouts->next = timeout;
  10ff4b:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
  10ff4e:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10ff51:	89 02                	mov    %eax,(%edx)
    return;
  10ff53:	e9 b7 00 00 00       	jmp    11000f <sys_timeout+0x11f>
  }

  if (timeouts->next->time > msecs) {
  10ff58:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10ff5b:	8b 00                	mov    (%eax),%eax
  10ff5d:	8b 40 04             	mov    0x4(%eax),%eax
  10ff60:	3b 45 08             	cmp    0x8(%ebp),%eax
  10ff63:	76 2a                	jbe    10ff8f <sys_timeout+0x9f>
    timeouts->next->time -= msecs;
  10ff65:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10ff68:	8b 10                	mov    (%eax),%edx
  10ff6a:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10ff6d:	8b 00                	mov    (%eax),%eax
  10ff6f:	8b 40 04             	mov    0x4(%eax),%eax
  10ff72:	2b 45 08             	sub    0x8(%ebp),%eax
  10ff75:	89 42 04             	mov    %eax,0x4(%edx)
    timeout->next = timeouts->next;
  10ff78:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10ff7b:	8b 10                	mov    (%eax),%edx
  10ff7d:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10ff80:	89 10                	mov    %edx,(%eax)
    timeouts->next = timeout;
  10ff82:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
  10ff85:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10ff88:	89 02                	mov    %eax,(%edx)
  10ff8a:	e9 80 00 00 00       	jmp    11000f <sys_timeout+0x11f>
  } else {
    for(t = timeouts->next; t != NULL; t = t->next) {
  10ff8f:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10ff92:	8b 00                	mov    (%eax),%eax
  10ff94:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  10ff97:	eb 70                	jmp    110009 <sys_timeout+0x119>
      timeout->time -= t->time;
  10ff99:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10ff9c:	8b 50 04             	mov    0x4(%eax),%edx
  10ff9f:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10ffa2:	8b 40 04             	mov    0x4(%eax),%eax
  10ffa5:	29 c2                	sub    %eax,%edx
  10ffa7:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10ffaa:	89 50 04             	mov    %edx,0x4(%eax)
      if (t->next == NULL || t->next->time > timeout->time) {
  10ffad:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10ffb0:	8b 00                	mov    (%eax),%eax
  10ffb2:	85 c0                	test   %eax,%eax
  10ffb4:	74 12                	je     10ffc8 <sys_timeout+0xd8>
  10ffb6:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10ffb9:	8b 00                	mov    (%eax),%eax
  10ffbb:	8b 50 04             	mov    0x4(%eax),%edx
  10ffbe:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10ffc1:	8b 40 04             	mov    0x4(%eax),%eax
  10ffc4:	39 c2                	cmp    %eax,%edx
  10ffc6:	76 39                	jbe    110001 <sys_timeout+0x111>
        if (t->next != NULL) {
  10ffc8:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10ffcb:	8b 00                	mov    (%eax),%eax
  10ffcd:	85 c0                	test   %eax,%eax
  10ffcf:	74 1c                	je     10ffed <sys_timeout+0xfd>
          t->next->time -= timeout->time;
  10ffd1:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10ffd4:	8b 08                	mov    (%eax),%ecx
  10ffd6:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10ffd9:	8b 00                	mov    (%eax),%eax
  10ffdb:	8b 50 04             	mov    0x4(%eax),%edx
  10ffde:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10ffe1:	8b 40 04             	mov    0x4(%eax),%eax
  10ffe4:	89 d3                	mov    %edx,%ebx
  10ffe6:	29 c3                	sub    %eax,%ebx
  10ffe8:	89 d8                	mov    %ebx,%eax
  10ffea:	89 41 04             	mov    %eax,0x4(%ecx)
        }
        timeout->next = t->next;
  10ffed:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10fff0:	8b 10                	mov    (%eax),%edx
  10fff2:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10fff5:	89 10                	mov    %edx,(%eax)
        t->next = timeout;
  10fff7:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
  10fffa:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10fffd:	89 02                	mov    %eax,(%edx)
        break;
  10ffff:	eb 0e                	jmp    11000f <sys_timeout+0x11f>
  110001:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  110004:	8b 00                	mov    (%eax),%eax
  110006:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  110009:	83 7d f4 00          	cmpl   $0x0,0xfffffff4(%ebp)
  11000d:	75 8a                	jne    10ff99 <sys_timeout+0xa9>
      }
    }
  }

}
  11000f:	83 c4 14             	add    $0x14,%esp
  110012:	5b                   	pop    %ebx
  110013:	5d                   	pop    %ebp
  110014:	c3                   	ret    
  110015:	8d 74 26 00          	lea    0x0(%esi),%esi
  110019:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00110020 <sys_untimeout>:

/* Go through timeout list (for this task only) and remove the first matching entry,
   even though the timeout has not triggered yet.
*/

void
sys_untimeout(sys_timeout_handler h, void *arg)
{
  110020:	55                   	push   %ebp
  110021:	89 e5                	mov    %esp,%ebp
  110023:	83 ec 18             	sub    $0x18,%esp
    struct sys_timeouts *timeouts;
    struct sys_timeout *prev_t, *t;

    timeouts = sys_arch_timeouts();
  110026:	e8 45 a1 00 00       	call   11a170 <sys_arch_timeouts>
  11002b:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)

    if (timeouts->next == NULL)
  11002e:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  110031:	8b 00                	mov    (%eax),%eax
  110033:	85 c0                	test   %eax,%eax
  110035:	0f 84 8e 00 00 00    	je     1100c9 <sys_untimeout+0xa9>
        return;

    for (t = timeouts->next, prev_t = NULL; t != NULL; prev_t = t, t = t->next)
  11003b:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  11003e:	8b 00                	mov    (%eax),%eax
  110040:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  110043:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)
  11004a:	eb 77                	jmp    1100c3 <sys_untimeout+0xa3>
    {
        if ((t->h == h) && (t->arg == arg))
  11004c:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  11004f:	8b 40 08             	mov    0x8(%eax),%eax
  110052:	3b 45 08             	cmp    0x8(%ebp),%eax
  110055:	75 5e                	jne    1100b5 <sys_untimeout+0x95>
  110057:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  11005a:	8b 40 0c             	mov    0xc(%eax),%eax
  11005d:	3b 45 0c             	cmp    0xc(%ebp),%eax
  110060:	75 53                	jne    1100b5 <sys_untimeout+0x95>
        {
            /* We have a match */
            /* Unlink from previous in list */
            if (prev_t == NULL)
  110062:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  110066:	75 0c                	jne    110074 <sys_untimeout+0x54>
                timeouts->next = t->next;
  110068:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  11006b:	8b 10                	mov    (%eax),%edx
  11006d:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  110070:	89 10                	mov    %edx,(%eax)
  110072:	eb 0a                	jmp    11007e <sys_untimeout+0x5e>
            else
                prev_t->next = t->next;
  110074:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  110077:	8b 10                	mov    (%eax),%edx
  110079:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  11007c:	89 10                	mov    %edx,(%eax)
            /* If not the last one, add time of this one back to next */
            if (t->next != NULL)
  11007e:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  110081:	8b 00                	mov    (%eax),%eax
  110083:	85 c0                	test   %eax,%eax
  110085:	74 19                	je     1100a0 <sys_untimeout+0x80>
                t->next->time += t->time;
  110087:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  11008a:	8b 08                	mov    (%eax),%ecx
  11008c:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  11008f:	8b 00                	mov    (%eax),%eax
  110091:	8b 50 04             	mov    0x4(%eax),%edx
  110094:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  110097:	8b 40 04             	mov    0x4(%eax),%eax
  11009a:	8d 04 02             	lea    (%edx,%eax,1),%eax
  11009d:	89 41 04             	mov    %eax,0x4(%ecx)
            memp_free(MEMP_SYS_TIMEOUT, t);
  1100a0:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1100a3:	89 44 24 04          	mov    %eax,0x4(%esp)
  1100a7:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
  1100ae:	e8 fd e9 ff ff       	call   10eab0 <memp_free>
            return;
  1100b3:	eb 14                	jmp    1100c9 <sys_untimeout+0xa9>
  1100b5:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1100b8:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  1100bb:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1100be:	8b 00                	mov    (%eax),%eax
  1100c0:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  1100c3:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  1100c7:	75 83                	jne    11004c <sys_untimeout+0x2c>
        }
    }
    return;
}
  1100c9:	c9                   	leave  
  1100ca:	c3                   	ret    
  1100cb:	90                   	nop    
  1100cc:	8d 74 26 00          	lea    0x0(%esi),%esi

001100d0 <sswt_handler>:





static void
sswt_handler(void *arg)
{
  1100d0:	55                   	push   %ebp
  1100d1:	89 e5                	mov    %esp,%ebp
  1100d3:	83 ec 18             	sub    $0x18,%esp
    struct sswt_cb *sswt_cb = (struct sswt_cb *) arg;
  1100d6:	8b 45 08             	mov    0x8(%ebp),%eax
  1100d9:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)

    /* Timeout. Set flag to TRUE and signal semaphore */
    sswt_cb->timeflag = 1;
  1100dc:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1100df:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    sys_sem_signal(*(sswt_cb->psem));
  1100e5:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1100e8:	8b 40 04             	mov    0x4(%eax),%eax
  1100eb:	8b 00                	mov    (%eax),%eax
  1100ed:	89 04 24             	mov    %eax,(%esp)
  1100f0:	e8 cb 9c 00 00       	call   119dc0 <sys_sem_signal>
}
  1100f5:	c9                   	leave  
  1100f6:	c3                   	ret    
  1100f7:	89 f6                	mov    %esi,%esi
  1100f9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00110100 <sys_sem_wait_timeout>:

/* Wait for a semaphore with timeout (specified in ms) */
/* timeout = 0: wait forever */
/* Returns 0 on timeout. 1 otherwise */

int
sys_sem_wait_timeout(sys_sem_t sem, u32_t timeout)
{
  110100:	55                   	push   %ebp
  110101:	89 e5                	mov    %esp,%ebp
  110103:	83 ec 28             	sub    $0x28,%esp
    struct sswt_cb sswt_cb;

    sswt_cb.psem = &sem;
  110106:	8d 45 08             	lea    0x8(%ebp),%eax
  110109:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
    sswt_cb.timeflag = 0;
  11010c:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)

    /* If timeout is zero, then just wait forever */
    if (timeout > 0)
  110113:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  110117:	74 1a                	je     110133 <sys_sem_wait_timeout+0x33>
        /* Create a timer and pass it the address of our flag */
        sys_timeout(timeout, sswt_handler, &sswt_cb);
  110119:	8d 45 f8             	lea    0xfffffff8(%ebp),%eax
  11011c:	89 44 24 08          	mov    %eax,0x8(%esp)
  110120:	c7 44 24 04 d0 00 11 	movl   $0x1100d0,0x4(%esp)
  110127:	00 
  110128:	8b 45 0c             	mov    0xc(%ebp),%eax
  11012b:	89 04 24             	mov    %eax,(%esp)
  11012e:	e8 bd fd ff ff       	call   10fef0 <sys_timeout>
    sys_sem_wait(sem);
  110133:	8b 45 08             	mov    0x8(%ebp),%eax
  110136:	89 04 24             	mov    %eax,(%esp)
  110139:	e8 c2 fc ff ff       	call   10fe00 <sys_sem_wait>
    /* Was it a timeout? */
    if (sswt_cb.timeflag)
  11013e:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  110141:	85 c0                	test   %eax,%eax
  110143:	74 09                	je     11014e <sys_sem_wait_timeout+0x4e>
    {
        /* timeout */
        return 0;
  110145:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  11014c:	eb 1a                	jmp    110168 <sys_sem_wait_timeout+0x68>
    } else {
        /* Not a timeout. Remove timeout entry */
        sys_untimeout(sswt_handler, &sswt_cb);
  11014e:	8d 45 f8             	lea    0xfffffff8(%ebp),%eax
  110151:	89 44 24 04          	mov    %eax,0x4(%esp)
  110155:	c7 04 24 d0 00 11 00 	movl   $0x1100d0,(%esp)
  11015c:	e8 bf fe ff ff       	call   110020 <sys_untimeout>
        return 1;
  110161:	c7 45 ec 01 00 00 00 	movl   $0x1,0xffffffec(%ebp)
  110168:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    }

}
  11016b:	c9                   	leave  
  11016c:	c3                   	ret    
  11016d:	8d 76 00             	lea    0x0(%esi),%esi

00110170 <sys_msleep>:


void
sys_msleep(u32_t ms)
{
  110170:	55                   	push   %ebp
  110171:	89 e5                	mov    %esp,%ebp
  110173:	83 ec 18             	sub    $0x18,%esp
  sys_sem_t delaysem = sys_sem_new(0);
  110176:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  11017d:	e8 be 9b 00 00       	call   119d40 <sys_sem_new>
  110182:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)

  sys_sem_wait_timeout(delaysem, ms);
  110185:	8b 45 08             	mov    0x8(%ebp),%eax
  110188:	89 44 24 04          	mov    %eax,0x4(%esp)
  11018c:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  11018f:	89 04 24             	mov    %eax,(%esp)
  110192:	e8 69 ff ff ff       	call   110100 <sys_sem_wait_timeout>

  sys_sem_free(delaysem);
  110197:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  11019a:	89 04 24             	mov    %eax,(%esp)
  11019d:	e8 ee 9b 00 00       	call   119d90 <sys_sem_free>
}
  1101a2:	c9                   	leave  
  1101a3:	c3                   	ret    
  1101a4:	90                   	nop    
  1101a5:	90                   	nop    
  1101a6:	90                   	nop    
  1101a7:	90                   	nop    
  1101a8:	90                   	nop    
  1101a9:	90                   	nop    
  1101aa:	90                   	nop    
  1101ab:	90                   	nop    
  1101ac:	90                   	nop    
  1101ad:	90                   	nop    
  1101ae:	90                   	nop    
  1101af:	90                   	nop    

001101b0 <tcp_init>:
 */

void
tcp_init(void)
{
  1101b0:	55                   	push   %ebp
  1101b1:	89 e5                	mov    %esp,%ebp
  /* Clear globals. */
  tcp_listen_pcbs.listen_pcbs = NULL;
  1101b3:	c7 05 5c 16 14 00 00 	movl   $0x0,0x14165c
  1101ba:	00 00 00 
  tcp_active_pcbs = NULL;
  1101bd:	c7 05 54 16 14 00 00 	movl   $0x0,0x141654
  1101c4:	00 00 00 
  tcp_tw_pcbs = NULL;
  1101c7:	c7 05 64 16 14 00 00 	movl   $0x0,0x141664
  1101ce:	00 00 00 
  tcp_tmp_pcb = NULL;
  1101d1:	c7 05 60 16 14 00 00 	movl   $0x0,0x141660
  1101d8:	00 00 00 
  
  /* initialize timer */
  tcp_ticks = 0;
  1101db:	c7 05 58 16 14 00 00 	movl   $0x0,0x141658
  1101e2:	00 00 00 
  tcp_timer = 0;
  1101e5:	c6 05 ec 98 13 00 00 	movb   $0x0,0x1398ec
  
}
  1101ec:	5d                   	pop    %ebp
  1101ed:	c3                   	ret    
  1101ee:	89 f6                	mov    %esi,%esi

001101f0 <tcp_tmr>:

/*
 * tcp_tmr():
 *
 * Called periodically to dispatch TCP timers.
 *
 */

void
tcp_tmr(void)
{
  1101f0:	55                   	push   %ebp
  1101f1:	89 e5                	mov    %esp,%ebp
  1101f3:	83 ec 08             	sub    $0x8,%esp
  /* Call tcp_fasttmr() every 250 ms */
  tcp_fasttmr();
  1101f6:	e8 65 0e 00 00       	call   111060 <tcp_fasttmr>

  if (++tcp_timer & 1) {
  1101fb:	0f b6 05 ec 98 13 00 	movzbl 0x1398ec,%eax
  110202:	83 c0 01             	add    $0x1,%eax
  110205:	a2 ec 98 13 00       	mov    %al,0x1398ec
  11020a:	0f b6 05 ec 98 13 00 	movzbl 0x1398ec,%eax
  110211:	0f b6 c0             	movzbl %al,%eax
  110214:	83 e0 01             	and    $0x1,%eax
  110217:	84 c0                	test   %al,%al
  110219:	74 05                	je     110220 <tcp_tmr+0x30>
    /* Call tcp_tmr() every 500 ms, i.e., every other timer
       tcp_tmr() is called. */
    tcp_slowtmr();
  11021b:	e8 e0 09 00 00       	call   110c00 <tcp_slowtmr>
  }
}
  110220:	c9                   	leave  
  110221:	c3                   	ret    
  110222:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi
  110229:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00110230 <tcp_close>:

/*
 * tcp_close():
 *
 * Closes the connection held by the PCB.
 *
 */

err_t
tcp_close(struct tcp_pcb *pcb)
{
  110230:	55                   	push   %ebp
  110231:	89 e5                	mov    %esp,%ebp
  110233:	83 ec 28             	sub    $0x28,%esp
  err_t err;

#if TCP_DEBUG
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_close: closing in state "));
  tcp_debug_print_state(pcb->state);
  LWIP_DEBUGF(TCP_DEBUG, ("\n"));
#endif /* TCP_DEBUG */
  switch (pcb->state) {
  110236:	8b 45 08             	mov    0x8(%ebp),%eax
  110239:	8b 40 10             	mov    0x10(%eax),%eax
  11023c:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  11023f:	83 7d ec 07          	cmpl   $0x7,0xffffffec(%ebp)
  110243:	0f 87 c5 00 00 00    	ja     11030e <tcp_close+0xde>
  110249:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
  11024c:	8b 04 95 b8 ae 11 00 	mov    0x11aeb8(,%edx,4),%eax
  110253:	ff e0                	jmp    *%eax
  case LISTEN:
    err = ERR_OK;
  110255:	c6 45 ff 00          	movb   $0x0,0xffffffff(%ebp)
    tcp_pcb_remove((struct tcp_pcb **)&tcp_listen_pcbs.pcbs, pcb);
  110259:	8b 45 08             	mov    0x8(%ebp),%eax
  11025c:	89 44 24 04          	mov    %eax,0x4(%esp)
  110260:	c7 04 24 5c 16 14 00 	movl   $0x14165c,(%esp)
  110267:	e8 74 13 00 00       	call   1115e0 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB_LISTEN, pcb);
  11026c:	8b 45 08             	mov    0x8(%ebp),%eax
  11026f:	89 44 24 04          	mov    %eax,0x4(%esp)
  110273:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  11027a:	e8 31 e8 ff ff       	call   10eab0 <memp_free>
    pcb = NULL;
  11027f:	c7 45 08 00 00 00 00 	movl   $0x0,0x8(%ebp)
    break;
  110286:	e9 8e 00 00 00       	jmp    110319 <tcp_close+0xe9>
  case SYN_SENT:
    err = ERR_OK;
  11028b:	c6 45 ff 00          	movb   $0x0,0xffffffff(%ebp)
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
  11028f:	8b 45 08             	mov    0x8(%ebp),%eax
  110292:	89 44 24 04          	mov    %eax,0x4(%esp)
  110296:	c7 04 24 54 16 14 00 	movl   $0x141654,(%esp)
  11029d:	e8 3e 13 00 00       	call   1115e0 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB, pcb);
  1102a2:	8b 45 08             	mov    0x8(%ebp),%eax
  1102a5:	89 44 24 04          	mov    %eax,0x4(%esp)
  1102a9:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  1102b0:	e8 fb e7 ff ff       	call   10eab0 <memp_free>
    pcb = NULL;
  1102b5:	c7 45 08 00 00 00 00 	movl   $0x0,0x8(%ebp)
    break;
  1102bc:	eb 5b                	jmp    110319 <tcp_close+0xe9>
  case SYN_RCVD:
  case ESTABLISHED:
    err = tcp_send_ctrl(pcb, TCP_FIN);
  1102be:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  1102c5:	00 
  1102c6:	8b 45 08             	mov    0x8(%ebp),%eax
  1102c9:	89 04 24             	mov    %eax,(%esp)
  1102cc:	e8 ff 13 00 00       	call   1116d0 <tcp_send_ctrl>
  1102d1:	88 45 ff             	mov    %al,0xffffffff(%ebp)
    if (err == ERR_OK) {
  1102d4:	80 7d ff 00          	cmpb   $0x0,0xffffffff(%ebp)
  1102d8:	75 3f                	jne    110319 <tcp_close+0xe9>
      pcb->state = FIN_WAIT_1;
  1102da:	8b 45 08             	mov    0x8(%ebp),%eax
  1102dd:	c7 40 10 05 00 00 00 	movl   $0x5,0x10(%eax)
    }
    break;
  1102e4:	eb 33                	jmp    110319 <tcp_close+0xe9>
  case CLOSE_WAIT:
    err = tcp_send_ctrl(pcb, TCP_FIN);
  1102e6:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  1102ed:	00 
  1102ee:	8b 45 08             	mov    0x8(%ebp),%eax
  1102f1:	89 04 24             	mov    %eax,(%esp)
  1102f4:	e8 d7 13 00 00       	call   1116d0 <tcp_send_ctrl>
  1102f9:	88 45 ff             	mov    %al,0xffffffff(%ebp)
    if (err == ERR_OK) {
  1102fc:	80 7d ff 00          	cmpb   $0x0,0xffffffff(%ebp)
  110300:	75 17                	jne    110319 <tcp_close+0xe9>
      pcb->state = LAST_ACK;
  110302:	8b 45 08             	mov    0x8(%ebp),%eax
  110305:	c7 40 10 09 00 00 00 	movl   $0x9,0x10(%eax)
    }
    break;
  11030c:	eb 0b                	jmp    110319 <tcp_close+0xe9>
  default:
    /* Has already been closed, do nothing. */
    err = ERR_OK;
  11030e:	c6 45 ff 00          	movb   $0x0,0xffffffff(%ebp)
    pcb = NULL;
  110312:	c7 45 08 00 00 00 00 	movl   $0x0,0x8(%ebp)
    break;
  }

  if (pcb != NULL && err == ERR_OK) {
  110319:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  11031d:	74 14                	je     110333 <tcp_close+0x103>
  11031f:	80 7d ff 00          	cmpb   $0x0,0xffffffff(%ebp)
  110323:	75 0e                	jne    110333 <tcp_close+0x103>
    err = tcp_output(pcb);
  110325:	8b 45 08             	mov    0x8(%ebp),%eax
  110328:	89 04 24             	mov    %eax,(%esp)
  11032b:	e8 10 1b 00 00       	call   111e40 <tcp_output>
  110330:	88 45 ff             	mov    %al,0xffffffff(%ebp)
  }
  return err;
  110333:	0f be 45 ff          	movsbl 0xffffffff(%ebp),%eax
}
  110337:	c9                   	leave  
  110338:	c3                   	ret    
  110339:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

00110340 <tcp_abort>:

/*
 * tcp_abort()
 *
 * Aborts a connection by sending a RST to the remote host and deletes
 * the local protocol control block. This is done when a connection is
 * killed because of shortage of memory.
 *
 */

void
tcp_abort(struct tcp_pcb *pcb)
{
  110340:	55                   	push   %ebp
  110341:	89 e5                	mov    %esp,%ebp
  110343:	83 ec 48             	sub    $0x48,%esp
  u32_t seqno, ackno;
  u16_t remote_port, local_port;
  struct ip_addr remote_ip, local_ip;
#if LWIP_CALLBACK_API  
  void (* errf)(void *arg, err_t err);
#endif /* LWIP_CALLBACK_API */
  void *errf_arg;

  
  /* Figure out on which TCP PCB list we are, and remove us. If we
     are in an active state, call the receive function associated with
     the PCB with a NULL argument, and send an RST to the remote end. */
  if (pcb->state == TIME_WAIT) {
  110346:	8b 45 08             	mov    0x8(%ebp),%eax
  110349:	8b 40 10             	mov    0x10(%eax),%eax
  11034c:	83 f8 0a             	cmp    $0xa,%eax
  11034f:	75 2b                	jne    11037c <tcp_abort+0x3c>
    tcp_pcb_remove(&tcp_tw_pcbs, pcb);
  110351:	8b 45 08             	mov    0x8(%ebp),%eax
  110354:	89 44 24 04          	mov    %eax,0x4(%esp)
  110358:	c7 04 24 64 16 14 00 	movl   $0x141664,(%esp)
  11035f:	e8 7c 12 00 00       	call   1115e0 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB, pcb);
  110364:	8b 45 08             	mov    0x8(%ebp),%eax
  110367:	89 44 24 04          	mov    %eax,0x4(%esp)
  11036b:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  110372:	e8 39 e7 ff ff       	call   10eab0 <memp_free>
  110377:	e9 34 01 00 00       	jmp    1104b0 <tcp_abort+0x170>
  } else {
    seqno = pcb->snd_nxt;
  11037c:	8b 45 08             	mov    0x8(%ebp),%eax
  11037f:	8b 40 50             	mov    0x50(%eax),%eax
  110382:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
    ackno = pcb->rcv_nxt;
  110385:	8b 45 08             	mov    0x8(%ebp),%eax
  110388:	8b 40 24             	mov    0x24(%eax),%eax
  11038b:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
    ip_addr_set(&local_ip, &(pcb->local_ip));
  11038e:	8b 45 08             	mov    0x8(%ebp),%eax
  110391:	85 c0                	test   %eax,%eax
  110393:	74 0a                	je     11039f <tcp_abort+0x5f>
  110395:	8b 45 08             	mov    0x8(%ebp),%eax
  110398:	8b 00                	mov    (%eax),%eax
  11039a:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
  11039d:	eb 07                	jmp    1103a6 <tcp_abort+0x66>
  11039f:	c7 45 d8 00 00 00 00 	movl   $0x0,0xffffffd8(%ebp)
  1103a6:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  1103a9:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
    ip_addr_set(&remote_ip, &(pcb->remote_ip));
  1103ac:	8b 45 08             	mov    0x8(%ebp),%eax
  1103af:	83 c0 04             	add    $0x4,%eax
  1103b2:	85 c0                	test   %eax,%eax
  1103b4:	74 0b                	je     1103c1 <tcp_abort+0x81>
  1103b6:	8b 45 08             	mov    0x8(%ebp),%eax
  1103b9:	8b 40 04             	mov    0x4(%eax),%eax
  1103bc:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
  1103bf:	eb 07                	jmp    1103c8 <tcp_abort+0x88>
  1103c1:	c7 45 dc 00 00 00 00 	movl   $0x0,0xffffffdc(%ebp)
  1103c8:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  1103cb:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
    local_port = pcb->local_port;
  1103ce:	8b 45 08             	mov    0x8(%ebp),%eax
  1103d1:	0f b7 40 1c          	movzwl 0x1c(%eax),%eax
  1103d5:	66 89 45 f6          	mov    %ax,0xfffffff6(%ebp)
    remote_port = pcb->remote_port;
  1103d9:	8b 45 08             	mov    0x8(%ebp),%eax
  1103dc:	0f b7 40 1e          	movzwl 0x1e(%eax),%eax
  1103e0:	66 89 45 f4          	mov    %ax,0xfffffff4(%ebp)
#if LWIP_CALLBACK_API
    errf = pcb->errf;
  1103e4:	8b 45 08             	mov    0x8(%ebp),%eax
  1103e7:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
  1103ed:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
#endif /* LWIP_CALLBACK_API */
    errf_arg = pcb->callback_arg;
  1103f0:	8b 45 08             	mov    0x8(%ebp),%eax
  1103f3:	8b 40 18             	mov    0x18(%eax),%eax
  1103f6:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
  1103f9:	8b 45 08             	mov    0x8(%ebp),%eax
  1103fc:	89 44 24 04          	mov    %eax,0x4(%esp)
  110400:	c7 04 24 54 16 14 00 	movl   $0x141654,(%esp)
  110407:	e8 d4 11 00 00       	call   1115e0 <tcp_pcb_remove>
    if (pcb->unacked != NULL) {
  11040c:	8b 45 08             	mov    0x8(%ebp),%eax
  11040f:	8b 40 74             	mov    0x74(%eax),%eax
  110412:	85 c0                	test   %eax,%eax
  110414:	74 0e                	je     110424 <tcp_abort+0xe4>
      tcp_segs_free(pcb->unacked);
  110416:	8b 45 08             	mov    0x8(%ebp),%eax
  110419:	8b 40 74             	mov    0x74(%eax),%eax
  11041c:	89 04 24             	mov    %eax,(%esp)
  11041f:	e8 ac 0c 00 00       	call   1110d0 <tcp_segs_free>
    }
    if (pcb->unsent != NULL) {
  110424:	8b 45 08             	mov    0x8(%ebp),%eax
  110427:	8b 40 70             	mov    0x70(%eax),%eax
  11042a:	85 c0                	test   %eax,%eax
  11042c:	74 0e                	je     11043c <tcp_abort+0xfc>
      tcp_segs_free(pcb->unsent);
  11042e:	8b 45 08             	mov    0x8(%ebp),%eax
  110431:	8b 40 70             	mov    0x70(%eax),%eax
  110434:	89 04 24             	mov    %eax,(%esp)
  110437:	e8 94 0c 00 00       	call   1110d0 <tcp_segs_free>
    }
#if TCP_QUEUE_OOSEQ    
    if (pcb->ooseq != NULL) {
  11043c:	8b 45 08             	mov    0x8(%ebp),%eax
  11043f:	8b 40 78             	mov    0x78(%eax),%eax
  110442:	85 c0                	test   %eax,%eax
  110444:	74 0e                	je     110454 <tcp_abort+0x114>
      tcp_segs_free(pcb->ooseq);
  110446:	8b 45 08             	mov    0x8(%ebp),%eax
  110449:	8b 40 78             	mov    0x78(%eax),%eax
  11044c:	89 04 24             	mov    %eax,(%esp)
  11044f:	e8 7c 0c 00 00       	call   1110d0 <tcp_segs_free>
    }
#endif /* TCP_QUEUE_OOSEQ */
    memp_free(MEMP_TCP_PCB, pcb);
  110454:	8b 45 08             	mov    0x8(%ebp),%eax
  110457:	89 44 24 04          	mov    %eax,0x4(%esp)
  11045b:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  110462:	e8 49 e6 ff ff       	call   10eab0 <memp_free>
    TCP_EVENT_ERR(errf, errf_arg, ERR_ABRT);
  110467:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  11046b:	74 13                	je     110480 <tcp_abort+0x140>
  11046d:	c7 44 24 04 fd ff ff 	movl   $0xfffffffd,0x4(%esp)
  110474:	ff 
  110475:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  110478:	89 04 24             	mov    %eax,(%esp)
  11047b:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  11047e:	ff d0                	call   *%eax
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_abort: sending RST\n"));
    tcp_rst(seqno, ackno, &local_ip, &remote_ip, local_port, remote_port);
  110480:	0f b7 45 f4          	movzwl 0xfffffff4(%ebp),%eax
  110484:	0f b7 55 f6          	movzwl 0xfffffff6(%ebp),%edx
  110488:	89 44 24 14          	mov    %eax,0x14(%esp)
  11048c:	89 54 24 10          	mov    %edx,0x10(%esp)
  110490:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
  110493:	89 44 24 0c          	mov    %eax,0xc(%esp)
  110497:	8d 45 e4             	lea    0xffffffe4(%ebp),%eax
  11049a:	89 44 24 08          	mov    %eax,0x8(%esp)
  11049e:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  1104a1:	89 44 24 04          	mov    %eax,0x4(%esp)
  1104a5:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  1104a8:	89 04 24             	mov    %eax,(%esp)
  1104ab:	e8 10 20 00 00       	call   1124c0 <tcp_rst>
  }
}
  1104b0:	c9                   	leave  
  1104b1:	c3                   	ret    
  1104b2:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi
  1104b9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

001104c0 <tcp_bind>:

/*
 * tcp_bind():
 *
 * Binds the connection to a local portnumber and IP address. If the
 * IP address is not given (i.e., ipaddr == NULL), the IP address of
 * the outgoing network interface is used instead.
 *
 */

err_t
tcp_bind(struct tcp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  1104c0:	55                   	push   %ebp
  1104c1:	89 e5                	mov    %esp,%ebp
  1104c3:	83 ec 28             	sub    $0x28,%esp
  1104c6:	8b 45 10             	mov    0x10(%ebp),%eax
  1104c9:	66 89 45 ec          	mov    %ax,0xffffffec(%ebp)
  struct tcp_pcb *cpcb;
#if SO_REUSE
  int reuse_port_all_set = 1;
  1104cd:	c7 45 fc 01 00 00 00 	movl   $0x1,0xfffffffc(%ebp)
#endif /* SO_REUSE */

  if (port == 0) {
  1104d4:	66 83 7d ec 00       	cmpw   $0x0,0xffffffec(%ebp)
  1104d9:	75 09                	jne    1104e4 <tcp_bind+0x24>
    port = tcp_new_port();
  1104db:	e8 d0 04 00 00       	call   1109b0 <tcp_new_port>
  1104e0:	66 89 45 ec          	mov    %ax,0xffffffec(%ebp)
  }
#if SO_REUSE == 0
  /* Check if the address already is in use. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_isany(&(cpcb->local_ip)) ||
        ip_addr_isany(ipaddr) ||
        ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
          return ERR_USE;
      }
    }
  }
  for(cpcb = tcp_active_pcbs;
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_isany(&(cpcb->local_ip)) ||
   ip_addr_isany(ipaddr) ||
   ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
  return ERR_USE;
      }
    }
  }
#else /* SO_REUSE */
  /* Search through list of PCB's in LISTEN state. 
     
  If there is a PCB bound to specified port and IP_ADDR_ANY another PCB can be bound to the interface IP
  or to the loopback address on the same port if SOF_REUSEADDR is set. Any combination of PCB's bound to 
  the same local port, but to one address out of {IP_ADDR_ANY, 127.0.0.1, interface IP} at a time is valid.
  But no two PCB's bound to same local port and same local address is valid.
  
  If SOF_REUSEPORT is set several PCB's can be bound to same local port and same local address also. But then 
  all PCB's must have the SOF_REUSEPORT option set.
  
  When the two options aren't set and specified port is already bound, ERR_USE is returned saying that 
  address is already in use. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; cpcb != NULL; cpcb = cpcb->next) {
  1104e4:	a1 5c 16 14 00       	mov    0x14165c,%eax
  1104e9:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  1104ec:	e9 e6 00 00 00       	jmp    1105d7 <tcp_bind+0x117>
    if(cpcb->local_port == port) {
  1104f1:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1104f4:	0f b7 40 1c          	movzwl 0x1c(%eax),%eax
  1104f8:	66 3b 45 ec          	cmp    0xffffffec(%ebp),%ax
  1104fc:	0f 85 cc 00 00 00    	jne    1105ce <tcp_bind+0x10e>
      if(ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
  110502:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  110505:	8b 10                	mov    (%eax),%edx
  110507:	8b 45 0c             	mov    0xc(%ebp),%eax
  11050a:	8b 00                	mov    (%eax),%eax
  11050c:	39 c2                	cmp    %eax,%edx
  11050e:	75 50                	jne    110560 <tcp_bind+0xa0>
        if(pcb->so_options & SOF_REUSEPORT) {
  110510:	8b 45 08             	mov    0x8(%ebp),%eax
  110513:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  110517:	0f b7 c0             	movzwl %ax,%eax
  11051a:	25 00 02 00 00       	and    $0x200,%eax
  11051f:	85 c0                	test   %eax,%eax
  110521:	74 31                	je     110554 <tcp_bind+0x94>
          LWIP_DEBUGF(TCP_DEBUG, ("tcp_bind: in listening PCB's: SO_REUSEPORT set and same address.\n"));
          reuse_port_all_set = (reuse_port_all_set && (cpcb->so_options & SOF_REUSEPORT));
  110523:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  110527:	74 1c                	je     110545 <tcp_bind+0x85>
  110529:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  11052c:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  110530:	0f b7 c0             	movzwl %ax,%eax
  110533:	25 00 02 00 00       	and    $0x200,%eax
  110538:	85 c0                	test   %eax,%eax
  11053a:	74 09                	je     110545 <tcp_bind+0x85>
  11053c:	c7 45 dc 01 00 00 00 	movl   $0x1,0xffffffdc(%ebp)
  110543:	eb 07                	jmp    11054c <tcp_bind+0x8c>
  110545:	c7 45 dc 00 00 00 00 	movl   $0x0,0xffffffdc(%ebp)
  11054c:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  11054f:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  110552:	eb 7a                	jmp    1105ce <tcp_bind+0x10e>
        }
        else {
          LWIP_DEBUGF(TCP_DEBUG, ("tcp_bind: in listening PCB's: SO_REUSEPORT not set and same address.\n"));
          return ERR_USE;
  110554:	c7 45 e0 f6 ff ff ff 	movl   $0xfffffff6,0xffffffe0(%ebp)
  11055b:	e9 69 02 00 00       	jmp    1107c9 <tcp_bind+0x309>
        }
      }
      else if((ip_addr_isany(ipaddr) && !ip_addr_isany(&(cpcb->local_ip))) ||
  110560:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  110564:	74 09                	je     11056f <tcp_bind+0xaf>
  110566:	8b 45 0c             	mov    0xc(%ebp),%eax
  110569:	8b 00                	mov    (%eax),%eax
  11056b:	85 c0                	test   %eax,%eax
  11056d:	75 10                	jne    11057f <tcp_bind+0xbf>
  11056f:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  110572:	85 c0                	test   %eax,%eax
  110574:	74 09                	je     11057f <tcp_bind+0xbf>
  110576:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  110579:	8b 00                	mov    (%eax),%eax
  11057b:	85 c0                	test   %eax,%eax
  11057d:	75 1f                	jne    11059e <tcp_bind+0xde>
  11057f:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  110583:	74 49                	je     1105ce <tcp_bind+0x10e>
  110585:	8b 45 0c             	mov    0xc(%ebp),%eax
  110588:	8b 00                	mov    (%eax),%eax
  11058a:	85 c0                	test   %eax,%eax
  11058c:	74 40                	je     1105ce <tcp_bind+0x10e>
  11058e:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  110591:	85 c0                	test   %eax,%eax
  110593:	74 09                	je     11059e <tcp_bind+0xde>
  110595:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  110598:	8b 00                	mov    (%eax),%eax
  11059a:	85 c0                	test   %eax,%eax
  11059c:	75 30                	jne    1105ce <tcp_bind+0x10e>
              (!ip_addr_isany(ipaddr) && ip_addr_isany(&(cpcb->local_ip)))) {
        if(!(pcb->so_options & SOF_REUSEADDR) && !(pcb->so_options & SOF_REUSEPORT)) {
  11059e:	8b 45 08             	mov    0x8(%ebp),%eax
  1105a1:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  1105a5:	0f b7 c0             	movzwl %ax,%eax
  1105a8:	83 e0 04             	and    $0x4,%eax
  1105ab:	85 c0                	test   %eax,%eax
  1105ad:	75 1f                	jne    1105ce <tcp_bind+0x10e>
  1105af:	8b 45 08             	mov    0x8(%ebp),%eax
  1105b2:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  1105b6:	0f b7 c0             	movzwl %ax,%eax
  1105b9:	25 00 02 00 00       	and    $0x200,%eax
  1105be:	85 c0                	test   %eax,%eax
  1105c0:	75 0c                	jne    1105ce <tcp_bind+0x10e>
          LWIP_DEBUGF(TCP_DEBUG, ("tcp_bind: in listening PCB's SO_REUSEPORT or SO_REUSEADDR not set and not the same address.\n"));
          return ERR_USE;
  1105c2:	c7 45 e0 f6 ff ff ff 	movl   $0xfffffff6,0xffffffe0(%ebp)
  1105c9:	e9 fb 01 00 00       	jmp    1107c9 <tcp_bind+0x309>
  1105ce:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1105d1:	8b 40 0c             	mov    0xc(%eax),%eax
  1105d4:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  1105d7:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  1105db:	0f 85 10 ff ff ff    	jne    1104f1 <tcp_bind+0x31>
        }      
        else {
          LWIP_DEBUGF(TCP_DEBUG, ("tcp_bind: in listening PCB's SO_REUSEPORT or SO_REUSEADDR set and not the same address.\n"));
        }     
      }
    }
  }

  /* Search through list of PCB's in a state in which they can accept or send data. Same decription as for 
     PCB's in state LISTEN applies to this PCB's regarding the options SOF_REUSEADDR and SOF_REUSEPORT. */
  for(cpcb = tcp_active_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  1105e1:	a1 54 16 14 00       	mov    0x141654,%eax
  1105e6:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  1105e9:	e9 e6 00 00 00       	jmp    1106d4 <tcp_bind+0x214>
    if(cpcb->local_port == port) {
  1105ee:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1105f1:	0f b7 40 1c          	movzwl 0x1c(%eax),%eax
  1105f5:	66 3b 45 ec          	cmp    0xffffffec(%ebp),%ax
  1105f9:	0f 85 cc 00 00 00    	jne    1106cb <tcp_bind+0x20b>
      if(ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
  1105ff:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  110602:	8b 10                	mov    (%eax),%edx
  110604:	8b 45 0c             	mov    0xc(%ebp),%eax
  110607:	8b 00                	mov    (%eax),%eax
  110609:	39 c2                	cmp    %eax,%edx
  11060b:	75 50                	jne    11065d <tcp_bind+0x19d>
        if(pcb->so_options & SOF_REUSEPORT) {
  11060d:	8b 45 08             	mov    0x8(%ebp),%eax
  110610:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  110614:	0f b7 c0             	movzwl %ax,%eax
  110617:	25 00 02 00 00       	and    $0x200,%eax
  11061c:	85 c0                	test   %eax,%eax
  11061e:	74 31                	je     110651 <tcp_bind+0x191>
          LWIP_DEBUGF(TCP_DEBUG, ("tcp_bind: in active PCB's SO_REUSEPORT set and same address.\n"));
          reuse_port_all_set = (reuse_port_all_set && (cpcb->so_options & SOF_REUSEPORT));
  110620:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  110624:	74 1c                	je     110642 <tcp_bind+0x182>
  110626:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  110629:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  11062d:	0f b7 c0             	movzwl %ax,%eax
  110630:	25 00 02 00 00       	and    $0x200,%eax
  110635:	85 c0                	test   %eax,%eax
  110637:	74 09                	je     110642 <tcp_bind+0x182>
  110639:	c7 45 e4 01 00 00 00 	movl   $0x1,0xffffffe4(%ebp)
  110640:	eb 07                	jmp    110649 <tcp_bind+0x189>
  110642:	c7 45 e4 00 00 00 00 	movl   $0x0,0xffffffe4(%ebp)
  110649:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
  11064c:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  11064f:	eb 7a                	jmp    1106cb <tcp_bind+0x20b>
        }
        else {
          LWIP_DEBUGF(TCP_DEBUG, ("tcp_bind: in active PCB's SO_REUSEPORT not set and same address.\n"));
          return ERR_USE;
  110651:	c7 45 e0 f6 ff ff ff 	movl   $0xfffffff6,0xffffffe0(%ebp)
  110658:	e9 6c 01 00 00       	jmp    1107c9 <tcp_bind+0x309>
        }
      }
      else if((ip_addr_isany(ipaddr) && !ip_addr_isany(&(cpcb->local_ip))) ||
  11065d:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  110661:	74 09                	je     11066c <tcp_bind+0x1ac>
  110663:	8b 45 0c             	mov    0xc(%ebp),%eax
  110666:	8b 00                	mov    (%eax),%eax
  110668:	85 c0                	test   %eax,%eax
  11066a:	75 10                	jne    11067c <tcp_bind+0x1bc>
  11066c:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  11066f:	85 c0                	test   %eax,%eax
  110671:	74 09                	je     11067c <tcp_bind+0x1bc>
  110673:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  110676:	8b 00                	mov    (%eax),%eax
  110678:	85 c0                	test   %eax,%eax
  11067a:	75 1f                	jne    11069b <tcp_bind+0x1db>
  11067c:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  110680:	74 49                	je     1106cb <tcp_bind+0x20b>
  110682:	8b 45 0c             	mov    0xc(%ebp),%eax
  110685:	8b 00                	mov    (%eax),%eax
  110687:	85 c0                	test   %eax,%eax
  110689:	74 40                	je     1106cb <tcp_bind+0x20b>
  11068b:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  11068e:	85 c0                	test   %eax,%eax
  110690:	74 09                	je     11069b <tcp_bind+0x1db>
  110692:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  110695:	8b 00                	mov    (%eax),%eax
  110697:	85 c0                	test   %eax,%eax
  110699:	75 30                	jne    1106cb <tcp_bind+0x20b>
              (!ip_addr_isany(ipaddr) && ip_addr_isany(&(cpcb->local_ip)))) {
        if(!(pcb->so_options & SOF_REUSEADDR) && !(pcb->so_options & SOF_REUSEPORT)) {
  11069b:	8b 45 08             	mov    0x8(%ebp),%eax
  11069e:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  1106a2:	0f b7 c0             	movzwl %ax,%eax
  1106a5:	83 e0 04             	and    $0x4,%eax
  1106a8:	85 c0                	test   %eax,%eax
  1106aa:	75 1f                	jne    1106cb <tcp_bind+0x20b>
  1106ac:	8b 45 08             	mov    0x8(%ebp),%eax
  1106af:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  1106b3:	0f b7 c0             	movzwl %ax,%eax
  1106b6:	25 00 02 00 00       	and    $0x200,%eax
  1106bb:	85 c0                	test   %eax,%eax
  1106bd:	75 0c                	jne    1106cb <tcp_bind+0x20b>
          LWIP_DEBUGF(TCP_DEBUG, ("tcp_bind: in active PCB's SO_REUSEPORT or SO_REUSEADDR not set and not the same address.\n"));
          return ERR_USE;
  1106bf:	c7 45 e0 f6 ff ff ff 	movl   $0xfffffff6,0xffffffe0(%ebp)
  1106c6:	e9 fe 00 00 00       	jmp    1107c9 <tcp_bind+0x309>
  1106cb:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1106ce:	8b 40 0c             	mov    0xc(%eax),%eax
  1106d1:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  1106d4:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  1106d8:	0f 85 10 ff ff ff    	jne    1105ee <tcp_bind+0x12e>
        }   
        else {
          LWIP_DEBUGF(TCP_DEBUG, ("tcp_bind: in active PCB's SO_REUSEPORT or SO_REUSEADDR set and not the same address.\n"));
        }        
      }
    }
  }

  /* Search through list of PCB's in TIME_WAIT state. If SO_REUSEADDR is set a bound combination [IP, port} 
     can be rebound. The same applies when SOF_REUSEPORT is set. 
     
     If SOF_REUSEPORT is set several PCB's can be bound to same local port and same local address also. But then 
     all PCB's must have the SOF_REUSEPORT option set.
     
     When the two options aren't set and specified port is already bound, ERR_USE is returned saying that 
     address is already in use. */
  for(cpcb = tcp_tw_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  1106de:	a1 64 16 14 00       	mov    0x141664,%eax
  1106e3:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  1106e6:	e9 9a 00 00 00       	jmp    110785 <tcp_bind+0x2c5>
    if(cpcb->local_port == port) {
  1106eb:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1106ee:	0f b7 40 1c          	movzwl 0x1c(%eax),%eax
  1106f2:	66 3b 45 ec          	cmp    0xffffffec(%ebp),%ax
  1106f6:	0f 85 80 00 00 00    	jne    11077c <tcp_bind+0x2bc>
      if(ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
  1106fc:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1106ff:	8b 10                	mov    (%eax),%edx
  110701:	8b 45 0c             	mov    0xc(%ebp),%eax
  110704:	8b 00                	mov    (%eax),%eax
  110706:	39 c2                	cmp    %eax,%edx
  110708:	75 72                	jne    11077c <tcp_bind+0x2bc>
        if(!(pcb->so_options & SOF_REUSEADDR) && !(pcb->so_options & SOF_REUSEPORT)) {
  11070a:	8b 45 08             	mov    0x8(%ebp),%eax
  11070d:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  110711:	0f b7 c0             	movzwl %ax,%eax
  110714:	83 e0 04             	and    $0x4,%eax
  110717:	85 c0                	test   %eax,%eax
  110719:	75 1f                	jne    11073a <tcp_bind+0x27a>
  11071b:	8b 45 08             	mov    0x8(%ebp),%eax
  11071e:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  110722:	0f b7 c0             	movzwl %ax,%eax
  110725:	25 00 02 00 00       	and    $0x200,%eax
  11072a:	85 c0                	test   %eax,%eax
  11072c:	75 0c                	jne    11073a <tcp_bind+0x27a>
          LWIP_DEBUGF(TCP_DEBUG, ("tcp_bind: in TIME_WAIT PCB's SO_REUSEPORT or SO_REUSEADDR not set and same address.\n"));
          return ERR_USE;
  11072e:	c7 45 e0 f6 ff ff ff 	movl   $0xfffffff6,0xffffffe0(%ebp)
  110735:	e9 8f 00 00 00       	jmp    1107c9 <tcp_bind+0x309>
        }
        else if(pcb->so_options & SOF_REUSEPORT) {
  11073a:	8b 45 08             	mov    0x8(%ebp),%eax
  11073d:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  110741:	0f b7 c0             	movzwl %ax,%eax
  110744:	25 00 02 00 00       	and    $0x200,%eax
  110749:	85 c0                	test   %eax,%eax
  11074b:	74 2f                	je     11077c <tcp_bind+0x2bc>
          LWIP_DEBUGF(TCP_DEBUG, ("tcp_bind: in TIME_WAIT PCB's SO_REUSEPORT set and same address.\n"));
          reuse_port_all_set = (reuse_port_all_set && (cpcb->so_options & SOF_REUSEPORT));
  11074d:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  110751:	74 1c                	je     11076f <tcp_bind+0x2af>
  110753:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  110756:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  11075a:	0f b7 c0             	movzwl %ax,%eax
  11075d:	25 00 02 00 00       	and    $0x200,%eax
  110762:	85 c0                	test   %eax,%eax
  110764:	74 09                	je     11076f <tcp_bind+0x2af>
  110766:	c7 45 e8 01 00 00 00 	movl   $0x1,0xffffffe8(%ebp)
  11076d:	eb 07                	jmp    110776 <tcp_bind+0x2b6>
  11076f:	c7 45 e8 00 00 00 00 	movl   $0x0,0xffffffe8(%ebp)
  110776:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  110779:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  11077c:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  11077f:	8b 40 0c             	mov    0xc(%eax),%eax
  110782:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  110785:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  110789:	0f 85 5c ff ff ff    	jne    1106eb <tcp_bind+0x22b>
        }
      }
    }
  }

  /* If SOF_REUSEPORT isn't set in all PCB's bound to specified port and local address specified then 
     {IP, port} can't be reused. */
  if(!reuse_port_all_set) {
  11078f:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  110793:	75 09                	jne    11079e <tcp_bind+0x2de>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_bind: not all sockets have SO_REUSEPORT set.\n"));
    return ERR_USE;
  110795:	c7 45 e0 f6 ff ff ff 	movl   $0xfffffff6,0xffffffe0(%ebp)
  11079c:	eb 2b                	jmp    1107c9 <tcp_bind+0x309>
  }
#endif /* SO_REUSE */

  if (!ip_addr_isany(ipaddr)) {
  11079e:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  1107a2:	74 13                	je     1107b7 <tcp_bind+0x2f7>
  1107a4:	8b 45 0c             	mov    0xc(%ebp),%eax
  1107a7:	8b 00                	mov    (%eax),%eax
  1107a9:	85 c0                	test   %eax,%eax
  1107ab:	74 0a                	je     1107b7 <tcp_bind+0x2f7>
    pcb->local_ip = *ipaddr;
  1107ad:	8b 45 0c             	mov    0xc(%ebp),%eax
  1107b0:	8b 10                	mov    (%eax),%edx
  1107b2:	8b 45 08             	mov    0x8(%ebp),%eax
  1107b5:	89 10                	mov    %edx,(%eax)
  }
  pcb->local_port = port;
  1107b7:	8b 55 08             	mov    0x8(%ebp),%edx
  1107ba:	0f b7 45 ec          	movzwl 0xffffffec(%ebp),%eax
  1107be:	66 89 42 1c          	mov    %ax,0x1c(%edx)
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_bind: bind to port %u\n", port));
  return ERR_OK;
  1107c2:	c7 45 e0 00 00 00 00 	movl   $0x0,0xffffffe0(%ebp)
  1107c9:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
}
  1107cc:	c9                   	leave  
  1107cd:	c3                   	ret    
  1107ce:	89 f6                	mov    %esi,%esi

001107d0 <tcp_accept_null>:
#if LWIP_CALLBACK_API
static err_t
tcp_accept_null(void *arg, struct tcp_pcb *pcb, err_t err)
{
  1107d0:	55                   	push   %ebp
  1107d1:	89 e5                	mov    %esp,%ebp
  1107d3:	83 ec 04             	sub    $0x4,%esp
  1107d6:	8b 45 10             	mov    0x10(%ebp),%eax
  1107d9:	88 45 fc             	mov    %al,0xfffffffc(%ebp)
  (void)arg;
  (void)pcb;
  (void)err;

  return ERR_ABRT;
  1107dc:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
}
  1107e1:	c9                   	leave  
  1107e2:	c3                   	ret    
  1107e3:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  1107e9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

001107f0 <tcp_listen>:
#endif /* LWIP_CALLBACK_API */

/*
 * tcp_listen():
 *
 * Set the state of the connection to be LISTEN, which means that it
 * is able to accept incoming connections. The protocol control block
 * is reallocated in order to consume less memory. Setting the
 * connection to LISTEN is an irreversible process.
 *
 */

struct tcp_pcb *
tcp_listen(struct tcp_pcb *pcb)
{
  1107f0:	55                   	push   %ebp
  1107f1:	89 e5                	mov    %esp,%ebp
  1107f3:	83 ec 28             	sub    $0x28,%esp
  struct tcp_pcb_listen *lpcb;

  /* already listening? */
  if (pcb->state == LISTEN) {
  1107f6:	8b 45 08             	mov    0x8(%ebp),%eax
  1107f9:	8b 40 10             	mov    0x10(%eax),%eax
  1107fc:	83 f8 01             	cmp    $0x1,%eax
  1107ff:	75 0b                	jne    11080c <tcp_listen+0x1c>
    return pcb;
  110801:	8b 45 08             	mov    0x8(%ebp),%eax
  110804:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
  110807:	e9 dc 00 00 00       	jmp    1108e8 <tcp_listen+0xf8>
  }
  lpcb = memp_malloc(MEMP_TCP_PCB_LISTEN);
  11080c:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  110813:	e8 a8 e1 ff ff       	call   10e9c0 <memp_malloc>
  110818:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  if (lpcb == NULL) {
  11081b:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  11081f:	75 0c                	jne    11082d <tcp_listen+0x3d>
    return NULL;
  110821:	c7 45 e8 00 00 00 00 	movl   $0x0,0xffffffe8(%ebp)
  110828:	e9 bb 00 00 00       	jmp    1108e8 <tcp_listen+0xf8>
  }
  lpcb->callback_arg = pcb->callback_arg;
  11082d:	8b 45 08             	mov    0x8(%ebp),%eax
  110830:	8b 50 18             	mov    0x18(%eax),%edx
  110833:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  110836:	89 50 18             	mov    %edx,0x18(%eax)
  lpcb->local_port = pcb->local_port;
  110839:	8b 45 08             	mov    0x8(%ebp),%eax
  11083c:	0f b7 50 1c          	movzwl 0x1c(%eax),%edx
  110840:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  110843:	66 89 50 1c          	mov    %dx,0x1c(%eax)
  lpcb->state = LISTEN;
  110847:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  11084a:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
  lpcb->so_options = pcb->so_options;
  110851:	8b 45 08             	mov    0x8(%ebp),%eax
  110854:	0f b7 50 08          	movzwl 0x8(%eax),%edx
  110858:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  11085b:	66 89 50 08          	mov    %dx,0x8(%eax)
  lpcb->so_options |= SOF_ACCEPTCONN;
  11085f:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  110862:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  110866:	89 c2                	mov    %eax,%edx
  110868:	83 ca 02             	or     $0x2,%edx
  11086b:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  11086e:	66 89 50 08          	mov    %dx,0x8(%eax)
  lpcb->ttl = pcb->ttl;
  110872:	8b 45 08             	mov    0x8(%ebp),%eax
  110875:	0f b6 50 0b          	movzbl 0xb(%eax),%edx
  110879:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  11087c:	88 50 0b             	mov    %dl,0xb(%eax)
  lpcb->tos = pcb->tos;
  11087f:	8b 45 08             	mov    0x8(%ebp),%eax
  110882:	0f b6 50 0a          	movzbl 0xa(%eax),%edx
  110886:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  110889:	88 50 0a             	mov    %dl,0xa(%eax)
  ip_addr_set(&lpcb->local_ip, &pcb->local_ip);
  11088c:	8b 45 08             	mov    0x8(%ebp),%eax
  11088f:	85 c0                	test   %eax,%eax
  110891:	74 0a                	je     11089d <tcp_listen+0xad>
  110893:	8b 45 08             	mov    0x8(%ebp),%eax
  110896:	8b 00                	mov    (%eax),%eax
  110898:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  11089b:	eb 07                	jmp    1108a4 <tcp_listen+0xb4>
  11089d:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  1108a4:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1108a7:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
  1108aa:	89 10                	mov    %edx,(%eax)
  memp_free(MEMP_TCP_PCB, pcb);
  1108ac:	8b 45 08             	mov    0x8(%ebp),%eax
  1108af:	89 44 24 04          	mov    %eax,0x4(%esp)
  1108b3:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  1108ba:	e8 f1 e1 ff ff       	call   10eab0 <memp_free>
#if LWIP_CALLBACK_API
  lpcb->accept = tcp_accept_null;
  1108bf:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1108c2:	c7 40 20 d0 07 11 00 	movl   $0x1107d0,0x20(%eax)
#endif /* LWIP_CALLBACK_API */
  TCP_REG(&tcp_listen_pcbs.listen_pcbs, lpcb);
  1108c9:	8b 15 5c 16 14 00    	mov    0x14165c,%edx
  1108cf:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1108d2:	89 50 0c             	mov    %edx,0xc(%eax)
  1108d5:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1108d8:	a3 5c 16 14 00       	mov    %eax,0x14165c
  1108dd:	e8 de 91 00 00       	call   119ac0 <tcp_timer_needed>
  return (struct tcp_pcb *)lpcb;
  1108e2:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1108e5:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
  1108e8:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
}
  1108eb:	c9                   	leave  
  1108ec:	c3                   	ret    
  1108ed:	8d 76 00             	lea    0x0(%esi),%esi

001108f0 <tcp_recved>:

/*
 * tcp_recved():
 *
 * This function should be called by the application when it has
 * processed the data. The purpose is to advertise a larger window
 * when the data has been processed.
 *
 */

void
tcp_recved(struct tcp_pcb *pcb, u16_t len)
{
  1108f0:	55                   	push   %ebp
  1108f1:	89 e5                	mov    %esp,%ebp
  1108f3:	83 ec 08             	sub    $0x8,%esp
  1108f6:	8b 45 0c             	mov    0xc(%ebp),%eax
  1108f9:	66 89 45 fc          	mov    %ax,0xfffffffc(%ebp)
  if ((u32_t)pcb->rcv_wnd + len > TCP_WND) {
  1108fd:	8b 45 08             	mov    0x8(%ebp),%eax
  110900:	0f b7 40 28          	movzwl 0x28(%eax),%eax
  110904:	0f b7 d0             	movzwl %ax,%edx
  110907:	0f b7 45 fc          	movzwl 0xfffffffc(%ebp),%eax
  11090b:	8d 04 02             	lea    (%edx,%eax,1),%eax
  11090e:	3d 00 20 00 00       	cmp    $0x2000,%eax
  110913:	76 0b                	jbe    110920 <tcp_recved+0x30>
    pcb->rcv_wnd = TCP_WND;
  110915:	8b 45 08             	mov    0x8(%ebp),%eax
  110918:	66 c7 40 28 00 20    	movw   $0x2000,0x28(%eax)
  11091e:	eb 14                	jmp    110934 <tcp_recved+0x44>
  } else {
    pcb->rcv_wnd += len;
  110920:	8b 45 08             	mov    0x8(%ebp),%eax
  110923:	0f b7 40 28          	movzwl 0x28(%eax),%eax
  110927:	89 c2                	mov    %eax,%edx
  110929:	66 03 55 fc          	add    0xfffffffc(%ebp),%dx
  11092d:	8b 45 08             	mov    0x8(%ebp),%eax
  110930:	66 89 50 28          	mov    %dx,0x28(%eax)
  }
  if (!(pcb->flags & TF_ACK_DELAY) &&
  110934:	8b 45 08             	mov    0x8(%ebp),%eax
  110937:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  11093b:	0f b6 c0             	movzbl %al,%eax
  11093e:	83 e0 01             	and    $0x1,%eax
  110941:	85 c0                	test   %eax,%eax
  110943:	75 65                	jne    1109aa <tcp_recved+0xba>
  110945:	8b 45 08             	mov    0x8(%ebp),%eax
  110948:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  11094c:	0f b6 c0             	movzbl %al,%eax
  11094f:	83 e0 02             	and    $0x2,%eax
  110952:	85 c0                	test   %eax,%eax
  110954:	75 54                	jne    1109aa <tcp_recved+0xba>
     !(pcb->flags & TF_ACK_NOW)) {
    /*
     * We send an ACK here (if one is not already pending, hence
     * the above tests) as tcp_recved() implies that the application
     * has processed some data, and so we can open the receiver's
     * window to allow more to be transmitted.  This could result in
     * two ACKs being sent for each received packet in some limited cases
     * (where the application is only receiving data, and is slow to
     * process it) but it is necessary to guarantee that the sender can
     * continue to transmit.
     */
    tcp_ack(pcb);
  110956:	8b 45 08             	mov    0x8(%ebp),%eax
  110959:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  11095d:	0f b6 c0             	movzbl %al,%eax
  110960:	83 e0 01             	and    $0x1,%eax
  110963:	84 c0                	test   %al,%al
  110965:	74 31                	je     110998 <tcp_recved+0xa8>
  110967:	8b 45 08             	mov    0x8(%ebp),%eax
  11096a:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  11096e:	89 c2                	mov    %eax,%edx
  110970:	83 e2 fe             	and    $0xfffffffe,%edx
  110973:	8b 45 08             	mov    0x8(%ebp),%eax
  110976:	88 50 20             	mov    %dl,0x20(%eax)
  110979:	8b 45 08             	mov    0x8(%ebp),%eax
  11097c:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  110980:	89 c2                	mov    %eax,%edx
  110982:	83 ca 02             	or     $0x2,%edx
  110985:	8b 45 08             	mov    0x8(%ebp),%eax
  110988:	88 50 20             	mov    %dl,0x20(%eax)
  11098b:	8b 45 08             	mov    0x8(%ebp),%eax
  11098e:	89 04 24             	mov    %eax,(%esp)
  110991:	e8 aa 14 00 00       	call   111e40 <tcp_output>
  110996:	eb 12                	jmp    1109aa <tcp_recved+0xba>
  110998:	8b 45 08             	mov    0x8(%ebp),%eax
  11099b:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  11099f:	89 c2                	mov    %eax,%edx
  1109a1:	83 ca 01             	or     $0x1,%edx
  1109a4:	8b 45 08             	mov    0x8(%ebp),%eax
  1109a7:	88 50 20             	mov    %dl,0x20(%eax)
  }

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_recved: recveived %u bytes, wnd %u (%u).\n",
         len, pcb->rcv_wnd, TCP_WND - pcb->rcv_wnd));
}
  1109aa:	c9                   	leave  
  1109ab:	c3                   	ret    
  1109ac:	8d 74 26 00          	lea    0x0(%esi),%esi

001109b0 <tcp_new_port>:

/*
 * tcp_new_port():
 *
 * A nastly hack featuring 'goto' statements that allocates a
 * new TCP local port.
 */

static u16_t
tcp_new_port(void)
{
  1109b0:	55                   	push   %ebp
  1109b1:	89 e5                	mov    %esp,%ebp
  1109b3:	83 ec 10             	sub    $0x10,%esp
  struct tcp_pcb *pcb;
#ifndef TCP_LOCAL_PORT_RANGE_START
#define TCP_LOCAL_PORT_RANGE_START 4096
#define TCP_LOCAL_PORT_RANGE_END   0x7fff
#endif
  static u16_t port = TCP_LOCAL_PORT_RANGE_START;
  
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
  1109b6:	0f b7 05 a0 cb 11 00 	movzwl 0x11cba0,%eax
  1109bd:	83 c0 01             	add    $0x1,%eax
  1109c0:	66 a3 a0 cb 11 00    	mov    %ax,0x11cba0
  1109c6:	0f b7 05 a0 cb 11 00 	movzwl 0x11cba0,%eax
  1109cd:	66 85 c0             	test   %ax,%ax
  1109d0:	79 09                	jns    1109db <tcp_new_port+0x2b>
    port = TCP_LOCAL_PORT_RANGE_START;
  1109d2:	66 c7 05 a0 cb 11 00 	movw   $0x1000,0x11cba0
  1109d9:	00 10 
  }
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  1109db:	a1 54 16 14 00       	mov    0x141654,%eax
  1109e0:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  1109e3:	eb 1c                	jmp    110a01 <tcp_new_port+0x51>
    if (pcb->local_port == port) {
  1109e5:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1109e8:	0f b7 50 1c          	movzwl 0x1c(%eax),%edx
  1109ec:	0f b7 05 a0 cb 11 00 	movzwl 0x11cba0,%eax
  1109f3:	66 39 c2             	cmp    %ax,%dx
  1109f6:	74 be                	je     1109b6 <tcp_new_port+0x6>
  1109f8:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1109fb:	8b 40 0c             	mov    0xc(%eax),%eax
  1109fe:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  110a01:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  110a05:	75 de                	jne    1109e5 <tcp_new_port+0x35>
      goto again;
    }
  }
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  110a07:	a1 64 16 14 00       	mov    0x141664,%eax
  110a0c:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  110a0f:	eb 1c                	jmp    110a2d <tcp_new_port+0x7d>
    if (pcb->local_port == port) {
  110a11:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  110a14:	0f b7 50 1c          	movzwl 0x1c(%eax),%edx
  110a18:	0f b7 05 a0 cb 11 00 	movzwl 0x11cba0,%eax
  110a1f:	66 39 c2             	cmp    %ax,%dx
  110a22:	74 92                	je     1109b6 <tcp_new_port+0x6>
  110a24:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  110a27:	8b 40 0c             	mov    0xc(%eax),%eax
  110a2a:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  110a2d:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  110a31:	75 de                	jne    110a11 <tcp_new_port+0x61>
      goto again;
    }
  }
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
  110a33:	a1 5c 16 14 00       	mov    0x14165c,%eax
  110a38:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  110a3b:	eb 20                	jmp    110a5d <tcp_new_port+0xad>
    if (pcb->local_port == port) {
  110a3d:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  110a40:	0f b7 50 1c          	movzwl 0x1c(%eax),%edx
  110a44:	0f b7 05 a0 cb 11 00 	movzwl 0x11cba0,%eax
  110a4b:	66 39 c2             	cmp    %ax,%dx
  110a4e:	0f 84 62 ff ff ff    	je     1109b6 <tcp_new_port+0x6>
  110a54:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  110a57:	8b 40 0c             	mov    0xc(%eax),%eax
  110a5a:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  110a5d:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  110a61:	75 da                	jne    110a3d <tcp_new_port+0x8d>
      goto again;
    }
  }
  return port;
  110a63:	0f b7 05 a0 cb 11 00 	movzwl 0x11cba0,%eax
  110a6a:	0f b7 c0             	movzwl %ax,%eax
}
  110a6d:	c9                   	leave  
  110a6e:	c3                   	ret    
  110a6f:	90                   	nop    

00110a70 <tcp_connect>:

/*
 * tcp_connect():
 *
 * Connects to another host. The function given as the "connected"
 * argument will be called when the connection has been established.
 *
 */

err_t
tcp_connect(struct tcp_pcb *pcb, struct ip_addr *ipaddr, u16_t port,
      err_t (* connected)(void *arg, struct tcp_pcb *tpcb, err_t err))
{
  110a70:	55                   	push   %ebp
  110a71:	89 e5                	mov    %esp,%ebp
  110a73:	83 ec 38             	sub    $0x38,%esp
  110a76:	8b 45 10             	mov    0x10(%ebp),%eax
  110a79:	66 89 45 ec          	mov    %ax,0xffffffec(%ebp)
  u32_t optdata;
  err_t ret;
  u32_t iss;

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_connect to port %u\n", port));
  if (ipaddr != NULL) {
  110a7d:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  110a81:	74 24                	je     110aa7 <tcp_connect+0x37>
    pcb->remote_ip = *ipaddr;
  110a83:	8b 45 0c             	mov    0xc(%ebp),%eax
  110a86:	8b 10                	mov    (%eax),%edx
  110a88:	8b 45 08             	mov    0x8(%ebp),%eax
  110a8b:	89 50 04             	mov    %edx,0x4(%eax)
  } else {
    return ERR_VAL;
  }
  pcb->remote_port = port;
  110a8e:	8b 55 08             	mov    0x8(%ebp),%edx
  110a91:	0f b7 45 ec          	movzwl 0xffffffec(%ebp),%eax
  110a95:	66 89 42 1e          	mov    %ax,0x1e(%edx)
  if (pcb->local_port == 0) {
  110a99:	8b 45 08             	mov    0x8(%ebp),%eax
  110a9c:	0f b7 40 1c          	movzwl 0x1c(%eax),%eax
  110aa0:	66 85 c0             	test   %ax,%ax
  110aa3:	74 0e                	je     110ab3 <tcp_connect+0x43>
  110aa5:	eb 1a                	jmp    110ac1 <tcp_connect+0x51>
  110aa7:	c7 45 e8 f9 ff ff ff 	movl   $0xfffffff9,0xffffffe8(%ebp)
  110aae:	e9 3a 01 00 00       	jmp    110bed <tcp_connect+0x17d>
    pcb->local_port = tcp_new_port();
  110ab3:	e8 f8 fe ff ff       	call   1109b0 <tcp_new_port>
  110ab8:	89 c2                	mov    %eax,%edx
  110aba:	8b 45 08             	mov    0x8(%ebp),%eax
  110abd:	66 89 50 1c          	mov    %dx,0x1c(%eax)
  }
  iss = tcp_next_iss();
  110ac1:	e8 ea 0b 00 00       	call   1116b0 <tcp_next_iss>
  110ac6:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  pcb->rcv_nxt = 0;
  110ac9:	8b 45 08             	mov    0x8(%ebp),%eax
  110acc:	c7 40 24 00 00 00 00 	movl   $0x0,0x24(%eax)
  pcb->snd_nxt = iss;
  110ad3:	8b 55 08             	mov    0x8(%ebp),%edx
  110ad6:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  110ad9:	89 42 50             	mov    %eax,0x50(%edx)
  pcb->lastack = iss - 1;
  110adc:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  110adf:	83 ea 01             	sub    $0x1,%edx
  110ae2:	8b 45 08             	mov    0x8(%ebp),%eax
  110ae5:	89 50 44             	mov    %edx,0x44(%eax)
  pcb->snd_lbb = iss - 1;
  110ae8:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  110aeb:	83 ea 01             	sub    $0x1,%edx
  110aee:	8b 45 08             	mov    0x8(%ebp),%eax
  110af1:	89 50 64             	mov    %edx,0x64(%eax)
  pcb->rcv_wnd = TCP_WND;
  110af4:	8b 45 08             	mov    0x8(%ebp),%eax
  110af7:	66 c7 40 28 00 20    	movw   $0x2000,0x28(%eax)
  pcb->snd_wnd = TCP_WND;
  110afd:	8b 45 08             	mov    0x8(%ebp),%eax
  110b00:	c7 40 58 00 20 00 00 	movl   $0x2000,0x58(%eax)
  pcb->mss = TCP_MSS;
  110b07:	8b 45 08             	mov    0x8(%ebp),%eax
  110b0a:	66 c7 40 34 00 02    	movw   $0x200,0x34(%eax)
  pcb->cwnd = 1;
  110b10:	8b 45 08             	mov    0x8(%ebp),%eax
  110b13:	66 c7 40 4a 01 00    	movw   $0x1,0x4a(%eax)
  pcb->ssthresh = pcb->mss * 10;
  110b19:	8b 45 08             	mov    0x8(%ebp),%eax
  110b1c:	0f b7 40 34          	movzwl 0x34(%eax),%eax
  110b20:	0f b7 d0             	movzwl %ax,%edx
  110b23:	89 d0                	mov    %edx,%eax
  110b25:	c1 e0 02             	shl    $0x2,%eax
  110b28:	01 d0                	add    %edx,%eax
  110b2a:	01 c0                	add    %eax,%eax
  110b2c:	89 c2                	mov    %eax,%edx
  110b2e:	8b 45 08             	mov    0x8(%ebp),%eax
  110b31:	66 89 50 4c          	mov    %dx,0x4c(%eax)
  pcb->state = SYN_SENT;
  110b35:	8b 45 08             	mov    0x8(%ebp),%eax
  110b38:	c7 40 10 02 00 00 00 	movl   $0x2,0x10(%eax)
#if LWIP_CALLBACK_API  
  pcb->connected = connected;
  110b3f:	8b 55 08             	mov    0x8(%ebp),%edx
  110b42:	8b 45 14             	mov    0x14(%ebp),%eax
  110b45:	89 82 84 00 00 00    	mov    %eax,0x84(%edx)
#endif /* LWIP_CALLBACK_API */  
  TCP_REG(&tcp_active_pcbs, pcb);
  110b4b:	8b 15 54 16 14 00    	mov    0x141654,%edx
  110b51:	8b 45 08             	mov    0x8(%ebp),%eax
  110b54:	89 50 0c             	mov    %edx,0xc(%eax)
  110b57:	8b 45 08             	mov    0x8(%ebp),%eax
  110b5a:	a3 54 16 14 00       	mov    %eax,0x141654
  110b5f:	e8 5c 8f 00 00       	call   119ac0 <tcp_timer_needed>
  
  /* Build an MSS option */
  optdata = htonl(((u32_t)2 << 24) | 
  110b64:	8b 45 08             	mov    0x8(%ebp),%eax
  110b67:	0f b7 40 34          	movzwl 0x34(%eax),%eax
  110b6b:	66 c1 e8 08          	shr    $0x8,%ax
  110b6f:	0f b7 c0             	movzwl %ax,%eax
  110b72:	89 c2                	mov    %eax,%edx
  110b74:	c1 e2 08             	shl    $0x8,%edx
  110b77:	8b 45 08             	mov    0x8(%ebp),%eax
  110b7a:	0f b7 40 34          	movzwl 0x34(%eax),%eax
  110b7e:	0f b7 c0             	movzwl %ax,%eax
  110b81:	25 ff 00 00 00       	and    $0xff,%eax
  110b86:	09 d0                	or     %edx,%eax
  110b88:	0d 00 00 04 02       	or     $0x2040000,%eax
  110b8d:	89 04 24             	mov    %eax,(%esp)
  110b90:	e8 2b d7 ff ff       	call   10e2c0 <htonl>
  110b95:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
      ((u32_t)4 << 16) | 
      (((u32_t)pcb->mss / 256) << 8) |
      (pcb->mss & 255));

  ret = tcp_enqueue(pcb, NULL, 0, TCP_SYN, 0, (u8_t *)&optdata, 4);
  110b98:	8d 45 f4             	lea    0xfffffff4(%ebp),%eax
  110b9b:	c7 44 24 18 04 00 00 	movl   $0x4,0x18(%esp)
  110ba2:	00 
  110ba3:	89 44 24 14          	mov    %eax,0x14(%esp)
  110ba7:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  110bae:	00 
  110baf:	c7 44 24 0c 02 00 00 	movl   $0x2,0xc(%esp)
  110bb6:	00 
  110bb7:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  110bbe:	00 
  110bbf:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  110bc6:	00 
  110bc7:	8b 45 08             	mov    0x8(%ebp),%eax
  110bca:	89 04 24             	mov    %eax,(%esp)
  110bcd:	e8 ee 0b 00 00       	call   1117c0 <tcp_enqueue>
  110bd2:	88 45 fb             	mov    %al,0xfffffffb(%ebp)
  if (ret == ERR_OK) { 
  110bd5:	80 7d fb 00          	cmpb   $0x0,0xfffffffb(%ebp)
  110bd9:	75 0b                	jne    110be6 <tcp_connect+0x176>
    tcp_output(pcb);
  110bdb:	8b 45 08             	mov    0x8(%ebp),%eax
  110bde:	89 04 24             	mov    %eax,(%esp)
  110be1:	e8 5a 12 00 00       	call   111e40 <tcp_output>
  }
  return ret;
  110be6:	0f be 45 fb          	movsbl 0xfffffffb(%ebp),%eax
  110bea:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
  110bed:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
} 
  110bf0:	c9                   	leave  
  110bf1:	c3                   	ret    
  110bf2:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi
  110bf9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00110c00 <tcp_slowtmr>:

/*
 * tcp_slowtmr():
 *
 * Called every 500 ms and implements the retransmission timer and the timer that
 * removes PCBs that have been in TIME-WAIT for enough time. It also increments
 * various timers such as the inactivity timer in each PCB.
 */

void
tcp_slowtmr(void)
{
  110c00:	55                   	push   %ebp
  110c01:	89 e5                	mov    %esp,%ebp
  110c03:	83 ec 38             	sub    $0x38,%esp
  struct tcp_pcb *pcb, *pcb2, *prev;
  u32_t eff_wnd;
  u8_t pcb_remove;      /* flag if a PCB should be removed */
  err_t err;

  err = ERR_OK;
  110c06:	c6 45 ff 00          	movb   $0x0,0xffffffff(%ebp)

  ++tcp_ticks;
  110c0a:	a1 58 16 14 00       	mov    0x141658,%eax
  110c0f:	83 c0 01             	add    $0x1,%eax
  110c12:	a3 58 16 14 00       	mov    %eax,0x141658

  /* Steps through all of the active PCBs. */
  prev = NULL;
  110c17:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
  pcb = tcp_active_pcbs;
  110c1e:	a1 54 16 14 00       	mov    0x141654,%eax
  110c23:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  110c26:	e9 83 03 00 00       	jmp    110fae <tcp_slowtmr+0x3ae>
  if (pcb == NULL) LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  while (pcb != NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);

    pcb_remove = 0;
  110c2b:	c6 45 fe 00          	movb   $0x0,0xfffffffe(%ebp)

    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
  110c2f:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110c32:	8b 40 10             	mov    0x10(%eax),%eax
  110c35:	83 f8 02             	cmp    $0x2,%eax
  110c38:	75 14                	jne    110c4e <tcp_slowtmr+0x4e>
  110c3a:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110c3d:	0f b6 40 42          	movzbl 0x42(%eax),%eax
  110c41:	3c 06                	cmp    $0x6,%al
  110c43:	75 09                	jne    110c4e <tcp_slowtmr+0x4e>
      ++pcb_remove;
  110c45:	80 45 fe 01          	addb   $0x1,0xfffffffe(%ebp)
  110c49:	e9 07 01 00 00       	jmp    110d55 <tcp_slowtmr+0x155>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max SYN retries reached\n"));
    }
    else if (pcb->nrtx == TCP_MAXRTX) {
  110c4e:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110c51:	0f b6 40 42          	movzbl 0x42(%eax),%eax
  110c55:	3c 0c                	cmp    $0xc,%al
  110c57:	75 09                	jne    110c62 <tcp_slowtmr+0x62>
      ++pcb_remove;
  110c59:	80 45 fe 01          	addb   $0x1,0xfffffffe(%ebp)
  110c5d:	e9 f3 00 00 00       	jmp    110d55 <tcp_slowtmr+0x155>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max DATA retries reached\n"));
    } else {
      ++pcb->rtime;
  110c62:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110c65:	0f b7 40 32          	movzwl 0x32(%eax),%eax
  110c69:	8d 50 01             	lea    0x1(%eax),%edx
  110c6c:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110c6f:	66 89 50 32          	mov    %dx,0x32(%eax)
      if (pcb->unacked != NULL && pcb->rtime >= pcb->rto) {
  110c73:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110c76:	8b 40 74             	mov    0x74(%eax),%eax
  110c79:	85 c0                	test   %eax,%eax
  110c7b:	0f 84 d4 00 00 00    	je     110d55 <tcp_slowtmr+0x155>
  110c81:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110c84:	0f b7 50 32          	movzwl 0x32(%eax),%edx
  110c88:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110c8b:	0f b7 40 40          	movzwl 0x40(%eax),%eax
  110c8f:	66 39 c2             	cmp    %ax,%dx
  110c92:	0f 82 bd 00 00 00    	jb     110d55 <tcp_slowtmr+0x155>

        /* Time for a retransmission. */
        LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_slowtmr: rtime %u pcb->rto %u\n",
          pcb->rtime, pcb->rto));

        /* Double retransmission time-out unless we are trying to
         * connect to somebody (i.e., we are in SYN_SENT). */
        if (pcb->state != SYN_SENT) {
  110c98:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110c9b:	8b 40 10             	mov    0x10(%eax),%eax
  110c9e:	83 f8 02             	cmp    $0x2,%eax
  110ca1:	74 39                	je     110cdc <tcp_slowtmr+0xdc>
          pcb->rto = ((pcb->sa >> 3) + pcb->sv) << tcp_backoff[pcb->nrtx];
  110ca3:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110ca6:	0f b7 40 3c          	movzwl 0x3c(%eax),%eax
  110caa:	66 c1 f8 03          	sar    $0x3,%ax
  110cae:	0f bf d0             	movswl %ax,%edx
  110cb1:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110cb4:	0f b7 40 3e          	movzwl 0x3e(%eax),%eax
  110cb8:	98                   	cwtl   
  110cb9:	01 c2                	add    %eax,%edx
  110cbb:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110cbe:	0f b6 40 42          	movzbl 0x42(%eax),%eax
  110cc2:	0f b6 c0             	movzbl %al,%eax
  110cc5:	0f b6 80 a8 ae 11 00 	movzbl 0x11aea8(%eax),%eax
  110ccc:	0f b6 c8             	movzbl %al,%ecx
  110ccf:	89 d0                	mov    %edx,%eax
  110cd1:	d3 e0                	shl    %cl,%eax
  110cd3:	89 c2                	mov    %eax,%edx
  110cd5:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110cd8:	66 89 50 40          	mov    %dx,0x40(%eax)
        }
        tcp_rexmit(pcb);
  110cdc:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110cdf:	89 04 24             	mov    %eax,(%esp)
  110ce2:	e8 79 19 00 00       	call   112660 <tcp_rexmit>
        /* Reduce congestion window and ssthresh. */
        eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
  110ce7:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110cea:	8b 50 58             	mov    0x58(%eax),%edx
  110ced:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110cf0:	0f b7 40 4a          	movzwl 0x4a(%eax),%eax
  110cf4:	0f b7 c0             	movzwl %ax,%eax
  110cf7:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
  110cfa:	89 55 d8             	mov    %edx,0xffffffd8(%ebp)
  110cfd:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  110d00:	39 45 d8             	cmp    %eax,0xffffffd8(%ebp)
  110d03:	76 06                	jbe    110d0b <tcp_slowtmr+0x10b>
  110d05:	8b 4d dc             	mov    0xffffffdc(%ebp),%ecx
  110d08:	89 4d d8             	mov    %ecx,0xffffffd8(%ebp)
  110d0b:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  110d0e:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
        pcb->ssthresh = eff_wnd >> 1;
  110d11:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  110d14:	d1 e8                	shr    %eax
  110d16:	89 c2                	mov    %eax,%edx
  110d18:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110d1b:	66 89 50 4c          	mov    %dx,0x4c(%eax)
        if (pcb->ssthresh < pcb->mss) {
  110d1f:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110d22:	0f b7 50 4c          	movzwl 0x4c(%eax),%edx
  110d26:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110d29:	0f b7 40 34          	movzwl 0x34(%eax),%eax
  110d2d:	66 39 c2             	cmp    %ax,%dx
  110d30:	73 15                	jae    110d47 <tcp_slowtmr+0x147>
          pcb->ssthresh = pcb->mss * 2;
  110d32:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110d35:	0f b7 40 34          	movzwl 0x34(%eax),%eax
  110d39:	0f b7 c0             	movzwl %ax,%eax
  110d3c:	01 c0                	add    %eax,%eax
  110d3e:	89 c2                	mov    %eax,%edx
  110d40:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110d43:	66 89 50 4c          	mov    %dx,0x4c(%eax)
        }
        pcb->cwnd = pcb->mss;
  110d47:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110d4a:	0f b7 50 34          	movzwl 0x34(%eax),%edx
  110d4e:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110d51:	66 89 50 4a          	mov    %dx,0x4a(%eax)
        LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_slowtmr: cwnd %u ssthresh %u\n",
                                pcb->cwnd, pcb->ssthresh));
      }
    }
    /* Check if this PCB has stayed too long in FIN-WAIT-2 */
    if (pcb->state == FIN_WAIT_2) {
  110d55:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110d58:	8b 40 10             	mov    0x10(%eax),%eax
  110d5b:	83 f8 06             	cmp    $0x6,%eax
  110d5e:	75 1b                	jne    110d7b <tcp_slowtmr+0x17b>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
  110d60:	8b 15 58 16 14 00    	mov    0x141658,%edx
  110d66:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110d69:	8b 40 2c             	mov    0x2c(%eax),%eax
  110d6c:	89 d1                	mov    %edx,%ecx
  110d6e:	29 c1                	sub    %eax,%ecx
  110d70:	89 c8                	mov    %ecx,%eax
  110d72:	83 f8 28             	cmp    $0x28,%eax
  110d75:	76 04                	jbe    110d7b <tcp_slowtmr+0x17b>
        TCP_FIN_WAIT_TIMEOUT / TCP_SLOW_INTERVAL) {
        ++pcb_remove;
  110d77:	80 45 fe 01          	addb   $0x1,0xfffffffe(%ebp)
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in FIN-WAIT-2\n"));
      }
    }

   /* Check if KEEPALIVE should be sent */
   if((pcb->so_options & SOF_KEEPALIVE) && ((pcb->state == ESTABLISHED) || (pcb->state == CLOSE_WAIT))) {
  110d7b:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110d7e:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  110d82:	0f b7 c0             	movzwl %ax,%eax
  110d85:	83 e0 08             	and    $0x8,%eax
  110d88:	85 c0                	test   %eax,%eax
  110d8a:	0f 84 bf 00 00 00    	je     110e4f <tcp_slowtmr+0x24f>
  110d90:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110d93:	8b 40 10             	mov    0x10(%eax),%eax
  110d96:	83 f8 04             	cmp    $0x4,%eax
  110d99:	74 0f                	je     110daa <tcp_slowtmr+0x1aa>
  110d9b:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110d9e:	8b 40 10             	mov    0x10(%eax),%eax
  110da1:	83 f8 07             	cmp    $0x7,%eax
  110da4:	0f 85 a5 00 00 00    	jne    110e4f <tcp_slowtmr+0x24f>
      if((u32_t)(tcp_ticks - pcb->tmr) > (pcb->keepalive + TCP_MAXIDLE) / TCP_SLOW_INTERVAL)  {
  110daa:	8b 15 58 16 14 00    	mov    0x141658,%edx
  110db0:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110db3:	8b 40 2c             	mov    0x2c(%eax),%eax
  110db6:	89 d1                	mov    %edx,%ecx
  110db8:	29 c1                	sub    %eax,%ecx
  110dba:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110dbd:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
  110dc3:	8d 90 b8 4c 0a 00    	lea    0xa4cb8(%eax),%edx
  110dc9:	c7 45 d4 d3 4d 62 10 	movl   $0x10624dd3,0xffffffd4(%ebp)
  110dd0:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
  110dd3:	f7 e2                	mul    %edx
  110dd5:	89 d0                	mov    %edx,%eax
  110dd7:	c1 e8 05             	shr    $0x5,%eax
  110dda:	39 c1                	cmp    %eax,%ecx
  110ddc:	76 0d                	jbe    110deb <tcp_slowtmr+0x1eb>
         LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: KEEPALIVE timeout. Aborting connection to %u.%u.%u.%u.\n",
                                 ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                                 ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip)));

         tcp_abort(pcb);
  110dde:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110de1:	89 04 24             	mov    %eax,(%esp)
  110de4:	e8 57 f5 ff ff       	call   110340 <tcp_abort>
  110de9:	eb 64                	jmp    110e4f <tcp_slowtmr+0x24f>
      }
      else if((u32_t)(tcp_ticks - pcb->tmr) > (pcb->keepalive + pcb->keep_cnt * TCP_KEEPINTVL) / TCP_SLOW_INTERVAL) {
  110deb:	8b 15 58 16 14 00    	mov    0x141658,%edx
  110df1:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110df4:	8b 40 2c             	mov    0x2c(%eax),%eax
  110df7:	89 d1                	mov    %edx,%ecx
  110df9:	29 c1                	sub    %eax,%ecx
  110dfb:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110dfe:	8b 90 94 00 00 00    	mov    0x94(%eax),%edx
  110e04:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110e07:	0f b6 80 98 00 00 00 	movzbl 0x98(%eax),%eax
  110e0e:	0f b6 c0             	movzbl %al,%eax
  110e11:	69 c0 f8 24 01 00    	imul   $0x124f8,%eax,%eax
  110e17:	01 c2                	add    %eax,%edx
  110e19:	c7 45 d4 d3 4d 62 10 	movl   $0x10624dd3,0xffffffd4(%ebp)
  110e20:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
  110e23:	f7 e2                	mul    %edx
  110e25:	89 d0                	mov    %edx,%eax
  110e27:	c1 e8 05             	shr    $0x5,%eax
  110e2a:	39 c1                	cmp    %eax,%ecx
  110e2c:	76 21                	jbe    110e4f <tcp_slowtmr+0x24f>
         tcp_keepalive(pcb);
  110e2e:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110e31:	89 04 24             	mov    %eax,(%esp)
  110e34:	e8 b7 18 00 00       	call   1126f0 <tcp_keepalive>
         pcb->keep_cnt++;
  110e39:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110e3c:	0f b6 80 98 00 00 00 	movzbl 0x98(%eax),%eax
  110e43:	8d 50 01             	lea    0x1(%eax),%edx
  110e46:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110e49:	88 90 98 00 00 00    	mov    %dl,0x98(%eax)
      }
   }

    /* If this PCB has queued out of sequence data, but has been
       inactive for too long, will drop the data (it will eventually
       be retransmitted). */
#if TCP_QUEUE_OOSEQ    
    if (pcb->ooseq != NULL &&
  110e4f:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110e52:	8b 40 78             	mov    0x78(%eax),%eax
  110e55:	85 c0                	test   %eax,%eax
  110e57:	74 3e                	je     110e97 <tcp_slowtmr+0x297>
  110e59:	8b 15 58 16 14 00    	mov    0x141658,%edx
  110e5f:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110e62:	8b 40 2c             	mov    0x2c(%eax),%eax
  110e65:	89 d1                	mov    %edx,%ecx
  110e67:	29 c1                	sub    %eax,%ecx
  110e69:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110e6c:	0f b7 40 40          	movzwl 0x40(%eax),%eax
  110e70:	0f b7 d0             	movzwl %ax,%edx
  110e73:	89 d0                	mov    %edx,%eax
  110e75:	01 c0                	add    %eax,%eax
  110e77:	01 d0                	add    %edx,%eax
  110e79:	01 c0                	add    %eax,%eax
  110e7b:	39 c1                	cmp    %eax,%ecx
  110e7d:	72 18                	jb     110e97 <tcp_slowtmr+0x297>
       (u32_t)tcp_ticks - pcb->tmr >=
       pcb->rto * TCP_OOSEQ_TIMEOUT) {
      tcp_segs_free(pcb->ooseq);
  110e7f:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110e82:	8b 40 78             	mov    0x78(%eax),%eax
  110e85:	89 04 24             	mov    %eax,(%esp)
  110e88:	e8 43 02 00 00       	call   1110d0 <tcp_segs_free>
      pcb->ooseq = NULL;
  110e8d:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110e90:	c7 40 78 00 00 00 00 	movl   $0x0,0x78(%eax)
      LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_slowtmr: dropping OOSEQ queued data\n"));
    }
#endif /* TCP_QUEUE_OOSEQ */

    /* Check if this PCB has stayed too long in SYN-RCVD */
    if (pcb->state == SYN_RCVD) {
  110e97:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110e9a:	8b 40 10             	mov    0x10(%eax),%eax
  110e9d:	83 f8 03             	cmp    $0x3,%eax
  110ea0:	75 1b                	jne    110ebd <tcp_slowtmr+0x2bd>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
  110ea2:	8b 15 58 16 14 00    	mov    0x141658,%edx
  110ea8:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110eab:	8b 40 2c             	mov    0x2c(%eax),%eax
  110eae:	89 d1                	mov    %edx,%ecx
  110eb0:	29 c1                	sub    %eax,%ecx
  110eb2:	89 c8                	mov    %ecx,%eax
  110eb4:	83 f8 28             	cmp    $0x28,%eax
  110eb7:	76 04                	jbe    110ebd <tcp_slowtmr+0x2bd>
   TCP_SYN_RCVD_TIMEOUT / TCP_SLOW_INTERVAL) {
        ++pcb_remove;
  110eb9:	80 45 fe 01          	addb   $0x1,0xfffffffe(%ebp)
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in SYN-RCVD\n"));
      }
    }


    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
  110ebd:	80 7d fe 00          	cmpb   $0x0,0xfffffffe(%ebp)
  110ec1:	74 77                	je     110f3a <tcp_slowtmr+0x33a>
      tcp_pcb_purge(pcb);      
  110ec3:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110ec6:	89 04 24             	mov    %eax,(%esp)
  110ec9:	e8 92 06 00 00       	call   111560 <tcp_pcb_purge>
      /* Remove PCB from tcp_active_pcbs list. */
      if (prev != NULL) {
  110ece:	83 7d f4 00          	cmpl   $0x0,0xfffffff4(%ebp)
  110ed2:	74 0e                	je     110ee2 <tcp_slowtmr+0x2e2>
  LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
        prev->next = pcb->next;
  110ed4:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110ed7:	8b 50 0c             	mov    0xc(%eax),%edx
  110eda:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  110edd:	89 50 0c             	mov    %edx,0xc(%eax)
  110ee0:	eb 0b                	jmp    110eed <tcp_slowtmr+0x2ed>
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
        tcp_active_pcbs = pcb->next;
  110ee2:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110ee5:	8b 40 0c             	mov    0xc(%eax),%eax
  110ee8:	a3 54 16 14 00       	mov    %eax,0x141654
      }

      TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_ABRT);
  110eed:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110ef0:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
  110ef6:	85 c0                	test   %eax,%eax
  110ef8:	74 1c                	je     110f16 <tcp_slowtmr+0x316>
  110efa:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110efd:	8b 90 90 00 00 00    	mov    0x90(%eax),%edx
  110f03:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110f06:	8b 40 18             	mov    0x18(%eax),%eax
  110f09:	c7 44 24 04 fd ff ff 	movl   $0xfffffffd,0x4(%esp)
  110f10:	ff 
  110f11:	89 04 24             	mov    %eax,(%esp)
  110f14:	ff d2                	call   *%edx

      pcb2 = pcb->next;
  110f16:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110f19:	8b 40 0c             	mov    0xc(%eax),%eax
  110f1c:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
      memp_free(MEMP_TCP_PCB, pcb);
  110f1f:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110f22:	89 44 24 04          	mov    %eax,0x4(%esp)
  110f26:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  110f2d:	e8 7e db ff ff       	call   10eab0 <memp_free>
      pcb = pcb2;
  110f32:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  110f35:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  110f38:	eb 74                	jmp    110fae <tcp_slowtmr+0x3ae>
    } else {

      /* We check if we should poll the connection. */
      ++pcb->polltmr;
  110f3a:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110f3d:	0f b6 40 30          	movzbl 0x30(%eax),%eax
  110f41:	8d 50 01             	lea    0x1(%eax),%edx
  110f44:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110f47:	88 50 30             	mov    %dl,0x30(%eax)
      if (pcb->polltmr >= pcb->pollinterval) {
  110f4a:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110f4d:	0f b6 50 30          	movzbl 0x30(%eax),%edx
  110f51:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110f54:	0f b6 40 31          	movzbl 0x31(%eax),%eax
  110f58:	38 c2                	cmp    %al,%dl
  110f5a:	72 43                	jb     110f9f <tcp_slowtmr+0x39f>
        pcb->polltmr = 0;
  110f5c:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110f5f:	c6 40 30 00          	movb   $0x0,0x30(%eax)
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: polling application\n"));
        TCP_EVENT_POLL(pcb, err);
  110f63:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110f66:	8b 80 8c 00 00 00    	mov    0x8c(%eax),%eax
  110f6c:	85 c0                	test   %eax,%eax
  110f6e:	74 1e                	je     110f8e <tcp_slowtmr+0x38e>
  110f70:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110f73:	8b 88 8c 00 00 00    	mov    0x8c(%eax),%ecx
  110f79:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110f7c:	8b 50 18             	mov    0x18(%eax),%edx
  110f7f:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110f82:	89 44 24 04          	mov    %eax,0x4(%esp)
  110f86:	89 14 24             	mov    %edx,(%esp)
  110f89:	ff d1                	call   *%ecx
  110f8b:	88 45 ff             	mov    %al,0xffffffff(%ebp)
        if (err == ERR_OK) {
  110f8e:	80 7d ff 00          	cmpb   $0x0,0xffffffff(%ebp)
  110f92:	75 0b                	jne    110f9f <tcp_slowtmr+0x39f>
          tcp_output(pcb);
  110f94:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110f97:	89 04 24             	mov    %eax,(%esp)
  110f9a:	e8 a1 0e 00 00       	call   111e40 <tcp_output>
        }
      }
      
      prev = pcb;
  110f9f:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110fa2:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
      pcb = pcb->next;
  110fa5:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110fa8:	8b 40 0c             	mov    0xc(%eax),%eax
  110fab:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  110fae:	83 7d ec 00          	cmpl   $0x0,0xffffffec(%ebp)
  110fb2:	0f 85 73 fc ff ff    	jne    110c2b <tcp_slowtmr+0x2b>
    }
  }

  
  /* Steps through all of the TIME-WAIT PCBs. */
  prev = NULL;    
  110fb8:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
  pcb = tcp_tw_pcbs;
  110fbf:	a1 64 16 14 00       	mov    0x141664,%eax
  110fc4:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  while (pcb != NULL) {
  110fc7:	e9 84 00 00 00       	jmp    111050 <tcp_slowtmr+0x450>
    LWIP_ASSERT("tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
    pcb_remove = 0;
  110fcc:	c6 45 fe 00          	movb   $0x0,0xfffffffe(%ebp)

    /* Check if this PCB has stayed long enough in TIME-WAIT */
    if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
  110fd0:	8b 15 58 16 14 00    	mov    0x141658,%edx
  110fd6:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110fd9:	8b 40 2c             	mov    0x2c(%eax),%eax
  110fdc:	89 d1                	mov    %edx,%ecx
  110fde:	29 c1                	sub    %eax,%ecx
  110fe0:	89 c8                	mov    %ecx,%eax
  110fe2:	3d f0 00 00 00       	cmp    $0xf0,%eax
  110fe7:	76 04                	jbe    110fed <tcp_slowtmr+0x3ed>
      ++pcb_remove;
  110fe9:	80 45 fe 01          	addb   $0x1,0xfffffffe(%ebp)
    }
    


    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
  110fed:	80 7d fe 00          	cmpb   $0x0,0xfffffffe(%ebp)
  110ff1:	74 4e                	je     111041 <tcp_slowtmr+0x441>
      tcp_pcb_purge(pcb);      
  110ff3:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110ff6:	89 04 24             	mov    %eax,(%esp)
  110ff9:	e8 62 05 00 00       	call   111560 <tcp_pcb_purge>
      /* Remove PCB from tcp_tw_pcbs list. */
      if (prev != NULL) {
  110ffe:	83 7d f4 00          	cmpl   $0x0,0xfffffff4(%ebp)
  111002:	74 0e                	je     111012 <tcp_slowtmr+0x412>
  LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_tw_pcbs", pcb != tcp_tw_pcbs);
        prev->next = pcb->next;
  111004:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  111007:	8b 50 0c             	mov    0xc(%eax),%edx
  11100a:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  11100d:	89 50 0c             	mov    %edx,0xc(%eax)
  111010:	eb 0b                	jmp    11101d <tcp_slowtmr+0x41d>
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_tw_pcbs", tcp_tw_pcbs == pcb);
        tcp_tw_pcbs = pcb->next;
  111012:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  111015:	8b 40 0c             	mov    0xc(%eax),%eax
  111018:	a3 64 16 14 00       	mov    %eax,0x141664
      }
      pcb2 = pcb->next;
  11101d:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  111020:	8b 40 0c             	mov    0xc(%eax),%eax
  111023:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
      memp_free(MEMP_TCP_PCB, pcb);
  111026:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  111029:	89 44 24 04          	mov    %eax,0x4(%esp)
  11102d:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  111034:	e8 77 da ff ff       	call   10eab0 <memp_free>
      pcb = pcb2;
  111039:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  11103c:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  11103f:	eb 0f                	jmp    111050 <tcp_slowtmr+0x450>
    } else {
      prev = pcb;
  111041:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  111044:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
      pcb = pcb->next;
  111047:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  11104a:	8b 40 0c             	mov    0xc(%eax),%eax
  11104d:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  111050:	83 7d ec 00          	cmpl   $0x0,0xffffffec(%ebp)
  111054:	0f 85 72 ff ff ff    	jne    110fcc <tcp_slowtmr+0x3cc>
    }
  }
}
  11105a:	c9                   	leave  
  11105b:	c3                   	ret    
  11105c:	8d 74 26 00          	lea    0x0(%esi),%esi

00111060 <tcp_fasttmr>:

/*
 * tcp_fasttmr():
 *
 * Is called every TCP_FAST_INTERVAL (250 ms) and sends delayed ACKs.
 */

void
tcp_fasttmr(void)
{
  111060:	55                   	push   %ebp
  111061:	89 e5                	mov    %esp,%ebp
  111063:	83 ec 18             	sub    $0x18,%esp
  struct tcp_pcb *pcb;

  /* send delayed ACKs */  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  111066:	a1 54 16 14 00       	mov    0x141654,%eax
  11106b:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  11106e:	eb 49                	jmp    1110b9 <tcp_fasttmr+0x59>
    if (pcb->flags & TF_ACK_DELAY) {
  111070:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  111073:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  111077:	0f b6 c0             	movzbl %al,%eax
  11107a:	83 e0 01             	and    $0x1,%eax
  11107d:	84 c0                	test   %al,%al
  11107f:	74 2f                	je     1110b0 <tcp_fasttmr+0x50>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
      tcp_ack_now(pcb);
  111081:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  111084:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  111088:	89 c2                	mov    %eax,%edx
  11108a:	83 ca 02             	or     $0x2,%edx
  11108d:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  111090:	88 50 20             	mov    %dl,0x20(%eax)
  111093:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  111096:	89 04 24             	mov    %eax,(%esp)
  111099:	e8 a2 0d 00 00       	call   111e40 <tcp_output>
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  11109e:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1110a1:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  1110a5:	89 c2                	mov    %eax,%edx
  1110a7:	83 e2 fc             	and    $0xfffffffc,%edx
  1110aa:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1110ad:	88 50 20             	mov    %dl,0x20(%eax)
  1110b0:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1110b3:	8b 40 0c             	mov    0xc(%eax),%eax
  1110b6:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  1110b9:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  1110bd:	75 b1                	jne    111070 <tcp_fasttmr+0x10>
    }
  }
}
  1110bf:	c9                   	leave  
  1110c0:	c3                   	ret    
  1110c1:	eb 0d                	jmp    1110d0 <tcp_segs_free>
  1110c3:	90                   	nop    
  1110c4:	90                   	nop    
  1110c5:	90                   	nop    
  1110c6:	90                   	nop    
  1110c7:	90                   	nop    
  1110c8:	90                   	nop    
  1110c9:	90                   	nop    
  1110ca:	90                   	nop    
  1110cb:	90                   	nop    
  1110cc:	90                   	nop    
  1110cd:	90                   	nop    
  1110ce:	90                   	nop    
  1110cf:	90                   	nop    

001110d0 <tcp_segs_free>:

/*
 * tcp_segs_free():
 *
 * Deallocates a list of TCP segments (tcp_seg structures).
 *
 */

u8_t
tcp_segs_free(struct tcp_seg *seg)
{
  1110d0:	55                   	push   %ebp
  1110d1:	89 e5                	mov    %esp,%ebp
  1110d3:	83 ec 18             	sub    $0x18,%esp
  u8_t count = 0;
  1110d6:	c6 45 fb 00          	movb   $0x0,0xfffffffb(%ebp)
  struct tcp_seg *next;
  while (seg != NULL) {
  1110da:	eb 1c                	jmp    1110f8 <tcp_segs_free+0x28>
    next = seg->next;
  1110dc:	8b 45 08             	mov    0x8(%ebp),%eax
  1110df:	8b 00                	mov    (%eax),%eax
  1110e1:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
    count += tcp_seg_free(seg);
  1110e4:	8b 45 08             	mov    0x8(%ebp),%eax
  1110e7:	89 04 24             	mov    %eax,(%esp)
  1110ea:	e8 21 00 00 00       	call   111110 <tcp_seg_free>
  1110ef:	00 45 fb             	add    %al,0xfffffffb(%ebp)
    seg = next;
  1110f2:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1110f5:	89 45 08             	mov    %eax,0x8(%ebp)
  1110f8:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  1110fc:	75 de                	jne    1110dc <tcp_segs_free+0xc>
  }
  return count;
  1110fe:	0f b6 45 fb          	movzbl 0xfffffffb(%ebp),%eax
}
  111102:	c9                   	leave  
  111103:	c3                   	ret    
  111104:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  11110a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

00111110 <tcp_seg_free>:

/*
 * tcp_seg_free():
 *
 * Frees a TCP segment.
 *
 */

u8_t
tcp_seg_free(struct tcp_seg *seg)
{
  111110:	55                   	push   %ebp
  111111:	89 e5                	mov    %esp,%ebp
  111113:	83 ec 18             	sub    $0x18,%esp
  u8_t count = 0;
  111116:	c6 45 ff 00          	movb   $0x0,0xffffffff(%ebp)
  
  if (seg != NULL) {
  11111a:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  11111e:	74 2e                	je     11114e <tcp_seg_free+0x3e>
    if (seg->p != NULL) {
  111120:	8b 45 08             	mov    0x8(%ebp),%eax
  111123:	8b 40 04             	mov    0x4(%eax),%eax
  111126:	85 c0                	test   %eax,%eax
  111128:	74 11                	je     11113b <tcp_seg_free+0x2b>
      count = pbuf_free(seg->p);
  11112a:	8b 45 08             	mov    0x8(%ebp),%eax
  11112d:	8b 40 04             	mov    0x4(%eax),%eax
  111130:	89 04 24             	mov    %eax,(%esp)
  111133:	e8 78 e3 ff ff       	call   10f4b0 <pbuf_free>
  111138:	88 45 ff             	mov    %al,0xffffffff(%ebp)
#if TCP_DEBUG
      seg->p = NULL;
#endif /* TCP_DEBUG */
    }
    memp_free(MEMP_TCP_SEG, seg);
  11113b:	8b 45 08             	mov    0x8(%ebp),%eax
  11113e:	89 44 24 04          	mov    %eax,0x4(%esp)
  111142:	c7 04 24 05 00 00 00 	movl   $0x5,(%esp)
  111149:	e8 62 d9 ff ff       	call   10eab0 <memp_free>
  }
  return count;
  11114e:	0f b6 45 ff          	movzbl 0xffffffff(%ebp),%eax
}
  111152:	c9                   	leave  
  111153:	c3                   	ret    
  111154:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  11115a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

00111160 <tcp_setprio>:

/*
 * tcp_setprio():
 *
 * Sets the priority of a connection.
 *
 */

void
tcp_setprio(struct tcp_pcb *pcb, u8_t prio)
{
  111160:	55                   	push   %ebp
  111161:	89 e5                	mov    %esp,%ebp
  111163:	83 ec 04             	sub    $0x4,%esp
  111166:	8b 45 0c             	mov    0xc(%ebp),%eax
  111169:	88 45 fc             	mov    %al,0xfffffffc(%ebp)
  pcb->prio = prio;
  11116c:	8b 55 08             	mov    0x8(%ebp),%edx
  11116f:	0f b6 45 fc          	movzbl 0xfffffffc(%ebp),%eax
  111173:	88 42 14             	mov    %al,0x14(%edx)
}
  111176:	c9                   	leave  
  111177:	c3                   	ret    
  111178:	90                   	nop    
  111179:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

00111180 <tcp_seg_copy>:
#if TCP_QUEUE_OOSEQ

/*
 * tcp_seg_copy():
 *
 * Returns a copy of the given TCP segment.
 *
 */ 

struct tcp_seg *
tcp_seg_copy(struct tcp_seg *seg)
{
  111180:	55                   	push   %ebp
  111181:	89 e5                	mov    %esp,%ebp
  111183:	83 ec 28             	sub    $0x28,%esp
  struct tcp_seg *cseg;

  cseg = memp_malloc(MEMP_TCP_SEG);
  111186:	c7 04 24 05 00 00 00 	movl   $0x5,(%esp)
  11118d:	e8 2e d8 ff ff       	call   10e9c0 <memp_malloc>
  111192:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  if (cseg == NULL) {
  111195:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  111199:	75 09                	jne    1111a4 <tcp_seg_copy+0x24>
    return NULL;
  11119b:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  1111a2:	eb 2e                	jmp    1111d2 <tcp_seg_copy+0x52>
  }
  memcpy((char *)cseg, (const char *)seg, sizeof(struct tcp_seg)); 
  1111a4:	8b 45 08             	mov    0x8(%ebp),%eax
  1111a7:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  1111aa:	c7 44 24 08 14 00 00 	movl   $0x14,0x8(%esp)
  1111b1:	00 
  1111b2:	89 44 24 04          	mov    %eax,0x4(%esp)
  1111b6:	89 14 24             	mov    %edx,(%esp)
  1111b9:	e8 02 4d ff ff       	call   105ec0 <memcpy>
  pbuf_ref(cseg->p);
  1111be:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1111c1:	8b 40 04             	mov    0x4(%eax),%eax
  1111c4:	89 04 24             	mov    %eax,(%esp)
  1111c7:	e8 54 e4 ff ff       	call   10f620 <pbuf_ref>
  return cseg;
  1111cc:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1111cf:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  1111d2:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  1111d5:	c9                   	leave  
  1111d6:	c3                   	ret    
  1111d7:	89 f6                	mov    %esi,%esi
  1111d9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

001111e0 <tcp_recv_null>:
#endif

#if LWIP_CALLBACK_API
static err_t
tcp_recv_null(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
  1111e0:	55                   	push   %ebp
  1111e1:	89 e5                	mov    %esp,%ebp
  1111e3:	83 ec 18             	sub    $0x18,%esp
  1111e6:	8b 45 14             	mov    0x14(%ebp),%eax
  1111e9:	88 45 fc             	mov    %al,0xfffffffc(%ebp)
  arg = arg;
  if (p != NULL) {
  1111ec:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  1111f0:	74 0d                	je     1111ff <tcp_recv_null+0x1f>
    pbuf_free(p);
  1111f2:	8b 45 10             	mov    0x10(%ebp),%eax
  1111f5:	89 04 24             	mov    %eax,(%esp)
  1111f8:	e8 b3 e2 ff ff       	call   10f4b0 <pbuf_free>
  1111fd:	eb 19                	jmp    111218 <tcp_recv_null+0x38>
  } else if (err == ERR_OK) {
  1111ff:	80 7d fc 00          	cmpb   $0x0,0xfffffffc(%ebp)
  111203:	75 13                	jne    111218 <tcp_recv_null+0x38>
    return tcp_close(pcb);
  111205:	8b 45 0c             	mov    0xc(%ebp),%eax
  111208:	89 04 24             	mov    %eax,(%esp)
  11120b:	e8 20 f0 ff ff       	call   110230 <tcp_close>
  111210:	0f be c0             	movsbl %al,%eax
  111213:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  111216:	eb 07                	jmp    11121f <tcp_recv_null+0x3f>
  }
  return ERR_OK;
  111218:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)
  11121f:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
}
  111222:	c9                   	leave  
  111223:	c3                   	ret    
  111224:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  11122a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

00111230 <tcp_kill_prio>:
#endif /* LWIP_CALLBACK_API */

static void
tcp_kill_prio(u8_t prio)
{
  111230:	55                   	push   %ebp
  111231:	89 e5                	mov    %esp,%ebp
  111233:	83 ec 18             	sub    $0x18,%esp
  111236:	8b 45 08             	mov    0x8(%ebp),%eax
  111239:	88 45 ec             	mov    %al,0xffffffec(%ebp)
  struct tcp_pcb *pcb, *inactive;
  u32_t inactivity;
  u8_t mprio;


  mprio = TCP_PRIO_MAX;
  11123c:	c6 45 ff 7f          	movb   $0x7f,0xffffffff(%ebp)
  
  /* We kill the oldest active connection that has lower priority than
     prio. */
  inactivity = 0;
  111240:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)
  inactive = NULL;
  111247:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  11124e:	a1 54 16 14 00       	mov    0x141654,%eax
  111253:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
  111256:	eb 5d                	jmp    1112b5 <tcp_kill_prio+0x85>
    if (pcb->prio <= prio &&
  111258:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  11125b:	0f b6 40 14          	movzbl 0x14(%eax),%eax
  11125f:	3a 45 ec             	cmp    0xffffffec(%ebp),%al
  111262:	77 48                	ja     1112ac <tcp_kill_prio+0x7c>
  111264:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  111267:	0f b6 40 14          	movzbl 0x14(%eax),%eax
  11126b:	3a 45 ff             	cmp    0xffffffff(%ebp),%al
  11126e:	77 3c                	ja     1112ac <tcp_kill_prio+0x7c>
  111270:	8b 15 58 16 14 00    	mov    0x141658,%edx
  111276:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  111279:	8b 40 2c             	mov    0x2c(%eax),%eax
  11127c:	89 d1                	mov    %edx,%ecx
  11127e:	29 c1                	sub    %eax,%ecx
  111280:	89 c8                	mov    %ecx,%eax
  111282:	3b 45 f8             	cmp    0xfffffff8(%ebp),%eax
  111285:	72 25                	jb     1112ac <tcp_kill_prio+0x7c>
       pcb->prio <= mprio &&
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
      inactivity = tcp_ticks - pcb->tmr;
  111287:	8b 15 58 16 14 00    	mov    0x141658,%edx
  11128d:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  111290:	8b 40 2c             	mov    0x2c(%eax),%eax
  111293:	89 d1                	mov    %edx,%ecx
  111295:	29 c1                	sub    %eax,%ecx
  111297:	89 c8                	mov    %ecx,%eax
  111299:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
      inactive = pcb;
  11129c:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  11129f:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
      mprio = pcb->prio;
  1112a2:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  1112a5:	0f b6 40 14          	movzbl 0x14(%eax),%eax
  1112a9:	88 45 ff             	mov    %al,0xffffffff(%ebp)
  1112ac:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  1112af:	8b 40 0c             	mov    0xc(%eax),%eax
  1112b2:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
  1112b5:	83 7d f0 00          	cmpl   $0x0,0xfffffff0(%ebp)
  1112b9:	75 9d                	jne    111258 <tcp_kill_prio+0x28>
    }
  }
  if (inactive != NULL) {
  1112bb:	83 7d f4 00          	cmpl   $0x0,0xfffffff4(%ebp)
  1112bf:	74 0b                	je     1112cc <tcp_kill_prio+0x9c>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_prio: killing oldest PCB 0x%p (%ld)\n",
           (void *)inactive, inactivity));
    tcp_abort(inactive);
  1112c1:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  1112c4:	89 04 24             	mov    %eax,(%esp)
  1112c7:	e8 74 f0 ff ff       	call   110340 <tcp_abort>
  }      
}
  1112cc:	c9                   	leave  
  1112cd:	c3                   	ret    
  1112ce:	89 f6                	mov    %esi,%esi

001112d0 <tcp_kill_timewait>:


static void
tcp_kill_timewait(void)
{
  1112d0:	55                   	push   %ebp
  1112d1:	89 e5                	mov    %esp,%ebp
  1112d3:	83 ec 18             	sub    $0x18,%esp
  struct tcp_pcb *pcb, *inactive;
  u32_t inactivity;

  inactivity = 0;
  1112d6:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
  inactive = NULL;
  1112dd:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  1112e4:	a1 64 16 14 00       	mov    0x141664,%eax
  1112e9:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  1112ec:	eb 3b                	jmp    111329 <tcp_kill_timewait+0x59>
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  1112ee:	8b 15 58 16 14 00    	mov    0x141658,%edx
  1112f4:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  1112f7:	8b 40 2c             	mov    0x2c(%eax),%eax
  1112fa:	89 d1                	mov    %edx,%ecx
  1112fc:	29 c1                	sub    %eax,%ecx
  1112fe:	89 c8                	mov    %ecx,%eax
  111300:	3b 45 fc             	cmp    0xfffffffc(%ebp),%eax
  111303:	72 1b                	jb     111320 <tcp_kill_timewait+0x50>
      inactivity = tcp_ticks - pcb->tmr;
  111305:	8b 15 58 16 14 00    	mov    0x141658,%edx
  11130b:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  11130e:	8b 40 2c             	mov    0x2c(%eax),%eax
  111311:	89 d1                	mov    %edx,%ecx
  111313:	29 c1                	sub    %eax,%ecx
  111315:	89 c8                	mov    %ecx,%eax
  111317:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
      inactive = pcb;
  11131a:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  11131d:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  111320:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  111323:	8b 40 0c             	mov    0xc(%eax),%eax
  111326:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  111329:	83 7d f4 00          	cmpl   $0x0,0xfffffff4(%ebp)
  11132d:	75 bf                	jne    1112ee <tcp_kill_timewait+0x1e>
    }
  }
  if (inactive != NULL) {
  11132f:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  111333:	74 0b                	je     111340 <tcp_kill_timewait+0x70>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_timewait: killing oldest TIME-WAIT PCB 0x%p (%ld)\n",
           (void *)inactive, inactivity));
    tcp_abort(inactive);
  111335:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  111338:	89 04 24             	mov    %eax,(%esp)
  11133b:	e8 00 f0 ff ff       	call   110340 <tcp_abort>
  }      
}
  111340:	c9                   	leave  
  111341:	c3                   	ret    
  111342:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi
  111349:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00111350 <tcp_alloc>:



struct tcp_pcb *
tcp_alloc(u8_t prio)
{
  111350:	55                   	push   %ebp
  111351:	89 e5                	mov    %esp,%ebp
  111353:	83 ec 28             	sub    $0x28,%esp
  111356:	8b 45 08             	mov    0x8(%ebp),%eax
  111359:	88 45 ec             	mov    %al,0xffffffec(%ebp)
  struct tcp_pcb *pcb;
  u32_t iss;
  
  pcb = memp_malloc(MEMP_TCP_PCB);
  11135c:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  111363:	e8 58 d6 ff ff       	call   10e9c0 <memp_malloc>
  111368:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  if (pcb == NULL) {
  11136b:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  11136f:	75 35                	jne    1113a6 <tcp_alloc+0x56>
    /* Try killing oldest connection in TIME-WAIT. */
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing off oldest TIME-WAIT connection\n"));
    tcp_kill_timewait();
  111371:	e8 5a ff ff ff       	call   1112d0 <tcp_kill_timewait>
    pcb = memp_malloc(MEMP_TCP_PCB);
  111376:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  11137d:	e8 3e d6 ff ff       	call   10e9c0 <memp_malloc>
  111382:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
    if (pcb == NULL) {
  111385:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  111389:	75 1b                	jne    1113a6 <tcp_alloc+0x56>
      tcp_kill_prio(prio);    
  11138b:	0f b6 45 ec          	movzbl 0xffffffec(%ebp),%eax
  11138f:	89 04 24             	mov    %eax,(%esp)
  111392:	e8 99 fe ff ff       	call   111230 <tcp_kill_prio>
      pcb = memp_malloc(MEMP_TCP_PCB);
  111397:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  11139e:	e8 1d d6 ff ff       	call   10e9c0 <memp_malloc>
  1113a3:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
    }
  }
  if (pcb != NULL) {
  1113a6:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  1113aa:	0f 84 eb 00 00 00    	je     11149b <tcp_alloc+0x14b>
    memset(pcb, 0, sizeof(struct tcp_pcb));
  1113b0:	c7 44 24 08 9c 00 00 	movl   $0x9c,0x8(%esp)
  1113b7:	00 
  1113b8:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  1113bf:	00 
  1113c0:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1113c3:	89 04 24             	mov    %eax,(%esp)
  1113c6:	e8 35 4b ff ff       	call   105f00 <memset>
    pcb->prio = TCP_PRIO_NORMAL;
  1113cb:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1113ce:	c6 40 14 40          	movb   $0x40,0x14(%eax)
    pcb->snd_buf = TCP_SND_BUF;
  1113d2:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1113d5:	66 c7 40 6a 00 08    	movw   $0x800,0x6a(%eax)
    pcb->snd_queuelen = 0;
  1113db:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1113de:	c6 40 6c 00          	movb   $0x0,0x6c(%eax)
    pcb->rcv_wnd = TCP_WND;
  1113e2:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1113e5:	66 c7 40 28 00 20    	movw   $0x2000,0x28(%eax)
    pcb->tos = 0;
  1113eb:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1113ee:	c6 40 0a 00          	movb   $0x0,0xa(%eax)
    pcb->ttl = TCP_TTL;
  1113f2:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1113f5:	c6 40 0b ff          	movb   $0xff,0xb(%eax)
    pcb->mss = TCP_MSS;
  1113f9:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1113fc:	66 c7 40 34 00 02    	movw   $0x200,0x34(%eax)
    pcb->rto = 3000 / TCP_SLOW_INTERVAL;
  111402:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  111405:	66 c7 40 40 06 00    	movw   $0x6,0x40(%eax)
    pcb->sa = 0;
  11140b:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  11140e:	66 c7 40 3c 00 00    	movw   $0x0,0x3c(%eax)
    pcb->sv = 3000 / TCP_SLOW_INTERVAL;
  111414:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  111417:	66 c7 40 3e 06 00    	movw   $0x6,0x3e(%eax)
    pcb->rtime = 0;
  11141d:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  111420:	66 c7 40 32 00 00    	movw   $0x0,0x32(%eax)
    pcb->cwnd = 1;
  111426:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  111429:	66 c7 40 4a 01 00    	movw   $0x1,0x4a(%eax)
    iss = tcp_next_iss();
  11142f:	e8 7c 02 00 00       	call   1116b0 <tcp_next_iss>
  111434:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
    pcb->snd_wl2 = iss;
  111437:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  11143a:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  11143d:	89 42 60             	mov    %eax,0x60(%edx)
    pcb->snd_nxt = iss;
  111440:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  111443:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  111446:	89 42 50             	mov    %eax,0x50(%edx)
    pcb->snd_max = iss;
  111449:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  11144c:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  11144f:	89 42 54             	mov    %eax,0x54(%edx)
    pcb->lastack = iss;
  111452:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  111455:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  111458:	89 42 44             	mov    %eax,0x44(%edx)
    pcb->snd_lbb = iss;   
  11145b:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  11145e:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  111461:	89 42 64             	mov    %eax,0x64(%edx)
    pcb->tmr = tcp_ticks;
  111464:	8b 15 58 16 14 00    	mov    0x141658,%edx
  11146a:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  11146d:	89 50 2c             	mov    %edx,0x2c(%eax)

    pcb->polltmr = 0;
  111470:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  111473:	c6 40 30 00          	movb   $0x0,0x30(%eax)

#if LWIP_CALLBACK_API
    pcb->recv = tcp_recv_null;
  111477:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  11147a:	c7 80 80 00 00 00 e0 	movl   $0x1111e0,0x80(%eax)
  111481:	11 11 00 
#endif /* LWIP_CALLBACK_API */  
    
    /* Init KEEPALIVE timer */
    pcb->keepalive = TCP_KEEPDEFAULT;
  111484:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  111487:	c7 80 94 00 00 00 00 	movl   $0x6ddd00,0x94(%eax)
  11148e:	dd 6d 00 
    pcb->keep_cnt = 0;
  111491:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  111494:	c6 80 98 00 00 00 00 	movb   $0x0,0x98(%eax)
  }
  return pcb;
  11149b:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
}
  11149e:	c9                   	leave  
  11149f:	c3                   	ret    

001114a0 <tcp_new>:

/*
 * tcp_new():
 *
 * Creates a new TCP protocol control block but doesn't place it on
 * any of the TCP PCB lists.
 *
 */

struct tcp_pcb *
tcp_new(void)
{
  1114a0:	55                   	push   %ebp
  1114a1:	89 e5                	mov    %esp,%ebp
  1114a3:	83 ec 08             	sub    $0x8,%esp
  return tcp_alloc(TCP_PRIO_NORMAL);
  1114a6:	c7 04 24 40 00 00 00 	movl   $0x40,(%esp)
  1114ad:	e8 9e fe ff ff       	call   111350 <tcp_alloc>
}
  1114b2:	c9                   	leave  
  1114b3:	c3                   	ret    
  1114b4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  1114ba:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

001114c0 <tcp_arg>:

/*
 * tcp_arg():
 *
 * Used to specify the argument that should be passed callback
 * functions.
 *
 */ 

void
tcp_arg(struct tcp_pcb *pcb, void *arg)
{  
  1114c0:	55                   	push   %ebp
  1114c1:	89 e5                	mov    %esp,%ebp
  pcb->callback_arg = arg;
  1114c3:	8b 55 08             	mov    0x8(%ebp),%edx
  1114c6:	8b 45 0c             	mov    0xc(%ebp),%eax
  1114c9:	89 42 18             	mov    %eax,0x18(%edx)
}
  1114cc:	5d                   	pop    %ebp
  1114cd:	c3                   	ret    
  1114ce:	89 f6                	mov    %esi,%esi

001114d0 <tcp_recv>:
#if LWIP_CALLBACK_API

/*
 * tcp_recv():
 *
 * Used to specify the function that should be called when a TCP
 * connection receives data.
 *
 */ 

void
tcp_recv(struct tcp_pcb *pcb,
   err_t (* recv)(void *arg, struct tcp_pcb *tpcb, struct pbuf *p, err_t err))
{
  1114d0:	55                   	push   %ebp
  1114d1:	89 e5                	mov    %esp,%ebp
  pcb->recv = recv;
  1114d3:	8b 55 08             	mov    0x8(%ebp),%edx
  1114d6:	8b 45 0c             	mov    0xc(%ebp),%eax
  1114d9:	89 82 80 00 00 00    	mov    %eax,0x80(%edx)
}
  1114df:	5d                   	pop    %ebp
  1114e0:	c3                   	ret    
  1114e1:	eb 0d                	jmp    1114f0 <tcp_sent>
  1114e3:	90                   	nop    
  1114e4:	90                   	nop    
  1114e5:	90                   	nop    
  1114e6:	90                   	nop    
  1114e7:	90                   	nop    
  1114e8:	90                   	nop    
  1114e9:	90                   	nop    
  1114ea:	90                   	nop    
  1114eb:	90                   	nop    
  1114ec:	90                   	nop    
  1114ed:	90                   	nop    
  1114ee:	90                   	nop    
  1114ef:	90                   	nop    

001114f0 <tcp_sent>:

/*
 * tcp_sent():
 *
 * Used to specify the function that should be called when TCP data
 * has been successfully delivered to the remote host.
 *
 */ 

void
tcp_sent(struct tcp_pcb *pcb,
   err_t (* sent)(void *arg, struct tcp_pcb *tpcb, u16_t len))
{
  1114f0:	55                   	push   %ebp
  1114f1:	89 e5                	mov    %esp,%ebp
  pcb->sent = sent;
  1114f3:	8b 55 08             	mov    0x8(%ebp),%edx
  1114f6:	8b 45 0c             	mov    0xc(%ebp),%eax
  1114f9:	89 42 7c             	mov    %eax,0x7c(%edx)
}
  1114fc:	5d                   	pop    %ebp
  1114fd:	c3                   	ret    
  1114fe:	89 f6                	mov    %esi,%esi

00111500 <tcp_err>:

/*
 * tcp_err():
 *
 * Used to specify the function that should be called when a fatal error
 * has occured on the connection.
 *
 */ 

void
tcp_err(struct tcp_pcb *pcb,
   void (* errf)(void *arg, err_t err))
{
  111500:	55                   	push   %ebp
  111501:	89 e5                	mov    %esp,%ebp
  pcb->errf = errf;
  111503:	8b 55 08             	mov    0x8(%ebp),%edx
  111506:	8b 45 0c             	mov    0xc(%ebp),%eax
  111509:	89 82 90 00 00 00    	mov    %eax,0x90(%edx)
}
  11150f:	5d                   	pop    %ebp
  111510:	c3                   	ret    
  111511:	eb 0d                	jmp    111520 <tcp_accept>
  111513:	90                   	nop    
  111514:	90                   	nop    
  111515:	90                   	nop    
  111516:	90                   	nop    
  111517:	90                   	nop    
  111518:	90                   	nop    
  111519:	90                   	nop    
  11151a:	90                   	nop    
  11151b:	90                   	nop    
  11151c:	90                   	nop    
  11151d:	90                   	nop    
  11151e:	90                   	nop    
  11151f:	90                   	nop    

00111520 <tcp_accept>:

/*
 * tcp_accept():
 *
 * Used for specifying the function that should be called when a
 * LISTENing connection has been connected to another host.
 *
 */ 

void
tcp_accept(struct tcp_pcb *pcb,
     err_t (* accept)(void *arg, struct tcp_pcb *newpcb, err_t err))
{
  111520:	55                   	push   %ebp
  111521:	89 e5                	mov    %esp,%ebp
  ((struct tcp_pcb_listen *)pcb)->accept = accept;
  111523:	8b 55 08             	mov    0x8(%ebp),%edx
  111526:	8b 45 0c             	mov    0xc(%ebp),%eax
  111529:	89 42 20             	mov    %eax,0x20(%edx)
}
  11152c:	5d                   	pop    %ebp
  11152d:	c3                   	ret    
  11152e:	89 f6                	mov    %esi,%esi

00111530 <tcp_poll>:
#endif /* LWIP_CALLBACK_API */


/*
 * tcp_poll():
 *
 * Used to specify the function that should be called periodically
 * from TCP. The interval is specified in terms of the TCP coarse
 * timer interval, which is called twice a second.
 *
 */ 

void
tcp_poll(struct tcp_pcb *pcb,
   err_t (* poll)(void *arg, struct tcp_pcb *tpcb), u8_t interval)
{
  111530:	55                   	push   %ebp
  111531:	89 e5                	mov    %esp,%ebp
  111533:	83 ec 04             	sub    $0x4,%esp
  111536:	8b 45 10             	mov    0x10(%ebp),%eax
  111539:	88 45 fc             	mov    %al,0xfffffffc(%ebp)
#if LWIP_CALLBACK_API
  pcb->poll = poll;
  11153c:	8b 55 08             	mov    0x8(%ebp),%edx
  11153f:	8b 45 0c             	mov    0xc(%ebp),%eax
  111542:	89 82 8c 00 00 00    	mov    %eax,0x8c(%edx)
#endif /* LWIP_CALLBACK_API */  
  pcb->pollinterval = interval;
  111548:	8b 55 08             	mov    0x8(%ebp),%edx
  11154b:	0f b6 45 fc          	movzbl 0xfffffffc(%ebp),%eax
  11154f:	88 42 31             	mov    %al,0x31(%edx)
}
  111552:	c9                   	leave  
  111553:	c3                   	ret    
  111554:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  11155a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

00111560 <tcp_pcb_purge>:

/*
 * tcp_pcb_purge():
 *
 * Purges a TCP PCB. Removes any buffered data and frees the buffer memory.
 *
 */

void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
  111560:	55                   	push   %ebp
  111561:	89 e5                	mov    %esp,%ebp
  111563:	83 ec 08             	sub    $0x8,%esp
  if (pcb->state != CLOSED &&
  111566:	8b 45 08             	mov    0x8(%ebp),%eax
  111569:	8b 40 10             	mov    0x10(%eax),%eax
  11156c:	85 c0                	test   %eax,%eax
  11156e:	74 60                	je     1115d0 <tcp_pcb_purge+0x70>
  111570:	8b 45 08             	mov    0x8(%ebp),%eax
  111573:	8b 40 10             	mov    0x10(%eax),%eax
  111576:	83 f8 0a             	cmp    $0xa,%eax
  111579:	74 55                	je     1115d0 <tcp_pcb_purge+0x70>
  11157b:	8b 45 08             	mov    0x8(%ebp),%eax
  11157e:	8b 40 10             	mov    0x10(%eax),%eax
  111581:	83 f8 01             	cmp    $0x1,%eax
  111584:	74 4a                	je     1115d0 <tcp_pcb_purge+0x70>
     pcb->state != TIME_WAIT &&
     pcb->state != LISTEN) {

    LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge\n"));
    
    if (pcb->unsent != NULL) {    
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: not all data sent\n"));
    }
    if (pcb->unacked != NULL) {    
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->unacked\n"));
    }
#if TCP_QUEUE_OOSEQ /* LW */
    if (pcb->ooseq != NULL) {    
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->ooseq\n"));
    }
    
    tcp_segs_free(pcb->ooseq);
  111586:	8b 45 08             	mov    0x8(%ebp),%eax
  111589:	8b 40 78             	mov    0x78(%eax),%eax
  11158c:	89 04 24             	mov    %eax,(%esp)
  11158f:	e8 3c fb ff ff       	call   1110d0 <tcp_segs_free>
    pcb->ooseq = NULL;
  111594:	8b 45 08             	mov    0x8(%ebp),%eax
  111597:	c7 40 78 00 00 00 00 	movl   $0x0,0x78(%eax)
#endif /* TCP_QUEUE_OOSEQ */
    tcp_segs_free(pcb->unsent);
  11159e:	8b 45 08             	mov    0x8(%ebp),%eax
  1115a1:	8b 40 70             	mov    0x70(%eax),%eax
  1115a4:	89 04 24             	mov    %eax,(%esp)
  1115a7:	e8 24 fb ff ff       	call   1110d0 <tcp_segs_free>
    tcp_segs_free(pcb->unacked);
  1115ac:	8b 45 08             	mov    0x8(%ebp),%eax
  1115af:	8b 40 74             	mov    0x74(%eax),%eax
  1115b2:	89 04 24             	mov    %eax,(%esp)
  1115b5:	e8 16 fb ff ff       	call   1110d0 <tcp_segs_free>
    pcb->unacked = pcb->unsent = NULL;
  1115ba:	8b 45 08             	mov    0x8(%ebp),%eax
  1115bd:	c7 40 70 00 00 00 00 	movl   $0x0,0x70(%eax)
  1115c4:	8b 45 08             	mov    0x8(%ebp),%eax
  1115c7:	8b 50 70             	mov    0x70(%eax),%edx
  1115ca:	8b 45 08             	mov    0x8(%ebp),%eax
  1115cd:	89 50 74             	mov    %edx,0x74(%eax)
  }
}
  1115d0:	c9                   	leave  
  1115d1:	c3                   	ret    
  1115d2:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi
  1115d9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

001115e0 <tcp_pcb_remove>:

/*
 * tcp_pcb_remove():
 *
 * Purges the PCB and removes it from a PCB list. Any delayed ACKs are sent first.
 *
 */

void
tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
{
  1115e0:	55                   	push   %ebp
  1115e1:	89 e5                	mov    %esp,%ebp
  1115e3:	83 ec 08             	sub    $0x8,%esp
  TCP_RMV(pcblist, pcb);
  1115e6:	8b 45 08             	mov    0x8(%ebp),%eax
  1115e9:	8b 00                	mov    (%eax),%eax
  1115eb:	3b 45 0c             	cmp    0xc(%ebp),%eax
  1115ee:	75 0f                	jne    1115ff <tcp_pcb_remove+0x1f>
  1115f0:	8b 45 08             	mov    0x8(%ebp),%eax
  1115f3:	8b 00                	mov    (%eax),%eax
  1115f5:	8b 50 0c             	mov    0xc(%eax),%edx
  1115f8:	8b 45 08             	mov    0x8(%ebp),%eax
  1115fb:	89 10                	mov    %edx,(%eax)
  1115fd:	eb 4b                	jmp    11164a <tcp_pcb_remove+0x6a>
  1115ff:	8b 45 08             	mov    0x8(%ebp),%eax
  111602:	8b 00                	mov    (%eax),%eax
  111604:	a3 60 16 14 00       	mov    %eax,0x141660
  111609:	eb 36                	jmp    111641 <tcp_pcb_remove+0x61>
  11160b:	a1 60 16 14 00       	mov    0x141660,%eax
  111610:	8b 40 0c             	mov    0xc(%eax),%eax
  111613:	85 c0                	test   %eax,%eax
  111615:	74 1d                	je     111634 <tcp_pcb_remove+0x54>
  111617:	a1 60 16 14 00       	mov    0x141660,%eax
  11161c:	8b 40 0c             	mov    0xc(%eax),%eax
  11161f:	3b 45 0c             	cmp    0xc(%ebp),%eax
  111622:	75 10                	jne    111634 <tcp_pcb_remove+0x54>
  111624:	a1 60 16 14 00       	mov    0x141660,%eax
  111629:	8b 55 0c             	mov    0xc(%ebp),%edx
  11162c:	8b 52 0c             	mov    0xc(%edx),%edx
  11162f:	89 50 0c             	mov    %edx,0xc(%eax)
  111632:	eb 16                	jmp    11164a <tcp_pcb_remove+0x6a>
  111634:	a1 60 16 14 00       	mov    0x141660,%eax
  111639:	8b 40 0c             	mov    0xc(%eax),%eax
  11163c:	a3 60 16 14 00       	mov    %eax,0x141660
  111641:	a1 60 16 14 00       	mov    0x141660,%eax
  111646:	85 c0                	test   %eax,%eax
  111648:	75 c1                	jne    11160b <tcp_pcb_remove+0x2b>
  11164a:	8b 45 0c             	mov    0xc(%ebp),%eax
  11164d:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)

  tcp_pcb_purge(pcb);
  111654:	8b 45 0c             	mov    0xc(%ebp),%eax
  111657:	89 04 24             	mov    %eax,(%esp)
  11165a:	e8 01 ff ff ff       	call   111560 <tcp_pcb_purge>
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
  11165f:	8b 45 0c             	mov    0xc(%ebp),%eax
  111662:	8b 40 10             	mov    0x10(%eax),%eax
  111665:	83 f8 0a             	cmp    $0xa,%eax
  111668:	74 39                	je     1116a3 <tcp_pcb_remove+0xc3>
  11166a:	8b 45 0c             	mov    0xc(%ebp),%eax
  11166d:	8b 40 10             	mov    0x10(%eax),%eax
  111670:	83 f8 01             	cmp    $0x1,%eax
  111673:	74 2e                	je     1116a3 <tcp_pcb_remove+0xc3>
  111675:	8b 45 0c             	mov    0xc(%ebp),%eax
  111678:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  11167c:	0f b6 c0             	movzbl %al,%eax
  11167f:	83 e0 01             	and    $0x1,%eax
  111682:	84 c0                	test   %al,%al
  111684:	74 1d                	je     1116a3 <tcp_pcb_remove+0xc3>
     pcb->state != LISTEN &&
     pcb->flags & TF_ACK_DELAY) {
    pcb->flags |= TF_ACK_NOW;
  111686:	8b 45 0c             	mov    0xc(%ebp),%eax
  111689:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  11168d:	89 c2                	mov    %eax,%edx
  11168f:	83 ca 02             	or     $0x2,%edx
  111692:	8b 45 0c             	mov    0xc(%ebp),%eax
  111695:	88 50 20             	mov    %dl,0x20(%eax)
    tcp_output(pcb);
  111698:	8b 45 0c             	mov    0xc(%ebp),%eax
  11169b:	89 04 24             	mov    %eax,(%esp)
  11169e:	e8 9d 07 00 00       	call   111e40 <tcp_output>
  }  
  pcb->state = CLOSED;
  1116a3:	8b 45 0c             	mov    0xc(%ebp),%eax
  1116a6:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)

  LWIP_ASSERT("tcp_pcb_remove: tcp_pcbs_sane()", tcp_pcbs_sane());
}
  1116ad:	c9                   	leave  
  1116ae:	c3                   	ret    
  1116af:	90                   	nop    

001116b0 <tcp_next_iss>:

/*
 * tcp_next_iss():
 *
 * Calculates a new initial sequence number for new connections.
 *
 */

u32_t
tcp_next_iss(void)
{
  1116b0:	55                   	push   %ebp
  1116b1:	89 e5                	mov    %esp,%ebp
  static u32_t iss = 6510;
  
  iss += tcp_ticks;       /* XXX */
  1116b3:	8b 15 a4 cb 11 00    	mov    0x11cba4,%edx
  1116b9:	a1 58 16 14 00       	mov    0x141658,%eax
  1116be:	8d 04 02             	lea    (%edx,%eax,1),%eax
  1116c1:	a3 a4 cb 11 00       	mov    %eax,0x11cba4
  return iss;
  1116c6:	a1 a4 cb 11 00       	mov    0x11cba4,%eax
}
  1116cb:	5d                   	pop    %ebp
  1116cc:	c3                   	ret    
  1116cd:	90                   	nop    
  1116ce:	90                   	nop    
  1116cf:	90                   	nop    

001116d0 <tcp_send_ctrl>:
static void tcp_output_segment(struct tcp_seg *seg, struct tcp_pcb *pcb);

err_t
tcp_send_ctrl(struct tcp_pcb *pcb, u8_t flags)
{
  1116d0:	55                   	push   %ebp
  1116d1:	89 e5                	mov    %esp,%ebp
  1116d3:	83 ec 28             	sub    $0x28,%esp
  1116d6:	8b 45 0c             	mov    0xc(%ebp),%eax
  1116d9:	88 45 fc             	mov    %al,0xfffffffc(%ebp)
  return tcp_enqueue(pcb, NULL, 0, flags, 1, NULL, 0);
  1116dc:	0f b6 45 fc          	movzbl 0xfffffffc(%ebp),%eax
  1116e0:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
  1116e7:	00 
  1116e8:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
  1116ef:	00 
  1116f0:	c7 44 24 10 01 00 00 	movl   $0x1,0x10(%esp)
  1116f7:	00 
  1116f8:	89 44 24 0c          	mov    %eax,0xc(%esp)
  1116fc:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  111703:	00 
  111704:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  11170b:	00 
  11170c:	8b 45 08             	mov    0x8(%ebp),%eax
  11170f:	89 04 24             	mov    %eax,(%esp)
  111712:	e8 a9 00 00 00       	call   1117c0 <tcp_enqueue>
  111717:	0f be c0             	movsbl %al,%eax

}
  11171a:	c9                   	leave  
  11171b:	c3                   	ret    
  11171c:	8d 74 26 00          	lea    0x0(%esi),%esi

00111720 <tcp_write>:

/*
 * NB. tcp_write() enqueues data for sending, but does not send it
 * straight away.  It waits in the expectation of more data being sent
 * soon (as it can send them more efficiently by combining them
 * together).  To prompt the system to send data now, call
 * tcp_output() after calling tcp_write().
 */

err_t
tcp_write(struct tcp_pcb *pcb, const void *arg, u16_t len, u8_t copy)
{
  111720:	55                   	push   %ebp
  111721:	89 e5                	mov    %esp,%ebp
  111723:	83 ec 28             	sub    $0x28,%esp
  111726:	8b 45 10             	mov    0x10(%ebp),%eax
  111729:	8b 55 14             	mov    0x14(%ebp),%edx
  11172c:	66 89 45 fc          	mov    %ax,0xfffffffc(%ebp)
  111730:	88 55 f8             	mov    %dl,0xfffffff8(%ebp)
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, arg=%p, len=%u, copy=%d)\n", (void *)pcb,
    arg, len, (unsigned int)copy));
  if (pcb->state == SYN_SENT ||
  111733:	8b 45 08             	mov    0x8(%ebp),%eax
  111736:	8b 40 10             	mov    0x10(%eax),%eax
  111739:	83 f8 02             	cmp    $0x2,%eax
  11173c:	74 21                	je     11175f <tcp_write+0x3f>
  11173e:	8b 45 08             	mov    0x8(%ebp),%eax
  111741:	8b 40 10             	mov    0x10(%eax),%eax
  111744:	83 f8 03             	cmp    $0x3,%eax
  111747:	74 16                	je     11175f <tcp_write+0x3f>
  111749:	8b 45 08             	mov    0x8(%ebp),%eax
  11174c:	8b 40 10             	mov    0x10(%eax),%eax
  11174f:	83 f8 04             	cmp    $0x4,%eax
  111752:	74 0b                	je     11175f <tcp_write+0x3f>
  111754:	8b 45 08             	mov    0x8(%ebp),%eax
  111757:	8b 40 10             	mov    0x10(%eax),%eax
  11175a:	83 f8 07             	cmp    $0x7,%eax
  11175d:	75 52                	jne    1117b1 <tcp_write+0x91>
     pcb->state == SYN_RCVD ||
     pcb->state == ESTABLISHED ||
     pcb->state == CLOSE_WAIT) {
    if (len > 0) {
  11175f:	66 83 7d fc 00       	cmpw   $0x0,0xfffffffc(%ebp)
  111764:	74 42                	je     1117a8 <tcp_write+0x88>
      return tcp_enqueue(pcb, (void *)arg, len, 0, copy, NULL, 0);
  111766:	0f b6 45 f8          	movzbl 0xfffffff8(%ebp),%eax
  11176a:	0f b7 55 fc          	movzwl 0xfffffffc(%ebp),%edx
  11176e:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
  111775:	00 
  111776:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
  11177d:	00 
  11177e:	89 44 24 10          	mov    %eax,0x10(%esp)
  111782:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  111789:	00 
  11178a:	89 54 24 08          	mov    %edx,0x8(%esp)
  11178e:	8b 45 0c             	mov    0xc(%ebp),%eax
  111791:	89 44 24 04          	mov    %eax,0x4(%esp)
  111795:	8b 45 08             	mov    0x8(%ebp),%eax
  111798:	89 04 24             	mov    %eax,(%esp)
  11179b:	e8 20 00 00 00       	call   1117c0 <tcp_enqueue>
  1117a0:	0f be c0             	movsbl %al,%eax
  1117a3:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  1117a6:	eb 10                	jmp    1117b8 <tcp_write+0x98>
    }
    return ERR_OK;
  1117a8:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
  1117af:	eb 07                	jmp    1117b8 <tcp_write+0x98>
  } else {
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | DBG_STATE | 3, ("tcp_write() called in invalid state\n"));
    return ERR_CONN;
  1117b1:	c7 45 f4 fa ff ff ff 	movl   $0xfffffffa,0xfffffff4(%ebp)
  1117b8:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  }
}
  1117bb:	c9                   	leave  
  1117bc:	c3                   	ret    
  1117bd:	8d 76 00             	lea    0x0(%esi),%esi

001117c0 <tcp_enqueue>:

err_t
tcp_enqueue(struct tcp_pcb *pcb, void *arg, u16_t len,
      u8_t flags, u8_t copy,
            u8_t *optdata, u8_t optlen)
{
  1117c0:	55                   	push   %ebp
  1117c1:	89 e5                	mov    %esp,%ebp
  1117c3:	56                   	push   %esi
  1117c4:	53                   	push   %ebx
  1117c5:	83 ec 60             	sub    $0x60,%esp
  1117c8:	8b 45 10             	mov    0x10(%ebp),%eax
  1117cb:	8b 55 14             	mov    0x14(%ebp),%edx
  1117ce:	8b 4d 18             	mov    0x18(%ebp),%ecx
  1117d1:	8b 5d 20             	mov    0x20(%ebp),%ebx
  1117d4:	66 89 45 c4          	mov    %ax,0xffffffc4(%ebp)
  1117d8:	88 55 c0             	mov    %dl,0xffffffc0(%ebp)
  1117db:	88 4d bc             	mov    %cl,0xffffffbc(%ebp)
  1117de:	88 5d b8             	mov    %bl,0xffffffb8(%ebp)
  struct pbuf *p;
  struct tcp_seg *seg, *useg, *queue;
  u32_t left, seqno;
  u16_t seglen;
  void *ptr;
  u8_t queuelen;

  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_enqueue(pcb=%p, arg=%p, len=%u, flags=%x, copy=%u)\n",
    (void *)pcb, arg, len, (unsigned int)flags, (unsigned int)copy));
  left = len;
  1117e1:	0f b7 45 c4          	movzwl 0xffffffc4(%ebp),%eax
  1117e5:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
  ptr = arg;
  1117e8:	8b 45 0c             	mov    0xc(%ebp),%eax
  1117eb:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
  /* fail on too much data */
  if (len > pcb->snd_buf) {
  1117ee:	8b 45 08             	mov    0x8(%ebp),%eax
  1117f1:	0f b7 40 6a          	movzwl 0x6a(%eax),%eax
  1117f5:	66 3b 45 c4          	cmp    0xffffffc4(%ebp),%ax
  1117f9:	73 0c                	jae    111807 <tcp_enqueue+0x47>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue: too much data (len=%u > snd_buf=%u)\n", len, pcb->snd_buf));
    return ERR_MEM;
  1117fb:	c7 45 a8 ff ff ff ff 	movl   $0xffffffff,0xffffffa8(%ebp)
  111802:	e9 28 06 00 00       	jmp    111e2f <tcp_enqueue+0x66f>
  }

  /* seqno will be the sequence number of the first segment enqueued
   * by the call to this function. */
  seqno = pcb->snd_lbb;
  111807:	8b 45 08             	mov    0x8(%ebp),%eax
  11180a:	8b 40 64             	mov    0x64(%eax),%eax
  11180d:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)

  queue = NULL;
  111810:	c7 45 e0 00 00 00 00 	movl   $0x0,0xffffffe0(%ebp)
  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue: queuelen: %u\n", (unsigned int)pcb->snd_queuelen));

  /* Check if the queue length exceeds the configured maximum queue
   * length. If so, we return an error. */
  queuelen = pcb->snd_queuelen;
  111817:	8b 45 08             	mov    0x8(%ebp),%eax
  11181a:	0f b6 40 6c          	movzbl 0x6c(%eax),%eax
  11181e:	88 45 f7             	mov    %al,0xfffffff7(%ebp)
  if (queuelen >= TCP_SND_QUEUELEN) {
  111821:	80 7d f7 3f          	cmpb   $0x3f,0xfffffff7(%ebp)
  111825:	76 05                	jbe    11182c <tcp_enqueue+0x6c>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue: too long queue %u (max %u)\n", queuelen, TCP_SND_QUEUELEN));
    goto memerr;
  111827:	e9 d0 05 00 00       	jmp    111dfc <tcp_enqueue+0x63c>
  }

  if (pcb->snd_queuelen != 0) {
  11182c:	8b 45 08             	mov    0x8(%ebp),%eax
  11182f:	0f b6 40 6c          	movzbl 0x6c(%eax),%eax
  111833:	84 c0                	test   %al,%al
  111835:	74 00                	je     111837 <tcp_enqueue+0x77>
    LWIP_ASSERT("tcp_enqueue: valid queue length", pcb->unacked != NULL ||
    pcb->unsent != NULL);
  }

  seg = useg = NULL;
  111837:	c7 45 dc 00 00 00 00 	movl   $0x0,0xffffffdc(%ebp)
  11183e:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  111841:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
  seglen = 0;
  111844:	66 c7 45 ee 00 00    	movw   $0x0,0xffffffee(%ebp)

  /* First, break up the data into segments and tuck them together in
   * the local "queue" variable. */
  while (queue == NULL || left > 0) {
  11184a:	e9 72 03 00 00       	jmp    111bc1 <tcp_enqueue+0x401>

    /* The segment length should be the MSS if the data to be enqueued
     * is larger than the MSS. */
    seglen = left > pcb->mss? pcb->mss: left;
  11184f:	8b 45 08             	mov    0x8(%ebp),%eax
  111852:	0f b7 40 34          	movzwl 0x34(%eax),%eax
  111856:	0f b7 c0             	movzwl %ax,%eax
  111859:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
  11185c:	89 55 a4             	mov    %edx,0xffffffa4(%ebp)
  11185f:	89 45 ac             	mov    %eax,0xffffffac(%ebp)
  111862:	8b 45 a4             	mov    0xffffffa4(%ebp),%eax
  111865:	39 45 ac             	cmp    %eax,0xffffffac(%ebp)
  111868:	76 06                	jbe    111870 <tcp_enqueue+0xb0>
  11186a:	8b 55 a4             	mov    0xffffffa4(%ebp),%edx
  11186d:	89 55 ac             	mov    %edx,0xffffffac(%ebp)
  111870:	0f b7 45 ac          	movzwl 0xffffffac(%ebp),%eax
  111874:	66 89 45 ee          	mov    %ax,0xffffffee(%ebp)

    /* Allocate memory for tcp_seg, and fill in fields. */
    seg = memp_malloc(MEMP_TCP_SEG);
  111878:	c7 04 24 05 00 00 00 	movl   $0x5,(%esp)
  11187f:	e8 3c d1 ff ff       	call   10e9c0 <memp_malloc>
  111884:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
    if (seg == NULL) {
  111887:	83 7d d8 00          	cmpl   $0x0,0xffffffd8(%ebp)
  11188b:	75 05                	jne    111892 <tcp_enqueue+0xd2>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: could not allocate memory for tcp_seg\n"));
      goto memerr;
  11188d:	e9 6a 05 00 00       	jmp    111dfc <tcp_enqueue+0x63c>
    }
    seg->next = NULL;
  111892:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  111895:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    seg->p = NULL;
  11189b:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  11189e:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)

    if (queue == NULL) {
  1118a5:	83 7d e0 00          	cmpl   $0x0,0xffffffe0(%ebp)
  1118a9:	75 0e                	jne    1118b9 <tcp_enqueue+0xf9>
      useg = queue = seg;
  1118ab:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  1118ae:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
  1118b1:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  1118b4:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
  1118b7:	eb 0e                	jmp    1118c7 <tcp_enqueue+0x107>
    }
    else {
      /* Attach the segment to the end of the queued segments. */
      LWIP_ASSERT("useg != NULL", useg != NULL);
      useg->next = seg;
  1118b9:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  1118bc:	8b 55 d8             	mov    0xffffffd8(%ebp),%edx
  1118bf:	89 10                	mov    %edx,(%eax)
      useg = seg;
  1118c1:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  1118c4:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
    }

    /* If copy is set, memory should be allocated
     * and data copied into pbuf, otherwise data comes from
     * ROM or other static memory, and need not be copied. If
     * optdata is != NULL, we have options instead of data. */
    if (optdata != NULL) {
  1118c7:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  1118cb:	74 4a                	je     111917 <tcp_enqueue+0x157>
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
  1118cd:	0f b6 45 b8          	movzbl 0xffffffb8(%ebp),%eax
  1118d1:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  1118d8:	00 
  1118d9:	89 44 24 04          	mov    %eax,0x4(%esp)
  1118dd:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  1118e4:	e8 e7 d6 ff ff       	call   10efd0 <pbuf_alloc>
  1118e9:	89 c2                	mov    %eax,%edx
  1118eb:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  1118ee:	89 50 04             	mov    %edx,0x4(%eax)
  1118f1:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  1118f4:	8b 40 04             	mov    0x4(%eax),%eax
  1118f7:	85 c0                	test   %eax,%eax
  1118f9:	0f 84 fd 04 00 00    	je     111dfc <tcp_enqueue+0x63c>
        goto memerr;
      }
      ++queuelen;
  1118ff:	80 45 f7 01          	addb   $0x1,0xfffffff7(%ebp)
      seg->dataptr = seg->p->payload;
  111903:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  111906:	8b 40 04             	mov    0x4(%eax),%eax
  111909:	8b 50 04             	mov    0x4(%eax),%edx
  11190c:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  11190f:	89 50 08             	mov    %edx,0x8(%eax)
  111912:	e9 15 01 00 00       	jmp    111a2c <tcp_enqueue+0x26c>
    }
    else if (copy) {
  111917:	80 7d bc 00          	cmpb   $0x0,0xffffffbc(%ebp)
  11191b:	74 71                	je     11198e <tcp_enqueue+0x1ce>
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_RAM)) == NULL) {
  11191d:	0f b7 45 ee          	movzwl 0xffffffee(%ebp),%eax
  111921:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  111928:	00 
  111929:	89 44 24 04          	mov    %eax,0x4(%esp)
  11192d:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  111934:	e8 97 d6 ff ff       	call   10efd0 <pbuf_alloc>
  111939:	89 c2                	mov    %eax,%edx
  11193b:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  11193e:	89 50 04             	mov    %edx,0x4(%eax)
  111941:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  111944:	8b 40 04             	mov    0x4(%eax),%eax
  111947:	85 c0                	test   %eax,%eax
  111949:	75 05                	jne    111950 <tcp_enqueue+0x190>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue : could not allocate memory for pbuf copy size %u\n", seglen));
        goto memerr;
  11194b:	e9 ac 04 00 00       	jmp    111dfc <tcp_enqueue+0x63c>
      }
      ++queuelen;
  111950:	80 45 f7 01          	addb   $0x1,0xfffffff7(%ebp)
      if (arg != NULL) {
  111954:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  111958:	74 20                	je     11197a <tcp_enqueue+0x1ba>
        memcpy(seg->p->payload, ptr, seglen);
  11195a:	0f b7 55 ee          	movzwl 0xffffffee(%ebp),%edx
  11195e:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  111961:	8b 40 04             	mov    0x4(%eax),%eax
  111964:	8b 48 04             	mov    0x4(%eax),%ecx
  111967:	89 54 24 08          	mov    %edx,0x8(%esp)
  11196b:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  11196e:	89 44 24 04          	mov    %eax,0x4(%esp)
  111972:	89 0c 24             	mov    %ecx,(%esp)
  111975:	e8 46 45 ff ff       	call   105ec0 <memcpy>
      }
      seg->dataptr = seg->p->payload;
  11197a:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  11197d:	8b 40 04             	mov    0x4(%eax),%eax
  111980:	8b 50 04             	mov    0x4(%eax),%edx
  111983:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  111986:	89 50 08             	mov    %edx,0x8(%eax)
  111989:	e9 9e 00 00 00       	jmp    111a2c <tcp_enqueue+0x26c>
    }
    /* do not copy data */
    else {

      /* first, allocate a pbuf for holding the data.
       * since the referenced data is available at least until it is sent out on the
       * link (as it has to be ACKed by the remote party) we can safely use PBUF_ROM
       * instead of PBUF_REF here.
       */
      if ((p = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_ROM)) == NULL) {
  11198e:	0f b7 45 ee          	movzwl 0xffffffee(%ebp),%eax
  111992:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  111999:	00 
  11199a:	89 44 24 04          	mov    %eax,0x4(%esp)
  11199e:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  1119a5:	e8 26 d6 ff ff       	call   10efd0 <pbuf_alloc>
  1119aa:	89 45 d4             	mov    %eax,0xffffffd4(%ebp)
  1119ad:	83 7d d4 00          	cmpl   $0x0,0xffffffd4(%ebp)
  1119b1:	75 05                	jne    1119b8 <tcp_enqueue+0x1f8>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: could not allocate memory for zero-copy pbuf\n"));
        goto memerr;
  1119b3:	e9 44 04 00 00       	jmp    111dfc <tcp_enqueue+0x63c>
      }
      ++queuelen;
  1119b8:	80 45 f7 01          	addb   $0x1,0xfffffff7(%ebp)
      p->payload = ptr;
  1119bc:	8b 55 d4             	mov    0xffffffd4(%ebp),%edx
  1119bf:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  1119c2:	89 42 04             	mov    %eax,0x4(%edx)
      seg->dataptr = ptr;
  1119c5:	8b 55 d8             	mov    0xffffffd8(%ebp),%edx
  1119c8:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  1119cb:	89 42 08             	mov    %eax,0x8(%edx)

      /* Second, allocate a pbuf for the headers. */
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, 0, PBUF_RAM)) == NULL) {
  1119ce:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  1119d5:	00 
  1119d6:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  1119dd:	00 
  1119de:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  1119e5:	e8 e6 d5 ff ff       	call   10efd0 <pbuf_alloc>
  1119ea:	89 c2                	mov    %eax,%edx
  1119ec:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  1119ef:	89 50 04             	mov    %edx,0x4(%eax)
  1119f2:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  1119f5:	8b 40 04             	mov    0x4(%eax),%eax
  1119f8:	85 c0                	test   %eax,%eax
  1119fa:	75 10                	jne    111a0c <tcp_enqueue+0x24c>
        /* If allocation fails, we have to deallocate the data pbuf as
         * well. */
        pbuf_free(p);
  1119fc:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
  1119ff:	89 04 24             	mov    %eax,(%esp)
  111a02:	e8 a9 da ff ff       	call   10f4b0 <pbuf_free>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: could not allocate memory for header pbuf\n"));
        goto memerr;
  111a07:	e9 f0 03 00 00       	jmp    111dfc <tcp_enqueue+0x63c>
      }
      ++queuelen;
  111a0c:	80 45 f7 01          	addb   $0x1,0xfffffff7(%ebp)

      /* Concatenate the headers and data pbufs together. */
      pbuf_cat(seg->p, p);
  111a10:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  111a13:	8b 50 04             	mov    0x4(%eax),%edx
  111a16:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
  111a19:	89 44 24 04          	mov    %eax,0x4(%esp)
  111a1d:	89 14 24             	mov    %edx,(%esp)
  111a20:	e8 1b dc ff ff       	call   10f640 <pbuf_cat>
      p = NULL;
  111a25:	c7 45 d4 00 00 00 00 	movl   $0x0,0xffffffd4(%ebp)
    }

    /* Now that there are more segments queued, we check again if the
    length of the queue exceeds the configured maximum. */
    if (queuelen > TCP_SND_QUEUELEN) {
  111a2c:	80 7d f7 40          	cmpb   $0x40,0xfffffff7(%ebp)
  111a30:	76 05                	jbe    111a37 <tcp_enqueue+0x277>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: queue too long %u (%u)\n", queuelen, TCP_SND_QUEUELEN));
      goto memerr;
  111a32:	e9 c5 03 00 00       	jmp    111dfc <tcp_enqueue+0x63c>
    }

    seg->len = seglen;
  111a37:	8b 55 d8             	mov    0xffffffd8(%ebp),%edx
  111a3a:	0f b7 45 ee          	movzwl 0xffffffee(%ebp),%eax
  111a3e:	66 89 42 0c          	mov    %ax,0xc(%edx)
#if 0 /* Was commented out. TODO: can someone say why this is here? */
    if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
      ++seg->len;
    }
#endif
    /* Build TCP header. */
    if (pbuf_header(seg->p, TCP_HLEN)) {
  111a42:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  111a45:	8b 40 04             	mov    0x4(%eax),%eax
  111a48:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  111a4f:	00 
  111a50:	89 04 24             	mov    %eax,(%esp)
  111a53:	e8 58 d9 ff ff       	call   10f3b0 <pbuf_header>
  111a58:	84 c0                	test   %al,%al
  111a5a:	74 15                	je     111a71 <tcp_enqueue+0x2b1>

      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: no room for TCP header in pbuf.\n"));

      TCP_STATS_INC(tcp.err);
  111a5c:	0f b7 05 78 15 14 00 	movzwl 0x141578,%eax
  111a63:	83 c0 01             	add    $0x1,%eax
  111a66:	66 a3 78 15 14 00    	mov    %ax,0x141578
      goto memerr;
  111a6c:	e9 8b 03 00 00       	jmp    111dfc <tcp_enqueue+0x63c>
    }
    seg->tcphdr = seg->p->payload;
  111a71:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  111a74:	8b 40 04             	mov    0x4(%eax),%eax
  111a77:	8b 40 04             	mov    0x4(%eax),%eax
  111a7a:	89 c2                	mov    %eax,%edx
  111a7c:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  111a7f:	89 50 10             	mov    %edx,0x10(%eax)
    seg->tcphdr->src = htons(pcb->local_port);
  111a82:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  111a85:	8b 58 10             	mov    0x10(%eax),%ebx
  111a88:	8b 45 08             	mov    0x8(%ebp),%eax
  111a8b:	0f b7 40 1c          	movzwl 0x1c(%eax),%eax
  111a8f:	0f b7 c0             	movzwl %ax,%eax
  111a92:	89 04 24             	mov    %eax,(%esp)
  111a95:	e8 d6 c7 ff ff       	call   10e270 <htons>
  111a9a:	66 89 03             	mov    %ax,(%ebx)
    seg->tcphdr->dest = htons(pcb->remote_port);
  111a9d:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  111aa0:	8b 58 10             	mov    0x10(%eax),%ebx
  111aa3:	8b 45 08             	mov    0x8(%ebp),%eax
  111aa6:	0f b7 40 1e          	movzwl 0x1e(%eax),%eax
  111aaa:	0f b7 c0             	movzwl %ax,%eax
  111aad:	89 04 24             	mov    %eax,(%esp)
  111ab0:	e8 bb c7 ff ff       	call   10e270 <htons>
  111ab5:	66 89 43 02          	mov    %ax,0x2(%ebx)
    seg->tcphdr->seqno = htonl(seqno);
  111ab9:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  111abc:	8b 58 10             	mov    0x10(%eax),%ebx
  111abf:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  111ac2:	89 04 24             	mov    %eax,(%esp)
  111ac5:	e8 f6 c7 ff ff       	call   10e2c0 <htonl>
  111aca:	89 43 04             	mov    %eax,0x4(%ebx)
    seg->tcphdr->urgp = 0;
  111acd:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  111ad0:	8b 40 10             	mov    0x10(%eax),%eax
  111ad3:	66 c7 40 12 00 00    	movw   $0x0,0x12(%eax)
    TCPH_FLAGS_SET(seg->tcphdr, flags);
  111ad9:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  111adc:	8b 58 10             	mov    0x10(%eax),%ebx
  111adf:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  111ae2:	8b 40 10             	mov    0x10(%eax),%eax
  111ae5:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  111ae9:	0f b7 c0             	movzwl %ax,%eax
  111aec:	89 04 24             	mov    %eax,(%esp)
  111aef:	e8 ac c7 ff ff       	call   10e2a0 <ntohs>
  111af4:	89 c2                	mov    %eax,%edx
  111af6:	83 e2 c0             	and    $0xffffffc0,%edx
  111af9:	0f b6 45 c0          	movzbl 0xffffffc0(%ebp),%eax
  111afd:	09 d0                	or     %edx,%eax
  111aff:	0f b7 c0             	movzwl %ax,%eax
  111b02:	89 04 24             	mov    %eax,(%esp)
  111b05:	e8 66 c7 ff ff       	call   10e270 <htons>
  111b0a:	66 89 43 0c          	mov    %ax,0xc(%ebx)
    /* don't fill in tcphdr->ackno and tcphdr->wnd until later */

    /* Copy the options into the header, if they are present. */
    if (optdata == NULL) {
  111b0e:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  111b12:	75 32                	jne    111b46 <tcp_enqueue+0x386>
      TCPH_HDRLEN_SET(seg->tcphdr, 5);
  111b14:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  111b17:	8b 58 10             	mov    0x10(%eax),%ebx
  111b1a:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  111b1d:	8b 40 10             	mov    0x10(%eax),%eax
  111b20:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  111b24:	0f b7 c0             	movzwl %ax,%eax
  111b27:	89 04 24             	mov    %eax,(%esp)
  111b2a:	e8 71 c7 ff ff       	call   10e2a0 <ntohs>
  111b2f:	83 e0 3f             	and    $0x3f,%eax
  111b32:	80 cc 50             	or     $0x50,%ah
  111b35:	0f b7 c0             	movzwl %ax,%eax
  111b38:	89 04 24             	mov    %eax,(%esp)
  111b3b:	e8 30 c7 ff ff       	call   10e270 <htons>
  111b40:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  111b44:	eb 5e                	jmp    111ba4 <tcp_enqueue+0x3e4>
    }
    else {
      TCPH_HDRLEN_SET(seg->tcphdr, (5 + optlen / 4));
  111b46:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  111b49:	8b 70 10             	mov    0x10(%eax),%esi
  111b4c:	0f b6 45 b8          	movzbl 0xffffffb8(%ebp),%eax
  111b50:	c0 e8 02             	shr    $0x2,%al
  111b53:	0f b6 c0             	movzbl %al,%eax
  111b56:	83 c0 05             	add    $0x5,%eax
  111b59:	89 c3                	mov    %eax,%ebx
  111b5b:	c1 e3 0c             	shl    $0xc,%ebx
  111b5e:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  111b61:	8b 40 10             	mov    0x10(%eax),%eax
  111b64:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  111b68:	0f b7 c0             	movzwl %ax,%eax
  111b6b:	89 04 24             	mov    %eax,(%esp)
  111b6e:	e8 2d c7 ff ff       	call   10e2a0 <ntohs>
  111b73:	83 e0 3f             	and    $0x3f,%eax
  111b76:	09 d8                	or     %ebx,%eax
  111b78:	0f b7 c0             	movzwl %ax,%eax
  111b7b:	89 04 24             	mov    %eax,(%esp)
  111b7e:	e8 ed c6 ff ff       	call   10e270 <htons>
  111b83:	66 89 46 0c          	mov    %ax,0xc(%esi)
      /* Copy options into data portion of segment.
       Options can thus only be sent in non data carrying
       segments such as SYN|ACK. */
      memcpy(seg->dataptr, optdata, optlen);
  111b87:	0f b6 55 b8          	movzbl 0xffffffb8(%ebp),%edx
  111b8b:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  111b8e:	8b 48 08             	mov    0x8(%eax),%ecx
  111b91:	89 54 24 08          	mov    %edx,0x8(%esp)
  111b95:	8b 45 1c             	mov    0x1c(%ebp),%eax
  111b98:	89 44 24 04          	mov    %eax,0x4(%esp)
  111b9c:	89 0c 24             	mov    %ecx,(%esp)
  111b9f:	e8 1c 43 ff ff       	call   105ec0 <memcpy>
    }
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | DBG_TRACE, ("tcp_enqueue: queueing %lu:%lu (0x%x)\n",
      ntohl(seg->tcphdr->seqno),
      ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg),
      flags));

    left -= seglen;
  111ba4:	0f b7 45 ee          	movzwl 0xffffffee(%ebp),%eax
  111ba8:	29 45 e4             	sub    %eax,0xffffffe4(%ebp)
    seqno += seglen;
  111bab:	0f b7 45 ee          	movzwl 0xffffffee(%ebp),%eax
  111baf:	01 45 e8             	add    %eax,0xffffffe8(%ebp)
    ptr = (void *)((char *)ptr + seglen);
  111bb2:	0f b7 45 ee          	movzwl 0xffffffee(%ebp),%eax
  111bb6:	89 c2                	mov    %eax,%edx
  111bb8:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  111bbb:	8d 04 02             	lea    (%edx,%eax,1),%eax
  111bbe:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
  111bc1:	83 7d e0 00          	cmpl   $0x0,0xffffffe0(%ebp)
  111bc5:	0f 84 84 fc ff ff    	je     11184f <tcp_enqueue+0x8f>
  111bcb:	83 7d e4 00          	cmpl   $0x0,0xffffffe4(%ebp)
  111bcf:	0f 85 7a fc ff ff    	jne    11184f <tcp_enqueue+0x8f>
  }


  /* Now that the data to be enqueued has been broken up into TCP
  segments in the queue variable, we add them to the end of the
  pcb->unsent queue. */
  if (pcb->unsent == NULL) {
  111bd5:	8b 45 08             	mov    0x8(%ebp),%eax
  111bd8:	8b 40 70             	mov    0x70(%eax),%eax
  111bdb:	85 c0                	test   %eax,%eax
  111bdd:	75 09                	jne    111be8 <tcp_enqueue+0x428>
    useg = NULL;
  111bdf:	c7 45 dc 00 00 00 00 	movl   $0x0,0xffffffdc(%ebp)
  111be6:	eb 1c                	jmp    111c04 <tcp_enqueue+0x444>
  }
  else {
    for (useg = pcb->unsent; useg->next != NULL; useg = useg->next);
  111be8:	8b 45 08             	mov    0x8(%ebp),%eax
  111beb:	8b 40 70             	mov    0x70(%eax),%eax
  111bee:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
  111bf1:	eb 08                	jmp    111bfb <tcp_enqueue+0x43b>
  111bf3:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  111bf6:	8b 00                	mov    (%eax),%eax
  111bf8:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
  111bfb:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  111bfe:	8b 00                	mov    (%eax),%eax
  111c00:	85 c0                	test   %eax,%eax
  111c02:	75 ef                	jne    111bf3 <tcp_enqueue+0x433>
  }

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
  111c04:	83 7d dc 00          	cmpl   $0x0,0xffffffdc(%ebp)
  111c08:	0f 84 32 01 00 00    	je     111d40 <tcp_enqueue+0x580>
  111c0e:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  111c11:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  111c15:	0f b7 c0             	movzwl %ax,%eax
  111c18:	89 45 b0             	mov    %eax,0xffffffb0(%ebp)
  111c1b:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  111c1e:	8b 40 10             	mov    0x10(%eax),%eax
  111c21:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  111c25:	0f b7 c0             	movzwl %ax,%eax
  111c28:	89 04 24             	mov    %eax,(%esp)
  111c2b:	e8 70 c6 ff ff       	call   10e2a0 <ntohs>
  111c30:	0f b7 c0             	movzwl %ax,%eax
  111c33:	83 e0 01             	and    $0x1,%eax
  111c36:	84 c0                	test   %al,%al
  111c38:	75 1f                	jne    111c59 <tcp_enqueue+0x499>
  111c3a:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  111c3d:	8b 40 10             	mov    0x10(%eax),%eax
  111c40:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  111c44:	0f b7 c0             	movzwl %ax,%eax
  111c47:	89 04 24             	mov    %eax,(%esp)
  111c4a:	e8 51 c6 ff ff       	call   10e2a0 <ntohs>
  111c4f:	0f b7 c0             	movzwl %ax,%eax
  111c52:	83 e0 02             	and    $0x2,%eax
  111c55:	85 c0                	test   %eax,%eax
  111c57:	74 09                	je     111c62 <tcp_enqueue+0x4a2>
  111c59:	c7 45 b4 01 00 00 00 	movl   $0x1,0xffffffb4(%ebp)
  111c60:	eb 07                	jmp    111c69 <tcp_enqueue+0x4a9>
  111c62:	c7 45 b4 00 00 00 00 	movl   $0x0,0xffffffb4(%ebp)
  111c69:	8b 45 b0             	mov    0xffffffb0(%ebp),%eax
  111c6c:	03 45 b4             	add    0xffffffb4(%ebp),%eax
  111c6f:	85 c0                	test   %eax,%eax
  111c71:	0f 84 c9 00 00 00    	je     111d40 <tcp_enqueue+0x580>
  111c77:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  111c7a:	8b 40 10             	mov    0x10(%eax),%eax
  111c7d:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  111c81:	0f b7 c0             	movzwl %ax,%eax
  111c84:	89 04 24             	mov    %eax,(%esp)
  111c87:	e8 14 c6 ff ff       	call   10e2a0 <ntohs>
  111c8c:	0f b7 c0             	movzwl %ax,%eax
  111c8f:	83 e0 03             	and    $0x3,%eax
  111c92:	85 c0                	test   %eax,%eax
  111c94:	0f 85 a6 00 00 00    	jne    111d40 <tcp_enqueue+0x580>
  111c9a:	0f b6 45 c0          	movzbl 0xffffffc0(%ebp),%eax
  111c9e:	83 e0 03             	and    $0x3,%eax
  111ca1:	85 c0                	test   %eax,%eax
  111ca3:	0f 85 97 00 00 00    	jne    111d40 <tcp_enqueue+0x580>
  111ca9:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  111cac:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  111cb0:	0f b7 d0             	movzwl %ax,%edx
  111cb3:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  111cb6:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  111cba:	0f b7 c0             	movzwl %ax,%eax
  111cbd:	01 c2                	add    %eax,%edx
  111cbf:	8b 45 08             	mov    0x8(%ebp),%eax
  111cc2:	0f b7 40 34          	movzwl 0x34(%eax),%eax
  111cc6:	0f b7 c0             	movzwl %ax,%eax
  111cc9:	39 c2                	cmp    %eax,%edx
  111ccb:	7f 73                	jg     111d40 <tcp_enqueue+0x580>
    TCP_TCPLEN(useg) != 0 &&
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
    !(flags & (TCP_SYN | TCP_FIN)) &&
    useg->len + queue->len <= pcb->mss) {
    /* Remove TCP header from first segment. */
    pbuf_header(queue->p, -TCP_HLEN);
  111ccd:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  111cd0:	8b 40 04             	mov    0x4(%eax),%eax
  111cd3:	c7 44 24 04 ec ff ff 	movl   $0xffffffec,0x4(%esp)
  111cda:	ff 
  111cdb:	89 04 24             	mov    %eax,(%esp)
  111cde:	e8 cd d6 ff ff       	call   10f3b0 <pbuf_header>
    pbuf_cat(useg->p, queue->p);
  111ce3:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  111ce6:	8b 50 04             	mov    0x4(%eax),%edx
  111ce9:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  111cec:	8b 40 04             	mov    0x4(%eax),%eax
  111cef:	89 54 24 04          	mov    %edx,0x4(%esp)
  111cf3:	89 04 24             	mov    %eax,(%esp)
  111cf6:	e8 45 d9 ff ff       	call   10f640 <pbuf_cat>
    useg->len += queue->len;
  111cfb:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  111cfe:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
  111d02:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  111d05:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  111d09:	01 c2                	add    %eax,%edx
  111d0b:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  111d0e:	66 89 50 0c          	mov    %dx,0xc(%eax)
    useg->next = queue->next;
  111d12:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  111d15:	8b 10                	mov    (%eax),%edx
  111d17:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  111d1a:	89 10                	mov    %edx,(%eax)

    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | DBG_TRACE | DBG_STATE, ("tcp_enqueue: chaining, new len %u\n", useg->len));
    if (seg == queue) {
  111d1c:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  111d1f:	3b 45 e0             	cmp    0xffffffe0(%ebp),%eax
  111d22:	75 07                	jne    111d2b <tcp_enqueue+0x56b>
      seg = NULL;
  111d24:	c7 45 d8 00 00 00 00 	movl   $0x0,0xffffffd8(%ebp)
    }
    memp_free(MEMP_TCP_SEG, queue);
  111d2b:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  111d2e:	89 44 24 04          	mov    %eax,0x4(%esp)
  111d32:	c7 04 24 05 00 00 00 	movl   $0x5,(%esp)
  111d39:	e8 72 cd ff ff       	call   10eab0 <memp_free>
  111d3e:	eb 19                	jmp    111d59 <tcp_enqueue+0x599>
  }
  else {
    if (useg == NULL) {
  111d40:	83 7d dc 00          	cmpl   $0x0,0xffffffdc(%ebp)
  111d44:	75 0b                	jne    111d51 <tcp_enqueue+0x591>
      pcb->unsent = queue;
  111d46:	8b 55 08             	mov    0x8(%ebp),%edx
  111d49:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  111d4c:	89 42 70             	mov    %eax,0x70(%edx)
  111d4f:	eb 08                	jmp    111d59 <tcp_enqueue+0x599>

    }
    else {
      useg->next = queue;
  111d51:	8b 55 dc             	mov    0xffffffdc(%ebp),%edx
  111d54:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  111d57:	89 02                	mov    %eax,(%edx)
    }
  }
  if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
  111d59:	0f b6 45 c0          	movzbl 0xffffffc0(%ebp),%eax
  111d5d:	83 e0 02             	and    $0x2,%eax
  111d60:	85 c0                	test   %eax,%eax
  111d62:	75 0b                	jne    111d6f <tcp_enqueue+0x5af>
  111d64:	0f b6 45 c0          	movzbl 0xffffffc0(%ebp),%eax
  111d68:	83 e0 01             	and    $0x1,%eax
  111d6b:	84 c0                	test   %al,%al
  111d6d:	74 05                	je     111d74 <tcp_enqueue+0x5b4>
    ++len;
  111d6f:	66 83 45 c4 01       	addw   $0x1,0xffffffc4(%ebp)
  }
  pcb->snd_lbb += len;
  111d74:	8b 45 08             	mov    0x8(%ebp),%eax
  111d77:	8b 50 64             	mov    0x64(%eax),%edx
  111d7a:	0f b7 45 c4          	movzwl 0xffffffc4(%ebp),%eax
  111d7e:	01 c2                	add    %eax,%edx
  111d80:	8b 45 08             	mov    0x8(%ebp),%eax
  111d83:	89 50 64             	mov    %edx,0x64(%eax)
  pcb->snd_buf -= len;
  111d86:	8b 45 08             	mov    0x8(%ebp),%eax
  111d89:	0f b7 40 6a          	movzwl 0x6a(%eax),%eax
  111d8d:	89 c2                	mov    %eax,%edx
  111d8f:	66 2b 55 c4          	sub    0xffffffc4(%ebp),%dx
  111d93:	8b 45 08             	mov    0x8(%ebp),%eax
  111d96:	66 89 50 6a          	mov    %dx,0x6a(%eax)
  pcb->snd_queuelen = queuelen;
  111d9a:	8b 55 08             	mov    0x8(%ebp),%edx
  111d9d:	0f b6 45 f7          	movzbl 0xfffffff7(%ebp),%eax
  111da1:	88 42 6c             	mov    %al,0x6c(%edx)
  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue: %d (after enqueued)\n", pcb->snd_queuelen));
  if (pcb->snd_queuelen != 0) {
  111da4:	8b 45 08             	mov    0x8(%ebp),%eax
  111da7:	0f b6 40 6c          	movzbl 0x6c(%eax),%eax
  111dab:	84 c0                	test   %al,%al
  111dad:	74 00                	je     111daf <tcp_enqueue+0x5ef>
    LWIP_ASSERT("tcp_enqueue: valid queue length", pcb->unacked != NULL ||
      pcb->unsent != NULL);

  }

  /* Set the PSH flag in the last segment that we enqueued, but only
  if the segment has data (indicated by seglen > 0). */
  if (seg != NULL && seglen > 0 && seg->tcphdr != NULL) {
  111daf:	83 7d d8 00          	cmpl   $0x0,0xffffffd8(%ebp)
  111db3:	74 3e                	je     111df3 <tcp_enqueue+0x633>
  111db5:	66 83 7d ee 00       	cmpw   $0x0,0xffffffee(%ebp)
  111dba:	74 37                	je     111df3 <tcp_enqueue+0x633>
  111dbc:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  111dbf:	8b 40 10             	mov    0x10(%eax),%eax
  111dc2:	85 c0                	test   %eax,%eax
  111dc4:	74 2d                	je     111df3 <tcp_enqueue+0x633>
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
  111dc6:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  111dc9:	8b 58 10             	mov    0x10(%eax),%ebx
  111dcc:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  111dcf:	8b 40 10             	mov    0x10(%eax),%eax
  111dd2:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  111dd6:	0f b7 c0             	movzwl %ax,%eax
  111dd9:	89 04 24             	mov    %eax,(%esp)
  111ddc:	e8 bf c4 ff ff       	call   10e2a0 <ntohs>
  111de1:	83 c8 08             	or     $0x8,%eax
  111de4:	0f b7 c0             	movzwl %ax,%eax
  111de7:	89 04 24             	mov    %eax,(%esp)
  111dea:	e8 81 c4 ff ff       	call   10e270 <htons>
  111def:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  }

  return ERR_OK;
  111df3:	c7 45 a8 00 00 00 00 	movl   $0x0,0xffffffa8(%ebp)
  111dfa:	eb 33                	jmp    111e2f <tcp_enqueue+0x66f>
  memerr:
  TCP_STATS_INC(tcp.memerr);
  111dfc:	0f b7 05 70 15 14 00 	movzwl 0x141570,%eax
  111e03:	83 c0 01             	add    $0x1,%eax
  111e06:	66 a3 70 15 14 00    	mov    %ax,0x141570

  if (queue != NULL) {
  111e0c:	83 7d e0 00          	cmpl   $0x0,0xffffffe0(%ebp)
  111e10:	74 0b                	je     111e1d <tcp_enqueue+0x65d>
    tcp_segs_free(queue);
  111e12:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  111e15:	89 04 24             	mov    %eax,(%esp)
  111e18:	e8 b3 f2 ff ff       	call   1110d0 <tcp_segs_free>
  }
  if (pcb->snd_queuelen != 0) {
  111e1d:	8b 45 08             	mov    0x8(%ebp),%eax
  111e20:	0f b6 40 6c          	movzbl 0x6c(%eax),%eax
  111e24:	84 c0                	test   %al,%al
  111e26:	74 00                	je     111e28 <tcp_enqueue+0x668>
    LWIP_ASSERT("tcp_enqueue: valid queue length", pcb->unacked != NULL ||
      pcb->unsent != NULL);

  }
  LWIP_DEBUGF(TCP_QLEN_DEBUG | DBG_STATE, ("tcp_enqueue: %d (with mem err)\n", pcb->snd_queuelen));
  return ERR_MEM;
  111e28:	c7 45 a8 ff ff ff ff 	movl   $0xffffffff,0xffffffa8(%ebp)
  111e2f:	8b 45 a8             	mov    0xffffffa8(%ebp),%eax
}
  111e32:	83 c4 60             	add    $0x60,%esp
  111e35:	5b                   	pop    %ebx
  111e36:	5e                   	pop    %esi
  111e37:	5d                   	pop    %ebp
  111e38:	c3                   	ret    
  111e39:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

00111e40 <tcp_output>:

/* find out what we can send and send it */
err_t
tcp_output(struct tcp_pcb *pcb)
{
  111e40:	55                   	push   %ebp
  111e41:	89 e5                	mov    %esp,%ebp
  111e43:	53                   	push   %ebx
  111e44:	83 ec 64             	sub    $0x64,%esp
  struct pbuf *p;
  struct tcp_hdr *tcphdr;
  struct tcp_seg *seg, *useg;
  u32_t wnd;
#if TCP_CWND_DEBUG
  int i = 0;
#endif /* TCP_CWND_DEBUG */

  /* First, check if we are invoked by the TCP input processing
     code. If so, we do not output anything. Instead, we rely on the
     input processing code to call us when input processing is done
     with. */
  if (tcp_input_pcb == pcb) {
  111e47:	a1 68 16 14 00       	mov    0x141668,%eax
  111e4c:	3b 45 08             	cmp    0x8(%ebp),%eax
  111e4f:	75 0c                	jne    111e5d <tcp_output+0x1d>
    return ERR_OK;
  111e51:	c7 45 c0 00 00 00 00 	movl   $0x0,0xffffffc0(%ebp)
  111e58:	e9 5f 04 00 00       	jmp    1122bc <tcp_output+0x47c>
  }

  wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);
  111e5d:	8b 45 08             	mov    0x8(%ebp),%eax
  111e60:	0f b7 40 4a          	movzwl 0x4a(%eax),%eax
  111e64:	0f b7 d0             	movzwl %ax,%edx
  111e67:	8b 45 08             	mov    0x8(%ebp),%eax
  111e6a:	8b 40 58             	mov    0x58(%eax),%eax
  111e6d:	89 45 c4             	mov    %eax,0xffffffc4(%ebp)
  111e70:	89 55 bc             	mov    %edx,0xffffffbc(%ebp)
  111e73:	8b 45 c4             	mov    0xffffffc4(%ebp),%eax
  111e76:	39 45 bc             	cmp    %eax,0xffffffbc(%ebp)
  111e79:	76 06                	jbe    111e81 <tcp_output+0x41>
  111e7b:	8b 4d c4             	mov    0xffffffc4(%ebp),%ecx
  111e7e:	89 4d bc             	mov    %ecx,0xffffffbc(%ebp)
  111e81:	8b 45 bc             	mov    0xffffffbc(%ebp),%eax
  111e84:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)


  seg = pcb->unsent;
  111e87:	8b 45 08             	mov    0x8(%ebp),%eax
  111e8a:	8b 40 70             	mov    0x70(%eax),%eax
  111e8d:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)

  /* useg should point to last segment on unacked queue */
  useg = pcb->unacked;
  111e90:	8b 45 08             	mov    0x8(%ebp),%eax
  111e93:	8b 40 74             	mov    0x74(%eax),%eax
  111e96:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  if (useg != NULL) {
  111e99:	83 7d f4 00          	cmpl   $0x0,0xfffffff4(%ebp)
  111e9d:	74 13                	je     111eb2 <tcp_output+0x72>
    for (; useg->next != NULL; useg = useg->next);
  111e9f:	eb 08                	jmp    111ea9 <tcp_output+0x69>
  111ea1:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  111ea4:	8b 00                	mov    (%eax),%eax
  111ea6:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  111ea9:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  111eac:	8b 00                	mov    (%eax),%eax
  111eae:	85 c0                	test   %eax,%eax
  111eb0:	75 ef                	jne    111ea1 <tcp_output+0x61>
  }                                                                             

   
  /* If the TF_ACK_NOW flag is set, we check if there is data that is
     to be sent. If data is to be sent out, we'll just piggyback our
     acknowledgement with the outgoing segment. If no data will be
     sent (either because the ->unsent queue is empty or because the
     window doesn't allow it) we'll have to construct an empty ACK
     segment and send it. */
  if (pcb->flags & TF_ACK_NOW &&
  111eb2:	8b 45 08             	mov    0x8(%ebp),%eax
  111eb5:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  111eb9:	0f b6 c0             	movzbl %al,%eax
  111ebc:	83 e0 02             	and    $0x2,%eax
  111ebf:	85 c0                	test   %eax,%eax
  111ec1:	0f 84 b7 03 00 00    	je     11227e <tcp_output+0x43e>
  111ec7:	83 7d f0 00          	cmpl   $0x0,0xfffffff0(%ebp)
  111ecb:	74 31                	je     111efe <tcp_output+0xbe>
  111ecd:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  111ed0:	8b 40 10             	mov    0x10(%eax),%eax
  111ed3:	8b 40 04             	mov    0x4(%eax),%eax
  111ed6:	89 04 24             	mov    %eax,(%esp)
  111ed9:	e8 22 c4 ff ff       	call   10e300 <ntohl>
  111ede:	89 c2                	mov    %eax,%edx
  111ee0:	8b 45 08             	mov    0x8(%ebp),%eax
  111ee3:	8b 40 44             	mov    0x44(%eax),%eax
  111ee6:	29 c2                	sub    %eax,%edx
  111ee8:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  111eeb:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  111eef:	0f b7 c0             	movzwl %ax,%eax
  111ef2:	8d 04 02             	lea    (%edx,%eax,1),%eax
  111ef5:	3b 45 f8             	cmp    0xfffffff8(%ebp),%eax
  111ef8:	0f 86 80 03 00 00    	jbe    11227e <tcp_output+0x43e>
     (seg == NULL ||
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
    pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  111efe:	8b 45 08             	mov    0x8(%ebp),%eax
  111f01:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  111f05:	89 c2                	mov    %eax,%edx
  111f07:	83 e2 fc             	and    $0xfffffffc,%edx
  111f0a:	8b 45 08             	mov    0x8(%ebp),%eax
  111f0d:	88 50 20             	mov    %dl,0x20(%eax)
    p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  111f10:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  111f17:	00 
  111f18:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  111f1f:	00 
  111f20:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  111f27:	e8 a4 d0 ff ff       	call   10efd0 <pbuf_alloc>
  111f2c:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
    if (p == NULL) {
  111f2f:	83 7d e8 00          	cmpl   $0x0,0xffffffe8(%ebp)
  111f33:	75 0c                	jne    111f41 <tcp_output+0x101>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: (ACK) could not allocate pbuf\n"));
      return ERR_BUF;
  111f35:	c7 45 c0 fe ff ff ff 	movl   $0xfffffffe,0xffffffc0(%ebp)
  111f3c:	e9 7b 03 00 00       	jmp    1122bc <tcp_output+0x47c>
    }
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: sending ACK for %lu\n", pcb->rcv_nxt));

    tcphdr = p->payload;
  111f41:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  111f44:	8b 40 04             	mov    0x4(%eax),%eax
  111f47:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
    tcphdr->src = htons(pcb->local_port);
  111f4a:	8b 45 08             	mov    0x8(%ebp),%eax
  111f4d:	0f b7 40 1c          	movzwl 0x1c(%eax),%eax
  111f51:	0f b7 c0             	movzwl %ax,%eax
  111f54:	89 04 24             	mov    %eax,(%esp)
  111f57:	e8 14 c3 ff ff       	call   10e270 <htons>
  111f5c:	89 c2                	mov    %eax,%edx
  111f5e:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  111f61:	66 89 10             	mov    %dx,(%eax)
    tcphdr->dest = htons(pcb->remote_port);
  111f64:	8b 45 08             	mov    0x8(%ebp),%eax
  111f67:	0f b7 40 1e          	movzwl 0x1e(%eax),%eax
  111f6b:	0f b7 c0             	movzwl %ax,%eax
  111f6e:	89 04 24             	mov    %eax,(%esp)
  111f71:	e8 fa c2 ff ff       	call   10e270 <htons>
  111f76:	89 c2                	mov    %eax,%edx
  111f78:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  111f7b:	66 89 50 02          	mov    %dx,0x2(%eax)
    tcphdr->seqno = htonl(pcb->snd_nxt);
  111f7f:	8b 45 08             	mov    0x8(%ebp),%eax
  111f82:	8b 40 50             	mov    0x50(%eax),%eax
  111f85:	89 04 24             	mov    %eax,(%esp)
  111f88:	e8 33 c3 ff ff       	call   10e2c0 <htonl>
  111f8d:	89 c2                	mov    %eax,%edx
  111f8f:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  111f92:	89 50 04             	mov    %edx,0x4(%eax)
    tcphdr->ackno = htonl(pcb->rcv_nxt);
  111f95:	8b 45 08             	mov    0x8(%ebp),%eax
  111f98:	8b 40 24             	mov    0x24(%eax),%eax
  111f9b:	89 04 24             	mov    %eax,(%esp)
  111f9e:	e8 1d c3 ff ff       	call   10e2c0 <htonl>
  111fa3:	89 c2                	mov    %eax,%edx
  111fa5:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  111fa8:	89 50 08             	mov    %edx,0x8(%eax)
    TCPH_FLAGS_SET(tcphdr, TCP_ACK);
  111fab:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  111fae:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  111fb2:	0f b7 c0             	movzwl %ax,%eax
  111fb5:	89 04 24             	mov    %eax,(%esp)
  111fb8:	e8 e3 c2 ff ff       	call   10e2a0 <ntohs>
  111fbd:	83 e0 c0             	and    $0xffffffc0,%eax
  111fc0:	83 c8 10             	or     $0x10,%eax
  111fc3:	0f b7 c0             	movzwl %ax,%eax
  111fc6:	89 04 24             	mov    %eax,(%esp)
  111fc9:	e8 a2 c2 ff ff       	call   10e270 <htons>
  111fce:	89 c2                	mov    %eax,%edx
  111fd0:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  111fd3:	66 89 50 0c          	mov    %dx,0xc(%eax)
    tcphdr->wnd = htons(pcb->rcv_wnd);
  111fd7:	8b 45 08             	mov    0x8(%ebp),%eax
  111fda:	0f b7 40 28          	movzwl 0x28(%eax),%eax
  111fde:	0f b7 c0             	movzwl %ax,%eax
  111fe1:	89 04 24             	mov    %eax,(%esp)
  111fe4:	e8 87 c2 ff ff       	call   10e270 <htons>
  111fe9:	89 c2                	mov    %eax,%edx
  111feb:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  111fee:	66 89 50 0e          	mov    %dx,0xe(%eax)
    tcphdr->urgp = 0;
  111ff2:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  111ff5:	66 c7 40 12 00 00    	movw   $0x0,0x12(%eax)
    TCPH_HDRLEN_SET(tcphdr, 5);
  111ffb:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  111ffe:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  112002:	0f b7 c0             	movzwl %ax,%eax
  112005:	89 04 24             	mov    %eax,(%esp)
  112008:	e8 93 c2 ff ff       	call   10e2a0 <ntohs>
  11200d:	83 e0 3f             	and    $0x3f,%eax
  112010:	80 cc 50             	or     $0x50,%ah
  112013:	0f b7 c0             	movzwl %ax,%eax
  112016:	89 04 24             	mov    %eax,(%esp)
  112019:	e8 52 c2 ff ff       	call   10e270 <htons>
  11201e:	89 c2                	mov    %eax,%edx
  112020:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  112023:	66 89 50 0c          	mov    %dx,0xc(%eax)

    tcphdr->chksum = 0;
  112027:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  11202a:	66 c7 40 10 00 00    	movw   $0x0,0x10(%eax)
    tcphdr->chksum = inet_chksum_pseudo(p, &(pcb->local_ip), &(pcb->remote_ip),
  112030:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  112033:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  112037:	0f b7 c0             	movzwl %ax,%eax
  11203a:	8b 55 08             	mov    0x8(%ebp),%edx
  11203d:	83 c2 04             	add    $0x4,%edx
  112040:	8b 4d 08             	mov    0x8(%ebp),%ecx
  112043:	89 44 24 10          	mov    %eax,0x10(%esp)
  112047:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
  11204e:	00 
  11204f:	89 54 24 08          	mov    %edx,0x8(%esp)
  112053:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  112057:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  11205a:	89 04 24             	mov    %eax,(%esp)
  11205d:	e8 ce bb ff ff       	call   10dc30 <inet_chksum_pseudo>
  112062:	89 c2                	mov    %eax,%edx
  112064:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  112067:	66 89 50 10          	mov    %dx,0x10(%eax)
          IP_PROTO_TCP, p->tot_len);

    ip_output(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
  11206b:	8b 45 08             	mov    0x8(%ebp),%eax
  11206e:	0f b6 40 0a          	movzbl 0xa(%eax),%eax
  112072:	0f b6 d8             	movzbl %al,%ebx
  112075:	8b 45 08             	mov    0x8(%ebp),%eax
  112078:	0f b6 40 0b          	movzbl 0xb(%eax),%eax
  11207c:	0f b6 c0             	movzbl %al,%eax
  11207f:	8b 55 08             	mov    0x8(%ebp),%edx
  112082:	83 c2 04             	add    $0x4,%edx
  112085:	8b 4d 08             	mov    0x8(%ebp),%ecx
  112088:	c7 44 24 14 06 00 00 	movl   $0x6,0x14(%esp)
  11208f:	00 
  112090:	89 5c 24 10          	mov    %ebx,0x10(%esp)
  112094:	89 44 24 0c          	mov    %eax,0xc(%esp)
  112098:	89 54 24 08          	mov    %edx,0x8(%esp)
  11209c:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1120a0:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  1120a3:	89 04 24             	mov    %eax,(%esp)
  1120a6:	e8 55 b1 ff ff       	call   10d200 <ip_output>
        IP_PROTO_TCP);
    pbuf_free(p);
  1120ab:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  1120ae:	89 04 24             	mov    %eax,(%esp)
  1120b1:	e8 fa d3 ff ff       	call   10f4b0 <pbuf_free>

    return ERR_OK;
  1120b6:	c7 45 c0 00 00 00 00 	movl   $0x0,0xffffffc0(%ebp)
  1120bd:	e9 fa 01 00 00       	jmp    1122bc <tcp_output+0x47c>
  }

#if TCP_OUTPUT_DEBUG
  if (seg == NULL) {
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: nothing to send (%p)\n", pcb->unsent));
  }
#endif /* TCP_OUTPUT_DEBUG */
#if TCP_CWND_DEBUG
  if (seg == NULL) {
    LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_output: snd_wnd %lu, cwnd %lu, wnd %lu, seg == NULL, ack %lu\n",
                            pcb->snd_wnd, pcb->cwnd, wnd,
                            pcb->lastack));
  } else {
    LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_output: snd_wnd %lu, cwnd %lu, wnd %lu, effwnd %lu, seq %lu, ack %lu\n",
                            pcb->snd_wnd, pcb->cwnd, wnd,
                            ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                            ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */

  while (seg != NULL &&
  ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
#if TCP_CWND_DEBUG
    LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_output: snd_wnd %lu, cwnd %lu, wnd %lu, effwnd %lu, seq %lu, ack %lu, i%d\n",
                            pcb->snd_wnd, pcb->cwnd, wnd,
                            ntohl(seg->tcphdr->seqno) + seg->len -
                            pcb->lastack,
                            ntohl(seg->tcphdr->seqno), pcb->lastack, i));
    ++i;
#endif /* TCP_CWND_DEBUG */

    pcb->unsent = seg->next;
  1120c2:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  1120c5:	8b 10                	mov    (%eax),%edx
  1120c7:	8b 45 08             	mov    0x8(%ebp),%eax
  1120ca:	89 50 70             	mov    %edx,0x70(%eax)

    if (pcb->state != SYN_SENT) {
  1120cd:	8b 45 08             	mov    0x8(%ebp),%eax
  1120d0:	8b 40 10             	mov    0x10(%eax),%eax
  1120d3:	83 f8 02             	cmp    $0x2,%eax
  1120d6:	74 3f                	je     112117 <tcp_output+0x2d7>
      TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
  1120d8:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  1120db:	8b 58 10             	mov    0x10(%eax),%ebx
  1120de:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  1120e1:	8b 40 10             	mov    0x10(%eax),%eax
  1120e4:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  1120e8:	0f b7 c0             	movzwl %ax,%eax
  1120eb:	89 04 24             	mov    %eax,(%esp)
  1120ee:	e8 ad c1 ff ff       	call   10e2a0 <ntohs>
  1120f3:	83 c8 10             	or     $0x10,%eax
  1120f6:	0f b7 c0             	movzwl %ax,%eax
  1120f9:	89 04 24             	mov    %eax,(%esp)
  1120fc:	e8 6f c1 ff ff       	call   10e270 <htons>
  112101:	66 89 43 0c          	mov    %ax,0xc(%ebx)
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  112105:	8b 45 08             	mov    0x8(%ebp),%eax
  112108:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  11210c:	89 c2                	mov    %eax,%edx
  11210e:	83 e2 fc             	and    $0xfffffffc,%edx
  112111:	8b 45 08             	mov    0x8(%ebp),%eax
  112114:	88 50 20             	mov    %dl,0x20(%eax)
    }

    tcp_output_segment(seg, pcb);
  112117:	8b 45 08             	mov    0x8(%ebp),%eax
  11211a:	89 44 24 04          	mov    %eax,0x4(%esp)
  11211e:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  112121:	89 04 24             	mov    %eax,(%esp)
  112124:	e8 a7 01 00 00       	call   1122d0 <tcp_output_segment>
    pcb->snd_nxt = ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
  112129:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  11212c:	8b 40 10             	mov    0x10(%eax),%eax
  11212f:	8b 40 04             	mov    0x4(%eax),%eax
  112132:	89 04 24             	mov    %eax,(%esp)
  112135:	e8 c6 c1 ff ff       	call   10e300 <ntohl>
  11213a:	89 45 c8             	mov    %eax,0xffffffc8(%ebp)
  11213d:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  112140:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  112144:	0f b7 c0             	movzwl %ax,%eax
  112147:	89 45 cc             	mov    %eax,0xffffffcc(%ebp)
  11214a:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  11214d:	8b 40 10             	mov    0x10(%eax),%eax
  112150:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  112154:	0f b7 c0             	movzwl %ax,%eax
  112157:	89 04 24             	mov    %eax,(%esp)
  11215a:	e8 41 c1 ff ff       	call   10e2a0 <ntohs>
  11215f:	0f b7 c0             	movzwl %ax,%eax
  112162:	83 e0 01             	and    $0x1,%eax
  112165:	84 c0                	test   %al,%al
  112167:	75 1f                	jne    112188 <tcp_output+0x348>
  112169:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  11216c:	8b 40 10             	mov    0x10(%eax),%eax
  11216f:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  112173:	0f b7 c0             	movzwl %ax,%eax
  112176:	89 04 24             	mov    %eax,(%esp)
  112179:	e8 22 c1 ff ff       	call   10e2a0 <ntohs>
  11217e:	0f b7 c0             	movzwl %ax,%eax
  112181:	83 e0 02             	and    $0x2,%eax
  112184:	85 c0                	test   %eax,%eax
  112186:	74 09                	je     112191 <tcp_output+0x351>
  112188:	c7 45 d0 01 00 00 00 	movl   $0x1,0xffffffd0(%ebp)
  11218f:	eb 07                	jmp    112198 <tcp_output+0x358>
  112191:	c7 45 d0 00 00 00 00 	movl   $0x0,0xffffffd0(%ebp)
  112198:	8b 45 cc             	mov    0xffffffcc(%ebp),%eax
  11219b:	03 45 d0             	add    0xffffffd0(%ebp),%eax
  11219e:	8b 55 c8             	mov    0xffffffc8(%ebp),%edx
  1121a1:	01 c2                	add    %eax,%edx
  1121a3:	8b 45 08             	mov    0x8(%ebp),%eax
  1121a6:	89 50 50             	mov    %edx,0x50(%eax)
    if (TCP_SEQ_LT(pcb->snd_max, pcb->snd_nxt)) {
  1121a9:	8b 45 08             	mov    0x8(%ebp),%eax
  1121ac:	8b 40 54             	mov    0x54(%eax),%eax
  1121af:	89 c2                	mov    %eax,%edx
  1121b1:	8b 45 08             	mov    0x8(%ebp),%eax
  1121b4:	8b 40 50             	mov    0x50(%eax),%eax
  1121b7:	89 d1                	mov    %edx,%ecx
  1121b9:	66 29 c1             	sub    %ax,%cx
  1121bc:	89 c8                	mov    %ecx,%eax
  1121be:	66 85 c0             	test   %ax,%ax
  1121c1:	79 0c                	jns    1121cf <tcp_output+0x38f>
      pcb->snd_max = pcb->snd_nxt;
  1121c3:	8b 45 08             	mov    0x8(%ebp),%eax
  1121c6:	8b 50 50             	mov    0x50(%eax),%edx
  1121c9:	8b 45 08             	mov    0x8(%ebp),%eax
  1121cc:	89 50 54             	mov    %edx,0x54(%eax)
    }
    /* put segment on unacknowledged list if length > 0 */
    if (TCP_TCPLEN(seg) > 0) {
  1121cf:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  1121d2:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  1121d6:	0f b7 c0             	movzwl %ax,%eax
  1121d9:	89 45 d4             	mov    %eax,0xffffffd4(%ebp)
  1121dc:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  1121df:	8b 40 10             	mov    0x10(%eax),%eax
  1121e2:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  1121e6:	0f b7 c0             	movzwl %ax,%eax
  1121e9:	89 04 24             	mov    %eax,(%esp)
  1121ec:	e8 af c0 ff ff       	call   10e2a0 <ntohs>
  1121f1:	0f b7 c0             	movzwl %ax,%eax
  1121f4:	83 e0 01             	and    $0x1,%eax
  1121f7:	84 c0                	test   %al,%al
  1121f9:	75 1f                	jne    11221a <tcp_output+0x3da>
  1121fb:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  1121fe:	8b 40 10             	mov    0x10(%eax),%eax
  112201:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  112205:	0f b7 c0             	movzwl %ax,%eax
  112208:	89 04 24             	mov    %eax,(%esp)
  11220b:	e8 90 c0 ff ff       	call   10e2a0 <ntohs>
  112210:	0f b7 c0             	movzwl %ax,%eax
  112213:	83 e0 02             	and    $0x2,%eax
  112216:	85 c0                	test   %eax,%eax
  112218:	74 09                	je     112223 <tcp_output+0x3e3>
  11221a:	c7 45 d8 01 00 00 00 	movl   $0x1,0xffffffd8(%ebp)
  112221:	eb 07                	jmp    11222a <tcp_output+0x3ea>
  112223:	c7 45 d8 00 00 00 00 	movl   $0x0,0xffffffd8(%ebp)
  11222a:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
  11222d:	03 45 d8             	add    0xffffffd8(%ebp),%eax
  112230:	85 c0                	test   %eax,%eax
  112232:	7e 36                	jle    11226a <tcp_output+0x42a>
      seg->next = NULL;
  112234:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  112237:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
      if (pcb->unacked == NULL) {
  11223d:	8b 45 08             	mov    0x8(%ebp),%eax
  112240:	8b 40 74             	mov    0x74(%eax),%eax
  112243:	85 c0                	test   %eax,%eax
  112245:	75 11                	jne    112258 <tcp_output+0x418>
        pcb->unacked = seg;
  112247:	8b 45 08             	mov    0x8(%ebp),%eax
  11224a:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
  11224d:	89 50 74             	mov    %edx,0x74(%eax)
        useg = seg;
  112250:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  112253:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  112256:	eb 1d                	jmp    112275 <tcp_output+0x435>
      } else {
        useg->next = seg;
  112258:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
  11225b:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  11225e:	89 02                	mov    %eax,(%edx)
        useg = useg->next;
  112260:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  112263:	8b 00                	mov    (%eax),%eax
  112265:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  112268:	eb 0b                	jmp    112275 <tcp_output+0x435>
      }
    } else {
      tcp_seg_free(seg);
  11226a:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  11226d:	89 04 24             	mov    %eax,(%esp)
  112270:	e8 9b ee ff ff       	call   111110 <tcp_seg_free>
    }
    seg = pcb->unsent;
  112275:	8b 45 08             	mov    0x8(%ebp),%eax
  112278:	8b 40 70             	mov    0x70(%eax),%eax
  11227b:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
  11227e:	83 7d f0 00          	cmpl   $0x0,0xfffffff0(%ebp)
  112282:	74 31                	je     1122b5 <tcp_output+0x475>
  112284:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  112287:	8b 40 10             	mov    0x10(%eax),%eax
  11228a:	8b 40 04             	mov    0x4(%eax),%eax
  11228d:	89 04 24             	mov    %eax,(%esp)
  112290:	e8 6b c0 ff ff       	call   10e300 <ntohl>
  112295:	89 c2                	mov    %eax,%edx
  112297:	8b 45 08             	mov    0x8(%ebp),%eax
  11229a:	8b 40 44             	mov    0x44(%eax),%eax
  11229d:	29 c2                	sub    %eax,%edx
  11229f:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  1122a2:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  1122a6:	0f b7 c0             	movzwl %ax,%eax
  1122a9:	8d 04 02             	lea    (%edx,%eax,1),%eax
  1122ac:	3b 45 f8             	cmp    0xfffffff8(%ebp),%eax
  1122af:	0f 86 0d fe ff ff    	jbe    1120c2 <tcp_output+0x282>
  }
  return ERR_OK;
  1122b5:	c7 45 c0 00 00 00 00 	movl   $0x0,0xffffffc0(%ebp)
  1122bc:	8b 45 c0             	mov    0xffffffc0(%ebp),%eax
}
  1122bf:	83 c4 64             	add    $0x64,%esp
  1122c2:	5b                   	pop    %ebx
  1122c3:	5d                   	pop    %ebp
  1122c4:	c3                   	ret    
  1122c5:	8d 74 26 00          	lea    0x0(%esi),%esi
  1122c9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

001122d0 <tcp_output_segment>:

static void
tcp_output_segment(struct tcp_seg *seg, struct tcp_pcb *pcb)
{
  1122d0:	55                   	push   %ebp
  1122d1:	89 e5                	mov    %esp,%ebp
  1122d3:	56                   	push   %esi
  1122d4:	53                   	push   %ebx
  1122d5:	83 ec 30             	sub    $0x30,%esp
  u16_t len;
  struct netif *netif;

  /* The TCP header has already been constructed, but the ackno and
   wnd fields remain. */
  seg->tcphdr->ackno = htonl(pcb->rcv_nxt);
  1122d8:	8b 45 08             	mov    0x8(%ebp),%eax
  1122db:	8b 58 10             	mov    0x10(%eax),%ebx
  1122de:	8b 45 0c             	mov    0xc(%ebp),%eax
  1122e1:	8b 40 24             	mov    0x24(%eax),%eax
  1122e4:	89 04 24             	mov    %eax,(%esp)
  1122e7:	e8 d4 bf ff ff       	call   10e2c0 <htonl>
  1122ec:	89 43 08             	mov    %eax,0x8(%ebx)

  /* silly window avoidance */
  if (pcb->rcv_wnd < pcb->mss) {
  1122ef:	8b 45 0c             	mov    0xc(%ebp),%eax
  1122f2:	0f b7 50 28          	movzwl 0x28(%eax),%edx
  1122f6:	8b 45 0c             	mov    0xc(%ebp),%eax
  1122f9:	0f b7 40 34          	movzwl 0x34(%eax),%eax
  1122fd:	66 39 c2             	cmp    %ax,%dx
  112300:	73 0e                	jae    112310 <tcp_output_segment+0x40>
    seg->tcphdr->wnd = 0;
  112302:	8b 45 08             	mov    0x8(%ebp),%eax
  112305:	8b 40 10             	mov    0x10(%eax),%eax
  112308:	66 c7 40 0e 00 00    	movw   $0x0,0xe(%eax)
  11230e:	eb 1c                	jmp    11232c <tcp_output_segment+0x5c>
  } else {
    /* advertise our receive window size in this TCP segment */
    seg->tcphdr->wnd = htons(pcb->rcv_wnd);
  112310:	8b 45 08             	mov    0x8(%ebp),%eax
  112313:	8b 58 10             	mov    0x10(%eax),%ebx
  112316:	8b 45 0c             	mov    0xc(%ebp),%eax
  112319:	0f b7 40 28          	movzwl 0x28(%eax),%eax
  11231d:	0f b7 c0             	movzwl %ax,%eax
  112320:	89 04 24             	mov    %eax,(%esp)
  112323:	e8 48 bf ff ff       	call   10e270 <htons>
  112328:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  }

  /* If we don't have a local IP address, we get one by
     calling ip_route(). */
  if (ip_addr_isany(&(pcb->local_ip))) {
  11232c:	8b 45 0c             	mov    0xc(%ebp),%eax
  11232f:	85 c0                	test   %eax,%eax
  112331:	74 09                	je     11233c <tcp_output_segment+0x6c>
  112333:	8b 45 0c             	mov    0xc(%ebp),%eax
  112336:	8b 00                	mov    (%eax),%eax
  112338:	85 c0                	test   %eax,%eax
  11233a:	75 3f                	jne    11237b <tcp_output_segment+0xab>
    netif = ip_route(&(pcb->remote_ip));
  11233c:	8b 45 0c             	mov    0xc(%ebp),%eax
  11233f:	83 c0 04             	add    $0x4,%eax
  112342:	89 04 24             	mov    %eax,(%esp)
  112345:	e8 a6 a7 ff ff       	call   10caf0 <ip_route>
  11234a:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
    if (netif == NULL) {
  11234d:	83 7d f4 00          	cmpl   $0x0,0xfffffff4(%ebp)
  112351:	0f 84 5c 01 00 00    	je     1124b3 <tcp_output_segment+0x1e3>
      return;
    }
    ip_addr_set(&(pcb->local_ip), &(netif->ip_addr));
  112357:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  11235a:	83 c0 04             	add    $0x4,%eax
  11235d:	85 c0                	test   %eax,%eax
  11235f:	74 0b                	je     11236c <tcp_output_segment+0x9c>
  112361:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  112364:	8b 40 04             	mov    0x4(%eax),%eax
  112367:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
  11236a:	eb 07                	jmp    112373 <tcp_output_segment+0xa3>
  11236c:	c7 45 e4 00 00 00 00 	movl   $0x0,0xffffffe4(%ebp)
  112373:	8b 45 0c             	mov    0xc(%ebp),%eax
  112376:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
  112379:	89 10                	mov    %edx,(%eax)
  }

  pcb->rtime = 0;
  11237b:	8b 45 0c             	mov    0xc(%ebp),%eax
  11237e:	66 c7 40 32 00 00    	movw   $0x0,0x32(%eax)

  if (pcb->rttest == 0) {
  112384:	8b 45 0c             	mov    0xc(%ebp),%eax
  112387:	0f b7 40 36          	movzwl 0x36(%eax),%eax
  11238b:	66 85 c0             	test   %ax,%ax
  11238e:	75 27                	jne    1123b7 <tcp_output_segment+0xe7>
    pcb->rttest = tcp_ticks;
  112390:	a1 58 16 14 00       	mov    0x141658,%eax
  112395:	89 c2                	mov    %eax,%edx
  112397:	8b 45 0c             	mov    0xc(%ebp),%eax
  11239a:	66 89 50 36          	mov    %dx,0x36(%eax)
    pcb->rtseq = ntohl(seg->tcphdr->seqno);
  11239e:	8b 45 08             	mov    0x8(%ebp),%eax
  1123a1:	8b 40 10             	mov    0x10(%eax),%eax
  1123a4:	8b 40 04             	mov    0x4(%eax),%eax
  1123a7:	89 04 24             	mov    %eax,(%esp)
  1123aa:	e8 51 bf ff ff       	call   10e300 <ntohl>
  1123af:	89 c2                	mov    %eax,%edx
  1123b1:	8b 45 0c             	mov    0xc(%ebp),%eax
  1123b4:	89 50 38             	mov    %edx,0x38(%eax)

    LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_output_segment: rtseq %lu\n", pcb->rtseq));
  }
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output_segment: %lu:%lu\n",
          htonl(seg->tcphdr->seqno), htonl(seg->tcphdr->seqno) +
          seg->len));

  len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
  1123b7:	8b 45 08             	mov    0x8(%ebp),%eax
  1123ba:	8b 40 10             	mov    0x10(%eax),%eax
  1123bd:	89 c2                	mov    %eax,%edx
  1123bf:	8b 45 08             	mov    0x8(%ebp),%eax
  1123c2:	8b 40 04             	mov    0x4(%eax),%eax
  1123c5:	8b 40 04             	mov    0x4(%eax),%eax
  1123c8:	89 d1                	mov    %edx,%ecx
  1123ca:	66 29 c1             	sub    %ax,%cx
  1123cd:	89 c8                	mov    %ecx,%eax
  1123cf:	66 89 45 f2          	mov    %ax,0xfffffff2(%ebp)

  seg->p->len -= len;
  1123d3:	8b 45 08             	mov    0x8(%ebp),%eax
  1123d6:	8b 50 04             	mov    0x4(%eax),%edx
  1123d9:	8b 45 08             	mov    0x8(%ebp),%eax
  1123dc:	8b 40 04             	mov    0x4(%eax),%eax
  1123df:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  1123e3:	66 2b 45 f2          	sub    0xfffffff2(%ebp),%ax
  1123e7:	66 89 42 0a          	mov    %ax,0xa(%edx)
  seg->p->tot_len -= len;
  1123eb:	8b 45 08             	mov    0x8(%ebp),%eax
  1123ee:	8b 50 04             	mov    0x4(%eax),%edx
  1123f1:	8b 45 08             	mov    0x8(%ebp),%eax
  1123f4:	8b 40 04             	mov    0x4(%eax),%eax
  1123f7:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  1123fb:	66 2b 45 f2          	sub    0xfffffff2(%ebp),%ax
  1123ff:	66 89 42 08          	mov    %ax,0x8(%edx)

  seg->p->payload = seg->tcphdr;
  112403:	8b 45 08             	mov    0x8(%ebp),%eax
  112406:	8b 50 04             	mov    0x4(%eax),%edx
  112409:	8b 45 08             	mov    0x8(%ebp),%eax
  11240c:	8b 40 10             	mov    0x10(%eax),%eax
  11240f:	89 42 04             	mov    %eax,0x4(%edx)

  seg->tcphdr->chksum = 0;
  112412:	8b 45 08             	mov    0x8(%ebp),%eax
  112415:	8b 40 10             	mov    0x10(%eax),%eax
  112418:	66 c7 40 10 00 00    	movw   $0x0,0x10(%eax)
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p,
  11241e:	8b 45 08             	mov    0x8(%ebp),%eax
  112421:	8b 70 10             	mov    0x10(%eax),%esi
  112424:	8b 45 08             	mov    0x8(%ebp),%eax
  112427:	8b 40 04             	mov    0x4(%eax),%eax
  11242a:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  11242e:	0f b7 d0             	movzwl %ax,%edx
  112431:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  112434:	83 c1 04             	add    $0x4,%ecx
  112437:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  11243a:	8b 45 08             	mov    0x8(%ebp),%eax
  11243d:	8b 40 04             	mov    0x4(%eax),%eax
  112440:	89 54 24 10          	mov    %edx,0x10(%esp)
  112444:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
  11244b:	00 
  11244c:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  112450:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  112454:	89 04 24             	mov    %eax,(%esp)
  112457:	e8 d4 b7 ff ff       	call   10dc30 <inet_chksum_pseudo>
  11245c:	66 89 46 10          	mov    %ax,0x10(%esi)
             &(pcb->local_ip),
             &(pcb->remote_ip),
             IP_PROTO_TCP, seg->p->tot_len);
  TCP_STATS_INC(tcp.xmit);
  112460:	0f b7 05 62 15 14 00 	movzwl 0x141562,%eax
  112467:	83 c0 01             	add    $0x1,%eax
  11246a:	66 a3 62 15 14 00    	mov    %ax,0x141562

  ip_output(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
  112470:	8b 45 0c             	mov    0xc(%ebp),%eax
  112473:	0f b6 40 0a          	movzbl 0xa(%eax),%eax
  112477:	0f b6 d0             	movzbl %al,%edx
  11247a:	8b 45 0c             	mov    0xc(%ebp),%eax
  11247d:	0f b6 40 0b          	movzbl 0xb(%eax),%eax
  112481:	0f b6 c8             	movzbl %al,%ecx
  112484:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  112487:	83 c3 04             	add    $0x4,%ebx
  11248a:	8b 75 0c             	mov    0xc(%ebp),%esi
  11248d:	8b 45 08             	mov    0x8(%ebp),%eax
  112490:	8b 40 04             	mov    0x4(%eax),%eax
  112493:	c7 44 24 14 06 00 00 	movl   $0x6,0x14(%esp)
  11249a:	00 
  11249b:	89 54 24 10          	mov    %edx,0x10(%esp)
  11249f:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
  1124a3:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  1124a7:	89 74 24 04          	mov    %esi,0x4(%esp)
  1124ab:	89 04 24             	mov    %eax,(%esp)
  1124ae:	e8 4d ad ff ff       	call   10d200 <ip_output>
      IP_PROTO_TCP);
}
  1124b3:	83 c4 30             	add    $0x30,%esp
  1124b6:	5b                   	pop    %ebx
  1124b7:	5e                   	pop    %esi
  1124b8:	5d                   	pop    %ebp
  1124b9:	c3                   	ret    
  1124ba:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

001124c0 <tcp_rst>:

void
tcp_rst(u32_t seqno, u32_t ackno,
  struct ip_addr *local_ip, struct ip_addr *remote_ip,
  u16_t local_port, u16_t remote_port)
{
  1124c0:	55                   	push   %ebp
  1124c1:	89 e5                	mov    %esp,%ebp
  1124c3:	83 ec 38             	sub    $0x38,%esp
  1124c6:	8b 45 18             	mov    0x18(%ebp),%eax
  1124c9:	8b 55 1c             	mov    0x1c(%ebp),%edx
  1124cc:	66 89 45 ec          	mov    %ax,0xffffffec(%ebp)
  1124d0:	66 89 55 e8          	mov    %dx,0xffffffe8(%ebp)
  struct pbuf *p;
  struct tcp_hdr *tcphdr;
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  1124d4:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  1124db:	00 
  1124dc:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  1124e3:	00 
  1124e4:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  1124eb:	e8 e0 ca ff ff       	call   10efd0 <pbuf_alloc>
  1124f0:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  if (p == NULL) {
  1124f3:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  1124f7:	75 05                	jne    1124fe <tcp_rst+0x3e>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_rst: could not allocate memory for pbuf\n"));
      return;
  1124f9:	e9 5b 01 00 00       	jmp    112659 <tcp_rst+0x199>
  }

  tcphdr = p->payload;
  1124fe:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  112501:	8b 40 04             	mov    0x4(%eax),%eax
  112504:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  tcphdr->src = htons(local_port);
  112507:	0f b7 45 ec          	movzwl 0xffffffec(%ebp),%eax
  11250b:	89 04 24             	mov    %eax,(%esp)
  11250e:	e8 5d bd ff ff       	call   10e270 <htons>
  112513:	89 c2                	mov    %eax,%edx
  112515:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  112518:	66 89 10             	mov    %dx,(%eax)
  tcphdr->dest = htons(remote_port);
  11251b:	0f b7 45 e8          	movzwl 0xffffffe8(%ebp),%eax
  11251f:	89 04 24             	mov    %eax,(%esp)
  112522:	e8 49 bd ff ff       	call   10e270 <htons>
  112527:	89 c2                	mov    %eax,%edx
  112529:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  11252c:	66 89 50 02          	mov    %dx,0x2(%eax)
  tcphdr->seqno = htonl(seqno);
  112530:	8b 45 08             	mov    0x8(%ebp),%eax
  112533:	89 04 24             	mov    %eax,(%esp)
  112536:	e8 85 bd ff ff       	call   10e2c0 <htonl>
  11253b:	89 c2                	mov    %eax,%edx
  11253d:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  112540:	89 50 04             	mov    %edx,0x4(%eax)
  tcphdr->ackno = htonl(ackno);
  112543:	8b 45 0c             	mov    0xc(%ebp),%eax
  112546:	89 04 24             	mov    %eax,(%esp)
  112549:	e8 72 bd ff ff       	call   10e2c0 <htonl>
  11254e:	89 c2                	mov    %eax,%edx
  112550:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  112553:	89 50 08             	mov    %edx,0x8(%eax)
  TCPH_FLAGS_SET(tcphdr, TCP_RST | TCP_ACK);
  112556:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  112559:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  11255d:	0f b7 c0             	movzwl %ax,%eax
  112560:	89 04 24             	mov    %eax,(%esp)
  112563:	e8 38 bd ff ff       	call   10e2a0 <ntohs>
  112568:	83 e0 c0             	and    $0xffffffc0,%eax
  11256b:	83 c8 14             	or     $0x14,%eax
  11256e:	0f b7 c0             	movzwl %ax,%eax
  112571:	89 04 24             	mov    %eax,(%esp)
  112574:	e8 f7 bc ff ff       	call   10e270 <htons>
  112579:	89 c2                	mov    %eax,%edx
  11257b:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  11257e:	66 89 50 0c          	mov    %dx,0xc(%eax)
  tcphdr->wnd = htons(TCP_WND);
  112582:	c7 04 24 00 20 00 00 	movl   $0x2000,(%esp)
  112589:	e8 e2 bc ff ff       	call   10e270 <htons>
  11258e:	89 c2                	mov    %eax,%edx
  112590:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  112593:	66 89 50 0e          	mov    %dx,0xe(%eax)
  tcphdr->urgp = 0;
  112597:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  11259a:	66 c7 40 12 00 00    	movw   $0x0,0x12(%eax)
  TCPH_HDRLEN_SET(tcphdr, 5);
  1125a0:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1125a3:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  1125a7:	0f b7 c0             	movzwl %ax,%eax
  1125aa:	89 04 24             	mov    %eax,(%esp)
  1125ad:	e8 ee bc ff ff       	call   10e2a0 <ntohs>
  1125b2:	83 e0 3f             	and    $0x3f,%eax
  1125b5:	80 cc 50             	or     $0x50,%ah
  1125b8:	0f b7 c0             	movzwl %ax,%eax
  1125bb:	89 04 24             	mov    %eax,(%esp)
  1125be:	e8 ad bc ff ff       	call   10e270 <htons>
  1125c3:	89 c2                	mov    %eax,%edx
  1125c5:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1125c8:	66 89 50 0c          	mov    %dx,0xc(%eax)

  tcphdr->chksum = 0;
  1125cc:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1125cf:	66 c7 40 10 00 00    	movw   $0x0,0x10(%eax)
  tcphdr->chksum = inet_chksum_pseudo(p, local_ip, remote_ip,
  1125d5:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1125d8:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  1125dc:	0f b7 c0             	movzwl %ax,%eax
  1125df:	89 44 24 10          	mov    %eax,0x10(%esp)
  1125e3:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
  1125ea:	00 
  1125eb:	8b 45 14             	mov    0x14(%ebp),%eax
  1125ee:	89 44 24 08          	mov    %eax,0x8(%esp)
  1125f2:	8b 45 10             	mov    0x10(%ebp),%eax
  1125f5:	89 44 24 04          	mov    %eax,0x4(%esp)
  1125f9:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1125fc:	89 04 24             	mov    %eax,(%esp)
  1125ff:	e8 2c b6 ff ff       	call   10dc30 <inet_chksum_pseudo>
  112604:	89 c2                	mov    %eax,%edx
  112606:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  112609:	66 89 50 10          	mov    %dx,0x10(%eax)
              IP_PROTO_TCP, p->tot_len);

  TCP_STATS_INC(tcp.xmit);
  11260d:	0f b7 05 62 15 14 00 	movzwl 0x141562,%eax
  112614:	83 c0 01             	add    $0x1,%eax
  112617:	66 a3 62 15 14 00    	mov    %ax,0x141562
   /* Send output with hardcoded TTL since we have no access to the pcb */
  ip_output(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
  11261d:	c7 44 24 14 06 00 00 	movl   $0x6,0x14(%esp)
  112624:	00 
  112625:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  11262c:	00 
  11262d:	c7 44 24 0c ff 00 00 	movl   $0xff,0xc(%esp)
  112634:	00 
  112635:	8b 45 14             	mov    0x14(%ebp),%eax
  112638:	89 44 24 08          	mov    %eax,0x8(%esp)
  11263c:	8b 45 10             	mov    0x10(%ebp),%eax
  11263f:	89 44 24 04          	mov    %eax,0x4(%esp)
  112643:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  112646:	89 04 24             	mov    %eax,(%esp)
  112649:	e8 b2 ab ff ff       	call   10d200 <ip_output>
  pbuf_free(p);
  11264e:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  112651:	89 04 24             	mov    %eax,(%esp)
  112654:	e8 57 ce ff ff       	call   10f4b0 <pbuf_free>
  LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_rst: seqno %lu ackno %lu.\n", seqno, ackno));
}
  112659:	c9                   	leave  
  11265a:	c3                   	ret    
  11265b:	90                   	nop    
  11265c:	8d 74 26 00          	lea    0x0(%esi),%esi

00112660 <tcp_rexmit>:

void
tcp_rexmit(struct tcp_pcb *pcb)
{
  112660:	55                   	push   %ebp
  112661:	89 e5                	mov    %esp,%ebp
  112663:	83 ec 18             	sub    $0x18,%esp
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
  112666:	8b 45 08             	mov    0x8(%ebp),%eax
  112669:	8b 40 74             	mov    0x74(%eax),%eax
  11266c:	85 c0                	test   %eax,%eax
  11266e:	74 7d                	je     1126ed <tcp_rexmit+0x8d>
    return;
  }

  /* Move all unacked segments to the unsent queue. */
  for (seg = pcb->unacked; seg->next != NULL; seg = seg->next);
  112670:	8b 45 08             	mov    0x8(%ebp),%eax
  112673:	8b 40 74             	mov    0x74(%eax),%eax
  112676:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  112679:	eb 08                	jmp    112683 <tcp_rexmit+0x23>
  11267b:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  11267e:	8b 00                	mov    (%eax),%eax
  112680:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  112683:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  112686:	8b 00                	mov    (%eax),%eax
  112688:	85 c0                	test   %eax,%eax
  11268a:	75 ef                	jne    11267b <tcp_rexmit+0x1b>

  seg->next = pcb->unsent;
  11268c:	8b 45 08             	mov    0x8(%ebp),%eax
  11268f:	8b 50 70             	mov    0x70(%eax),%edx
  112692:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  112695:	89 10                	mov    %edx,(%eax)
  pcb->unsent = pcb->unacked;
  112697:	8b 45 08             	mov    0x8(%ebp),%eax
  11269a:	8b 50 74             	mov    0x74(%eax),%edx
  11269d:	8b 45 08             	mov    0x8(%ebp),%eax
  1126a0:	89 50 70             	mov    %edx,0x70(%eax)

  pcb->unacked = NULL;
  1126a3:	8b 45 08             	mov    0x8(%ebp),%eax
  1126a6:	c7 40 74 00 00 00 00 	movl   $0x0,0x74(%eax)


  pcb->snd_nxt = ntohl(pcb->unsent->tcphdr->seqno);
  1126ad:	8b 45 08             	mov    0x8(%ebp),%eax
  1126b0:	8b 40 70             	mov    0x70(%eax),%eax
  1126b3:	8b 40 10             	mov    0x10(%eax),%eax
  1126b6:	8b 40 04             	mov    0x4(%eax),%eax
  1126b9:	89 04 24             	mov    %eax,(%esp)
  1126bc:	e8 3f bc ff ff       	call   10e300 <ntohl>
  1126c1:	89 c2                	mov    %eax,%edx
  1126c3:	8b 45 08             	mov    0x8(%ebp),%eax
  1126c6:	89 50 50             	mov    %edx,0x50(%eax)

  ++pcb->nrtx;
  1126c9:	8b 45 08             	mov    0x8(%ebp),%eax
  1126cc:	0f b6 40 42          	movzbl 0x42(%eax),%eax
  1126d0:	8d 50 01             	lea    0x1(%eax),%edx
  1126d3:	8b 45 08             	mov    0x8(%ebp),%eax
  1126d6:	88 50 42             	mov    %dl,0x42(%eax)

  /* Don't take any rtt measurements after retransmitting. */
  pcb->rttest = 0;
  1126d9:	8b 45 08             	mov    0x8(%ebp),%eax
  1126dc:	66 c7 40 36 00 00    	movw   $0x0,0x36(%eax)

  /* Do the actual retransmission. */
  tcp_output(pcb);
  1126e2:	8b 45 08             	mov    0x8(%ebp),%eax
  1126e5:	89 04 24             	mov    %eax,(%esp)
  1126e8:	e8 53 f7 ff ff       	call   111e40 <tcp_output>

}
  1126ed:	c9                   	leave  
  1126ee:	c3                   	ret    
  1126ef:	90                   	nop    

001126f0 <tcp_keepalive>:

void
tcp_keepalive(struct tcp_pcb *pcb)
{
  1126f0:	55                   	push   %ebp
  1126f1:	89 e5                	mov    %esp,%ebp
  1126f3:	83 ec 28             	sub    $0x28,%esp
   struct pbuf *p;
   struct tcp_hdr *tcphdr;

   LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: sending KEEPALIVE probe to %u.%u.%u.%u\n",
                           ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                           ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip)));

   LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: tcp_ticks %ld   pcb->tmr %ld  pcb->keep_cnt %ld\n", tcp_ticks, pcb->tmr, pcb->keep_cnt));
   
   p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  1126f6:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  1126fd:	00 
  1126fe:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  112705:	00 
  112706:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  11270d:	e8 be c8 ff ff       	call   10efd0 <pbuf_alloc>
  112712:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)

   if(p == NULL) {
  112715:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  112719:	75 05                	jne    112720 <tcp_keepalive+0x30>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: could not allocate memory for pbuf\n"));
      return;
  11271b:	e9 56 01 00 00       	jmp    112876 <tcp_keepalive+0x186>
   }

   tcphdr = p->payload;
  112720:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  112723:	8b 40 04             	mov    0x4(%eax),%eax
  112726:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
   tcphdr->src = htons(pcb->local_port);
  112729:	8b 45 08             	mov    0x8(%ebp),%eax
  11272c:	0f b7 40 1c          	movzwl 0x1c(%eax),%eax
  112730:	0f b7 c0             	movzwl %ax,%eax
  112733:	89 04 24             	mov    %eax,(%esp)
  112736:	e8 35 bb ff ff       	call   10e270 <htons>
  11273b:	89 c2                	mov    %eax,%edx
  11273d:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  112740:	66 89 10             	mov    %dx,(%eax)
   tcphdr->dest = htons(pcb->remote_port);
  112743:	8b 45 08             	mov    0x8(%ebp),%eax
  112746:	0f b7 40 1e          	movzwl 0x1e(%eax),%eax
  11274a:	0f b7 c0             	movzwl %ax,%eax
  11274d:	89 04 24             	mov    %eax,(%esp)
  112750:	e8 1b bb ff ff       	call   10e270 <htons>
  112755:	89 c2                	mov    %eax,%edx
  112757:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  11275a:	66 89 50 02          	mov    %dx,0x2(%eax)
   tcphdr->seqno = htonl(pcb->snd_nxt - 1);
  11275e:	8b 45 08             	mov    0x8(%ebp),%eax
  112761:	8b 40 50             	mov    0x50(%eax),%eax
  112764:	83 e8 01             	sub    $0x1,%eax
  112767:	89 04 24             	mov    %eax,(%esp)
  11276a:	e8 51 bb ff ff       	call   10e2c0 <htonl>
  11276f:	89 c2                	mov    %eax,%edx
  112771:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  112774:	89 50 04             	mov    %edx,0x4(%eax)
   tcphdr->ackno = htonl(pcb->rcv_nxt);
  112777:	8b 45 08             	mov    0x8(%ebp),%eax
  11277a:	8b 40 24             	mov    0x24(%eax),%eax
  11277d:	89 04 24             	mov    %eax,(%esp)
  112780:	e8 3b bb ff ff       	call   10e2c0 <htonl>
  112785:	89 c2                	mov    %eax,%edx
  112787:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  11278a:	89 50 08             	mov    %edx,0x8(%eax)
   tcphdr->wnd = htons(pcb->rcv_wnd);
  11278d:	8b 45 08             	mov    0x8(%ebp),%eax
  112790:	0f b7 40 28          	movzwl 0x28(%eax),%eax
  112794:	0f b7 c0             	movzwl %ax,%eax
  112797:	89 04 24             	mov    %eax,(%esp)
  11279a:	e8 d1 ba ff ff       	call   10e270 <htons>
  11279f:	89 c2                	mov    %eax,%edx
  1127a1:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1127a4:	66 89 50 0e          	mov    %dx,0xe(%eax)
   tcphdr->urgp = 0;
  1127a8:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1127ab:	66 c7 40 12 00 00    	movw   $0x0,0x12(%eax)
   TCPH_HDRLEN_SET(tcphdr, 5);
  1127b1:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1127b4:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  1127b8:	0f b7 c0             	movzwl %ax,%eax
  1127bb:	89 04 24             	mov    %eax,(%esp)
  1127be:	e8 dd ba ff ff       	call   10e2a0 <ntohs>
  1127c3:	83 e0 3f             	and    $0x3f,%eax
  1127c6:	80 cc 50             	or     $0x50,%ah
  1127c9:	0f b7 c0             	movzwl %ax,%eax
  1127cc:	89 04 24             	mov    %eax,(%esp)
  1127cf:	e8 9c ba ff ff       	call   10e270 <htons>
  1127d4:	89 c2                	mov    %eax,%edx
  1127d6:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1127d9:	66 89 50 0c          	mov    %dx,0xc(%eax)
   
   tcphdr->chksum = 0;
  1127dd:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1127e0:	66 c7 40 10 00 00    	movw   $0x0,0x10(%eax)
   tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip, IP_PROTO_TCP, p->tot_len);
  1127e6:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1127e9:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  1127ed:	0f b7 c0             	movzwl %ax,%eax
  1127f0:	8b 55 08             	mov    0x8(%ebp),%edx
  1127f3:	83 c2 04             	add    $0x4,%edx
  1127f6:	8b 4d 08             	mov    0x8(%ebp),%ecx
  1127f9:	89 44 24 10          	mov    %eax,0x10(%esp)
  1127fd:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
  112804:	00 
  112805:	89 54 24 08          	mov    %edx,0x8(%esp)
  112809:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  11280d:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  112810:	89 04 24             	mov    %eax,(%esp)
  112813:	e8 18 b4 ff ff       	call   10dc30 <inet_chksum_pseudo>
  112818:	89 c2                	mov    %eax,%edx
  11281a:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  11281d:	66 89 50 10          	mov    %dx,0x10(%eax)

  TCP_STATS_INC(tcp.xmit);
  112821:	0f b7 05 62 15 14 00 	movzwl 0x141562,%eax
  112828:	83 c0 01             	add    $0x1,%eax
  11282b:	66 a3 62 15 14 00    	mov    %ax,0x141562

   /* Send output to IP */
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
  112831:	8b 45 08             	mov    0x8(%ebp),%eax
  112834:	0f b6 40 0b          	movzbl 0xb(%eax),%eax
  112838:	0f b6 c0             	movzbl %al,%eax
  11283b:	8b 55 08             	mov    0x8(%ebp),%edx
  11283e:	83 c2 04             	add    $0x4,%edx
  112841:	8b 4d 08             	mov    0x8(%ebp),%ecx
  112844:	c7 44 24 14 06 00 00 	movl   $0x6,0x14(%esp)
  11284b:	00 
  11284c:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  112853:	00 
  112854:	89 44 24 0c          	mov    %eax,0xc(%esp)
  112858:	89 54 24 08          	mov    %edx,0x8(%esp)
  11285c:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  112860:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  112863:	89 04 24             	mov    %eax,(%esp)
  112866:	e8 95 a9 ff ff       	call   10d200 <ip_output>

  pbuf_free(p);
  11286b:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  11286e:	89 04 24             	mov    %eax,(%esp)
  112871:	e8 3a cc ff ff       	call   10f4b0 <pbuf_free>

  LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_keepalive: seqno %lu ackno %lu.\n", pcb->snd_nxt - 1, pcb->rcv_nxt));
}
  112876:	c9                   	leave  
  112877:	c3                   	ret    
  112878:	90                   	nop    
  112879:	90                   	nop    
  11287a:	90                   	nop    
  11287b:	90                   	nop    
  11287c:	90                   	nop    
  11287d:	90                   	nop    
  11287e:	90                   	nop    
  11287f:	90                   	nop    

00112880 <tcp_input>:
 */

void
tcp_input(struct pbuf *p, struct netif *inp)
{
  112880:	55                   	push   %ebp
  112881:	89 e5                	mov    %esp,%ebp
  112883:	57                   	push   %edi
  112884:	56                   	push   %esi
  112885:	53                   	push   %ebx
  112886:	83 ec 4c             	sub    $0x4c,%esp
  struct tcp_pcb *pcb, *prev;
  struct tcp_pcb_listen *lpcb;
  u8_t hdrlen;
  err_t err;

#if SO_REUSE
  struct tcp_pcb *pcb_temp;
  int reuse = 0;
  112889:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  int reuse_port = 0;
  112890:	c7 45 f0 00 00 00 00 	movl   $0x0,0xfffffff0(%ebp)
#endif /* SO_REUSE */

  PERF_START;

  TCP_STATS_INC(tcp.recv);
  112897:	0f b7 05 66 15 14 00 	movzwl 0x141566,%eax
  11289e:	83 c0 01             	add    $0x1,%eax
  1128a1:	66 a3 66 15 14 00    	mov    %ax,0x141566

  iphdr = p->payload;
  1128a7:	8b 45 08             	mov    0x8(%ebp),%eax
  1128aa:	8b 40 04             	mov    0x4(%eax),%eax
  1128ad:	a3 08 99 13 00       	mov    %eax,0x139908
  tcphdr = (struct tcp_hdr *)((u8_t *)p->payload + IPH_HL(iphdr) * 4);
  1128b2:	8b 45 08             	mov    0x8(%ebp),%eax
  1128b5:	8b 40 04             	mov    0x4(%eax),%eax
  1128b8:	89 c3                	mov    %eax,%ebx
  1128ba:	a1 08 99 13 00       	mov    0x139908,%eax
  1128bf:	0f b7 00             	movzwl (%eax),%eax
  1128c2:	0f b7 c0             	movzwl %ax,%eax
  1128c5:	89 04 24             	mov    %eax,(%esp)
  1128c8:	e8 d3 b9 ff ff       	call   10e2a0 <ntohs>
  1128cd:	66 c1 e8 08          	shr    $0x8,%ax
  1128d1:	0f b7 c0             	movzwl %ax,%eax
  1128d4:	83 e0 0f             	and    $0xf,%eax
  1128d7:	c1 e0 02             	shl    $0x2,%eax
  1128da:	8d 04 03             	lea    (%ebx,%eax,1),%eax
  1128dd:	a3 04 99 13 00       	mov    %eax,0x139904

#if TCP_INPUT_DEBUG
  tcp_debug_print(tcphdr);
#endif

  /* remove header from payload */
  if (pbuf_header(p, -((s16_t)(IPH_HL(iphdr) * 4))) || (p->tot_len < sizeof(struct tcp_hdr))) {
  1128e2:	a1 08 99 13 00       	mov    0x139908,%eax
  1128e7:	0f b7 00             	movzwl (%eax),%eax
  1128ea:	0f b7 c0             	movzwl %ax,%eax
  1128ed:	89 04 24             	mov    %eax,(%esp)
  1128f0:	e8 ab b9 ff ff       	call   10e2a0 <ntohs>
  1128f5:	66 c1 e8 08          	shr    $0x8,%ax
  1128f9:	0f b7 c0             	movzwl %ax,%eax
  1128fc:	83 e0 0f             	and    $0xf,%eax
  1128ff:	c1 e0 02             	shl    $0x2,%eax
  112902:	f7 d8                	neg    %eax
  112904:	98                   	cwtl   
  112905:	89 44 24 04          	mov    %eax,0x4(%esp)
  112909:	8b 45 08             	mov    0x8(%ebp),%eax
  11290c:	89 04 24             	mov    %eax,(%esp)
  11290f:	e8 9c ca ff ff       	call   10f3b0 <pbuf_header>
  112914:	84 c0                	test   %al,%al
  112916:	75 0d                	jne    112925 <tcp_input+0xa5>
  112918:	8b 45 08             	mov    0x8(%ebp),%eax
  11291b:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  11291f:	66 83 f8 13          	cmp    $0x13,%ax
  112923:	77 30                	ja     112955 <tcp_input+0xd5>
    /* drop short packets */
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: short packet (%u bytes) discarded\n", p->tot_len));
    TCP_STATS_INC(tcp.lenerr);
  112925:	0f b7 05 6e 15 14 00 	movzwl 0x14156e,%eax
  11292c:	83 c0 01             	add    $0x1,%eax
  11292f:	66 a3 6e 15 14 00    	mov    %ax,0x14156e
    TCP_STATS_INC(tcp.drop);
  112935:	0f b7 05 6a 15 14 00 	movzwl 0x14156a,%eax
  11293c:	83 c0 01             	add    $0x1,%eax
  11293f:	66 a3 6a 15 14 00    	mov    %ax,0x14156a
    pbuf_free(p);
  112945:	8b 45 08             	mov    0x8(%ebp),%eax
  112948:	89 04 24             	mov    %eax,(%esp)
  11294b:	e8 60 cb ff ff       	call   10f4b0 <pbuf_free>
    return;
  112950:	e9 2c 07 00 00       	jmp    113081 <tcp_input+0x801>
  }

  /* Don't even process incoming broadcasts/multicasts. */
  if (ip_addr_isbroadcast(&(iphdr->dest), &(inp->netmask)) ||
  112955:	a1 08 99 13 00       	mov    0x139908,%eax
  11295a:	8b 50 10             	mov    0x10(%eax),%edx
  11295d:	8b 45 0c             	mov    0xc(%ebp),%eax
  112960:	8b 40 08             	mov    0x8(%eax),%eax
  112963:	f7 d0                	not    %eax
  112965:	21 c2                	and    %eax,%edx
  112967:	8b 45 0c             	mov    0xc(%ebp),%eax
  11296a:	8b 40 08             	mov    0x8(%eax),%eax
  11296d:	f7 d0                	not    %eax
  11296f:	39 c2                	cmp    %eax,%edx
  112971:	74 3f                	je     1129b2 <tcp_input+0x132>
  112973:	a1 08 99 13 00       	mov    0x139908,%eax
  112978:	8b 40 10             	mov    0x10(%eax),%eax
  11297b:	83 f8 ff             	cmp    $0xffffffff,%eax
  11297e:	74 32                	je     1129b2 <tcp_input+0x132>
  112980:	a1 08 99 13 00       	mov    0x139908,%eax
  112985:	8b 40 10             	mov    0x10(%eax),%eax
  112988:	85 c0                	test   %eax,%eax
  11298a:	74 26                	je     1129b2 <tcp_input+0x132>
  11298c:	a1 08 99 13 00       	mov    0x139908,%eax
  112991:	8b 58 10             	mov    0x10(%eax),%ebx
  112994:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  11299b:	e8 60 b9 ff ff       	call   10e300 <ntohl>
  1129a0:	21 c3                	and    %eax,%ebx
  1129a2:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  1129a9:	e8 52 b9 ff ff       	call   10e300 <ntohl>
  1129ae:	39 c3                	cmp    %eax,%ebx
  1129b0:	75 10                	jne    1129c2 <tcp_input+0x142>
     ip_addr_ismulticast(&(iphdr->dest))) {
    pbuf_free(p);
  1129b2:	8b 45 08             	mov    0x8(%ebp),%eax
  1129b5:	89 04 24             	mov    %eax,(%esp)
  1129b8:	e8 f3 ca ff ff       	call   10f4b0 <pbuf_free>
    return;
  1129bd:	e9 bf 06 00 00       	jmp    113081 <tcp_input+0x801>
  }

  /* Verify TCP checksum. */
  if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
  1129c2:	8b 45 08             	mov    0x8(%ebp),%eax
  1129c5:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  1129c9:	0f b7 d0             	movzwl %ax,%edx
  1129cc:	a1 08 99 13 00       	mov    0x139908,%eax
  1129d1:	8d 48 10             	lea    0x10(%eax),%ecx
  1129d4:	a1 08 99 13 00       	mov    0x139908,%eax
  1129d9:	83 c0 0c             	add    $0xc,%eax
  1129dc:	89 54 24 10          	mov    %edx,0x10(%esp)
  1129e0:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
  1129e7:	00 
  1129e8:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  1129ec:	89 44 24 04          	mov    %eax,0x4(%esp)
  1129f0:	8b 45 08             	mov    0x8(%ebp),%eax
  1129f3:	89 04 24             	mov    %eax,(%esp)
  1129f6:	e8 35 b2 ff ff       	call   10dc30 <inet_chksum_pseudo>
  1129fb:	66 85 c0             	test   %ax,%ax
  1129fe:	74 30                	je     112a30 <tcp_input+0x1b0>
      (struct ip_addr *)&(iphdr->dest),
      IP_PROTO_TCP, p->tot_len) != 0) {
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packet discarded due to failing checksum 0x%04x\n",
        inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src), (struct ip_addr *)&(iphdr->dest),
      IP_PROTO_TCP, p->tot_len)));
#if TCP_DEBUG
    tcp_debug_print(tcphdr);
#endif /* TCP_DEBUG */
    TCP_STATS_INC(tcp.chkerr);
  112a00:	0f b7 05 6c 15 14 00 	movzwl 0x14156c,%eax
  112a07:	83 c0 01             	add    $0x1,%eax
  112a0a:	66 a3 6c 15 14 00    	mov    %ax,0x14156c
    TCP_STATS_INC(tcp.drop);
  112a10:	0f b7 05 6a 15 14 00 	movzwl 0x14156a,%eax
  112a17:	83 c0 01             	add    $0x1,%eax
  112a1a:	66 a3 6a 15 14 00    	mov    %ax,0x14156a

    pbuf_free(p);
  112a20:	8b 45 08             	mov    0x8(%ebp),%eax
  112a23:	89 04 24             	mov    %eax,(%esp)
  112a26:	e8 85 ca ff ff       	call   10f4b0 <pbuf_free>
    return;
  112a2b:	e9 51 06 00 00       	jmp    113081 <tcp_input+0x801>
  }

  /* Move the payload pointer in the pbuf so that it points to the
     TCP data instead of the TCP header. */
  hdrlen = TCPH_HDRLEN(tcphdr);
  112a30:	a1 04 99 13 00       	mov    0x139904,%eax
  112a35:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  112a39:	0f b7 c0             	movzwl %ax,%eax
  112a3c:	89 04 24             	mov    %eax,(%esp)
  112a3f:	e8 5c b8 ff ff       	call   10e2a0 <ntohs>
  112a44:	66 c1 e8 0c          	shr    $0xc,%ax
  112a48:	88 45 e6             	mov    %al,0xffffffe6(%ebp)
  pbuf_header(p, -(hdrlen * 4));
  112a4b:	0f b6 45 e6          	movzbl 0xffffffe6(%ebp),%eax
  112a4f:	c1 e0 02             	shl    $0x2,%eax
  112a52:	f7 d8                	neg    %eax
  112a54:	98                   	cwtl   
  112a55:	89 44 24 04          	mov    %eax,0x4(%esp)
  112a59:	8b 45 08             	mov    0x8(%ebp),%eax
  112a5c:	89 04 24             	mov    %eax,(%esp)
  112a5f:	e8 4c c9 ff ff       	call   10f3b0 <pbuf_header>

  /* Convert fields in TCP header to host byte order. */
  tcphdr->src = ntohs(tcphdr->src);
  112a64:	8b 1d 04 99 13 00    	mov    0x139904,%ebx
  112a6a:	a1 04 99 13 00       	mov    0x139904,%eax
  112a6f:	0f b7 00             	movzwl (%eax),%eax
  112a72:	0f b7 c0             	movzwl %ax,%eax
  112a75:	89 04 24             	mov    %eax,(%esp)
  112a78:	e8 23 b8 ff ff       	call   10e2a0 <ntohs>
  112a7d:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = ntohs(tcphdr->dest);
  112a80:	8b 1d 04 99 13 00    	mov    0x139904,%ebx
  112a86:	a1 04 99 13 00       	mov    0x139904,%eax
  112a8b:	0f b7 40 02          	movzwl 0x2(%eax),%eax
  112a8f:	0f b7 c0             	movzwl %ax,%eax
  112a92:	89 04 24             	mov    %eax,(%esp)
  112a95:	e8 06 b8 ff ff       	call   10e2a0 <ntohs>
  112a9a:	66 89 43 02          	mov    %ax,0x2(%ebx)
  seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
  112a9e:	8b 1d 04 99 13 00    	mov    0x139904,%ebx
  112aa4:	a1 04 99 13 00       	mov    0x139904,%eax
  112aa9:	8b 40 04             	mov    0x4(%eax),%eax
  112aac:	89 04 24             	mov    %eax,(%esp)
  112aaf:	e8 4c b8 ff ff       	call   10e300 <ntohl>
  112ab4:	89 43 04             	mov    %eax,0x4(%ebx)
  112ab7:	8b 43 04             	mov    0x4(%ebx),%eax
  112aba:	a3 0c 99 13 00       	mov    %eax,0x13990c
  ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
  112abf:	8b 1d 04 99 13 00    	mov    0x139904,%ebx
  112ac5:	a1 04 99 13 00       	mov    0x139904,%eax
  112aca:	8b 40 08             	mov    0x8(%eax),%eax
  112acd:	89 04 24             	mov    %eax,(%esp)
  112ad0:	e8 2b b8 ff ff       	call   10e300 <ntohl>
  112ad5:	89 43 08             	mov    %eax,0x8(%ebx)
  112ad8:	8b 43 08             	mov    0x8(%ebx),%eax
  112adb:	a3 10 99 13 00       	mov    %eax,0x139910
  tcphdr->wnd = ntohs(tcphdr->wnd);
  112ae0:	8b 1d 04 99 13 00    	mov    0x139904,%ebx
  112ae6:	a1 04 99 13 00       	mov    0x139904,%eax
  112aeb:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
  112aef:	0f b7 c0             	movzwl %ax,%eax
  112af2:	89 04 24             	mov    %eax,(%esp)
  112af5:	e8 a6 b7 ff ff       	call   10e2a0 <ntohs>
  112afa:	66 89 43 0e          	mov    %ax,0xe(%ebx)

  flags = TCPH_FLAGS(tcphdr) & TCP_FLAGS;
  112afe:	a1 04 99 13 00       	mov    0x139904,%eax
  112b03:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  112b07:	0f b7 c0             	movzwl %ax,%eax
  112b0a:	89 04 24             	mov    %eax,(%esp)
  112b0d:	e8 8e b7 ff ff       	call   10e2a0 <ntohs>
  112b12:	83 e0 3f             	and    $0x3f,%eax
  112b15:	a2 14 99 13 00       	mov    %al,0x139914
  tcplen = p->tot_len + ((flags & TCP_FIN || flags & TCP_SYN)? 1: 0);
  112b1a:	8b 45 08             	mov    0x8(%ebp),%eax
  112b1d:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  112b21:	66 89 45 ce          	mov    %ax,0xffffffce(%ebp)
  112b25:	0f b6 05 14 99 13 00 	movzbl 0x139914,%eax
  112b2c:	0f b6 c0             	movzbl %al,%eax
  112b2f:	83 e0 01             	and    $0x1,%eax
  112b32:	84 c0                	test   %al,%al
  112b34:	75 11                	jne    112b47 <tcp_input+0x2c7>
  112b36:	0f b6 05 14 99 13 00 	movzbl 0x139914,%eax
  112b3d:	0f b6 c0             	movzbl %al,%eax
  112b40:	83 e0 02             	and    $0x2,%eax
  112b43:	85 c0                	test   %eax,%eax
  112b45:	74 09                	je     112b50 <tcp_input+0x2d0>
  112b47:	c7 45 d0 01 00 00 00 	movl   $0x1,0xffffffd0(%ebp)
  112b4e:	eb 07                	jmp    112b57 <tcp_input+0x2d7>
  112b50:	c7 45 d0 00 00 00 00 	movl   $0x0,0xffffffd0(%ebp)
  112b57:	0f b7 45 d0          	movzwl 0xffffffd0(%ebp),%eax
  112b5b:	66 03 45 ce          	add    0xffffffce(%ebp),%ax
  112b5f:	66 a3 16 99 13 00    	mov    %ax,0x139916

  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;
  112b65:	c7 45 dc 00 00 00 00 	movl   $0x0,0xffffffdc(%ebp)

#if SO_REUSE
  pcb_temp = tcp_active_pcbs;
  112b6c:	a1 54 16 14 00       	mov    0x141654,%eax
  112b71:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
  
 again_1:
  
  /* Iterate through the TCP pcb list for a fully matching pcb */
  for(pcb = pcb_temp; pcb != NULL; pcb = pcb->next) {
  112b74:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  112b77:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
  112b7a:	e9 d0 00 00 00       	jmp    112c4f <tcp_input+0x3cf>
#else  /* SO_REUSE */
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
#endif  /* SO_REUSE */
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
    if (pcb->remote_port == tcphdr->src &&
  112b7f:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  112b82:	0f b7 50 1e          	movzwl 0x1e(%eax),%edx
  112b86:	a1 04 99 13 00       	mov    0x139904,%eax
  112b8b:	0f b7 00             	movzwl (%eax),%eax
  112b8e:	66 39 c2             	cmp    %ax,%dx
  112b91:	0f 85 a9 00 00 00    	jne    112c40 <tcp_input+0x3c0>
  112b97:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  112b9a:	0f b7 50 1c          	movzwl 0x1c(%eax),%edx
  112b9e:	a1 04 99 13 00       	mov    0x139904,%eax
  112ba3:	0f b7 40 02          	movzwl 0x2(%eax),%eax
  112ba7:	66 39 c2             	cmp    %ax,%dx
  112baa:	0f 85 90 00 00 00    	jne    112c40 <tcp_input+0x3c0>
  112bb0:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  112bb3:	8b 50 04             	mov    0x4(%eax),%edx
  112bb6:	a1 08 99 13 00       	mov    0x139908,%eax
  112bbb:	8b 40 0c             	mov    0xc(%eax),%eax
  112bbe:	39 c2                	cmp    %eax,%edx
  112bc0:	75 7e                	jne    112c40 <tcp_input+0x3c0>
  112bc2:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  112bc5:	8b 10                	mov    (%eax),%edx
  112bc7:	a1 08 99 13 00       	mov    0x139908,%eax
  112bcc:	8b 40 10             	mov    0x10(%eax),%eax
  112bcf:	39 c2                	cmp    %eax,%edx
  112bd1:	75 6d                	jne    112c40 <tcp_input+0x3c0>
       pcb->local_port == tcphdr->dest &&
       ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
       ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest))) {

#if SO_REUSE
      if(pcb->so_options & SOF_REUSEPORT) {
  112bd3:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  112bd6:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  112bda:	0f b7 c0             	movzwl %ax,%eax
  112bdd:	25 00 02 00 00       	and    $0x200,%eax
  112be2:	85 c0                	test   %eax,%eax
  112be4:	74 32                	je     112c18 <tcp_input+0x398>
        if(reuse) {
  112be6:	83 7d ec 00          	cmpl   $0x0,0xffffffec(%ebp)
  112bea:	74 02                	je     112bee <tcp_input+0x36e>
  112bec:	eb 07                	jmp    112bf5 <tcp_input+0x375>
          /* We processed one PCB already */
          LWIP_DEBUGF(TCP_INPUT_DEBUG,("tcp_input: second or later PCB and SOF_REUSEPORT set.\n"));
        } else {
          /* First PCB with this address */
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: first PCB and SOF_REUSEPORT set.\n"));
          reuse = 1;
  112bee:	c7 45 ec 01 00 00 00 	movl   $0x1,0xffffffec(%ebp)
        }
        
        reuse_port = 1; 
  112bf5:	c7 45 f0 01 00 00 00 	movl   $0x1,0xfffffff0(%ebp)
        p->ref++;
  112bfc:	8b 45 08             	mov    0x8(%ebp),%eax
  112bff:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
  112c03:	8d 50 01             	lea    0x1(%eax),%edx
  112c06:	8b 45 08             	mov    0x8(%ebp),%eax
  112c09:	66 89 50 0e          	mov    %dx,0xe(%eax)
        
        /* We want to search on next socket after receiving */
        pcb_temp = pcb->next;
  112c0d:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  112c10:	8b 40 0c             	mov    0xc(%eax),%eax
  112c13:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
  112c16:	eb 00                	jmp    112c18 <tcp_input+0x398>
        
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: reference counter on PBUF set to %i\n", p->ref));
      } else  {
        if(reuse) {
          /* We processed one PCB already */
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: second or later PCB but SOF_REUSEPORT not set !\n"));
        }
      }
#endif /* SO_REUSE */

      /* Move this PCB to the front of the list so that subsequent
   lookups will be faster (we exploit locality in TCP segment
   arrivals). */
      LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
      if (prev != NULL) {
  112c18:	83 7d dc 00          	cmpl   $0x0,0xffffffdc(%ebp)
  112c1c:	74 3b                	je     112c59 <tcp_input+0x3d9>
  prev->next = pcb->next;
  112c1e:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  112c21:	8b 50 0c             	mov    0xc(%eax),%edx
  112c24:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  112c27:	89 50 0c             	mov    %edx,0xc(%eax)
  pcb->next = tcp_active_pcbs;
  112c2a:	8b 15 54 16 14 00    	mov    0x141654,%edx
  112c30:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  112c33:	89 50 0c             	mov    %edx,0xc(%eax)
  tcp_active_pcbs = pcb;
  112c36:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  112c39:	a3 54 16 14 00       	mov    %eax,0x141654
      }
      LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
      break;
  112c3e:	eb 19                	jmp    112c59 <tcp_input+0x3d9>
    }
    prev = pcb;
  112c40:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  112c43:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
  112c46:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  112c49:	8b 40 0c             	mov    0xc(%eax),%eax
  112c4c:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
  112c4f:	83 7d d8 00          	cmpl   $0x0,0xffffffd8(%ebp)
  112c53:	0f 85 26 ff ff ff    	jne    112b7f <tcp_input+0x2ff>
  }

  if (pcb == NULL) {
  112c59:	83 7d d8 00          	cmpl   $0x0,0xffffffd8(%ebp)
  112c5d:	0f 85 24 01 00 00    	jne    112d87 <tcp_input+0x507>
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */

    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  112c63:	a1 64 16 14 00       	mov    0x141664,%eax
  112c68:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
  112c6b:	eb 70                	jmp    112cdd <tcp_input+0x45d>
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
      if (pcb->remote_port == tcphdr->src &&
  112c6d:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  112c70:	0f b7 50 1e          	movzwl 0x1e(%eax),%edx
  112c74:	a1 04 99 13 00       	mov    0x139904,%eax
  112c79:	0f b7 00             	movzwl (%eax),%eax
  112c7c:	66 39 c2             	cmp    %ax,%dx
  112c7f:	75 53                	jne    112cd4 <tcp_input+0x454>
  112c81:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  112c84:	0f b7 50 1c          	movzwl 0x1c(%eax),%edx
  112c88:	a1 04 99 13 00       	mov    0x139904,%eax
  112c8d:	0f b7 40 02          	movzwl 0x2(%eax),%eax
  112c91:	66 39 c2             	cmp    %ax,%dx
  112c94:	75 3e                	jne    112cd4 <tcp_input+0x454>
  112c96:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  112c99:	8b 50 04             	mov    0x4(%eax),%edx
  112c9c:	a1 08 99 13 00       	mov    0x139908,%eax
  112ca1:	8b 40 0c             	mov    0xc(%eax),%eax
  112ca4:	39 c2                	cmp    %eax,%edx
  112ca6:	75 2c                	jne    112cd4 <tcp_input+0x454>
  112ca8:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  112cab:	8b 10                	mov    (%eax),%edx
  112cad:	a1 08 99 13 00       	mov    0x139908,%eax
  112cb2:	8b 40 10             	mov    0x10(%eax),%eax
  112cb5:	39 c2                	cmp    %eax,%edx
  112cb7:	75 1b                	jne    112cd4 <tcp_input+0x454>
   pcb->local_port == tcphdr->dest &&
   ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
         ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest))) {
  /* We don't really care enough to move this PCB to the front
     of the list since we are not very likely to receive that
     many segments for connections in TIME-WAIT. */
  LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for TIME_WAITing connection.\n"));
  tcp_timewait_input(pcb);
  112cb9:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  112cbc:	89 04 24             	mov    %eax,(%esp)
  112cbf:	e8 3c 06 00 00       	call   113300 <tcp_timewait_input>
  pbuf_free(p);
  112cc4:	8b 45 08             	mov    0x8(%ebp),%eax
  112cc7:	89 04 24             	mov    %eax,(%esp)
  112cca:	e8 e1 c7 ff ff       	call   10f4b0 <pbuf_free>
  return;
  112ccf:	e9 ad 03 00 00       	jmp    113081 <tcp_input+0x801>
  112cd4:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  112cd7:	8b 40 0c             	mov    0xc(%eax),%eax
  112cda:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
  112cdd:	83 7d d8 00          	cmpl   $0x0,0xffffffd8(%ebp)
  112ce1:	75 8a                	jne    112c6d <tcp_input+0x3ed>
      }
    }

  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
  112ce3:	c7 45 dc 00 00 00 00 	movl   $0x0,0xffffffdc(%ebp)
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  112cea:	a1 5c 16 14 00       	mov    0x14165c,%eax
  112cef:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
  112cf2:	e9 86 00 00 00       	jmp    112d7d <tcp_input+0x4fd>
      if ((ip_addr_isany(&(lpcb->local_ip)) ||
  112cf7:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  112cfa:	85 c0                	test   %eax,%eax
  112cfc:	74 1a                	je     112d18 <tcp_input+0x498>
  112cfe:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  112d01:	8b 00                	mov    (%eax),%eax
  112d03:	85 c0                	test   %eax,%eax
  112d05:	74 11                	je     112d18 <tcp_input+0x498>
  112d07:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  112d0a:	8b 10                	mov    (%eax),%edx
  112d0c:	a1 08 99 13 00       	mov    0x139908,%eax
  112d11:	8b 40 10             	mov    0x10(%eax),%eax
  112d14:	39 c2                	cmp    %eax,%edx
  112d16:	75 56                	jne    112d6e <tcp_input+0x4ee>
  112d18:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  112d1b:	0f b7 50 1c          	movzwl 0x1c(%eax),%edx
  112d1f:	a1 04 99 13 00       	mov    0x139904,%eax
  112d24:	0f b7 40 02          	movzwl 0x2(%eax),%eax
  112d28:	66 39 c2             	cmp    %ax,%dx
  112d2b:	75 41                	jne    112d6e <tcp_input+0x4ee>
    ip_addr_cmp(&(lpcb->local_ip), &(iphdr->dest))) &&
   lpcb->local_port == tcphdr->dest) {
  /* Move this PCB to the front of the list so that subsequent
     lookups will be faster (we exploit locality in TCP segment
     arrivals). */
  if (prev != NULL) {
  112d2d:	83 7d dc 00          	cmpl   $0x0,0xffffffdc(%ebp)
  112d31:	74 20                	je     112d53 <tcp_input+0x4d3>
    ((struct tcp_pcb_listen *)prev)->next = lpcb->next;
  112d33:	8b 55 dc             	mov    0xffffffdc(%ebp),%edx
  112d36:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  112d39:	8b 40 0c             	mov    0xc(%eax),%eax
  112d3c:	89 42 0c             	mov    %eax,0xc(%edx)
          /* our successor is the remainder of the listening list */
    lpcb->next = tcp_listen_pcbs.listen_pcbs;
  112d3f:	8b 15 5c 16 14 00    	mov    0x14165c,%edx
  112d45:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  112d48:	89 50 0c             	mov    %edx,0xc(%eax)
          /* put this listening pcb at the head of the listening list */
    tcp_listen_pcbs.listen_pcbs = lpcb;
  112d4b:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  112d4e:	a3 5c 16 14 00       	mov    %eax,0x14165c
  }

  LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for LISTENing connection.\n"));
  tcp_listen_input(lpcb);
  112d53:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  112d56:	89 04 24             	mov    %eax,(%esp)
  112d59:	e8 32 03 00 00       	call   113090 <tcp_listen_input>
  pbuf_free(p);
  112d5e:	8b 45 08             	mov    0x8(%ebp),%eax
  112d61:	89 04 24             	mov    %eax,(%esp)
  112d64:	e8 47 c7 ff ff       	call   10f4b0 <pbuf_free>
  return;
  112d69:	e9 13 03 00 00       	jmp    113081 <tcp_input+0x801>
      }
      prev = (struct tcp_pcb *)lpcb;
  112d6e:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  112d71:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
  112d74:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  112d77:	8b 40 0c             	mov    0xc(%eax),%eax
  112d7a:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
  112d7d:	83 7d e0 00          	cmpl   $0x0,0xffffffe0(%ebp)
  112d81:	0f 85 70 ff ff ff    	jne    112cf7 <tcp_input+0x477>
    }
  }

#if TCP_INPUT_DEBUG
  LWIP_DEBUGF(TCP_INPUT_DEBUG, ("+-+-+-+-+-+-+-+-+-+-+-+-+-+- tcp_input: flags "));
  tcp_debug_print_flags(TCPH_FLAGS(tcphdr));
  LWIP_DEBUGF(TCP_INPUT_DEBUG, ("-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"));
#endif /* TCP_INPUT_DEBUG */


  if (pcb != NULL) {
  112d87:	83 7d d8 00          	cmpl   $0x0,0xffffffd8(%ebp)
  112d8b:	0f 84 36 02 00 00    	je     112fc7 <tcp_input+0x747>
    /* The incoming segment belongs to a connection. */
#if TCP_INPUT_DEBUG
#if TCP_DEBUG
    tcp_debug_print_state(pcb->state);
#endif /* TCP_DEBUG */
#endif /* TCP_INPUT_DEBUG */

    /* Set up a tcp_seg structure. */
    inseg.next = NULL;
  112d91:	c7 05 f0 98 13 00 00 	movl   $0x0,0x1398f0
  112d98:	00 00 00 
    inseg.len = p->tot_len;
  112d9b:	8b 45 08             	mov    0x8(%ebp),%eax
  112d9e:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  112da2:	66 a3 fc 98 13 00    	mov    %ax,0x1398fc
    inseg.dataptr = p->payload;
  112da8:	8b 45 08             	mov    0x8(%ebp),%eax
  112dab:	8b 40 04             	mov    0x4(%eax),%eax
  112dae:	a3 f8 98 13 00       	mov    %eax,0x1398f8
    inseg.p = p;
  112db3:	8b 45 08             	mov    0x8(%ebp),%eax
  112db6:	a3 f4 98 13 00       	mov    %eax,0x1398f4
    inseg.tcphdr = tcphdr;
  112dbb:	a1 04 99 13 00       	mov    0x139904,%eax
  112dc0:	a3 00 99 13 00       	mov    %eax,0x139900

    recv_data = NULL;
  112dc5:	c7 05 1c 99 13 00 00 	movl   $0x0,0x13991c
  112dcc:	00 00 00 
    recv_flags = 0;
  112dcf:	c6 05 18 99 13 00 00 	movb   $0x0,0x139918

    tcp_input_pcb = pcb;
  112dd6:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  112dd9:	a3 68 16 14 00       	mov    %eax,0x141668
    err = tcp_process(pcb);
  112dde:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  112de1:	89 04 24             	mov    %eax,(%esp)
  112de4:	e8 97 05 00 00       	call   113380 <tcp_process>
  112de9:	88 45 e7             	mov    %al,0xffffffe7(%ebp)
    tcp_input_pcb = NULL;
  112dec:	c7 05 68 16 14 00 00 	movl   $0x0,0x141668
  112df3:	00 00 00 
    /* A return value of ERR_ABRT means that tcp_abort() was called
       and that the pcb has been freed. If so, we don't do anything. */
    if (err != ERR_ABRT) {
  112df6:	80 7d e7 fd          	cmpb   $0xfd,0xffffffe7(%ebp)
  112dfa:	0f 84 a4 01 00 00    	je     112fa4 <tcp_input+0x724>
      if (recv_flags & TF_RESET) {
  112e00:	0f b6 05 18 99 13 00 	movzbl 0x139918,%eax
  112e07:	0f b6 c0             	movzbl %al,%eax
  112e0a:	83 e0 08             	and    $0x8,%eax
  112e0d:	85 c0                	test   %eax,%eax
  112e0f:	74 54                	je     112e65 <tcp_input+0x5e5>
  /* TF_RESET means that the connection was reset by the other
     end. We then call the error callback to inform the
     application that the connection is dead before we
     deallocate the PCB. */
  TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_RST);
  112e11:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  112e14:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
  112e1a:	85 c0                	test   %eax,%eax
  112e1c:	74 1c                	je     112e3a <tcp_input+0x5ba>
  112e1e:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  112e21:	8b 90 90 00 00 00    	mov    0x90(%eax),%edx
  112e27:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  112e2a:	8b 40 18             	mov    0x18(%eax),%eax
  112e2d:	c7 44 24 04 fc ff ff 	movl   $0xfffffffc,0x4(%esp)
  112e34:	ff 
  112e35:	89 04 24             	mov    %eax,(%esp)
  112e38:	ff d2                	call   *%edx
  tcp_pcb_remove(&tcp_active_pcbs, pcb);
  112e3a:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  112e3d:	89 44 24 04          	mov    %eax,0x4(%esp)
  112e41:	c7 04 24 54 16 14 00 	movl   $0x141654,(%esp)
  112e48:	e8 93 e7 ff ff       	call   1115e0 <tcp_pcb_remove>
  memp_free(MEMP_TCP_PCB, pcb);
  112e4d:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  112e50:	89 44 24 04          	mov    %eax,0x4(%esp)
  112e54:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  112e5b:	e8 50 bc ff ff       	call   10eab0 <memp_free>
  112e60:	e9 3f 01 00 00       	jmp    112fa4 <tcp_input+0x724>
      } else if (recv_flags & TF_CLOSED) {
  112e65:	0f b6 05 18 99 13 00 	movzbl 0x139918,%eax
  112e6c:	0f b6 c0             	movzbl %al,%eax
  112e6f:	83 e0 10             	and    $0x10,%eax
  112e72:	85 c0                	test   %eax,%eax
  112e74:	74 2b                	je     112ea1 <tcp_input+0x621>
  /* The connection has been closed and we will deallocate the
     PCB. */
  tcp_pcb_remove(&tcp_active_pcbs, pcb);
  112e76:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  112e79:	89 44 24 04          	mov    %eax,0x4(%esp)
  112e7d:	c7 04 24 54 16 14 00 	movl   $0x141654,(%esp)
  112e84:	e8 57 e7 ff ff       	call   1115e0 <tcp_pcb_remove>
  memp_free(MEMP_TCP_PCB, pcb);
  112e89:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  112e8c:	89 44 24 04          	mov    %eax,0x4(%esp)
  112e90:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  112e97:	e8 14 bc ff ff       	call   10eab0 <memp_free>
  112e9c:	e9 03 01 00 00       	jmp    112fa4 <tcp_input+0x724>
      } else {
  err = ERR_OK;
  112ea1:	c6 45 e7 00          	movb   $0x0,0xffffffe7(%ebp)
  /* If the application has registered a "sent" function to be
     called when new send buffer space is available, we call it
     now. */
  if (pcb->acked > 0) {
  112ea5:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  112ea8:	0f b7 40 68          	movzwl 0x68(%eax),%eax
  112eac:	66 85 c0             	test   %ax,%ax
  112eaf:	74 33                	je     112ee4 <tcp_input+0x664>
    TCP_EVENT_SENT(pcb, pcb->acked, err);
  112eb1:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  112eb4:	8b 40 7c             	mov    0x7c(%eax),%eax
  112eb7:	85 c0                	test   %eax,%eax
  112eb9:	74 29                	je     112ee4 <tcp_input+0x664>
  112ebb:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  112ebe:	8b 58 7c             	mov    0x7c(%eax),%ebx
  112ec1:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  112ec4:	0f b7 40 68          	movzwl 0x68(%eax),%eax
  112ec8:	0f b7 d0             	movzwl %ax,%edx
  112ecb:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  112ece:	8b 48 18             	mov    0x18(%eax),%ecx
  112ed1:	89 54 24 08          	mov    %edx,0x8(%esp)
  112ed5:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  112ed8:	89 44 24 04          	mov    %eax,0x4(%esp)
  112edc:	89 0c 24             	mov    %ecx,(%esp)
  112edf:	ff d3                	call   *%ebx
  112ee1:	88 45 e7             	mov    %al,0xffffffe7(%ebp)
  }

  if (recv_data != NULL) {
  112ee4:	a1 1c 99 13 00       	mov    0x13991c,%eax
  112ee9:	85 c0                	test   %eax,%eax
  112eeb:	74 4c                	je     112f39 <tcp_input+0x6b9>
    /* Notify application that data has been received. */
    TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
  112eed:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  112ef0:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
  112ef6:	85 c0                	test   %eax,%eax
  112ef8:	74 32                	je     112f2c <tcp_input+0x6ac>
  112efa:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  112efd:	8b 98 80 00 00 00    	mov    0x80(%eax),%ebx
  112f03:	8b 15 1c 99 13 00    	mov    0x13991c,%edx
  112f09:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  112f0c:	8b 48 18             	mov    0x18(%eax),%ecx
  112f0f:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  112f16:	00 
  112f17:	89 54 24 08          	mov    %edx,0x8(%esp)
  112f1b:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  112f1e:	89 44 24 04          	mov    %eax,0x4(%esp)
  112f22:	89 0c 24             	mov    %ecx,(%esp)
  112f25:	ff d3                	call   *%ebx
  112f27:	88 45 e7             	mov    %al,0xffffffe7(%ebp)
  112f2a:	eb 0d                	jmp    112f39 <tcp_input+0x6b9>
  112f2c:	a1 1c 99 13 00       	mov    0x13991c,%eax
  112f31:	89 04 24             	mov    %eax,(%esp)
  112f34:	e8 77 c5 ff ff       	call   10f4b0 <pbuf_free>
  }

  /* If a FIN segment was received, we call the callback
     function with a NULL buffer to indicate EOF. */
  if (recv_flags & TF_GOT_FIN) {
  112f39:	0f b6 05 18 99 13 00 	movzbl 0x139918,%eax
  112f40:	0f b6 c0             	movzbl %al,%eax
  112f43:	83 e0 20             	and    $0x20,%eax
  112f46:	85 c0                	test   %eax,%eax
  112f48:	74 49                	je     112f93 <tcp_input+0x713>
    TCP_EVENT_RECV(pcb, NULL, ERR_OK, err);
  112f4a:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  112f4d:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
  112f53:	85 c0                	test   %eax,%eax
  112f55:	74 30                	je     112f87 <tcp_input+0x707>
  112f57:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  112f5a:	8b 88 80 00 00 00    	mov    0x80(%eax),%ecx
  112f60:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  112f63:	8b 50 18             	mov    0x18(%eax),%edx
  112f66:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  112f6d:	00 
  112f6e:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  112f75:	00 
  112f76:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  112f79:	89 44 24 04          	mov    %eax,0x4(%esp)
  112f7d:	89 14 24             	mov    %edx,(%esp)
  112f80:	ff d1                	call   *%ecx
  112f82:	88 45 e7             	mov    %al,0xffffffe7(%ebp)
  112f85:	eb 0c                	jmp    112f93 <tcp_input+0x713>
  112f87:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  112f8e:	e8 1d c5 ff ff       	call   10f4b0 <pbuf_free>
  }
  /* If there were no errors, we try to send something out. */
  if (err == ERR_OK) {
  112f93:	80 7d e7 00          	cmpb   $0x0,0xffffffe7(%ebp)
  112f97:	75 0b                	jne    112fa4 <tcp_input+0x724>
    tcp_output(pcb);
  112f99:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  112f9c:	89 04 24             	mov    %eax,(%esp)
  112f9f:	e8 9c ee ff ff       	call   111e40 <tcp_output>
  }
      }
    }


    /* We deallocate the incoming pbuf. If it was buffered by the
       application, the application should have called pbuf_ref() to
       increase the reference counter in the pbuf. If so, the buffer
       isn't actually deallocated by the call to pbuf_free(), only the
       reference count is decreased. */
    pbuf_free(inseg.p);
  112fa4:	a1 f4 98 13 00       	mov    0x1398f4,%eax
  112fa9:	89 04 24             	mov    %eax,(%esp)
  112fac:	e8 ff c4 ff ff       	call   10f4b0 <pbuf_free>
#if TCP_INPUT_DEBUG
#if TCP_DEBUG
    tcp_debug_print_state(pcb->state);
#endif /* TCP_DEBUG */
#endif /* TCP_INPUT_DEBUG */
#if SO_REUSE
    /* First socket should receive now */
    if(reuse_port) {
  112fb1:	83 7d f0 00          	cmpl   $0x0,0xfffffff0(%ebp)
  112fb5:	0f 84 c6 00 00 00    	je     113081 <tcp_input+0x801>
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: searching next PCB.\n"));
      reuse_port = 0;
  112fbb:	c7 45 f0 00 00 00 00 	movl   $0x0,0xfffffff0(%ebp)
      
      /* We are searching connected sockets */
      goto again_1;
  112fc2:	e9 ad fb ff ff       	jmp    112b74 <tcp_input+0x2f4>
    }
#endif /* SO_REUSE */

  } else {
#if SO_REUSE
    if(reuse) {
  112fc7:	83 7d ec 00          	cmpl   $0x0,0xffffffec(%ebp)
  112fcb:	74 10                	je     112fdd <tcp_input+0x75d>
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: freeing PBUF with reference counter set to %i\n", p->ref));
      pbuf_free(p);
  112fcd:	8b 45 08             	mov    0x8(%ebp),%eax
  112fd0:	89 04 24             	mov    %eax,(%esp)
  112fd3:	e8 d8 c4 ff ff       	call   10f4b0 <pbuf_free>
      goto end;
  112fd8:	e9 a4 00 00 00       	jmp    113081 <tcp_input+0x801>
    }
#endif /* SO_REUSE */
    /* If no matching PCB was found, send a TCP RST (reset) to the
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
  112fdd:	a1 04 99 13 00       	mov    0x139904,%eax
  112fe2:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  112fe6:	0f b7 c0             	movzwl %ax,%eax
  112fe9:	89 04 24             	mov    %eax,(%esp)
  112fec:	e8 af b2 ff ff       	call   10e2a0 <ntohs>
  112ff1:	0f b7 c0             	movzwl %ax,%eax
  112ff4:	83 e0 04             	and    $0x4,%eax
  112ff7:	85 c0                	test   %eax,%eax
  112ff9:	75 7b                	jne    113076 <tcp_input+0x7f6>
      TCP_STATS_INC(tcp.proterr);
  112ffb:	0f b7 05 74 15 14 00 	movzwl 0x141574,%eax
  113002:	83 c0 01             	add    $0x1,%eax
  113005:	66 a3 74 15 14 00    	mov    %ax,0x141574
      TCP_STATS_INC(tcp.drop);
  11300b:	0f b7 05 6a 15 14 00 	movzwl 0x14156a,%eax
  113012:	83 c0 01             	add    $0x1,%eax
  113015:	66 a3 6a 15 14 00    	mov    %ax,0x14156a
      tcp_rst(ackno, seqno + tcplen,
  11301b:	a1 04 99 13 00       	mov    0x139904,%eax
  113020:	0f b7 00             	movzwl (%eax),%eax
  113023:	0f b7 f0             	movzwl %ax,%esi
  113026:	a1 04 99 13 00       	mov    0x139904,%eax
  11302b:	0f b7 40 02          	movzwl 0x2(%eax),%eax
  11302f:	0f b7 f8             	movzwl %ax,%edi
  113032:	a1 08 99 13 00       	mov    0x139908,%eax
  113037:	8d 48 0c             	lea    0xc(%eax),%ecx
  11303a:	a1 08 99 13 00       	mov    0x139908,%eax
  11303f:	8d 58 10             	lea    0x10(%eax),%ebx
  113042:	0f b7 05 16 99 13 00 	movzwl 0x139916,%eax
  113049:	0f b7 d0             	movzwl %ax,%edx
  11304c:	a1 0c 99 13 00       	mov    0x13990c,%eax
  113051:	8d 04 02             	lea    (%edx,%eax,1),%eax
  113054:	8b 15 10 99 13 00    	mov    0x139910,%edx
  11305a:	89 74 24 14          	mov    %esi,0x14(%esp)
  11305e:	89 7c 24 10          	mov    %edi,0x10(%esp)
  113062:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
  113066:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  11306a:	89 44 24 04          	mov    %eax,0x4(%esp)
  11306e:	89 14 24             	mov    %edx,(%esp)
  113071:	e8 4a f4 ff ff       	call   1124c0 <tcp_rst>
        &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
    }
    pbuf_free(p);
  113076:	8b 45 08             	mov    0x8(%ebp),%eax
  113079:	89 04 24             	mov    %eax,(%esp)
  11307c:	e8 2f c4 ff ff       	call   10f4b0 <pbuf_free>
  }
#if SO_REUSE
 end:
#endif /* SO_REUSE */
  LWIP_ASSERT("tcp_input: tcp_pcbs_sane()", tcp_pcbs_sane());
  PERF_STOP("tcp_input");
}
  113081:	83 c4 4c             	add    $0x4c,%esp
  113084:	5b                   	pop    %ebx
  113085:	5e                   	pop    %esi
  113086:	5f                   	pop    %edi
  113087:	5d                   	pop    %ebp
  113088:	c3                   	ret    
  113089:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

00113090 <tcp_listen_input>:

/* tcp_listen_input():
 *
 * Called by tcp_input() when a segment arrives for a listening
 * connection.
 */

static err_t
tcp_listen_input(struct tcp_pcb_listen *pcb)
{
  113090:	55                   	push   %ebp
  113091:	89 e5                	mov    %esp,%ebp
  113093:	57                   	push   %edi
  113094:	56                   	push   %esi
  113095:	53                   	push   %ebx
  113096:	83 ec 3c             	sub    $0x3c,%esp
  struct tcp_pcb *npcb;
  u32_t optdata;

  /* In the LISTEN state, we check for incoming SYN segments,
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
  113099:	0f b6 05 14 99 13 00 	movzbl 0x139914,%eax
  1130a0:	0f b6 c0             	movzbl %al,%eax
  1130a3:	83 e0 10             	and    $0x10,%eax
  1130a6:	85 c0                	test   %eax,%eax
  1130a8:	74 61                	je     11310b <tcp_listen_input+0x7b>
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno + 1, seqno + tcplen,
  1130aa:	a1 04 99 13 00       	mov    0x139904,%eax
  1130af:	0f b7 00             	movzwl (%eax),%eax
  1130b2:	0f b7 d8             	movzwl %ax,%ebx
  1130b5:	a1 04 99 13 00       	mov    0x139904,%eax
  1130ba:	0f b7 40 02          	movzwl 0x2(%eax),%eax
  1130be:	0f b7 f0             	movzwl %ax,%esi
  1130c1:	a1 08 99 13 00       	mov    0x139908,%eax
  1130c6:	8d 78 0c             	lea    0xc(%eax),%edi
  1130c9:	a1 08 99 13 00       	mov    0x139908,%eax
  1130ce:	8d 48 10             	lea    0x10(%eax),%ecx
  1130d1:	0f b7 05 16 99 13 00 	movzwl 0x139916,%eax
  1130d8:	0f b7 d0             	movzwl %ax,%edx
  1130db:	a1 0c 99 13 00       	mov    0x13990c,%eax
  1130e0:	01 c2                	add    %eax,%edx
  1130e2:	a1 10 99 13 00       	mov    0x139910,%eax
  1130e7:	83 c0 01             	add    $0x1,%eax
  1130ea:	89 5c 24 14          	mov    %ebx,0x14(%esp)
  1130ee:	89 74 24 10          	mov    %esi,0x10(%esp)
  1130f2:	89 7c 24 0c          	mov    %edi,0xc(%esp)
  1130f6:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  1130fa:	89 54 24 04          	mov    %edx,0x4(%esp)
  1130fe:	89 04 24             	mov    %eax,(%esp)
  113101:	e8 ba f3 ff ff       	call   1124c0 <tcp_rst>
  113106:	e9 d6 01 00 00       	jmp    1132e1 <tcp_listen_input+0x251>
      &(iphdr->dest), &(iphdr->src),
      tcphdr->dest, tcphdr->src);
  } else if (flags & TCP_SYN) {
  11310b:	0f b6 05 14 99 13 00 	movzbl 0x139914,%eax
  113112:	0f b6 c0             	movzbl %al,%eax
  113115:	83 e0 02             	and    $0x2,%eax
  113118:	85 c0                	test   %eax,%eax
  11311a:	0f 84 c1 01 00 00    	je     1132e1 <tcp_listen_input+0x251>
    LWIP_DEBUGF(TCP_DEBUG, ("TCP connection request %u -> %u.\n", tcphdr->src, tcphdr->dest));
    npcb = tcp_alloc(pcb->prio);
  113120:	8b 45 08             	mov    0x8(%ebp),%eax
  113123:	0f b6 40 14          	movzbl 0x14(%eax),%eax
  113127:	0f b6 c0             	movzbl %al,%eax
  11312a:	89 04 24             	mov    %eax,(%esp)
  11312d:	e8 1e e2 ff ff       	call   111350 <tcp_alloc>
  113132:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
    /* If a new PCB could not be created (probably due to lack of memory),
       we don't do anything, but rely on the sender will retransmit the
       SYN at a time when we have more memory available. */
    if (npcb == NULL) {
  113135:	83 7d f0 00          	cmpl   $0x0,0xfffffff0(%ebp)
  113139:	75 1c                	jne    113157 <tcp_listen_input+0xc7>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_listen_input: could not allocate PCB\n"));
      TCP_STATS_INC(tcp.memerr);
  11313b:	0f b7 05 70 15 14 00 	movzwl 0x141570,%eax
  113142:	83 c0 01             	add    $0x1,%eax
  113145:	66 a3 70 15 14 00    	mov    %ax,0x141570
      return ERR_MEM;
  11314b:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,0xffffffd8(%ebp)
  113152:	e9 91 01 00 00       	jmp    1132e8 <tcp_listen_input+0x258>
    }
    /* Set up the new PCB. */
    ip_addr_set(&(npcb->local_ip), &(iphdr->dest));
  113157:	a1 08 99 13 00       	mov    0x139908,%eax
  11315c:	83 c0 10             	add    $0x10,%eax
  11315f:	85 c0                	test   %eax,%eax
  113161:	74 0d                	je     113170 <tcp_listen_input+0xe0>
  113163:	a1 08 99 13 00       	mov    0x139908,%eax
  113168:	8b 40 10             	mov    0x10(%eax),%eax
  11316b:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
  11316e:	eb 07                	jmp    113177 <tcp_listen_input+0xe7>
  113170:	c7 45 dc 00 00 00 00 	movl   $0x0,0xffffffdc(%ebp)
  113177:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  11317a:	8b 55 dc             	mov    0xffffffdc(%ebp),%edx
  11317d:	89 10                	mov    %edx,(%eax)
    npcb->local_port = pcb->local_port;
  11317f:	8b 45 08             	mov    0x8(%ebp),%eax
  113182:	0f b7 50 1c          	movzwl 0x1c(%eax),%edx
  113186:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  113189:	66 89 50 1c          	mov    %dx,0x1c(%eax)
    ip_addr_set(&(npcb->remote_ip), &(iphdr->src));
  11318d:	a1 08 99 13 00       	mov    0x139908,%eax
  113192:	83 c0 0c             	add    $0xc,%eax
  113195:	85 c0                	test   %eax,%eax
  113197:	74 0d                	je     1131a6 <tcp_listen_input+0x116>
  113199:	a1 08 99 13 00       	mov    0x139908,%eax
  11319e:	8b 40 0c             	mov    0xc(%eax),%eax
  1131a1:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
  1131a4:	eb 07                	jmp    1131ad <tcp_listen_input+0x11d>
  1131a6:	c7 45 e0 00 00 00 00 	movl   $0x0,0xffffffe0(%ebp)
  1131ad:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  1131b0:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
  1131b3:	89 50 04             	mov    %edx,0x4(%eax)
    npcb->remote_port = tcphdr->src;
  1131b6:	a1 04 99 13 00       	mov    0x139904,%eax
  1131bb:	0f b7 10             	movzwl (%eax),%edx
  1131be:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  1131c1:	66 89 50 1e          	mov    %dx,0x1e(%eax)
    npcb->state = SYN_RCVD;
  1131c5:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  1131c8:	c7 40 10 03 00 00 00 	movl   $0x3,0x10(%eax)
    npcb->rcv_nxt = seqno + 1;
  1131cf:	a1 0c 99 13 00       	mov    0x13990c,%eax
  1131d4:	8d 50 01             	lea    0x1(%eax),%edx
  1131d7:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  1131da:	89 50 24             	mov    %edx,0x24(%eax)
    npcb->snd_wnd = tcphdr->wnd;
  1131dd:	a1 04 99 13 00       	mov    0x139904,%eax
  1131e2:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
  1131e6:	0f b7 d0             	movzwl %ax,%edx
  1131e9:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  1131ec:	89 50 58             	mov    %edx,0x58(%eax)
    npcb->ssthresh = npcb->snd_wnd;
  1131ef:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  1131f2:	8b 40 58             	mov    0x58(%eax),%eax
  1131f5:	89 c2                	mov    %eax,%edx
  1131f7:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  1131fa:	66 89 50 4c          	mov    %dx,0x4c(%eax)
    npcb->snd_wl1 = seqno - 1;/* initialise to seqno-1 to force window update */
  1131fe:	a1 0c 99 13 00       	mov    0x13990c,%eax
  113203:	8d 50 ff             	lea    0xffffffff(%eax),%edx
  113206:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  113209:	89 50 5c             	mov    %edx,0x5c(%eax)
    npcb->callback_arg = pcb->callback_arg;
  11320c:	8b 45 08             	mov    0x8(%ebp),%eax
  11320f:	8b 50 18             	mov    0x18(%eax),%edx
  113212:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  113215:	89 50 18             	mov    %edx,0x18(%eax)
#if LWIP_CALLBACK_API
    npcb->accept = pcb->accept;
  113218:	8b 45 08             	mov    0x8(%ebp),%eax
  11321b:	8b 50 20             	mov    0x20(%eax),%edx
  11321e:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  113221:	89 90 88 00 00 00    	mov    %edx,0x88(%eax)
#endif /* LWIP_CALLBACK_API */
    /* inherit socket options */
    npcb->so_options = pcb->so_options & (SOF_DEBUG|SOF_DONTROUTE|SOF_KEEPALIVE|SOF_OOBINLINE|SOF_LINGER);
  113227:	8b 45 08             	mov    0x8(%ebp),%eax
  11322a:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  11322e:	89 c2                	mov    %eax,%edx
  113230:	66 81 e2 99 01       	and    $0x199,%dx
  113235:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  113238:	66 89 50 08          	mov    %dx,0x8(%eax)
    /* Register the new PCB so that we can begin receiving segments
       for it. */
    TCP_REG(&tcp_active_pcbs, npcb);
  11323c:	8b 15 54 16 14 00    	mov    0x141654,%edx
  113242:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  113245:	89 50 0c             	mov    %edx,0xc(%eax)
  113248:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  11324b:	a3 54 16 14 00       	mov    %eax,0x141654
  113250:	e8 6b 68 00 00       	call   119ac0 <tcp_timer_needed>

    /* Parse any options in the SYN. */
    tcp_parseopt(npcb);
  113255:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  113258:	89 04 24             	mov    %eax,(%esp)
  11325b:	e8 40 18 00 00       	call   114aa0 <tcp_parseopt>

    /* Build an MSS option. */
    optdata = htonl(((u32_t)2 << 24) |
  113260:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  113263:	0f b7 40 34          	movzwl 0x34(%eax),%eax
  113267:	66 c1 e8 08          	shr    $0x8,%ax
  11326b:	0f b7 c0             	movzwl %ax,%eax
  11326e:	89 c2                	mov    %eax,%edx
  113270:	c1 e2 08             	shl    $0x8,%edx
  113273:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  113276:	0f b7 40 34          	movzwl 0x34(%eax),%eax
  11327a:	0f b7 c0             	movzwl %ax,%eax
  11327d:	25 ff 00 00 00       	and    $0xff,%eax
  113282:	09 d0                	or     %edx,%eax
  113284:	0d 00 00 04 02       	or     $0x2040000,%eax
  113289:	89 04 24             	mov    %eax,(%esp)
  11328c:	e8 2f b0 ff ff       	call   10e2c0 <htonl>
  113291:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
        ((u32_t)4 << 16) |
        (((u32_t)npcb->mss / 256) << 8) |
        (npcb->mss & 255));
    /* Send a SYN|ACK together with the MSS option. */
    tcp_enqueue(npcb, NULL, 0, TCP_SYN | TCP_ACK, 0, (u8_t *)&optdata, 4);
  113294:	8d 45 ec             	lea    0xffffffec(%ebp),%eax
  113297:	c7 44 24 18 04 00 00 	movl   $0x4,0x18(%esp)
  11329e:	00 
  11329f:	89 44 24 14          	mov    %eax,0x14(%esp)
  1132a3:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  1132aa:	00 
  1132ab:	c7 44 24 0c 12 00 00 	movl   $0x12,0xc(%esp)
  1132b2:	00 
  1132b3:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  1132ba:	00 
  1132bb:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  1132c2:	00 
  1132c3:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  1132c6:	89 04 24             	mov    %eax,(%esp)
  1132c9:	e8 f2 e4 ff ff       	call   1117c0 <tcp_enqueue>
    return tcp_output(npcb);
  1132ce:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  1132d1:	89 04 24             	mov    %eax,(%esp)
  1132d4:	e8 67 eb ff ff       	call   111e40 <tcp_output>
  1132d9:	0f be c0             	movsbl %al,%eax
  1132dc:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
  1132df:	eb 07                	jmp    1132e8 <tcp_listen_input+0x258>
  }
  return ERR_OK;
  1132e1:	c7 45 d8 00 00 00 00 	movl   $0x0,0xffffffd8(%ebp)
  1132e8:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
}
  1132eb:	83 c4 3c             	add    $0x3c,%esp
  1132ee:	5b                   	pop    %ebx
  1132ef:	5e                   	pop    %esi
  1132f0:	5f                   	pop    %edi
  1132f1:	5d                   	pop    %ebp
  1132f2:	c3                   	ret    
  1132f3:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  1132f9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00113300 <tcp_timewait_input>:

/* tcp_timewait_input():
 *
 * Called by tcp_input() when a segment arrives for a connection in
 * TIME_WAIT.
 */

static err_t
tcp_timewait_input(struct tcp_pcb *pcb)
{
  113300:	55                   	push   %ebp
  113301:	89 e5                	mov    %esp,%ebp
  113303:	83 ec 08             	sub    $0x8,%esp
  if (TCP_SEQ_GT(seqno + tcplen, pcb->rcv_nxt)) {
  113306:	a1 0c 99 13 00       	mov    0x13990c,%eax
  11330b:	89 c2                	mov    %eax,%edx
  11330d:	0f b7 05 16 99 13 00 	movzwl 0x139916,%eax
  113314:	01 c2                	add    %eax,%edx
  113316:	8b 45 08             	mov    0x8(%ebp),%eax
  113319:	8b 40 24             	mov    0x24(%eax),%eax
  11331c:	89 d1                	mov    %edx,%ecx
  11331e:	66 29 c1             	sub    %ax,%cx
  113321:	89 c8                	mov    %ecx,%eax
  113323:	66 85 c0             	test   %ax,%ax
  113326:	7e 17                	jle    11333f <tcp_timewait_input+0x3f>
    pcb->rcv_nxt = seqno + tcplen;
  113328:	0f b7 05 16 99 13 00 	movzwl 0x139916,%eax
  11332f:	0f b7 d0             	movzwl %ax,%edx
  113332:	a1 0c 99 13 00       	mov    0x13990c,%eax
  113337:	01 c2                	add    %eax,%edx
  113339:	8b 45 08             	mov    0x8(%ebp),%eax
  11333c:	89 50 24             	mov    %edx,0x24(%eax)
  }
  if (tcplen > 0) {
  11333f:	0f b7 05 16 99 13 00 	movzwl 0x139916,%eax
  113346:	66 85 c0             	test   %ax,%ax
  113349:	74 1d                	je     113368 <tcp_timewait_input+0x68>
    tcp_ack_now(pcb);
  11334b:	8b 45 08             	mov    0x8(%ebp),%eax
  11334e:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  113352:	89 c2                	mov    %eax,%edx
  113354:	83 ca 02             	or     $0x2,%edx
  113357:	8b 45 08             	mov    0x8(%ebp),%eax
  11335a:	88 50 20             	mov    %dl,0x20(%eax)
  11335d:	8b 45 08             	mov    0x8(%ebp),%eax
  113360:	89 04 24             	mov    %eax,(%esp)
  113363:	e8 d8 ea ff ff       	call   111e40 <tcp_output>
  }
  return tcp_output(pcb);
  113368:	8b 45 08             	mov    0x8(%ebp),%eax
  11336b:	89 04 24             	mov    %eax,(%esp)
  11336e:	e8 cd ea ff ff       	call   111e40 <tcp_output>
  113373:	0f be c0             	movsbl %al,%eax
}
  113376:	c9                   	leave  
  113377:	c3                   	ret    
  113378:	90                   	nop    
  113379:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

00113380 <tcp_process>:

/* tcp_process
 *
 * Implements the TCP state machine. Called by tcp_input. In some
 * states tcp_receive() is called to receive data. The tcp_seg
 * argument will be freed by the caller (tcp_input()) unless the
 * recv_data pointer in the pcb is set.
 */

static err_t
tcp_process(struct tcp_pcb *pcb)
{
  113380:	55                   	push   %ebp
  113381:	89 e5                	mov    %esp,%ebp
  113383:	83 ec 28             	sub    $0x28,%esp
  struct tcp_seg *rseg;
  u8_t acceptable = 0;
  113386:	c6 45 fe 00          	movb   $0x0,0xfffffffe(%ebp)
  err_t err;


  err = ERR_OK;
  11338a:	c6 45 ff 00          	movb   $0x0,0xffffffff(%ebp)

  /* Process incoming RST segments. */
  if (flags & TCP_RST) {
  11338e:	0f b6 05 14 99 13 00 	movzbl 0x139914,%eax
  113395:	0f b6 c0             	movzbl %al,%eax
  113398:	83 e0 04             	and    $0x4,%eax
  11339b:	85 c0                	test   %eax,%eax
  11339d:	0f 84 99 00 00 00    	je     11343c <tcp_process+0xbc>
    /* First, determine if the reset is acceptable. */
    if (pcb->state == SYN_SENT) {
  1133a3:	8b 45 08             	mov    0x8(%ebp),%eax
  1133a6:	8b 40 10             	mov    0x10(%eax),%eax
  1133a9:	83 f8 02             	cmp    $0x2,%eax
  1133ac:	75 15                	jne    1133c3 <tcp_process+0x43>
      if (ackno == pcb->snd_nxt) {
  1133ae:	8b 45 08             	mov    0x8(%ebp),%eax
  1133b1:	8b 50 50             	mov    0x50(%eax),%edx
  1133b4:	a1 10 99 13 00       	mov    0x139910,%eax
  1133b9:	39 c2                	cmp    %eax,%edx
  1133bb:	75 48                	jne    113405 <tcp_process+0x85>
  acceptable = 1;
  1133bd:	c6 45 fe 01          	movb   $0x1,0xfffffffe(%ebp)
  1133c1:	eb 42                	jmp    113405 <tcp_process+0x85>
      }
    } else {
      if (TCP_SEQ_GEQ(seqno, pcb->rcv_nxt) &&
  1133c3:	a1 0c 99 13 00       	mov    0x13990c,%eax
  1133c8:	89 c2                	mov    %eax,%edx
  1133ca:	8b 45 08             	mov    0x8(%ebp),%eax
  1133cd:	8b 40 24             	mov    0x24(%eax),%eax
  1133d0:	89 d1                	mov    %edx,%ecx
  1133d2:	66 29 c1             	sub    %ax,%cx
  1133d5:	89 c8                	mov    %ecx,%eax
  1133d7:	66 85 c0             	test   %ax,%ax
  1133da:	78 29                	js     113405 <tcp_process+0x85>
  1133dc:	a1 0c 99 13 00       	mov    0x13990c,%eax
  1133e1:	89 c1                	mov    %eax,%ecx
  1133e3:	8b 45 08             	mov    0x8(%ebp),%eax
  1133e6:	8b 40 24             	mov    0x24(%eax),%eax
  1133e9:	89 c2                	mov    %eax,%edx
  1133eb:	8b 45 08             	mov    0x8(%ebp),%eax
  1133ee:	0f b7 40 28          	movzwl 0x28(%eax),%eax
  1133f2:	8d 04 02             	lea    (%edx,%eax,1),%eax
  1133f5:	89 ca                	mov    %ecx,%edx
  1133f7:	66 29 c2             	sub    %ax,%dx
  1133fa:	89 d0                	mov    %edx,%eax
  1133fc:	66 85 c0             	test   %ax,%ax
  1133ff:	7f 04                	jg     113405 <tcp_process+0x85>
   TCP_SEQ_LEQ(seqno, pcb->rcv_nxt + pcb->rcv_wnd)) {
  acceptable = 1;
  113401:	c6 45 fe 01          	movb   $0x1,0xfffffffe(%ebp)
      }
    }

    if (acceptable) {
  113405:	80 7d fe 00          	cmpb   $0x0,0xfffffffe(%ebp)
  113409:	74 25                	je     113430 <tcp_process+0xb0>
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: Connection RESET\n"));
      LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
      recv_flags = TF_RESET;
  11340b:	c6 05 18 99 13 00 08 	movb   $0x8,0x139918
      pcb->flags &= ~TF_ACK_DELAY;
  113412:	8b 45 08             	mov    0x8(%ebp),%eax
  113415:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  113419:	89 c2                	mov    %eax,%edx
  11341b:	83 e2 fe             	and    $0xfffffffe,%edx
  11341e:	8b 45 08             	mov    0x8(%ebp),%eax
  113421:	88 50 20             	mov    %dl,0x20(%eax)
      return ERR_RST;
  113424:	c7 45 e8 fc ff ff ff 	movl   $0xfffffffc,0xffffffe8(%ebp)
  11342b:	e9 4a 06 00 00       	jmp    113a7a <tcp_process+0x6fa>
    } else {
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: unacceptable reset seqno %lu rcv_nxt %lu\n",
       seqno, pcb->rcv_nxt));
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_process: unacceptable reset seqno %lu rcv_nxt %lu\n",
       seqno, pcb->rcv_nxt));
      return ERR_OK;
  113430:	c7 45 e8 00 00 00 00 	movl   $0x0,0xffffffe8(%ebp)
  113437:	e9 3e 06 00 00       	jmp    113a7a <tcp_process+0x6fa>
    }
  }

  /* Update the PCB (in)activity timer. */
  pcb->tmr = tcp_ticks;
  11343c:	8b 15 58 16 14 00    	mov    0x141658,%edx
  113442:	8b 45 08             	mov    0x8(%ebp),%eax
  113445:	89 50 2c             	mov    %edx,0x2c(%eax)
  pcb->keep_cnt = 0;
  113448:	8b 45 08             	mov    0x8(%ebp),%eax
  11344b:	c6 80 98 00 00 00 00 	movb   $0x0,0x98(%eax)

  /* Do different things depending on the TCP state. */
  switch (pcb->state) {
  113452:	8b 45 08             	mov    0x8(%ebp),%eax
  113455:	8b 40 10             	mov    0x10(%eax),%eax
  113458:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  11345b:	83 7d ec 09          	cmpl   $0x9,0xffffffec(%ebp)
  11345f:	0f 87 0e 06 00 00    	ja     113a73 <tcp_process+0x6f3>
  113465:	8b 4d ec             	mov    0xffffffec(%ebp),%ecx
  113468:	8b 04 8d 18 af 11 00 	mov    0x11af18(,%ecx,4),%eax
  11346f:	ff e0                	jmp    *%eax
  case SYN_SENT:
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("SYN-SENT: ackno %lu pcb->snd_nxt %lu unacked %lu\n", ackno,
     pcb->snd_nxt, ntohl(pcb->unacked->tcphdr->seqno)));
    if ((flags & TCP_ACK) && (flags & TCP_SYN)
  113471:	0f b6 05 14 99 13 00 	movzbl 0x139914,%eax
  113478:	0f b6 c0             	movzbl %al,%eax
  11347b:	83 e0 10             	and    $0x10,%eax
  11347e:	85 c0                	test   %eax,%eax
  113480:	0f 84 ed 05 00 00    	je     113a73 <tcp_process+0x6f3>
  113486:	0f b6 05 14 99 13 00 	movzbl 0x139914,%eax
  11348d:	0f b6 c0             	movzbl %al,%eax
  113490:	83 e0 02             	and    $0x2,%eax
  113493:	85 c0                	test   %eax,%eax
  113495:	0f 84 d8 05 00 00    	je     113a73 <tcp_process+0x6f3>
  11349b:	8b 45 08             	mov    0x8(%ebp),%eax
  11349e:	8b 40 74             	mov    0x74(%eax),%eax
  1134a1:	8b 40 10             	mov    0x10(%eax),%eax
  1134a4:	8b 40 04             	mov    0x4(%eax),%eax
  1134a7:	89 04 24             	mov    %eax,(%esp)
  1134aa:	e8 51 ae ff ff       	call   10e300 <ntohl>
  1134af:	8d 50 01             	lea    0x1(%eax),%edx
  1134b2:	a1 10 99 13 00       	mov    0x139910,%eax
  1134b7:	39 c2                	cmp    %eax,%edx
  1134b9:	0f 85 b4 05 00 00    	jne    113a73 <tcp_process+0x6f3>
        && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
      pcb->rcv_nxt = seqno + 1;
  1134bf:	a1 0c 99 13 00       	mov    0x13990c,%eax
  1134c4:	8d 50 01             	lea    0x1(%eax),%edx
  1134c7:	8b 45 08             	mov    0x8(%ebp),%eax
  1134ca:	89 50 24             	mov    %edx,0x24(%eax)
      pcb->lastack = ackno;
  1134cd:	8b 15 10 99 13 00    	mov    0x139910,%edx
  1134d3:	8b 45 08             	mov    0x8(%ebp),%eax
  1134d6:	89 50 44             	mov    %edx,0x44(%eax)
      pcb->snd_wnd = tcphdr->wnd;
  1134d9:	a1 04 99 13 00       	mov    0x139904,%eax
  1134de:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
  1134e2:	0f b7 d0             	movzwl %ax,%edx
  1134e5:	8b 45 08             	mov    0x8(%ebp),%eax
  1134e8:	89 50 58             	mov    %edx,0x58(%eax)
      pcb->snd_wl1 = seqno - 1; /* initialise to seqno - 1 to force window update */
  1134eb:	a1 0c 99 13 00       	mov    0x13990c,%eax
  1134f0:	8d 50 ff             	lea    0xffffffff(%eax),%edx
  1134f3:	8b 45 08             	mov    0x8(%ebp),%eax
  1134f6:	89 50 5c             	mov    %edx,0x5c(%eax)
      pcb->state = ESTABLISHED;
  1134f9:	8b 45 08             	mov    0x8(%ebp),%eax
  1134fc:	c7 40 10 04 00 00 00 	movl   $0x4,0x10(%eax)
      pcb->cwnd = pcb->mss;
  113503:	8b 45 08             	mov    0x8(%ebp),%eax
  113506:	0f b7 50 34          	movzwl 0x34(%eax),%edx
  11350a:	8b 45 08             	mov    0x8(%ebp),%eax
  11350d:	66 89 50 4a          	mov    %dx,0x4a(%eax)
      --pcb->snd_queuelen;
  113511:	8b 45 08             	mov    0x8(%ebp),%eax
  113514:	0f b6 40 6c          	movzbl 0x6c(%eax),%eax
  113518:	8d 50 ff             	lea    0xffffffff(%eax),%edx
  11351b:	8b 45 08             	mov    0x8(%ebp),%eax
  11351e:	88 50 6c             	mov    %dl,0x6c(%eax)
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_process: SYN-SENT --queuelen %u\n", (unsigned int)pcb->snd_queuelen));
      rseg = pcb->unacked;
  113521:	8b 45 08             	mov    0x8(%ebp),%eax
  113524:	8b 40 74             	mov    0x74(%eax),%eax
  113527:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
      pcb->unacked = rseg->next;
  11352a:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  11352d:	8b 10                	mov    (%eax),%edx
  11352f:	8b 45 08             	mov    0x8(%ebp),%eax
  113532:	89 50 74             	mov    %edx,0x74(%eax)
      tcp_seg_free(rseg);
  113535:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  113538:	89 04 24             	mov    %eax,(%esp)
  11353b:	e8 d0 db ff ff       	call   111110 <tcp_seg_free>

      /* Parse any options in the SYNACK. */
      tcp_parseopt(pcb);
  113540:	8b 45 08             	mov    0x8(%ebp),%eax
  113543:	89 04 24             	mov    %eax,(%esp)
  113546:	e8 55 15 00 00       	call   114aa0 <tcp_parseopt>

      /* Call the user specified function to call when sucessfully
       * connected. */
      TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
  11354b:	8b 45 08             	mov    0x8(%ebp),%eax
  11354e:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
  113554:	85 c0                	test   %eax,%eax
  113556:	74 26                	je     11357e <tcp_process+0x1fe>
  113558:	8b 45 08             	mov    0x8(%ebp),%eax
  11355b:	8b 88 84 00 00 00    	mov    0x84(%eax),%ecx
  113561:	8b 45 08             	mov    0x8(%ebp),%eax
  113564:	8b 50 18             	mov    0x18(%eax),%edx
  113567:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  11356e:	00 
  11356f:	8b 45 08             	mov    0x8(%ebp),%eax
  113572:	89 44 24 04          	mov    %eax,0x4(%esp)
  113576:	89 14 24             	mov    %edx,(%esp)
  113579:	ff d1                	call   *%ecx
  11357b:	88 45 ff             	mov    %al,0xffffffff(%ebp)
      tcp_ack(pcb);
  11357e:	8b 45 08             	mov    0x8(%ebp),%eax
  113581:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  113585:	0f b6 c0             	movzbl %al,%eax
  113588:	83 e0 01             	and    $0x1,%eax
  11358b:	84 c0                	test   %al,%al
  11358d:	74 34                	je     1135c3 <tcp_process+0x243>
  11358f:	8b 45 08             	mov    0x8(%ebp),%eax
  113592:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  113596:	89 c2                	mov    %eax,%edx
  113598:	83 e2 fe             	and    $0xfffffffe,%edx
  11359b:	8b 45 08             	mov    0x8(%ebp),%eax
  11359e:	88 50 20             	mov    %dl,0x20(%eax)
  1135a1:	8b 45 08             	mov    0x8(%ebp),%eax
  1135a4:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  1135a8:	89 c2                	mov    %eax,%edx
  1135aa:	83 ca 02             	or     $0x2,%edx
  1135ad:	8b 45 08             	mov    0x8(%ebp),%eax
  1135b0:	88 50 20             	mov    %dl,0x20(%eax)
  1135b3:	8b 45 08             	mov    0x8(%ebp),%eax
  1135b6:	89 04 24             	mov    %eax,(%esp)
  1135b9:	e8 82 e8 ff ff       	call   111e40 <tcp_output>
  1135be:	e9 b0 04 00 00       	jmp    113a73 <tcp_process+0x6f3>
  1135c3:	8b 45 08             	mov    0x8(%ebp),%eax
  1135c6:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  1135ca:	89 c2                	mov    %eax,%edx
  1135cc:	83 ca 01             	or     $0x1,%edx
  1135cf:	8b 45 08             	mov    0x8(%ebp),%eax
  1135d2:	88 50 20             	mov    %dl,0x20(%eax)
    }
    break;
  1135d5:	e9 99 04 00 00       	jmp    113a73 <tcp_process+0x6f3>
  case SYN_RCVD:
    if (flags & TCP_ACK &&
  1135da:	0f b6 05 14 99 13 00 	movzbl 0x139914,%eax
  1135e1:	0f b6 c0             	movzbl %al,%eax
  1135e4:	83 e0 10             	and    $0x10,%eax
  1135e7:	85 c0                	test   %eax,%eax
  1135e9:	0f 84 84 04 00 00    	je     113a73 <tcp_process+0x6f3>
  1135ef:	0f b6 05 14 99 13 00 	movzbl 0x139914,%eax
  1135f6:	0f b6 c0             	movzbl %al,%eax
  1135f9:	83 e0 04             	and    $0x4,%eax
  1135fc:	85 c0                	test   %eax,%eax
  1135fe:	0f 85 6f 04 00 00    	jne    113a73 <tcp_process+0x6f3>
       !(flags & TCP_RST)) {
      if (TCP_SEQ_LT(pcb->lastack, ackno) &&
  113604:	8b 45 08             	mov    0x8(%ebp),%eax
  113607:	8b 40 44             	mov    0x44(%eax),%eax
  11360a:	89 c2                	mov    %eax,%edx
  11360c:	a1 10 99 13 00       	mov    0x139910,%eax
  113611:	89 d1                	mov    %edx,%ecx
  113613:	66 29 c1             	sub    %ax,%cx
  113616:	89 c8                	mov    %ecx,%eax
  113618:	66 85 c0             	test   %ax,%ax
  11361b:	0f 89 52 04 00 00    	jns    113a73 <tcp_process+0x6f3>
  113621:	a1 10 99 13 00       	mov    0x139910,%eax
  113626:	89 c2                	mov    %eax,%edx
  113628:	8b 45 08             	mov    0x8(%ebp),%eax
  11362b:	8b 40 50             	mov    0x50(%eax),%eax
  11362e:	89 d1                	mov    %edx,%ecx
  113630:	66 29 c1             	sub    %ax,%cx
  113633:	89 c8                	mov    %ecx,%eax
  113635:	66 85 c0             	test   %ax,%ax
  113638:	0f 8f 35 04 00 00    	jg     113a73 <tcp_process+0x6f3>
          TCP_SEQ_LEQ(ackno, pcb->snd_nxt)) {
        pcb->state = ESTABLISHED;
  11363e:	8b 45 08             	mov    0x8(%ebp),%eax
  113641:	c7 40 10 04 00 00 00 	movl   $0x4,0x10(%eax)
        LWIP_DEBUGF(TCP_DEBUG, ("TCP connection established %u -> %u.\n", inseg.tcphdr->src, inseg.tcphdr->dest));
#if LWIP_CALLBACK_API
        LWIP_ASSERT("pcb->accept != NULL", pcb->accept != NULL);
#endif
        /* Call the accept function. */
        TCP_EVENT_ACCEPT(pcb, ERR_OK, err);
  113648:	8b 45 08             	mov    0x8(%ebp),%eax
  11364b:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
  113651:	85 c0                	test   %eax,%eax
  113653:	74 26                	je     11367b <tcp_process+0x2fb>
  113655:	8b 45 08             	mov    0x8(%ebp),%eax
  113658:	8b 88 88 00 00 00    	mov    0x88(%eax),%ecx
  11365e:	8b 45 08             	mov    0x8(%ebp),%eax
  113661:	8b 50 18             	mov    0x18(%eax),%edx
  113664:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  11366b:	00 
  11366c:	8b 45 08             	mov    0x8(%ebp),%eax
  11366f:	89 44 24 04          	mov    %eax,0x4(%esp)
  113673:	89 14 24             	mov    %edx,(%esp)
  113676:	ff d1                	call   *%ecx
  113678:	88 45 ff             	mov    %al,0xffffffff(%ebp)
        if (err != ERR_OK) {
  11367b:	80 7d ff 00          	cmpb   $0x0,0xffffffff(%ebp)
  11367f:	74 17                	je     113698 <tcp_process+0x318>
          /* If the accept function returns with an error, we abort
           * the connection. */
          tcp_abort(pcb);
  113681:	8b 45 08             	mov    0x8(%ebp),%eax
  113684:	89 04 24             	mov    %eax,(%esp)
  113687:	e8 b4 cc ff ff       	call   110340 <tcp_abort>
          return ERR_ABRT;
  11368c:	c7 45 e8 fd ff ff ff 	movl   $0xfffffffd,0xffffffe8(%ebp)
  113693:	e9 e2 03 00 00       	jmp    113a7a <tcp_process+0x6fa>
        }
        /* If there was any data contained within this ACK,
         * we'd better pass it on to the application as well. */
        tcp_receive(pcb);
  113698:	8b 45 08             	mov    0x8(%ebp),%eax
  11369b:	89 04 24             	mov    %eax,(%esp)
  11369e:	e8 dd 03 00 00       	call   113a80 <tcp_receive>
        pcb->cwnd = pcb->mss;
  1136a3:	8b 45 08             	mov    0x8(%ebp),%eax
  1136a6:	0f b7 50 34          	movzwl 0x34(%eax),%edx
  1136aa:	8b 45 08             	mov    0x8(%ebp),%eax
  1136ad:	66 89 50 4a          	mov    %dx,0x4a(%eax)
      }
    }
    break;
  1136b1:	e9 bd 03 00 00       	jmp    113a73 <tcp_process+0x6f3>
  case CLOSE_WAIT:
    /* FALLTHROUGH */
  case ESTABLISHED:
    tcp_receive(pcb);
  1136b6:	8b 45 08             	mov    0x8(%ebp),%eax
  1136b9:	89 04 24             	mov    %eax,(%esp)
  1136bc:	e8 bf 03 00 00       	call   113a80 <tcp_receive>
    if (flags & TCP_FIN) {
  1136c1:	0f b6 05 14 99 13 00 	movzbl 0x139914,%eax
  1136c8:	0f b6 c0             	movzbl %al,%eax
  1136cb:	83 e0 01             	and    $0x1,%eax
  1136ce:	84 c0                	test   %al,%al
  1136d0:	0f 84 9d 03 00 00    	je     113a73 <tcp_process+0x6f3>
      tcp_ack_now(pcb);
  1136d6:	8b 45 08             	mov    0x8(%ebp),%eax
  1136d9:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  1136dd:	89 c2                	mov    %eax,%edx
  1136df:	83 ca 02             	or     $0x2,%edx
  1136e2:	8b 45 08             	mov    0x8(%ebp),%eax
  1136e5:	88 50 20             	mov    %dl,0x20(%eax)
  1136e8:	8b 45 08             	mov    0x8(%ebp),%eax
  1136eb:	89 04 24             	mov    %eax,(%esp)
  1136ee:	e8 4d e7 ff ff       	call   111e40 <tcp_output>
      pcb->state = CLOSE_WAIT;
  1136f3:	8b 45 08             	mov    0x8(%ebp),%eax
  1136f6:	c7 40 10 07 00 00 00 	movl   $0x7,0x10(%eax)
    }
    break;
  1136fd:	e9 71 03 00 00       	jmp    113a73 <tcp_process+0x6f3>
  case FIN_WAIT_1:
    tcp_receive(pcb);
  113702:	8b 45 08             	mov    0x8(%ebp),%eax
  113705:	89 04 24             	mov    %eax,(%esp)
  113708:	e8 73 03 00 00       	call   113a80 <tcp_receive>
    if (flags & TCP_FIN) {
  11370d:	0f b6 05 14 99 13 00 	movzbl 0x139914,%eax
  113714:	0f b6 c0             	movzbl %al,%eax
  113717:	83 e0 01             	and    $0x1,%eax
  11371a:	84 c0                	test   %al,%al
  11371c:	0f 84 12 01 00 00    	je     113834 <tcp_process+0x4b4>
      if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  113722:	0f b6 05 14 99 13 00 	movzbl 0x139914,%eax
  113729:	0f b6 c0             	movzbl %al,%eax
  11372c:	83 e0 10             	and    $0x10,%eax
  11372f:	85 c0                	test   %eax,%eax
  113731:	0f 84 d1 00 00 00    	je     113808 <tcp_process+0x488>
  113737:	8b 45 08             	mov    0x8(%ebp),%eax
  11373a:	8b 50 50             	mov    0x50(%eax),%edx
  11373d:	a1 10 99 13 00       	mov    0x139910,%eax
  113742:	39 c2                	cmp    %eax,%edx
  113744:	0f 85 be 00 00 00    	jne    113808 <tcp_process+0x488>
        LWIP_DEBUGF(TCP_DEBUG,
         ("TCP connection closed %d -> %d.\n", inseg.tcphdr->src, inseg.tcphdr->dest));
  tcp_ack_now(pcb);
  11374a:	8b 45 08             	mov    0x8(%ebp),%eax
  11374d:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  113751:	89 c2                	mov    %eax,%edx
  113753:	83 ca 02             	or     $0x2,%edx
  113756:	8b 45 08             	mov    0x8(%ebp),%eax
  113759:	88 50 20             	mov    %dl,0x20(%eax)
  11375c:	8b 45 08             	mov    0x8(%ebp),%eax
  11375f:	89 04 24             	mov    %eax,(%esp)
  113762:	e8 d9 e6 ff ff       	call   111e40 <tcp_output>
  tcp_pcb_purge(pcb);
  113767:	8b 45 08             	mov    0x8(%ebp),%eax
  11376a:	89 04 24             	mov    %eax,(%esp)
  11376d:	e8 ee dd ff ff       	call   111560 <tcp_pcb_purge>
  TCP_RMV(&tcp_active_pcbs, pcb);
  113772:	a1 54 16 14 00       	mov    0x141654,%eax
  113777:	3b 45 08             	cmp    0x8(%ebp),%eax
  11377a:	75 0f                	jne    11378b <tcp_process+0x40b>
  11377c:	a1 54 16 14 00       	mov    0x141654,%eax
  113781:	8b 40 0c             	mov    0xc(%eax),%eax
  113784:	a3 54 16 14 00       	mov    %eax,0x141654
  113789:	eb 4b                	jmp    1137d6 <tcp_process+0x456>
  11378b:	a1 54 16 14 00       	mov    0x141654,%eax
  113790:	a3 60 16 14 00       	mov    %eax,0x141660
  113795:	eb 36                	jmp    1137cd <tcp_process+0x44d>
  113797:	a1 60 16 14 00       	mov    0x141660,%eax
  11379c:	8b 40 0c             	mov    0xc(%eax),%eax
  11379f:	85 c0                	test   %eax,%eax
  1137a1:	74 1d                	je     1137c0 <tcp_process+0x440>
  1137a3:	a1 60 16 14 00       	mov    0x141660,%eax
  1137a8:	8b 40 0c             	mov    0xc(%eax),%eax
  1137ab:	3b 45 08             	cmp    0x8(%ebp),%eax
  1137ae:	75 10                	jne    1137c0 <tcp_process+0x440>
  1137b0:	a1 60 16 14 00       	mov    0x141660,%eax
  1137b5:	8b 55 08             	mov    0x8(%ebp),%edx
  1137b8:	8b 52 0c             	mov    0xc(%edx),%edx
  1137bb:	89 50 0c             	mov    %edx,0xc(%eax)
  1137be:	eb 16                	jmp    1137d6 <tcp_process+0x456>
  1137c0:	a1 60 16 14 00       	mov    0x141660,%eax
  1137c5:	8b 40 0c             	mov    0xc(%eax),%eax
  1137c8:	a3 60 16 14 00       	mov    %eax,0x141660
  1137cd:	a1 60 16 14 00       	mov    0x141660,%eax
  1137d2:	85 c0                	test   %eax,%eax
  1137d4:	75 c1                	jne    113797 <tcp_process+0x417>
  1137d6:	8b 45 08             	mov    0x8(%ebp),%eax
  1137d9:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
  pcb->state = TIME_WAIT;
  1137e0:	8b 45 08             	mov    0x8(%ebp),%eax
  1137e3:	c7 40 10 0a 00 00 00 	movl   $0xa,0x10(%eax)
  TCP_REG(&tcp_tw_pcbs, pcb);
  1137ea:	8b 15 64 16 14 00    	mov    0x141664,%edx
  1137f0:	8b 45 08             	mov    0x8(%ebp),%eax
  1137f3:	89 50 0c             	mov    %edx,0xc(%eax)
  1137f6:	8b 45 08             	mov    0x8(%ebp),%eax
  1137f9:	a3 64 16 14 00       	mov    %eax,0x141664
  1137fe:	e8 bd 62 00 00       	call   119ac0 <tcp_timer_needed>
  113803:	e9 6b 02 00 00       	jmp    113a73 <tcp_process+0x6f3>
      } else {
  tcp_ack_now(pcb);
  113808:	8b 45 08             	mov    0x8(%ebp),%eax
  11380b:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  11380f:	89 c2                	mov    %eax,%edx
  113811:	83 ca 02             	or     $0x2,%edx
  113814:	8b 45 08             	mov    0x8(%ebp),%eax
  113817:	88 50 20             	mov    %dl,0x20(%eax)
  11381a:	8b 45 08             	mov    0x8(%ebp),%eax
  11381d:	89 04 24             	mov    %eax,(%esp)
  113820:	e8 1b e6 ff ff       	call   111e40 <tcp_output>
  pcb->state = CLOSING;
  113825:	8b 45 08             	mov    0x8(%ebp),%eax
  113828:	c7 40 10 08 00 00 00 	movl   $0x8,0x10(%eax)
  11382f:	e9 3f 02 00 00       	jmp    113a73 <tcp_process+0x6f3>
      }
    } else if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  113834:	0f b6 05 14 99 13 00 	movzbl 0x139914,%eax
  11383b:	0f b6 c0             	movzbl %al,%eax
  11383e:	83 e0 10             	and    $0x10,%eax
  113841:	85 c0                	test   %eax,%eax
  113843:	0f 84 2a 02 00 00    	je     113a73 <tcp_process+0x6f3>
  113849:	8b 45 08             	mov    0x8(%ebp),%eax
  11384c:	8b 50 50             	mov    0x50(%eax),%edx
  11384f:	a1 10 99 13 00       	mov    0x139910,%eax
  113854:	39 c2                	cmp    %eax,%edx
  113856:	0f 85 17 02 00 00    	jne    113a73 <tcp_process+0x6f3>
      pcb->state = FIN_WAIT_2;
  11385c:	8b 45 08             	mov    0x8(%ebp),%eax
  11385f:	c7 40 10 06 00 00 00 	movl   $0x6,0x10(%eax)
    }
    break;
  113866:	e9 08 02 00 00       	jmp    113a73 <tcp_process+0x6f3>
  case FIN_WAIT_2:
    tcp_receive(pcb);
  11386b:	8b 45 08             	mov    0x8(%ebp),%eax
  11386e:	89 04 24             	mov    %eax,(%esp)
  113871:	e8 0a 02 00 00       	call   113a80 <tcp_receive>
    if (flags & TCP_FIN) {
  113876:	0f b6 05 14 99 13 00 	movzbl 0x139914,%eax
  11387d:	0f b6 c0             	movzbl %al,%eax
  113880:	83 e0 01             	and    $0x1,%eax
  113883:	84 c0                	test   %al,%al
  113885:	0f 84 e8 01 00 00    	je     113a73 <tcp_process+0x6f3>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %u -> %u.\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_ack_now(pcb);
  11388b:	8b 45 08             	mov    0x8(%ebp),%eax
  11388e:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  113892:	89 c2                	mov    %eax,%edx
  113894:	83 ca 02             	or     $0x2,%edx
  113897:	8b 45 08             	mov    0x8(%ebp),%eax
  11389a:	88 50 20             	mov    %dl,0x20(%eax)
  11389d:	8b 45 08             	mov    0x8(%ebp),%eax
  1138a0:	89 04 24             	mov    %eax,(%esp)
  1138a3:	e8 98 e5 ff ff       	call   111e40 <tcp_output>
      tcp_pcb_purge(pcb);
  1138a8:	8b 45 08             	mov    0x8(%ebp),%eax
  1138ab:	89 04 24             	mov    %eax,(%esp)
  1138ae:	e8 ad dc ff ff       	call   111560 <tcp_pcb_purge>
      TCP_RMV(&tcp_active_pcbs, pcb);
  1138b3:	a1 54 16 14 00       	mov    0x141654,%eax
  1138b8:	3b 45 08             	cmp    0x8(%ebp),%eax
  1138bb:	75 0f                	jne    1138cc <tcp_process+0x54c>
  1138bd:	a1 54 16 14 00       	mov    0x141654,%eax
  1138c2:	8b 40 0c             	mov    0xc(%eax),%eax
  1138c5:	a3 54 16 14 00       	mov    %eax,0x141654
  1138ca:	eb 4b                	jmp    113917 <tcp_process+0x597>
  1138cc:	a1 54 16 14 00       	mov    0x141654,%eax
  1138d1:	a3 60 16 14 00       	mov    %eax,0x141660
  1138d6:	eb 36                	jmp    11390e <tcp_process+0x58e>
  1138d8:	a1 60 16 14 00       	mov    0x141660,%eax
  1138dd:	8b 40 0c             	mov    0xc(%eax),%eax
  1138e0:	85 c0                	test   %eax,%eax
  1138e2:	74 1d                	je     113901 <tcp_process+0x581>
  1138e4:	a1 60 16 14 00       	mov    0x141660,%eax
  1138e9:	8b 40 0c             	mov    0xc(%eax),%eax
  1138ec:	3b 45 08             	cmp    0x8(%ebp),%eax
  1138ef:	75 10                	jne    113901 <tcp_process+0x581>
  1138f1:	a1 60 16 14 00       	mov    0x141660,%eax
  1138f6:	8b 55 08             	mov    0x8(%ebp),%edx
  1138f9:	8b 52 0c             	mov    0xc(%edx),%edx
  1138fc:	89 50 0c             	mov    %edx,0xc(%eax)
  1138ff:	eb 16                	jmp    113917 <tcp_process+0x597>
  113901:	a1 60 16 14 00       	mov    0x141660,%eax
  113906:	8b 40 0c             	mov    0xc(%eax),%eax
  113909:	a3 60 16 14 00       	mov    %eax,0x141660
  11390e:	a1 60 16 14 00       	mov    0x141660,%eax
  113913:	85 c0                	test   %eax,%eax
  113915:	75 c1                	jne    1138d8 <tcp_process+0x558>
  113917:	8b 45 08             	mov    0x8(%ebp),%eax
  11391a:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
      pcb->state = TIME_WAIT;
  113921:	8b 45 08             	mov    0x8(%ebp),%eax
  113924:	c7 40 10 0a 00 00 00 	movl   $0xa,0x10(%eax)
      TCP_REG(&tcp_tw_pcbs, pcb);
  11392b:	8b 15 64 16 14 00    	mov    0x141664,%edx
  113931:	8b 45 08             	mov    0x8(%ebp),%eax
  113934:	89 50 0c             	mov    %edx,0xc(%eax)
  113937:	8b 45 08             	mov    0x8(%ebp),%eax
  11393a:	a3 64 16 14 00       	mov    %eax,0x141664
  11393f:	e8 7c 61 00 00       	call   119ac0 <tcp_timer_needed>
    }
    break;
  113944:	e9 2a 01 00 00       	jmp    113a73 <tcp_process+0x6f3>
  case CLOSING:
    tcp_receive(pcb);
  113949:	8b 45 08             	mov    0x8(%ebp),%eax
  11394c:	89 04 24             	mov    %eax,(%esp)
  11394f:	e8 2c 01 00 00       	call   113a80 <tcp_receive>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  113954:	0f b6 05 14 99 13 00 	movzbl 0x139914,%eax
  11395b:	0f b6 c0             	movzbl %al,%eax
  11395e:	83 e0 10             	and    $0x10,%eax
  113961:	85 c0                	test   %eax,%eax
  113963:	0f 84 0a 01 00 00    	je     113a73 <tcp_process+0x6f3>
  113969:	8b 45 08             	mov    0x8(%ebp),%eax
  11396c:	8b 50 50             	mov    0x50(%eax),%edx
  11396f:	a1 10 99 13 00       	mov    0x139910,%eax
  113974:	39 c2                	cmp    %eax,%edx
  113976:	0f 85 f7 00 00 00    	jne    113a73 <tcp_process+0x6f3>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %u -> %u.\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_ack_now(pcb);
  11397c:	8b 45 08             	mov    0x8(%ebp),%eax
  11397f:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  113983:	89 c2                	mov    %eax,%edx
  113985:	83 ca 02             	or     $0x2,%edx
  113988:	8b 45 08             	mov    0x8(%ebp),%eax
  11398b:	88 50 20             	mov    %dl,0x20(%eax)
  11398e:	8b 45 08             	mov    0x8(%ebp),%eax
  113991:	89 04 24             	mov    %eax,(%esp)
  113994:	e8 a7 e4 ff ff       	call   111e40 <tcp_output>
      tcp_pcb_purge(pcb);
  113999:	8b 45 08             	mov    0x8(%ebp),%eax
  11399c:	89 04 24             	mov    %eax,(%esp)
  11399f:	e8 bc db ff ff       	call   111560 <tcp_pcb_purge>
      TCP_RMV(&tcp_active_pcbs, pcb);
  1139a4:	a1 54 16 14 00       	mov    0x141654,%eax
  1139a9:	3b 45 08             	cmp    0x8(%ebp),%eax
  1139ac:	75 0f                	jne    1139bd <tcp_process+0x63d>
  1139ae:	a1 54 16 14 00       	mov    0x141654,%eax
  1139b3:	8b 40 0c             	mov    0xc(%eax),%eax
  1139b6:	a3 54 16 14 00       	mov    %eax,0x141654
  1139bb:	eb 4b                	jmp    113a08 <tcp_process+0x688>
  1139bd:	a1 54 16 14 00       	mov    0x141654,%eax
  1139c2:	a3 60 16 14 00       	mov    %eax,0x141660
  1139c7:	eb 36                	jmp    1139ff <tcp_process+0x67f>
  1139c9:	a1 60 16 14 00       	mov    0x141660,%eax
  1139ce:	8b 40 0c             	mov    0xc(%eax),%eax
  1139d1:	85 c0                	test   %eax,%eax
  1139d3:	74 1d                	je     1139f2 <tcp_process+0x672>
  1139d5:	a1 60 16 14 00       	mov    0x141660,%eax
  1139da:	8b 40 0c             	mov    0xc(%eax),%eax
  1139dd:	3b 45 08             	cmp    0x8(%ebp),%eax
  1139e0:	75 10                	jne    1139f2 <tcp_process+0x672>
  1139e2:	a1 60 16 14 00       	mov    0x141660,%eax
  1139e7:	8b 55 08             	mov    0x8(%ebp),%edx
  1139ea:	8b 52 0c             	mov    0xc(%edx),%edx
  1139ed:	89 50 0c             	mov    %edx,0xc(%eax)
  1139f0:	eb 16                	jmp    113a08 <tcp_process+0x688>
  1139f2:	a1 60 16 14 00       	mov    0x141660,%eax
  1139f7:	8b 40 0c             	mov    0xc(%eax),%eax
  1139fa:	a3 60 16 14 00       	mov    %eax,0x141660
  1139ff:	a1 60 16 14 00       	mov    0x141660,%eax
  113a04:	85 c0                	test   %eax,%eax
  113a06:	75 c1                	jne    1139c9 <tcp_process+0x649>
  113a08:	8b 45 08             	mov    0x8(%ebp),%eax
  113a0b:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
      pcb->state = TIME_WAIT;
  113a12:	8b 45 08             	mov    0x8(%ebp),%eax
  113a15:	c7 40 10 0a 00 00 00 	movl   $0xa,0x10(%eax)
      TCP_REG(&tcp_tw_pcbs, pcb);
  113a1c:	8b 15 64 16 14 00    	mov    0x141664,%edx
  113a22:	8b 45 08             	mov    0x8(%ebp),%eax
  113a25:	89 50 0c             	mov    %edx,0xc(%eax)
  113a28:	8b 45 08             	mov    0x8(%ebp),%eax
  113a2b:	a3 64 16 14 00       	mov    %eax,0x141664
  113a30:	e8 8b 60 00 00       	call   119ac0 <tcp_timer_needed>
    }
    break;
  113a35:	eb 3c                	jmp    113a73 <tcp_process+0x6f3>
  case LAST_ACK:
    tcp_receive(pcb);
  113a37:	8b 45 08             	mov    0x8(%ebp),%eax
  113a3a:	89 04 24             	mov    %eax,(%esp)
  113a3d:	e8 3e 00 00 00       	call   113a80 <tcp_receive>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  113a42:	0f b6 05 14 99 13 00 	movzbl 0x139914,%eax
  113a49:	0f b6 c0             	movzbl %al,%eax
  113a4c:	83 e0 10             	and    $0x10,%eax
  113a4f:	85 c0                	test   %eax,%eax
  113a51:	74 20                	je     113a73 <tcp_process+0x6f3>
  113a53:	8b 45 08             	mov    0x8(%ebp),%eax
  113a56:	8b 50 50             	mov    0x50(%eax),%edx
  113a59:	a1 10 99 13 00       	mov    0x139910,%eax
  113a5e:	39 c2                	cmp    %eax,%edx
  113a60:	75 11                	jne    113a73 <tcp_process+0x6f3>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %u -> %u.\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      pcb->state = CLOSED;
  113a62:	8b 45 08             	mov    0x8(%ebp),%eax
  113a65:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
      recv_flags = TF_CLOSED;
  113a6c:	c6 05 18 99 13 00 10 	movb   $0x10,0x139918
    }
    break;
  default:
    break;
  }

  return ERR_OK;
  113a73:	c7 45 e8 00 00 00 00 	movl   $0x0,0xffffffe8(%ebp)
  113a7a:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
}
  113a7d:	c9                   	leave  
  113a7e:	c3                   	ret    
  113a7f:	90                   	nop    

00113a80 <tcp_receive>:

/* tcp_receive:
 *
 * Called by tcp_process. Checks if the given segment is an ACK for outstanding
 * data, and if so frees the memory of the buffered data. Next, is places the
 * segment on any of the receive queues (pcb->recved or pcb->ooseq). If the segment
 * is buffered, the pbuf is referenced by pbuf_ref so that it will not be freed until
 * i it has been removed from the buffer.
 *
 * If the incoming segment constitutes an ACK for a segment that was used for RTT
 * estimation, the RTT is estimated here as well.
 */

static void
tcp_receive(struct tcp_pcb *pcb)
{
  113a80:	55                   	push   %ebp
  113a81:	89 e5                	mov    %esp,%ebp
  113a83:	53                   	push   %ebx
  113a84:	83 ec 74             	sub    $0x74,%esp
  struct tcp_seg *next;
#if TCP_QUEUE_OOSEQ
  struct tcp_seg *prev, *cseg;
#endif
  struct pbuf *p;
  s32_t off;
  int m;
  u32_t right_wnd_edge;


  if (flags & TCP_ACK) {
  113a87:	0f b6 05 14 99 13 00 	movzbl 0x139914,%eax
  113a8e:	0f b6 c0             	movzbl %al,%eax
  113a91:	83 e0 10             	and    $0x10,%eax
  113a94:	85 c0                	test   %eax,%eax
  113a96:	0f 84 53 06 00 00    	je     1140ef <tcp_receive+0x66f>
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl1;
  113a9c:	8b 45 08             	mov    0x8(%ebp),%eax
  113a9f:	8b 50 58             	mov    0x58(%eax),%edx
  113aa2:	8b 45 08             	mov    0x8(%ebp),%eax
  113aa5:	8b 40 5c             	mov    0x5c(%eax),%eax
  113aa8:	8d 04 02             	lea    (%edx,%eax,1),%eax
  113aab:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
  113aae:	8b 45 08             	mov    0x8(%ebp),%eax
  113ab1:	8b 40 5c             	mov    0x5c(%eax),%eax
  113ab4:	89 c2                	mov    %eax,%edx
  113ab6:	a1 0c 99 13 00       	mov    0x13990c,%eax
  113abb:	89 d1                	mov    %edx,%ecx
  113abd:	66 29 c1             	sub    %ax,%cx
  113ac0:	89 c8                	mov    %ecx,%eax
  113ac2:	66 85 c0             	test   %ax,%ax
  113ac5:	78 4d                	js     113b14 <tcp_receive+0x94>
  113ac7:	8b 45 08             	mov    0x8(%ebp),%eax
  113aca:	8b 50 5c             	mov    0x5c(%eax),%edx
  113acd:	a1 0c 99 13 00       	mov    0x13990c,%eax
  113ad2:	39 c2                	cmp    %eax,%edx
  113ad4:	75 19                	jne    113aef <tcp_receive+0x6f>
  113ad6:	8b 45 08             	mov    0x8(%ebp),%eax
  113ad9:	8b 40 60             	mov    0x60(%eax),%eax
  113adc:	89 c2                	mov    %eax,%edx
  113ade:	a1 10 99 13 00       	mov    0x139910,%eax
  113ae3:	89 d3                	mov    %edx,%ebx
  113ae5:	66 29 c3             	sub    %ax,%bx
  113ae8:	89 d8                	mov    %ebx,%eax
  113aea:	66 85 c0             	test   %ax,%ax
  113aed:	78 25                	js     113b14 <tcp_receive+0x94>
  113aef:	8b 45 08             	mov    0x8(%ebp),%eax
  113af2:	8b 50 60             	mov    0x60(%eax),%edx
  113af5:	a1 10 99 13 00       	mov    0x139910,%eax
  113afa:	39 c2                	cmp    %eax,%edx
  113afc:	75 40                	jne    113b3e <tcp_receive+0xbe>
  113afe:	a1 04 99 13 00       	mov    0x139904,%eax
  113b03:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
  113b07:	0f b7 d0             	movzwl %ax,%edx
  113b0a:	8b 45 08             	mov    0x8(%ebp),%eax
  113b0d:	8b 40 58             	mov    0x58(%eax),%eax
  113b10:	39 c2                	cmp    %eax,%edx
  113b12:	76 2a                	jbe    113b3e <tcp_receive+0xbe>
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
       (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
      pcb->snd_wnd = tcphdr->wnd;
  113b14:	a1 04 99 13 00       	mov    0x139904,%eax
  113b19:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
  113b1d:	0f b7 d0             	movzwl %ax,%edx
  113b20:	8b 45 08             	mov    0x8(%ebp),%eax
  113b23:	89 50 58             	mov    %edx,0x58(%eax)
      pcb->snd_wl1 = seqno;
  113b26:	8b 15 0c 99 13 00    	mov    0x13990c,%edx
  113b2c:	8b 45 08             	mov    0x8(%ebp),%eax
  113b2f:	89 50 5c             	mov    %edx,0x5c(%eax)
      pcb->snd_wl2 = ackno;
  113b32:	8b 15 10 99 13 00    	mov    0x139910,%edx
  113b38:	8b 45 08             	mov    0x8(%ebp),%eax
  113b3b:	89 50 60             	mov    %edx,0x60(%eax)
      LWIP_DEBUGF(TCP_WND_DEBUG, ("tcp_receive: window update %lu\n", pcb->snd_wnd));
#if TCP_WND_DEBUG
    } else {
      if (pcb->snd_wnd != tcphdr->wnd) {
        LWIP_DEBUGF(TCP_WND_DEBUG, ("tcp_receive: no window update lastack %lu snd_max %lu ackno %lu wl1 %lu seqno %lu wl2 %lu\n",
                               pcb->lastack, pcb->snd_max, ackno, pcb->snd_wl1, seqno, pcb->snd_wl2));
      }
#endif /* TCP_WND_DEBUG */
    }


    if (pcb->lastack == ackno) {
  113b3e:	8b 45 08             	mov    0x8(%ebp),%eax
  113b41:	8b 50 44             	mov    0x44(%eax),%edx
  113b44:	a1 10 99 13 00       	mov    0x139910,%eax
  113b49:	39 c2                	cmp    %eax,%edx
  113b4b:	0f 85 25 01 00 00    	jne    113c76 <tcp_receive+0x1f6>
      pcb->acked = 0;
  113b51:	8b 45 08             	mov    0x8(%ebp),%eax
  113b54:	66 c7 40 68 00 00    	movw   $0x0,0x68(%eax)

      if (pcb->snd_wl1 + pcb->snd_wnd == right_wnd_edge){
  113b5a:	8b 45 08             	mov    0x8(%ebp),%eax
  113b5d:	8b 50 5c             	mov    0x5c(%eax),%edx
  113b60:	8b 45 08             	mov    0x8(%ebp),%eax
  113b63:	8b 40 58             	mov    0x58(%eax),%eax
  113b66:	8d 04 02             	lea    (%edx,%eax,1),%eax
  113b69:	3b 45 f4             	cmp    0xfffffff4(%ebp),%eax
  113b6c:	0f 85 f6 03 00 00    	jne    113f68 <tcp_receive+0x4e8>
  ++pcb->dupacks;
  113b72:	8b 45 08             	mov    0x8(%ebp),%eax
  113b75:	0f b6 40 48          	movzbl 0x48(%eax),%eax
  113b79:	8d 50 01             	lea    0x1(%eax),%edx
  113b7c:	8b 45 08             	mov    0x8(%ebp),%eax
  113b7f:	88 50 48             	mov    %dl,0x48(%eax)
  if (pcb->dupacks >= 3 && pcb->unacked != NULL) {
  113b82:	8b 45 08             	mov    0x8(%ebp),%eax
  113b85:	0f b6 40 48          	movzbl 0x48(%eax),%eax
  113b89:	3c 02                	cmp    $0x2,%al
  113b8b:	0f 86 d7 03 00 00    	jbe    113f68 <tcp_receive+0x4e8>
  113b91:	8b 45 08             	mov    0x8(%ebp),%eax
  113b94:	8b 40 74             	mov    0x74(%eax),%eax
  113b97:	85 c0                	test   %eax,%eax
  113b99:	0f 84 c9 03 00 00    	je     113f68 <tcp_receive+0x4e8>
    if (!(pcb->flags & TF_INFR)) {
  113b9f:	8b 45 08             	mov    0x8(%ebp),%eax
  113ba2:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  113ba6:	0f b6 c0             	movzbl %al,%eax
  113ba9:	83 e0 04             	and    $0x4,%eax
  113bac:	85 c0                	test   %eax,%eax
  113bae:	0f 85 86 00 00 00    	jne    113c3a <tcp_receive+0x1ba>
      /* This is fast retransmit. Retransmit the first unacked segment. */
      LWIP_DEBUGF(TCP_FR_DEBUG, ("tcp_receive: dupacks %u (%lu), fast retransmit %lu\n",
          (unsigned int)pcb->dupacks, pcb->lastack,
          ntohl(pcb->unacked->tcphdr->seqno)));
      tcp_rexmit(pcb);
  113bb4:	8b 45 08             	mov    0x8(%ebp),%eax
  113bb7:	89 04 24             	mov    %eax,(%esp)
  113bba:	e8 a1 ea ff ff       	call   112660 <tcp_rexmit>
      /* Set ssthresh to max (FlightSize / 2, 2*SMSS) */
      pcb->ssthresh = LWIP_MAX((pcb->snd_max -
  113bbf:	8b 45 08             	mov    0x8(%ebp),%eax
  113bc2:	0f b7 40 34          	movzwl 0x34(%eax),%eax
  113bc6:	0f b7 c0             	movzwl %ax,%eax
  113bc9:	01 c0                	add    %eax,%eax
  113bcb:	89 c1                	mov    %eax,%ecx
  113bcd:	8b 45 08             	mov    0x8(%ebp),%eax
  113bd0:	8b 50 54             	mov    0x54(%eax),%edx
  113bd3:	8b 45 08             	mov    0x8(%ebp),%eax
  113bd6:	8b 40 44             	mov    0x44(%eax),%eax
  113bd9:	89 d3                	mov    %edx,%ebx
  113bdb:	29 c3                	sub    %eax,%ebx
  113bdd:	89 d8                	mov    %ebx,%eax
  113bdf:	89 c2                	mov    %eax,%edx
  113be1:	d1 ea                	shr    %edx
  113be3:	89 55 9c             	mov    %edx,0xffffff9c(%ebp)
  113be6:	89 4d a0             	mov    %ecx,0xffffffa0(%ebp)
  113be9:	8b 4d 9c             	mov    0xffffff9c(%ebp),%ecx
  113bec:	39 4d a0             	cmp    %ecx,0xffffffa0(%ebp)
  113bef:	73 06                	jae    113bf7 <tcp_receive+0x177>
  113bf1:	8b 5d 9c             	mov    0xffffff9c(%ebp),%ebx
  113bf4:	89 5d a0             	mov    %ebx,0xffffffa0(%ebp)
  113bf7:	0f b7 55 a0          	movzwl 0xffffffa0(%ebp),%edx
  113bfb:	8b 45 08             	mov    0x8(%ebp),%eax
  113bfe:	66 89 50 4c          	mov    %dx,0x4c(%eax)
          pcb->lastack) / 2,
         2 * pcb->mss);

      pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
  113c02:	8b 45 08             	mov    0x8(%ebp),%eax
  113c05:	0f b7 48 4c          	movzwl 0x4c(%eax),%ecx
  113c09:	8b 45 08             	mov    0x8(%ebp),%eax
  113c0c:	0f b7 40 34          	movzwl 0x34(%eax),%eax
  113c10:	0f b7 d0             	movzwl %ax,%edx
  113c13:	89 d0                	mov    %edx,%eax
  113c15:	01 c0                	add    %eax,%eax
  113c17:	01 d0                	add    %edx,%eax
  113c19:	8d 14 01             	lea    (%ecx,%eax,1),%edx
  113c1c:	8b 45 08             	mov    0x8(%ebp),%eax
  113c1f:	66 89 50 4a          	mov    %dx,0x4a(%eax)
      pcb->flags |= TF_INFR;
  113c23:	8b 45 08             	mov    0x8(%ebp),%eax
  113c26:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  113c2a:	89 c2                	mov    %eax,%edx
  113c2c:	83 ca 04             	or     $0x4,%edx
  113c2f:	8b 45 08             	mov    0x8(%ebp),%eax
  113c32:	88 50 20             	mov    %dl,0x20(%eax)
  113c35:	e9 2e 03 00 00       	jmp    113f68 <tcp_receive+0x4e8>
    } else {
      /* Inflate the congestion window, but not if it means that
         the value overflows. */
      if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
  113c3a:	8b 45 08             	mov    0x8(%ebp),%eax
  113c3d:	0f b7 50 4a          	movzwl 0x4a(%eax),%edx
  113c41:	8b 45 08             	mov    0x8(%ebp),%eax
  113c44:	0f b7 40 34          	movzwl 0x34(%eax),%eax
  113c48:	01 c2                	add    %eax,%edx
  113c4a:	8b 45 08             	mov    0x8(%ebp),%eax
  113c4d:	0f b7 40 4a          	movzwl 0x4a(%eax),%eax
  113c51:	66 39 c2             	cmp    %ax,%dx
  113c54:	0f 86 0e 03 00 00    	jbe    113f68 <tcp_receive+0x4e8>
        pcb->cwnd += pcb->mss;
  113c5a:	8b 45 08             	mov    0x8(%ebp),%eax
  113c5d:	0f b7 50 4a          	movzwl 0x4a(%eax),%edx
  113c61:	8b 45 08             	mov    0x8(%ebp),%eax
  113c64:	0f b7 40 34          	movzwl 0x34(%eax),%eax
  113c68:	01 c2                	add    %eax,%edx
  113c6a:	8b 45 08             	mov    0x8(%ebp),%eax
  113c6d:	66 89 50 4a          	mov    %dx,0x4a(%eax)
  113c71:	e9 f2 02 00 00       	jmp    113f68 <tcp_receive+0x4e8>
      }
    }
  }
      } else {
  LWIP_DEBUGF(TCP_FR_DEBUG, ("tcp_receive: dupack averted %lu %lu\n",
            pcb->snd_wl1 + pcb->snd_wnd, right_wnd_edge));
      }
    } else if (TCP_SEQ_LT(pcb->lastack, ackno) &&
  113c76:	8b 45 08             	mov    0x8(%ebp),%eax
  113c79:	8b 40 44             	mov    0x44(%eax),%eax
  113c7c:	89 c2                	mov    %eax,%edx
  113c7e:	a1 10 99 13 00       	mov    0x139910,%eax
  113c83:	89 d1                	mov    %edx,%ecx
  113c85:	66 29 c1             	sub    %ax,%cx
  113c88:	89 c8                	mov    %ecx,%eax
  113c8a:	66 85 c0             	test   %ax,%ax
  113c8d:	0f 89 d5 02 00 00    	jns    113f68 <tcp_receive+0x4e8>
  113c93:	a1 10 99 13 00       	mov    0x139910,%eax
  113c98:	89 c2                	mov    %eax,%edx
  113c9a:	8b 45 08             	mov    0x8(%ebp),%eax
  113c9d:	8b 40 54             	mov    0x54(%eax),%eax
  113ca0:	89 d3                	mov    %edx,%ebx
  113ca2:	66 29 c3             	sub    %ax,%bx
  113ca5:	89 d8                	mov    %ebx,%eax
  113ca7:	66 85 c0             	test   %ax,%ax
  113caa:	0f 8f b8 02 00 00    	jg     113f68 <tcp_receive+0x4e8>
              TCP_SEQ_LEQ(ackno, pcb->snd_max)) {
      /* We come here when the ACK acknowledges new data. */

      /* Reset the "IN Fast Retransmit" flag, since we are no longer
         in fast retransmit. Also reset the congestion window to the
         slow start threshold. */
      if (pcb->flags & TF_INFR) {
  113cb0:	8b 45 08             	mov    0x8(%ebp),%eax
  113cb3:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  113cb7:	0f b6 c0             	movzbl %al,%eax
  113cba:	83 e0 04             	and    $0x4,%eax
  113cbd:	85 c0                	test   %eax,%eax
  113cbf:	74 20                	je     113ce1 <tcp_receive+0x261>
  pcb->flags &= ~TF_INFR;
  113cc1:	8b 45 08             	mov    0x8(%ebp),%eax
  113cc4:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  113cc8:	89 c2                	mov    %eax,%edx
  113cca:	83 e2 fb             	and    $0xfffffffb,%edx
  113ccd:	8b 45 08             	mov    0x8(%ebp),%eax
  113cd0:	88 50 20             	mov    %dl,0x20(%eax)
  pcb->cwnd = pcb->ssthresh;
  113cd3:	8b 45 08             	mov    0x8(%ebp),%eax
  113cd6:	0f b7 50 4c          	movzwl 0x4c(%eax),%edx
  113cda:	8b 45 08             	mov    0x8(%ebp),%eax
  113cdd:	66 89 50 4a          	mov    %dx,0x4a(%eax)
      }

      /* Reset the number of retransmissions. */
      pcb->nrtx = 0;
  113ce1:	8b 45 08             	mov    0x8(%ebp),%eax
  113ce4:	c6 40 42 00          	movb   $0x0,0x42(%eax)

      /* Reset the retransmission time-out. */
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
  113ce8:	8b 45 08             	mov    0x8(%ebp),%eax
  113ceb:	0f b7 40 3c          	movzwl 0x3c(%eax),%eax
  113cef:	66 c1 f8 03          	sar    $0x3,%ax
  113cf3:	89 c2                	mov    %eax,%edx
  113cf5:	8b 45 08             	mov    0x8(%ebp),%eax
  113cf8:	0f b7 40 3e          	movzwl 0x3e(%eax),%eax
  113cfc:	01 c2                	add    %eax,%edx
  113cfe:	8b 45 08             	mov    0x8(%ebp),%eax
  113d01:	66 89 50 40          	mov    %dx,0x40(%eax)

      /* Update the send buffer space. */
      pcb->acked = ackno - pcb->lastack;
  113d05:	a1 10 99 13 00       	mov    0x139910,%eax
  113d0a:	89 c2                	mov    %eax,%edx
  113d0c:	8b 45 08             	mov    0x8(%ebp),%eax
  113d0f:	8b 40 44             	mov    0x44(%eax),%eax
  113d12:	66 29 c2             	sub    %ax,%dx
  113d15:	8b 45 08             	mov    0x8(%ebp),%eax
  113d18:	66 89 50 68          	mov    %dx,0x68(%eax)
      pcb->snd_buf += pcb->acked;
  113d1c:	8b 45 08             	mov    0x8(%ebp),%eax
  113d1f:	0f b7 50 6a          	movzwl 0x6a(%eax),%edx
  113d23:	8b 45 08             	mov    0x8(%ebp),%eax
  113d26:	0f b7 40 68          	movzwl 0x68(%eax),%eax
  113d2a:	01 c2                	add    %eax,%edx
  113d2c:	8b 45 08             	mov    0x8(%ebp),%eax
  113d2f:	66 89 50 6a          	mov    %dx,0x6a(%eax)

      /* Reset the fast retransmit variables. */
      pcb->dupacks = 0;
  113d33:	8b 45 08             	mov    0x8(%ebp),%eax
  113d36:	c6 40 48 00          	movb   $0x0,0x48(%eax)
      pcb->lastack = ackno;
  113d3a:	8b 15 10 99 13 00    	mov    0x139910,%edx
  113d40:	8b 45 08             	mov    0x8(%ebp),%eax
  113d43:	89 50 44             	mov    %edx,0x44(%eax)

      /* Update the congestion control variables (cwnd and
         ssthresh). */
      if (pcb->state >= ESTABLISHED) {
  113d46:	8b 45 08             	mov    0x8(%ebp),%eax
  113d49:	8b 40 10             	mov    0x10(%eax),%eax
  113d4c:	83 f8 03             	cmp    $0x3,%eax
  113d4f:	0f 86 ed 00 00 00    	jbe    113e42 <tcp_receive+0x3c2>
        if (pcb->cwnd < pcb->ssthresh) {
  113d55:	8b 45 08             	mov    0x8(%ebp),%eax
  113d58:	0f b7 50 4a          	movzwl 0x4a(%eax),%edx
  113d5c:	8b 45 08             	mov    0x8(%ebp),%eax
  113d5f:	0f b7 40 4c          	movzwl 0x4c(%eax),%eax
  113d63:	66 39 c2             	cmp    %ax,%dx
  113d66:	73 3c                	jae    113da4 <tcp_receive+0x324>
    if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
  113d68:	8b 45 08             	mov    0x8(%ebp),%eax
  113d6b:	0f b7 50 4a          	movzwl 0x4a(%eax),%edx
  113d6f:	8b 45 08             	mov    0x8(%ebp),%eax
  113d72:	0f b7 40 34          	movzwl 0x34(%eax),%eax
  113d76:	01 c2                	add    %eax,%edx
  113d78:	8b 45 08             	mov    0x8(%ebp),%eax
  113d7b:	0f b7 40 4a          	movzwl 0x4a(%eax),%eax
  113d7f:	66 39 c2             	cmp    %ax,%dx
  113d82:	0f 86 ba 00 00 00    	jbe    113e42 <tcp_receive+0x3c2>
      pcb->cwnd += pcb->mss;
  113d88:	8b 45 08             	mov    0x8(%ebp),%eax
  113d8b:	0f b7 50 4a          	movzwl 0x4a(%eax),%edx
  113d8f:	8b 45 08             	mov    0x8(%ebp),%eax
  113d92:	0f b7 40 34          	movzwl 0x34(%eax),%eax
  113d96:	01 c2                	add    %eax,%edx
  113d98:	8b 45 08             	mov    0x8(%ebp),%eax
  113d9b:	66 89 50 4a          	mov    %dx,0x4a(%eax)
  113d9f:	e9 9e 00 00 00       	jmp    113e42 <tcp_receive+0x3c2>
    }
          LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_receive: slow start cwnd %u\n", pcb->cwnd));
        } else {
    u16_t new_cwnd = (pcb->cwnd + pcb->mss * pcb->mss / pcb->cwnd);
  113da4:	8b 45 08             	mov    0x8(%ebp),%eax
  113da7:	0f b7 48 4a          	movzwl 0x4a(%eax),%ecx
  113dab:	8b 45 08             	mov    0x8(%ebp),%eax
  113dae:	0f b7 40 34          	movzwl 0x34(%eax),%eax
  113db2:	0f b7 d0             	movzwl %ax,%edx
  113db5:	8b 45 08             	mov    0x8(%ebp),%eax
  113db8:	0f b7 40 34          	movzwl 0x34(%eax),%eax
  113dbc:	0f b7 c0             	movzwl %ax,%eax
  113dbf:	0f af d0             	imul   %eax,%edx
  113dc2:	8b 45 08             	mov    0x8(%ebp),%eax
  113dc5:	0f b7 40 4a          	movzwl 0x4a(%eax),%eax
  113dc9:	0f b7 c0             	movzwl %ax,%eax
  113dcc:	89 c3                	mov    %eax,%ebx
  113dce:	89 d0                	mov    %edx,%eax
  113dd0:	c1 fa 1f             	sar    $0x1f,%edx
  113dd3:	f7 fb                	idiv   %ebx
  113dd5:	8d 04 01             	lea    (%ecx,%eax,1),%eax
  113dd8:	66 89 45 fa          	mov    %ax,0xfffffffa(%ebp)
    if (new_cwnd > pcb->cwnd) {
  113ddc:	8b 45 08             	mov    0x8(%ebp),%eax
  113ddf:	0f b7 40 4a          	movzwl 0x4a(%eax),%eax
  113de3:	66 3b 45 fa          	cmp    0xfffffffa(%ebp),%ax
  113de7:	73 59                	jae    113e42 <tcp_receive+0x3c2>
      pcb->cwnd = new_cwnd;
  113de9:	8b 55 08             	mov    0x8(%ebp),%edx
  113dec:	0f b7 45 fa          	movzwl 0xfffffffa(%ebp),%eax
  113df0:	66 89 42 4a          	mov    %ax,0x4a(%edx)
    }
          LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_receive: congestion avoidance cwnd %u\n", pcb->cwnd));
        }
      }
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: ACK for %lu, unacked->seqno %lu:%lu\n",
                               ackno,
                               pcb->unacked != NULL?
                               ntohl(pcb->unacked->tcphdr->seqno): 0,
                               pcb->unacked != NULL?
                               ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
   ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
  113df4:	eb 4c                	jmp    113e42 <tcp_receive+0x3c2>
      TCP_SEQ_LEQ(ntohl(pcb->unacked->tcphdr->seqno) +
      TCP_TCPLEN(pcb->unacked), ackno)) {
  LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %lu:%lu from pcb->unacked\n",
         ntohl(pcb->unacked->tcphdr->seqno),
         ntohl(pcb->unacked->tcphdr->seqno) +
         TCP_TCPLEN(pcb->unacked)));

  next = pcb->unacked;
  113df6:	8b 45 08             	mov    0x8(%ebp),%eax
  113df9:	8b 40 74             	mov    0x74(%eax),%eax
  113dfc:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
  pcb->unacked = pcb->unacked->next;
  113dff:	8b 45 08             	mov    0x8(%ebp),%eax
  113e02:	8b 40 74             	mov    0x74(%eax),%eax
  113e05:	8b 10                	mov    (%eax),%edx
  113e07:	8b 45 08             	mov    0x8(%ebp),%eax
  113e0a:	89 50 74             	mov    %edx,0x74(%eax)

  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %u ... ", (unsigned int)pcb->snd_queuelen));
  pcb->snd_queuelen -= pbuf_clen(next->p);
  113e0d:	8b 45 08             	mov    0x8(%ebp),%eax
  113e10:	0f b6 58 6c          	movzbl 0x6c(%eax),%ebx
  113e14:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  113e17:	8b 40 04             	mov    0x4(%eax),%eax
  113e1a:	89 04 24             	mov    %eax,(%esp)
  113e1d:	e8 ce b7 ff ff       	call   10f5f0 <pbuf_clen>
  113e22:	89 da                	mov    %ebx,%edx
  113e24:	28 c2                	sub    %al,%dl
  113e26:	8b 45 08             	mov    0x8(%ebp),%eax
  113e29:	88 50 6c             	mov    %dl,0x6c(%eax)
  tcp_seg_free(next);
  113e2c:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  113e2f:	89 04 24             	mov    %eax,(%esp)
  113e32:	e8 d9 d2 ff ff       	call   111110 <tcp_seg_free>

  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%u (after freeing unacked)\n", (unsigned int)pcb->snd_queuelen));
  if (pcb->snd_queuelen != 0) {
  113e37:	8b 45 08             	mov    0x8(%ebp),%eax
  113e3a:	0f b6 40 6c          	movzbl 0x6c(%eax),%eax
  113e3e:	84 c0                	test   %al,%al
  113e40:	74 00                	je     113e42 <tcp_receive+0x3c2>
  113e42:	8b 45 08             	mov    0x8(%ebp),%eax
  113e45:	8b 40 74             	mov    0x74(%eax),%eax
  113e48:	85 c0                	test   %eax,%eax
  113e4a:	0f 84 9d 00 00 00    	je     113eed <tcp_receive+0x46d>
  113e50:	8b 45 08             	mov    0x8(%ebp),%eax
  113e53:	8b 40 74             	mov    0x74(%eax),%eax
  113e56:	8b 40 10             	mov    0x10(%eax),%eax
  113e59:	8b 40 04             	mov    0x4(%eax),%eax
  113e5c:	89 04 24             	mov    %eax,(%esp)
  113e5f:	e8 9c a4 ff ff       	call   10e300 <ntohl>
  113e64:	66 89 45 a4          	mov    %ax,0xffffffa4(%ebp)
  113e68:	8b 45 08             	mov    0x8(%ebp),%eax
  113e6b:	8b 40 74             	mov    0x74(%eax),%eax
  113e6e:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  113e72:	66 89 45 a6          	mov    %ax,0xffffffa6(%ebp)
  113e76:	8b 45 08             	mov    0x8(%ebp),%eax
  113e79:	8b 40 74             	mov    0x74(%eax),%eax
  113e7c:	8b 40 10             	mov    0x10(%eax),%eax
  113e7f:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  113e83:	0f b7 c0             	movzwl %ax,%eax
  113e86:	89 04 24             	mov    %eax,(%esp)
  113e89:	e8 12 a4 ff ff       	call   10e2a0 <ntohs>
  113e8e:	0f b7 c0             	movzwl %ax,%eax
  113e91:	83 e0 01             	and    $0x1,%eax
  113e94:	84 c0                	test   %al,%al
  113e96:	75 22                	jne    113eba <tcp_receive+0x43a>
  113e98:	8b 45 08             	mov    0x8(%ebp),%eax
  113e9b:	8b 40 74             	mov    0x74(%eax),%eax
  113e9e:	8b 40 10             	mov    0x10(%eax),%eax
  113ea1:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  113ea5:	0f b7 c0             	movzwl %ax,%eax
  113ea8:	89 04 24             	mov    %eax,(%esp)
  113eab:	e8 f0 a3 ff ff       	call   10e2a0 <ntohs>
  113eb0:	0f b7 c0             	movzwl %ax,%eax
  113eb3:	83 e0 02             	and    $0x2,%eax
  113eb6:	85 c0                	test   %eax,%eax
  113eb8:	74 09                	je     113ec3 <tcp_receive+0x443>
  113eba:	c7 45 a8 01 00 00 00 	movl   $0x1,0xffffffa8(%ebp)
  113ec1:	eb 07                	jmp    113eca <tcp_receive+0x44a>
  113ec3:	c7 45 a8 00 00 00 00 	movl   $0x0,0xffffffa8(%ebp)
  113eca:	0f b7 45 a8          	movzwl 0xffffffa8(%ebp),%eax
  113ece:	66 03 45 a6          	add    0xffffffa6(%ebp),%ax
  113ed2:	0f b7 55 a4          	movzwl 0xffffffa4(%ebp),%edx
  113ed6:	01 c2                	add    %eax,%edx
  113ed8:	a1 10 99 13 00       	mov    0x139910,%eax
  113edd:	89 d1                	mov    %edx,%ecx
  113edf:	66 29 c1             	sub    %ax,%cx
  113ee2:	89 c8                	mov    %ecx,%eax
  113ee4:	66 85 c0             	test   %ax,%ax
  113ee7:	0f 8e 09 ff ff ff    	jle    113df6 <tcp_receive+0x376>
    LWIP_ASSERT("tcp_receive: valid queue length", pcb->unacked != NULL ||
     pcb->unsent != NULL);
  }
      }
      pcb->polltmr = 0;
  113eed:	8b 45 08             	mov    0x8(%ebp),%eax
  113ef0:	c6 40 30 00          	movb   $0x0,0x30(%eax)
    }

      /* We go through the ->unsent list to see if any of the segments
         on the list are acknowledged by the ACK. This may seem
         strange since an "unsent" segment shouldn't be acked. The
         rationale is that lwIP puts all outstanding segments on the
         ->unsent list after a retransmission, so these segments may
         in fact have been sent once. */
      while (pcb->unsent != NULL &&
  113ef4:	eb 72                	jmp    113f68 <tcp_receive+0x4e8>
      TCP_SEQ_LEQ(ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent),
                        ackno) &&
      TCP_SEQ_LEQ(ackno, pcb->snd_max)) {
  LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %lu:%lu from pcb->unsent\n",
         ntohl(pcb->unsent->tcphdr->seqno),
         ntohl(pcb->unsent->tcphdr->seqno) +
         TCP_TCPLEN(pcb->unsent)));

  next = pcb->unsent;
  113ef6:	8b 45 08             	mov    0x8(%ebp),%eax
  113ef9:	8b 40 70             	mov    0x70(%eax),%eax
  113efc:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
  pcb->unsent = pcb->unsent->next;
  113eff:	8b 45 08             	mov    0x8(%ebp),%eax
  113f02:	8b 40 70             	mov    0x70(%eax),%eax
  113f05:	8b 10                	mov    (%eax),%edx
  113f07:	8b 45 08             	mov    0x8(%ebp),%eax
  113f0a:	89 50 70             	mov    %edx,0x70(%eax)
  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %u ... ", (unsigned int)pcb->snd_queuelen));
  pcb->snd_queuelen -= pbuf_clen(next->p);
  113f0d:	8b 45 08             	mov    0x8(%ebp),%eax
  113f10:	0f b6 58 6c          	movzbl 0x6c(%eax),%ebx
  113f14:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  113f17:	8b 40 04             	mov    0x4(%eax),%eax
  113f1a:	89 04 24             	mov    %eax,(%esp)
  113f1d:	e8 ce b6 ff ff       	call   10f5f0 <pbuf_clen>
  113f22:	89 da                	mov    %ebx,%edx
  113f24:	28 c2                	sub    %al,%dl
  113f26:	8b 45 08             	mov    0x8(%ebp),%eax
  113f29:	88 50 6c             	mov    %dl,0x6c(%eax)
  tcp_seg_free(next);
  113f2c:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  113f2f:	89 04 24             	mov    %eax,(%esp)
  113f32:	e8 d9 d1 ff ff       	call   111110 <tcp_seg_free>
  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%u (after freeing unsent)\n", (unsigned int)pcb->snd_queuelen));
  if (pcb->snd_queuelen != 0) {
  113f37:	8b 45 08             	mov    0x8(%ebp),%eax
  113f3a:	0f b6 40 6c          	movzbl 0x6c(%eax),%eax
  113f3e:	84 c0                	test   %al,%al
  113f40:	74 00                	je     113f42 <tcp_receive+0x4c2>
    LWIP_ASSERT("tcp_receive: valid queue length", pcb->unacked != NULL ||
     pcb->unsent != NULL);
  }

        if (pcb->unsent != NULL) {
  113f42:	8b 45 08             	mov    0x8(%ebp),%eax
  113f45:	8b 40 70             	mov    0x70(%eax),%eax
  113f48:	85 c0                	test   %eax,%eax
  113f4a:	74 1c                	je     113f68 <tcp_receive+0x4e8>
          pcb->snd_nxt = htonl(pcb->unsent->tcphdr->seqno);
  113f4c:	8b 45 08             	mov    0x8(%ebp),%eax
  113f4f:	8b 40 70             	mov    0x70(%eax),%eax
  113f52:	8b 40 10             	mov    0x10(%eax),%eax
  113f55:	8b 40 04             	mov    0x4(%eax),%eax
  113f58:	89 04 24             	mov    %eax,(%esp)
  113f5b:	e8 60 a3 ff ff       	call   10e2c0 <htonl>
  113f60:	89 c2                	mov    %eax,%edx
  113f62:	8b 45 08             	mov    0x8(%ebp),%eax
  113f65:	89 50 50             	mov    %edx,0x50(%eax)
  113f68:	8b 45 08             	mov    0x8(%ebp),%eax
  113f6b:	8b 40 70             	mov    0x70(%eax),%eax
  113f6e:	85 c0                	test   %eax,%eax
  113f70:	0f 84 b6 00 00 00    	je     11402c <tcp_receive+0x5ac>
  113f76:	8b 45 08             	mov    0x8(%ebp),%eax
  113f79:	8b 40 70             	mov    0x70(%eax),%eax
  113f7c:	8b 40 10             	mov    0x10(%eax),%eax
  113f7f:	8b 40 04             	mov    0x4(%eax),%eax
  113f82:	89 04 24             	mov    %eax,(%esp)
  113f85:	e8 76 a3 ff ff       	call   10e300 <ntohl>
  113f8a:	66 89 45 ac          	mov    %ax,0xffffffac(%ebp)
  113f8e:	8b 45 08             	mov    0x8(%ebp),%eax
  113f91:	8b 40 70             	mov    0x70(%eax),%eax
  113f94:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  113f98:	66 89 45 ae          	mov    %ax,0xffffffae(%ebp)
  113f9c:	8b 45 08             	mov    0x8(%ebp),%eax
  113f9f:	8b 40 70             	mov    0x70(%eax),%eax
  113fa2:	8b 40 10             	mov    0x10(%eax),%eax
  113fa5:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  113fa9:	0f b7 c0             	movzwl %ax,%eax
  113fac:	89 04 24             	mov    %eax,(%esp)
  113faf:	e8 ec a2 ff ff       	call   10e2a0 <ntohs>
  113fb4:	0f b7 c0             	movzwl %ax,%eax
  113fb7:	83 e0 01             	and    $0x1,%eax
  113fba:	84 c0                	test   %al,%al
  113fbc:	75 22                	jne    113fe0 <tcp_receive+0x560>
  113fbe:	8b 45 08             	mov    0x8(%ebp),%eax
  113fc1:	8b 40 70             	mov    0x70(%eax),%eax
  113fc4:	8b 40 10             	mov    0x10(%eax),%eax
  113fc7:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  113fcb:	0f b7 c0             	movzwl %ax,%eax
  113fce:	89 04 24             	mov    %eax,(%esp)
  113fd1:	e8 ca a2 ff ff       	call   10e2a0 <ntohs>
  113fd6:	0f b7 c0             	movzwl %ax,%eax
  113fd9:	83 e0 02             	and    $0x2,%eax
  113fdc:	85 c0                	test   %eax,%eax
  113fde:	74 09                	je     113fe9 <tcp_receive+0x569>
  113fe0:	c7 45 b0 01 00 00 00 	movl   $0x1,0xffffffb0(%ebp)
  113fe7:	eb 07                	jmp    113ff0 <tcp_receive+0x570>
  113fe9:	c7 45 b0 00 00 00 00 	movl   $0x0,0xffffffb0(%ebp)
  113ff0:	0f b7 45 b0          	movzwl 0xffffffb0(%ebp),%eax
  113ff4:	66 03 45 ae          	add    0xffffffae(%ebp),%ax
  113ff8:	0f b7 55 ac          	movzwl 0xffffffac(%ebp),%edx
  113ffc:	01 c2                	add    %eax,%edx
  113ffe:	a1 10 99 13 00       	mov    0x139910,%eax
  114003:	89 d3                	mov    %edx,%ebx
  114005:	66 29 c3             	sub    %ax,%bx
  114008:	89 d8                	mov    %ebx,%eax
  11400a:	66 85 c0             	test   %ax,%ax
  11400d:	7f 1d                	jg     11402c <tcp_receive+0x5ac>
  11400f:	a1 10 99 13 00       	mov    0x139910,%eax
  114014:	89 c2                	mov    %eax,%edx
  114016:	8b 45 08             	mov    0x8(%ebp),%eax
  114019:	8b 40 54             	mov    0x54(%eax),%eax
  11401c:	89 d1                	mov    %edx,%ecx
  11401e:	66 29 c1             	sub    %ax,%cx
  114021:	89 c8                	mov    %ecx,%eax
  114023:	66 85 c0             	test   %ax,%ax
  114026:	0f 8e ca fe ff ff    	jle    113ef6 <tcp_receive+0x476>
        }
      }

    /* End of ACK for new data processing. */

    LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: pcb->rttest %u rtseq %lu ackno %lu\n",
     pcb->rttest, pcb->rtseq, ackno));

    /* RTT estimation calculations. This is done by checking if the
       incoming segment acknowledges the segment we use to take a
       round-trip time measurement. */
    if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
  11402c:	8b 45 08             	mov    0x8(%ebp),%eax
  11402f:	0f b7 40 36          	movzwl 0x36(%eax),%eax
  114033:	66 85 c0             	test   %ax,%ax
  114036:	0f 84 b3 00 00 00    	je     1140ef <tcp_receive+0x66f>
  11403c:	8b 45 08             	mov    0x8(%ebp),%eax
  11403f:	8b 40 38             	mov    0x38(%eax),%eax
  114042:	89 c2                	mov    %eax,%edx
  114044:	a1 10 99 13 00       	mov    0x139910,%eax
  114049:	89 d3                	mov    %edx,%ebx
  11404b:	66 29 c3             	sub    %ax,%bx
  11404e:	89 d8                	mov    %ebx,%eax
  114050:	66 85 c0             	test   %ax,%ax
  114053:	0f 89 96 00 00 00    	jns    1140ef <tcp_receive+0x66f>
      m = tcp_ticks - pcb->rttest;
  114059:	8b 15 58 16 14 00    	mov    0x141658,%edx
  11405f:	8b 45 08             	mov    0x8(%ebp),%eax
  114062:	0f b7 40 36          	movzwl 0x36(%eax),%eax
  114066:	0f b7 c0             	movzwl %ax,%eax
  114069:	89 d1                	mov    %edx,%ecx
  11406b:	29 c1                	sub    %eax,%ecx
  11406d:	89 c8                	mov    %ecx,%eax
  11406f:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: experienced rtt %u ticks (%u msec).\n",
       m, m * TCP_SLOW_INTERVAL));

      /* This is taken directly from VJs original code in his paper */
      m = m - (pcb->sa >> 3);
  114072:	8b 45 08             	mov    0x8(%ebp),%eax
  114075:	0f b7 40 3c          	movzwl 0x3c(%eax),%eax
  114079:	66 c1 f8 03          	sar    $0x3,%ax
  11407d:	98                   	cwtl   
  11407e:	29 45 f0             	sub    %eax,0xfffffff0(%ebp)
      pcb->sa += m;
  114081:	8b 45 08             	mov    0x8(%ebp),%eax
  114084:	0f b7 40 3c          	movzwl 0x3c(%eax),%eax
  114088:	89 c2                	mov    %eax,%edx
  11408a:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  11408d:	8d 04 02             	lea    (%edx,%eax,1),%eax
  114090:	89 c2                	mov    %eax,%edx
  114092:	8b 45 08             	mov    0x8(%ebp),%eax
  114095:	66 89 50 3c          	mov    %dx,0x3c(%eax)
      if (m < 0) {
  114099:	83 7d f0 00          	cmpl   $0x0,0xfffffff0(%ebp)
  11409d:	79 03                	jns    1140a2 <tcp_receive+0x622>
  m = -m;
  11409f:	f7 5d f0             	negl   0xfffffff0(%ebp)
      }
      m = m - (pcb->sv >> 2);
  1140a2:	8b 45 08             	mov    0x8(%ebp),%eax
  1140a5:	0f b7 40 3e          	movzwl 0x3e(%eax),%eax
  1140a9:	66 c1 f8 02          	sar    $0x2,%ax
  1140ad:	98                   	cwtl   
  1140ae:	29 45 f0             	sub    %eax,0xfffffff0(%ebp)
      pcb->sv += m;
  1140b1:	8b 45 08             	mov    0x8(%ebp),%eax
  1140b4:	0f b7 40 3e          	movzwl 0x3e(%eax),%eax
  1140b8:	89 c2                	mov    %eax,%edx
  1140ba:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  1140bd:	8d 04 02             	lea    (%edx,%eax,1),%eax
  1140c0:	89 c2                	mov    %eax,%edx
  1140c2:	8b 45 08             	mov    0x8(%ebp),%eax
  1140c5:	66 89 50 3e          	mov    %dx,0x3e(%eax)
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
  1140c9:	8b 45 08             	mov    0x8(%ebp),%eax
  1140cc:	0f b7 40 3c          	movzwl 0x3c(%eax),%eax
  1140d0:	66 c1 f8 03          	sar    $0x3,%ax
  1140d4:	89 c2                	mov    %eax,%edx
  1140d6:	8b 45 08             	mov    0x8(%ebp),%eax
  1140d9:	0f b7 40 3e          	movzwl 0x3e(%eax),%eax
  1140dd:	01 c2                	add    %eax,%edx
  1140df:	8b 45 08             	mov    0x8(%ebp),%eax
  1140e2:	66 89 50 40          	mov    %dx,0x40(%eax)

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: RTO %u (%u miliseconds)\n",
           pcb->rto, pcb->rto * TCP_SLOW_INTERVAL));

      pcb->rttest = 0;
  1140e6:	8b 45 08             	mov    0x8(%ebp),%eax
  1140e9:	66 c7 40 36 00 00    	movw   $0x0,0x36(%eax)
    }
  }

  /* If the incoming segment contains data, we must process it
     further. */
  if (tcplen > 0) {
  1140ef:	0f b7 05 16 99 13 00 	movzwl 0x139916,%eax
  1140f6:	66 85 c0             	test   %ax,%ax
  1140f9:	0f 84 31 09 00 00    	je     114a30 <tcp_receive+0xfb0>
    /* This code basically does three things:

     +) If the incoming segment contains data that is the next
        in-sequence data, this data is passed to the application. This
        might involve trimming the first edge of the data. The rcv_nxt
        variable and the advertised window are adjusted.

     +) If the incoming segment has data that is above the next
        sequence number expected (->rcv_nxt), the segment is placed on
        the ->ooseq queue. This is done by finding the appropriate
        place in the ->ooseq queue (which is ordered by sequence
        number) and trim the segment in both ends if needed. An
        immediate ACK is sent to indicate that we received an
        out-of-sequence segment.

     +) Finally, we check if the first segment on the ->ooseq queue
        now is in sequence (i.e., if rcv_nxt >= ooseq->seqno). If
        rcv_nxt > ooseq->seqno, we must trim the first edge of the
        segment on ->ooseq before we adjust rcv_nxt. The data in the
        segments that are now on sequence are chained onto the
        incoming segment so that we only need to call the application
        once.
    */

    /* First, we check if we must trim the first edge. We have to do
       this if the sequence number of the incoming segment is less
       than rcv_nxt, and the sequence number plus the length of the
       segment is larger than rcv_nxt. */
    if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
  1140ff:	a1 0c 99 13 00       	mov    0x13990c,%eax
  114104:	89 c2                	mov    %eax,%edx
  114106:	8b 45 08             	mov    0x8(%ebp),%eax
  114109:	8b 40 24             	mov    0x24(%eax),%eax
  11410c:	89 d3                	mov    %edx,%ebx
  11410e:	66 29 c3             	sub    %ax,%bx
  114111:	89 d8                	mov    %ebx,%eax
  114113:	66 85 c0             	test   %ax,%ax
  114116:	0f 89 57 01 00 00    	jns    114273 <tcp_receive+0x7f3>
      if (TCP_SEQ_LT(pcb->rcv_nxt, seqno + tcplen)) {
  11411c:	8b 45 08             	mov    0x8(%ebp),%eax
  11411f:	8b 40 24             	mov    0x24(%eax),%eax
  114122:	89 c1                	mov    %eax,%ecx
  114124:	a1 0c 99 13 00       	mov    0x13990c,%eax
  114129:	89 c2                	mov    %eax,%edx
  11412b:	0f b7 05 16 99 13 00 	movzwl 0x139916,%eax
  114132:	8d 04 02             	lea    (%edx,%eax,1),%eax
  114135:	89 ca                	mov    %ecx,%edx
  114137:	66 29 c2             	sub    %ax,%dx
  11413a:	89 d0                	mov    %edx,%eax
  11413c:	66 85 c0             	test   %ax,%ax
  11413f:	0f 89 11 01 00 00    	jns    114256 <tcp_receive+0x7d6>
  /* Trimming the first edge is done by pushing the payload
     pointer in the pbuf downwards. This is somewhat tricky since
     we do not want to discard the full contents of the pbuf up to
     the new starting point of the data since we have to keep the
     TCP header which is present in the first pbuf in the chain.

     What is done is really quite a nasty hack: the first pbuf in
     the pbuf chain is pointed to by inseg.p. Since we need to be
     able to deallocate the whole pbuf, we cannot change this
     inseg.p pointer to point to any of the later pbufs in the
     chain. Instead, we point the ->payload pointer in the first
     pbuf to data in one of the later pbufs. We also set the
     inseg.data pointer to point to the right place. This way, the
     ->p pointer will still point to the first pbuf, but the
     ->p->payload pointer will point to data in another pbuf.

     After we are done with adjusting the pbuf pointers we must
     adjust the ->data pointer in the seg and the segment
     length.*/
  off = pcb->rcv_nxt - seqno;
  114145:	8b 45 08             	mov    0x8(%ebp),%eax
  114148:	8b 40 24             	mov    0x24(%eax),%eax
  11414b:	89 c2                	mov    %eax,%edx
  11414d:	a1 0c 99 13 00       	mov    0x13990c,%eax
  114152:	89 d1                	mov    %edx,%ecx
  114154:	66 29 c1             	sub    %ax,%cx
  114157:	89 c8                	mov    %ecx,%eax
  114159:	66 89 45 ee          	mov    %ax,0xffffffee(%ebp)
  if (inseg.p->len < off) {
  11415d:	a1 f4 98 13 00       	mov    0x1398f4,%eax
  114162:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  114166:	0f b7 d0             	movzwl %ax,%edx
  114169:	0f bf 45 ee          	movswl 0xffffffee(%ebp),%eax
  11416d:	39 c2                	cmp    %eax,%edx
  11416f:	7d 7c                	jge    1141ed <tcp_receive+0x76d>
    p = inseg.p;
  114171:	a1 f4 98 13 00       	mov    0x1398f4,%eax
  114176:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
    while (p->len < off) {
  114179:	eb 48                	jmp    1141c3 <tcp_receive+0x743>
      off -= p->len;
  11417b:	0f b7 55 ee          	movzwl 0xffffffee(%ebp),%edx
  11417f:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  114182:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  114186:	89 d3                	mov    %edx,%ebx
  114188:	66 29 c3             	sub    %ax,%bx
  11418b:	89 d8                	mov    %ebx,%eax
  11418d:	66 89 45 ee          	mov    %ax,0xffffffee(%ebp)
      inseg.p->tot_len -= p->len;
  114191:	8b 0d f4 98 13 00    	mov    0x1398f4,%ecx
  114197:	a1 f4 98 13 00       	mov    0x1398f4,%eax
  11419c:	0f b7 50 08          	movzwl 0x8(%eax),%edx
  1141a0:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  1141a3:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  1141a7:	89 d3                	mov    %edx,%ebx
  1141a9:	66 29 c3             	sub    %ax,%bx
  1141ac:	89 d8                	mov    %ebx,%eax
  1141ae:	66 89 41 08          	mov    %ax,0x8(%ecx)
      p->len = 0;
  1141b2:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  1141b5:	66 c7 40 0a 00 00    	movw   $0x0,0xa(%eax)
      p = p->next;
  1141bb:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  1141be:	8b 00                	mov    (%eax),%eax
  1141c0:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
  1141c3:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  1141c6:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  1141ca:	0f b7 d0             	movzwl %ax,%edx
  1141cd:	0f bf 45 ee          	movswl 0xffffffee(%ebp),%eax
  1141d1:	39 c2                	cmp    %eax,%edx
  1141d3:	7c a6                	jl     11417b <tcp_receive+0x6fb>
    }
    pbuf_header(p, -off);
  1141d5:	0f b7 45 ee          	movzwl 0xffffffee(%ebp),%eax
  1141d9:	f7 d8                	neg    %eax
  1141db:	98                   	cwtl   
  1141dc:	89 44 24 04          	mov    %eax,0x4(%esp)
  1141e0:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  1141e3:	89 04 24             	mov    %eax,(%esp)
  1141e6:	e8 c5 b1 ff ff       	call   10f3b0 <pbuf_header>
  1141eb:	eb 19                	jmp    114206 <tcp_receive+0x786>
  } else {
    pbuf_header(inseg.p, -off);
  1141ed:	0f b7 45 ee          	movzwl 0xffffffee(%ebp),%eax
  1141f1:	f7 d8                	neg    %eax
  1141f3:	98                   	cwtl   
  1141f4:	8b 15 f4 98 13 00    	mov    0x1398f4,%edx
  1141fa:	89 44 24 04          	mov    %eax,0x4(%esp)
  1141fe:	89 14 24             	mov    %edx,(%esp)
  114201:	e8 aa b1 ff ff       	call   10f3b0 <pbuf_header>
  }
  inseg.dataptr = inseg.p->payload;
  114206:	a1 f4 98 13 00       	mov    0x1398f4,%eax
  11420b:	8b 40 04             	mov    0x4(%eax),%eax
  11420e:	a3 f8 98 13 00       	mov    %eax,0x1398f8
  inseg.len -= pcb->rcv_nxt - seqno;
  114213:	0f b7 0d fc 98 13 00 	movzwl 0x1398fc,%ecx
  11421a:	8b 45 08             	mov    0x8(%ebp),%eax
  11421d:	8b 40 24             	mov    0x24(%eax),%eax
  114220:	89 c2                	mov    %eax,%edx
  114222:	a1 0c 99 13 00       	mov    0x13990c,%eax
  114227:	89 d3                	mov    %edx,%ebx
  114229:	66 29 c3             	sub    %ax,%bx
  11422c:	89 d8                	mov    %ebx,%eax
  11422e:	89 ca                	mov    %ecx,%edx
  114230:	66 29 c2             	sub    %ax,%dx
  114233:	89 d0                	mov    %edx,%eax
  114235:	66 a3 fc 98 13 00    	mov    %ax,0x1398fc
  inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
  11423b:	8b 15 00 99 13 00    	mov    0x139900,%edx
  114241:	8b 45 08             	mov    0x8(%ebp),%eax
  114244:	8b 40 24             	mov    0x24(%eax),%eax
  114247:	a3 0c 99 13 00       	mov    %eax,0x13990c
  11424c:	a1 0c 99 13 00       	mov    0x13990c,%eax
  114251:	89 42 04             	mov    %eax,0x4(%edx)
  114254:	eb 1d                	jmp    114273 <tcp_receive+0x7f3>
      }
      else{
  /* the whole segment is < rcv_nxt */
  /* must be a duplicate of a packet that has already been correctly handled */

  LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: duplicate seqno %lu\n", seqno));
  tcp_ack_now(pcb);
  114256:	8b 45 08             	mov    0x8(%ebp),%eax
  114259:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  11425d:	89 c2                	mov    %eax,%edx
  11425f:	83 ca 02             	or     $0x2,%edx
  114262:	8b 45 08             	mov    0x8(%ebp),%eax
  114265:	88 50 20             	mov    %dl,0x20(%eax)
  114268:	8b 45 08             	mov    0x8(%ebp),%eax
  11426b:	89 04 24             	mov    %eax,(%esp)
  11426e:	e8 cd db ff ff       	call   111e40 <tcp_output>
      }
    }

    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_GEQ(seqno, pcb->rcv_nxt) &&
  114273:	a1 0c 99 13 00       	mov    0x13990c,%eax
  114278:	89 c2                	mov    %eax,%edx
  11427a:	8b 45 08             	mov    0x8(%ebp),%eax
  11427d:	8b 40 24             	mov    0x24(%eax),%eax
  114280:	89 d1                	mov    %edx,%ecx
  114282:	66 29 c1             	sub    %ax,%cx
  114285:	89 c8                	mov    %ecx,%eax
  114287:	66 85 c0             	test   %ax,%ax
  11428a:	0f 88 fb 07 00 00    	js     114a8b <tcp_receive+0x100b>
  114290:	a1 0c 99 13 00       	mov    0x13990c,%eax
  114295:	89 c1                	mov    %eax,%ecx
  114297:	8b 45 08             	mov    0x8(%ebp),%eax
  11429a:	8b 40 24             	mov    0x24(%eax),%eax
  11429d:	89 c2                	mov    %eax,%edx
  11429f:	8b 45 08             	mov    0x8(%ebp),%eax
  1142a2:	0f b7 40 28          	movzwl 0x28(%eax),%eax
  1142a6:	8d 04 02             	lea    (%edx,%eax,1),%eax
  1142a9:	89 cb                	mov    %ecx,%ebx
  1142ab:	66 29 c3             	sub    %ax,%bx
  1142ae:	89 d8                	mov    %ebx,%eax
  1142b0:	66 85 c0             	test   %ax,%ax
  1142b3:	0f 89 d2 07 00 00    	jns    114a8b <tcp_receive+0x100b>
       TCP_SEQ_LT(seqno, pcb->rcv_nxt + pcb->rcv_wnd)) {
      if (pcb->rcv_nxt == seqno) {
  1142b9:	8b 45 08             	mov    0x8(%ebp),%eax
  1142bc:	8b 50 24             	mov    0x24(%eax),%edx
  1142bf:	a1 0c 99 13 00       	mov    0x13990c,%eax
  1142c4:	39 c2                	cmp    %eax,%edx
  1142c6:	0f 85 fc 03 00 00    	jne    1146c8 <tcp_receive+0xc48>
  /* The incoming segment is the next in sequence. We check if
           we have to trim the end of the segment and update rcv_nxt
           and pass the data to the application. */
#if TCP_QUEUE_OOSEQ
  if (pcb->ooseq != NULL &&
  1142cc:	8b 45 08             	mov    0x8(%ebp),%eax
  1142cf:	8b 40 78             	mov    0x78(%eax),%eax
  1142d2:	85 c0                	test   %eax,%eax
  1142d4:	74 65                	je     11433b <tcp_receive+0x8bb>
  1142d6:	8b 45 08             	mov    0x8(%ebp),%eax
  1142d9:	8b 40 78             	mov    0x78(%eax),%eax
  1142dc:	8b 40 10             	mov    0x10(%eax),%eax
  1142df:	8b 40 04             	mov    0x4(%eax),%eax
  1142e2:	89 c1                	mov    %eax,%ecx
  1142e4:	0f b7 15 fc 98 13 00 	movzwl 0x1398fc,%edx
  1142eb:	a1 0c 99 13 00       	mov    0x13990c,%eax
  1142f0:	8d 04 02             	lea    (%edx,%eax,1),%eax
  1142f3:	89 ca                	mov    %ecx,%edx
  1142f5:	66 29 c2             	sub    %ax,%dx
  1142f8:	89 d0                	mov    %edx,%eax
  1142fa:	66 85 c0             	test   %ax,%ax
  1142fd:	7f 3c                	jg     11433b <tcp_receive+0x8bb>
     TCP_SEQ_LEQ(pcb->ooseq->tcphdr->seqno, seqno + inseg.len)) {
    /* We have to trim the second edge of the incoming
             segment. */
    inseg.len = pcb->ooseq->tcphdr->seqno - seqno;
  1142ff:	8b 45 08             	mov    0x8(%ebp),%eax
  114302:	8b 40 78             	mov    0x78(%eax),%eax
  114305:	8b 40 10             	mov    0x10(%eax),%eax
  114308:	8b 40 04             	mov    0x4(%eax),%eax
  11430b:	89 c2                	mov    %eax,%edx
  11430d:	a1 0c 99 13 00       	mov    0x13990c,%eax
  114312:	89 d1                	mov    %edx,%ecx
  114314:	66 29 c1             	sub    %ax,%cx
  114317:	89 c8                	mov    %ecx,%eax
  114319:	66 a3 fc 98 13 00    	mov    %ax,0x1398fc
    pbuf_realloc(inseg.p, inseg.len);
  11431f:	0f b7 05 fc 98 13 00 	movzwl 0x1398fc,%eax
  114326:	0f b7 c0             	movzwl %ax,%eax
  114329:	8b 15 f4 98 13 00    	mov    0x1398f4,%edx
  11432f:	89 44 24 04          	mov    %eax,0x4(%esp)
  114333:	89 14 24             	mov    %edx,(%esp)
  114336:	e8 65 af ff ff       	call   10f2a0 <pbuf_realloc>
  }
#endif /* TCP_QUEUE_OOSEQ */

  tcplen = TCP_TCPLEN(&inseg);
  11433b:	0f b7 1d fc 98 13 00 	movzwl 0x1398fc,%ebx
  114342:	66 89 5d b6          	mov    %bx,0xffffffb6(%ebp)
  114346:	a1 00 99 13 00       	mov    0x139900,%eax
  11434b:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  11434f:	0f b7 c0             	movzwl %ax,%eax
  114352:	89 04 24             	mov    %eax,(%esp)
  114355:	e8 46 9f ff ff       	call   10e2a0 <ntohs>
  11435a:	0f b7 c0             	movzwl %ax,%eax
  11435d:	83 e0 01             	and    $0x1,%eax
  114360:	84 c0                	test   %al,%al
  114362:	75 1e                	jne    114382 <tcp_receive+0x902>
  114364:	a1 00 99 13 00       	mov    0x139900,%eax
  114369:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  11436d:	0f b7 c0             	movzwl %ax,%eax
  114370:	89 04 24             	mov    %eax,(%esp)
  114373:	e8 28 9f ff ff       	call   10e2a0 <ntohs>
  114378:	0f b7 c0             	movzwl %ax,%eax
  11437b:	83 e0 02             	and    $0x2,%eax
  11437e:	85 c0                	test   %eax,%eax
  114380:	74 09                	je     11438b <tcp_receive+0x90b>
  114382:	c7 45 b8 01 00 00 00 	movl   $0x1,0xffffffb8(%ebp)
  114389:	eb 07                	jmp    114392 <tcp_receive+0x912>
  11438b:	c7 45 b8 00 00 00 00 	movl   $0x0,0xffffffb8(%ebp)
  114392:	0f b7 45 b8          	movzwl 0xffffffb8(%ebp),%eax
  114396:	66 03 45 b6          	add    0xffffffb6(%ebp),%ax
  11439a:	66 a3 16 99 13 00    	mov    %ax,0x139916

  pcb->rcv_nxt += tcplen;
  1143a0:	8b 45 08             	mov    0x8(%ebp),%eax
  1143a3:	8b 50 24             	mov    0x24(%eax),%edx
  1143a6:	0f b7 05 16 99 13 00 	movzwl 0x139916,%eax
  1143ad:	0f b7 c0             	movzwl %ax,%eax
  1143b0:	01 c2                	add    %eax,%edx
  1143b2:	8b 45 08             	mov    0x8(%ebp),%eax
  1143b5:	89 50 24             	mov    %edx,0x24(%eax)

  /* Update the receiver's (our) window. */
  if (pcb->rcv_wnd < tcplen) {
  1143b8:	8b 45 08             	mov    0x8(%ebp),%eax
  1143bb:	0f b7 50 28          	movzwl 0x28(%eax),%edx
  1143bf:	0f b7 05 16 99 13 00 	movzwl 0x139916,%eax
  1143c6:	66 39 c2             	cmp    %ax,%dx
  1143c9:	73 0b                	jae    1143d6 <tcp_receive+0x956>
    pcb->rcv_wnd = 0;
  1143cb:	8b 45 08             	mov    0x8(%ebp),%eax
  1143ce:	66 c7 40 28 00 00    	movw   $0x0,0x28(%eax)
  1143d4:	eb 18                	jmp    1143ee <tcp_receive+0x96e>
  } else {
    pcb->rcv_wnd -= tcplen;
  1143d6:	8b 45 08             	mov    0x8(%ebp),%eax
  1143d9:	0f b7 50 28          	movzwl 0x28(%eax),%edx
  1143dd:	0f b7 05 16 99 13 00 	movzwl 0x139916,%eax
  1143e4:	66 29 c2             	sub    %ax,%dx
  1143e7:	8b 45 08             	mov    0x8(%ebp),%eax
  1143ea:	66 89 50 28          	mov    %dx,0x28(%eax)
  }

  /* If there is data in the segment, we make preparations to
     pass this up to the application. The ->recv_data variable
     is used for holding the pbuf that goes to the
     application. The code for reassembling out-of-sequence data
     chains its data on this pbuf as well.

     If the segment was a FIN, we set the TF_GOT_FIN flag that will
     be used to indicate to the application that the remote side has
     closed its end of the connection. */
  if (inseg.p->tot_len > 0) {
  1143ee:	a1 f4 98 13 00       	mov    0x1398f4,%eax
  1143f3:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  1143f7:	66 85 c0             	test   %ax,%ax
  1143fa:	74 14                	je     114410 <tcp_receive+0x990>
    recv_data = inseg.p;
  1143fc:	a1 f4 98 13 00       	mov    0x1398f4,%eax
  114401:	a3 1c 99 13 00       	mov    %eax,0x13991c
    /* Since this pbuf now is the responsibility of the
       application, we delete our reference to it so that we won't
       (mistakingly) deallocate it. */
    inseg.p = NULL;
  114406:	c7 05 f4 98 13 00 00 	movl   $0x0,0x1398f4
  11440d:	00 00 00 
  }
  if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
  114410:	a1 00 99 13 00       	mov    0x139900,%eax
  114415:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  114419:	0f b7 c0             	movzwl %ax,%eax
  11441c:	89 04 24             	mov    %eax,(%esp)
  11441f:	e8 7c 9e ff ff       	call   10e2a0 <ntohs>
  114424:	0f b7 c0             	movzwl %ax,%eax
  114427:	83 e0 01             	and    $0x1,%eax
  11442a:	84 c0                	test   %al,%al
  11442c:	0f 84 16 02 00 00    	je     114648 <tcp_receive+0xbc8>
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: received FIN.\n"));
    recv_flags = TF_GOT_FIN;
  114432:	c6 05 18 99 13 00 20 	movb   $0x20,0x139918
  }

#if TCP_QUEUE_OOSEQ
  /* We now check if we have segments on the ->ooseq queue that
           is now in sequence. */
  while (pcb->ooseq != NULL &&
  114439:	e9 0a 02 00 00       	jmp    114648 <tcp_receive+0xbc8>
        pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {

    cseg = pcb->ooseq;
  11443e:	8b 45 08             	mov    0x8(%ebp),%eax
  114441:	8b 40 78             	mov    0x78(%eax),%eax
  114444:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
    seqno = pcb->ooseq->tcphdr->seqno;
  114447:	8b 45 08             	mov    0x8(%ebp),%eax
  11444a:	8b 40 78             	mov    0x78(%eax),%eax
  11444d:	8b 40 10             	mov    0x10(%eax),%eax
  114450:	8b 40 04             	mov    0x4(%eax),%eax
  114453:	a3 0c 99 13 00       	mov    %eax,0x13990c

    pcb->rcv_nxt += TCP_TCPLEN(cseg);
  114458:	8b 45 08             	mov    0x8(%ebp),%eax
  11445b:	8b 40 24             	mov    0x24(%eax),%eax
  11445e:	89 45 bc             	mov    %eax,0xffffffbc(%ebp)
  114461:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
  114464:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  114468:	0f b7 c0             	movzwl %ax,%eax
  11446b:	89 45 c0             	mov    %eax,0xffffffc0(%ebp)
  11446e:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
  114471:	8b 40 10             	mov    0x10(%eax),%eax
  114474:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  114478:	0f b7 c0             	movzwl %ax,%eax
  11447b:	89 04 24             	mov    %eax,(%esp)
  11447e:	e8 1d 9e ff ff       	call   10e2a0 <ntohs>
  114483:	0f b7 c0             	movzwl %ax,%eax
  114486:	83 e0 01             	and    $0x1,%eax
  114489:	84 c0                	test   %al,%al
  11448b:	75 1f                	jne    1144ac <tcp_receive+0xa2c>
  11448d:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
  114490:	8b 40 10             	mov    0x10(%eax),%eax
  114493:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  114497:	0f b7 c0             	movzwl %ax,%eax
  11449a:	89 04 24             	mov    %eax,(%esp)
  11449d:	e8 fe 9d ff ff       	call   10e2a0 <ntohs>
  1144a2:	0f b7 c0             	movzwl %ax,%eax
  1144a5:	83 e0 02             	and    $0x2,%eax
  1144a8:	85 c0                	test   %eax,%eax
  1144aa:	74 09                	je     1144b5 <tcp_receive+0xa35>
  1144ac:	c7 45 c4 01 00 00 00 	movl   $0x1,0xffffffc4(%ebp)
  1144b3:	eb 07                	jmp    1144bc <tcp_receive+0xa3c>
  1144b5:	c7 45 c4 00 00 00 00 	movl   $0x0,0xffffffc4(%ebp)
  1144bc:	8b 45 c0             	mov    0xffffffc0(%ebp),%eax
  1144bf:	03 45 c4             	add    0xffffffc4(%ebp),%eax
  1144c2:	8b 55 bc             	mov    0xffffffbc(%ebp),%edx
  1144c5:	01 c2                	add    %eax,%edx
  1144c7:	8b 45 08             	mov    0x8(%ebp),%eax
  1144ca:	89 50 24             	mov    %edx,0x24(%eax)
    if (pcb->rcv_wnd < TCP_TCPLEN(cseg)) {
  1144cd:	8b 45 08             	mov    0x8(%ebp),%eax
  1144d0:	0f b7 40 28          	movzwl 0x28(%eax),%eax
  1144d4:	0f b7 c0             	movzwl %ax,%eax
  1144d7:	89 45 c8             	mov    %eax,0xffffffc8(%ebp)
  1144da:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
  1144dd:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  1144e1:	0f b7 c0             	movzwl %ax,%eax
  1144e4:	89 45 cc             	mov    %eax,0xffffffcc(%ebp)
  1144e7:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
  1144ea:	8b 40 10             	mov    0x10(%eax),%eax
  1144ed:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  1144f1:	0f b7 c0             	movzwl %ax,%eax
  1144f4:	89 04 24             	mov    %eax,(%esp)
  1144f7:	e8 a4 9d ff ff       	call   10e2a0 <ntohs>
  1144fc:	0f b7 c0             	movzwl %ax,%eax
  1144ff:	83 e0 01             	and    $0x1,%eax
  114502:	84 c0                	test   %al,%al
  114504:	75 1f                	jne    114525 <tcp_receive+0xaa5>
  114506:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
  114509:	8b 40 10             	mov    0x10(%eax),%eax
  11450c:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  114510:	0f b7 c0             	movzwl %ax,%eax
  114513:	89 04 24             	mov    %eax,(%esp)
  114516:	e8 85 9d ff ff       	call   10e2a0 <ntohs>
  11451b:	0f b7 c0             	movzwl %ax,%eax
  11451e:	83 e0 02             	and    $0x2,%eax
  114521:	85 c0                	test   %eax,%eax
  114523:	74 09                	je     11452e <tcp_receive+0xaae>
  114525:	c7 45 d0 01 00 00 00 	movl   $0x1,0xffffffd0(%ebp)
  11452c:	eb 07                	jmp    114535 <tcp_receive+0xab5>
  11452e:	c7 45 d0 00 00 00 00 	movl   $0x0,0xffffffd0(%ebp)
  114535:	8b 45 cc             	mov    0xffffffcc(%ebp),%eax
  114538:	03 45 d0             	add    0xffffffd0(%ebp),%eax
  11453b:	39 45 c8             	cmp    %eax,0xffffffc8(%ebp)
  11453e:	7d 0b                	jge    11454b <tcp_receive+0xacb>
      pcb->rcv_wnd = 0;
  114540:	8b 45 08             	mov    0x8(%ebp),%eax
  114543:	66 c7 40 28 00 00    	movw   $0x0,0x28(%eax)
  114549:	eb 7a                	jmp    1145c5 <tcp_receive+0xb45>
    } else {
      pcb->rcv_wnd -= TCP_TCPLEN(cseg);
  11454b:	8b 45 08             	mov    0x8(%ebp),%eax
  11454e:	0f b7 40 28          	movzwl 0x28(%eax),%eax
  114552:	66 89 45 d4          	mov    %ax,0xffffffd4(%ebp)
  114556:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
  114559:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  11455d:	66 89 45 d6          	mov    %ax,0xffffffd6(%ebp)
  114561:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
  114564:	8b 40 10             	mov    0x10(%eax),%eax
  114567:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  11456b:	0f b7 c0             	movzwl %ax,%eax
  11456e:	89 04 24             	mov    %eax,(%esp)
  114571:	e8 2a 9d ff ff       	call   10e2a0 <ntohs>
  114576:	0f b7 c0             	movzwl %ax,%eax
  114579:	83 e0 01             	and    $0x1,%eax
  11457c:	84 c0                	test   %al,%al
  11457e:	75 1f                	jne    11459f <tcp_receive+0xb1f>
  114580:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
  114583:	8b 40 10             	mov    0x10(%eax),%eax
  114586:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  11458a:	0f b7 c0             	movzwl %ax,%eax
  11458d:	89 04 24             	mov    %eax,(%esp)
  114590:	e8 0b 9d ff ff       	call   10e2a0 <ntohs>
  114595:	0f b7 c0             	movzwl %ax,%eax
  114598:	83 e0 02             	and    $0x2,%eax
  11459b:	85 c0                	test   %eax,%eax
  11459d:	74 09                	je     1145a8 <tcp_receive+0xb28>
  11459f:	c7 45 d8 01 00 00 00 	movl   $0x1,0xffffffd8(%ebp)
  1145a6:	eb 07                	jmp    1145af <tcp_receive+0xb2f>
  1145a8:	c7 45 d8 00 00 00 00 	movl   $0x0,0xffffffd8(%ebp)
  1145af:	0f b7 45 d8          	movzwl 0xffffffd8(%ebp),%eax
  1145b3:	66 03 45 d6          	add    0xffffffd6(%ebp),%ax
  1145b7:	0f b7 55 d4          	movzwl 0xffffffd4(%ebp),%edx
  1145bb:	66 29 c2             	sub    %ax,%dx
  1145be:	8b 45 08             	mov    0x8(%ebp),%eax
  1145c1:	66 89 50 28          	mov    %dx,0x28(%eax)
    }
    if (cseg->p->tot_len > 0) {
  1145c5:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
  1145c8:	8b 40 04             	mov    0x4(%eax),%eax
  1145cb:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  1145cf:	66 85 c0             	test   %ax,%ax
  1145d2:	74 38                	je     11460c <tcp_receive+0xb8c>
      /* Chain this pbuf onto the pbuf that we will pass to
         the application. */
      if (recv_data) {
  1145d4:	a1 1c 99 13 00       	mov    0x13991c,%eax
  1145d9:	85 c0                	test   %eax,%eax
  1145db:	74 1a                	je     1145f7 <tcp_receive+0xb77>
              pbuf_cat(recv_data, cseg->p);
  1145dd:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
  1145e0:	8b 40 04             	mov    0x4(%eax),%eax
  1145e3:	8b 15 1c 99 13 00    	mov    0x13991c,%edx
  1145e9:	89 44 24 04          	mov    %eax,0x4(%esp)
  1145ed:	89 14 24             	mov    %edx,(%esp)
  1145f0:	e8 4b b0 ff ff       	call   10f640 <pbuf_cat>
  1145f5:	eb 0b                	jmp    114602 <tcp_receive+0xb82>
            } else {
        recv_data = cseg->p;
  1145f7:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
  1145fa:	8b 40 04             	mov    0x4(%eax),%eax
  1145fd:	a3 1c 99 13 00       	mov    %eax,0x13991c
      }
      cseg->p = NULL;
  114602:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
  114605:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    }
    if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
  11460c:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
  11460f:	8b 40 10             	mov    0x10(%eax),%eax
  114612:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  114616:	0f b7 c0             	movzwl %ax,%eax
  114619:	89 04 24             	mov    %eax,(%esp)
  11461c:	e8 7f 9c ff ff       	call   10e2a0 <ntohs>
  114621:	0f b7 c0             	movzwl %ax,%eax
  114624:	83 e0 01             	and    $0x1,%eax
  114627:	84 c0                	test   %al,%al
  114629:	74 07                	je     114632 <tcp_receive+0xbb2>
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: dequeued FIN.\n"));
      recv_flags = TF_GOT_FIN;
  11462b:	c6 05 18 99 13 00 20 	movb   $0x20,0x139918
    }


    pcb->ooseq = cseg->next;
  114632:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
  114635:	8b 10                	mov    (%eax),%edx
  114637:	8b 45 08             	mov    0x8(%ebp),%eax
  11463a:	89 50 78             	mov    %edx,0x78(%eax)
    tcp_seg_free(cseg);
  11463d:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
  114640:	89 04 24             	mov    %eax,(%esp)
  114643:	e8 c8 ca ff ff       	call   111110 <tcp_seg_free>
  114648:	8b 45 08             	mov    0x8(%ebp),%eax
  11464b:	8b 40 78             	mov    0x78(%eax),%eax
  11464e:	85 c0                	test   %eax,%eax
  114650:	74 1a                	je     11466c <tcp_receive+0xbec>
  114652:	8b 45 08             	mov    0x8(%ebp),%eax
  114655:	8b 40 78             	mov    0x78(%eax),%eax
  114658:	8b 40 10             	mov    0x10(%eax),%eax
  11465b:	8b 50 04             	mov    0x4(%eax),%edx
  11465e:	8b 45 08             	mov    0x8(%ebp),%eax
  114661:	8b 40 24             	mov    0x24(%eax),%eax
  114664:	39 c2                	cmp    %eax,%edx
  114666:	0f 84 d2 fd ff ff    	je     11443e <tcp_receive+0x9be>
  }
#endif /* TCP_QUEUE_OOSEQ */


  /* Acknowledge the segment(s). */
  tcp_ack(pcb);
  11466c:	8b 45 08             	mov    0x8(%ebp),%eax
  11466f:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  114673:	0f b6 c0             	movzbl %al,%eax
  114676:	83 e0 01             	and    $0x1,%eax
  114679:	84 c0                	test   %al,%al
  11467b:	74 34                	je     1146b1 <tcp_receive+0xc31>
  11467d:	8b 45 08             	mov    0x8(%ebp),%eax
  114680:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  114684:	89 c2                	mov    %eax,%edx
  114686:	83 e2 fe             	and    $0xfffffffe,%edx
  114689:	8b 45 08             	mov    0x8(%ebp),%eax
  11468c:	88 50 20             	mov    %dl,0x20(%eax)
  11468f:	8b 45 08             	mov    0x8(%ebp),%eax
  114692:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  114696:	89 c2                	mov    %eax,%edx
  114698:	83 ca 02             	or     $0x2,%edx
  11469b:	8b 45 08             	mov    0x8(%ebp),%eax
  11469e:	88 50 20             	mov    %dl,0x20(%eax)
  1146a1:	8b 45 08             	mov    0x8(%ebp),%eax
  1146a4:	89 04 24             	mov    %eax,(%esp)
  1146a7:	e8 94 d7 ff ff       	call   111e40 <tcp_output>
  1146ac:	e9 da 03 00 00       	jmp    114a8b <tcp_receive+0x100b>
  1146b1:	8b 45 08             	mov    0x8(%ebp),%eax
  1146b4:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  1146b8:	89 c2                	mov    %eax,%edx
  1146ba:	83 ca 01             	or     $0x1,%edx
  1146bd:	8b 45 08             	mov    0x8(%ebp),%eax
  1146c0:	88 50 20             	mov    %dl,0x20(%eax)
  1146c3:	e9 c3 03 00 00       	jmp    114a8b <tcp_receive+0x100b>

      } else {
  /* We get here if the incoming segment is out-of-sequence. */
  tcp_ack_now(pcb);
  1146c8:	8b 45 08             	mov    0x8(%ebp),%eax
  1146cb:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  1146cf:	89 c2                	mov    %eax,%edx
  1146d1:	83 ca 02             	or     $0x2,%edx
  1146d4:	8b 45 08             	mov    0x8(%ebp),%eax
  1146d7:	88 50 20             	mov    %dl,0x20(%eax)
  1146da:	8b 45 08             	mov    0x8(%ebp),%eax
  1146dd:	89 04 24             	mov    %eax,(%esp)
  1146e0:	e8 5b d7 ff ff       	call   111e40 <tcp_output>
#if TCP_QUEUE_OOSEQ
  /* We queue the segment on the ->ooseq queue. */
  if (pcb->ooseq == NULL) {
  1146e5:	8b 45 08             	mov    0x8(%ebp),%eax
  1146e8:	8b 40 78             	mov    0x78(%eax),%eax
  1146eb:	85 c0                	test   %eax,%eax
  1146ed:	75 19                	jne    114708 <tcp_receive+0xc88>
    pcb->ooseq = tcp_seg_copy(&inseg);
  1146ef:	c7 04 24 f0 98 13 00 	movl   $0x1398f0,(%esp)
  1146f6:	e8 85 ca ff ff       	call   111180 <tcp_seg_copy>
  1146fb:	89 c2                	mov    %eax,%edx
  1146fd:	8b 45 08             	mov    0x8(%ebp),%eax
  114700:	89 50 78             	mov    %edx,0x78(%eax)
  114703:	e9 83 03 00 00       	jmp    114a8b <tcp_receive+0x100b>
  } else {
    /* If the queue is not empty, we walk through the queue and
    try to find a place where the sequence number of the
    incoming segment is between the sequence numbers of the
    previous and the next segment on the ->ooseq queue. That is
    the place where we put the incoming segment. If needed, we
    trim the second edges of the previous and the incoming
    segment so that it will fit into the sequence.

    If the incoming segment has the same sequence number as a
    segment on the ->ooseq queue, we discard the segment that
    contains less data. */

    prev = NULL;
  114708:	c7 45 e0 00 00 00 00 	movl   $0x0,0xffffffe0(%ebp)
    for(next = pcb->ooseq; next != NULL; next = next->next) {
  11470f:	8b 45 08             	mov    0x8(%ebp),%eax
  114712:	8b 40 78             	mov    0x78(%eax),%eax
  114715:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
  114718:	e9 07 03 00 00       	jmp    114a24 <tcp_receive+0xfa4>
      if (seqno == next->tcphdr->seqno) {
  11471d:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  114720:	8b 40 10             	mov    0x10(%eax),%eax
  114723:	8b 50 04             	mov    0x4(%eax),%edx
  114726:	a1 0c 99 13 00       	mov    0x13990c,%eax
  11472b:	39 c2                	cmp    %eax,%edx
  11472d:	75 5b                	jne    11478a <tcp_receive+0xd0a>
        /* The sequence number of the incoming segment is the
                 same as the sequence number of the segment on
                 ->ooseq. We check the lengths to see which one to
                 discard. */
        if (inseg.len > next->len) {
  11472f:	0f b7 05 fc 98 13 00 	movzwl 0x1398fc,%eax
  114736:	8b 55 dc             	mov    0xffffffdc(%ebp),%edx
  114739:	0f b7 52 0c          	movzwl 0xc(%edx),%edx
  11473d:	66 39 d0             	cmp    %dx,%ax
  114740:	0f 86 45 03 00 00    	jbe    114a8b <tcp_receive+0x100b>
    /* The incoming segment is larger than the old
                   segment. We replace the old segment with the new
                   one. */
    cseg = tcp_seg_copy(&inseg);
  114746:	c7 04 24 f0 98 13 00 	movl   $0x1398f0,(%esp)
  11474d:	e8 2e ca ff ff       	call   111180 <tcp_seg_copy>
  114752:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
    if (cseg != NULL) {
  114755:	83 7d e4 00          	cmpl   $0x0,0xffffffe4(%ebp)
  114759:	0f 84 2c 03 00 00    	je     114a8b <tcp_receive+0x100b>
      cseg->next = next->next;
  11475f:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  114762:	8b 10                	mov    (%eax),%edx
  114764:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
  114767:	89 10                	mov    %edx,(%eax)
      if (prev != NULL) {
  114769:	83 7d e0 00          	cmpl   $0x0,0xffffffe0(%ebp)
  11476d:	74 0d                	je     11477c <tcp_receive+0xcfc>
        prev->next = cseg;
  11476f:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
  114772:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
  114775:	89 02                	mov    %eax,(%edx)
  114777:	e9 0f 03 00 00       	jmp    114a8b <tcp_receive+0x100b>
      } else {
        pcb->ooseq = cseg;
  11477c:	8b 55 08             	mov    0x8(%ebp),%edx
  11477f:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
  114782:	89 42 78             	mov    %eax,0x78(%edx)
      }
    }
    break;
  114785:	e9 01 03 00 00       	jmp    114a8b <tcp_receive+0x100b>
        } else {
    /* Either the lenghts are the same or the incoming
                   segment was smaller than the old one; in either
                   case, we ditch the incoming segment. */
    break;
        }
      } else {
        if (prev == NULL) {
  11478a:	83 7d e0 00          	cmpl   $0x0,0xffffffe0(%ebp)
  11478e:	0f 85 ab 00 00 00    	jne    11483f <tcp_receive+0xdbf>
    if (TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {
  114794:	a1 0c 99 13 00       	mov    0x13990c,%eax
  114799:	89 c2                	mov    %eax,%edx
  11479b:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  11479e:	8b 40 10             	mov    0x10(%eax),%eax
  1147a1:	8b 40 04             	mov    0x4(%eax),%eax
  1147a4:	89 d1                	mov    %edx,%ecx
  1147a6:	66 29 c1             	sub    %ax,%cx
  1147a9:	89 c8                	mov    %ecx,%eax
  1147ab:	66 85 c0             	test   %ax,%ax
  1147ae:	0f 89 b4 01 00 00    	jns    114968 <tcp_receive+0xee8>
      /* The sequence number of the incoming segment is lower
         than the sequence number of the first segment on the
         queue. We put the incoming segment first on the
         queue. */

      if (TCP_SEQ_GT(seqno + inseg.len, next->tcphdr->seqno)) {
  1147b4:	0f b7 15 fc 98 13 00 	movzwl 0x1398fc,%edx
  1147bb:	a1 0c 99 13 00       	mov    0x13990c,%eax
  1147c0:	01 c2                	add    %eax,%edx
  1147c2:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  1147c5:	8b 40 10             	mov    0x10(%eax),%eax
  1147c8:	8b 40 04             	mov    0x4(%eax),%eax
  1147cb:	89 d3                	mov    %edx,%ebx
  1147cd:	66 29 c3             	sub    %ax,%bx
  1147d0:	89 d8                	mov    %ebx,%eax
  1147d2:	66 85 c0             	test   %ax,%ax
  1147d5:	7e 39                	jle    114810 <tcp_receive+0xd90>
        /* We need to trim the incoming segment. */
        inseg.len = next->tcphdr->seqno - seqno;
  1147d7:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  1147da:	8b 40 10             	mov    0x10(%eax),%eax
  1147dd:	8b 40 04             	mov    0x4(%eax),%eax
  1147e0:	89 c2                	mov    %eax,%edx
  1147e2:	a1 0c 99 13 00       	mov    0x13990c,%eax
  1147e7:	89 d1                	mov    %edx,%ecx
  1147e9:	66 29 c1             	sub    %ax,%cx
  1147ec:	89 c8                	mov    %ecx,%eax
  1147ee:	66 a3 fc 98 13 00    	mov    %ax,0x1398fc
        pbuf_realloc(inseg.p, inseg.len);
  1147f4:	0f b7 05 fc 98 13 00 	movzwl 0x1398fc,%eax
  1147fb:	0f b7 c0             	movzwl %ax,%eax
  1147fe:	8b 15 f4 98 13 00    	mov    0x1398f4,%edx
  114804:	89 44 24 04          	mov    %eax,0x4(%esp)
  114808:	89 14 24             	mov    %edx,(%esp)
  11480b:	e8 90 aa ff ff       	call   10f2a0 <pbuf_realloc>
      }
      cseg = tcp_seg_copy(&inseg);
  114810:	c7 04 24 f0 98 13 00 	movl   $0x1398f0,(%esp)
  114817:	e8 64 c9 ff ff       	call   111180 <tcp_seg_copy>
  11481c:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
      if (cseg != NULL) {
  11481f:	83 7d e4 00          	cmpl   $0x0,0xffffffe4(%ebp)
  114823:	0f 84 62 02 00 00    	je     114a8b <tcp_receive+0x100b>
        cseg->next = next;
  114829:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
  11482c:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  11482f:	89 02                	mov    %eax,(%edx)
        pcb->ooseq = cseg;
  114831:	8b 55 08             	mov    0x8(%ebp),%edx
  114834:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
  114837:	89 42 78             	mov    %eax,0x78(%edx)
      }
      break;
  11483a:	e9 4c 02 00 00       	jmp    114a8b <tcp_receive+0x100b>
    }
        } else if (TCP_SEQ_LT(prev->tcphdr->seqno, seqno) &&
  11483f:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  114842:	8b 40 10             	mov    0x10(%eax),%eax
  114845:	8b 40 04             	mov    0x4(%eax),%eax
  114848:	89 c2                	mov    %eax,%edx
  11484a:	a1 0c 99 13 00       	mov    0x13990c,%eax
  11484f:	89 d3                	mov    %edx,%ebx
  114851:	66 29 c3             	sub    %ax,%bx
  114854:	89 d8                	mov    %ebx,%eax
  114856:	66 85 c0             	test   %ax,%ax
  114859:	0f 89 09 01 00 00    	jns    114968 <tcp_receive+0xee8>
  11485f:	a1 0c 99 13 00       	mov    0x13990c,%eax
  114864:	89 c2                	mov    %eax,%edx
  114866:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  114869:	8b 40 10             	mov    0x10(%eax),%eax
  11486c:	8b 40 04             	mov    0x4(%eax),%eax
  11486f:	89 d1                	mov    %edx,%ecx
  114871:	66 29 c1             	sub    %ax,%cx
  114874:	89 c8                	mov    %ecx,%eax
  114876:	66 85 c0             	test   %ax,%ax
  114879:	0f 89 e9 00 00 00    	jns    114968 <tcp_receive+0xee8>
     TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {
    /* The sequence number of the incoming segment is in
                   between the sequence numbers of the previous and
                   the next segment on ->ooseq. We trim and insert the
                   incoming segment and trim the previous segment, if
                   needed. */
    if (TCP_SEQ_GT(seqno + inseg.len, next->tcphdr->seqno)) {
  11487f:	0f b7 15 fc 98 13 00 	movzwl 0x1398fc,%edx
  114886:	a1 0c 99 13 00       	mov    0x13990c,%eax
  11488b:	01 c2                	add    %eax,%edx
  11488d:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  114890:	8b 40 10             	mov    0x10(%eax),%eax
  114893:	8b 40 04             	mov    0x4(%eax),%eax
  114896:	89 d3                	mov    %edx,%ebx
  114898:	66 29 c3             	sub    %ax,%bx
  11489b:	89 d8                	mov    %ebx,%eax
  11489d:	66 85 c0             	test   %ax,%ax
  1148a0:	7e 39                	jle    1148db <tcp_receive+0xe5b>
      /* We need to trim the incoming segment. */
      inseg.len = next->tcphdr->seqno - seqno;
  1148a2:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  1148a5:	8b 40 10             	mov    0x10(%eax),%eax
  1148a8:	8b 40 04             	mov    0x4(%eax),%eax
  1148ab:	89 c2                	mov    %eax,%edx
  1148ad:	a1 0c 99 13 00       	mov    0x13990c,%eax
  1148b2:	89 d1                	mov    %edx,%ecx
  1148b4:	66 29 c1             	sub    %ax,%cx
  1148b7:	89 c8                	mov    %ecx,%eax
  1148b9:	66 a3 fc 98 13 00    	mov    %ax,0x1398fc
      pbuf_realloc(inseg.p, inseg.len);
  1148bf:	0f b7 05 fc 98 13 00 	movzwl 0x1398fc,%eax
  1148c6:	0f b7 c0             	movzwl %ax,%eax
  1148c9:	8b 15 f4 98 13 00    	mov    0x1398f4,%edx
  1148cf:	89 44 24 04          	mov    %eax,0x4(%esp)
  1148d3:	89 14 24             	mov    %edx,(%esp)
  1148d6:	e8 c5 a9 ff ff       	call   10f2a0 <pbuf_realloc>
    }

    cseg = tcp_seg_copy(&inseg);
  1148db:	c7 04 24 f0 98 13 00 	movl   $0x1398f0,(%esp)
  1148e2:	e8 99 c8 ff ff       	call   111180 <tcp_seg_copy>
  1148e7:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
    if (cseg != NULL) {
  1148ea:	83 7d e4 00          	cmpl   $0x0,0xffffffe4(%ebp)
  1148ee:	0f 84 97 01 00 00    	je     114a8b <tcp_receive+0x100b>
      cseg->next = next;
  1148f4:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
  1148f7:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  1148fa:	89 02                	mov    %eax,(%edx)
      prev->next = cseg;
  1148fc:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
  1148ff:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
  114902:	89 02                	mov    %eax,(%edx)
      if (TCP_SEQ_GT(prev->tcphdr->seqno + prev->len, seqno)) {
  114904:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  114907:	8b 40 10             	mov    0x10(%eax),%eax
  11490a:	8b 40 04             	mov    0x4(%eax),%eax
  11490d:	89 c2                	mov    %eax,%edx
  11490f:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  114912:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  114916:	01 c2                	add    %eax,%edx
  114918:	a1 0c 99 13 00       	mov    0x13990c,%eax
  11491d:	89 d3                	mov    %edx,%ebx
  11491f:	66 29 c3             	sub    %ax,%bx
  114922:	89 d8                	mov    %ebx,%eax
  114924:	66 85 c0             	test   %ax,%ax
  114927:	0f 8e 5e 01 00 00    	jle    114a8b <tcp_receive+0x100b>
        /* We need to trim the prev segment. */
        prev->len = seqno - prev->tcphdr->seqno;
  11492d:	a1 0c 99 13 00       	mov    0x13990c,%eax
  114932:	89 c2                	mov    %eax,%edx
  114934:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  114937:	8b 40 10             	mov    0x10(%eax),%eax
  11493a:	8b 40 04             	mov    0x4(%eax),%eax
  11493d:	66 29 c2             	sub    %ax,%dx
  114940:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  114943:	66 89 50 0c          	mov    %dx,0xc(%eax)
        pbuf_realloc(prev->p, prev->len);
  114947:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  11494a:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  11494e:	0f b7 d0             	movzwl %ax,%edx
  114951:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  114954:	8b 40 04             	mov    0x4(%eax),%eax
  114957:	89 54 24 04          	mov    %edx,0x4(%esp)
  11495b:	89 04 24             	mov    %eax,(%esp)
  11495e:	e8 3d a9 ff ff       	call   10f2a0 <pbuf_realloc>
      }
    }
    break;
  114963:	e9 23 01 00 00       	jmp    114a8b <tcp_receive+0x100b>
    }
        /* If the "next" segment is the last segment on the
                 ooseq queue, we add the incoming segment to the end
                 of the list. */
        if (next->next == NULL &&
  114968:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  11496b:	8b 00                	mov    (%eax),%eax
  11496d:	85 c0                	test   %eax,%eax
  11496f:	0f 85 a1 00 00 00    	jne    114a16 <tcp_receive+0xf96>
  114975:	a1 0c 99 13 00       	mov    0x13990c,%eax
  11497a:	89 c2                	mov    %eax,%edx
  11497c:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  11497f:	8b 40 10             	mov    0x10(%eax),%eax
  114982:	8b 40 04             	mov    0x4(%eax),%eax
  114985:	89 d1                	mov    %edx,%ecx
  114987:	66 29 c1             	sub    %ax,%cx
  11498a:	89 c8                	mov    %ecx,%eax
  11498c:	66 85 c0             	test   %ax,%ax
  11498f:	0f 8e 81 00 00 00    	jle    114a16 <tcp_receive+0xf96>
     TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
    next->next = tcp_seg_copy(&inseg);
  114995:	c7 04 24 f0 98 13 00 	movl   $0x1398f0,(%esp)
  11499c:	e8 df c7 ff ff       	call   111180 <tcp_seg_copy>
  1149a1:	89 c2                	mov    %eax,%edx
  1149a3:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  1149a6:	89 10                	mov    %edx,(%eax)
    if (next->next != NULL) {
  1149a8:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  1149ab:	8b 00                	mov    (%eax),%eax
  1149ad:	85 c0                	test   %eax,%eax
  1149af:	0f 84 d6 00 00 00    	je     114a8b <tcp_receive+0x100b>
      if (TCP_SEQ_GT(next->tcphdr->seqno + next->len, seqno)) {
  1149b5:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  1149b8:	8b 40 10             	mov    0x10(%eax),%eax
  1149bb:	8b 40 04             	mov    0x4(%eax),%eax
  1149be:	89 c2                	mov    %eax,%edx
  1149c0:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  1149c3:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  1149c7:	01 c2                	add    %eax,%edx
  1149c9:	a1 0c 99 13 00       	mov    0x13990c,%eax
  1149ce:	89 d3                	mov    %edx,%ebx
  1149d0:	66 29 c3             	sub    %ax,%bx
  1149d3:	89 d8                	mov    %ebx,%eax
  1149d5:	66 85 c0             	test   %ax,%ax
  1149d8:	0f 8e ad 00 00 00    	jle    114a8b <tcp_receive+0x100b>
        /* We need to trim the last segment. */
        next->len = seqno - next->tcphdr->seqno;
  1149de:	a1 0c 99 13 00       	mov    0x13990c,%eax
  1149e3:	89 c2                	mov    %eax,%edx
  1149e5:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  1149e8:	8b 40 10             	mov    0x10(%eax),%eax
  1149eb:	8b 40 04             	mov    0x4(%eax),%eax
  1149ee:	66 29 c2             	sub    %ax,%dx
  1149f1:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  1149f4:	66 89 50 0c          	mov    %dx,0xc(%eax)
        pbuf_realloc(next->p, next->len);
  1149f8:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  1149fb:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  1149ff:	0f b7 d0             	movzwl %ax,%edx
  114a02:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  114a05:	8b 40 04             	mov    0x4(%eax),%eax
  114a08:	89 54 24 04          	mov    %edx,0x4(%esp)
  114a0c:	89 04 24             	mov    %eax,(%esp)
  114a0f:	e8 8c a8 ff ff       	call   10f2a0 <pbuf_realloc>
      }
    }
    break;
  114a14:	eb 75                	jmp    114a8b <tcp_receive+0x100b>
        }
      }
      prev = next;
  114a16:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  114a19:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
  114a1c:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  114a1f:	8b 00                	mov    (%eax),%eax
  114a21:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
  114a24:	83 7d dc 00          	cmpl   $0x0,0xffffffdc(%ebp)
  114a28:	0f 85 ef fc ff ff    	jne    11471d <tcp_receive+0xc9d>
  114a2e:	eb 5b                	jmp    114a8b <tcp_receive+0x100b>
    }
  }
#endif /* TCP_QUEUE_OOSEQ */

      }
    }
  } else {
    /* Segments with length 0 is taken care of here. Segments that
       fall out of the window are ACKed. */
    if (TCP_SEQ_GT(pcb->rcv_nxt, seqno) ||
  114a30:	8b 45 08             	mov    0x8(%ebp),%eax
  114a33:	8b 40 24             	mov    0x24(%eax),%eax
  114a36:	89 c2                	mov    %eax,%edx
  114a38:	a1 0c 99 13 00       	mov    0x13990c,%eax
  114a3d:	89 d1                	mov    %edx,%ecx
  114a3f:	66 29 c1             	sub    %ax,%cx
  114a42:	89 c8                	mov    %ecx,%eax
  114a44:	66 85 c0             	test   %ax,%ax
  114a47:	7f 25                	jg     114a6e <tcp_receive+0xfee>
  114a49:	a1 0c 99 13 00       	mov    0x13990c,%eax
  114a4e:	89 c1                	mov    %eax,%ecx
  114a50:	8b 45 08             	mov    0x8(%ebp),%eax
  114a53:	8b 40 24             	mov    0x24(%eax),%eax
  114a56:	89 c2                	mov    %eax,%edx
  114a58:	8b 45 08             	mov    0x8(%ebp),%eax
  114a5b:	0f b7 40 28          	movzwl 0x28(%eax),%eax
  114a5f:	8d 04 02             	lea    (%edx,%eax,1),%eax
  114a62:	89 cb                	mov    %ecx,%ebx
  114a64:	66 29 c3             	sub    %ax,%bx
  114a67:	89 d8                	mov    %ebx,%eax
  114a69:	66 85 c0             	test   %ax,%ax
  114a6c:	78 1d                	js     114a8b <tcp_receive+0x100b>
       TCP_SEQ_GEQ(seqno, pcb->rcv_nxt + pcb->rcv_wnd)) {
      tcp_ack_now(pcb);
  114a6e:	8b 45 08             	mov    0x8(%ebp),%eax
  114a71:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  114a75:	89 c2                	mov    %eax,%edx
  114a77:	83 ca 02             	or     $0x2,%edx
  114a7a:	8b 45 08             	mov    0x8(%ebp),%eax
  114a7d:	88 50 20             	mov    %dl,0x20(%eax)
  114a80:	8b 45 08             	mov    0x8(%ebp),%eax
  114a83:	89 04 24             	mov    %eax,(%esp)
  114a86:	e8 b5 d3 ff ff       	call   111e40 <tcp_output>
    }
  }
}
  114a8b:	83 c4 74             	add    $0x74,%esp
  114a8e:	5b                   	pop    %ebx
  114a8f:	5d                   	pop    %ebp
  114a90:	c3                   	ret    
  114a91:	eb 0d                	jmp    114aa0 <tcp_parseopt>
  114a93:	90                   	nop    
  114a94:	90                   	nop    
  114a95:	90                   	nop    
  114a96:	90                   	nop    
  114a97:	90                   	nop    
  114a98:	90                   	nop    
  114a99:	90                   	nop    
  114a9a:	90                   	nop    
  114a9b:	90                   	nop    
  114a9c:	90                   	nop    
  114a9d:	90                   	nop    
  114a9e:	90                   	nop    
  114a9f:	90                   	nop    

00114aa0 <tcp_parseopt>:

/*
 * tcp_parseopt:
 *
 * Parses the options contained in the incoming segment. (Code taken
 * from uIP with only small changes.)
 *
 */

static void
tcp_parseopt(struct tcp_pcb *pcb)
{
  114aa0:	55                   	push   %ebp
  114aa1:	89 e5                	mov    %esp,%ebp
  114aa3:	53                   	push   %ebx
  114aa4:	83 ec 24             	sub    $0x24,%esp
  u8_t c;
  u8_t *opts, opt;
  u16_t mss;

  opts = (u8_t *)tcphdr + TCP_HLEN;
  114aa7:	a1 04 99 13 00       	mov    0x139904,%eax
  114aac:	83 c0 14             	add    $0x14,%eax
  114aaf:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
  114ab2:	a1 04 99 13 00       	mov    0x139904,%eax
  114ab7:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  114abb:	0f b7 c0             	movzwl %ax,%eax
  114abe:	89 04 24             	mov    %eax,(%esp)
  114ac1:	e8 da 97 ff ff       	call   10e2a0 <ntohs>
  114ac6:	66 c1 e8 0c          	shr    $0xc,%ax
  114aca:	66 83 f8 05          	cmp    $0x5,%ax
  114ace:	0f 86 f1 00 00 00    	jbe    114bc5 <tcp_parseopt+0x125>
    for(c = 0; c < (TCPH_HDRLEN(tcphdr) - 5) << 2 ;) {
  114ad4:	c6 45 f3 00          	movb   $0x0,0xfffffff3(%ebp)
  114ad8:	e9 bb 00 00 00       	jmp    114b98 <tcp_parseopt+0xf8>
      opt = opts[c];
  114add:	0f b6 45 f3          	movzbl 0xfffffff3(%ebp),%eax
  114ae1:	03 45 f4             	add    0xfffffff4(%ebp),%eax
  114ae4:	0f b6 00             	movzbl (%eax),%eax
  114ae7:	88 45 f9             	mov    %al,0xfffffff9(%ebp)
      if (opt == 0x00) {
  114aea:	80 7d f9 00          	cmpb   $0x0,0xfffffff9(%ebp)
  114aee:	0f 84 d1 00 00 00    	je     114bc5 <tcp_parseopt+0x125>
        /* End of options. */
  break;
      } else if (opt == 0x01) {
  114af4:	80 7d f9 01          	cmpb   $0x1,0xfffffff9(%ebp)
  114af8:	75 09                	jne    114b03 <tcp_parseopt+0x63>
        ++c;
  114afa:	80 45 f3 01          	addb   $0x1,0xfffffff3(%ebp)
  114afe:	e9 95 00 00 00       	jmp    114b98 <tcp_parseopt+0xf8>
        /* NOP option. */
      } else if (opt == 0x02 &&
  114b03:	80 7d f9 02          	cmpb   $0x2,0xfffffff9(%ebp)
  114b07:	75 68                	jne    114b71 <tcp_parseopt+0xd1>
  114b09:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
  114b0c:	83 c2 01             	add    $0x1,%edx
  114b0f:	0f b6 45 f3          	movzbl 0xfffffff3(%ebp),%eax
  114b13:	8d 04 02             	lea    (%edx,%eax,1),%eax
  114b16:	0f b6 00             	movzbl (%eax),%eax
  114b19:	3c 04                	cmp    $0x4,%al
  114b1b:	75 54                	jne    114b71 <tcp_parseopt+0xd1>
                opts[c + 1] == 0x04) {
        /* An MSS option with the right option length. */
        mss = (opts[c + 2] << 8) | opts[c + 3];
  114b1d:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
  114b20:	83 c2 02             	add    $0x2,%edx
  114b23:	0f b6 45 f3          	movzbl 0xfffffff3(%ebp),%eax
  114b27:	8d 04 02             	lea    (%edx,%eax,1),%eax
  114b2a:	0f b6 00             	movzbl (%eax),%eax
  114b2d:	0f b6 c0             	movzbl %al,%eax
  114b30:	c1 e0 08             	shl    $0x8,%eax
  114b33:	89 c1                	mov    %eax,%ecx
  114b35:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
  114b38:	83 c2 03             	add    $0x3,%edx
  114b3b:	0f b6 45 f3          	movzbl 0xfffffff3(%ebp),%eax
  114b3f:	8d 04 02             	lea    (%edx,%eax,1),%eax
  114b42:	0f b6 00             	movzbl (%eax),%eax
  114b45:	0f b6 c0             	movzbl %al,%eax
  114b48:	09 c8                	or     %ecx,%eax
  114b4a:	66 89 45 fa          	mov    %ax,0xfffffffa(%ebp)
        pcb->mss = mss > TCP_MSS? TCP_MSS: mss;
  114b4e:	0f b7 45 fa          	movzwl 0xfffffffa(%ebp),%eax
  114b52:	66 89 45 ea          	mov    %ax,0xffffffea(%ebp)
  114b56:	66 81 7d ea 00 02    	cmpw   $0x200,0xffffffea(%ebp)
  114b5c:	76 06                	jbe    114b64 <tcp_parseopt+0xc4>
  114b5e:	66 c7 45 ea 00 02    	movw   $0x200,0xffffffea(%ebp)
  114b64:	8b 45 08             	mov    0x8(%ebp),%eax
  114b67:	0f b7 55 ea          	movzwl 0xffffffea(%ebp),%edx
  114b6b:	66 89 50 34          	mov    %dx,0x34(%eax)

        /* And we are done processing options. */
        break;
  114b6f:	eb 54                	jmp    114bc5 <tcp_parseopt+0x125>
      } else {
  if (opts[c + 1] == 0) {
  114b71:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
  114b74:	83 c2 01             	add    $0x1,%edx
  114b77:	0f b6 45 f3          	movzbl 0xfffffff3(%ebp),%eax
  114b7b:	8d 04 02             	lea    (%edx,%eax,1),%eax
  114b7e:	0f b6 00             	movzbl (%eax),%eax
  114b81:	84 c0                	test   %al,%al
  114b83:	74 40                	je     114bc5 <tcp_parseopt+0x125>
          /* If the length field is zero, the options are malformed
             and we don't process them further. */
          break;
        }
        /* All other options have a length field, so that we easily
           can skip past them. */
        c += opts[c + 1];
  114b85:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
  114b88:	83 c2 01             	add    $0x1,%edx
  114b8b:	0f b6 45 f3          	movzbl 0xfffffff3(%ebp),%eax
  114b8f:	8d 04 02             	lea    (%edx,%eax,1),%eax
  114b92:	0f b6 00             	movzbl (%eax),%eax
  114b95:	00 45 f3             	add    %al,0xfffffff3(%ebp)
  114b98:	0f b6 5d f3          	movzbl 0xfffffff3(%ebp),%ebx
  114b9c:	a1 04 99 13 00       	mov    0x139904,%eax
  114ba1:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  114ba5:	0f b7 c0             	movzwl %ax,%eax
  114ba8:	89 04 24             	mov    %eax,(%esp)
  114bab:	e8 f0 96 ff ff       	call   10e2a0 <ntohs>
  114bb0:	66 c1 e8 0c          	shr    $0xc,%ax
  114bb4:	0f b7 c0             	movzwl %ax,%eax
  114bb7:	83 e8 05             	sub    $0x5,%eax
  114bba:	c1 e0 02             	shl    $0x2,%eax
  114bbd:	39 c3                	cmp    %eax,%ebx
  114bbf:	0f 8c 18 ff ff ff    	jl     114add <tcp_parseopt+0x3d>
      }
    }
  }
}
  114bc5:	83 c4 24             	add    $0x24,%esp
  114bc8:	5b                   	pop    %ebx
  114bc9:	5d                   	pop    %ebp
  114bca:	c3                   	ret    
  114bcb:	90                   	nop    
  114bcc:	90                   	nop    
  114bcd:	90                   	nop    
  114bce:	90                   	nop    
  114bcf:	90                   	nop    

00114bd0 <udp_init>:


void
udp_init(void)
{
  114bd0:	55                   	push   %ebp
  114bd1:	89 e5                	mov    %esp,%ebp
  udp_pcbs = pcb_cache = NULL;
  114bd3:	c7 05 24 99 13 00 00 	movl   $0x0,0x139924
  114bda:	00 00 00 
  114bdd:	a1 24 99 13 00       	mov    0x139924,%eax
  114be2:	a3 20 99 13 00       	mov    %eax,0x139920
}
  114be7:	5d                   	pop    %ebp
  114be8:	c3                   	ret    
  114be9:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

00114bf0 <udp_input>:

/**
 * Process an incoming UDP datagram.
 *
 * Given an incoming UDP datagram (as a chain of pbufs) this function
 * finds a corresponding UDP PCB and
 *
 * @param pbuf pbuf to be demultiplexed to a UDP PCB.
 * @param netif network interface on which the datagram was received.
 *
 */
void
udp_input(struct pbuf *p, struct netif *inp)
{
  114bf0:	55                   	push   %ebp
  114bf1:	89 e5                	mov    %esp,%ebp
  114bf3:	56                   	push   %esi
  114bf4:	53                   	push   %ebx
  114bf5:	83 ec 40             	sub    $0x40,%esp
  struct udp_hdr *udphdr;
  struct udp_pcb *pcb;
  struct ip_hdr *iphdr;
  u16_t src, dest;

#if SO_REUSE
  struct udp_pcb *pcb_temp;
  int reuse = 0;
  114bf8:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  int reuse_port_1 = 0;
  114bff:	c7 45 f0 00 00 00 00 	movl   $0x0,0xfffffff0(%ebp)
  int reuse_port_2 = 0;
  114c06:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
#endif /* SO_REUSE */
  
  PERF_START;

  UDP_STATS_INC(udp.recv);
  114c0d:	0f b7 05 4c 15 14 00 	movzwl 0x14154c,%eax
  114c14:	83 c0 01             	add    $0x1,%eax
  114c17:	66 a3 4c 15 14 00    	mov    %ax,0x14154c

  iphdr = p->payload;
  114c1d:	8b 45 08             	mov    0x8(%ebp),%eax
  114c20:	8b 40 04             	mov    0x4(%eax),%eax
  114c23:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)

  if (pbuf_header(p, -((s16_t)(UDP_HLEN + IPH_HL(iphdr) * 4)))) {
  114c26:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  114c29:	0f b7 00             	movzwl (%eax),%eax
  114c2c:	0f b7 c0             	movzwl %ax,%eax
  114c2f:	89 04 24             	mov    %eax,(%esp)
  114c32:	e8 69 96 ff ff       	call   10e2a0 <ntohs>
  114c37:	66 c1 e8 08          	shr    $0x8,%ax
  114c3b:	0f b7 c0             	movzwl %ax,%eax
  114c3e:	83 e0 0f             	and    $0xf,%eax
  114c41:	c1 e0 02             	shl    $0x2,%eax
  114c44:	89 c2                	mov    %eax,%edx
  114c46:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
  114c4b:	66 29 d0             	sub    %dx,%ax
  114c4e:	98                   	cwtl   
  114c4f:	89 44 24 04          	mov    %eax,0x4(%esp)
  114c53:	8b 45 08             	mov    0x8(%ebp),%eax
  114c56:	89 04 24             	mov    %eax,(%esp)
  114c59:	e8 52 a7 ff ff       	call   10f3b0 <pbuf_header>
  114c5e:	84 c0                	test   %al,%al
  114c60:	74 30                	je     114c92 <udp_input+0xa2>
    /* drop short packets */
    LWIP_DEBUGF(UDP_DEBUG, ("udp_input: short UDP datagram (%u bytes) discarded\n", p->tot_len));
    UDP_STATS_INC(udp.lenerr);
  114c62:	0f b7 05 54 15 14 00 	movzwl 0x141554,%eax
  114c69:	83 c0 01             	add    $0x1,%eax
  114c6c:	66 a3 54 15 14 00    	mov    %ax,0x141554
    UDP_STATS_INC(udp.drop);
  114c72:	0f b7 05 50 15 14 00 	movzwl 0x141550,%eax
  114c79:	83 c0 01             	add    $0x1,%eax
  114c7c:	66 a3 50 15 14 00    	mov    %ax,0x141550
    snmp_inc_udpinerrors();
    pbuf_free(p);
  114c82:	8b 45 08             	mov    0x8(%ebp),%eax
  114c85:	89 04 24             	mov    %eax,(%esp)
  114c88:	e8 23 a8 ff ff       	call   10f4b0 <pbuf_free>
    goto end;
  114c8d:	e9 36 04 00 00       	jmp    1150c8 <udp_input+0x4d8>
  }

  udphdr = (struct udp_hdr *)((u8_t *)p->payload - UDP_HLEN);
  114c92:	8b 45 08             	mov    0x8(%ebp),%eax
  114c95:	8b 40 04             	mov    0x4(%eax),%eax
  114c98:	83 e8 08             	sub    $0x8,%eax
  114c9b:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)

  LWIP_DEBUGF(UDP_DEBUG, ("udp_input: received datagram of length %u\n", p->tot_len));

  src = ntohs(udphdr->src);
  114c9e:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  114ca1:	0f b7 00             	movzwl (%eax),%eax
  114ca4:	0f b7 c0             	movzwl %ax,%eax
  114ca7:	89 04 24             	mov    %eax,(%esp)
  114caa:	e8 f1 95 ff ff       	call   10e2a0 <ntohs>
  114caf:	66 89 45 e4          	mov    %ax,0xffffffe4(%ebp)
  dest = ntohs(udphdr->dest);
  114cb3:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  114cb6:	0f b7 40 02          	movzwl 0x2(%eax),%eax
  114cba:	0f b7 c0             	movzwl %ax,%eax
  114cbd:	89 04 24             	mov    %eax,(%esp)
  114cc0:	e8 db 95 ff ff       	call   10e2a0 <ntohs>
  114cc5:	66 89 45 e6          	mov    %ax,0xffffffe6(%ebp)

  udp_debug_print(udphdr);

  /* print the UDP source and destination */
  LWIP_DEBUGF(UDP_DEBUG, ("udp (%u.%u.%u.%u, %u) <-- (%u.%u.%u.%u, %u)\n",
    ip4_addr1(&iphdr->dest), ip4_addr2(&iphdr->dest),
    ip4_addr3(&iphdr->dest), ip4_addr4(&iphdr->dest), ntohs(udphdr->dest),
    ip4_addr1(&iphdr->src), ip4_addr2(&iphdr->src),
    ip4_addr3(&iphdr->src), ip4_addr4(&iphdr->src), ntohs(udphdr->src)));

#if SO_REUSE
  pcb_temp = udp_pcbs;
  114cc9:	a1 20 99 13 00       	mov    0x139920,%eax
  114cce:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
  
 again_1:
  
  /* Iterate through the UDP pcb list for a fully matching pcb */
  for(pcb = pcb_temp; pcb != NULL; pcb = pcb->next) {
  114cd1:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  114cd4:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
  114cd7:	e9 ac 00 00 00       	jmp    114d88 <udp_input+0x198>
#else  /* SO_REUSE */ 
  /* Iterate through the UDP pcb list for a fully matching pcb */
  for(pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
#endif  /* SO_REUSE */ 
    /* print the PCB local and remote address */
    LWIP_DEBUGF(UDP_DEBUG, ("pcb (%u.%u.%u.%u, %u) --- (%u.%u.%u.%u, %u)\n",
      ip4_addr1(&pcb->local_ip), ip4_addr2(&pcb->local_ip),
      ip4_addr3(&pcb->local_ip), ip4_addr4(&pcb->local_ip), pcb->local_port,
      ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
      ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip), pcb->remote_port));

       /* PCB remote port matches UDP source port? */
    if ((pcb->remote_port == src) &&
  114cdc:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  114cdf:	0f b7 40 14          	movzwl 0x14(%eax),%eax
  114ce3:	66 3b 45 e4          	cmp    0xffffffe4(%ebp),%ax
  114ce7:	0f 85 92 00 00 00    	jne    114d7f <udp_input+0x18f>
  114ced:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  114cf0:	0f b7 40 12          	movzwl 0x12(%eax),%eax
  114cf4:	66 3b 45 e6          	cmp    0xffffffe6(%ebp),%ax
  114cf8:	0f 85 81 00 00 00    	jne    114d7f <udp_input+0x18f>
  114cfe:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  114d01:	83 c0 04             	add    $0x4,%eax
  114d04:	85 c0                	test   %eax,%eax
  114d06:	74 1a                	je     114d22 <udp_input+0x132>
  114d08:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  114d0b:	8b 40 04             	mov    0x4(%eax),%eax
  114d0e:	85 c0                	test   %eax,%eax
  114d10:	74 10                	je     114d22 <udp_input+0x132>
  114d12:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  114d15:	8b 50 04             	mov    0x4(%eax),%edx
  114d18:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  114d1b:	8b 40 0c             	mov    0xc(%eax),%eax
  114d1e:	39 c2                	cmp    %eax,%edx
  114d20:	75 5d                	jne    114d7f <udp_input+0x18f>
  114d22:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  114d25:	85 c0                	test   %eax,%eax
  114d27:	74 18                	je     114d41 <udp_input+0x151>
  114d29:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  114d2c:	8b 00                	mov    (%eax),%eax
  114d2e:	85 c0                	test   %eax,%eax
  114d30:	74 0f                	je     114d41 <udp_input+0x151>
  114d32:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  114d35:	8b 10                	mov    (%eax),%edx
  114d37:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  114d3a:	8b 40 10             	mov    0x10(%eax),%eax
  114d3d:	39 c2                	cmp    %eax,%edx
  114d3f:	75 3e                	jne    114d7f <udp_input+0x18f>
       /* PCB local port matches UDP destination port? */
       (pcb->local_port == dest) &&
       /* accepting from any remote (source) IP address? or... */
       (ip_addr_isany(&pcb->remote_ip) ||
       /* PCB remote IP address matches UDP source IP address? */
        ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src))) &&
       /* accepting on any local (netif) IP address? or... */
       (ip_addr_isany(&pcb->local_ip) ||
       /* PCB local IP address matches UDP destination IP address? */
        ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest)))) {
#if SO_REUSE
      if(pcb->so_options & SOF_REUSEPORT) {
  114d41:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  114d44:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  114d48:	0f b7 c0             	movzwl %ax,%eax
  114d4b:	25 00 02 00 00       	and    $0x200,%eax
  114d50:	85 c0                	test   %eax,%eax
  114d52:	74 29                	je     114d7d <udp_input+0x18d>
        if(reuse) {
  114d54:	83 7d ec 00          	cmpl   $0x0,0xffffffec(%ebp)
  114d58:	74 02                	je     114d5c <udp_input+0x16c>
  114d5a:	eb 07                	jmp    114d63 <udp_input+0x173>
          /* We processed one PCB already */
          LWIP_DEBUGF(UDP_DEBUG, ("udp_input: second or later PCB and SOF_REUSEPORT set.\n"));
        } else {
          /* First PCB with this address */
          LWIP_DEBUGF(UDP_DEBUG, ("udp_input: first PCB and SOF_REUSEPORT set.\n"));
          reuse = 1;
  114d5c:	c7 45 ec 01 00 00 00 	movl   $0x1,0xffffffec(%ebp)
        }
        
        reuse_port_1 = 1; 
  114d63:	c7 45 f0 01 00 00 00 	movl   $0x1,0xfffffff0(%ebp)
        p->ref++;
  114d6a:	8b 45 08             	mov    0x8(%ebp),%eax
  114d6d:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
  114d71:	8d 50 01             	lea    0x1(%eax),%edx
  114d74:	8b 45 08             	mov    0x8(%ebp),%eax
  114d77:	66 89 50 0e          	mov    %dx,0xe(%eax)
  114d7b:	eb 15                	jmp    114d92 <udp_input+0x1a2>
  114d7d:	eb 13                	jmp    114d92 <udp_input+0x1a2>
  114d7f:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  114d82:	8b 40 0c             	mov    0xc(%eax),%eax
  114d85:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
  114d88:	83 7d dc 00          	cmpl   $0x0,0xffffffdc(%ebp)
  114d8c:	0f 85 4a ff ff ff    	jne    114cdc <udp_input+0xec>
        LWIP_DEBUGF(UDP_DEBUG, ("udp_input: reference counter on PBUF set to %i\n", p->ref));
      } else {
        if(reuse) {
          /* We processed one PCB already */
          LWIP_DEBUGF(UDP_DEBUG, ("udp_input: second or later PCB but SOF_REUSEPORT not set !\n"));
        }
      }
#endif /* SO_REUSE */
      break;
    }
  }
  /* no fully matching pcb found? then look for an unconnected pcb */
  if (pcb == NULL) {
  114d92:	83 7d dc 00          	cmpl   $0x0,0xffffffdc(%ebp)
  114d96:	0f 85 a1 00 00 00    	jne    114e3d <udp_input+0x24d>
    /* Iterate through the UDP PCB list for a pcb that matches
       the local address. */

#if SO_REUSE
    pcb_temp = udp_pcbs;
  114d9c:	a1 20 99 13 00       	mov    0x139920,%eax
  114da1:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
    
  again_2:

    for(pcb = pcb_temp; pcb != NULL; pcb = pcb->next) {
  114da4:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  114da7:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
  114daa:	e9 84 00 00 00       	jmp    114e33 <udp_input+0x243>
#else  /* SO_REUSE */ 
    for(pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
#endif  /* SO_REUSE */ 
      LWIP_DEBUGF(UDP_DEBUG, ("pcb (%u.%u.%u.%u, %u) --- (%u.%u.%u.%u, %u)\n",
        ip4_addr1(&pcb->local_ip), ip4_addr2(&pcb->local_ip),
        ip4_addr3(&pcb->local_ip), ip4_addr4(&pcb->local_ip), pcb->local_port,
        ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
        ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip), pcb->remote_port));
      /* unconnected? */
      if (((pcb->flags & UDP_FLAGS_CONNECTED) == 0) &&
  114daf:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  114db2:	0f b6 40 10          	movzbl 0x10(%eax),%eax
  114db6:	0f b6 c0             	movzbl %al,%eax
  114db9:	83 e0 04             	and    $0x4,%eax
  114dbc:	85 c0                	test   %eax,%eax
  114dbe:	75 6a                	jne    114e2a <udp_input+0x23a>
  114dc0:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  114dc3:	0f b7 40 12          	movzwl 0x12(%eax),%eax
  114dc7:	66 3b 45 e6          	cmp    0xffffffe6(%ebp),%ax
  114dcb:	75 5d                	jne    114e2a <udp_input+0x23a>
  114dcd:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  114dd0:	85 c0                	test   %eax,%eax
  114dd2:	74 18                	je     114dec <udp_input+0x1fc>
  114dd4:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  114dd7:	8b 00                	mov    (%eax),%eax
  114dd9:	85 c0                	test   %eax,%eax
  114ddb:	74 0f                	je     114dec <udp_input+0x1fc>
  114ddd:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  114de0:	8b 10                	mov    (%eax),%edx
  114de2:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  114de5:	8b 40 10             	mov    0x10(%eax),%eax
  114de8:	39 c2                	cmp    %eax,%edx
  114dea:	75 3e                	jne    114e2a <udp_input+0x23a>
         /* destination port matches? */
        (pcb->local_port == dest) &&
        /* not bound to a specific (local) interface address? or... */
        (ip_addr_isany(&pcb->local_ip) ||
        /* ...matching interface address? */
        ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest)))) {
#if SO_REUSE
        if(pcb->so_options & SOF_REUSEPORT) {
  114dec:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  114def:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  114df3:	0f b7 c0             	movzwl %ax,%eax
  114df6:	25 00 02 00 00       	and    $0x200,%eax
  114dfb:	85 c0                	test   %eax,%eax
  114dfd:	74 29                	je     114e28 <udp_input+0x238>
          if(reuse) {
  114dff:	83 7d ec 00          	cmpl   $0x0,0xffffffec(%ebp)
  114e03:	74 02                	je     114e07 <udp_input+0x217>
  114e05:	eb 07                	jmp    114e0e <udp_input+0x21e>
            /* We processed one PCB already */
            LWIP_DEBUGF(UDP_DEBUG, ("udp_input: second or later PCB and SOF_REUSEPORT set.\n"));
          } else {
            /* First PCB with this address */
            LWIP_DEBUGF(UDP_DEBUG, ("udp_input: first PCB and SOF_REUSEPORT set.\n"));
            reuse = 1;
  114e07:	c7 45 ec 01 00 00 00 	movl   $0x1,0xffffffec(%ebp)
          }
          
          reuse_port_2 = 1; 
  114e0e:	c7 45 f4 01 00 00 00 	movl   $0x1,0xfffffff4(%ebp)
          p->ref++;
  114e15:	8b 45 08             	mov    0x8(%ebp),%eax
  114e18:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
  114e1c:	8d 50 01             	lea    0x1(%eax),%edx
  114e1f:	8b 45 08             	mov    0x8(%ebp),%eax
  114e22:	66 89 50 0e          	mov    %dx,0xe(%eax)
  114e26:	eb 15                	jmp    114e3d <udp_input+0x24d>
  114e28:	eb 13                	jmp    114e3d <udp_input+0x24d>
  114e2a:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  114e2d:	8b 40 0c             	mov    0xc(%eax),%eax
  114e30:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
  114e33:	83 7d dc 00          	cmpl   $0x0,0xffffffdc(%ebp)
  114e37:	0f 85 72 ff ff ff    	jne    114daf <udp_input+0x1bf>
          LWIP_DEBUGF(UDP_DEBUG, ("udp_input: reference counter on PBUF set to %i\n", p->ref));
        } else {
          if(reuse) {
            /* We processed one PCB already */
            LWIP_DEBUGF(UDP_DEBUG, ("udp_input: second or later PCB but SOF_REUSEPORT not set !\n"));
          }
        }
#endif /* SO_REUSE */
        break;
      }
    }
  }

  /* Check checksum if this is a match or if it was directed at us. */
  if (pcb != NULL  || ip_addr_cmp(&inp->ip_addr, &iphdr->dest))
  114e3d:	83 7d dc 00          	cmpl   $0x0,0xffffffdc(%ebp)
  114e41:	75 14                	jne    114e57 <udp_input+0x267>
  114e43:	8b 45 0c             	mov    0xc(%ebp),%eax
  114e46:	8b 50 04             	mov    0x4(%eax),%edx
  114e49:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  114e4c:	8b 40 10             	mov    0x10(%eax),%eax
  114e4f:	39 c2                	cmp    %eax,%edx
  114e51:	0f 85 66 02 00 00    	jne    1150bd <udp_input+0x4cd>
    {
    LWIP_DEBUGF(UDP_DEBUG | DBG_TRACE, ("udp_input: calculating checksum\n"));
    pbuf_header(p, UDP_HLEN);
  114e57:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
  114e5e:	00 
  114e5f:	8b 45 08             	mov    0x8(%ebp),%eax
  114e62:	89 04 24             	mov    %eax,(%esp)
  114e65:	e8 46 a5 ff ff       	call   10f3b0 <pbuf_header>
#ifdef IPv6
    if (iphdr->nexthdr == IP_PROTO_UDPLITE) {
#else
    if (IPH_PROTO(iphdr) == IP_PROTO_UDPLITE) {
  114e6a:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  114e6d:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  114e71:	0f b7 c0             	movzwl %ax,%eax
  114e74:	89 04 24             	mov    %eax,(%esp)
  114e77:	e8 24 94 ff ff       	call   10e2a0 <ntohs>
  114e7c:	0f b7 c0             	movzwl %ax,%eax
  114e7f:	25 ff 00 00 00       	and    $0xff,%eax
  114e84:	3d aa 00 00 00       	cmp    $0xaa,%eax
  114e89:	75 79                	jne    114f04 <udp_input+0x314>
#endif /* IPv4 */
      /* Do the UDP Lite checksum */
      if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
  114e8b:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  114e8e:	0f b7 40 04          	movzwl 0x4(%eax),%eax
  114e92:	0f b7 c0             	movzwl %ax,%eax
  114e95:	89 04 24             	mov    %eax,(%esp)
  114e98:	e8 03 94 ff ff       	call   10e2a0 <ntohs>
  114e9d:	0f b7 c0             	movzwl %ax,%eax
  114ea0:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
  114ea3:	83 c2 10             	add    $0x10,%edx
  114ea6:	8b 4d e0             	mov    0xffffffe0(%ebp),%ecx
  114ea9:	83 c1 0c             	add    $0xc,%ecx
  114eac:	89 44 24 10          	mov    %eax,0x10(%esp)
  114eb0:	c7 44 24 0c aa 00 00 	movl   $0xaa,0xc(%esp)
  114eb7:	00 
  114eb8:	89 54 24 08          	mov    %edx,0x8(%esp)
  114ebc:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  114ec0:	8b 45 08             	mov    0x8(%ebp),%eax
  114ec3:	89 04 24             	mov    %eax,(%esp)
  114ec6:	e8 65 8d ff ff       	call   10dc30 <inet_chksum_pseudo>
  114ecb:	66 85 c0             	test   %ax,%ax
  114ece:	0f 84 a6 00 00 00    	je     114f7a <udp_input+0x38a>
         (struct ip_addr *)&(iphdr->dest),
         IP_PROTO_UDPLITE, ntohs(udphdr->len)) != 0) {
  LWIP_DEBUGF(UDP_DEBUG | 2, ("udp_input: UDP Lite datagram discarded due to failing checksum\n"));
  UDP_STATS_INC(udp.chkerr);
  114ed4:	0f b7 05 52 15 14 00 	movzwl 0x141552,%eax
  114edb:	83 c0 01             	add    $0x1,%eax
  114ede:	66 a3 52 15 14 00    	mov    %ax,0x141552
  UDP_STATS_INC(udp.drop);
  114ee4:	0f b7 05 50 15 14 00 	movzwl 0x141550,%eax
  114eeb:	83 c0 01             	add    $0x1,%eax
  114eee:	66 a3 50 15 14 00    	mov    %ax,0x141550
  snmp_inc_udpinerrors();
  pbuf_free(p);
  114ef4:	8b 45 08             	mov    0x8(%ebp),%eax
  114ef7:	89 04 24             	mov    %eax,(%esp)
  114efa:	e8 b1 a5 ff ff       	call   10f4b0 <pbuf_free>
  goto end;
  114eff:	e9 c4 01 00 00       	jmp    1150c8 <udp_input+0x4d8>
      }
    } else {
      if (udphdr->chksum != 0) {
  114f04:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  114f07:	0f b7 40 06          	movzwl 0x6(%eax),%eax
  114f0b:	66 85 c0             	test   %ax,%ax
  114f0e:	74 6a                	je     114f7a <udp_input+0x38a>
  if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
  114f10:	8b 45 08             	mov    0x8(%ebp),%eax
  114f13:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  114f17:	0f b7 c0             	movzwl %ax,%eax
  114f1a:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
  114f1d:	83 c2 10             	add    $0x10,%edx
  114f20:	8b 4d e0             	mov    0xffffffe0(%ebp),%ecx
  114f23:	83 c1 0c             	add    $0xc,%ecx
  114f26:	89 44 24 10          	mov    %eax,0x10(%esp)
  114f2a:	c7 44 24 0c 11 00 00 	movl   $0x11,0xc(%esp)
  114f31:	00 
  114f32:	89 54 24 08          	mov    %edx,0x8(%esp)
  114f36:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  114f3a:	8b 45 08             	mov    0x8(%ebp),%eax
  114f3d:	89 04 24             	mov    %eax,(%esp)
  114f40:	e8 eb 8c ff ff       	call   10dc30 <inet_chksum_pseudo>
  114f45:	66 85 c0             	test   %ax,%ax
  114f48:	74 30                	je     114f7a <udp_input+0x38a>
       (struct ip_addr *)&(iphdr->dest),
        IP_PROTO_UDP, p->tot_len) != 0) {
    LWIP_DEBUGF(UDP_DEBUG | 2, ("udp_input: UDP datagram discarded due to failing checksum\n"));

    UDP_STATS_INC(udp.chkerr);
  114f4a:	0f b7 05 52 15 14 00 	movzwl 0x141552,%eax
  114f51:	83 c0 01             	add    $0x1,%eax
  114f54:	66 a3 52 15 14 00    	mov    %ax,0x141552
    UDP_STATS_INC(udp.drop);
  114f5a:	0f b7 05 50 15 14 00 	movzwl 0x141550,%eax
  114f61:	83 c0 01             	add    $0x1,%eax
  114f64:	66 a3 50 15 14 00    	mov    %ax,0x141550
    snmp_inc_udpinerrors();
    pbuf_free(p);
  114f6a:	8b 45 08             	mov    0x8(%ebp),%eax
  114f6d:	89 04 24             	mov    %eax,(%esp)
  114f70:	e8 3b a5 ff ff       	call   10f4b0 <pbuf_free>
    goto end;
  114f75:	e9 4e 01 00 00       	jmp    1150c8 <udp_input+0x4d8>
  }
      }
    }
    pbuf_header(p, -UDP_HLEN);
  114f7a:	c7 44 24 04 f8 ff ff 	movl   $0xfffffff8,0x4(%esp)
  114f81:	ff 
  114f82:	8b 45 08             	mov    0x8(%ebp),%eax
  114f85:	89 04 24             	mov    %eax,(%esp)
  114f88:	e8 23 a4 ff ff       	call   10f3b0 <pbuf_header>
    if (pcb != NULL) {
  114f8d:	83 7d dc 00          	cmpl   $0x0,0xffffffdc(%ebp)
  114f91:	74 76                	je     115009 <udp_input+0x419>
      snmp_inc_udpindatagrams();
      pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src), src);
  114f93:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  114f96:	8b 70 18             	mov    0x18(%eax),%esi
  114f99:	0f b7 55 e4          	movzwl 0xffffffe4(%ebp),%edx
  114f9d:	8b 4d e0             	mov    0xffffffe0(%ebp),%ecx
  114fa0:	83 c1 0c             	add    $0xc,%ecx
  114fa3:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  114fa6:	8b 58 1c             	mov    0x1c(%eax),%ebx
  114fa9:	89 54 24 10          	mov    %edx,0x10(%esp)
  114fad:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
  114fb1:	8b 45 08             	mov    0x8(%ebp),%eax
  114fb4:	89 44 24 08          	mov    %eax,0x8(%esp)
  114fb8:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  114fbb:	89 44 24 04          	mov    %eax,0x4(%esp)
  114fbf:	89 1c 24             	mov    %ebx,(%esp)
  114fc2:	ff d6                	call   *%esi
#if SO_REUSE
      /* First socket should receive now */
      if(reuse_port_1 || reuse_port_2) {
  114fc4:	83 7d f0 00          	cmpl   $0x0,0xfffffff0(%ebp)
  114fc8:	75 0a                	jne    114fd4 <udp_input+0x3e4>
  114fca:	83 7d f4 00          	cmpl   $0x0,0xfffffff4(%ebp)
  114fce:	0f 84 f4 00 00 00    	je     1150c8 <udp_input+0x4d8>
        /* We want to search on next socket after receiving */
        pcb_temp = pcb->next;
  114fd4:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  114fd7:	8b 40 0c             	mov    0xc(%eax),%eax
  114fda:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
        
        if(reuse_port_1) {
  114fdd:	83 7d f0 00          	cmpl   $0x0,0xfffffff0(%ebp)
  114fe1:	74 13                	je     114ff6 <udp_input+0x406>
          /* We are searching connected sockets */
          reuse_port_1 = 0;
  114fe3:	c7 45 f0 00 00 00 00 	movl   $0x0,0xfffffff0(%ebp)
          reuse_port_2 = 0;
  114fea:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
          goto again_1;
  114ff1:	e9 db fc ff ff       	jmp    114cd1 <udp_input+0xe1>
        } else {
          /* We are searching unconnected sockets */
          reuse_port_1 = 0;
  114ff6:	c7 45 f0 00 00 00 00 	movl   $0x0,0xfffffff0(%ebp)
          reuse_port_2 = 0;
  114ffd:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
          goto again_2;
  115004:	e9 9b fd ff ff       	jmp    114da4 <udp_input+0x1b4>
        }
      }
#endif /* SO_REUSE */ 
    } else {
#if SO_REUSE
      if(reuse) {
  115009:	83 7d ec 00          	cmpl   $0x0,0xffffffec(%ebp)
  11500d:	74 10                	je     11501f <udp_input+0x42f>
        LWIP_DEBUGF(UDP_DEBUG, ("udp_input: freeing PBUF with reference counter set to %i\n", p->ref));
        pbuf_free(p);
  11500f:	8b 45 08             	mov    0x8(%ebp),%eax
  115012:	89 04 24             	mov    %eax,(%esp)
  115015:	e8 96 a4 ff ff       	call   10f4b0 <pbuf_free>
        goto end;
  11501a:	e9 a9 00 00 00       	jmp    1150c8 <udp_input+0x4d8>
      }
#endif /* SO_REUSE */
      LWIP_DEBUGF(UDP_DEBUG | DBG_TRACE, ("udp_input: not for us.\n"));

      /* No match was found, send ICMP destination port unreachable unless
      destination address was broadcast/multicast. */

      if (!ip_addr_isbroadcast(&iphdr->dest, &inp->netmask) &&
  11501f:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  115022:	8b 50 10             	mov    0x10(%eax),%edx
  115025:	8b 45 0c             	mov    0xc(%ebp),%eax
  115028:	8b 40 08             	mov    0x8(%eax),%eax
  11502b:	f7 d0                	not    %eax
  11502d:	21 c2                	and    %eax,%edx
  11502f:	8b 45 0c             	mov    0xc(%ebp),%eax
  115032:	8b 40 08             	mov    0x8(%eax),%eax
  115035:	f7 d0                	not    %eax
  115037:	39 c2                	cmp    %eax,%edx
  115039:	74 55                	je     115090 <udp_input+0x4a0>
  11503b:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  11503e:	8b 40 10             	mov    0x10(%eax),%eax
  115041:	83 f8 ff             	cmp    $0xffffffff,%eax
  115044:	74 4a                	je     115090 <udp_input+0x4a0>
  115046:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  115049:	8b 40 10             	mov    0x10(%eax),%eax
  11504c:	85 c0                	test   %eax,%eax
  11504e:	74 40                	je     115090 <udp_input+0x4a0>
  115050:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  115053:	8b 58 10             	mov    0x10(%eax),%ebx
  115056:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  11505d:	e8 9e 92 ff ff       	call   10e300 <ntohl>
  115062:	21 c3                	and    %eax,%ebx
  115064:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  11506b:	e8 90 92 ff ff       	call   10e300 <ntohl>
  115070:	39 c3                	cmp    %eax,%ebx
  115072:	74 1c                	je     115090 <udp_input+0x4a0>
   !ip_addr_ismulticast(&iphdr->dest)) {

  /* adjust pbuf pointer */
  p->payload = iphdr;
  115074:	8b 45 08             	mov    0x8(%ebp),%eax
  115077:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
  11507a:	89 50 04             	mov    %edx,0x4(%eax)
  icmp_dest_unreach(p, ICMP_DUR_PORT);
  11507d:	c7 44 24 04 03 00 00 	movl   $0x3,0x4(%esp)
  115084:	00 
  115085:	8b 45 08             	mov    0x8(%ebp),%eax
  115088:	89 04 24             	mov    %eax,(%esp)
  11508b:	e8 20 79 ff ff       	call   10c9b0 <icmp_dest_unreach>
      }
      UDP_STATS_INC(udp.proterr);
  115090:	0f b7 05 5a 15 14 00 	movzwl 0x14155a,%eax
  115097:	83 c0 01             	add    $0x1,%eax
  11509a:	66 a3 5a 15 14 00    	mov    %ax,0x14155a
      UDP_STATS_INC(udp.drop);
  1150a0:	0f b7 05 50 15 14 00 	movzwl 0x141550,%eax
  1150a7:	83 c0 01             	add    $0x1,%eax
  1150aa:	66 a3 50 15 14 00    	mov    %ax,0x141550
    snmp_inc_udpnoports();
      pbuf_free(p);
  1150b0:	8b 45 08             	mov    0x8(%ebp),%eax
  1150b3:	89 04 24             	mov    %eax,(%esp)
  1150b6:	e8 f5 a3 ff ff       	call   10f4b0 <pbuf_free>
  1150bb:	eb 0b                	jmp    1150c8 <udp_input+0x4d8>
    }
  } else {
    pbuf_free(p);
  1150bd:	8b 45 08             	mov    0x8(%ebp),%eax
  1150c0:	89 04 24             	mov    %eax,(%esp)
  1150c3:	e8 e8 a3 ff ff       	call   10f4b0 <pbuf_free>
  }
  end:

  PERF_STOP("udp_input");
}
  1150c8:	83 c4 40             	add    $0x40,%esp
  1150cb:	5b                   	pop    %ebx
  1150cc:	5e                   	pop    %esi
  1150cd:	5d                   	pop    %ebp
  1150ce:	c3                   	ret    
  1150cf:	90                   	nop    

001150d0 <udp_sendto>:

/**
 * Send data to a specified address using UDP.
 *
 * @param pcb UDP PCB used to send the data.
 * @param pbuf chain of pbuf's to be sent.
 * @param dst_ip Destination IP address.
 * @param dst_port Destination UDP port.
 *
 * If the PCB already has a remote address association, it will
 * be restored after the data is sent.
 * 
 * @return lwIP error code.
 * - ERR_OK. Successful. No error occured.
 * - ERR_MEM. Out of memory.
 * - ERR_RTE. Could not find route to destination address.
 *
 * @see udp_disconnect() udp_send()
 */
err_t
udp_sendto(struct udp_pcb *pcb, struct pbuf *p,
  struct ip_addr *dst_ip, u16_t dst_port)
{
  1150d0:	55                   	push   %ebp
  1150d1:	89 e5                	mov    %esp,%ebp
  1150d3:	83 ec 28             	sub    $0x28,%esp
  1150d6:	8b 45 14             	mov    0x14(%ebp),%eax
  1150d9:	66 89 45 ec          	mov    %ax,0xffffffec(%ebp)
  err_t err;
  struct ip_addr pcb_remote_ip;
  u16_t pcb_remote_port;
  /* remember remote peer address of PCB */
  pcb_remote_ip.addr = pcb->remote_ip.addr;
  1150dd:	8b 45 08             	mov    0x8(%ebp),%eax
  1150e0:	8b 40 04             	mov    0x4(%eax),%eax
  1150e3:	89 45 f9             	mov    %eax,0xfffffff9(%ebp)
  pcb_remote_port = pcb->remote_port;
  1150e6:	8b 45 08             	mov    0x8(%ebp),%eax
  1150e9:	0f b7 40 14          	movzwl 0x14(%eax),%eax
  1150ed:	66 89 45 fe          	mov    %ax,0xfffffffe(%ebp)
  /* copy packet destination address to PCB remote peer address */
  pcb->remote_ip.addr = dst_ip->addr;
  1150f1:	8b 45 10             	mov    0x10(%ebp),%eax
  1150f4:	8b 10                	mov    (%eax),%edx
  1150f6:	8b 45 08             	mov    0x8(%ebp),%eax
  1150f9:	89 50 04             	mov    %edx,0x4(%eax)
  pcb->remote_port = dst_port;
  1150fc:	8b 55 08             	mov    0x8(%ebp),%edx
  1150ff:	0f b7 45 ec          	movzwl 0xffffffec(%ebp),%eax
  115103:	66 89 42 14          	mov    %ax,0x14(%edx)
  /* send to the packet destination address */
  err = udp_send(pcb, p);
  115107:	8b 45 0c             	mov    0xc(%ebp),%eax
  11510a:	89 44 24 04          	mov    %eax,0x4(%esp)
  11510e:	8b 45 08             	mov    0x8(%ebp),%eax
  115111:	89 04 24             	mov    %eax,(%esp)
  115114:	e8 27 00 00 00       	call   115140 <udp_send>
  115119:	88 45 fd             	mov    %al,0xfffffffd(%ebp)
  /* reset PCB remote peer address */
  pcb->remote_ip.addr = pcb_remote_ip.addr;
  11511c:	8b 55 f9             	mov    0xfffffff9(%ebp),%edx
  11511f:	8b 45 08             	mov    0x8(%ebp),%eax
  115122:	89 50 04             	mov    %edx,0x4(%eax)
  pcb->remote_port = pcb_remote_port;
  115125:	8b 55 08             	mov    0x8(%ebp),%edx
  115128:	0f b7 45 fe          	movzwl 0xfffffffe(%ebp),%eax
  11512c:	66 89 42 14          	mov    %ax,0x14(%edx)
  return err;
  115130:	0f be 45 fd          	movsbl 0xfffffffd(%ebp),%eax
}
  115134:	c9                   	leave  
  115135:	c3                   	ret    
  115136:	8d 76 00             	lea    0x0(%esi),%esi
  115139:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00115140 <udp_send>:

/**
 * Send data using UDP.
 *
 * @param pcb UDP PCB used to send the data.
 * @param pbuf chain of pbuf's to be sent.
 *
 * @return lwIP error code.
 * - ERR_OK. Successful. No error occured.
 * - ERR_MEM. Out of memory.
 * - ERR_RTE. Could not find route to destination address.
 *
 * @see udp_disconnect() udp_sendto()
 */
err_t
udp_send(struct udp_pcb *pcb, struct pbuf *p)
{
  115140:	55                   	push   %ebp
  115141:	89 e5                	mov    %esp,%ebp
  115143:	53                   	push   %ebx
  115144:	83 ec 44             	sub    $0x44,%esp
  struct udp_hdr *udphdr;
  struct netif *netif;
  struct ip_addr *src_ip;
  err_t err;
  struct pbuf *q; /* q will be sent down the stack */

  LWIP_DEBUGF(UDP_DEBUG | DBG_TRACE | 3, ("udp_send\n"));

  /* if the PCB is not yet bound to a port, bind it here */
  if (pcb->local_port == 0) {
  115147:	8b 45 08             	mov    0x8(%ebp),%eax
  11514a:	0f b7 40 12          	movzwl 0x12(%eax),%eax
  11514e:	66 85 c0             	test   %ax,%ax
  115151:	75 35                	jne    115188 <udp_send+0x48>
    LWIP_DEBUGF(UDP_DEBUG | DBG_TRACE | 2, ("udp_send: not yet bound to a port, binding now\n"));
    err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
  115153:	8b 45 08             	mov    0x8(%ebp),%eax
  115156:	0f b7 40 12          	movzwl 0x12(%eax),%eax
  11515a:	0f b7 c0             	movzwl %ax,%eax
  11515d:	8b 55 08             	mov    0x8(%ebp),%edx
  115160:	89 44 24 08          	mov    %eax,0x8(%esp)
  115164:	89 54 24 04          	mov    %edx,0x4(%esp)
  115168:	8b 45 08             	mov    0x8(%ebp),%eax
  11516b:	89 04 24             	mov    %eax,(%esp)
  11516e:	e8 ed 02 00 00       	call   115460 <udp_bind>
  115173:	88 45 f7             	mov    %al,0xfffffff7(%ebp)
    if (err != ERR_OK) {
  115176:	80 7d f7 00          	cmpb   $0x0,0xfffffff7(%ebp)
  11517a:	74 0c                	je     115188 <udp_send+0x48>
      LWIP_DEBUGF(UDP_DEBUG | DBG_TRACE | 2, ("udp_send: forced port bind failed\n"));
      return err;
  11517c:	0f be 45 f7          	movsbl 0xfffffff7(%ebp),%eax
  115180:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
  115183:	e9 c3 02 00 00       	jmp    11544b <udp_send+0x30b>
    }
  }

  /* not enough space to add an UDP header to first pbuf in given p chain? */
  if (pbuf_header(p, UDP_HLEN)) {
  115188:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
  11518f:	00 
  115190:	8b 45 0c             	mov    0xc(%ebp),%eax
  115193:	89 04 24             	mov    %eax,(%esp)
  115196:	e8 15 a2 ff ff       	call   10f3b0 <pbuf_header>
  11519b:	84 c0                	test   %al,%al
  11519d:	74 45                	je     1151e4 <udp_send+0xa4>
    /* allocate header in a seperate new pbuf */
    q = pbuf_alloc(PBUF_IP, UDP_HLEN, PBUF_RAM);
  11519f:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  1151a6:	00 
  1151a7:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
  1151ae:	00 
  1151af:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  1151b6:	e8 15 9e ff ff       	call   10efd0 <pbuf_alloc>
  1151bb:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
  1151be:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  1151c2:	75 0c                	jne    1151d0 <udp_send+0x90>
      LWIP_DEBUGF(UDP_DEBUG | DBG_TRACE | 2, ("udp_send: could not allocate header\n"));
      return ERR_MEM;
  1151c4:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,0xffffffd8(%ebp)
  1151cb:	e9 7b 02 00 00       	jmp    11544b <udp_send+0x30b>
    }
    /* chain header q in front of given pbuf p */
    pbuf_chain(q, p);
  1151d0:	8b 45 0c             	mov    0xc(%ebp),%eax
  1151d3:	89 44 24 04          	mov    %eax,0x4(%esp)
  1151d7:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1151da:	89 04 24             	mov    %eax,(%esp)
  1151dd:	e8 ce a4 ff ff       	call   10f6b0 <pbuf_chain>
  1151e2:	eb 06                	jmp    1151ea <udp_send+0xaa>
    /* { first pbuf q points to header pbuf } */
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
  /* adding a header within p succeeded */
  } else {
    /* first pbuf q equals given pbuf */
    q = p;
  1151e4:	8b 45 0c             	mov    0xc(%ebp),%eax
  1151e7:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: added header in given pbuf %p\n", (void *)p));
  }
  /* { q now represents the packet to be sent } */
  udphdr = q->payload;
  1151ea:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1151ed:	8b 40 04             	mov    0x4(%eax),%eax
  1151f0:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
  udphdr->src = htons(pcb->local_port);
  1151f3:	8b 45 08             	mov    0x8(%ebp),%eax
  1151f6:	0f b7 40 12          	movzwl 0x12(%eax),%eax
  1151fa:	0f b7 c0             	movzwl %ax,%eax
  1151fd:	89 04 24             	mov    %eax,(%esp)
  115200:	e8 6b 90 ff ff       	call   10e270 <htons>
  115205:	89 c2                	mov    %eax,%edx
  115207:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  11520a:	66 89 10             	mov    %dx,(%eax)
  udphdr->dest = htons(pcb->remote_port);
  11520d:	8b 45 08             	mov    0x8(%ebp),%eax
  115210:	0f b7 40 14          	movzwl 0x14(%eax),%eax
  115214:	0f b7 c0             	movzwl %ax,%eax
  115217:	89 04 24             	mov    %eax,(%esp)
  11521a:	e8 51 90 ff ff       	call   10e270 <htons>
  11521f:	89 c2                	mov    %eax,%edx
  115221:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  115224:	66 89 50 02          	mov    %dx,0x2(%eax)
  /* in UDP, 0 checksum means 'no checksum' */
  udphdr->chksum = 0x0000; 
  115228:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  11522b:	66 c7 40 06 00 00    	movw   $0x0,0x6(%eax)

  /* find the outgoing network interface for this packet */
  if ((netif = ip_route(&(pcb->remote_ip))) == NULL) {
  115231:	8b 45 08             	mov    0x8(%ebp),%eax
  115234:	83 c0 04             	add    $0x4,%eax
  115237:	89 04 24             	mov    %eax,(%esp)
  11523a:	e8 b1 78 ff ff       	call   10caf0 <ip_route>
  11523f:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  115242:	83 7d ec 00          	cmpl   $0x0,0xffffffec(%ebp)
  115246:	75 1c                	jne    115264 <udp_send+0x124>
    LWIP_DEBUGF(UDP_DEBUG | 1, ("udp_send: No route to 0x%lx\n", pcb->remote_ip.addr));
    UDP_STATS_INC(udp.rterr);
  115248:	0f b7 05 58 15 14 00 	movzwl 0x141558,%eax
  11524f:	83 c0 01             	add    $0x1,%eax
  115252:	66 a3 58 15 14 00    	mov    %ax,0x141558
    return ERR_RTE;
  115258:	c7 45 d8 f7 ff ff ff 	movl   $0xfffffff7,0xffffffd8(%ebp)
  11525f:	e9 e7 01 00 00       	jmp    11544b <udp_send+0x30b>
  }
  /* PCB local address is IP_ANY_ADDR? */
  if (ip_addr_isany(&pcb->local_ip)) {
  115264:	8b 45 08             	mov    0x8(%ebp),%eax
  115267:	85 c0                	test   %eax,%eax
  115269:	74 09                	je     115274 <udp_send+0x134>
  11526b:	8b 45 08             	mov    0x8(%ebp),%eax
  11526e:	8b 00                	mov    (%eax),%eax
  115270:	85 c0                	test   %eax,%eax
  115272:	75 0b                	jne    11527f <udp_send+0x13f>
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
  115274:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  115277:	83 c0 04             	add    $0x4,%eax
  11527a:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
  11527d:	eb 06                	jmp    115285 <udp_send+0x145>
  } else {
    /* use UDP PCB local IP address as source address */
    src_ip = &(pcb->local_ip);
  11527f:	8b 45 08             	mov    0x8(%ebp),%eax
  115282:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
  }

  LWIP_DEBUGF(UDP_DEBUG, ("udp_send: sending datagram of length %u\n", q->tot_len));

  /* UDP Lite protocol? */
  if (pcb->flags & UDP_FLAGS_UDPLITE) {
  115285:	8b 45 08             	mov    0x8(%ebp),%eax
  115288:	0f b6 40 10          	movzbl 0x10(%eax),%eax
  11528c:	0f b6 c0             	movzbl %al,%eax
  11528f:	83 e0 02             	and    $0x2,%eax
  115292:	85 c0                	test   %eax,%eax
  115294:	0f 84 ba 00 00 00    	je     115354 <udp_send+0x214>
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP LITE packet length %u\n", q->tot_len));
    /* set UDP message length in UDP header */
    udphdr->len = htons(pcb->chksum_len);
  11529a:	8b 45 08             	mov    0x8(%ebp),%eax
  11529d:	0f b7 40 16          	movzwl 0x16(%eax),%eax
  1152a1:	0f b7 c0             	movzwl %ax,%eax
  1152a4:	89 04 24             	mov    %eax,(%esp)
  1152a7:	e8 c4 8f ff ff       	call   10e270 <htons>
  1152ac:	89 c2                	mov    %eax,%edx
  1152ae:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  1152b1:	66 89 50 04          	mov    %dx,0x4(%eax)
    /* calculate checksum */
    udphdr->chksum = inet_chksum_pseudo(q, src_ip, &(pcb->remote_ip),
  1152b5:	8b 45 08             	mov    0x8(%ebp),%eax
  1152b8:	0f b7 40 16          	movzwl 0x16(%eax),%eax
  1152bc:	0f b7 c0             	movzwl %ax,%eax
  1152bf:	8b 55 08             	mov    0x8(%ebp),%edx
  1152c2:	83 c2 04             	add    $0x4,%edx
  1152c5:	89 44 24 10          	mov    %eax,0x10(%esp)
  1152c9:	c7 44 24 0c 11 00 00 	movl   $0x11,0xc(%esp)
  1152d0:	00 
  1152d1:	89 54 24 08          	mov    %edx,0x8(%esp)
  1152d5:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  1152d8:	89 44 24 04          	mov    %eax,0x4(%esp)
  1152dc:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1152df:	89 04 24             	mov    %eax,(%esp)
  1152e2:	e8 49 89 ff ff       	call   10dc30 <inet_chksum_pseudo>
  1152e7:	89 c2                	mov    %eax,%edx
  1152e9:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  1152ec:	66 89 50 06          	mov    %dx,0x6(%eax)
          IP_PROTO_UDP, pcb->chksum_len);
    /* chksum zero must become 0xffff, as zero means 'no checksum' */
    if (udphdr->chksum == 0x0000) udphdr->chksum = 0xffff;
  1152f0:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  1152f3:	0f b7 40 06          	movzwl 0x6(%eax),%eax
  1152f7:	66 85 c0             	test   %ax,%ax
  1152fa:	75 09                	jne    115305 <udp_send+0x1c5>
  1152fc:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  1152ff:	66 c7 40 06 ff ff    	movw   $0xffff,0x6(%eax)
    /* output to IP */
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: ip_output_if (,,,,IP_PROTO_UDPLITE,)\n"));
    err = ip_output_if (q, src_ip, &pcb->remote_ip, pcb->ttl, pcb->tos, IP_PROTO_UDPLITE, netif);    
  115305:	8b 45 08             	mov    0x8(%ebp),%eax
  115308:	0f b6 40 0a          	movzbl 0xa(%eax),%eax
  11530c:	0f b6 d0             	movzbl %al,%edx
  11530f:	8b 45 08             	mov    0x8(%ebp),%eax
  115312:	0f b6 40 0b          	movzbl 0xb(%eax),%eax
  115316:	0f b6 c8             	movzbl %al,%ecx
  115319:	8b 5d 08             	mov    0x8(%ebp),%ebx
  11531c:	83 c3 04             	add    $0x4,%ebx
  11531f:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  115322:	89 44 24 18          	mov    %eax,0x18(%esp)
  115326:	c7 44 24 14 aa 00 00 	movl   $0xaa,0x14(%esp)
  11532d:	00 
  11532e:	89 54 24 10          	mov    %edx,0x10(%esp)
  115332:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
  115336:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  11533a:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  11533d:	89 44 24 04          	mov    %eax,0x4(%esp)
  115341:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  115344:	89 04 24             	mov    %eax,(%esp)
  115347:	e8 14 7c ff ff       	call   10cf60 <ip_output_if>
  11534c:	88 45 f7             	mov    %al,0xfffffff7(%ebp)
  11534f:	e9 c6 00 00 00       	jmp    11541a <udp_send+0x2da>
  /* UDP */
  } else {
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP packet length %u\n", q->tot_len));
    udphdr->len = htons(q->tot_len);
  115354:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  115357:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  11535b:	0f b7 c0             	movzwl %ax,%eax
  11535e:	89 04 24             	mov    %eax,(%esp)
  115361:	e8 0a 8f ff ff       	call   10e270 <htons>
  115366:	89 c2                	mov    %eax,%edx
  115368:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  11536b:	66 89 50 04          	mov    %dx,0x4(%eax)
    /* calculate checksum */
    if ((pcb->flags & UDP_FLAGS_NOCHKSUM) == 0) {
  11536f:	8b 45 08             	mov    0x8(%ebp),%eax
  115372:	0f b6 40 10          	movzbl 0x10(%eax),%eax
  115376:	0f b6 c0             	movzbl %al,%eax
  115379:	83 e0 01             	and    $0x1,%eax
  11537c:	85 c0                	test   %eax,%eax
  11537e:	75 50                	jne    1153d0 <udp_send+0x290>
      udphdr->chksum = inet_chksum_pseudo(q, src_ip, &pcb->remote_ip, IP_PROTO_UDP, q->tot_len);
  115380:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  115383:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  115387:	0f b7 c0             	movzwl %ax,%eax
  11538a:	8b 55 08             	mov    0x8(%ebp),%edx
  11538d:	83 c2 04             	add    $0x4,%edx
  115390:	89 44 24 10          	mov    %eax,0x10(%esp)
  115394:	c7 44 24 0c 11 00 00 	movl   $0x11,0xc(%esp)
  11539b:	00 
  11539c:	89 54 24 08          	mov    %edx,0x8(%esp)
  1153a0:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  1153a3:	89 44 24 04          	mov    %eax,0x4(%esp)
  1153a7:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1153aa:	89 04 24             	mov    %eax,(%esp)
  1153ad:	e8 7e 88 ff ff       	call   10dc30 <inet_chksum_pseudo>
  1153b2:	89 c2                	mov    %eax,%edx
  1153b4:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  1153b7:	66 89 50 06          	mov    %dx,0x6(%eax)
      /* chksum zero must become 0xffff, as zero means 'no checksum' */
      if (udphdr->chksum == 0x0000) udphdr->chksum = 0xffff;
  1153bb:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  1153be:	0f b7 40 06          	movzwl 0x6(%eax),%eax
  1153c2:	66 85 c0             	test   %ax,%ax
  1153c5:	75 09                	jne    1153d0 <udp_send+0x290>
  1153c7:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  1153ca:	66 c7 40 06 ff ff    	movw   $0xffff,0x6(%eax)
    }
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP checksum 0x%04x\n", udphdr->chksum));
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: ip_output_if (,,,,IP_PROTO_UDP,)\n"));
    /* output to IP */
    err = ip_output_if(q, src_ip, &pcb->remote_ip, pcb->ttl, pcb->tos, IP_PROTO_UDP, netif);    
  1153d0:	8b 45 08             	mov    0x8(%ebp),%eax
  1153d3:	0f b6 40 0a          	movzbl 0xa(%eax),%eax
  1153d7:	0f b6 d0             	movzbl %al,%edx
  1153da:	8b 45 08             	mov    0x8(%ebp),%eax
  1153dd:	0f b6 40 0b          	movzbl 0xb(%eax),%eax
  1153e1:	0f b6 c8             	movzbl %al,%ecx
  1153e4:	8b 5d 08             	mov    0x8(%ebp),%ebx
  1153e7:	83 c3 04             	add    $0x4,%ebx
  1153ea:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  1153ed:	89 44 24 18          	mov    %eax,0x18(%esp)
  1153f1:	c7 44 24 14 11 00 00 	movl   $0x11,0x14(%esp)
  1153f8:	00 
  1153f9:	89 54 24 10          	mov    %edx,0x10(%esp)
  1153fd:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
  115401:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  115405:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  115408:	89 44 24 04          	mov    %eax,0x4(%esp)
  11540c:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  11540f:	89 04 24             	mov    %eax,(%esp)
  115412:	e8 49 7b ff ff       	call   10cf60 <ip_output_if>
  115417:	88 45 f7             	mov    %al,0xfffffff7(%ebp)
  }
  /* TODO: must this be increased even if error occured? */
  snmp_inc_udpoutdatagrams();

  /* did we chain a seperate header pbuf earlier? */
  if (q != p) {
  11541a:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  11541d:	3b 45 0c             	cmp    0xc(%ebp),%eax
  115420:	74 12                	je     115434 <udp_send+0x2f4>
    /* free the header pbuf */
    pbuf_free(q); q = NULL;
  115422:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  115425:	89 04 24             	mov    %eax,(%esp)
  115428:	e8 83 a0 ff ff       	call   10f4b0 <pbuf_free>
  11542d:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)
    /* { p is still referenced by the caller, and will live on } */
  }

  UDP_STATS_INC(udp.xmit);
  115434:	0f b7 05 48 15 14 00 	movzwl 0x141548,%eax
  11543b:	83 c0 01             	add    $0x1,%eax
  11543e:	66 a3 48 15 14 00    	mov    %ax,0x141548
  return err;
  115444:	0f be 45 f7          	movsbl 0xfffffff7(%ebp),%eax
  115448:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
  11544b:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
}
  11544e:	83 c4 44             	add    $0x44,%esp
  115451:	5b                   	pop    %ebx
  115452:	5d                   	pop    %ebp
  115453:	c3                   	ret    
  115454:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  11545a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

00115460 <udp_bind>:

/**
 * Bind an UDP PCB.
 *
 * @param pcb UDP PCB to be bound with a local address ipaddr and port.
 * @param ipaddr local IP address to bind with. Use IP_ADDR_ANY to
 * bind to all local interfaces.
 * @param port local UDP port to bind with.
 *
 * @return lwIP error code.
 * - ERR_OK. Successful. No error occured.
 * - ERR_USE. The specified ipaddr and port are already bound to by
 * another UDP PCB.
 *
 * @see udp_disconnect()
 */
err_t
udp_bind(struct udp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  115460:	55                   	push   %ebp
  115461:	89 e5                	mov    %esp,%ebp
  115463:	83 ec 20             	sub    $0x20,%esp
  115466:	8b 45 10             	mov    0x10(%ebp),%eax
  115469:	66 89 45 ec          	mov    %ax,0xffffffec(%ebp)
  struct udp_pcb *ipcb;
  u8_t rebind;
#if SO_REUSE
  int reuse_port_all_set = 1;
  11546d:	c7 45 fc 01 00 00 00 	movl   $0x1,0xfffffffc(%ebp)
#endif /* SO_REUSE */
  LWIP_DEBUGF(UDP_DEBUG | DBG_TRACE | 3, ("udp_bind(ipaddr = "));
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | DBG_TRACE | 3, (", port = %u)\n", port));

  rebind = 0;
  115474:	c6 45 fb 00          	movb   $0x0,0xfffffffb(%ebp)
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  115478:	a1 20 99 13 00       	mov    0x139920,%eax
  11547d:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  115480:	e9 f7 00 00 00       	jmp    11557c <udp_bind+0x11c>
    /* is this UDP PCB already on active list? */
    if (pcb == ipcb) {
  115485:	8b 45 08             	mov    0x8(%ebp),%eax
  115488:	3b 45 f4             	cmp    0xfffffff4(%ebp),%eax
  11548b:	75 09                	jne    115496 <udp_bind+0x36>
      /* pcb may occur at most once in active list */
      LWIP_ASSERT("rebind == 0", rebind == 0);
      /* pcb already in list, just rebind */
      rebind = 1;
  11548d:	c6 45 fb 01          	movb   $0x1,0xfffffffb(%ebp)
  115491:	e9 dd 00 00 00       	jmp    115573 <udp_bind+0x113>
    }

#if SO_REUSE == 0
/* this code does not allow upper layer to share a UDP port for
   listening to broadcast or multicast traffic (See SO_REUSE_ADDR and
   SO_REUSE_PORT under *BSD). TODO: See where it fits instead, OR
   combine with implementation of UDP PCB flags. Leon Woestenberg. */
#ifdef LWIP_UDP_TODO
    /* port matches that of PCB in list? */
    else if ((ipcb->local_port == port) &&
       /* IP address matches, or one is IP_ADDR_ANY? */
       (ip_addr_isany(&(ipcb->local_ip)) ||
       ip_addr_isany(ipaddr) ||
       ip_addr_cmp(&(ipcb->local_ip), ipaddr))) {
      /* other PCB already binds to this local IP and port */
      LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: local port %u already bound by another pcb\n", port));
      return ERR_USE;
    }
#endif

#else /* SO_REUSE */
      /* Search through list of PCB's. 
         
      If there is a PCB bound to specified port and IP_ADDR_ANY another PCB can be bound to the interface IP
      or to the loopback address on the same port if SOF_REUSEADDR is set. Any combination of PCB's bound to 
      the same local port, but to one address out of {IP_ADDR_ANY, 127.0.0.1, interface IP} at a time is valid.
      But no two PCB's bound to same local port and same local address is valid.
      
      If SOF_REUSEPORT is set several PCB's can be bound to same local port and same local address also. But then 
      all PCB's must have the SOF_REUSEPORT option set.
      
      When the two options aren't set and specified port is already bound, ERR_USE is returned saying that 
      address is already in use. */
    else if (ipcb->local_port == port) {
  115496:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  115499:	0f b7 40 12          	movzwl 0x12(%eax),%eax
  11549d:	66 3b 45 ec          	cmp    0xffffffec(%ebp),%ax
  1154a1:	0f 85 cc 00 00 00    	jne    115573 <udp_bind+0x113>
      if(ip_addr_cmp(&(ipcb->local_ip), ipaddr)) {
  1154a7:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  1154aa:	8b 10                	mov    (%eax),%edx
  1154ac:	8b 45 0c             	mov    0xc(%ebp),%eax
  1154af:	8b 00                	mov    (%eax),%eax
  1154b1:	39 c2                	cmp    %eax,%edx
  1154b3:	75 50                	jne    115505 <udp_bind+0xa5>
        if(pcb->so_options & SOF_REUSEPORT) {
  1154b5:	8b 45 08             	mov    0x8(%ebp),%eax
  1154b8:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  1154bc:	0f b7 c0             	movzwl %ax,%eax
  1154bf:	25 00 02 00 00       	and    $0x200,%eax
  1154c4:	85 c0                	test   %eax,%eax
  1154c6:	74 31                	je     1154f9 <udp_bind+0x99>
          LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: in UDP PCB's SO_REUSEPORT set and same address.\n"));
          reuse_port_all_set = (reuse_port_all_set && (ipcb->so_options & SOF_REUSEPORT));
  1154c8:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  1154cc:	74 1c                	je     1154ea <udp_bind+0x8a>
  1154ce:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  1154d1:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  1154d5:	0f b7 c0             	movzwl %ax,%eax
  1154d8:	25 00 02 00 00       	and    $0x200,%eax
  1154dd:	85 c0                	test   %eax,%eax
  1154df:	74 09                	je     1154ea <udp_bind+0x8a>
  1154e1:	c7 45 e0 01 00 00 00 	movl   $0x1,0xffffffe0(%ebp)
  1154e8:	eb 07                	jmp    1154f1 <udp_bind+0x91>
  1154ea:	c7 45 e0 00 00 00 00 	movl   $0x0,0xffffffe0(%ebp)
  1154f1:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  1154f4:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  1154f7:	eb 7a                	jmp    115573 <udp_bind+0x113>
        }
        else {
          LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: in UDP PCB's SO_REUSEPORT not set and same address.\n"));
          return ERR_USE;
  1154f9:	c7 45 e4 f6 ff ff ff 	movl   $0xfffffff6,0xffffffe4(%ebp)
  115500:	e9 36 01 00 00       	jmp    11563b <udp_bind+0x1db>
        }
      }
      else if((ip_addr_isany(ipaddr) && !ip_addr_isany(&(ipcb->local_ip))) ||
  115505:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  115509:	74 09                	je     115514 <udp_bind+0xb4>
  11550b:	8b 45 0c             	mov    0xc(%ebp),%eax
  11550e:	8b 00                	mov    (%eax),%eax
  115510:	85 c0                	test   %eax,%eax
  115512:	75 10                	jne    115524 <udp_bind+0xc4>
  115514:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  115517:	85 c0                	test   %eax,%eax
  115519:	74 09                	je     115524 <udp_bind+0xc4>
  11551b:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  11551e:	8b 00                	mov    (%eax),%eax
  115520:	85 c0                	test   %eax,%eax
  115522:	75 1f                	jne    115543 <udp_bind+0xe3>
  115524:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  115528:	74 49                	je     115573 <udp_bind+0x113>
  11552a:	8b 45 0c             	mov    0xc(%ebp),%eax
  11552d:	8b 00                	mov    (%eax),%eax
  11552f:	85 c0                	test   %eax,%eax
  115531:	74 40                	je     115573 <udp_bind+0x113>
  115533:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  115536:	85 c0                	test   %eax,%eax
  115538:	74 09                	je     115543 <udp_bind+0xe3>
  11553a:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  11553d:	8b 00                	mov    (%eax),%eax
  11553f:	85 c0                	test   %eax,%eax
  115541:	75 30                	jne    115573 <udp_bind+0x113>
              (!ip_addr_isany(ipaddr) && ip_addr_isany(&(ipcb->local_ip)))) {
        if(!(pcb->so_options & SOF_REUSEADDR) && !(pcb->so_options & SOF_REUSEPORT)) {
  115543:	8b 45 08             	mov    0x8(%ebp),%eax
  115546:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  11554a:	0f b7 c0             	movzwl %ax,%eax
  11554d:	83 e0 04             	and    $0x4,%eax
  115550:	85 c0                	test   %eax,%eax
  115552:	75 1f                	jne    115573 <udp_bind+0x113>
  115554:	8b 45 08             	mov    0x8(%ebp),%eax
  115557:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  11555b:	0f b7 c0             	movzwl %ax,%eax
  11555e:	25 00 02 00 00       	and    $0x200,%eax
  115563:	85 c0                	test   %eax,%eax
  115565:	75 0c                	jne    115573 <udp_bind+0x113>
          LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: in UDP PCB's SO_REUSEPORT or SO_REUSEADDR not set and not the same address.\n"));
          return ERR_USE;
  115567:	c7 45 e4 f6 ff ff ff 	movl   $0xfffffff6,0xffffffe4(%ebp)
  11556e:	e9 c8 00 00 00       	jmp    11563b <udp_bind+0x1db>
  115573:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  115576:	8b 40 0c             	mov    0xc(%eax),%eax
  115579:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  11557c:	83 7d f4 00          	cmpl   $0x0,0xfffffff4(%ebp)
  115580:	0f 85 ff fe ff ff    	jne    115485 <udp_bind+0x25>
        }           
      }
    }
#endif /* SO_REUSE */

  }

#if SO_REUSE
  /* If SOF_REUSEPORT isn't set in all PCB's bound to specified port and local address specified then 
     {IP, port} can't be reused. */
  if(!reuse_port_all_set) {
  115586:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  11558a:	75 0c                	jne    115598 <udp_bind+0x138>
    LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: not all sockets have SO_REUSEPORT set.\n"));
    return ERR_USE;
  11558c:	c7 45 e4 f6 ff ff ff 	movl   $0xfffffff6,0xffffffe4(%ebp)
  115593:	e9 a3 00 00 00       	jmp    11563b <udp_bind+0x1db>
  }
#endif /* SO_REUSE */

  ip_addr_set(&pcb->local_ip, ipaddr);
  115598:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  11559c:	74 0a                	je     1155a8 <udp_bind+0x148>
  11559e:	8b 45 0c             	mov    0xc(%ebp),%eax
  1155a1:	8b 00                	mov    (%eax),%eax
  1155a3:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
  1155a6:	eb 07                	jmp    1155af <udp_bind+0x14f>
  1155a8:	c7 45 e8 00 00 00 00 	movl   $0x0,0xffffffe8(%ebp)
  1155af:	8b 45 08             	mov    0x8(%ebp),%eax
  1155b2:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
  1155b5:	89 10                	mov    %edx,(%eax)
  /* no port specified? */
  if (port == 0) {
  1155b7:	66 83 7d ec 00       	cmpw   $0x0,0xffffffec(%ebp)
  1155bc:	75 52                	jne    115610 <udp_bind+0x1b0>
#ifndef UDP_LOCAL_PORT_RANGE_START
#define UDP_LOCAL_PORT_RANGE_START 4096
#define UDP_LOCAL_PORT_RANGE_END   0x7fff
#endif
    port = UDP_LOCAL_PORT_RANGE_START;
  1155be:	66 c7 45 ec 00 10    	movw   $0x1000,0xffffffec(%ebp)
    ipcb = udp_pcbs;
  1155c4:	a1 20 99 13 00       	mov    0x139920,%eax
  1155c9:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
    while ((ipcb != NULL) && (port != UDP_LOCAL_PORT_RANGE_END)) {
  1155cc:	eb 25                	jmp    1155f3 <udp_bind+0x193>
      if (ipcb->local_port == port) {
  1155ce:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  1155d1:	0f b7 40 12          	movzwl 0x12(%eax),%eax
  1155d5:	66 3b 45 ec          	cmp    0xffffffec(%ebp),%ax
  1155d9:	75 0f                	jne    1155ea <udp_bind+0x18a>
        port++;
  1155db:	66 83 45 ec 01       	addw   $0x1,0xffffffec(%ebp)
        ipcb = udp_pcbs;
  1155e0:	a1 20 99 13 00       	mov    0x139920,%eax
  1155e5:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  1155e8:	eb 09                	jmp    1155f3 <udp_bind+0x193>
      } else
        ipcb = ipcb->next;
  1155ea:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  1155ed:	8b 40 0c             	mov    0xc(%eax),%eax
  1155f0:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  1155f3:	83 7d f4 00          	cmpl   $0x0,0xfffffff4(%ebp)
  1155f7:	74 08                	je     115601 <udp_bind+0x1a1>
  1155f9:	66 81 7d ec ff 7f    	cmpw   $0x7fff,0xffffffec(%ebp)
  1155ff:	75 cd                	jne    1155ce <udp_bind+0x16e>
    }
    if (ipcb != NULL) {
  115601:	83 7d f4 00          	cmpl   $0x0,0xfffffff4(%ebp)
  115605:	74 09                	je     115610 <udp_bind+0x1b0>
      /* no more ports available in local range */
      LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: out of free UDP ports\n"));
      return ERR_USE;
  115607:	c7 45 e4 f6 ff ff ff 	movl   $0xfffffff6,0xffffffe4(%ebp)
  11560e:	eb 2b                	jmp    11563b <udp_bind+0x1db>
    }
  }
  pcb->local_port = port;
  115610:	8b 55 08             	mov    0x8(%ebp),%edx
  115613:	0f b7 45 ec          	movzwl 0xffffffec(%ebp),%eax
  115617:	66 89 42 12          	mov    %ax,0x12(%edx)
  /* pcb not active yet? */
  if (rebind == 0) {
  11561b:	80 7d fb 00          	cmpb   $0x0,0xfffffffb(%ebp)
  11561f:	75 13                	jne    115634 <udp_bind+0x1d4>
    /* place the PCB on the active list if not already there */
    pcb->next = udp_pcbs;
  115621:	a1 20 99 13 00       	mov    0x139920,%eax
  115626:	8b 55 08             	mov    0x8(%ebp),%edx
  115629:	89 42 0c             	mov    %eax,0xc(%edx)
    udp_pcbs = pcb;
  11562c:	8b 45 08             	mov    0x8(%ebp),%eax
  11562f:	a3 20 99 13 00       	mov    %eax,0x139920
  }
  LWIP_DEBUGF(UDP_DEBUG | DBG_TRACE | DBG_STATE, ("udp_bind: bound to %u.%u.%u.%u, port %u\n",
   (unsigned int)(ntohl(pcb->local_ip.addr) >> 24 & 0xff),
   (unsigned int)(ntohl(pcb->local_ip.addr) >> 16 & 0xff),
   (unsigned int)(ntohl(pcb->local_ip.addr) >> 8 & 0xff),
   (unsigned int)(ntohl(pcb->local_ip.addr) & 0xff), pcb->local_port));
  return ERR_OK;
  115634:	c7 45 e4 00 00 00 00 	movl   $0x0,0xffffffe4(%ebp)
  11563b:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
}
  11563e:	c9                   	leave  
  11563f:	c3                   	ret    

00115640 <udp_connect>:
/**
 * Connect an UDP PCB.
 *
 * This will associate the UDP PCB with the remote address.
 *
 * @param pcb UDP PCB to be connected with remote address ipaddr and port.
 * @param ipaddr remote IP address to connect with.
 * @param port remote UDP port to connect with.
 *
 * @return lwIP error code
 *
 * @see udp_disconnect()
 */
err_t
udp_connect(struct udp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  115640:	55                   	push   %ebp
  115641:	89 e5                	mov    %esp,%ebp
  115643:	83 ec 28             	sub    $0x28,%esp
  115646:	8b 45 10             	mov    0x10(%ebp),%eax
  115649:	66 89 45 ec          	mov    %ax,0xffffffec(%ebp)
  struct udp_pcb *ipcb;

  if (pcb->local_port == 0) {
  11564d:	8b 45 08             	mov    0x8(%ebp),%eax
  115650:	0f b7 40 12          	movzwl 0x12(%eax),%eax
  115654:	66 85 c0             	test   %ax,%ax
  115657:	75 35                	jne    11568e <udp_connect+0x4e>
    err_t err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
  115659:	8b 45 08             	mov    0x8(%ebp),%eax
  11565c:	0f b7 40 12          	movzwl 0x12(%eax),%eax
  115660:	0f b7 c0             	movzwl %ax,%eax
  115663:	8b 55 08             	mov    0x8(%ebp),%edx
  115666:	89 44 24 08          	mov    %eax,0x8(%esp)
  11566a:	89 54 24 04          	mov    %edx,0x4(%esp)
  11566e:	8b 45 08             	mov    0x8(%ebp),%eax
  115671:	89 04 24             	mov    %eax,(%esp)
  115674:	e8 e7 fd ff ff       	call   115460 <udp_bind>
  115679:	88 45 ff             	mov    %al,0xffffffff(%ebp)
    if (err != ERR_OK)
  11567c:	80 7d ff 00          	cmpb   $0x0,0xffffffff(%ebp)
  115680:	74 0c                	je     11568e <udp_connect+0x4e>
      return err;
  115682:	0f be 45 ff          	movsbl 0xffffffff(%ebp),%eax
  115686:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
  115689:	e9 81 00 00 00       	jmp    11570f <udp_connect+0xcf>
  }

  ip_addr_set(&pcb->remote_ip, ipaddr);
  11568e:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  115692:	74 0a                	je     11569e <udp_connect+0x5e>
  115694:	8b 45 0c             	mov    0xc(%ebp),%eax
  115697:	8b 00                	mov    (%eax),%eax
  115699:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
  11569c:	eb 07                	jmp    1156a5 <udp_connect+0x65>
  11569e:	c7 45 e8 00 00 00 00 	movl   $0x0,0xffffffe8(%ebp)
  1156a5:	8b 45 08             	mov    0x8(%ebp),%eax
  1156a8:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
  1156ab:	89 50 04             	mov    %edx,0x4(%eax)
  pcb->remote_port = port;
  1156ae:	8b 55 08             	mov    0x8(%ebp),%edx
  1156b1:	0f b7 45 ec          	movzwl 0xffffffec(%ebp),%eax
  1156b5:	66 89 42 14          	mov    %ax,0x14(%edx)
  pcb->flags |= UDP_FLAGS_CONNECTED;
  1156b9:	8b 45 08             	mov    0x8(%ebp),%eax
  1156bc:	0f b6 40 10          	movzbl 0x10(%eax),%eax
  1156c0:	89 c2                	mov    %eax,%edx
  1156c2:	83 ca 04             	or     $0x4,%edx
  1156c5:	8b 45 08             	mov    0x8(%ebp),%eax
  1156c8:	88 50 10             	mov    %dl,0x10(%eax)
/** TODO: this functionality belongs in upper layers */
#ifdef LWIP_UDP_TODO
  /* Nail down local IP for netconn_addr()/getsockname() */
  if (ip_addr_isany(&pcb->local_ip) && !ip_addr_isany(&pcb->remote_ip)) {
    struct netif *netif;

    if ((netif = ip_route(&(pcb->remote_ip))) == NULL) {
      LWIP_DEBUGF(UDP_DEBUG, ("udp_connect: No route to 0x%lx\n", pcb->remote_ip.addr));
        UDP_STATS_INC(udp.rterr);
      return ERR_RTE;
    }
    /** TODO: this will bind the udp pcb locally, to the interface which
        is used to route output packets to the remote address. However, we
        might want to accept incoming packets on any interface! */
    pcb->local_ip = netif->ip_addr;
  } else if (ip_addr_isany(&pcb->remote_ip)) {
    pcb->local_ip.addr = 0;
  }
#endif
  LWIP_DEBUGF(UDP_DEBUG | DBG_TRACE | DBG_STATE, ("udp_connect: connected to %u.%u.%u.%u, port %u\n",
   (unsigned int)(ntohl(pcb->remote_ip.addr) >> 24 & 0xff),
   (unsigned int)(ntohl(pcb->remote_ip.addr) >> 16 & 0xff),
   (unsigned int)(ntohl(pcb->remote_ip.addr) >> 8 & 0xff),
   (unsigned int)(ntohl(pcb->remote_ip.addr) & 0xff), pcb->remote_port));

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for(ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  1156cb:	a1 20 99 13 00       	mov    0x139920,%eax
  1156d0:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  1156d3:	eb 1a                	jmp    1156ef <udp_connect+0xaf>
    if (pcb == ipcb) {
  1156d5:	8b 45 08             	mov    0x8(%ebp),%eax
  1156d8:	3b 45 f8             	cmp    0xfffffff8(%ebp),%eax
  1156db:	75 09                	jne    1156e6 <udp_connect+0xa6>
      /* already on the list, just return */
      return ERR_OK;
  1156dd:	c7 45 e4 00 00 00 00 	movl   $0x0,0xffffffe4(%ebp)
  1156e4:	eb 29                	jmp    11570f <udp_connect+0xcf>
  1156e6:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1156e9:	8b 40 0c             	mov    0xc(%eax),%eax
  1156ec:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  1156ef:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  1156f3:	75 e0                	jne    1156d5 <udp_connect+0x95>
    }
  }
  /* PCB not yet on the list, add PCB now */
  pcb->next = udp_pcbs;
  1156f5:	a1 20 99 13 00       	mov    0x139920,%eax
  1156fa:	8b 55 08             	mov    0x8(%ebp),%edx
  1156fd:	89 42 0c             	mov    %eax,0xc(%edx)
  udp_pcbs = pcb;
  115700:	8b 45 08             	mov    0x8(%ebp),%eax
  115703:	a3 20 99 13 00       	mov    %eax,0x139920
  return ERR_OK;
  115708:	c7 45 e4 00 00 00 00 	movl   $0x0,0xffffffe4(%ebp)
  11570f:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
}
  115712:	c9                   	leave  
  115713:	c3                   	ret    
  115714:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  11571a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

00115720 <udp_disconnect>:

void
udp_disconnect(struct udp_pcb *pcb)
{
  115720:	55                   	push   %ebp
  115721:	89 e5                	mov    %esp,%ebp
  /* reset remote address association */
  ip_addr_set(&pcb->remote_ip, IP_ADDR_ANY);
  115723:	b8 af ad 11 00       	mov    $0x11adaf,%eax
  115728:	8b 10                	mov    (%eax),%edx
  11572a:	8b 45 08             	mov    0x8(%ebp),%eax
  11572d:	89 50 04             	mov    %edx,0x4(%eax)
  pcb->remote_port = 0;
  115730:	8b 45 08             	mov    0x8(%ebp),%eax
  115733:	66 c7 40 14 00 00    	movw   $0x0,0x14(%eax)
  /* mark PCB as unconnected */
  pcb->flags &= ~UDP_FLAGS_CONNECTED;
  115739:	8b 45 08             	mov    0x8(%ebp),%eax
  11573c:	0f b6 40 10          	movzbl 0x10(%eax),%eax
  115740:	89 c2                	mov    %eax,%edx
  115742:	83 e2 fb             	and    $0xfffffffb,%edx
  115745:	8b 45 08             	mov    0x8(%ebp),%eax
  115748:	88 50 10             	mov    %dl,0x10(%eax)
}
  11574b:	5d                   	pop    %ebp
  11574c:	c3                   	ret    
  11574d:	8d 76 00             	lea    0x0(%esi),%esi

00115750 <udp_recv>:

void
udp_recv(struct udp_pcb *pcb,
   void (* recv)(void *arg, struct udp_pcb *upcb, struct pbuf *p,
           struct ip_addr *addr, u16_t port),
   void *recv_arg)
{
  115750:	55                   	push   %ebp
  115751:	89 e5                	mov    %esp,%ebp
  /* remember recv() callback and user data */
  pcb->recv = recv;
  115753:	8b 55 08             	mov    0x8(%ebp),%edx
  115756:	8b 45 0c             	mov    0xc(%ebp),%eax
  115759:	89 42 18             	mov    %eax,0x18(%edx)
  pcb->recv_arg = recv_arg;
  11575c:	8b 55 08             	mov    0x8(%ebp),%edx
  11575f:	8b 45 10             	mov    0x10(%ebp),%eax
  115762:	89 42 1c             	mov    %eax,0x1c(%edx)
}
  115765:	5d                   	pop    %ebp
  115766:	c3                   	ret    
  115767:	89 f6                	mov    %esi,%esi
  115769:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00115770 <udp_remove>:
/**
 * Remove an UDP PCB.
 *
 * @param pcb UDP PCB to be removed. The PCB is removed from the list of
 * UDP PCB's and the data structure is freed from memory.
 *
 * @see udp_new()
 */
void
udp_remove(struct udp_pcb *pcb)
{
  115770:	55                   	push   %ebp
  115771:	89 e5                	mov    %esp,%ebp
  115773:	83 ec 18             	sub    $0x18,%esp
  struct udp_pcb *pcb2;
  /* pcb to be removed is first in list? */
  if (udp_pcbs == pcb) {
  115776:	a1 20 99 13 00       	mov    0x139920,%eax
  11577b:	3b 45 08             	cmp    0x8(%ebp),%eax
  11577e:	75 0f                	jne    11578f <udp_remove+0x1f>
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
  115780:	a1 20 99 13 00       	mov    0x139920,%eax
  115785:	8b 40 0c             	mov    0xc(%eax),%eax
  115788:	a3 20 99 13 00       	mov    %eax,0x139920
  11578d:	eb 3a                	jmp    1157c9 <udp_remove+0x59>
  /* pcb not 1st in list */
  } else for(pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  11578f:	a1 20 99 13 00       	mov    0x139920,%eax
  115794:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  115797:	eb 2a                	jmp    1157c3 <udp_remove+0x53>
    /* find pcb in udp_pcbs list */
    if (pcb2->next != NULL && pcb2->next == pcb) {
  115799:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  11579c:	8b 40 0c             	mov    0xc(%eax),%eax
  11579f:	85 c0                	test   %eax,%eax
  1157a1:	74 17                	je     1157ba <udp_remove+0x4a>
  1157a3:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1157a6:	8b 40 0c             	mov    0xc(%eax),%eax
  1157a9:	3b 45 08             	cmp    0x8(%ebp),%eax
  1157ac:	75 0c                	jne    1157ba <udp_remove+0x4a>
      /* remove pcb from list */
      pcb2->next = pcb->next;
  1157ae:	8b 45 08             	mov    0x8(%ebp),%eax
  1157b1:	8b 50 0c             	mov    0xc(%eax),%edx
  1157b4:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1157b7:	89 50 0c             	mov    %edx,0xc(%eax)
  1157ba:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1157bd:	8b 40 0c             	mov    0xc(%eax),%eax
  1157c0:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  1157c3:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  1157c7:	75 d0                	jne    115799 <udp_remove+0x29>
    }
  }
  memp_free(MEMP_UDP_PCB, pcb);
  1157c9:	8b 45 08             	mov    0x8(%ebp),%eax
  1157cc:	89 44 24 04          	mov    %eax,0x4(%esp)
  1157d0:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  1157d7:	e8 d4 92 ff ff       	call   10eab0 <memp_free>
}
  1157dc:	c9                   	leave  
  1157dd:	c3                   	ret    
  1157de:	89 f6                	mov    %esi,%esi

001157e0 <udp_new>:
/**
 * Create a UDP PCB.
 *
 * @return The UDP PCB which was created. NULL if the PCB data structure
 * could not be allocated.
 *
 * @see udp_remove()
 */
struct udp_pcb *
udp_new(void) {
  1157e0:	55                   	push   %ebp
  1157e1:	89 e5                	mov    %esp,%ebp
  1157e3:	83 ec 28             	sub    $0x28,%esp
  struct udp_pcb *pcb;
  pcb = memp_malloc(MEMP_UDP_PCB);
  1157e6:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  1157ed:	e8 ce 91 ff ff       	call   10e9c0 <memp_malloc>
  1157f2:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  /* could allocate UDP PCB? */
  if (pcb != NULL) {
  1157f5:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  1157f9:	74 22                	je     11581d <udp_new+0x3d>
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct udp_pcb));
  1157fb:	c7 44 24 08 20 00 00 	movl   $0x20,0x8(%esp)
  115802:	00 
  115803:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  11580a:	00 
  11580b:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  11580e:	89 04 24             	mov    %eax,(%esp)
  115811:	e8 ea 06 ff ff       	call   105f00 <memset>
    pcb->ttl = UDP_TTL;
  115816:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  115819:	c6 40 0b ff          	movb   $0xff,0xb(%eax)
  }
  
  
  return pcb;
  11581d:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
}
  115820:	c9                   	leave  
  115821:	c3                   	ret    
  115822:	90                   	nop    
  115823:	90                   	nop    
  115824:	90                   	nop    
  115825:	90                   	nop    
  115826:	90                   	nop    
  115827:	90                   	nop    
  115828:	90                   	nop    
  115829:	90                   	nop    
  11582a:	90                   	nop    
  11582b:	90                   	nop    
  11582c:	90                   	nop    
  11582d:	90                   	nop    
  11582e:	90                   	nop    
  11582f:	90                   	nop    

00115830 <netbuf_new>:


struct
netbuf *netbuf_new(void)
{
  115830:	55                   	push   %ebp
  115831:	89 e5                	mov    %esp,%ebp
  115833:	83 ec 18             	sub    $0x18,%esp
  struct netbuf *buf;

  buf = memp_malloc(MEMP_NETBUF);
  115836:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  11583d:	e8 7e 91 ff ff       	call   10e9c0 <memp_malloc>
  115842:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  if (buf != NULL) {
  115845:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  115849:	74 1b                	je     115866 <netbuf_new+0x36>
    buf->p = NULL;
  11584b:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  11584e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    buf->ptr = NULL;
  115854:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  115857:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    return buf;
  11585e:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  115861:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  115864:	eb 07                	jmp    11586d <netbuf_new+0x3d>
  } else {
    return NULL;
  115866:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  11586d:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  }
}
  115870:	c9                   	leave  
  115871:	c3                   	ret    
  115872:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi
  115879:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00115880 <netbuf_delete>:

void
netbuf_delete(struct netbuf *buf)
{
  115880:	55                   	push   %ebp
  115881:	89 e5                	mov    %esp,%ebp
  115883:	83 ec 08             	sub    $0x8,%esp
  if (buf != NULL) {
  115886:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  11588a:	74 3e                	je     1158ca <netbuf_delete+0x4a>
    if (buf->p != NULL) {
  11588c:	8b 45 08             	mov    0x8(%ebp),%eax
  11588f:	8b 00                	mov    (%eax),%eax
  115891:	85 c0                	test   %eax,%eax
  115893:	74 22                	je     1158b7 <netbuf_delete+0x37>
      pbuf_free(buf->p);
  115895:	8b 45 08             	mov    0x8(%ebp),%eax
  115898:	8b 00                	mov    (%eax),%eax
  11589a:	89 04 24             	mov    %eax,(%esp)
  11589d:	e8 0e 9c ff ff       	call   10f4b0 <pbuf_free>
      buf->p = buf->ptr = NULL;
  1158a2:	8b 45 08             	mov    0x8(%ebp),%eax
  1158a5:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  1158ac:	8b 45 08             	mov    0x8(%ebp),%eax
  1158af:	8b 50 04             	mov    0x4(%eax),%edx
  1158b2:	8b 45 08             	mov    0x8(%ebp),%eax
  1158b5:	89 10                	mov    %edx,(%eax)
    }
    memp_free(MEMP_NETBUF, buf);
  1158b7:	8b 45 08             	mov    0x8(%ebp),%eax
  1158ba:	89 44 24 04          	mov    %eax,0x4(%esp)
  1158be:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  1158c5:	e8 e6 91 ff ff       	call   10eab0 <memp_free>
  }
}
  1158ca:	c9                   	leave  
  1158cb:	c3                   	ret    
  1158cc:	8d 74 26 00          	lea    0x0(%esi),%esi

001158d0 <netbuf_alloc>:

void *
netbuf_alloc(struct netbuf *buf, u16_t size)
{
  1158d0:	55                   	push   %ebp
  1158d1:	89 e5                	mov    %esp,%ebp
  1158d3:	83 ec 18             	sub    $0x18,%esp
  1158d6:	8b 45 0c             	mov    0xc(%ebp),%eax
  1158d9:	66 89 45 fc          	mov    %ax,0xfffffffc(%ebp)
  /* Deallocate any previously allocated memory. */
  if (buf->p != NULL) {
  1158dd:	8b 45 08             	mov    0x8(%ebp),%eax
  1158e0:	8b 00                	mov    (%eax),%eax
  1158e2:	85 c0                	test   %eax,%eax
  1158e4:	74 0d                	je     1158f3 <netbuf_alloc+0x23>
    pbuf_free(buf->p);
  1158e6:	8b 45 08             	mov    0x8(%ebp),%eax
  1158e9:	8b 00                	mov    (%eax),%eax
  1158eb:	89 04 24             	mov    %eax,(%esp)
  1158ee:	e8 bd 9b ff ff       	call   10f4b0 <pbuf_free>
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, size, PBUF_RAM);
  1158f3:	0f b7 45 fc          	movzwl 0xfffffffc(%ebp),%eax
  1158f7:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  1158fe:	00 
  1158ff:	89 44 24 04          	mov    %eax,0x4(%esp)
  115903:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  11590a:	e8 c1 96 ff ff       	call   10efd0 <pbuf_alloc>
  11590f:	89 c2                	mov    %eax,%edx
  115911:	8b 45 08             	mov    0x8(%ebp),%eax
  115914:	89 10                	mov    %edx,(%eax)
  if (buf->p == NULL) {
  115916:	8b 45 08             	mov    0x8(%ebp),%eax
  115919:	8b 00                	mov    (%eax),%eax
  11591b:	85 c0                	test   %eax,%eax
  11591d:	75 09                	jne    115928 <netbuf_alloc+0x58>
     return NULL;
  11591f:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)
  115926:	eb 16                	jmp    11593e <netbuf_alloc+0x6e>
  }
  buf->ptr = buf->p;
  115928:	8b 45 08             	mov    0x8(%ebp),%eax
  11592b:	8b 10                	mov    (%eax),%edx
  11592d:	8b 45 08             	mov    0x8(%ebp),%eax
  115930:	89 50 04             	mov    %edx,0x4(%eax)
  return buf->p->payload;
  115933:	8b 45 08             	mov    0x8(%ebp),%eax
  115936:	8b 00                	mov    (%eax),%eax
  115938:	8b 40 04             	mov    0x4(%eax),%eax
  11593b:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  11593e:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
}
  115941:	c9                   	leave  
  115942:	c3                   	ret    
  115943:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  115949:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00115950 <netbuf_free>:

void
netbuf_free(struct netbuf *buf)
{
  115950:	55                   	push   %ebp
  115951:	89 e5                	mov    %esp,%ebp
  115953:	83 ec 08             	sub    $0x8,%esp
  if (buf->p != NULL) {
  115956:	8b 45 08             	mov    0x8(%ebp),%eax
  115959:	8b 00                	mov    (%eax),%eax
  11595b:	85 c0                	test   %eax,%eax
  11595d:	74 0d                	je     11596c <netbuf_free+0x1c>
    pbuf_free(buf->p);
  11595f:	8b 45 08             	mov    0x8(%ebp),%eax
  115962:	8b 00                	mov    (%eax),%eax
  115964:	89 04 24             	mov    %eax,(%esp)
  115967:	e8 44 9b ff ff       	call   10f4b0 <pbuf_free>
  }
  buf->p = buf->ptr = NULL;
  11596c:	8b 45 08             	mov    0x8(%ebp),%eax
  11596f:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  115976:	8b 45 08             	mov    0x8(%ebp),%eax
  115979:	8b 50 04             	mov    0x4(%eax),%edx
  11597c:	8b 45 08             	mov    0x8(%ebp),%eax
  11597f:	89 10                	mov    %edx,(%eax)
}
  115981:	c9                   	leave  
  115982:	c3                   	ret    
  115983:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  115989:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00115990 <netbuf_ref>:

void
netbuf_ref(struct netbuf *buf, void *dataptr, u16_t size)
{
  115990:	55                   	push   %ebp
  115991:	89 e5                	mov    %esp,%ebp
  115993:	83 ec 18             	sub    $0x18,%esp
  115996:	8b 45 10             	mov    0x10(%ebp),%eax
  115999:	66 89 45 fc          	mov    %ax,0xfffffffc(%ebp)
  if (buf->p != NULL) {
  11599d:	8b 45 08             	mov    0x8(%ebp),%eax
  1159a0:	8b 00                	mov    (%eax),%eax
  1159a2:	85 c0                	test   %eax,%eax
  1159a4:	74 0d                	je     1159b3 <netbuf_ref+0x23>
    pbuf_free(buf->p);
  1159a6:	8b 45 08             	mov    0x8(%ebp),%eax
  1159a9:	8b 00                	mov    (%eax),%eax
  1159ab:	89 04 24             	mov    %eax,(%esp)
  1159ae:	e8 fd 9a ff ff       	call   10f4b0 <pbuf_free>
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, 0, PBUF_REF);
  1159b3:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
  1159ba:	00 
  1159bb:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  1159c2:	00 
  1159c3:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  1159ca:	e8 01 96 ff ff       	call   10efd0 <pbuf_alloc>
  1159cf:	89 c2                	mov    %eax,%edx
  1159d1:	8b 45 08             	mov    0x8(%ebp),%eax
  1159d4:	89 10                	mov    %edx,(%eax)
  buf->p->payload = dataptr;
  1159d6:	8b 45 08             	mov    0x8(%ebp),%eax
  1159d9:	8b 10                	mov    (%eax),%edx
  1159db:	8b 45 0c             	mov    0xc(%ebp),%eax
  1159de:	89 42 04             	mov    %eax,0x4(%edx)
  buf->p->len = buf->p->tot_len = size;
  1159e1:	8b 45 08             	mov    0x8(%ebp),%eax
  1159e4:	8b 08                	mov    (%eax),%ecx
  1159e6:	8b 45 08             	mov    0x8(%ebp),%eax
  1159e9:	8b 10                	mov    (%eax),%edx
  1159eb:	0f b7 45 fc          	movzwl 0xfffffffc(%ebp),%eax
  1159ef:	66 89 42 08          	mov    %ax,0x8(%edx)
  1159f3:	0f b7 42 08          	movzwl 0x8(%edx),%eax
  1159f7:	66 89 41 0a          	mov    %ax,0xa(%ecx)
  buf->ptr = buf->p;
  1159fb:	8b 45 08             	mov    0x8(%ebp),%eax
  1159fe:	8b 10                	mov    (%eax),%edx
  115a00:	8b 45 08             	mov    0x8(%ebp),%eax
  115a03:	89 50 04             	mov    %edx,0x4(%eax)
}
  115a06:	c9                   	leave  
  115a07:	c3                   	ret    
  115a08:	90                   	nop    
  115a09:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

00115a10 <netbuf_chain>:

void
netbuf_chain(struct netbuf *head, struct netbuf *tail)
{
  115a10:	55                   	push   %ebp
  115a11:	89 e5                	mov    %esp,%ebp
  115a13:	83 ec 08             	sub    $0x8,%esp
  pbuf_chain(head->p, tail->p);
  115a16:	8b 45 0c             	mov    0xc(%ebp),%eax
  115a19:	8b 10                	mov    (%eax),%edx
  115a1b:	8b 45 08             	mov    0x8(%ebp),%eax
  115a1e:	8b 00                	mov    (%eax),%eax
  115a20:	89 54 24 04          	mov    %edx,0x4(%esp)
  115a24:	89 04 24             	mov    %eax,(%esp)
  115a27:	e8 84 9c ff ff       	call   10f6b0 <pbuf_chain>
  head->ptr = head->p;
  115a2c:	8b 45 08             	mov    0x8(%ebp),%eax
  115a2f:	8b 10                	mov    (%eax),%edx
  115a31:	8b 45 08             	mov    0x8(%ebp),%eax
  115a34:	89 50 04             	mov    %edx,0x4(%eax)
  memp_free(MEMP_NETBUF, tail);
  115a37:	8b 45 0c             	mov    0xc(%ebp),%eax
  115a3a:	89 44 24 04          	mov    %eax,0x4(%esp)
  115a3e:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  115a45:	e8 66 90 ff ff       	call   10eab0 <memp_free>
}
  115a4a:	c9                   	leave  
  115a4b:	c3                   	ret    
  115a4c:	8d 74 26 00          	lea    0x0(%esi),%esi

00115a50 <netbuf_len>:

u16_t
netbuf_len(struct netbuf *buf)
{
  115a50:	55                   	push   %ebp
  115a51:	89 e5                	mov    %esp,%ebp
  return buf->p->tot_len;
  115a53:	8b 45 08             	mov    0x8(%ebp),%eax
  115a56:	8b 00                	mov    (%eax),%eax
  115a58:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  115a5c:	0f b7 c0             	movzwl %ax,%eax
}
  115a5f:	5d                   	pop    %ebp
  115a60:	c3                   	ret    
  115a61:	eb 0d                	jmp    115a70 <netbuf_data>
  115a63:	90                   	nop    
  115a64:	90                   	nop    
  115a65:	90                   	nop    
  115a66:	90                   	nop    
  115a67:	90                   	nop    
  115a68:	90                   	nop    
  115a69:	90                   	nop    
  115a6a:	90                   	nop    
  115a6b:	90                   	nop    
  115a6c:	90                   	nop    
  115a6d:	90                   	nop    
  115a6e:	90                   	nop    
  115a6f:	90                   	nop    

00115a70 <netbuf_data>:

err_t
netbuf_data(struct netbuf *buf, void **dataptr, u16_t *len)
{
  115a70:	55                   	push   %ebp
  115a71:	89 e5                	mov    %esp,%ebp
  115a73:	83 ec 04             	sub    $0x4,%esp
  if (buf->ptr == NULL) {
  115a76:	8b 45 08             	mov    0x8(%ebp),%eax
  115a79:	8b 40 04             	mov    0x4(%eax),%eax
  115a7c:	85 c0                	test   %eax,%eax
  115a7e:	75 09                	jne    115a89 <netbuf_data+0x19>
    return ERR_BUF;
  115a80:	c7 45 fc fe ff ff ff 	movl   $0xfffffffe,0xfffffffc(%ebp)
  115a87:	eb 25                	jmp    115aae <netbuf_data+0x3e>
  }
  *dataptr = buf->ptr->payload;
  115a89:	8b 45 08             	mov    0x8(%ebp),%eax
  115a8c:	8b 40 04             	mov    0x4(%eax),%eax
  115a8f:	8b 50 04             	mov    0x4(%eax),%edx
  115a92:	8b 45 0c             	mov    0xc(%ebp),%eax
  115a95:	89 10                	mov    %edx,(%eax)
  *len = buf->ptr->len;
  115a97:	8b 45 08             	mov    0x8(%ebp),%eax
  115a9a:	8b 40 04             	mov    0x4(%eax),%eax
  115a9d:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
  115aa1:	8b 45 10             	mov    0x10(%ebp),%eax
  115aa4:	66 89 10             	mov    %dx,(%eax)
  return ERR_OK;
  115aa7:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
  115aae:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
}
  115ab1:	c9                   	leave  
  115ab2:	c3                   	ret    
  115ab3:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  115ab9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00115ac0 <netbuf_next>:

s8_t
netbuf_next(struct netbuf *buf)
{
  115ac0:	55                   	push   %ebp
  115ac1:	89 e5                	mov    %esp,%ebp
  115ac3:	83 ec 04             	sub    $0x4,%esp
  if (buf->ptr->next == NULL) {
  115ac6:	8b 45 08             	mov    0x8(%ebp),%eax
  115ac9:	8b 40 04             	mov    0x4(%eax),%eax
  115acc:	8b 00                	mov    (%eax),%eax
  115ace:	85 c0                	test   %eax,%eax
  115ad0:	75 09                	jne    115adb <netbuf_next+0x1b>
    return -1;
  115ad2:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,0xfffffffc(%ebp)
  115ad9:	eb 2a                	jmp    115b05 <netbuf_next+0x45>
  }
  buf->ptr = buf->ptr->next;
  115adb:	8b 45 08             	mov    0x8(%ebp),%eax
  115ade:	8b 40 04             	mov    0x4(%eax),%eax
  115ae1:	8b 10                	mov    (%eax),%edx
  115ae3:	8b 45 08             	mov    0x8(%ebp),%eax
  115ae6:	89 50 04             	mov    %edx,0x4(%eax)
  if (buf->ptr->next == NULL) {
  115ae9:	8b 45 08             	mov    0x8(%ebp),%eax
  115aec:	8b 40 04             	mov    0x4(%eax),%eax
  115aef:	8b 00                	mov    (%eax),%eax
  115af1:	85 c0                	test   %eax,%eax
  115af3:	75 09                	jne    115afe <netbuf_next+0x3e>
    return 1;
  115af5:	c7 45 fc 01 00 00 00 	movl   $0x1,0xfffffffc(%ebp)
  115afc:	eb 07                	jmp    115b05 <netbuf_next+0x45>
  }
  return 0;
  115afe:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
  115b05:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
}
  115b08:	c9                   	leave  
  115b09:	c3                   	ret    
  115b0a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

00115b10 <netbuf_first>:

void
netbuf_first(struct netbuf *buf)
{
  115b10:	55                   	push   %ebp
  115b11:	89 e5                	mov    %esp,%ebp
  buf->ptr = buf->p;
  115b13:	8b 45 08             	mov    0x8(%ebp),%eax
  115b16:	8b 10                	mov    (%eax),%edx
  115b18:	8b 45 08             	mov    0x8(%ebp),%eax
  115b1b:	89 50 04             	mov    %edx,0x4(%eax)
}
  115b1e:	5d                   	pop    %ebp
  115b1f:	c3                   	ret    

00115b20 <netbuf_copy_partial>:

void
netbuf_copy_partial(struct netbuf *buf, void *dataptr, u16_t len, u16_t offset)
{
  115b20:	55                   	push   %ebp
  115b21:	89 e5                	mov    %esp,%ebp
  115b23:	83 ec 18             	sub    $0x18,%esp
  115b26:	8b 45 10             	mov    0x10(%ebp),%eax
  115b29:	8b 55 14             	mov    0x14(%ebp),%edx
  115b2c:	66 89 45 ec          	mov    %ax,0xffffffec(%ebp)
  115b30:	66 89 55 e8          	mov    %dx,0xffffffe8(%ebp)
  struct pbuf *p;
  u16_t i, left;

  left = 0;
  115b34:	66 c7 45 fe 00 00    	movw   $0x0,0xfffffffe(%ebp)

  if(buf == NULL || dataptr == NULL) {
  115b3a:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  115b3e:	0f 84 a3 00 00 00    	je     115be7 <netbuf_copy_partial+0xc7>
  115b44:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  115b48:	75 05                	jne    115b4f <netbuf_copy_partial+0x2f>
    return;
  115b4a:	e9 98 00 00 00       	jmp    115be7 <netbuf_copy_partial+0xc7>
  }
  
  /* This implementation is bad. It should use bcopy
     instead. */
  for(p = buf->p; left < len && p != NULL; p = p->next) {
  115b4f:	8b 45 08             	mov    0x8(%ebp),%eax
  115b52:	8b 00                	mov    (%eax),%eax
  115b54:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  115b57:	eb 7a                	jmp    115bd3 <netbuf_copy_partial+0xb3>
    if (offset != 0 && offset >= p->len) {
  115b59:	66 83 7d e8 00       	cmpw   $0x0,0xffffffe8(%ebp)
  115b5e:	74 1a                	je     115b7a <netbuf_copy_partial+0x5a>
  115b60:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  115b63:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  115b67:	66 3b 45 e8          	cmp    0xffffffe8(%ebp),%ax
  115b6b:	77 0d                	ja     115b7a <netbuf_copy_partial+0x5a>
      offset -= p->len;
  115b6d:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  115b70:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  115b74:	66 29 45 e8          	sub    %ax,0xffffffe8(%ebp)
  115b78:	eb 51                	jmp    115bcb <netbuf_copy_partial+0xab>
    } else {    
      for(i = offset; i < p->len; ++i) {
  115b7a:	0f b7 45 e8          	movzwl 0xffffffe8(%ebp),%eax
  115b7e:	66 89 45 fc          	mov    %ax,0xfffffffc(%ebp)
  115b82:	eb 34                	jmp    115bb8 <netbuf_copy_partial+0x98>
  ((char *)dataptr)[left] = ((char *)p->payload)[i];
  115b84:	0f b7 45 fe          	movzwl 0xfffffffe(%ebp),%eax
  115b88:	89 c2                	mov    %eax,%edx
  115b8a:	8b 45 0c             	mov    0xc(%ebp),%eax
  115b8d:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
  115b90:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  115b93:	8b 40 04             	mov    0x4(%eax),%eax
  115b96:	89 c2                	mov    %eax,%edx
  115b98:	0f b7 45 fc          	movzwl 0xfffffffc(%ebp),%eax
  115b9c:	8d 04 02             	lea    (%edx,%eax,1),%eax
  115b9f:	0f b6 00             	movzbl (%eax),%eax
  115ba2:	88 01                	mov    %al,(%ecx)
  if (++left >= len) {
  115ba4:	66 83 45 fe 01       	addw   $0x1,0xfffffffe(%ebp)
  115ba9:	0f b7 45 fe          	movzwl 0xfffffffe(%ebp),%eax
  115bad:	66 3b 45 ec          	cmp    0xffffffec(%ebp),%ax
  115bb1:	73 34                	jae    115be7 <netbuf_copy_partial+0xc7>
  115bb3:	66 83 45 fc 01       	addw   $0x1,0xfffffffc(%ebp)
  115bb8:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  115bbb:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  115bbf:	66 3b 45 fc          	cmp    0xfffffffc(%ebp),%ax
  115bc3:	77 bf                	ja     115b84 <netbuf_copy_partial+0x64>
    return;
  }
      }
      offset = 0;
  115bc5:	66 c7 45 e8 00 00    	movw   $0x0,0xffffffe8(%ebp)
  115bcb:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  115bce:	8b 00                	mov    (%eax),%eax
  115bd0:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  115bd3:	0f b7 45 fe          	movzwl 0xfffffffe(%ebp),%eax
  115bd7:	66 3b 45 ec          	cmp    0xffffffec(%ebp),%ax
  115bdb:	73 0a                	jae    115be7 <netbuf_copy_partial+0xc7>
  115bdd:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  115be1:	0f 85 72 ff ff ff    	jne    115b59 <netbuf_copy_partial+0x39>
    }
  }
}
  115be7:	c9                   	leave  
  115be8:	c3                   	ret    
  115be9:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

00115bf0 <netbuf_copy>:

void
netbuf_copy(struct netbuf *buf, void *dataptr, u16_t len)
{
  115bf0:	55                   	push   %ebp
  115bf1:	89 e5                	mov    %esp,%ebp
  115bf3:	83 ec 14             	sub    $0x14,%esp
  115bf6:	8b 45 10             	mov    0x10(%ebp),%eax
  115bf9:	66 89 45 fc          	mov    %ax,0xfffffffc(%ebp)
  netbuf_copy_partial(buf, dataptr, len, 0);
  115bfd:	0f b7 45 fc          	movzwl 0xfffffffc(%ebp),%eax
  115c01:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  115c08:	00 
  115c09:	89 44 24 08          	mov    %eax,0x8(%esp)
  115c0d:	8b 45 0c             	mov    0xc(%ebp),%eax
  115c10:	89 44 24 04          	mov    %eax,0x4(%esp)
  115c14:	8b 45 08             	mov    0x8(%ebp),%eax
  115c17:	89 04 24             	mov    %eax,(%esp)
  115c1a:	e8 01 ff ff ff       	call   115b20 <netbuf_copy_partial>
}
  115c1f:	c9                   	leave  
  115c20:	c3                   	ret    
  115c21:	eb 0d                	jmp    115c30 <netbuf_fromaddr>
  115c23:	90                   	nop    
  115c24:	90                   	nop    
  115c25:	90                   	nop    
  115c26:	90                   	nop    
  115c27:	90                   	nop    
  115c28:	90                   	nop    
  115c29:	90                   	nop    
  115c2a:	90                   	nop    
  115c2b:	90                   	nop    
  115c2c:	90                   	nop    
  115c2d:	90                   	nop    
  115c2e:	90                   	nop    
  115c2f:	90                   	nop    

00115c30 <netbuf_fromaddr>:

struct ip_addr *
netbuf_fromaddr(struct netbuf *buf)
{
  115c30:	55                   	push   %ebp
  115c31:	89 e5                	mov    %esp,%ebp
  return buf->fromaddr;
  115c33:	8b 45 08             	mov    0x8(%ebp),%eax
  115c36:	8b 40 08             	mov    0x8(%eax),%eax
}
  115c39:	5d                   	pop    %ebp
  115c3a:	c3                   	ret    
  115c3b:	90                   	nop    
  115c3c:	8d 74 26 00          	lea    0x0(%esi),%esi

00115c40 <netbuf_fromport>:

u16_t
netbuf_fromport(struct netbuf *buf)
{
  115c40:	55                   	push   %ebp
  115c41:	89 e5                	mov    %esp,%ebp
  return buf->fromport;
  115c43:	8b 45 08             	mov    0x8(%ebp),%eax
  115c46:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  115c4a:	0f b7 c0             	movzwl %ax,%eax
}
  115c4d:	5d                   	pop    %ebp
  115c4e:	c3                   	ret    
  115c4f:	90                   	nop    

00115c50 <netconn_new_with_proto_and_callback>:

struct
netconn *netconn_new_with_proto_and_callback(enum netconn_type t, u16_t proto,
                                   void (*callback)(struct netconn *, enum netconn_evt, u16_t len))
{
  115c50:	55                   	push   %ebp
  115c51:	89 e5                	mov    %esp,%ebp
  115c53:	83 ec 28             	sub    $0x28,%esp
  115c56:	8b 45 0c             	mov    0xc(%ebp),%eax
  115c59:	66 89 45 ec          	mov    %ax,0xffffffec(%ebp)
  struct netconn *conn;
  struct api_msg *msg;

  conn = memp_malloc(MEMP_NETCONN);
  115c5d:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  115c64:	e8 57 8d ff ff       	call   10e9c0 <memp_malloc>
  115c69:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  if (conn == NULL) {
  115c6c:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  115c70:	75 0c                	jne    115c7e <netconn_new_with_proto_and_callback+0x2e>
    return NULL;
  115c72:	c7 45 e8 00 00 00 00 	movl   $0x0,0xffffffe8(%ebp)
  115c79:	e9 42 01 00 00       	jmp    115dc0 <netconn_new_with_proto_and_callback+0x170>
  }
  
  conn->err = ERR_OK;
  115c7e:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  115c81:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
  conn->type = t;
  115c85:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  115c88:	8b 45 08             	mov    0x8(%ebp),%eax
  115c8b:	89 02                	mov    %eax,(%edx)
  conn->pcb.tcp = NULL;
  115c8d:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  115c90:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)

  if ((conn->mbox = sys_mbox_new()) == SYS_MBOX_NULL) {
  115c97:	e8 b4 41 00 00       	call   119e50 <sys_mbox_new>
  115c9c:	89 c2                	mov    %eax,%edx
  115c9e:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  115ca1:	89 50 10             	mov    %edx,0x10(%eax)
  115ca4:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  115ca7:	8b 40 10             	mov    0x10(%eax),%eax
  115caa:	85 c0                	test   %eax,%eax
  115cac:	75 1f                	jne    115ccd <netconn_new_with_proto_and_callback+0x7d>
    memp_free(MEMP_NETCONN, conn);
  115cae:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  115cb1:	89 44 24 04          	mov    %eax,0x4(%esp)
  115cb5:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  115cbc:	e8 ef 8d ff ff       	call   10eab0 <memp_free>
    return NULL;
  115cc1:	c7 45 e8 00 00 00 00 	movl   $0x0,0xffffffe8(%ebp)
  115cc8:	e9 f3 00 00 00       	jmp    115dc0 <netconn_new_with_proto_and_callback+0x170>
  }
  conn->recvmbox = SYS_MBOX_NULL;
  115ccd:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  115cd0:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
  conn->acceptmbox = SYS_MBOX_NULL;
  115cd7:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  115cda:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
  conn->sem = SYS_SEM_NULL;
  115ce1:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  115ce4:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
  conn->state = NETCONN_NONE;
  115ceb:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  115cee:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  conn->socket = 0;
  115cf5:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  115cf8:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
  conn->callback = callback;
  115cff:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  115d02:	8b 45 10             	mov    0x10(%ebp),%eax
  115d05:	89 42 28             	mov    %eax,0x28(%edx)
  conn->recv_avail = 0;
  115d08:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  115d0b:	66 c7 40 24 00 00    	movw   $0x0,0x24(%eax)

  if((msg = memp_malloc(MEMP_API_MSG)) == NULL) {
  115d11:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  115d18:	e8 a3 8c ff ff       	call   10e9c0 <memp_malloc>
  115d1d:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  115d20:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  115d24:	75 1c                	jne    115d42 <netconn_new_with_proto_and_callback+0xf2>
    memp_free(MEMP_NETCONN, conn);
  115d26:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  115d29:	89 44 24 04          	mov    %eax,0x4(%esp)
  115d2d:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  115d34:	e8 77 8d ff ff       	call   10eab0 <memp_free>
    return NULL;
  115d39:	c7 45 e8 00 00 00 00 	movl   $0x0,0xffffffe8(%ebp)
  115d40:	eb 7e                	jmp    115dc0 <netconn_new_with_proto_and_callback+0x170>
  }
  
  msg->type = API_MSG_NEWCONN;
  115d42:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  115d45:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  msg->msg.msg.bc.port = proto; /* misusing the port field */
  115d4b:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  115d4e:	0f b7 45 ec          	movzwl 0xffffffec(%ebp),%eax
  115d52:	66 89 42 10          	mov    %ax,0x10(%edx)
  msg->msg.conn = conn;
  115d56:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  115d59:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  115d5c:	89 42 04             	mov    %eax,0x4(%edx)
  api_msg_post(msg);  
  115d5f:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  115d62:	89 04 24             	mov    %eax,(%esp)
  115d65:	e8 36 21 00 00       	call   117ea0 <api_msg_post>
  sys_mbox_fetch(conn->mbox, NULL);
  115d6a:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  115d6d:	8b 40 10             	mov    0x10(%eax),%eax
  115d70:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  115d77:	00 
  115d78:	89 04 24             	mov    %eax,(%esp)
  115d7b:	e8 80 9f ff ff       	call   10fd00 <sys_mbox_fetch>
  memp_free(MEMP_API_MSG, msg);
  115d80:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  115d83:	89 44 24 04          	mov    %eax,0x4(%esp)
  115d87:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  115d8e:	e8 1d 8d ff ff       	call   10eab0 <memp_free>

  if ( conn->err != ERR_OK ) {
  115d93:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  115d96:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
  115d9a:	84 c0                	test   %al,%al
  115d9c:	74 1c                	je     115dba <netconn_new_with_proto_and_callback+0x16a>
    memp_free(MEMP_NETCONN, conn);
  115d9e:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  115da1:	89 44 24 04          	mov    %eax,0x4(%esp)
  115da5:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  115dac:	e8 ff 8c ff ff       	call   10eab0 <memp_free>
    return NULL;
  115db1:	c7 45 e8 00 00 00 00 	movl   $0x0,0xffffffe8(%ebp)
  115db8:	eb 06                	jmp    115dc0 <netconn_new_with_proto_and_callback+0x170>
  }

  return conn;
  115dba:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  115dbd:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
  115dc0:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
}
  115dc3:	c9                   	leave  
  115dc4:	c3                   	ret    
  115dc5:	8d 74 26 00          	lea    0x0(%esi),%esi
  115dc9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00115dd0 <netconn_new>:


struct
netconn *netconn_new(enum netconn_type t)
{
  115dd0:	55                   	push   %ebp
  115dd1:	89 e5                	mov    %esp,%ebp
  115dd3:	83 ec 18             	sub    $0x18,%esp
  return netconn_new_with_proto_and_callback(t,0,NULL);
  115dd6:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  115ddd:	00 
  115dde:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  115de5:	00 
  115de6:	8b 45 08             	mov    0x8(%ebp),%eax
  115de9:	89 04 24             	mov    %eax,(%esp)
  115dec:	e8 5f fe ff ff       	call   115c50 <netconn_new_with_proto_and_callback>
}
  115df1:	c9                   	leave  
  115df2:	c3                   	ret    
  115df3:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  115df9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00115e00 <netconn_new_with_callback>:

struct
netconn *netconn_new_with_callback(enum netconn_type t,
                                   void (*callback)(struct netconn *, enum netconn_evt, u16_t len))
{
  115e00:	55                   	push   %ebp
  115e01:	89 e5                	mov    %esp,%ebp
  115e03:	83 ec 18             	sub    $0x18,%esp
  return netconn_new_with_proto_and_callback(t,0,callback);
  115e06:	8b 45 0c             	mov    0xc(%ebp),%eax
  115e09:	89 44 24 08          	mov    %eax,0x8(%esp)
  115e0d:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  115e14:	00 
  115e15:	8b 45 08             	mov    0x8(%ebp),%eax
  115e18:	89 04 24             	mov    %eax,(%esp)
  115e1b:	e8 30 fe ff ff       	call   115c50 <netconn_new_with_proto_and_callback>
}
  115e20:	c9                   	leave  
  115e21:	c3                   	ret    
  115e22:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi
  115e29:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00115e30 <netconn_delete>:


err_t
netconn_delete(struct netconn *conn)
{
  115e30:	55                   	push   %ebp
  115e31:	89 e5                	mov    %esp,%ebp
  115e33:	83 ec 28             	sub    $0x28,%esp
  struct api_msg *msg;
  void *mem;
  
  if (conn == NULL) {
  115e36:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  115e3a:	75 0c                	jne    115e48 <netconn_delete+0x18>
    return ERR_OK;
  115e3c:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  115e43:	e9 69 01 00 00       	jmp    115fb1 <netconn_delete+0x181>
  }
  
  if ((msg = memp_malloc(MEMP_API_MSG)) == NULL) {
  115e48:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  115e4f:	e8 6c 8b ff ff       	call   10e9c0 <memp_malloc>
  115e54:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  115e57:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  115e5b:	75 0c                	jne    115e69 <netconn_delete+0x39>
    return ERR_MEM;
  115e5d:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  115e64:	e9 48 01 00 00       	jmp    115fb1 <netconn_delete+0x181>
  }
  
  msg->type = API_MSG_DELCONN;
  115e69:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  115e6c:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
  msg->msg.conn = conn;
  115e72:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  115e75:	8b 45 08             	mov    0x8(%ebp),%eax
  115e78:	89 42 04             	mov    %eax,0x4(%edx)
  api_msg_post(msg);  
  115e7b:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  115e7e:	89 04 24             	mov    %eax,(%esp)
  115e81:	e8 1a 20 00 00       	call   117ea0 <api_msg_post>
  sys_mbox_fetch(conn->mbox, NULL);
  115e86:	8b 45 08             	mov    0x8(%ebp),%eax
  115e89:	8b 40 10             	mov    0x10(%eax),%eax
  115e8c:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  115e93:	00 
  115e94:	89 04 24             	mov    %eax,(%esp)
  115e97:	e8 64 9e ff ff       	call   10fd00 <sys_mbox_fetch>
  memp_free(MEMP_API_MSG, msg);
  115e9c:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  115e9f:	89 44 24 04          	mov    %eax,0x4(%esp)
  115ea3:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  115eaa:	e8 01 8c ff ff       	call   10eab0 <memp_free>

  /* Drain the recvmbox. */
  if (conn->recvmbox != SYS_MBOX_NULL) {
  115eaf:	8b 45 08             	mov    0x8(%ebp),%eax
  115eb2:	8b 40 14             	mov    0x14(%eax),%eax
  115eb5:	85 c0                	test   %eax,%eax
  115eb7:	74 5d                	je     115f16 <netconn_delete+0xe6>
    while (sys_arch_mbox_fetch(conn->recvmbox, &mem, 1) != SYS_ARCH_TIMEOUT) {
  115eb9:	eb 21                	jmp    115edc <netconn_delete+0xac>
      if (conn->type == NETCONN_TCP) {
  115ebb:	8b 45 08             	mov    0x8(%ebp),%eax
  115ebe:	8b 00                	mov    (%eax),%eax
  115ec0:	85 c0                	test   %eax,%eax
  115ec2:	75 0d                	jne    115ed1 <netconn_delete+0xa1>
  pbuf_free((struct pbuf *)mem);
  115ec4:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  115ec7:	89 04 24             	mov    %eax,(%esp)
  115eca:	e8 e1 95 ff ff       	call   10f4b0 <pbuf_free>
  115ecf:	eb 0b                	jmp    115edc <netconn_delete+0xac>
      } else {
  netbuf_delete((struct netbuf *)mem);
  115ed1:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  115ed4:	89 04 24             	mov    %eax,(%esp)
  115ed7:	e8 a4 f9 ff ff       	call   115880 <netbuf_delete>
  115edc:	8b 45 08             	mov    0x8(%ebp),%eax
  115edf:	8b 50 14             	mov    0x14(%eax),%edx
  115ee2:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  115ee9:	00 
  115eea:	8d 45 f8             	lea    0xfffffff8(%ebp),%eax
  115eed:	89 44 24 04          	mov    %eax,0x4(%esp)
  115ef1:	89 14 24             	mov    %edx,(%esp)
  115ef4:	e8 37 41 00 00       	call   11a030 <sys_arch_mbox_fetch>
  115ef9:	83 f8 ff             	cmp    $0xffffffff,%eax
  115efc:	75 bd                	jne    115ebb <netconn_delete+0x8b>
      }
    }
    sys_mbox_free(conn->recvmbox);
  115efe:	8b 45 08             	mov    0x8(%ebp),%eax
  115f01:	8b 40 14             	mov    0x14(%eax),%eax
  115f04:	89 04 24             	mov    %eax,(%esp)
  115f07:	e8 04 40 00 00       	call   119f10 <sys_mbox_free>
    conn->recvmbox = SYS_MBOX_NULL;
  115f0c:	8b 45 08             	mov    0x8(%ebp),%eax
  115f0f:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
  }
 

  /* Drain the acceptmbox. */
  if (conn->acceptmbox != SYS_MBOX_NULL) {
  115f16:	8b 45 08             	mov    0x8(%ebp),%eax
  115f19:	8b 40 18             	mov    0x18(%eax),%eax
  115f1c:	85 c0                	test   %eax,%eax
  115f1e:	74 47                	je     115f67 <netconn_delete+0x137>
    while (sys_arch_mbox_fetch(conn->acceptmbox, &mem, 1) != SYS_ARCH_TIMEOUT) {
  115f20:	eb 0b                	jmp    115f2d <netconn_delete+0xfd>
      netconn_delete((struct netconn *)mem);
  115f22:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  115f25:	89 04 24             	mov    %eax,(%esp)
  115f28:	e8 03 ff ff ff       	call   115e30 <netconn_delete>
  115f2d:	8b 45 08             	mov    0x8(%ebp),%eax
  115f30:	8b 50 18             	mov    0x18(%eax),%edx
  115f33:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  115f3a:	00 
  115f3b:	8d 45 f8             	lea    0xfffffff8(%ebp),%eax
  115f3e:	89 44 24 04          	mov    %eax,0x4(%esp)
  115f42:	89 14 24             	mov    %edx,(%esp)
  115f45:	e8 e6 40 00 00       	call   11a030 <sys_arch_mbox_fetch>
  115f4a:	83 f8 ff             	cmp    $0xffffffff,%eax
  115f4d:	75 d3                	jne    115f22 <netconn_delete+0xf2>
    }
    
    sys_mbox_free(conn->acceptmbox);
  115f4f:	8b 45 08             	mov    0x8(%ebp),%eax
  115f52:	8b 40 18             	mov    0x18(%eax),%eax
  115f55:	89 04 24             	mov    %eax,(%esp)
  115f58:	e8 b3 3f 00 00       	call   119f10 <sys_mbox_free>
    conn->acceptmbox = SYS_MBOX_NULL;
  115f5d:	8b 45 08             	mov    0x8(%ebp),%eax
  115f60:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
  }

  sys_mbox_free(conn->mbox);
  115f67:	8b 45 08             	mov    0x8(%ebp),%eax
  115f6a:	8b 40 10             	mov    0x10(%eax),%eax
  115f6d:	89 04 24             	mov    %eax,(%esp)
  115f70:	e8 9b 3f 00 00       	call   119f10 <sys_mbox_free>
  conn->mbox = SYS_MBOX_NULL;
  115f75:	8b 45 08             	mov    0x8(%ebp),%eax
  115f78:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  if (conn->sem != SYS_SEM_NULL) {
  115f7f:	8b 45 08             	mov    0x8(%ebp),%eax
  115f82:	8b 40 1c             	mov    0x1c(%eax),%eax
  115f85:	85 c0                	test   %eax,%eax
  115f87:	74 0e                	je     115f97 <netconn_delete+0x167>
    sys_sem_free(conn->sem);
  115f89:	8b 45 08             	mov    0x8(%ebp),%eax
  115f8c:	8b 40 1c             	mov    0x1c(%eax),%eax
  115f8f:	89 04 24             	mov    %eax,(%esp)
  115f92:	e8 f9 3d 00 00       	call   119d90 <sys_sem_free>
  }
  /*  conn->sem = SYS_SEM_NULL;*/
  memp_free(MEMP_NETCONN, conn);
  115f97:	8b 45 08             	mov    0x8(%ebp),%eax
  115f9a:	89 44 24 04          	mov    %eax,0x4(%esp)
  115f9e:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  115fa5:	e8 06 8b ff ff       	call   10eab0 <memp_free>
  return ERR_OK;
  115faa:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  115fb1:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  115fb4:	c9                   	leave  
  115fb5:	c3                   	ret    
  115fb6:	8d 76 00             	lea    0x0(%esi),%esi
  115fb9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00115fc0 <netconn_type>:

enum netconn_type
netconn_type(struct netconn *conn)
{
  115fc0:	55                   	push   %ebp
  115fc1:	89 e5                	mov    %esp,%ebp
  return conn->type;
  115fc3:	8b 45 08             	mov    0x8(%ebp),%eax
  115fc6:	8b 00                	mov    (%eax),%eax
}
  115fc8:	5d                   	pop    %ebp
  115fc9:	c3                   	ret    
  115fca:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

00115fd0 <netconn_peer>:

err_t
netconn_peer(struct netconn *conn, struct ip_addr *addr,
       u16_t *port)
{
  115fd0:	55                   	push   %ebp
  115fd1:	89 e5                	mov    %esp,%ebp
  115fd3:	83 ec 08             	sub    $0x8,%esp
  switch (conn->type) {
  115fd6:	8b 45 08             	mov    0x8(%ebp),%eax
  115fd9:	8b 00                	mov    (%eax),%eax
  115fdb:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  115fde:	83 7d f8 03          	cmpl   $0x3,0xfffffff8(%ebp)
  115fe2:	77 08                	ja     115fec <netconn_peer+0x1c>
  115fe4:	83 7d f8 01          	cmpl   $0x1,0xfffffff8(%ebp)
  115fe8:	73 19                	jae    116003 <netconn_peer+0x33>
  115fea:	eb 5e                	jmp    11604a <netconn_peer+0x7a>
  115fec:	83 7d f8 04          	cmpl   $0x4,0xfffffff8(%ebp)
  115ff0:	74 05                	je     115ff7 <netconn_peer+0x27>
  115ff2:	e9 84 00 00 00       	jmp    11607b <netconn_peer+0xab>
  case NETCONN_RAW:
    /* return an error as connecting is only a helper for upper layers */
    return ERR_CONN;
  115ff7:	c7 45 fc fa ff ff ff 	movl   $0xfffffffa,0xfffffffc(%ebp)
  115ffe:	e9 86 00 00 00       	jmp    116089 <netconn_peer+0xb9>
  case NETCONN_UDPLITE:
  case NETCONN_UDPNOCHKSUM:
  case NETCONN_UDP:
    if (conn->pcb.udp == NULL ||
  116003:	8b 45 08             	mov    0x8(%ebp),%eax
  116006:	8b 40 08             	mov    0x8(%eax),%eax
  116009:	85 c0                	test   %eax,%eax
  11600b:	74 14                	je     116021 <netconn_peer+0x51>
  11600d:	8b 45 08             	mov    0x8(%ebp),%eax
  116010:	8b 40 08             	mov    0x8(%eax),%eax
  116013:	0f b6 40 10          	movzbl 0x10(%eax),%eax
  116017:	0f b6 c0             	movzbl %al,%eax
  11601a:	83 e0 04             	and    $0x4,%eax
  11601d:	85 c0                	test   %eax,%eax
  11601f:	75 09                	jne    11602a <netconn_peer+0x5a>
  ((conn->pcb.udp->flags & UDP_FLAGS_CONNECTED) == 0))
     return ERR_CONN;
  116021:	c7 45 fc fa ff ff ff 	movl   $0xfffffffa,0xfffffffc(%ebp)
  116028:	eb 5f                	jmp    116089 <netconn_peer+0xb9>
    *addr = (conn->pcb.udp->remote_ip);
  11602a:	8b 45 08             	mov    0x8(%ebp),%eax
  11602d:	8b 40 08             	mov    0x8(%eax),%eax
  116030:	8b 50 04             	mov    0x4(%eax),%edx
  116033:	8b 45 0c             	mov    0xc(%ebp),%eax
  116036:	89 10                	mov    %edx,(%eax)
    *port = conn->pcb.udp->remote_port;
  116038:	8b 45 08             	mov    0x8(%ebp),%eax
  11603b:	8b 40 08             	mov    0x8(%eax),%eax
  11603e:	0f b7 50 14          	movzwl 0x14(%eax),%edx
  116042:	8b 45 10             	mov    0x10(%ebp),%eax
  116045:	66 89 10             	mov    %dx,(%eax)
    break;
  116048:	eb 31                	jmp    11607b <netconn_peer+0xab>
  case NETCONN_TCP:
    if (conn->pcb.tcp == NULL)
  11604a:	8b 45 08             	mov    0x8(%ebp),%eax
  11604d:	8b 40 08             	mov    0x8(%eax),%eax
  116050:	85 c0                	test   %eax,%eax
  116052:	75 09                	jne    11605d <netconn_peer+0x8d>
      return ERR_CONN;
  116054:	c7 45 fc fa ff ff ff 	movl   $0xfffffffa,0xfffffffc(%ebp)
  11605b:	eb 2c                	jmp    116089 <netconn_peer+0xb9>
    *addr = (conn->pcb.tcp->remote_ip);
  11605d:	8b 45 08             	mov    0x8(%ebp),%eax
  116060:	8b 40 08             	mov    0x8(%eax),%eax
  116063:	8b 50 04             	mov    0x4(%eax),%edx
  116066:	8b 45 0c             	mov    0xc(%ebp),%eax
  116069:	89 10                	mov    %edx,(%eax)
    *port = conn->pcb.tcp->remote_port;
  11606b:	8b 45 08             	mov    0x8(%ebp),%eax
  11606e:	8b 40 08             	mov    0x8(%eax),%eax
  116071:	0f b7 50 1e          	movzwl 0x1e(%eax),%edx
  116075:	8b 45 10             	mov    0x10(%ebp),%eax
  116078:	66 89 10             	mov    %dx,(%eax)
    break;
  }
  return (conn->err = ERR_OK);
  11607b:	8b 45 08             	mov    0x8(%ebp),%eax
  11607e:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
  116082:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
  116089:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
}
  11608c:	c9                   	leave  
  11608d:	c3                   	ret    
  11608e:	89 f6                	mov    %esi,%esi

00116090 <netconn_addr>:

err_t
netconn_addr(struct netconn *conn, struct ip_addr **addr,
       u16_t *port)
{
  116090:	55                   	push   %ebp
  116091:	89 e5                	mov    %esp,%ebp
  116093:	83 ec 04             	sub    $0x4,%esp
  switch (conn->type) {
  116096:	8b 45 08             	mov    0x8(%ebp),%eax
  116099:	8b 00                	mov    (%eax),%eax
  11609b:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  11609e:	83 7d fc 03          	cmpl   $0x3,0xfffffffc(%ebp)
  1160a2:	77 08                	ja     1160ac <netconn_addr+0x1c>
  1160a4:	83 7d fc 01          	cmpl   $0x1,0xfffffffc(%ebp)
  1160a8:	73 29                	jae    1160d3 <netconn_addr+0x43>
  1160aa:	eb 46                	jmp    1160f2 <netconn_addr+0x62>
  1160ac:	83 7d fc 04          	cmpl   $0x4,0xfffffffc(%ebp)
  1160b0:	74 02                	je     1160b4 <netconn_addr+0x24>
  1160b2:	eb 5b                	jmp    11610f <netconn_addr+0x7f>
  case NETCONN_RAW:
    *addr = &(conn->pcb.raw->local_ip);
  1160b4:	8b 45 08             	mov    0x8(%ebp),%eax
  1160b7:	8b 40 08             	mov    0x8(%eax),%eax
  1160ba:	89 c2                	mov    %eax,%edx
  1160bc:	8b 45 0c             	mov    0xc(%ebp),%eax
  1160bf:	89 10                	mov    %edx,(%eax)
    *port = conn->pcb.raw->protocol;
  1160c1:	8b 45 08             	mov    0x8(%ebp),%eax
  1160c4:	8b 40 08             	mov    0x8(%eax),%eax
  1160c7:	0f b7 50 10          	movzwl 0x10(%eax),%edx
  1160cb:	8b 45 10             	mov    0x10(%ebp),%eax
  1160ce:	66 89 10             	mov    %dx,(%eax)
    break;
  1160d1:	eb 3c                	jmp    11610f <netconn_addr+0x7f>
  case NETCONN_UDPLITE:
  case NETCONN_UDPNOCHKSUM:
  case NETCONN_UDP:
    *addr = &(conn->pcb.udp->local_ip);
  1160d3:	8b 45 08             	mov    0x8(%ebp),%eax
  1160d6:	8b 40 08             	mov    0x8(%eax),%eax
  1160d9:	89 c2                	mov    %eax,%edx
  1160db:	8b 45 0c             	mov    0xc(%ebp),%eax
  1160de:	89 10                	mov    %edx,(%eax)
    *port = conn->pcb.udp->local_port;
  1160e0:	8b 45 08             	mov    0x8(%ebp),%eax
  1160e3:	8b 40 08             	mov    0x8(%eax),%eax
  1160e6:	0f b7 50 12          	movzwl 0x12(%eax),%edx
  1160ea:	8b 45 10             	mov    0x10(%ebp),%eax
  1160ed:	66 89 10             	mov    %dx,(%eax)
    break;
  1160f0:	eb 1d                	jmp    11610f <netconn_addr+0x7f>
  case NETCONN_TCP:
    *addr = &(conn->pcb.tcp->local_ip);
  1160f2:	8b 45 08             	mov    0x8(%ebp),%eax
  1160f5:	8b 40 08             	mov    0x8(%eax),%eax
  1160f8:	89 c2                	mov    %eax,%edx
  1160fa:	8b 45 0c             	mov    0xc(%ebp),%eax
  1160fd:	89 10                	mov    %edx,(%eax)
    *port = conn->pcb.tcp->local_port;
  1160ff:	8b 45 08             	mov    0x8(%ebp),%eax
  116102:	8b 40 08             	mov    0x8(%eax),%eax
  116105:	0f b7 50 1c          	movzwl 0x1c(%eax),%edx
  116109:	8b 45 10             	mov    0x10(%ebp),%eax
  11610c:	66 89 10             	mov    %dx,(%eax)
    break;
  }
  return (conn->err = ERR_OK);
  11610f:	8b 45 08             	mov    0x8(%ebp),%eax
  116112:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
  116116:	b8 00 00 00 00       	mov    $0x0,%eax
}
  11611b:	c9                   	leave  
  11611c:	c3                   	ret    
  11611d:	8d 76 00             	lea    0x0(%esi),%esi

00116120 <netconn_bind>:

err_t
netconn_bind(struct netconn *conn, struct ip_addr *addr,
      u16_t port)
{
  116120:	55                   	push   %ebp
  116121:	89 e5                	mov    %esp,%ebp
  116123:	83 ec 28             	sub    $0x28,%esp
  116126:	8b 45 10             	mov    0x10(%ebp),%eax
  116129:	66 89 45 ec          	mov    %ax,0xffffffec(%ebp)
  struct api_msg *msg;

  if (conn == NULL) {
  11612d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  116131:	75 0c                	jne    11613f <netconn_bind+0x1f>
    return ERR_VAL;
  116133:	c7 45 e8 f9 ff ff ff 	movl   $0xfffffff9,0xffffffe8(%ebp)
  11613a:	e9 c2 00 00 00       	jmp    116201 <netconn_bind+0xe1>
  }

  if (conn->type != NETCONN_TCP &&
  11613f:	8b 45 08             	mov    0x8(%ebp),%eax
  116142:	8b 00                	mov    (%eax),%eax
  116144:	85 c0                	test   %eax,%eax
  116146:	74 2d                	je     116175 <netconn_bind+0x55>
  116148:	8b 45 08             	mov    0x8(%ebp),%eax
  11614b:	8b 40 14             	mov    0x14(%eax),%eax
  11614e:	85 c0                	test   %eax,%eax
  116150:	75 23                	jne    116175 <netconn_bind+0x55>
     conn->recvmbox == SYS_MBOX_NULL) {
    if ((conn->recvmbox = sys_mbox_new()) == SYS_MBOX_NULL) {
  116152:	e8 f9 3c 00 00       	call   119e50 <sys_mbox_new>
  116157:	89 c2                	mov    %eax,%edx
  116159:	8b 45 08             	mov    0x8(%ebp),%eax
  11615c:	89 50 14             	mov    %edx,0x14(%eax)
  11615f:	8b 45 08             	mov    0x8(%ebp),%eax
  116162:	8b 40 14             	mov    0x14(%eax),%eax
  116165:	85 c0                	test   %eax,%eax
  116167:	75 0c                	jne    116175 <netconn_bind+0x55>
      return ERR_MEM;
  116169:	c7 45 e8 ff ff ff ff 	movl   $0xffffffff,0xffffffe8(%ebp)
  116170:	e9 8c 00 00 00       	jmp    116201 <netconn_bind+0xe1>
    }
  }
  
  if ((msg = memp_malloc(MEMP_API_MSG)) == NULL) {
  116175:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  11617c:	e8 3f 88 ff ff       	call   10e9c0 <memp_malloc>
  116181:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  116184:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  116188:	75 10                	jne    11619a <netconn_bind+0x7a>
    return (conn->err = ERR_MEM);
  11618a:	8b 45 08             	mov    0x8(%ebp),%eax
  11618d:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  116191:	c7 45 e8 ff ff ff ff 	movl   $0xffffffff,0xffffffe8(%ebp)
  116198:	eb 67                	jmp    116201 <netconn_bind+0xe1>
  }
  msg->type = API_MSG_BIND;
  11619a:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  11619d:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
  msg->msg.conn = conn;
  1161a3:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  1161a6:	8b 45 08             	mov    0x8(%ebp),%eax
  1161a9:	89 42 04             	mov    %eax,0x4(%edx)
  msg->msg.msg.bc.ipaddr = addr;
  1161ac:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  1161af:	8b 45 0c             	mov    0xc(%ebp),%eax
  1161b2:	89 42 0c             	mov    %eax,0xc(%edx)
  msg->msg.msg.bc.port = port;
  1161b5:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  1161b8:	0f b7 45 ec          	movzwl 0xffffffec(%ebp),%eax
  1161bc:	66 89 42 10          	mov    %ax,0x10(%edx)
  api_msg_post(msg);
  1161c0:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1161c3:	89 04 24             	mov    %eax,(%esp)
  1161c6:	e8 d5 1c 00 00       	call   117ea0 <api_msg_post>
  sys_mbox_fetch(conn->mbox, NULL);
  1161cb:	8b 45 08             	mov    0x8(%ebp),%eax
  1161ce:	8b 40 10             	mov    0x10(%eax),%eax
  1161d1:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  1161d8:	00 
  1161d9:	89 04 24             	mov    %eax,(%esp)
  1161dc:	e8 1f 9b ff ff       	call   10fd00 <sys_mbox_fetch>
  memp_free(MEMP_API_MSG, msg);
  1161e1:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1161e4:	89 44 24 04          	mov    %eax,0x4(%esp)
  1161e8:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  1161ef:	e8 bc 88 ff ff       	call   10eab0 <memp_free>
  return conn->err;
  1161f4:	8b 45 08             	mov    0x8(%ebp),%eax
  1161f7:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
  1161fb:	0f be c0             	movsbl %al,%eax
  1161fe:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
  116201:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
}
  116204:	c9                   	leave  
  116205:	c3                   	ret    
  116206:	8d 76 00             	lea    0x0(%esi),%esi
  116209:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00116210 <netconn_connect>:


err_t
netconn_connect(struct netconn *conn, struct ip_addr *addr,
       u16_t port)
{
  116210:	55                   	push   %ebp
  116211:	89 e5                	mov    %esp,%ebp
  116213:	83 ec 28             	sub    $0x28,%esp
  116216:	8b 45 10             	mov    0x10(%ebp),%eax
  116219:	66 89 45 ec          	mov    %ax,0xffffffec(%ebp)
  struct api_msg *msg;
  
  if (conn == NULL) {
  11621d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  116221:	75 0c                	jne    11622f <netconn_connect+0x1f>
    return ERR_VAL;
  116223:	c7 45 e8 f9 ff ff ff 	movl   $0xfffffff9,0xffffffe8(%ebp)
  11622a:	e9 b2 00 00 00       	jmp    1162e1 <netconn_connect+0xd1>
  }


  if (conn->recvmbox == SYS_MBOX_NULL) {
  11622f:	8b 45 08             	mov    0x8(%ebp),%eax
  116232:	8b 40 14             	mov    0x14(%eax),%eax
  116235:	85 c0                	test   %eax,%eax
  116237:	75 23                	jne    11625c <netconn_connect+0x4c>
    if ((conn->recvmbox = sys_mbox_new()) == SYS_MBOX_NULL) {
  116239:	e8 12 3c 00 00       	call   119e50 <sys_mbox_new>
  11623e:	89 c2                	mov    %eax,%edx
  116240:	8b 45 08             	mov    0x8(%ebp),%eax
  116243:	89 50 14             	mov    %edx,0x14(%eax)
  116246:	8b 45 08             	mov    0x8(%ebp),%eax
  116249:	8b 40 14             	mov    0x14(%eax),%eax
  11624c:	85 c0                	test   %eax,%eax
  11624e:	75 0c                	jne    11625c <netconn_connect+0x4c>
      return ERR_MEM;
  116250:	c7 45 e8 ff ff ff ff 	movl   $0xffffffff,0xffffffe8(%ebp)
  116257:	e9 85 00 00 00       	jmp    1162e1 <netconn_connect+0xd1>
    }
  }
  
  if ((msg = memp_malloc(MEMP_API_MSG)) == NULL) {
  11625c:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  116263:	e8 58 87 ff ff       	call   10e9c0 <memp_malloc>
  116268:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  11626b:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  11626f:	75 09                	jne    11627a <netconn_connect+0x6a>
    return ERR_MEM;
  116271:	c7 45 e8 ff ff ff ff 	movl   $0xffffffff,0xffffffe8(%ebp)
  116278:	eb 67                	jmp    1162e1 <netconn_connect+0xd1>
  }
  msg->type = API_MSG_CONNECT;
  11627a:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  11627d:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
  msg->msg.conn = conn;  
  116283:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  116286:	8b 45 08             	mov    0x8(%ebp),%eax
  116289:	89 42 04             	mov    %eax,0x4(%edx)
  msg->msg.msg.bc.ipaddr = addr;
  11628c:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  11628f:	8b 45 0c             	mov    0xc(%ebp),%eax
  116292:	89 42 0c             	mov    %eax,0xc(%edx)
  msg->msg.msg.bc.port = port;
  116295:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  116298:	0f b7 45 ec          	movzwl 0xffffffec(%ebp),%eax
  11629c:	66 89 42 10          	mov    %ax,0x10(%edx)
  api_msg_post(msg);
  1162a0:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1162a3:	89 04 24             	mov    %eax,(%esp)
  1162a6:	e8 f5 1b 00 00       	call   117ea0 <api_msg_post>
  sys_mbox_fetch(conn->mbox, NULL);
  1162ab:	8b 45 08             	mov    0x8(%ebp),%eax
  1162ae:	8b 40 10             	mov    0x10(%eax),%eax
  1162b1:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  1162b8:	00 
  1162b9:	89 04 24             	mov    %eax,(%esp)
  1162bc:	e8 3f 9a ff ff       	call   10fd00 <sys_mbox_fetch>
  memp_free(MEMP_API_MSG, msg);
  1162c1:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1162c4:	89 44 24 04          	mov    %eax,0x4(%esp)
  1162c8:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  1162cf:	e8 dc 87 ff ff       	call   10eab0 <memp_free>
  return conn->err;
  1162d4:	8b 45 08             	mov    0x8(%ebp),%eax
  1162d7:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
  1162db:	0f be c0             	movsbl %al,%eax
  1162de:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
  1162e1:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
}
  1162e4:	c9                   	leave  
  1162e5:	c3                   	ret    
  1162e6:	8d 76 00             	lea    0x0(%esi),%esi
  1162e9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

001162f0 <netconn_disconnect>:

err_t
netconn_disconnect(struct netconn *conn)
{
  1162f0:	55                   	push   %ebp
  1162f1:	89 e5                	mov    %esp,%ebp
  1162f3:	83 ec 28             	sub    $0x28,%esp
  struct api_msg *msg;
  
  if (conn == NULL) {
  1162f6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  1162fa:	75 09                	jne    116305 <netconn_disconnect+0x15>
    return ERR_VAL;
  1162fc:	c7 45 ec f9 ff ff ff 	movl   $0xfffffff9,0xffffffec(%ebp)
  116303:	eb 71                	jmp    116376 <netconn_disconnect+0x86>
  }

  if ((msg = memp_malloc(MEMP_API_MSG)) == NULL) {
  116305:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  11630c:	e8 af 86 ff ff       	call   10e9c0 <memp_malloc>
  116311:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  116314:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  116318:	75 09                	jne    116323 <netconn_disconnect+0x33>
    return ERR_MEM;
  11631a:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  116321:	eb 53                	jmp    116376 <netconn_disconnect+0x86>
  }
  msg->type = API_MSG_DISCONNECT;
  116323:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  116326:	c7 00 04 00 00 00    	movl   $0x4,(%eax)
  msg->msg.conn = conn;  
  11632c:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  11632f:	8b 45 08             	mov    0x8(%ebp),%eax
  116332:	89 42 04             	mov    %eax,0x4(%edx)
  api_msg_post(msg);
  116335:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  116338:	89 04 24             	mov    %eax,(%esp)
  11633b:	e8 60 1b 00 00       	call   117ea0 <api_msg_post>
  sys_mbox_fetch(conn->mbox, NULL);
  116340:	8b 45 08             	mov    0x8(%ebp),%eax
  116343:	8b 40 10             	mov    0x10(%eax),%eax
  116346:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  11634d:	00 
  11634e:	89 04 24             	mov    %eax,(%esp)
  116351:	e8 aa 99 ff ff       	call   10fd00 <sys_mbox_fetch>
  memp_free(MEMP_API_MSG, msg);
  116356:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  116359:	89 44 24 04          	mov    %eax,0x4(%esp)
  11635d:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  116364:	e8 47 87 ff ff       	call   10eab0 <memp_free>
  return conn->err;
  116369:	8b 45 08             	mov    0x8(%ebp),%eax
  11636c:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
  116370:	0f be c0             	movsbl %al,%eax
  116373:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  116376:	8b 45 ec             	mov    0xffffffec(%ebp),%eax

}
  116379:	c9                   	leave  
  11637a:	c3                   	ret    
  11637b:	90                   	nop    
  11637c:	8d 74 26 00          	lea    0x0(%esi),%esi

00116380 <netconn_listen>:

err_t
netconn_listen(struct netconn *conn)
{
  116380:	55                   	push   %ebp
  116381:	89 e5                	mov    %esp,%ebp
  116383:	83 ec 28             	sub    $0x28,%esp
  struct api_msg *msg;

  if (conn == NULL) {
  116386:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  11638a:	75 0c                	jne    116398 <netconn_listen+0x18>
    return ERR_VAL;
  11638c:	c7 45 ec f9 ff ff ff 	movl   $0xfffffff9,0xffffffec(%ebp)
  116393:	e9 a2 00 00 00       	jmp    11643a <netconn_listen+0xba>
  }

  if (conn->acceptmbox == SYS_MBOX_NULL) {
  116398:	8b 45 08             	mov    0x8(%ebp),%eax
  11639b:	8b 40 18             	mov    0x18(%eax),%eax
  11639e:	85 c0                	test   %eax,%eax
  1163a0:	75 20                	jne    1163c2 <netconn_listen+0x42>
    conn->acceptmbox = sys_mbox_new();
  1163a2:	e8 a9 3a 00 00       	call   119e50 <sys_mbox_new>
  1163a7:	89 c2                	mov    %eax,%edx
  1163a9:	8b 45 08             	mov    0x8(%ebp),%eax
  1163ac:	89 50 18             	mov    %edx,0x18(%eax)
    if (conn->acceptmbox == SYS_MBOX_NULL) {
  1163af:	8b 45 08             	mov    0x8(%ebp),%eax
  1163b2:	8b 40 18             	mov    0x18(%eax),%eax
  1163b5:	85 c0                	test   %eax,%eax
  1163b7:	75 09                	jne    1163c2 <netconn_listen+0x42>
      return ERR_MEM;
  1163b9:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  1163c0:	eb 78                	jmp    11643a <netconn_listen+0xba>
    }
  }
  
  if ((msg = memp_malloc(MEMP_API_MSG)) == NULL) {
  1163c2:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  1163c9:	e8 f2 85 ff ff       	call   10e9c0 <memp_malloc>
  1163ce:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  1163d1:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  1163d5:	75 10                	jne    1163e7 <netconn_listen+0x67>
    return (conn->err = ERR_MEM);
  1163d7:	8b 45 08             	mov    0x8(%ebp),%eax
  1163da:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  1163de:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  1163e5:	eb 53                	jmp    11643a <netconn_listen+0xba>
  }
  msg->type = API_MSG_LISTEN;
  1163e7:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1163ea:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
  msg->msg.conn = conn;
  1163f0:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  1163f3:	8b 45 08             	mov    0x8(%ebp),%eax
  1163f6:	89 42 04             	mov    %eax,0x4(%edx)
  api_msg_post(msg);
  1163f9:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1163fc:	89 04 24             	mov    %eax,(%esp)
  1163ff:	e8 9c 1a 00 00       	call   117ea0 <api_msg_post>
  sys_mbox_fetch(conn->mbox, NULL);
  116404:	8b 45 08             	mov    0x8(%ebp),%eax
  116407:	8b 40 10             	mov    0x10(%eax),%eax
  11640a:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  116411:	00 
  116412:	89 04 24             	mov    %eax,(%esp)
  116415:	e8 e6 98 ff ff       	call   10fd00 <sys_mbox_fetch>
  memp_free(MEMP_API_MSG, msg);
  11641a:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  11641d:	89 44 24 04          	mov    %eax,0x4(%esp)
  116421:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  116428:	e8 83 86 ff ff       	call   10eab0 <memp_free>
  return conn->err;
  11642d:	8b 45 08             	mov    0x8(%ebp),%eax
  116430:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
  116434:	0f be c0             	movsbl %al,%eax
  116437:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  11643a:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  11643d:	c9                   	leave  
  11643e:	c3                   	ret    
  11643f:	90                   	nop    

00116440 <netconn_accept>:

struct netconn *
netconn_accept(struct netconn *conn)
{
  116440:	55                   	push   %ebp
  116441:	89 e5                	mov    %esp,%ebp
  116443:	83 ec 28             	sub    $0x28,%esp
  struct netconn *newconn;
  
  if (conn == NULL) {
  116446:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  11644a:	75 09                	jne    116455 <netconn_accept+0x15>
    return NULL;
  11644c:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  116453:	eb 43                	jmp    116498 <netconn_accept+0x58>
  }
  
  sys_mbox_fetch(conn->acceptmbox, (void **)&newconn);
  116455:	8d 55 fc             	lea    0xfffffffc(%ebp),%edx
  116458:	8b 45 08             	mov    0x8(%ebp),%eax
  11645b:	8b 40 18             	mov    0x18(%eax),%eax
  11645e:	89 54 24 04          	mov    %edx,0x4(%esp)
  116462:	89 04 24             	mov    %eax,(%esp)
  116465:	e8 96 98 ff ff       	call   10fd00 <sys_mbox_fetch>
  /* Register event with callback */
  if (conn->callback)
  11646a:	8b 45 08             	mov    0x8(%ebp),%eax
  11646d:	8b 40 28             	mov    0x28(%eax),%eax
  116470:	85 c0                	test   %eax,%eax
  116472:	74 1e                	je     116492 <netconn_accept+0x52>
      (*conn->callback)(conn, NETCONN_EVT_RCVMINUS, 0);
  116474:	8b 45 08             	mov    0x8(%ebp),%eax
  116477:	8b 50 28             	mov    0x28(%eax),%edx
  11647a:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  116481:	00 
  116482:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  116489:	00 
  11648a:	8b 45 08             	mov    0x8(%ebp),%eax
  11648d:	89 04 24             	mov    %eax,(%esp)
  116490:	ff d2                	call   *%edx
  
  return newconn;
  116492:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  116495:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  116498:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  11649b:	c9                   	leave  
  11649c:	c3                   	ret    
  11649d:	8d 76 00             	lea    0x0(%esi),%esi

001164a0 <netconn_recv>:

struct netbuf *
netconn_recv(struct netconn *conn)
{
  1164a0:	55                   	push   %ebp
  1164a1:	89 e5                	mov    %esp,%ebp
  1164a3:	83 ec 28             	sub    $0x28,%esp
  struct api_msg *msg;
  struct netbuf *buf;
  struct pbuf *p;
  u16_t len;
    
  if (conn == NULL) {
  1164a6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  1164aa:	75 0c                	jne    1164b8 <netconn_recv+0x18>
    return NULL;
  1164ac:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  1164b3:	e9 4e 02 00 00       	jmp    116706 <netconn_recv+0x266>
  }
  
  if (conn->recvmbox == SYS_MBOX_NULL) {
  1164b8:	8b 45 08             	mov    0x8(%ebp),%eax
  1164bb:	8b 40 14             	mov    0x14(%eax),%eax
  1164be:	85 c0                	test   %eax,%eax
  1164c0:	75 13                	jne    1164d5 <netconn_recv+0x35>
    conn->err = ERR_CONN;
  1164c2:	8b 45 08             	mov    0x8(%ebp),%eax
  1164c5:	c6 40 0c fa          	movb   $0xfa,0xc(%eax)
    return NULL;
  1164c9:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  1164d0:	e9 31 02 00 00       	jmp    116706 <netconn_recv+0x266>
  }

  if (conn->err != ERR_OK) {
  1164d5:	8b 45 08             	mov    0x8(%ebp),%eax
  1164d8:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
  1164dc:	84 c0                	test   %al,%al
  1164de:	74 0c                	je     1164ec <netconn_recv+0x4c>
    return NULL;
  1164e0:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  1164e7:	e9 1a 02 00 00       	jmp    116706 <netconn_recv+0x266>
  }

  if (conn->type == NETCONN_TCP) {
  1164ec:	8b 45 08             	mov    0x8(%ebp),%eax
  1164ef:	8b 00                	mov    (%eax),%eax
  1164f1:	85 c0                	test   %eax,%eax
  1164f3:	0f 85 a8 01 00 00    	jne    1166a1 <netconn_recv+0x201>
    if (conn->pcb.tcp->state == LISTEN) {
  1164f9:	8b 45 08             	mov    0x8(%ebp),%eax
  1164fc:	8b 40 08             	mov    0x8(%eax),%eax
  1164ff:	8b 40 10             	mov    0x10(%eax),%eax
  116502:	83 f8 01             	cmp    $0x1,%eax
  116505:	75 13                	jne    11651a <netconn_recv+0x7a>
      conn->err = ERR_CONN;
  116507:	8b 45 08             	mov    0x8(%ebp),%eax
  11650a:	c6 40 0c fa          	movb   $0xfa,0xc(%eax)
      return NULL;
  11650e:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  116515:	e9 ec 01 00 00       	jmp    116706 <netconn_recv+0x266>
    }


    buf = memp_malloc(MEMP_NETBUF);
  11651a:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  116521:	e8 9a 84 ff ff       	call   10e9c0 <memp_malloc>
  116526:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)

    if (buf == NULL) {
  116529:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  11652c:	85 c0                	test   %eax,%eax
  11652e:	75 13                	jne    116543 <netconn_recv+0xa3>
      conn->err = ERR_MEM;
  116530:	8b 45 08             	mov    0x8(%ebp),%eax
  116533:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
      return NULL;
  116537:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  11653e:	e9 c3 01 00 00       	jmp    116706 <netconn_recv+0x266>
    }
    
    sys_mbox_fetch(conn->recvmbox, (void **)&p);
  116543:	8d 55 f0             	lea    0xfffffff0(%ebp),%edx
  116546:	8b 45 08             	mov    0x8(%ebp),%eax
  116549:	8b 40 14             	mov    0x14(%eax),%eax
  11654c:	89 54 24 04          	mov    %edx,0x4(%esp)
  116550:	89 04 24             	mov    %eax,(%esp)
  116553:	e8 a8 97 ff ff       	call   10fd00 <sys_mbox_fetch>

    if (p != NULL)
  116558:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  11655b:	85 c0                	test   %eax,%eax
  11655d:	74 21                	je     116580 <netconn_recv+0xe0>
    {
        len = p->tot_len;
  11655f:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  116562:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  116566:	66 89 45 fe          	mov    %ax,0xfffffffe(%ebp)
        conn->recv_avail -= len;
  11656a:	8b 45 08             	mov    0x8(%ebp),%eax
  11656d:	0f b7 40 24          	movzwl 0x24(%eax),%eax
  116571:	89 c2                	mov    %eax,%edx
  116573:	66 2b 55 fe          	sub    0xfffffffe(%ebp),%dx
  116577:	8b 45 08             	mov    0x8(%ebp),%eax
  11657a:	66 89 50 24          	mov    %dx,0x24(%eax)
  11657e:	eb 06                	jmp    116586 <netconn_recv+0xe6>
    }
    else
        len = 0;
  116580:	66 c7 45 fe 00 00    	movw   $0x0,0xfffffffe(%ebp)
    
    /* Register event with callback */
      if (conn->callback)
  116586:	8b 45 08             	mov    0x8(%ebp),%eax
  116589:	8b 40 28             	mov    0x28(%eax),%eax
  11658c:	85 c0                	test   %eax,%eax
  11658e:	74 1e                	je     1165ae <netconn_recv+0x10e>
        (*conn->callback)(conn, NETCONN_EVT_RCVMINUS, len);
  116590:	8b 45 08             	mov    0x8(%ebp),%eax
  116593:	8b 50 28             	mov    0x28(%eax),%edx
  116596:	0f b7 45 fe          	movzwl 0xfffffffe(%ebp),%eax
  11659a:	89 44 24 08          	mov    %eax,0x8(%esp)
  11659e:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  1165a5:	00 
  1165a6:	8b 45 08             	mov    0x8(%ebp),%eax
  1165a9:	89 04 24             	mov    %eax,(%esp)
  1165ac:	ff d2                	call   *%edx

    /* If we are closed, we indicate that we no longer wish to receive
       data by setting conn->recvmbox to SYS_MBOX_NULL. */
    if (p == NULL) {
  1165ae:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  1165b1:	85 c0                	test   %eax,%eax
  1165b3:	75 37                	jne    1165ec <netconn_recv+0x14c>
      memp_free(MEMP_NETBUF, buf);
  1165b5:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  1165b8:	89 44 24 04          	mov    %eax,0x4(%esp)
  1165bc:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  1165c3:	e8 e8 84 ff ff       	call   10eab0 <memp_free>
      sys_mbox_free(conn->recvmbox);
  1165c8:	8b 45 08             	mov    0x8(%ebp),%eax
  1165cb:	8b 40 14             	mov    0x14(%eax),%eax
  1165ce:	89 04 24             	mov    %eax,(%esp)
  1165d1:	e8 3a 39 00 00       	call   119f10 <sys_mbox_free>
      conn->recvmbox = SYS_MBOX_NULL;
  1165d6:	8b 45 08             	mov    0x8(%ebp),%eax
  1165d9:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
      return NULL;
  1165e0:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  1165e7:	e9 1a 01 00 00       	jmp    116706 <netconn_recv+0x266>
    }

    buf->p = p;
  1165ec:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
  1165ef:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  1165f2:	89 02                	mov    %eax,(%edx)
    buf->ptr = p;
  1165f4:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
  1165f7:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  1165fa:	89 42 04             	mov    %eax,0x4(%edx)
    buf->fromport = 0;
  1165fd:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  116600:	66 c7 40 0c 00 00    	movw   $0x0,0xc(%eax)
    buf->fromaddr = NULL;
  116606:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  116609:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)

    /* Let the stack know that we have taken the data. */
    if ((msg = memp_malloc(MEMP_API_MSG)) == NULL) {
  116610:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  116617:	e8 a4 83 ff ff       	call   10e9c0 <memp_malloc>
  11661c:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  11661f:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  116623:	75 12                	jne    116637 <netconn_recv+0x197>
      conn->err = ERR_MEM;
  116625:	8b 45 08             	mov    0x8(%ebp),%eax
  116628:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
      return buf;
  11662c:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  11662f:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  116632:	e9 cf 00 00 00       	jmp    116706 <netconn_recv+0x266>
    }
    msg->type = API_MSG_RECV;
  116637:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  11663a:	c7 00 08 00 00 00    	movl   $0x8,(%eax)
    msg->msg.conn = conn;
  116640:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  116643:	8b 45 08             	mov    0x8(%ebp),%eax
  116646:	89 42 04             	mov    %eax,0x4(%edx)
    if (buf != NULL) {
  116649:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  11664c:	85 c0                	test   %eax,%eax
  11664e:	74 12                	je     116662 <netconn_recv+0x1c2>
      msg->msg.msg.len = buf->p->tot_len;
  116650:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  116653:	8b 00                	mov    (%eax),%eax
  116655:	0f b7 50 08          	movzwl 0x8(%eax),%edx
  116659:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  11665c:	66 89 50 0c          	mov    %dx,0xc(%eax)
  116660:	eb 09                	jmp    11666b <netconn_recv+0x1cb>
    } else {
      msg->msg.msg.len = 1;
  116662:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  116665:	66 c7 40 0c 01 00    	movw   $0x1,0xc(%eax)
    }
    api_msg_post(msg);
  11666b:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  11666e:	89 04 24             	mov    %eax,(%esp)
  116671:	e8 2a 18 00 00       	call   117ea0 <api_msg_post>

    sys_mbox_fetch(conn->mbox, NULL);
  116676:	8b 45 08             	mov    0x8(%ebp),%eax
  116679:	8b 40 10             	mov    0x10(%eax),%eax
  11667c:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  116683:	00 
  116684:	89 04 24             	mov    %eax,(%esp)
  116687:	e8 74 96 ff ff       	call   10fd00 <sys_mbox_fetch>
    memp_free(MEMP_API_MSG, msg);
  11668c:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  11668f:	89 44 24 04          	mov    %eax,0x4(%esp)
  116693:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  11669a:	e8 11 84 ff ff       	call   10eab0 <memp_free>
  11669f:	eb 5f                	jmp    116700 <netconn_recv+0x260>
  } else {
    sys_mbox_fetch(conn->recvmbox, (void **)&buf);
  1166a1:	8d 55 f4             	lea    0xfffffff4(%ebp),%edx
  1166a4:	8b 45 08             	mov    0x8(%ebp),%eax
  1166a7:	8b 40 14             	mov    0x14(%eax),%eax
  1166aa:	89 54 24 04          	mov    %edx,0x4(%esp)
  1166ae:	89 04 24             	mov    %eax,(%esp)
  1166b1:	e8 4a 96 ff ff       	call   10fd00 <sys_mbox_fetch>
  conn->recv_avail -= buf->p->tot_len;
  1166b6:	8b 45 08             	mov    0x8(%ebp),%eax
  1166b9:	0f b7 50 24          	movzwl 0x24(%eax),%edx
  1166bd:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  1166c0:	8b 00                	mov    (%eax),%eax
  1166c2:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  1166c6:	66 29 c2             	sub    %ax,%dx
  1166c9:	8b 45 08             	mov    0x8(%ebp),%eax
  1166cc:	66 89 50 24          	mov    %dx,0x24(%eax)
    /* Register event with callback */
    if (conn->callback)
  1166d0:	8b 45 08             	mov    0x8(%ebp),%eax
  1166d3:	8b 40 28             	mov    0x28(%eax),%eax
  1166d6:	85 c0                	test   %eax,%eax
  1166d8:	74 26                	je     116700 <netconn_recv+0x260>
        (*conn->callback)(conn, NETCONN_EVT_RCVMINUS, buf->p->tot_len);
  1166da:	8b 45 08             	mov    0x8(%ebp),%eax
  1166dd:	8b 50 28             	mov    0x28(%eax),%edx
  1166e0:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  1166e3:	8b 00                	mov    (%eax),%eax
  1166e5:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  1166e9:	0f b7 c0             	movzwl %ax,%eax
  1166ec:	89 44 24 08          	mov    %eax,0x8(%esp)
  1166f0:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  1166f7:	00 
  1166f8:	8b 45 08             	mov    0x8(%ebp),%eax
  1166fb:	89 04 24             	mov    %eax,(%esp)
  1166fe:	ff d2                	call   *%edx
  }

  

    
  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_recv: received %p (err %d)\n", (void *)buf, conn->err));


  return buf;
  116700:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  116703:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  116706:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  116709:	c9                   	leave  
  11670a:	c3                   	ret    
  11670b:	90                   	nop    
  11670c:	8d 74 26 00          	lea    0x0(%esi),%esi

00116710 <netconn_send>:

err_t
netconn_send(struct netconn *conn, struct netbuf *buf)
{
  116710:	55                   	push   %ebp
  116711:	89 e5                	mov    %esp,%ebp
  116713:	83 ec 28             	sub    $0x28,%esp
  struct api_msg *msg;

  if (conn == NULL) {
  116716:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  11671a:	75 0c                	jne    116728 <netconn_send+0x18>
    return ERR_VAL;
  11671c:	c7 45 ec f9 ff ff ff 	movl   $0xfffffff9,0xffffffec(%ebp)
  116723:	e9 a0 00 00 00       	jmp    1167c8 <netconn_send+0xb8>
  }

  if (conn->err != ERR_OK) {
  116728:	8b 45 08             	mov    0x8(%ebp),%eax
  11672b:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
  11672f:	84 c0                	test   %al,%al
  116731:	74 12                	je     116745 <netconn_send+0x35>
    return conn->err;
  116733:	8b 45 08             	mov    0x8(%ebp),%eax
  116736:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
  11673a:	0f be c0             	movsbl %al,%eax
  11673d:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  116740:	e9 83 00 00 00       	jmp    1167c8 <netconn_send+0xb8>
  }

  if ((msg = memp_malloc(MEMP_API_MSG)) == NULL) {
  116745:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  11674c:	e8 6f 82 ff ff       	call   10e9c0 <memp_malloc>
  116751:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  116754:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  116758:	75 10                	jne    11676a <netconn_send+0x5a>
    return (conn->err = ERR_MEM);
  11675a:	8b 45 08             	mov    0x8(%ebp),%eax
  11675d:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  116761:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  116768:	eb 5e                	jmp    1167c8 <netconn_send+0xb8>
  }

  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_send: sending %d bytes\n", buf->p->tot_len));
  msg->type = API_MSG_SEND;
  11676a:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  11676d:	c7 00 07 00 00 00    	movl   $0x7,(%eax)
  msg->msg.conn = conn;
  116773:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  116776:	8b 45 08             	mov    0x8(%ebp),%eax
  116779:	89 42 04             	mov    %eax,0x4(%edx)
  msg->msg.msg.p = buf->p;
  11677c:	8b 45 0c             	mov    0xc(%ebp),%eax
  11677f:	8b 10                	mov    (%eax),%edx
  116781:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  116784:	89 50 0c             	mov    %edx,0xc(%eax)
  api_msg_post(msg);
  116787:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  11678a:	89 04 24             	mov    %eax,(%esp)
  11678d:	e8 0e 17 00 00       	call   117ea0 <api_msg_post>

  sys_mbox_fetch(conn->mbox, NULL);
  116792:	8b 45 08             	mov    0x8(%ebp),%eax
  116795:	8b 40 10             	mov    0x10(%eax),%eax
  116798:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  11679f:	00 
  1167a0:	89 04 24             	mov    %eax,(%esp)
  1167a3:	e8 58 95 ff ff       	call   10fd00 <sys_mbox_fetch>
  memp_free(MEMP_API_MSG, msg);
  1167a8:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1167ab:	89 44 24 04          	mov    %eax,0x4(%esp)
  1167af:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  1167b6:	e8 f5 82 ff ff       	call   10eab0 <memp_free>
  return conn->err;
  1167bb:	8b 45 08             	mov    0x8(%ebp),%eax
  1167be:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
  1167c2:	0f be c0             	movsbl %al,%eax
  1167c5:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  1167c8:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  1167cb:	c9                   	leave  
  1167cc:	c3                   	ret    
  1167cd:	8d 76 00             	lea    0x0(%esi),%esi

001167d0 <netconn_write>:

err_t
netconn_write(struct netconn *conn, void *dataptr, u16_t size, u8_t copy)
{
  1167d0:	55                   	push   %ebp
  1167d1:	89 e5                	mov    %esp,%ebp
  1167d3:	83 ec 28             	sub    $0x28,%esp
  1167d6:	8b 45 10             	mov    0x10(%ebp),%eax
  1167d9:	8b 55 14             	mov    0x14(%ebp),%edx
  1167dc:	66 89 45 ec          	mov    %ax,0xffffffec(%ebp)
  1167e0:	88 55 e8             	mov    %dl,0xffffffe8(%ebp)
  struct api_msg *msg;
  u16_t len;
  
  if (conn == NULL) {
  1167e3:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  1167e7:	75 0c                	jne    1167f5 <netconn_write+0x25>
    return ERR_VAL;
  1167e9:	c7 45 e4 f9 ff ff ff 	movl   $0xfffffff9,0xffffffe4(%ebp)
  1167f0:	e9 e6 01 00 00       	jmp    1169db <netconn_write+0x20b>
  }

  if (conn->err != ERR_OK) {
  1167f5:	8b 45 08             	mov    0x8(%ebp),%eax
  1167f8:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
  1167fc:	84 c0                	test   %al,%al
  1167fe:	74 12                	je     116812 <netconn_write+0x42>
    return conn->err;
  116800:	8b 45 08             	mov    0x8(%ebp),%eax
  116803:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
  116807:	0f be c0             	movsbl %al,%eax
  11680a:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
  11680d:	e9 c9 01 00 00       	jmp    1169db <netconn_write+0x20b>
  }
  
  if (conn->sem == SYS_SEM_NULL) {
  116812:	8b 45 08             	mov    0x8(%ebp),%eax
  116815:	8b 40 1c             	mov    0x1c(%eax),%eax
  116818:	85 c0                	test   %eax,%eax
  11681a:	75 2a                	jne    116846 <netconn_write+0x76>
    conn->sem = sys_sem_new(0);
  11681c:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  116823:	e8 18 35 00 00       	call   119d40 <sys_sem_new>
  116828:	89 c2                	mov    %eax,%edx
  11682a:	8b 45 08             	mov    0x8(%ebp),%eax
  11682d:	89 50 1c             	mov    %edx,0x1c(%eax)
    if (conn->sem == SYS_SEM_NULL) {
  116830:	8b 45 08             	mov    0x8(%ebp),%eax
  116833:	8b 40 1c             	mov    0x1c(%eax),%eax
  116836:	85 c0                	test   %eax,%eax
  116838:	75 0c                	jne    116846 <netconn_write+0x76>
      return ERR_MEM;
  11683a:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,0xffffffe4(%ebp)
  116841:	e9 95 01 00 00       	jmp    1169db <netconn_write+0x20b>
    }
  }

  if ((msg = memp_malloc(MEMP_API_MSG)) == NULL) {
  116846:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  11684d:	e8 6e 81 ff ff       	call   10e9c0 <memp_malloc>
  116852:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  116855:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  116859:	75 13                	jne    11686e <netconn_write+0x9e>
    return (conn->err = ERR_MEM);
  11685b:	8b 45 08             	mov    0x8(%ebp),%eax
  11685e:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  116862:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,0xffffffe4(%ebp)
  116869:	e9 6d 01 00 00       	jmp    1169db <netconn_write+0x20b>
  }
  msg->type = API_MSG_WRITE;
  11686e:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  116871:	c7 00 09 00 00 00    	movl   $0x9,(%eax)
  msg->msg.conn = conn;
  116877:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  11687a:	8b 45 08             	mov    0x8(%ebp),%eax
  11687d:	89 42 04             	mov    %eax,0x4(%edx)
        

  conn->state = NETCONN_WRITE;
  116880:	8b 45 08             	mov    0x8(%ebp),%eax
  116883:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
  while (conn->err == ERR_OK && size > 0) {
  11688a:	e9 ea 00 00 00       	jmp    116979 <netconn_write+0x1a9>
    msg->msg.msg.w.dataptr = dataptr;
  11688f:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  116892:	8b 45 0c             	mov    0xc(%ebp),%eax
  116895:	89 42 0c             	mov    %eax,0xc(%edx)
    msg->msg.msg.w.copy = copy;
  116898:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  11689b:	0f b6 45 e8          	movzbl 0xffffffe8(%ebp),%eax
  11689f:	88 42 12             	mov    %al,0x12(%edx)
    
    if (conn->type == NETCONN_TCP) {
  1168a2:	8b 45 08             	mov    0x8(%ebp),%eax
  1168a5:	8b 00                	mov    (%eax),%eax
  1168a7:	85 c0                	test   %eax,%eax
  1168a9:	75 56                	jne    116901 <netconn_write+0x131>
      if (tcp_sndbuf(conn->pcb.tcp) == 0) {
  1168ab:	8b 45 08             	mov    0x8(%ebp),%eax
  1168ae:	8b 40 08             	mov    0x8(%eax),%eax
  1168b1:	0f b7 40 6a          	movzwl 0x6a(%eax),%eax
  1168b5:	66 85 c0             	test   %ax,%ax
  1168b8:	75 1d                	jne    1168d7 <netconn_write+0x107>
  sys_sem_wait(conn->sem);
  1168ba:	8b 45 08             	mov    0x8(%ebp),%eax
  1168bd:	8b 40 1c             	mov    0x1c(%eax),%eax
  1168c0:	89 04 24             	mov    %eax,(%esp)
  1168c3:	e8 38 95 ff ff       	call   10fe00 <sys_sem_wait>
  if (conn->err != ERR_OK) {
  1168c8:	8b 45 08             	mov    0x8(%ebp),%eax
  1168cb:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
  1168cf:	84 c0                	test   %al,%al
  1168d1:	0f 85 b8 00 00 00    	jne    11698f <netconn_write+0x1bf>
    goto ret;
  }
      }
      if (size > tcp_sndbuf(conn->pcb.tcp)) {
  1168d7:	8b 45 08             	mov    0x8(%ebp),%eax
  1168da:	8b 40 08             	mov    0x8(%eax),%eax
  1168dd:	0f b7 40 6a          	movzwl 0x6a(%eax),%eax
  1168e1:	66 3b 45 ec          	cmp    0xffffffec(%ebp),%ax
  1168e5:	73 10                	jae    1168f7 <netconn_write+0x127>
  /* We cannot send more than one send buffer's worth of data at a
     time. */
  len = tcp_sndbuf(conn->pcb.tcp);
  1168e7:	8b 45 08             	mov    0x8(%ebp),%eax
  1168ea:	8b 40 08             	mov    0x8(%eax),%eax
  1168ed:	0f b7 40 6a          	movzwl 0x6a(%eax),%eax
  1168f1:	66 89 45 fe          	mov    %ax,0xfffffffe(%ebp)
  1168f5:	eb 12                	jmp    116909 <netconn_write+0x139>
      } else {
  len = size;
  1168f7:	0f b7 45 ec          	movzwl 0xffffffec(%ebp),%eax
  1168fb:	66 89 45 fe          	mov    %ax,0xfffffffe(%ebp)
  1168ff:	eb 08                	jmp    116909 <netconn_write+0x139>
      }
    } else {
      len = size;
  116901:	0f b7 45 ec          	movzwl 0xffffffec(%ebp),%eax
  116905:	66 89 45 fe          	mov    %ax,0xfffffffe(%ebp)
    }
    
    LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_write: writing %d bytes (%d)\n", len, copy));
    msg->msg.msg.w.len = len;
  116909:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  11690c:	0f b7 45 fe          	movzwl 0xfffffffe(%ebp),%eax
  116910:	66 89 42 10          	mov    %ax,0x10(%edx)
    api_msg_post(msg);
  116914:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  116917:	89 04 24             	mov    %eax,(%esp)
  11691a:	e8 81 15 00 00       	call   117ea0 <api_msg_post>
    sys_mbox_fetch(conn->mbox, NULL);    
  11691f:	8b 45 08             	mov    0x8(%ebp),%eax
  116922:	8b 40 10             	mov    0x10(%eax),%eax
  116925:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  11692c:	00 
  11692d:	89 04 24             	mov    %eax,(%esp)
  116930:	e8 cb 93 ff ff       	call   10fd00 <sys_mbox_fetch>
    if (conn->err == ERR_OK) {
  116935:	8b 45 08             	mov    0x8(%ebp),%eax
  116938:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
  11693c:	84 c0                	test   %al,%al
  11693e:	75 19                	jne    116959 <netconn_write+0x189>
      dataptr = (void *)((char *)dataptr + len);
  116940:	0f b7 45 fe          	movzwl 0xfffffffe(%ebp),%eax
  116944:	89 c2                	mov    %eax,%edx
  116946:	8b 45 0c             	mov    0xc(%ebp),%eax
  116949:	8d 04 02             	lea    (%edx,%eax,1),%eax
  11694c:	89 45 0c             	mov    %eax,0xc(%ebp)
      size -= len;
  11694f:	0f b7 45 fe          	movzwl 0xfffffffe(%ebp),%eax
  116953:	66 29 45 ec          	sub    %ax,0xffffffec(%ebp)
  116957:	eb 20                	jmp    116979 <netconn_write+0x1a9>
    } else if (conn->err == ERR_MEM) {
  116959:	8b 45 08             	mov    0x8(%ebp),%eax
  11695c:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
  116960:	3c ff                	cmp    $0xff,%al
  116962:	75 2b                	jne    11698f <netconn_write+0x1bf>
      conn->err = ERR_OK;
  116964:	8b 45 08             	mov    0x8(%ebp),%eax
  116967:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
      sys_sem_wait(conn->sem);
  11696b:	8b 45 08             	mov    0x8(%ebp),%eax
  11696e:	8b 40 1c             	mov    0x1c(%eax),%eax
  116971:	89 04 24             	mov    %eax,(%esp)
  116974:	e8 87 94 ff ff       	call   10fe00 <sys_sem_wait>
  116979:	8b 45 08             	mov    0x8(%ebp),%eax
  11697c:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
  116980:	84 c0                	test   %al,%al
  116982:	75 0b                	jne    11698f <netconn_write+0x1bf>
  116984:	66 83 7d ec 00       	cmpw   $0x0,0xffffffec(%ebp)
  116989:	0f 85 00 ff ff ff    	jne    11688f <netconn_write+0xbf>
    } else {
      goto ret;
    }
  }
 ret:
  memp_free(MEMP_API_MSG, msg);
  11698f:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  116992:	89 44 24 04          	mov    %eax,0x4(%esp)
  116996:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  11699d:	e8 0e 81 ff ff       	call   10eab0 <memp_free>
  conn->state = NETCONN_NONE;
  1169a2:	8b 45 08             	mov    0x8(%ebp),%eax
  1169a5:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  if (conn->sem != SYS_SEM_NULL) {
  1169ac:	8b 45 08             	mov    0x8(%ebp),%eax
  1169af:	8b 40 1c             	mov    0x1c(%eax),%eax
  1169b2:	85 c0                	test   %eax,%eax
  1169b4:	74 18                	je     1169ce <netconn_write+0x1fe>
    sys_sem_free(conn->sem);
  1169b6:	8b 45 08             	mov    0x8(%ebp),%eax
  1169b9:	8b 40 1c             	mov    0x1c(%eax),%eax
  1169bc:	89 04 24             	mov    %eax,(%esp)
  1169bf:	e8 cc 33 00 00       	call   119d90 <sys_sem_free>
    conn->sem = SYS_SEM_NULL;
  1169c4:	8b 45 08             	mov    0x8(%ebp),%eax
  1169c7:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
  }
  
  return conn->err;
  1169ce:	8b 45 08             	mov    0x8(%ebp),%eax
  1169d1:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
  1169d5:	0f be c0             	movsbl %al,%eax
  1169d8:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
  1169db:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
}
  1169de:	c9                   	leave  
  1169df:	c3                   	ret    

001169e0 <netconn_close>:

err_t
netconn_close(struct netconn *conn)
{
  1169e0:	55                   	push   %ebp
  1169e1:	89 e5                	mov    %esp,%ebp
  1169e3:	83 ec 28             	sub    $0x28,%esp
  struct api_msg *msg;

  if (conn == NULL) {
  1169e6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  1169ea:	75 0c                	jne    1169f8 <netconn_close+0x18>
    return ERR_VAL;
  1169ec:	c7 45 ec f9 ff ff ff 	movl   $0xfffffff9,0xffffffec(%ebp)
  1169f3:	e9 b4 00 00 00       	jmp    116aac <netconn_close+0xcc>
  }
  if ((msg = memp_malloc(MEMP_API_MSG)) == NULL) {
  1169f8:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  1169ff:	e8 bc 7f ff ff       	call   10e9c0 <memp_malloc>
  116a04:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  116a07:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  116a0b:	75 13                	jne    116a20 <netconn_close+0x40>
    return (conn->err = ERR_MEM);
  116a0d:	8b 45 08             	mov    0x8(%ebp),%eax
  116a10:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  116a14:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  116a1b:	e9 8c 00 00 00       	jmp    116aac <netconn_close+0xcc>
  }

  conn->state = NETCONN_CLOSE;
  116a20:	8b 45 08             	mov    0x8(%ebp),%eax
  116a23:	c7 40 04 05 00 00 00 	movl   $0x5,0x4(%eax)
 again:
  msg->type = API_MSG_CLOSE;
  116a2a:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  116a2d:	c7 00 0a 00 00 00    	movl   $0xa,(%eax)
  msg->msg.conn = conn;
  116a33:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  116a36:	8b 45 08             	mov    0x8(%ebp),%eax
  116a39:	89 42 04             	mov    %eax,0x4(%edx)
  api_msg_post(msg);
  116a3c:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  116a3f:	89 04 24             	mov    %eax,(%esp)
  116a42:	e8 59 14 00 00       	call   117ea0 <api_msg_post>
  sys_mbox_fetch(conn->mbox, NULL);
  116a47:	8b 45 08             	mov    0x8(%ebp),%eax
  116a4a:	8b 40 10             	mov    0x10(%eax),%eax
  116a4d:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  116a54:	00 
  116a55:	89 04 24             	mov    %eax,(%esp)
  116a58:	e8 a3 92 ff ff       	call   10fd00 <sys_mbox_fetch>
  if (conn->err == ERR_MEM &&
  116a5d:	8b 45 08             	mov    0x8(%ebp),%eax
  116a60:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
  116a64:	3c ff                	cmp    $0xff,%al
  116a66:	75 1a                	jne    116a82 <netconn_close+0xa2>
  116a68:	8b 45 08             	mov    0x8(%ebp),%eax
  116a6b:	8b 40 1c             	mov    0x1c(%eax),%eax
  116a6e:	85 c0                	test   %eax,%eax
  116a70:	74 10                	je     116a82 <netconn_close+0xa2>
     conn->sem != SYS_SEM_NULL) {
    sys_sem_wait(conn->sem);
  116a72:	8b 45 08             	mov    0x8(%ebp),%eax
  116a75:	8b 40 1c             	mov    0x1c(%eax),%eax
  116a78:	89 04 24             	mov    %eax,(%esp)
  116a7b:	e8 80 93 ff ff       	call   10fe00 <sys_sem_wait>
    goto again;
  116a80:	eb a8                	jmp    116a2a <netconn_close+0x4a>
  }
  conn->state = NETCONN_NONE;
  116a82:	8b 45 08             	mov    0x8(%ebp),%eax
  116a85:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  memp_free(MEMP_API_MSG, msg);
  116a8c:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  116a8f:	89 44 24 04          	mov    %eax,0x4(%esp)
  116a93:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  116a9a:	e8 11 80 ff ff       	call   10eab0 <memp_free>
  return conn->err;
  116a9f:	8b 45 08             	mov    0x8(%ebp),%eax
  116aa2:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
  116aa6:	0f be c0             	movsbl %al,%eax
  116aa9:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  116aac:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  116aaf:	c9                   	leave  
  116ab0:	c3                   	ret    
  116ab1:	eb 0d                	jmp    116ac0 <netconn_err>
  116ab3:	90                   	nop    
  116ab4:	90                   	nop    
  116ab5:	90                   	nop    
  116ab6:	90                   	nop    
  116ab7:	90                   	nop    
  116ab8:	90                   	nop    
  116ab9:	90                   	nop    
  116aba:	90                   	nop    
  116abb:	90                   	nop    
  116abc:	90                   	nop    
  116abd:	90                   	nop    
  116abe:	90                   	nop    
  116abf:	90                   	nop    

00116ac0 <netconn_err>:

err_t
netconn_err(struct netconn *conn)
{
  116ac0:	55                   	push   %ebp
  116ac1:	89 e5                	mov    %esp,%ebp
  return conn->err;
  116ac3:	8b 45 08             	mov    0x8(%ebp),%eax
  116ac6:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
  116aca:	0f be c0             	movsbl %al,%eax
}
  116acd:	5d                   	pop    %ebp
  116ace:	c3                   	ret    
  116acf:	90                   	nop    

00116ad0 <recv_raw>:
#if LWIP_RAW
static int
recv_raw(void *arg, struct raw_pcb *pcb, struct pbuf *p,
    struct ip_addr *addr)
{
  116ad0:	55                   	push   %ebp
  116ad1:	89 e5                	mov    %esp,%ebp
  116ad3:	83 ec 28             	sub    $0x28,%esp
  struct netbuf *buf;
  struct netconn *conn;

  conn = arg;
  116ad6:	8b 45 08             	mov    0x8(%ebp),%eax
  116ad9:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  if (!conn) return 0;
  116adc:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  116ae0:	75 0c                	jne    116aee <recv_raw+0x1e>
  116ae2:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  116ae9:	e9 c3 00 00 00       	jmp    116bb1 <recv_raw+0xe1>

  if (conn->recvmbox != SYS_MBOX_NULL) {
  116aee:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  116af1:	8b 40 14             	mov    0x14(%eax),%eax
  116af4:	85 c0                	test   %eax,%eax
  116af6:	0f 84 ae 00 00 00    	je     116baa <recv_raw+0xda>
    if (!(buf = memp_malloc(MEMP_NETBUF))) {
  116afc:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  116b03:	e8 b8 7e ff ff       	call   10e9c0 <memp_malloc>
  116b08:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  116b0b:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  116b0f:	75 0c                	jne    116b1d <recv_raw+0x4d>
      return 0;
  116b11:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  116b18:	e9 94 00 00 00       	jmp    116bb1 <recv_raw+0xe1>
    }
    pbuf_ref(p);
  116b1d:	8b 45 10             	mov    0x10(%ebp),%eax
  116b20:	89 04 24             	mov    %eax,(%esp)
  116b23:	e8 f8 8a ff ff       	call   10f620 <pbuf_ref>
    buf->p = p;
  116b28:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  116b2b:	8b 45 10             	mov    0x10(%ebp),%eax
  116b2e:	89 02                	mov    %eax,(%edx)
    buf->ptr = p;
  116b30:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  116b33:	8b 45 10             	mov    0x10(%ebp),%eax
  116b36:	89 42 04             	mov    %eax,0x4(%edx)
    buf->fromaddr = addr;
  116b39:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  116b3c:	8b 45 14             	mov    0x14(%ebp),%eax
  116b3f:	89 42 08             	mov    %eax,0x8(%edx)
    buf->fromport = pcb->protocol;
  116b42:	8b 45 0c             	mov    0xc(%ebp),%eax
  116b45:	0f b7 50 10          	movzwl 0x10(%eax),%edx
  116b49:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  116b4c:	66 89 50 0c          	mov    %dx,0xc(%eax)

    conn->recv_avail += p->tot_len;
  116b50:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  116b53:	0f b7 50 24          	movzwl 0x24(%eax),%edx
  116b57:	8b 45 10             	mov    0x10(%ebp),%eax
  116b5a:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  116b5e:	01 c2                	add    %eax,%edx
  116b60:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  116b63:	66 89 50 24          	mov    %dx,0x24(%eax)
    /* Register event with callback */
    if (conn->callback)
  116b67:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  116b6a:	8b 40 28             	mov    0x28(%eax),%eax
  116b6d:	85 c0                	test   %eax,%eax
  116b6f:	74 24                	je     116b95 <recv_raw+0xc5>
        (*conn->callback)(conn, NETCONN_EVT_RCVPLUS, p->tot_len);
  116b71:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  116b74:	8b 50 28             	mov    0x28(%eax),%edx
  116b77:	8b 45 10             	mov    0x10(%ebp),%eax
  116b7a:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  116b7e:	0f b7 c0             	movzwl %ax,%eax
  116b81:	89 44 24 08          	mov    %eax,0x8(%esp)
  116b85:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  116b8c:	00 
  116b8d:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  116b90:	89 04 24             	mov    %eax,(%esp)
  116b93:	ff d2                	call   *%edx
    sys_mbox_post(conn->recvmbox, buf);
  116b95:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  116b98:	8b 50 14             	mov    0x14(%eax),%edx
  116b9b:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  116b9e:	89 44 24 04          	mov    %eax,0x4(%esp)
  116ba2:	89 14 24             	mov    %edx,(%esp)
  116ba5:	e8 d6 33 00 00       	call   119f80 <sys_mbox_post>
  }

  return 0; /* do not eat the packet */
  116baa:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  116bb1:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  116bb4:	c9                   	leave  
  116bb5:	c3                   	ret    
  116bb6:	8d 76 00             	lea    0x0(%esi),%esi
  116bb9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00116bc0 <recv_udp>:
#endif
#if LWIP_UDP
static void
recv_udp(void *arg, struct udp_pcb *pcb, struct pbuf *p,
   struct ip_addr *addr, u16_t port)
{
  116bc0:	55                   	push   %ebp
  116bc1:	89 e5                	mov    %esp,%ebp
  116bc3:	83 ec 28             	sub    $0x28,%esp
  116bc6:	8b 45 18             	mov    0x18(%ebp),%eax
  116bc9:	66 89 45 ec          	mov    %ax,0xffffffec(%ebp)
  struct netbuf *buf;
  struct netconn *conn;

  conn = arg;
  116bcd:	8b 45 08             	mov    0x8(%ebp),%eax
  116bd0:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  
  if (conn == NULL) {
  116bd3:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  116bd7:	75 10                	jne    116be9 <recv_udp+0x29>
    pbuf_free(p);
  116bd9:	8b 45 10             	mov    0x10(%ebp),%eax
  116bdc:	89 04 24             	mov    %eax,(%esp)
  116bdf:	e8 cc 88 ff ff       	call   10f4b0 <pbuf_free>
    return;
  116be4:	e9 af 00 00 00       	jmp    116c98 <recv_udp+0xd8>
  }
  if (conn->recvmbox != SYS_MBOX_NULL) {
  116be9:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  116bec:	8b 40 14             	mov    0x14(%eax),%eax
  116bef:	85 c0                	test   %eax,%eax
  116bf1:	0f 84 a1 00 00 00    	je     116c98 <recv_udp+0xd8>
    buf = memp_malloc(MEMP_NETBUF);
  116bf7:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  116bfe:	e8 bd 7d ff ff       	call   10e9c0 <memp_malloc>
  116c03:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
    if (buf == NULL) {
  116c06:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  116c0a:	75 0d                	jne    116c19 <recv_udp+0x59>
      pbuf_free(p);
  116c0c:	8b 45 10             	mov    0x10(%ebp),%eax
  116c0f:	89 04 24             	mov    %eax,(%esp)
  116c12:	e8 99 88 ff ff       	call   10f4b0 <pbuf_free>
      return;
  116c17:	eb 7f                	jmp    116c98 <recv_udp+0xd8>
    } else {
      buf->p = p;
  116c19:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  116c1c:	8b 45 10             	mov    0x10(%ebp),%eax
  116c1f:	89 02                	mov    %eax,(%edx)
      buf->ptr = p;
  116c21:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  116c24:	8b 45 10             	mov    0x10(%ebp),%eax
  116c27:	89 42 04             	mov    %eax,0x4(%edx)
      buf->fromaddr = addr;
  116c2a:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  116c2d:	8b 45 14             	mov    0x14(%ebp),%eax
  116c30:	89 42 08             	mov    %eax,0x8(%edx)
      buf->fromport = port;
  116c33:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  116c36:	0f b7 45 ec          	movzwl 0xffffffec(%ebp),%eax
  116c3a:	66 89 42 0c          	mov    %ax,0xc(%edx)
    }

  conn->recv_avail += p->tot_len;
  116c3e:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  116c41:	0f b7 50 24          	movzwl 0x24(%eax),%edx
  116c45:	8b 45 10             	mov    0x10(%ebp),%eax
  116c48:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  116c4c:	01 c2                	add    %eax,%edx
  116c4e:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  116c51:	66 89 50 24          	mov    %dx,0x24(%eax)
    /* Register event with callback */
    if (conn->callback)
  116c55:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  116c58:	8b 40 28             	mov    0x28(%eax),%eax
  116c5b:	85 c0                	test   %eax,%eax
  116c5d:	74 24                	je     116c83 <recv_udp+0xc3>
        (*conn->callback)(conn, NETCONN_EVT_RCVPLUS, p->tot_len);
  116c5f:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  116c62:	8b 50 28             	mov    0x28(%eax),%edx
  116c65:	8b 45 10             	mov    0x10(%ebp),%eax
  116c68:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  116c6c:	0f b7 c0             	movzwl %ax,%eax
  116c6f:	89 44 24 08          	mov    %eax,0x8(%esp)
  116c73:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  116c7a:	00 
  116c7b:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  116c7e:	89 04 24             	mov    %eax,(%esp)
  116c81:	ff d2                	call   *%edx
    sys_mbox_post(conn->recvmbox, buf);
  116c83:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  116c86:	8b 50 14             	mov    0x14(%eax),%edx
  116c89:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  116c8c:	89 44 24 04          	mov    %eax,0x4(%esp)
  116c90:	89 14 24             	mov    %edx,(%esp)
  116c93:	e8 e8 32 00 00       	call   119f80 <sys_mbox_post>
  }
}
  116c98:	c9                   	leave  
  116c99:	c3                   	ret    
  116c9a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

00116ca0 <recv_tcp>:
#endif /* LWIP_UDP */
#if LWIP_TCP

static err_t
recv_tcp(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
  116ca0:	55                   	push   %ebp
  116ca1:	89 e5                	mov    %esp,%ebp
  116ca3:	83 ec 28             	sub    $0x28,%esp
  116ca6:	8b 45 14             	mov    0x14(%ebp),%eax
  116ca9:	88 45 ec             	mov    %al,0xffffffec(%ebp)
  struct netconn *conn;
  u16_t len;
  
  conn = arg;
  116cac:	8b 45 08             	mov    0x8(%ebp),%eax
  116caf:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)

  if (conn == NULL) {
  116cb2:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  116cb6:	75 17                	jne    116ccf <recv_tcp+0x2f>
    pbuf_free(p);
  116cb8:	8b 45 10             	mov    0x10(%ebp),%eax
  116cbb:	89 04 24             	mov    %eax,(%esp)
  116cbe:	e8 ed 87 ff ff       	call   10f4b0 <pbuf_free>
    return ERR_VAL;
  116cc3:	c7 45 e8 f9 ff ff ff 	movl   $0xfffffff9,0xffffffe8(%ebp)
  116cca:	e9 85 00 00 00       	jmp    116d54 <recv_tcp+0xb4>
  }

  if (conn->recvmbox != SYS_MBOX_NULL) {
  116ccf:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  116cd2:	8b 40 14             	mov    0x14(%eax),%eax
  116cd5:	85 c0                	test   %eax,%eax
  116cd7:	74 74                	je     116d4d <recv_tcp+0xad>
        
    conn->err = err;
  116cd9:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  116cdc:	0f b6 45 ec          	movzbl 0xffffffec(%ebp),%eax
  116ce0:	88 42 0c             	mov    %al,0xc(%edx)
    if (p != NULL) {
  116ce3:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  116ce7:	74 21                	je     116d0a <recv_tcp+0x6a>
        len = p->tot_len;
  116ce9:	8b 45 10             	mov    0x10(%ebp),%eax
  116cec:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  116cf0:	66 89 45 fe          	mov    %ax,0xfffffffe(%ebp)
        conn->recv_avail += len;
  116cf4:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  116cf7:	0f b7 40 24          	movzwl 0x24(%eax),%eax
  116cfb:	89 c2                	mov    %eax,%edx
  116cfd:	66 03 55 fe          	add    0xfffffffe(%ebp),%dx
  116d01:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  116d04:	66 89 50 24          	mov    %dx,0x24(%eax)
  116d08:	eb 06                	jmp    116d10 <recv_tcp+0x70>
    }
    else
        len = 0;
  116d0a:	66 c7 45 fe 00 00    	movw   $0x0,0xfffffffe(%ebp)
    /* Register event with callback */
    if (conn->callback)
  116d10:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  116d13:	8b 40 28             	mov    0x28(%eax),%eax
  116d16:	85 c0                	test   %eax,%eax
  116d18:	74 1e                	je     116d38 <recv_tcp+0x98>
        (*conn->callback)(conn, NETCONN_EVT_RCVPLUS, len);
  116d1a:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  116d1d:	8b 50 28             	mov    0x28(%eax),%edx
  116d20:	0f b7 45 fe          	movzwl 0xfffffffe(%ebp),%eax
  116d24:	89 44 24 08          	mov    %eax,0x8(%esp)
  116d28:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  116d2f:	00 
  116d30:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  116d33:	89 04 24             	mov    %eax,(%esp)
  116d36:	ff d2                	call   *%edx
    sys_mbox_post(conn->recvmbox, p);
  116d38:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  116d3b:	8b 50 14             	mov    0x14(%eax),%edx
  116d3e:	8b 45 10             	mov    0x10(%ebp),%eax
  116d41:	89 44 24 04          	mov    %eax,0x4(%esp)
  116d45:	89 14 24             	mov    %edx,(%esp)
  116d48:	e8 33 32 00 00       	call   119f80 <sys_mbox_post>
  }  
  return ERR_OK;
  116d4d:	c7 45 e8 00 00 00 00 	movl   $0x0,0xffffffe8(%ebp)
  116d54:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
}
  116d57:	c9                   	leave  
  116d58:	c3                   	ret    
  116d59:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

00116d60 <poll_tcp>:


static err_t
poll_tcp(void *arg, struct tcp_pcb *pcb)
{
  116d60:	55                   	push   %ebp
  116d61:	89 e5                	mov    %esp,%ebp
  116d63:	83 ec 18             	sub    $0x18,%esp
  struct netconn *conn;

  conn = arg;
  116d66:	8b 45 08             	mov    0x8(%ebp),%eax
  116d69:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  if (conn != NULL &&
  116d6c:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  116d70:	74 2e                	je     116da0 <poll_tcp+0x40>
  116d72:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  116d75:	8b 40 04             	mov    0x4(%eax),%eax
  116d78:	83 f8 01             	cmp    $0x1,%eax
  116d7b:	74 0b                	je     116d88 <poll_tcp+0x28>
  116d7d:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  116d80:	8b 40 04             	mov    0x4(%eax),%eax
  116d83:	83 f8 05             	cmp    $0x5,%eax
  116d86:	75 18                	jne    116da0 <poll_tcp+0x40>
  116d88:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  116d8b:	8b 40 1c             	mov    0x1c(%eax),%eax
  116d8e:	85 c0                	test   %eax,%eax
  116d90:	74 0e                	je     116da0 <poll_tcp+0x40>
     (conn->state == NETCONN_WRITE || conn->state == NETCONN_CLOSE) &&
     conn->sem != SYS_SEM_NULL) {
    sys_sem_signal(conn->sem);
  116d92:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  116d95:	8b 40 1c             	mov    0x1c(%eax),%eax
  116d98:	89 04 24             	mov    %eax,(%esp)
  116d9b:	e8 20 30 00 00       	call   119dc0 <sys_sem_signal>
  }
  return ERR_OK;
  116da0:	b8 00 00 00 00       	mov    $0x0,%eax
}
  116da5:	c9                   	leave  
  116da6:	c3                   	ret    
  116da7:	89 f6                	mov    %esi,%esi
  116da9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00116db0 <sent_tcp>:

static err_t
sent_tcp(void *arg, struct tcp_pcb *pcb, u16_t len)
{
  116db0:	55                   	push   %ebp
  116db1:	89 e5                	mov    %esp,%ebp
  116db3:	83 ec 28             	sub    $0x28,%esp
  116db6:	8b 45 10             	mov    0x10(%ebp),%eax
  116db9:	66 89 45 ec          	mov    %ax,0xffffffec(%ebp)
  struct netconn *conn;

  conn = arg;
  116dbd:	8b 45 08             	mov    0x8(%ebp),%eax
  116dc0:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  if (conn != NULL && conn->sem != SYS_SEM_NULL) {
  116dc3:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  116dc7:	74 18                	je     116de1 <sent_tcp+0x31>
  116dc9:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  116dcc:	8b 40 1c             	mov    0x1c(%eax),%eax
  116dcf:	85 c0                	test   %eax,%eax
  116dd1:	74 0e                	je     116de1 <sent_tcp+0x31>
    sys_sem_signal(conn->sem);
  116dd3:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  116dd6:	8b 40 1c             	mov    0x1c(%eax),%eax
  116dd9:	89 04 24             	mov    %eax,(%esp)
  116ddc:	e8 df 2f 00 00       	call   119dc0 <sys_sem_signal>
  }

  if (conn && conn->callback)
  116de1:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  116de5:	74 38                	je     116e1f <sent_tcp+0x6f>
  116de7:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  116dea:	8b 40 28             	mov    0x28(%eax),%eax
  116ded:	85 c0                	test   %eax,%eax
  116def:	74 2e                	je     116e1f <sent_tcp+0x6f>
      if (tcp_sndbuf(conn->pcb.tcp) > TCP_SNDLOWAT)
  116df1:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  116df4:	8b 40 08             	mov    0x8(%eax),%eax
  116df7:	0f b7 40 6a          	movzwl 0x6a(%eax),%eax
  116dfb:	66 3d 00 04          	cmp    $0x400,%ax
  116dff:	76 1e                	jbe    116e1f <sent_tcp+0x6f>
          (*conn->callback)(conn, NETCONN_EVT_SENDPLUS, len);
  116e01:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  116e04:	8b 50 28             	mov    0x28(%eax),%edx
  116e07:	0f b7 45 ec          	movzwl 0xffffffec(%ebp),%eax
  116e0b:	89 44 24 08          	mov    %eax,0x8(%esp)
  116e0f:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
  116e16:	00 
  116e17:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  116e1a:	89 04 24             	mov    %eax,(%esp)
  116e1d:	ff d2                	call   *%edx
  
  return ERR_OK;
  116e1f:	b8 00 00 00 00       	mov    $0x0,%eax
}
  116e24:	c9                   	leave  
  116e25:	c3                   	ret    
  116e26:	8d 76 00             	lea    0x0(%esi),%esi
  116e29:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00116e30 <err_tcp>:

static void
err_tcp(void *arg, err_t err)
{
  116e30:	55                   	push   %ebp
  116e31:	89 e5                	mov    %esp,%ebp
  116e33:	83 ec 28             	sub    $0x28,%esp
  116e36:	8b 45 0c             	mov    0xc(%ebp),%eax
  116e39:	88 45 ec             	mov    %al,0xffffffec(%ebp)
  struct netconn *conn;

  conn = arg;
  116e3c:	8b 45 08             	mov    0x8(%ebp),%eax
  116e3f:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)

  conn->pcb.tcp = NULL;
  116e42:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  116e45:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)

  
  conn->err = err;
  116e4c:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  116e4f:	0f b6 45 ec          	movzbl 0xffffffec(%ebp),%eax
  116e53:	88 42 0c             	mov    %al,0xc(%edx)
  if (conn->recvmbox != SYS_MBOX_NULL) {
  116e56:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  116e59:	8b 40 14             	mov    0x14(%eax),%eax
  116e5c:	85 c0                	test   %eax,%eax
  116e5e:	74 3e                	je     116e9e <err_tcp+0x6e>
    /* Register event with callback */
    if (conn->callback)
  116e60:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  116e63:	8b 40 28             	mov    0x28(%eax),%eax
  116e66:	85 c0                	test   %eax,%eax
  116e68:	74 1e                	je     116e88 <err_tcp+0x58>
      (*conn->callback)(conn, NETCONN_EVT_RCVPLUS, 0);
  116e6a:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  116e6d:	8b 50 28             	mov    0x28(%eax),%edx
  116e70:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  116e77:	00 
  116e78:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  116e7f:	00 
  116e80:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  116e83:	89 04 24             	mov    %eax,(%esp)
  116e86:	ff d2                	call   *%edx
    sys_mbox_post(conn->recvmbox, NULL);
  116e88:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  116e8b:	8b 40 14             	mov    0x14(%eax),%eax
  116e8e:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  116e95:	00 
  116e96:	89 04 24             	mov    %eax,(%esp)
  116e99:	e8 e2 30 00 00       	call   119f80 <sys_mbox_post>
  }
  if (conn->mbox != SYS_MBOX_NULL) {
  116e9e:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  116ea1:	8b 40 10             	mov    0x10(%eax),%eax
  116ea4:	85 c0                	test   %eax,%eax
  116ea6:	74 16                	je     116ebe <err_tcp+0x8e>
    sys_mbox_post(conn->mbox, NULL);
  116ea8:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  116eab:	8b 40 10             	mov    0x10(%eax),%eax
  116eae:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  116eb5:	00 
  116eb6:	89 04 24             	mov    %eax,(%esp)
  116eb9:	e8 c2 30 00 00       	call   119f80 <sys_mbox_post>
  }
  if (conn->acceptmbox != SYS_MBOX_NULL) {
  116ebe:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  116ec1:	8b 40 18             	mov    0x18(%eax),%eax
  116ec4:	85 c0                	test   %eax,%eax
  116ec6:	74 3e                	je     116f06 <err_tcp+0xd6>
     /* Register event with callback */
    if (conn->callback)
  116ec8:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  116ecb:	8b 40 28             	mov    0x28(%eax),%eax
  116ece:	85 c0                	test   %eax,%eax
  116ed0:	74 1e                	je     116ef0 <err_tcp+0xc0>
      (*conn->callback)(conn, NETCONN_EVT_RCVPLUS, 0);
  116ed2:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  116ed5:	8b 50 28             	mov    0x28(%eax),%edx
  116ed8:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  116edf:	00 
  116ee0:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  116ee7:	00 
  116ee8:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  116eeb:	89 04 24             	mov    %eax,(%esp)
  116eee:	ff d2                	call   *%edx
    sys_mbox_post(conn->acceptmbox, NULL);
  116ef0:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  116ef3:	8b 40 18             	mov    0x18(%eax),%eax
  116ef6:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  116efd:	00 
  116efe:	89 04 24             	mov    %eax,(%esp)
  116f01:	e8 7a 30 00 00       	call   119f80 <sys_mbox_post>
  }
  if (conn->sem != SYS_SEM_NULL) {
  116f06:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  116f09:	8b 40 1c             	mov    0x1c(%eax),%eax
  116f0c:	85 c0                	test   %eax,%eax
  116f0e:	74 0e                	je     116f1e <err_tcp+0xee>
    sys_sem_signal(conn->sem);
  116f10:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  116f13:	8b 40 1c             	mov    0x1c(%eax),%eax
  116f16:	89 04 24             	mov    %eax,(%esp)
  116f19:	e8 a2 2e 00 00       	call   119dc0 <sys_sem_signal>
  }
}
  116f1e:	c9                   	leave  
  116f1f:	c3                   	ret    

00116f20 <setup_tcp>:

static void
setup_tcp(struct netconn *conn)
{
  116f20:	55                   	push   %ebp
  116f21:	89 e5                	mov    %esp,%ebp
  116f23:	83 ec 28             	sub    $0x28,%esp
  struct tcp_pcb *pcb;
  
  pcb = conn->pcb.tcp;
  116f26:	8b 45 08             	mov    0x8(%ebp),%eax
  116f29:	8b 40 08             	mov    0x8(%eax),%eax
  116f2c:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  tcp_arg(pcb, conn);
  116f2f:	8b 45 08             	mov    0x8(%ebp),%eax
  116f32:	89 44 24 04          	mov    %eax,0x4(%esp)
  116f36:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  116f39:	89 04 24             	mov    %eax,(%esp)
  116f3c:	e8 7f a5 ff ff       	call   1114c0 <tcp_arg>
  tcp_recv(pcb, recv_tcp);
  116f41:	c7 44 24 04 a0 6c 11 	movl   $0x116ca0,0x4(%esp)
  116f48:	00 
  116f49:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  116f4c:	89 04 24             	mov    %eax,(%esp)
  116f4f:	e8 7c a5 ff ff       	call   1114d0 <tcp_recv>
  tcp_sent(pcb, sent_tcp);
  116f54:	c7 44 24 04 b0 6d 11 	movl   $0x116db0,0x4(%esp)
  116f5b:	00 
  116f5c:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  116f5f:	89 04 24             	mov    %eax,(%esp)
  116f62:	e8 89 a5 ff ff       	call   1114f0 <tcp_sent>
  tcp_poll(pcb, poll_tcp, 4);
  116f67:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  116f6e:	00 
  116f6f:	c7 44 24 04 60 6d 11 	movl   $0x116d60,0x4(%esp)
  116f76:	00 
  116f77:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  116f7a:	89 04 24             	mov    %eax,(%esp)
  116f7d:	e8 ae a5 ff ff       	call   111530 <tcp_poll>
  tcp_err(pcb, err_tcp);
  116f82:	c7 44 24 04 30 6e 11 	movl   $0x116e30,0x4(%esp)
  116f89:	00 
  116f8a:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  116f8d:	89 04 24             	mov    %eax,(%esp)
  116f90:	e8 6b a5 ff ff       	call   111500 <tcp_err>
}
  116f95:	c9                   	leave  
  116f96:	c3                   	ret    
  116f97:	89 f6                	mov    %esi,%esi
  116f99:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00116fa0 <accept_function>:

static err_t
accept_function(void *arg, struct tcp_pcb *newpcb, err_t err)
{
  116fa0:	55                   	push   %ebp
  116fa1:	89 e5                	mov    %esp,%ebp
  116fa3:	83 ec 28             	sub    $0x28,%esp
  116fa6:	8b 45 10             	mov    0x10(%ebp),%eax
  116fa9:	88 45 ec             	mov    %al,0xffffffec(%ebp)
  sys_mbox_t mbox;
  struct netconn *newconn;
  struct netconn *conn;
  
#if API_MSG_DEBUG
#if TCP_DEBUG
  tcp_debug_print_state(newpcb->state);
#endif /* TCP_DEBUG */
#endif /* API_MSG_DEBUG */
  conn = (struct netconn *)arg;
  116fac:	8b 45 08             	mov    0x8(%ebp),%eax
  116faf:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  mbox = conn->acceptmbox;
  116fb2:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  116fb5:	8b 40 18             	mov    0x18(%eax),%eax
  116fb8:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  newconn = memp_malloc(MEMP_NETCONN);
  116fbb:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  116fc2:	e8 f9 79 ff ff       	call   10e9c0 <memp_malloc>
  116fc7:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  if (newconn == NULL) {
  116fca:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  116fce:	75 0c                	jne    116fdc <accept_function+0x3c>
    return ERR_MEM;
  116fd0:	c7 45 e8 ff ff ff ff 	movl   $0xffffffff,0xffffffe8(%ebp)
  116fd7:	e9 58 01 00 00       	jmp    117134 <accept_function+0x194>
  }
  newconn->type = NETCONN_TCP;
  116fdc:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  116fdf:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  newconn->pcb.tcp = newpcb;
  116fe5:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  116fe8:	8b 45 0c             	mov    0xc(%ebp),%eax
  116feb:	89 42 08             	mov    %eax,0x8(%edx)
  setup_tcp(newconn);
  116fee:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  116ff1:	89 04 24             	mov    %eax,(%esp)
  116ff4:	e8 27 ff ff ff       	call   116f20 <setup_tcp>
  newconn->recvmbox = sys_mbox_new();
  116ff9:	e8 52 2e 00 00       	call   119e50 <sys_mbox_new>
  116ffe:	89 c2                	mov    %eax,%edx
  117000:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  117003:	89 50 14             	mov    %edx,0x14(%eax)
  if (newconn->recvmbox == SYS_MBOX_NULL) {
  117006:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  117009:	8b 40 14             	mov    0x14(%eax),%eax
  11700c:	85 c0                	test   %eax,%eax
  11700e:	75 1f                	jne    11702f <accept_function+0x8f>
    memp_free(MEMP_NETCONN, newconn);
  117010:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  117013:	89 44 24 04          	mov    %eax,0x4(%esp)
  117017:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  11701e:	e8 8d 7a ff ff       	call   10eab0 <memp_free>
    return ERR_MEM;
  117023:	c7 45 e8 ff ff ff ff 	movl   $0xffffffff,0xffffffe8(%ebp)
  11702a:	e9 05 01 00 00       	jmp    117134 <accept_function+0x194>
  }
  newconn->mbox = sys_mbox_new();
  11702f:	e8 1c 2e 00 00       	call   119e50 <sys_mbox_new>
  117034:	89 c2                	mov    %eax,%edx
  117036:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  117039:	89 50 10             	mov    %edx,0x10(%eax)
  if (newconn->mbox == SYS_MBOX_NULL) {
  11703c:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  11703f:	8b 40 10             	mov    0x10(%eax),%eax
  117042:	85 c0                	test   %eax,%eax
  117044:	75 2d                	jne    117073 <accept_function+0xd3>
    sys_mbox_free(newconn->recvmbox);
  117046:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  117049:	8b 40 14             	mov    0x14(%eax),%eax
  11704c:	89 04 24             	mov    %eax,(%esp)
  11704f:	e8 bc 2e 00 00       	call   119f10 <sys_mbox_free>
    memp_free(MEMP_NETCONN, newconn);
  117054:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  117057:	89 44 24 04          	mov    %eax,0x4(%esp)
  11705b:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  117062:	e8 49 7a ff ff       	call   10eab0 <memp_free>
    return ERR_MEM;
  117067:	c7 45 e8 ff ff ff ff 	movl   $0xffffffff,0xffffffe8(%ebp)
  11706e:	e9 c1 00 00 00       	jmp    117134 <accept_function+0x194>
  }
  newconn->sem = sys_sem_new(0);
  117073:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  11707a:	e8 c1 2c 00 00       	call   119d40 <sys_sem_new>
  11707f:	89 c2                	mov    %eax,%edx
  117081:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  117084:	89 50 1c             	mov    %edx,0x1c(%eax)
  if (newconn->sem == SYS_SEM_NULL) {
  117087:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  11708a:	8b 40 1c             	mov    0x1c(%eax),%eax
  11708d:	85 c0                	test   %eax,%eax
  11708f:	75 38                	jne    1170c9 <accept_function+0x129>
    sys_mbox_free(newconn->recvmbox);
  117091:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  117094:	8b 40 14             	mov    0x14(%eax),%eax
  117097:	89 04 24             	mov    %eax,(%esp)
  11709a:	e8 71 2e 00 00       	call   119f10 <sys_mbox_free>
    sys_mbox_free(newconn->mbox);
  11709f:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1170a2:	8b 40 10             	mov    0x10(%eax),%eax
  1170a5:	89 04 24             	mov    %eax,(%esp)
  1170a8:	e8 63 2e 00 00       	call   119f10 <sys_mbox_free>
    memp_free(MEMP_NETCONN, newconn);
  1170ad:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1170b0:	89 44 24 04          	mov    %eax,0x4(%esp)
  1170b4:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  1170bb:	e8 f0 79 ff ff       	call   10eab0 <memp_free>
    return ERR_MEM;
  1170c0:	c7 45 e8 ff ff ff ff 	movl   $0xffffffff,0xffffffe8(%ebp)
  1170c7:	eb 6b                	jmp    117134 <accept_function+0x194>
  }
  newconn->acceptmbox = SYS_MBOX_NULL;
  1170c9:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1170cc:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
  newconn->err = err;
  1170d3:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  1170d6:	0f b6 45 ec          	movzbl 0xffffffec(%ebp),%eax
  1170da:	88 42 0c             	mov    %al,0xc(%edx)
  /* Register event with callback */
  if (conn->callback)
  1170dd:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1170e0:	8b 40 28             	mov    0x28(%eax),%eax
  1170e3:	85 c0                	test   %eax,%eax
  1170e5:	74 34                	je     11711b <accept_function+0x17b>
  {
    (*conn->callback)(conn, NETCONN_EVT_RCVPLUS, 0);
  1170e7:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1170ea:	8b 50 28             	mov    0x28(%eax),%edx
  1170ed:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  1170f4:	00 
  1170f5:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  1170fc:	00 
  1170fd:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  117100:	89 04 24             	mov    %eax,(%esp)
  117103:	ff d2                	call   *%edx
    /* We have to set the callback here even though
     * the new socket is unknown. Mark the socket as -1. */
    newconn->callback = conn->callback;
  117105:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  117108:	8b 50 28             	mov    0x28(%eax),%edx
  11710b:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  11710e:	89 50 28             	mov    %edx,0x28(%eax)
    newconn->socket = -1;
  117111:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  117114:	c7 40 20 ff ff ff ff 	movl   $0xffffffff,0x20(%eax)
  }
  
  sys_mbox_post(mbox, newconn);
  11711b:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  11711e:	89 44 24 04          	mov    %eax,0x4(%esp)
  117122:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  117125:	89 04 24             	mov    %eax,(%esp)
  117128:	e8 53 2e 00 00       	call   119f80 <sys_mbox_post>
  return ERR_OK;
  11712d:	c7 45 e8 00 00 00 00 	movl   $0x0,0xffffffe8(%ebp)
  117134:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
}
  117137:	c9                   	leave  
  117138:	c3                   	ret    
  117139:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

00117140 <do_newconn>:
#endif /* LWIP_TCP */

static void
do_newconn(struct api_msg_msg *msg)
{
  117140:	55                   	push   %ebp
  117141:	89 e5                	mov    %esp,%ebp
  117143:	53                   	push   %ebx
  117144:	83 ec 14             	sub    $0x14,%esp
   if(msg->conn->pcb.tcp != NULL) {
  117147:	8b 45 08             	mov    0x8(%ebp),%eax
  11714a:	8b 00                	mov    (%eax),%eax
  11714c:	8b 40 08             	mov    0x8(%eax),%eax
  11714f:	85 c0                	test   %eax,%eax
  117151:	74 1d                	je     117170 <do_newconn+0x30>
   /* This "new" connection already has a PCB allocated. */
   /* Is this an error condition? Should it be deleted? 
      We currently just are happy and return. */
     sys_mbox_post(msg->conn->mbox, NULL);
  117153:	8b 45 08             	mov    0x8(%ebp),%eax
  117156:	8b 00                	mov    (%eax),%eax
  117158:	8b 40 10             	mov    0x10(%eax),%eax
  11715b:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  117162:	00 
  117163:	89 04 24             	mov    %eax,(%esp)
  117166:	e8 15 2e 00 00       	call   119f80 <sys_mbox_post>
     return;
  11716b:	e9 a8 01 00 00       	jmp    117318 <do_newconn+0x1d8>
   }

   msg->conn->err = ERR_OK;
  117170:	8b 45 08             	mov    0x8(%ebp),%eax
  117173:	8b 00                	mov    (%eax),%eax
  117175:	c6 40 0c 00          	movb   $0x0,0xc(%eax)

   /* Allocate a PCB for this connection */
   switch(msg->conn->type) {
  117179:	8b 45 08             	mov    0x8(%ebp),%eax
  11717c:	8b 00                	mov    (%eax),%eax
  11717e:	8b 00                	mov    (%eax),%eax
  117180:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  117183:	83 7d f8 04          	cmpl   $0x4,0xfffffff8(%ebp)
  117187:	0f 87 73 01 00 00    	ja     117300 <do_newconn+0x1c0>
  11718d:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  117190:	8b 04 95 58 af 11 00 	mov    0x11af58(,%edx,4),%eax
  117197:	ff e0                	jmp    *%eax
#if LWIP_RAW
   case NETCONN_RAW:
      msg->conn->pcb.raw = raw_new(msg->msg.bc.port); /* misusing the port field */
  117199:	8b 45 08             	mov    0x8(%ebp),%eax
  11719c:	8b 18                	mov    (%eax),%ebx
  11719e:	8b 45 08             	mov    0x8(%ebp),%eax
  1171a1:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  1171a5:	0f b7 c0             	movzwl %ax,%eax
  1171a8:	89 04 24             	mov    %eax,(%esp)
  1171ab:	e8 b0 8a ff ff       	call   10fc60 <raw_new>
  1171b0:	89 43 08             	mov    %eax,0x8(%ebx)
      raw_recv(msg->conn->pcb.raw, recv_raw, msg->conn);
  1171b3:	8b 45 08             	mov    0x8(%ebp),%eax
  1171b6:	8b 10                	mov    (%eax),%edx
  1171b8:	8b 45 08             	mov    0x8(%ebp),%eax
  1171bb:	8b 00                	mov    (%eax),%eax
  1171bd:	8b 40 08             	mov    0x8(%eax),%eax
  1171c0:	89 54 24 08          	mov    %edx,0x8(%esp)
  1171c4:	c7 44 24 04 d0 6a 11 	movl   $0x116ad0,0x4(%esp)
  1171cb:	00 
  1171cc:	89 04 24             	mov    %eax,(%esp)
  1171cf:	e8 8c 88 ff ff       	call   10fa60 <raw_recv>
     break;
  1171d4:	e9 27 01 00 00       	jmp    117300 <do_newconn+0x1c0>
#endif
#if LWIP_UDP
   case NETCONN_UDPLITE:
      msg->conn->pcb.udp = udp_new();
  1171d9:	8b 45 08             	mov    0x8(%ebp),%eax
  1171dc:	8b 18                	mov    (%eax),%ebx
  1171de:	e8 fd e5 ff ff       	call   1157e0 <udp_new>
  1171e3:	89 43 08             	mov    %eax,0x8(%ebx)
      if(msg->conn->pcb.udp == NULL) {
  1171e6:	8b 45 08             	mov    0x8(%ebp),%eax
  1171e9:	8b 00                	mov    (%eax),%eax
  1171eb:	8b 40 08             	mov    0x8(%eax),%eax
  1171ee:	85 c0                	test   %eax,%eax
  1171f0:	75 0e                	jne    117200 <do_newconn+0xc0>
         msg->conn->err = ERR_MEM;
  1171f2:	8b 45 08             	mov    0x8(%ebp),%eax
  1171f5:	8b 00                	mov    (%eax),%eax
  1171f7:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
         break;
  1171fb:	e9 00 01 00 00       	jmp    117300 <do_newconn+0x1c0>
      }
      udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_UDPLITE);
  117200:	8b 45 08             	mov    0x8(%ebp),%eax
  117203:	8b 00                	mov    (%eax),%eax
  117205:	8b 40 08             	mov    0x8(%eax),%eax
  117208:	c6 40 10 02          	movb   $0x2,0x10(%eax)
      udp_recv(msg->conn->pcb.udp, recv_udp, msg->conn);
  11720c:	8b 45 08             	mov    0x8(%ebp),%eax
  11720f:	8b 10                	mov    (%eax),%edx
  117211:	8b 45 08             	mov    0x8(%ebp),%eax
  117214:	8b 00                	mov    (%eax),%eax
  117216:	8b 40 08             	mov    0x8(%eax),%eax
  117219:	89 54 24 08          	mov    %edx,0x8(%esp)
  11721d:	c7 44 24 04 c0 6b 11 	movl   $0x116bc0,0x4(%esp)
  117224:	00 
  117225:	89 04 24             	mov    %eax,(%esp)
  117228:	e8 23 e5 ff ff       	call   115750 <udp_recv>
      break;
  11722d:	e9 ce 00 00 00       	jmp    117300 <do_newconn+0x1c0>
   case NETCONN_UDPNOCHKSUM:
      msg->conn->pcb.udp = udp_new();
  117232:	8b 45 08             	mov    0x8(%ebp),%eax
  117235:	8b 18                	mov    (%eax),%ebx
  117237:	e8 a4 e5 ff ff       	call   1157e0 <udp_new>
  11723c:	89 43 08             	mov    %eax,0x8(%ebx)
      if(msg->conn->pcb.udp == NULL) {
  11723f:	8b 45 08             	mov    0x8(%ebp),%eax
  117242:	8b 00                	mov    (%eax),%eax
  117244:	8b 40 08             	mov    0x8(%eax),%eax
  117247:	85 c0                	test   %eax,%eax
  117249:	75 0e                	jne    117259 <do_newconn+0x119>
         msg->conn->err = ERR_MEM;
  11724b:	8b 45 08             	mov    0x8(%ebp),%eax
  11724e:	8b 00                	mov    (%eax),%eax
  117250:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
         break;
  117254:	e9 a7 00 00 00       	jmp    117300 <do_newconn+0x1c0>
      }
      udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_NOCHKSUM);
  117259:	8b 45 08             	mov    0x8(%ebp),%eax
  11725c:	8b 00                	mov    (%eax),%eax
  11725e:	8b 40 08             	mov    0x8(%eax),%eax
  117261:	c6 40 10 01          	movb   $0x1,0x10(%eax)
      udp_recv(msg->conn->pcb.udp, recv_udp, msg->conn);
  117265:	8b 45 08             	mov    0x8(%ebp),%eax
  117268:	8b 10                	mov    (%eax),%edx
  11726a:	8b 45 08             	mov    0x8(%ebp),%eax
  11726d:	8b 00                	mov    (%eax),%eax
  11726f:	8b 40 08             	mov    0x8(%eax),%eax
  117272:	89 54 24 08          	mov    %edx,0x8(%esp)
  117276:	c7 44 24 04 c0 6b 11 	movl   $0x116bc0,0x4(%esp)
  11727d:	00 
  11727e:	89 04 24             	mov    %eax,(%esp)
  117281:	e8 ca e4 ff ff       	call   115750 <udp_recv>
      break;
  117286:	eb 78                	jmp    117300 <do_newconn+0x1c0>
   case NETCONN_UDP:
      msg->conn->pcb.udp = udp_new();
  117288:	8b 45 08             	mov    0x8(%ebp),%eax
  11728b:	8b 18                	mov    (%eax),%ebx
  11728d:	e8 4e e5 ff ff       	call   1157e0 <udp_new>
  117292:	89 43 08             	mov    %eax,0x8(%ebx)
      if(msg->conn->pcb.udp == NULL) {
  117295:	8b 45 08             	mov    0x8(%ebp),%eax
  117298:	8b 00                	mov    (%eax),%eax
  11729a:	8b 40 08             	mov    0x8(%eax),%eax
  11729d:	85 c0                	test   %eax,%eax
  11729f:	75 0b                	jne    1172ac <do_newconn+0x16c>
         msg->conn->err = ERR_MEM;
  1172a1:	8b 45 08             	mov    0x8(%ebp),%eax
  1172a4:	8b 00                	mov    (%eax),%eax
  1172a6:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
         break;
  1172aa:	eb 54                	jmp    117300 <do_newconn+0x1c0>
      }
      udp_recv(msg->conn->pcb.udp, recv_udp, msg->conn);
  1172ac:	8b 45 08             	mov    0x8(%ebp),%eax
  1172af:	8b 10                	mov    (%eax),%edx
  1172b1:	8b 45 08             	mov    0x8(%ebp),%eax
  1172b4:	8b 00                	mov    (%eax),%eax
  1172b6:	8b 40 08             	mov    0x8(%eax),%eax
  1172b9:	89 54 24 08          	mov    %edx,0x8(%esp)
  1172bd:	c7 44 24 04 c0 6b 11 	movl   $0x116bc0,0x4(%esp)
  1172c4:	00 
  1172c5:	89 04 24             	mov    %eax,(%esp)
  1172c8:	e8 83 e4 ff ff       	call   115750 <udp_recv>
      break;
  1172cd:	eb 31                	jmp    117300 <do_newconn+0x1c0>
#endif /* LWIP_UDP */
#if LWIP_TCP
   case NETCONN_TCP:
      msg->conn->pcb.tcp = tcp_new();
  1172cf:	8b 45 08             	mov    0x8(%ebp),%eax
  1172d2:	8b 18                	mov    (%eax),%ebx
  1172d4:	e8 c7 a1 ff ff       	call   1114a0 <tcp_new>
  1172d9:	89 43 08             	mov    %eax,0x8(%ebx)
      if(msg->conn->pcb.tcp == NULL) {
  1172dc:	8b 45 08             	mov    0x8(%ebp),%eax
  1172df:	8b 00                	mov    (%eax),%eax
  1172e1:	8b 40 08             	mov    0x8(%eax),%eax
  1172e4:	85 c0                	test   %eax,%eax
  1172e6:	75 0b                	jne    1172f3 <do_newconn+0x1b3>
         msg->conn->err = ERR_MEM;
  1172e8:	8b 45 08             	mov    0x8(%ebp),%eax
  1172eb:	8b 00                	mov    (%eax),%eax
  1172ed:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
         break;
  1172f1:	eb 0d                	jmp    117300 <do_newconn+0x1c0>
      }
      setup_tcp(msg->conn);
  1172f3:	8b 45 08             	mov    0x8(%ebp),%eax
  1172f6:	8b 00                	mov    (%eax),%eax
  1172f8:	89 04 24             	mov    %eax,(%esp)
  1172fb:	e8 20 fc ff ff       	call   116f20 <setup_tcp>
      break;
#endif
   }
   
  
  sys_mbox_post(msg->conn->mbox, NULL);
  117300:	8b 45 08             	mov    0x8(%ebp),%eax
  117303:	8b 00                	mov    (%eax),%eax
  117305:	8b 40 10             	mov    0x10(%eax),%eax
  117308:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  11730f:	00 
  117310:	89 04 24             	mov    %eax,(%esp)
  117313:	e8 68 2c 00 00       	call   119f80 <sys_mbox_post>
}
  117318:	83 c4 14             	add    $0x14,%esp
  11731b:	5b                   	pop    %ebx
  11731c:	5d                   	pop    %ebp
  11731d:	c3                   	ret    
  11731e:	89 f6                	mov    %esi,%esi

00117320 <do_delconn>:


static void
do_delconn(struct api_msg_msg *msg)
{
  117320:	55                   	push   %ebp
  117321:	89 e5                	mov    %esp,%ebp
  117323:	83 ec 18             	sub    $0x18,%esp
  if (msg->conn->pcb.tcp != NULL) {
  117326:	8b 45 08             	mov    0x8(%ebp),%eax
  117329:	8b 00                	mov    (%eax),%eax
  11732b:	8b 40 08             	mov    0x8(%eax),%eax
  11732e:	85 c0                	test   %eax,%eax
  117330:	0f 84 55 01 00 00    	je     11748b <do_delconn+0x16b>
    switch (msg->conn->type) {
  117336:	8b 45 08             	mov    0x8(%ebp),%eax
  117339:	8b 00                	mov    (%eax),%eax
  11733b:	8b 00                	mov    (%eax),%eax
  11733d:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  117340:	83 7d fc 03          	cmpl   $0x3,0xfffffffc(%ebp)
  117344:	77 08                	ja     11734e <do_delconn+0x2e>
  117346:	83 7d fc 01          	cmpl   $0x1,0xfffffffc(%ebp)
  11734a:	73 22                	jae    11736e <do_delconn+0x4e>
  11734c:	eb 44                	jmp    117392 <do_delconn+0x72>
  11734e:	83 7d fc 04          	cmpl   $0x4,0xfffffffc(%ebp)
  117352:	74 05                	je     117359 <do_delconn+0x39>
  117354:	e9 32 01 00 00       	jmp    11748b <do_delconn+0x16b>
#if LWIP_RAW
    case NETCONN_RAW:
      raw_remove(msg->conn->pcb.raw);
  117359:	8b 45 08             	mov    0x8(%ebp),%eax
  11735c:	8b 00                	mov    (%eax),%eax
  11735e:	8b 40 08             	mov    0x8(%eax),%eax
  117361:	89 04 24             	mov    %eax,(%esp)
  117364:	e8 87 88 ff ff       	call   10fbf0 <raw_remove>
      break;
  117369:	e9 1d 01 00 00       	jmp    11748b <do_delconn+0x16b>
#endif
#if LWIP_UDP
    case NETCONN_UDPLITE:
      /* FALLTHROUGH */
    case NETCONN_UDPNOCHKSUM:
      /* FALLTHROUGH */
    case NETCONN_UDP:
      msg->conn->pcb.udp->recv_arg = NULL;
  11736e:	8b 45 08             	mov    0x8(%ebp),%eax
  117371:	8b 00                	mov    (%eax),%eax
  117373:	8b 40 08             	mov    0x8(%eax),%eax
  117376:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
      udp_remove(msg->conn->pcb.udp);
  11737d:	8b 45 08             	mov    0x8(%ebp),%eax
  117380:	8b 00                	mov    (%eax),%eax
  117382:	8b 40 08             	mov    0x8(%eax),%eax
  117385:	89 04 24             	mov    %eax,(%esp)
  117388:	e8 e3 e3 ff ff       	call   115770 <udp_remove>
      break;
  11738d:	e9 f9 00 00 00       	jmp    11748b <do_delconn+0x16b>
#endif /* LWIP_UDP */
#if LWIP_TCP      
    case NETCONN_TCP:
      if (msg->conn->pcb.tcp->state == LISTEN) {
  117392:	8b 45 08             	mov    0x8(%ebp),%eax
  117395:	8b 00                	mov    (%eax),%eax
  117397:	8b 40 08             	mov    0x8(%eax),%eax
  11739a:	8b 40 10             	mov    0x10(%eax),%eax
  11739d:	83 f8 01             	cmp    $0x1,%eax
  1173a0:	75 45                	jne    1173e7 <do_delconn+0xc7>
  tcp_arg(msg->conn->pcb.tcp, NULL);
  1173a2:	8b 45 08             	mov    0x8(%ebp),%eax
  1173a5:	8b 00                	mov    (%eax),%eax
  1173a7:	8b 40 08             	mov    0x8(%eax),%eax
  1173aa:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  1173b1:	00 
  1173b2:	89 04 24             	mov    %eax,(%esp)
  1173b5:	e8 06 a1 ff ff       	call   1114c0 <tcp_arg>
  tcp_accept(msg->conn->pcb.tcp, NULL);  
  1173ba:	8b 45 08             	mov    0x8(%ebp),%eax
  1173bd:	8b 00                	mov    (%eax),%eax
  1173bf:	8b 40 08             	mov    0x8(%eax),%eax
  1173c2:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  1173c9:	00 
  1173ca:	89 04 24             	mov    %eax,(%esp)
  1173cd:	e8 4e a1 ff ff       	call   111520 <tcp_accept>
  tcp_close(msg->conn->pcb.tcp);
  1173d2:	8b 45 08             	mov    0x8(%ebp),%eax
  1173d5:	8b 00                	mov    (%eax),%eax
  1173d7:	8b 40 08             	mov    0x8(%eax),%eax
  1173da:	89 04 24             	mov    %eax,(%esp)
  1173dd:	e8 4e 8e ff ff       	call   110230 <tcp_close>
  1173e2:	e9 a4 00 00 00       	jmp    11748b <do_delconn+0x16b>
      } else {
  tcp_arg(msg->conn->pcb.tcp, NULL);
  1173e7:	8b 45 08             	mov    0x8(%ebp),%eax
  1173ea:	8b 00                	mov    (%eax),%eax
  1173ec:	8b 40 08             	mov    0x8(%eax),%eax
  1173ef:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  1173f6:	00 
  1173f7:	89 04 24             	mov    %eax,(%esp)
  1173fa:	e8 c1 a0 ff ff       	call   1114c0 <tcp_arg>
  tcp_sent(msg->conn->pcb.tcp, NULL);
  1173ff:	8b 45 08             	mov    0x8(%ebp),%eax
  117402:	8b 00                	mov    (%eax),%eax
  117404:	8b 40 08             	mov    0x8(%eax),%eax
  117407:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  11740e:	00 
  11740f:	89 04 24             	mov    %eax,(%esp)
  117412:	e8 d9 a0 ff ff       	call   1114f0 <tcp_sent>
  tcp_recv(msg->conn->pcb.tcp, NULL);  
  117417:	8b 45 08             	mov    0x8(%ebp),%eax
  11741a:	8b 00                	mov    (%eax),%eax
  11741c:	8b 40 08             	mov    0x8(%eax),%eax
  11741f:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  117426:	00 
  117427:	89 04 24             	mov    %eax,(%esp)
  11742a:	e8 a1 a0 ff ff       	call   1114d0 <tcp_recv>
  tcp_poll(msg->conn->pcb.tcp, NULL, 0);
  11742f:	8b 45 08             	mov    0x8(%ebp),%eax
  117432:	8b 00                	mov    (%eax),%eax
  117434:	8b 40 08             	mov    0x8(%eax),%eax
  117437:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  11743e:	00 
  11743f:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  117446:	00 
  117447:	89 04 24             	mov    %eax,(%esp)
  11744a:	e8 e1 a0 ff ff       	call   111530 <tcp_poll>
  tcp_err(msg->conn->pcb.tcp, NULL);
  11744f:	8b 45 08             	mov    0x8(%ebp),%eax
  117452:	8b 00                	mov    (%eax),%eax
  117454:	8b 40 08             	mov    0x8(%eax),%eax
  117457:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  11745e:	00 
  11745f:	89 04 24             	mov    %eax,(%esp)
  117462:	e8 99 a0 ff ff       	call   111500 <tcp_err>
  if (tcp_close(msg->conn->pcb.tcp) != ERR_OK) {
  117467:	8b 45 08             	mov    0x8(%ebp),%eax
  11746a:	8b 00                	mov    (%eax),%eax
  11746c:	8b 40 08             	mov    0x8(%eax),%eax
  11746f:	89 04 24             	mov    %eax,(%esp)
  117472:	e8 b9 8d ff ff       	call   110230 <tcp_close>
  117477:	84 c0                	test   %al,%al
  117479:	74 10                	je     11748b <do_delconn+0x16b>
    tcp_abort(msg->conn->pcb.tcp);
  11747b:	8b 45 08             	mov    0x8(%ebp),%eax
  11747e:	8b 00                	mov    (%eax),%eax
  117480:	8b 40 08             	mov    0x8(%eax),%eax
  117483:	89 04 24             	mov    %eax,(%esp)
  117486:	e8 b5 8e ff ff       	call   110340 <tcp_abort>
  }
      }
#endif
    default:  
    break;
    }
  }
  /* Trigger select() in socket layer */
  if (msg->conn->callback)
  11748b:	8b 45 08             	mov    0x8(%ebp),%eax
  11748e:	8b 00                	mov    (%eax),%eax
  117490:	8b 40 28             	mov    0x28(%eax),%eax
  117493:	85 c0                	test   %eax,%eax
  117495:	74 44                	je     1174db <do_delconn+0x1bb>
  {
      (*msg->conn->callback)(msg->conn, NETCONN_EVT_RCVPLUS, 0);
  117497:	8b 45 08             	mov    0x8(%ebp),%eax
  11749a:	8b 00                	mov    (%eax),%eax
  11749c:	8b 50 28             	mov    0x28(%eax),%edx
  11749f:	8b 45 08             	mov    0x8(%ebp),%eax
  1174a2:	8b 00                	mov    (%eax),%eax
  1174a4:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  1174ab:	00 
  1174ac:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  1174b3:	00 
  1174b4:	89 04 24             	mov    %eax,(%esp)
  1174b7:	ff d2                	call   *%edx
      (*msg->conn->callback)(msg->conn, NETCONN_EVT_SENDPLUS, 0);
  1174b9:	8b 45 08             	mov    0x8(%ebp),%eax
  1174bc:	8b 00                	mov    (%eax),%eax
  1174be:	8b 50 28             	mov    0x28(%eax),%edx
  1174c1:	8b 45 08             	mov    0x8(%ebp),%eax
  1174c4:	8b 00                	mov    (%eax),%eax
  1174c6:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  1174cd:	00 
  1174ce:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
  1174d5:	00 
  1174d6:	89 04 24             	mov    %eax,(%esp)
  1174d9:	ff d2                	call   *%edx
  }
  
  if (msg->conn->mbox != SYS_MBOX_NULL) {
  1174db:	8b 45 08             	mov    0x8(%ebp),%eax
  1174de:	8b 00                	mov    (%eax),%eax
  1174e0:	8b 40 10             	mov    0x10(%eax),%eax
  1174e3:	85 c0                	test   %eax,%eax
  1174e5:	74 18                	je     1174ff <do_delconn+0x1df>
    sys_mbox_post(msg->conn->mbox, NULL);
  1174e7:	8b 45 08             	mov    0x8(%ebp),%eax
  1174ea:	8b 00                	mov    (%eax),%eax
  1174ec:	8b 40 10             	mov    0x10(%eax),%eax
  1174ef:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  1174f6:	00 
  1174f7:	89 04 24             	mov    %eax,(%esp)
  1174fa:	e8 81 2a 00 00       	call   119f80 <sys_mbox_post>
  }
}
  1174ff:	c9                   	leave  
  117500:	c3                   	ret    
  117501:	eb 0d                	jmp    117510 <do_bind>
  117503:	90                   	nop    
  117504:	90                   	nop    
  117505:	90                   	nop    
  117506:	90                   	nop    
  117507:	90                   	nop    
  117508:	90                   	nop    
  117509:	90                   	nop    
  11750a:	90                   	nop    
  11750b:	90                   	nop    
  11750c:	90                   	nop    
  11750d:	90                   	nop    
  11750e:	90                   	nop    
  11750f:	90                   	nop    

00117510 <do_bind>:

static void
do_bind(struct api_msg_msg *msg)
{
  117510:	55                   	push   %ebp
  117511:	89 e5                	mov    %esp,%ebp
  117513:	53                   	push   %ebx
  117514:	83 ec 14             	sub    $0x14,%esp
  if (msg->conn->pcb.tcp == NULL) {
  117517:	8b 45 08             	mov    0x8(%ebp),%eax
  11751a:	8b 00                	mov    (%eax),%eax
  11751c:	8b 40 08             	mov    0x8(%eax),%eax
  11751f:	85 c0                	test   %eax,%eax
  117521:	0f 85 25 01 00 00    	jne    11764c <do_bind+0x13c>
    switch (msg->conn->type) {
  117527:	8b 45 08             	mov    0x8(%ebp),%eax
  11752a:	8b 00                	mov    (%eax),%eax
  11752c:	8b 00                	mov    (%eax),%eax
  11752e:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  117531:	83 7d f4 04          	cmpl   $0x4,0xfffffff4(%ebp)
  117535:	0f 87 11 01 00 00    	ja     11764c <do_bind+0x13c>
  11753b:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
  11753e:	8b 04 95 6c af 11 00 	mov    0x11af6c(,%edx,4),%eax
  117545:	ff e0                	jmp    *%eax
#if LWIP_RAW
    case NETCONN_RAW:
      msg->conn->pcb.raw = raw_new(msg->msg.bc.port); /* misusing the port field as protocol */
  117547:	8b 45 08             	mov    0x8(%ebp),%eax
  11754a:	8b 18                	mov    (%eax),%ebx
  11754c:	8b 45 08             	mov    0x8(%ebp),%eax
  11754f:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  117553:	0f b7 c0             	movzwl %ax,%eax
  117556:	89 04 24             	mov    %eax,(%esp)
  117559:	e8 02 87 ff ff       	call   10fc60 <raw_new>
  11755e:	89 43 08             	mov    %eax,0x8(%ebx)
      raw_recv(msg->conn->pcb.raw, recv_raw, msg->conn);
  117561:	8b 45 08             	mov    0x8(%ebp),%eax
  117564:	8b 10                	mov    (%eax),%edx
  117566:	8b 45 08             	mov    0x8(%ebp),%eax
  117569:	8b 00                	mov    (%eax),%eax
  11756b:	8b 40 08             	mov    0x8(%eax),%eax
  11756e:	89 54 24 08          	mov    %edx,0x8(%esp)
  117572:	c7 44 24 04 d0 6a 11 	movl   $0x116ad0,0x4(%esp)
  117579:	00 
  11757a:	89 04 24             	mov    %eax,(%esp)
  11757d:	e8 de 84 ff ff       	call   10fa60 <raw_recv>
      break;
  117582:	e9 c5 00 00 00       	jmp    11764c <do_bind+0x13c>
#endif
#if LWIP_UDP
    case NETCONN_UDPLITE:
      msg->conn->pcb.udp = udp_new();
  117587:	8b 45 08             	mov    0x8(%ebp),%eax
  11758a:	8b 18                	mov    (%eax),%ebx
  11758c:	e8 4f e2 ff ff       	call   1157e0 <udp_new>
  117591:	89 43 08             	mov    %eax,0x8(%ebx)
      udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_UDPLITE);
  117594:	8b 45 08             	mov    0x8(%ebp),%eax
  117597:	8b 00                	mov    (%eax),%eax
  117599:	8b 40 08             	mov    0x8(%eax),%eax
  11759c:	c6 40 10 02          	movb   $0x2,0x10(%eax)
      udp_recv(msg->conn->pcb.udp, recv_udp, msg->conn);
  1175a0:	8b 45 08             	mov    0x8(%ebp),%eax
  1175a3:	8b 10                	mov    (%eax),%edx
  1175a5:	8b 45 08             	mov    0x8(%ebp),%eax
  1175a8:	8b 00                	mov    (%eax),%eax
  1175aa:	8b 40 08             	mov    0x8(%eax),%eax
  1175ad:	89 54 24 08          	mov    %edx,0x8(%esp)
  1175b1:	c7 44 24 04 c0 6b 11 	movl   $0x116bc0,0x4(%esp)
  1175b8:	00 
  1175b9:	89 04 24             	mov    %eax,(%esp)
  1175bc:	e8 8f e1 ff ff       	call   115750 <udp_recv>
      break;
  1175c1:	e9 86 00 00 00       	jmp    11764c <do_bind+0x13c>
    case NETCONN_UDPNOCHKSUM:
      msg->conn->pcb.udp = udp_new();
  1175c6:	8b 45 08             	mov    0x8(%ebp),%eax
  1175c9:	8b 18                	mov    (%eax),%ebx
  1175cb:	e8 10 e2 ff ff       	call   1157e0 <udp_new>
  1175d0:	89 43 08             	mov    %eax,0x8(%ebx)
      udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_NOCHKSUM);
  1175d3:	8b 45 08             	mov    0x8(%ebp),%eax
  1175d6:	8b 00                	mov    (%eax),%eax
  1175d8:	8b 40 08             	mov    0x8(%eax),%eax
  1175db:	c6 40 10 01          	movb   $0x1,0x10(%eax)
      udp_recv(msg->conn->pcb.udp, recv_udp, msg->conn);
  1175df:	8b 45 08             	mov    0x8(%ebp),%eax
  1175e2:	8b 10                	mov    (%eax),%edx
  1175e4:	8b 45 08             	mov    0x8(%ebp),%eax
  1175e7:	8b 00                	mov    (%eax),%eax
  1175e9:	8b 40 08             	mov    0x8(%eax),%eax
  1175ec:	89 54 24 08          	mov    %edx,0x8(%esp)
  1175f0:	c7 44 24 04 c0 6b 11 	movl   $0x116bc0,0x4(%esp)
  1175f7:	00 
  1175f8:	89 04 24             	mov    %eax,(%esp)
  1175fb:	e8 50 e1 ff ff       	call   115750 <udp_recv>
      break;
  117600:	eb 4a                	jmp    11764c <do_bind+0x13c>
    case NETCONN_UDP:
      msg->conn->pcb.udp = udp_new();
  117602:	8b 45 08             	mov    0x8(%ebp),%eax
  117605:	8b 18                	mov    (%eax),%ebx
  117607:	e8 d4 e1 ff ff       	call   1157e0 <udp_new>
  11760c:	89 43 08             	mov    %eax,0x8(%ebx)
      udp_recv(msg->conn->pcb.udp, recv_udp, msg->conn);
  11760f:	8b 45 08             	mov    0x8(%ebp),%eax
  117612:	8b 10                	mov    (%eax),%edx
  117614:	8b 45 08             	mov    0x8(%ebp),%eax
  117617:	8b 00                	mov    (%eax),%eax
  117619:	8b 40 08             	mov    0x8(%eax),%eax
  11761c:	89 54 24 08          	mov    %edx,0x8(%esp)
  117620:	c7 44 24 04 c0 6b 11 	movl   $0x116bc0,0x4(%esp)
  117627:	00 
  117628:	89 04 24             	mov    %eax,(%esp)
  11762b:	e8 20 e1 ff ff       	call   115750 <udp_recv>
      break;
  117630:	eb 1a                	jmp    11764c <do_bind+0x13c>
#endif /* LWIP_UDP */
#if LWIP_TCP      
    case NETCONN_TCP:
      msg->conn->pcb.tcp = tcp_new();
  117632:	8b 45 08             	mov    0x8(%ebp),%eax
  117635:	8b 18                	mov    (%eax),%ebx
  117637:	e8 64 9e ff ff       	call   1114a0 <tcp_new>
  11763c:	89 43 08             	mov    %eax,0x8(%ebx)
      setup_tcp(msg->conn);
  11763f:	8b 45 08             	mov    0x8(%ebp),%eax
  117642:	8b 00                	mov    (%eax),%eax
  117644:	89 04 24             	mov    %eax,(%esp)
  117647:	e8 d4 f8 ff ff       	call   116f20 <setup_tcp>
#endif /* LWIP_TCP */
    default:  
    break;
    }
  }
  switch (msg->conn->type) {
  11764c:	8b 45 08             	mov    0x8(%ebp),%eax
  11764f:	8b 00                	mov    (%eax),%eax
  117651:	8b 00                	mov    (%eax),%eax
  117653:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  117656:	83 7d f8 03          	cmpl   $0x3,0xfffffff8(%ebp)
  11765a:	77 08                	ja     117664 <do_bind+0x154>
  11765c:	83 7d f8 01          	cmpl   $0x1,0xfffffff8(%ebp)
  117660:	73 31                	jae    117693 <do_bind+0x183>
  117662:	eb 61                	jmp    1176c5 <do_bind+0x1b5>
  117664:	83 7d f8 04          	cmpl   $0x4,0xfffffff8(%ebp)
  117668:	74 05                	je     11766f <do_bind+0x15f>
  11766a:	e9 86 00 00 00       	jmp    1176f5 <do_bind+0x1e5>
#if LWIP_RAW
  case NETCONN_RAW:
    msg->conn->err = raw_bind(msg->conn->pcb.raw,msg->msg.bc.ipaddr);
  11766f:	8b 45 08             	mov    0x8(%ebp),%eax
  117672:	8b 18                	mov    (%eax),%ebx
  117674:	8b 45 08             	mov    0x8(%ebp),%eax
  117677:	8b 50 08             	mov    0x8(%eax),%edx
  11767a:	8b 45 08             	mov    0x8(%ebp),%eax
  11767d:	8b 00                	mov    (%eax),%eax
  11767f:	8b 40 08             	mov    0x8(%eax),%eax
  117682:	89 54 24 04          	mov    %edx,0x4(%esp)
  117686:	89 04 24             	mov    %eax,(%esp)
  117689:	e8 72 83 ff ff       	call   10fa00 <raw_bind>
  11768e:	88 43 0c             	mov    %al,0xc(%ebx)
    break;
  117691:	eb 62                	jmp    1176f5 <do_bind+0x1e5>
#endif
#if LWIP_UDP
  case NETCONN_UDPLITE:
    /* FALLTHROUGH */
  case NETCONN_UDPNOCHKSUM:
    /* FALLTHROUGH */
  case NETCONN_UDP:
    msg->conn->err = udp_bind(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  117693:	8b 45 08             	mov    0x8(%ebp),%eax
  117696:	8b 18                	mov    (%eax),%ebx
  117698:	8b 45 08             	mov    0x8(%ebp),%eax
  11769b:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  11769f:	0f b7 c8             	movzwl %ax,%ecx
  1176a2:	8b 45 08             	mov    0x8(%ebp),%eax
  1176a5:	8b 50 08             	mov    0x8(%eax),%edx
  1176a8:	8b 45 08             	mov    0x8(%ebp),%eax
  1176ab:	8b 00                	mov    (%eax),%eax
  1176ad:	8b 40 08             	mov    0x8(%eax),%eax
  1176b0:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  1176b4:	89 54 24 04          	mov    %edx,0x4(%esp)
  1176b8:	89 04 24             	mov    %eax,(%esp)
  1176bb:	e8 a0 dd ff ff       	call   115460 <udp_bind>
  1176c0:	88 43 0c             	mov    %al,0xc(%ebx)
    break;
  1176c3:	eb 30                	jmp    1176f5 <do_bind+0x1e5>
#endif /* LWIP_UDP */
#if LWIP_TCP
  case NETCONN_TCP:
    msg->conn->err = tcp_bind(msg->conn->pcb.tcp,
  1176c5:	8b 45 08             	mov    0x8(%ebp),%eax
  1176c8:	8b 18                	mov    (%eax),%ebx
  1176ca:	8b 45 08             	mov    0x8(%ebp),%eax
  1176cd:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  1176d1:	0f b7 c8             	movzwl %ax,%ecx
  1176d4:	8b 45 08             	mov    0x8(%ebp),%eax
  1176d7:	8b 50 08             	mov    0x8(%eax),%edx
  1176da:	8b 45 08             	mov    0x8(%ebp),%eax
  1176dd:	8b 00                	mov    (%eax),%eax
  1176df:	8b 40 08             	mov    0x8(%eax),%eax
  1176e2:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  1176e6:	89 54 24 04          	mov    %edx,0x4(%esp)
  1176ea:	89 04 24             	mov    %eax,(%esp)
  1176ed:	e8 ce 8d ff ff       	call   1104c0 <tcp_bind>
  1176f2:	88 43 0c             	mov    %al,0xc(%ebx)
            msg->msg.bc.ipaddr, msg->msg.bc.port);
#endif /* LWIP_TCP */
  default:
    break;
  }
  sys_mbox_post(msg->conn->mbox, NULL);
  1176f5:	8b 45 08             	mov    0x8(%ebp),%eax
  1176f8:	8b 00                	mov    (%eax),%eax
  1176fa:	8b 40 10             	mov    0x10(%eax),%eax
  1176fd:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  117704:	00 
  117705:	89 04 24             	mov    %eax,(%esp)
  117708:	e8 73 28 00 00       	call   119f80 <sys_mbox_post>
}
  11770d:	83 c4 14             	add    $0x14,%esp
  117710:	5b                   	pop    %ebx
  117711:	5d                   	pop    %ebp
  117712:	c3                   	ret    
  117713:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  117719:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00117720 <do_connected>:
#if LWIP_TCP

static err_t
do_connected(void *arg, struct tcp_pcb *pcb, err_t err)
{
  117720:	55                   	push   %ebp
  117721:	89 e5                	mov    %esp,%ebp
  117723:	83 ec 28             	sub    $0x28,%esp
  117726:	8b 45 10             	mov    0x10(%ebp),%eax
  117729:	88 45 ec             	mov    %al,0xffffffec(%ebp)
  struct netconn *conn;

  conn = arg;
  11772c:	8b 45 08             	mov    0x8(%ebp),%eax
  11772f:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)

  if (conn == NULL) {
  117732:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  117736:	75 09                	jne    117741 <do_connected+0x21>
    return ERR_VAL;
  117738:	c7 45 e8 f9 ff ff ff 	movl   $0xfffffff9,0xffffffe8(%ebp)
  11773f:	eb 41                	jmp    117782 <do_connected+0x62>
  }
  
  conn->err = err;
  117741:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  117744:	0f b6 45 ec          	movzbl 0xffffffec(%ebp),%eax
  117748:	88 42 0c             	mov    %al,0xc(%edx)
  if (conn->type == NETCONN_TCP && err == ERR_OK) {
  11774b:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  11774e:	8b 00                	mov    (%eax),%eax
  117750:	85 c0                	test   %eax,%eax
  117752:	75 11                	jne    117765 <do_connected+0x45>
  117754:	80 7d ec 00          	cmpb   $0x0,0xffffffec(%ebp)
  117758:	75 0b                	jne    117765 <do_connected+0x45>
    setup_tcp(conn);
  11775a:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  11775d:	89 04 24             	mov    %eax,(%esp)
  117760:	e8 bb f7 ff ff       	call   116f20 <setup_tcp>
  }    
  sys_mbox_post(conn->mbox, NULL);
  117765:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  117768:	8b 40 10             	mov    0x10(%eax),%eax
  11776b:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  117772:	00 
  117773:	89 04 24             	mov    %eax,(%esp)
  117776:	e8 05 28 00 00       	call   119f80 <sys_mbox_post>
  return ERR_OK;
  11777b:	c7 45 e8 00 00 00 00 	movl   $0x0,0xffffffe8(%ebp)
  117782:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
}
  117785:	c9                   	leave  
  117786:	c3                   	ret    
  117787:	89 f6                	mov    %esi,%esi
  117789:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00117790 <do_connect>:
#endif  

static void
do_connect(struct api_msg_msg *msg)
{
  117790:	55                   	push   %ebp
  117791:	89 e5                	mov    %esp,%ebp
  117793:	53                   	push   %ebx
  117794:	83 ec 24             	sub    $0x24,%esp
  if (msg->conn->pcb.tcp == NULL) {
  117797:	8b 45 08             	mov    0x8(%ebp),%eax
  11779a:	8b 00                	mov    (%eax),%eax
  11779c:	8b 40 08             	mov    0x8(%eax),%eax
  11779f:	85 c0                	test   %eax,%eax
  1177a1:	0f 85 e3 01 00 00    	jne    11798a <do_connect+0x1fa>
    switch (msg->conn->type) {
  1177a7:	8b 45 08             	mov    0x8(%ebp),%eax
  1177aa:	8b 00                	mov    (%eax),%eax
  1177ac:	8b 00                	mov    (%eax),%eax
  1177ae:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  1177b1:	83 7d f4 04          	cmpl   $0x4,0xfffffff4(%ebp)
  1177b5:	0f 87 cf 01 00 00    	ja     11798a <do_connect+0x1fa>
  1177bb:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
  1177be:	8b 04 95 80 af 11 00 	mov    0x11af80(,%edx,4),%eax
  1177c5:	ff e0                	jmp    *%eax
#if LWIP_RAW
    case NETCONN_RAW:
      msg->conn->pcb.raw = raw_new(msg->msg.bc.port); /* misusing the port field as protocol */
  1177c7:	8b 45 08             	mov    0x8(%ebp),%eax
  1177ca:	8b 18                	mov    (%eax),%ebx
  1177cc:	8b 45 08             	mov    0x8(%ebp),%eax
  1177cf:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  1177d3:	0f b7 c0             	movzwl %ax,%eax
  1177d6:	89 04 24             	mov    %eax,(%esp)
  1177d9:	e8 82 84 ff ff       	call   10fc60 <raw_new>
  1177de:	89 43 08             	mov    %eax,0x8(%ebx)
      raw_recv(msg->conn->pcb.raw, recv_raw, msg->conn);
  1177e1:	8b 45 08             	mov    0x8(%ebp),%eax
  1177e4:	8b 10                	mov    (%eax),%edx
  1177e6:	8b 45 08             	mov    0x8(%ebp),%eax
  1177e9:	8b 00                	mov    (%eax),%eax
  1177eb:	8b 40 08             	mov    0x8(%eax),%eax
  1177ee:	89 54 24 08          	mov    %edx,0x8(%esp)
  1177f2:	c7 44 24 04 d0 6a 11 	movl   $0x116ad0,0x4(%esp)
  1177f9:	00 
  1177fa:	89 04 24             	mov    %eax,(%esp)
  1177fd:	e8 5e 82 ff ff       	call   10fa60 <raw_recv>
      break;
  117802:	e9 83 01 00 00       	jmp    11798a <do_connect+0x1fa>
#endif
#if LWIP_UDP
    case NETCONN_UDPLITE:
      msg->conn->pcb.udp = udp_new();
  117807:	8b 45 08             	mov    0x8(%ebp),%eax
  11780a:	8b 18                	mov    (%eax),%ebx
  11780c:	e8 cf df ff ff       	call   1157e0 <udp_new>
  117811:	89 43 08             	mov    %eax,0x8(%ebx)
      if (msg->conn->pcb.udp == NULL) {
  117814:	8b 45 08             	mov    0x8(%ebp),%eax
  117817:	8b 00                	mov    (%eax),%eax
  117819:	8b 40 08             	mov    0x8(%eax),%eax
  11781c:	85 c0                	test   %eax,%eax
  11781e:	75 26                	jne    117846 <do_connect+0xb6>
  msg->conn->err = ERR_MEM;
  117820:	8b 45 08             	mov    0x8(%ebp),%eax
  117823:	8b 00                	mov    (%eax),%eax
  117825:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  sys_mbox_post(msg->conn->mbox, NULL);
  117829:	8b 45 08             	mov    0x8(%ebp),%eax
  11782c:	8b 00                	mov    (%eax),%eax
  11782e:	8b 40 10             	mov    0x10(%eax),%eax
  117831:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  117838:	00 
  117839:	89 04 24             	mov    %eax,(%esp)
  11783c:	e8 3f 27 00 00       	call   119f80 <sys_mbox_post>
  return;
  117841:	e9 1d 02 00 00       	jmp    117a63 <do_connect+0x2d3>
      }
      udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_UDPLITE);
  117846:	8b 45 08             	mov    0x8(%ebp),%eax
  117849:	8b 00                	mov    (%eax),%eax
  11784b:	8b 40 08             	mov    0x8(%eax),%eax
  11784e:	c6 40 10 02          	movb   $0x2,0x10(%eax)
      udp_recv(msg->conn->pcb.udp, recv_udp, msg->conn);
  117852:	8b 45 08             	mov    0x8(%ebp),%eax
  117855:	8b 10                	mov    (%eax),%edx
  117857:	8b 45 08             	mov    0x8(%ebp),%eax
  11785a:	8b 00                	mov    (%eax),%eax
  11785c:	8b 40 08             	mov    0x8(%eax),%eax
  11785f:	89 54 24 08          	mov    %edx,0x8(%esp)
  117863:	c7 44 24 04 c0 6b 11 	movl   $0x116bc0,0x4(%esp)
  11786a:	00 
  11786b:	89 04 24             	mov    %eax,(%esp)
  11786e:	e8 dd de ff ff       	call   115750 <udp_recv>
      break;
  117873:	e9 12 01 00 00       	jmp    11798a <do_connect+0x1fa>
    case NETCONN_UDPNOCHKSUM:
      msg->conn->pcb.udp = udp_new();
  117878:	8b 45 08             	mov    0x8(%ebp),%eax
  11787b:	8b 18                	mov    (%eax),%ebx
  11787d:	e8 5e df ff ff       	call   1157e0 <udp_new>
  117882:	89 43 08             	mov    %eax,0x8(%ebx)
      if (msg->conn->pcb.udp == NULL) {
  117885:	8b 45 08             	mov    0x8(%ebp),%eax
  117888:	8b 00                	mov    (%eax),%eax
  11788a:	8b 40 08             	mov    0x8(%eax),%eax
  11788d:	85 c0                	test   %eax,%eax
  11788f:	75 26                	jne    1178b7 <do_connect+0x127>
  msg->conn->err = ERR_MEM;
  117891:	8b 45 08             	mov    0x8(%ebp),%eax
  117894:	8b 00                	mov    (%eax),%eax
  117896:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  sys_mbox_post(msg->conn->mbox, NULL);
  11789a:	8b 45 08             	mov    0x8(%ebp),%eax
  11789d:	8b 00                	mov    (%eax),%eax
  11789f:	8b 40 10             	mov    0x10(%eax),%eax
  1178a2:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  1178a9:	00 
  1178aa:	89 04 24             	mov    %eax,(%esp)
  1178ad:	e8 ce 26 00 00       	call   119f80 <sys_mbox_post>
  return;
  1178b2:	e9 ac 01 00 00       	jmp    117a63 <do_connect+0x2d3>
      }
      udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_NOCHKSUM);
  1178b7:	8b 45 08             	mov    0x8(%ebp),%eax
  1178ba:	8b 00                	mov    (%eax),%eax
  1178bc:	8b 40 08             	mov    0x8(%eax),%eax
  1178bf:	c6 40 10 01          	movb   $0x1,0x10(%eax)
      udp_recv(msg->conn->pcb.udp, recv_udp, msg->conn);
  1178c3:	8b 45 08             	mov    0x8(%ebp),%eax
  1178c6:	8b 10                	mov    (%eax),%edx
  1178c8:	8b 45 08             	mov    0x8(%ebp),%eax
  1178cb:	8b 00                	mov    (%eax),%eax
  1178cd:	8b 40 08             	mov    0x8(%eax),%eax
  1178d0:	89 54 24 08          	mov    %edx,0x8(%esp)
  1178d4:	c7 44 24 04 c0 6b 11 	movl   $0x116bc0,0x4(%esp)
  1178db:	00 
  1178dc:	89 04 24             	mov    %eax,(%esp)
  1178df:	e8 6c de ff ff       	call   115750 <udp_recv>
      break;
  1178e4:	e9 a1 00 00 00       	jmp    11798a <do_connect+0x1fa>
    case NETCONN_UDP:
      msg->conn->pcb.udp = udp_new();
  1178e9:	8b 45 08             	mov    0x8(%ebp),%eax
  1178ec:	8b 18                	mov    (%eax),%ebx
  1178ee:	e8 ed de ff ff       	call   1157e0 <udp_new>
  1178f3:	89 43 08             	mov    %eax,0x8(%ebx)
      if (msg->conn->pcb.udp == NULL) {
  1178f6:	8b 45 08             	mov    0x8(%ebp),%eax
  1178f9:	8b 00                	mov    (%eax),%eax
  1178fb:	8b 40 08             	mov    0x8(%eax),%eax
  1178fe:	85 c0                	test   %eax,%eax
  117900:	75 26                	jne    117928 <do_connect+0x198>
  msg->conn->err = ERR_MEM;
  117902:	8b 45 08             	mov    0x8(%ebp),%eax
  117905:	8b 00                	mov    (%eax),%eax
  117907:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  sys_mbox_post(msg->conn->mbox, NULL);
  11790b:	8b 45 08             	mov    0x8(%ebp),%eax
  11790e:	8b 00                	mov    (%eax),%eax
  117910:	8b 40 10             	mov    0x10(%eax),%eax
  117913:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  11791a:	00 
  11791b:	89 04 24             	mov    %eax,(%esp)
  11791e:	e8 5d 26 00 00       	call   119f80 <sys_mbox_post>
  return;
  117923:	e9 3b 01 00 00       	jmp    117a63 <do_connect+0x2d3>
      }
      udp_recv(msg->conn->pcb.udp, recv_udp, msg->conn);
  117928:	8b 45 08             	mov    0x8(%ebp),%eax
  11792b:	8b 10                	mov    (%eax),%edx
  11792d:	8b 45 08             	mov    0x8(%ebp),%eax
  117930:	8b 00                	mov    (%eax),%eax
  117932:	8b 40 08             	mov    0x8(%eax),%eax
  117935:	89 54 24 08          	mov    %edx,0x8(%esp)
  117939:	c7 44 24 04 c0 6b 11 	movl   $0x116bc0,0x4(%esp)
  117940:	00 
  117941:	89 04 24             	mov    %eax,(%esp)
  117944:	e8 07 de ff ff       	call   115750 <udp_recv>
      break;
  117949:	eb 3f                	jmp    11798a <do_connect+0x1fa>
#endif /* LWIP_UDP */
#if LWIP_TCP      
    case NETCONN_TCP:
      msg->conn->pcb.tcp = tcp_new();      
  11794b:	8b 45 08             	mov    0x8(%ebp),%eax
  11794e:	8b 18                	mov    (%eax),%ebx
  117950:	e8 4b 9b ff ff       	call   1114a0 <tcp_new>
  117955:	89 43 08             	mov    %eax,0x8(%ebx)
      if (msg->conn->pcb.tcp == NULL) {
  117958:	8b 45 08             	mov    0x8(%ebp),%eax
  11795b:	8b 00                	mov    (%eax),%eax
  11795d:	8b 40 08             	mov    0x8(%eax),%eax
  117960:	85 c0                	test   %eax,%eax
  117962:	75 26                	jne    11798a <do_connect+0x1fa>
  msg->conn->err = ERR_MEM;
  117964:	8b 45 08             	mov    0x8(%ebp),%eax
  117967:	8b 00                	mov    (%eax),%eax
  117969:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  sys_mbox_post(msg->conn->mbox, NULL);
  11796d:	8b 45 08             	mov    0x8(%ebp),%eax
  117970:	8b 00                	mov    (%eax),%eax
  117972:	8b 40 10             	mov    0x10(%eax),%eax
  117975:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  11797c:	00 
  11797d:	89 04 24             	mov    %eax,(%esp)
  117980:	e8 fb 25 00 00       	call   119f80 <sys_mbox_post>
  return;
  117985:	e9 d9 00 00 00       	jmp    117a63 <do_connect+0x2d3>
      }
#endif
    default:
      break;
    }
  }
  switch (msg->conn->type) {
  11798a:	8b 45 08             	mov    0x8(%ebp),%eax
  11798d:	8b 00                	mov    (%eax),%eax
  11798f:	8b 00                	mov    (%eax),%eax
  117991:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  117994:	83 7d f8 03          	cmpl   $0x3,0xfffffff8(%ebp)
  117998:	77 0b                	ja     1179a5 <do_connect+0x215>
  11799a:	83 7d f8 01          	cmpl   $0x1,0xfffffff8(%ebp)
  11799e:	73 44                	jae    1179e4 <do_connect+0x254>
  1179a0:	e9 81 00 00 00       	jmp    117a26 <do_connect+0x296>
  1179a5:	83 7d f8 04          	cmpl   $0x4,0xfffffff8(%ebp)
  1179a9:	74 05                	je     1179b0 <do_connect+0x220>
  1179ab:	e9 b3 00 00 00       	jmp    117a63 <do_connect+0x2d3>
#if LWIP_RAW
  case NETCONN_RAW:
    raw_connect(msg->conn->pcb.raw, msg->msg.bc.ipaddr);
  1179b0:	8b 45 08             	mov    0x8(%ebp),%eax
  1179b3:	8b 50 08             	mov    0x8(%eax),%edx
  1179b6:	8b 45 08             	mov    0x8(%ebp),%eax
  1179b9:	8b 00                	mov    (%eax),%eax
  1179bb:	8b 40 08             	mov    0x8(%eax),%eax
  1179be:	89 54 24 04          	mov    %edx,0x4(%esp)
  1179c2:	89 04 24             	mov    %eax,(%esp)
  1179c5:	e8 66 80 ff ff       	call   10fa30 <raw_connect>
    sys_mbox_post(msg->conn->mbox, NULL);
  1179ca:	8b 45 08             	mov    0x8(%ebp),%eax
  1179cd:	8b 00                	mov    (%eax),%eax
  1179cf:	8b 40 10             	mov    0x10(%eax),%eax
  1179d2:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  1179d9:	00 
  1179da:	89 04 24             	mov    %eax,(%esp)
  1179dd:	e8 9e 25 00 00       	call   119f80 <sys_mbox_post>
    break;
  1179e2:	eb 7f                	jmp    117a63 <do_connect+0x2d3>
#endif
#if LWIP_UDP
  case NETCONN_UDPLITE:
    /* FALLTHROUGH */
  case NETCONN_UDPNOCHKSUM:
    /* FALLTHROUGH */
  case NETCONN_UDP:
    udp_connect(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  1179e4:	8b 45 08             	mov    0x8(%ebp),%eax
  1179e7:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  1179eb:	0f b7 c8             	movzwl %ax,%ecx
  1179ee:	8b 45 08             	mov    0x8(%ebp),%eax
  1179f1:	8b 50 08             	mov    0x8(%eax),%edx
  1179f4:	8b 45 08             	mov    0x8(%ebp),%eax
  1179f7:	8b 00                	mov    (%eax),%eax
  1179f9:	8b 40 08             	mov    0x8(%eax),%eax
  1179fc:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  117a00:	89 54 24 04          	mov    %edx,0x4(%esp)
  117a04:	89 04 24             	mov    %eax,(%esp)
  117a07:	e8 34 dc ff ff       	call   115640 <udp_connect>
    sys_mbox_post(msg->conn->mbox, NULL);
  117a0c:	8b 45 08             	mov    0x8(%ebp),%eax
  117a0f:	8b 00                	mov    (%eax),%eax
  117a11:	8b 40 10             	mov    0x10(%eax),%eax
  117a14:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  117a1b:	00 
  117a1c:	89 04 24             	mov    %eax,(%esp)
  117a1f:	e8 5c 25 00 00       	call   119f80 <sys_mbox_post>
    break;
  117a24:	eb 3d                	jmp    117a63 <do_connect+0x2d3>
#endif 
#if LWIP_TCP      
  case NETCONN_TCP:
    /*    tcp_arg(msg->conn->pcb.tcp, msg->conn);*/
    setup_tcp(msg->conn);
  117a26:	8b 45 08             	mov    0x8(%ebp),%eax
  117a29:	8b 00                	mov    (%eax),%eax
  117a2b:	89 04 24             	mov    %eax,(%esp)
  117a2e:	e8 ed f4 ff ff       	call   116f20 <setup_tcp>
    tcp_connect(msg->conn->pcb.tcp, msg->msg.bc.ipaddr, msg->msg.bc.port,
  117a33:	8b 45 08             	mov    0x8(%ebp),%eax
  117a36:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  117a3a:	0f b7 d0             	movzwl %ax,%edx
  117a3d:	8b 45 08             	mov    0x8(%ebp),%eax
  117a40:	8b 48 08             	mov    0x8(%eax),%ecx
  117a43:	8b 45 08             	mov    0x8(%ebp),%eax
  117a46:	8b 00                	mov    (%eax),%eax
  117a48:	8b 40 08             	mov    0x8(%eax),%eax
  117a4b:	c7 44 24 0c 20 77 11 	movl   $0x117720,0xc(%esp)
  117a52:	00 
  117a53:	89 54 24 08          	mov    %edx,0x8(%esp)
  117a57:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  117a5b:	89 04 24             	mov    %eax,(%esp)
  117a5e:	e8 0d 90 ff ff       	call   110a70 <tcp_connect>
    do_connected);
    /*tcp_output(msg->conn->pcb.tcp);*/
#endif

  default:
    break;
  }
}
  117a63:	83 c4 24             	add    $0x24,%esp
  117a66:	5b                   	pop    %ebx
  117a67:	5d                   	pop    %ebp
  117a68:	c3                   	ret    
  117a69:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

00117a70 <do_disconnect>:

static void
do_disconnect(struct api_msg_msg *msg)
{
  117a70:	55                   	push   %ebp
  117a71:	89 e5                	mov    %esp,%ebp
  117a73:	83 ec 18             	sub    $0x18,%esp

  switch (msg->conn->type) {
  117a76:	8b 45 08             	mov    0x8(%ebp),%eax
  117a79:	8b 00                	mov    (%eax),%eax
  117a7b:	8b 00                	mov    (%eax),%eax
  117a7d:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  117a80:	83 7d fc 01          	cmpl   $0x1,0xfffffffc(%ebp)
  117a84:	72 18                	jb     117a9e <do_disconnect+0x2e>
  117a86:	83 7d fc 03          	cmpl   $0x3,0xfffffffc(%ebp)
  117a8a:	76 02                	jbe    117a8e <do_disconnect+0x1e>
  117a8c:	eb 10                	jmp    117a9e <do_disconnect+0x2e>
#if LWIP_RAW
  case NETCONN_RAW:
    /* Do nothing as connecting is only a helper for upper lwip layers */
    break;
#endif
#if LWIP_UDP
  case NETCONN_UDPLITE:
    /* FALLTHROUGH */
  case NETCONN_UDPNOCHKSUM:
    /* FALLTHROUGH */
  case NETCONN_UDP:
    udp_disconnect(msg->conn->pcb.udp);
  117a8e:	8b 45 08             	mov    0x8(%ebp),%eax
  117a91:	8b 00                	mov    (%eax),%eax
  117a93:	8b 40 08             	mov    0x8(%eax),%eax
  117a96:	89 04 24             	mov    %eax,(%esp)
  117a99:	e8 82 dc ff ff       	call   115720 <udp_disconnect>
    break;
#endif 
  case NETCONN_TCP:
    break;
  }
  sys_mbox_post(msg->conn->mbox, NULL);
  117a9e:	8b 45 08             	mov    0x8(%ebp),%eax
  117aa1:	8b 00                	mov    (%eax),%eax
  117aa3:	8b 40 10             	mov    0x10(%eax),%eax
  117aa6:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  117aad:	00 
  117aae:	89 04 24             	mov    %eax,(%esp)
  117ab1:	e8 ca 24 00 00       	call   119f80 <sys_mbox_post>
}
  117ab6:	c9                   	leave  
  117ab7:	c3                   	ret    
  117ab8:	90                   	nop    
  117ab9:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

00117ac0 <do_listen>:


static void
do_listen(struct api_msg_msg *msg)
{
  117ac0:	55                   	push   %ebp
  117ac1:	89 e5                	mov    %esp,%ebp
  117ac3:	53                   	push   %ebx
  117ac4:	83 ec 14             	sub    $0x14,%esp
  if (msg->conn->pcb.tcp != NULL) {
  117ac7:	8b 45 08             	mov    0x8(%ebp),%eax
  117aca:	8b 00                	mov    (%eax),%eax
  117acc:	8b 40 08             	mov    0x8(%eax),%eax
  117acf:	85 c0                	test   %eax,%eax
  117ad1:	0f 84 b1 00 00 00    	je     117b88 <do_listen+0xc8>
    switch (msg->conn->type) {
  117ad7:	8b 45 08             	mov    0x8(%ebp),%eax
  117ada:	8b 00                	mov    (%eax),%eax
  117adc:	8b 00                	mov    (%eax),%eax
  117ade:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  117ae1:	83 7d f8 03          	cmpl   $0x3,0xfffffff8(%ebp)
  117ae5:	77 0c                	ja     117af3 <do_listen+0x33>
  117ae7:	83 7d f8 01          	cmpl   $0x1,0xfffffff8(%ebp)
  117aeb:	0f 83 97 00 00 00    	jae    117b88 <do_listen+0xc8>
  117af1:	eb 05                	jmp    117af8 <do_listen+0x38>
  117af3:	e9 90 00 00 00       	jmp    117b88 <do_listen+0xc8>
#if LWIP_RAW
    case NETCONN_RAW:
      LWIP_DEBUGF(API_MSG_DEBUG, ("api_msg: listen RAW: cannot listen for RAW.\n"));
      break;
#endif
#if LWIP_UDP
    case NETCONN_UDPLITE:
      /* FALLTHROUGH */
    case NETCONN_UDPNOCHKSUM:
      /* FALLTHROUGH */
    case NETCONN_UDP:
      LWIP_DEBUGF(API_MSG_DEBUG, ("api_msg: listen UDP: cannot listen for UDP.\n"));
      break;
#endif /* LWIP_UDP */
#if LWIP_TCP      
    case NETCONN_TCP:
      msg->conn->pcb.tcp = tcp_listen(msg->conn->pcb.tcp);
  117af8:	8b 45 08             	mov    0x8(%ebp),%eax
  117afb:	8b 18                	mov    (%eax),%ebx
  117afd:	8b 45 08             	mov    0x8(%ebp),%eax
  117b00:	8b 00                	mov    (%eax),%eax
  117b02:	8b 40 08             	mov    0x8(%eax),%eax
  117b05:	89 04 24             	mov    %eax,(%esp)
  117b08:	e8 e3 8c ff ff       	call   1107f0 <tcp_listen>
  117b0d:	89 43 08             	mov    %eax,0x8(%ebx)
      if (msg->conn->pcb.tcp == NULL) {
  117b10:	8b 45 08             	mov    0x8(%ebp),%eax
  117b13:	8b 00                	mov    (%eax),%eax
  117b15:	8b 40 08             	mov    0x8(%eax),%eax
  117b18:	85 c0                	test   %eax,%eax
  117b1a:	75 0b                	jne    117b27 <do_listen+0x67>
  msg->conn->err = ERR_MEM;
  117b1c:	8b 45 08             	mov    0x8(%ebp),%eax
  117b1f:	8b 00                	mov    (%eax),%eax
  117b21:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  117b25:	eb 61                	jmp    117b88 <do_listen+0xc8>
      } else {
  if (msg->conn->acceptmbox == SYS_MBOX_NULL) {
  117b27:	8b 45 08             	mov    0x8(%ebp),%eax
  117b2a:	8b 00                	mov    (%eax),%eax
  117b2c:	8b 40 18             	mov    0x18(%eax),%eax
  117b2f:	85 c0                	test   %eax,%eax
  117b31:	75 24                	jne    117b57 <do_listen+0x97>
    msg->conn->acceptmbox = sys_mbox_new();
  117b33:	8b 45 08             	mov    0x8(%ebp),%eax
  117b36:	8b 18                	mov    (%eax),%ebx
  117b38:	e8 13 23 00 00       	call   119e50 <sys_mbox_new>
  117b3d:	89 43 18             	mov    %eax,0x18(%ebx)
    if (msg->conn->acceptmbox == SYS_MBOX_NULL) {
  117b40:	8b 45 08             	mov    0x8(%ebp),%eax
  117b43:	8b 00                	mov    (%eax),%eax
  117b45:	8b 40 18             	mov    0x18(%eax),%eax
  117b48:	85 c0                	test   %eax,%eax
  117b4a:	75 0b                	jne    117b57 <do_listen+0x97>
      msg->conn->err = ERR_MEM;
  117b4c:	8b 45 08             	mov    0x8(%ebp),%eax
  117b4f:	8b 00                	mov    (%eax),%eax
  117b51:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
      break;
  117b55:	eb 31                	jmp    117b88 <do_listen+0xc8>
    }
  }
  tcp_arg(msg->conn->pcb.tcp, msg->conn);
  117b57:	8b 45 08             	mov    0x8(%ebp),%eax
  117b5a:	8b 10                	mov    (%eax),%edx
  117b5c:	8b 45 08             	mov    0x8(%ebp),%eax
  117b5f:	8b 00                	mov    (%eax),%eax
  117b61:	8b 40 08             	mov    0x8(%eax),%eax
  117b64:	89 54 24 04          	mov    %edx,0x4(%esp)
  117b68:	89 04 24             	mov    %eax,(%esp)
  117b6b:	e8 50 99 ff ff       	call   1114c0 <tcp_arg>
  tcp_accept(msg->conn->pcb.tcp, accept_function);
  117b70:	8b 45 08             	mov    0x8(%ebp),%eax
  117b73:	8b 00                	mov    (%eax),%eax
  117b75:	8b 40 08             	mov    0x8(%eax),%eax
  117b78:	c7 44 24 04 a0 6f 11 	movl   $0x116fa0,0x4(%esp)
  117b7f:	00 
  117b80:	89 04 24             	mov    %eax,(%esp)
  117b83:	e8 98 99 ff ff       	call   111520 <tcp_accept>
      }
#endif
    default:
      break;
    }
  }
  sys_mbox_post(msg->conn->mbox, NULL);
  117b88:	8b 45 08             	mov    0x8(%ebp),%eax
  117b8b:	8b 00                	mov    (%eax),%eax
  117b8d:	8b 40 10             	mov    0x10(%eax),%eax
  117b90:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  117b97:	00 
  117b98:	89 04 24             	mov    %eax,(%esp)
  117b9b:	e8 e0 23 00 00       	call   119f80 <sys_mbox_post>
}
  117ba0:	83 c4 14             	add    $0x14,%esp
  117ba3:	5b                   	pop    %ebx
  117ba4:	5d                   	pop    %ebp
  117ba5:	c3                   	ret    
  117ba6:	8d 76 00             	lea    0x0(%esi),%esi
  117ba9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00117bb0 <do_accept>:

static void
do_accept(struct api_msg_msg *msg)
{
  117bb0:	55                   	push   %ebp
  117bb1:	89 e5                	mov    %esp,%ebp
  117bb3:	83 ec 04             	sub    $0x4,%esp
  if (msg->conn->pcb.tcp != NULL) {
  117bb6:	8b 45 08             	mov    0x8(%ebp),%eax
  117bb9:	8b 00                	mov    (%eax),%eax
  117bbb:	8b 40 08             	mov    0x8(%eax),%eax
  117bbe:	85 c0                	test   %eax,%eax
  117bc0:	74 16                	je     117bd8 <do_accept+0x28>
    switch (msg->conn->type) {
  117bc2:	8b 45 08             	mov    0x8(%ebp),%eax
  117bc5:	8b 00                	mov    (%eax),%eax
  117bc7:	8b 00                	mov    (%eax),%eax
  117bc9:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  117bcc:	83 7d fc 01          	cmpl   $0x1,0xfffffffc(%ebp)
  117bd0:	72 06                	jb     117bd8 <do_accept+0x28>
  117bd2:	83 7d fc 03          	cmpl   $0x3,0xfffffffc(%ebp)
  117bd6:	76 00                	jbe    117bd8 <do_accept+0x28>
#if LWIP_RAW
    case NETCONN_RAW:
      LWIP_DEBUGF(API_MSG_DEBUG, ("api_msg: accept RAW: cannot accept for RAW.\n"));
      break;
#endif
#if LWIP_UDP
    case NETCONN_UDPLITE:
      /* FALLTHROUGH */
    case NETCONN_UDPNOCHKSUM:
      /* FALLTHROUGH */
    case NETCONN_UDP:    
      LWIP_DEBUGF(API_MSG_DEBUG, ("api_msg: accept UDP: cannot accept for UDP.\n"));
      break;
#endif /* LWIP_UDP */
    case NETCONN_TCP:
      break;
    }
  }
}
  117bd8:	c9                   	leave  
  117bd9:	c3                   	ret    
  117bda:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

00117be0 <do_send>:

static void
do_send(struct api_msg_msg *msg)
{
  117be0:	55                   	push   %ebp
  117be1:	89 e5                	mov    %esp,%ebp
  117be3:	83 ec 18             	sub    $0x18,%esp
  if (msg->conn->pcb.tcp != NULL) {
  117be6:	8b 45 08             	mov    0x8(%ebp),%eax
  117be9:	8b 00                	mov    (%eax),%eax
  117beb:	8b 40 08             	mov    0x8(%eax),%eax
  117bee:	85 c0                	test   %eax,%eax
  117bf0:	74 54                	je     117c46 <do_send+0x66>
    switch (msg->conn->type) {
  117bf2:	8b 45 08             	mov    0x8(%ebp),%eax
  117bf5:	8b 00                	mov    (%eax),%eax
  117bf7:	8b 00                	mov    (%eax),%eax
  117bf9:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  117bfc:	83 7d fc 01          	cmpl   $0x1,0xfffffffc(%ebp)
  117c00:	72 44                	jb     117c46 <do_send+0x66>
  117c02:	83 7d fc 03          	cmpl   $0x3,0xfffffffc(%ebp)
  117c06:	76 24                	jbe    117c2c <do_send+0x4c>
  117c08:	83 7d fc 04          	cmpl   $0x4,0xfffffffc(%ebp)
  117c0c:	74 02                	je     117c10 <do_send+0x30>
  117c0e:	eb 36                	jmp    117c46 <do_send+0x66>
#if LWIP_RAW
    case NETCONN_RAW:
      raw_send(msg->conn->pcb.raw, msg->msg.p);
  117c10:	8b 45 08             	mov    0x8(%ebp),%eax
  117c13:	8b 50 08             	mov    0x8(%eax),%edx
  117c16:	8b 45 08             	mov    0x8(%ebp),%eax
  117c19:	8b 00                	mov    (%eax),%eax
  117c1b:	8b 40 08             	mov    0x8(%eax),%eax
  117c1e:	89 54 24 04          	mov    %edx,0x4(%esp)
  117c22:	89 04 24             	mov    %eax,(%esp)
  117c25:	e8 96 7f ff ff       	call   10fbc0 <raw_send>
      break;
  117c2a:	eb 1a                	jmp    117c46 <do_send+0x66>
#endif
#if LWIP_UDP
    case NETCONN_UDPLITE:
      /* FALLTHROUGH */
    case NETCONN_UDPNOCHKSUM:
      /* FALLTHROUGH */
    case NETCONN_UDP:
      udp_send(msg->conn->pcb.udp, msg->msg.p);
  117c2c:	8b 45 08             	mov    0x8(%ebp),%eax
  117c2f:	8b 50 08             	mov    0x8(%eax),%edx
  117c32:	8b 45 08             	mov    0x8(%ebp),%eax
  117c35:	8b 00                	mov    (%eax),%eax
  117c37:	8b 40 08             	mov    0x8(%eax),%eax
  117c3a:	89 54 24 04          	mov    %edx,0x4(%esp)
  117c3e:	89 04 24             	mov    %eax,(%esp)
  117c41:	e8 fa d4 ff ff       	call   115140 <udp_send>
      break;
#endif /* LWIP_UDP */
    case NETCONN_TCP:
      break;
    }
  }
  sys_mbox_post(msg->conn->mbox, NULL);
  117c46:	8b 45 08             	mov    0x8(%ebp),%eax
  117c49:	8b 00                	mov    (%eax),%eax
  117c4b:	8b 40 10             	mov    0x10(%eax),%eax
  117c4e:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  117c55:	00 
  117c56:	89 04 24             	mov    %eax,(%esp)
  117c59:	e8 22 23 00 00       	call   119f80 <sys_mbox_post>
}
  117c5e:	c9                   	leave  
  117c5f:	c3                   	ret    

00117c60 <do_recv>:

static void
do_recv(struct api_msg_msg *msg)
{
  117c60:	55                   	push   %ebp
  117c61:	89 e5                	mov    %esp,%ebp
  117c63:	83 ec 08             	sub    $0x8,%esp
#if LWIP_TCP
  if (msg->conn->pcb.tcp != NULL) {
  117c66:	8b 45 08             	mov    0x8(%ebp),%eax
  117c69:	8b 00                	mov    (%eax),%eax
  117c6b:	8b 40 08             	mov    0x8(%eax),%eax
  117c6e:	85 c0                	test   %eax,%eax
  117c70:	74 29                	je     117c9b <do_recv+0x3b>
    if (msg->conn->type == NETCONN_TCP) {
  117c72:	8b 45 08             	mov    0x8(%ebp),%eax
  117c75:	8b 00                	mov    (%eax),%eax
  117c77:	8b 00                	mov    (%eax),%eax
  117c79:	85 c0                	test   %eax,%eax
  117c7b:	75 1e                	jne    117c9b <do_recv+0x3b>
      tcp_recved(msg->conn->pcb.tcp, msg->msg.len);
  117c7d:	8b 45 08             	mov    0x8(%ebp),%eax
  117c80:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  117c84:	0f b7 d0             	movzwl %ax,%edx
  117c87:	8b 45 08             	mov    0x8(%ebp),%eax
  117c8a:	8b 00                	mov    (%eax),%eax
  117c8c:	8b 40 08             	mov    0x8(%eax),%eax
  117c8f:	89 54 24 04          	mov    %edx,0x4(%esp)
  117c93:	89 04 24             	mov    %eax,(%esp)
  117c96:	e8 55 8c ff ff       	call   1108f0 <tcp_recved>
    }
  }
#endif  
  sys_mbox_post(msg->conn->mbox, NULL);
  117c9b:	8b 45 08             	mov    0x8(%ebp),%eax
  117c9e:	8b 00                	mov    (%eax),%eax
  117ca0:	8b 40 10             	mov    0x10(%eax),%eax
  117ca3:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  117caa:	00 
  117cab:	89 04 24             	mov    %eax,(%esp)
  117cae:	e8 cd 22 00 00       	call   119f80 <sys_mbox_post>
}
  117cb3:	c9                   	leave  
  117cb4:	c3                   	ret    
  117cb5:	8d 74 26 00          	lea    0x0(%esi),%esi
  117cb9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00117cc0 <do_write>:

static void
do_write(struct api_msg_msg *msg)
{
  117cc0:	55                   	push   %ebp
  117cc1:	89 e5                	mov    %esp,%ebp
  117cc3:	53                   	push   %ebx
  117cc4:	83 ec 24             	sub    $0x24,%esp
#if LWIP_TCP  
  err_t err;
#endif  
  if (msg->conn->pcb.tcp != NULL) {
  117cc7:	8b 45 08             	mov    0x8(%ebp),%eax
  117cca:	8b 00                	mov    (%eax),%eax
  117ccc:	8b 40 08             	mov    0x8(%eax),%eax
  117ccf:	85 c0                	test   %eax,%eax
  117cd1:	0f 84 0b 01 00 00    	je     117de2 <do_write+0x122>
    switch (msg->conn->type) {
  117cd7:	8b 45 08             	mov    0x8(%ebp),%eax
  117cda:	8b 00                	mov    (%eax),%eax
  117cdc:	8b 00                	mov    (%eax),%eax
  117cde:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
  117ce1:	83 7d e8 03          	cmpl   $0x3,0xffffffe8(%ebp)
  117ce5:	77 08                	ja     117cef <do_write+0x2f>
  117ce7:	83 7d e8 01          	cmpl   $0x1,0xffffffe8(%ebp)
  117ceb:	73 1b                	jae    117d08 <do_write+0x48>
  117ced:	eb 27                	jmp    117d16 <do_write+0x56>
  117cef:	83 7d e8 04          	cmpl   $0x4,0xffffffe8(%ebp)
  117cf3:	74 05                	je     117cfa <do_write+0x3a>
  117cf5:	e9 e8 00 00 00       	jmp    117de2 <do_write+0x122>
#if LWIP_RAW
    case NETCONN_RAW:
      msg->conn->err = ERR_VAL;
  117cfa:	8b 45 08             	mov    0x8(%ebp),%eax
  117cfd:	8b 00                	mov    (%eax),%eax
  117cff:	c6 40 0c f9          	movb   $0xf9,0xc(%eax)
      break;
  117d03:	e9 da 00 00 00       	jmp    117de2 <do_write+0x122>
#endif
#if LWIP_UDP 
    case NETCONN_UDPLITE:
      /* FALLTHROUGH */
    case NETCONN_UDPNOCHKSUM:
      /* FALLTHROUGH */
    case NETCONN_UDP:
      msg->conn->err = ERR_VAL;
  117d08:	8b 45 08             	mov    0x8(%ebp),%eax
  117d0b:	8b 00                	mov    (%eax),%eax
  117d0d:	c6 40 0c f9          	movb   $0xf9,0xc(%eax)
      break;
  117d11:	e9 cc 00 00 00       	jmp    117de2 <do_write+0x122>
#endif /* LWIP_UDP */
#if LWIP_TCP 
    case NETCONN_TCP:      
      err = tcp_write(msg->conn->pcb.tcp, msg->msg.w.dataptr,
  117d16:	8b 45 08             	mov    0x8(%ebp),%eax
  117d19:	0f b6 40 0e          	movzbl 0xe(%eax),%eax
  117d1d:	0f b6 d0             	movzbl %al,%edx
  117d20:	8b 45 08             	mov    0x8(%ebp),%eax
  117d23:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  117d27:	0f b7 c8             	movzwl %ax,%ecx
  117d2a:	8b 45 08             	mov    0x8(%ebp),%eax
  117d2d:	8b 58 08             	mov    0x8(%eax),%ebx
  117d30:	8b 45 08             	mov    0x8(%ebp),%eax
  117d33:	8b 00                	mov    (%eax),%eax
  117d35:	8b 40 08             	mov    0x8(%eax),%eax
  117d38:	89 54 24 0c          	mov    %edx,0xc(%esp)
  117d3c:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  117d40:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  117d44:	89 04 24             	mov    %eax,(%esp)
  117d47:	e8 d4 99 ff ff       	call   111720 <tcp_write>
  117d4c:	88 45 fb             	mov    %al,0xfffffffb(%ebp)
                      msg->msg.w.len, msg->msg.w.copy);
      /* This is the Nagle algorithm: inhibit the sending of new TCP
   segments when new outgoing data arrives from the user if any
   previously transmitted data on the connection remains
   unacknowledged. */
      if(err == ERR_OK && (msg->conn->pcb.tcp->unacked == NULL || (msg->conn->pcb.tcp->flags & TF_NODELAY)) ) {
  117d4f:	80 7d fb 00          	cmpb   $0x0,0xfffffffb(%ebp)
  117d53:	75 35                	jne    117d8a <do_write+0xca>
  117d55:	8b 45 08             	mov    0x8(%ebp),%eax
  117d58:	8b 00                	mov    (%eax),%eax
  117d5a:	8b 40 08             	mov    0x8(%eax),%eax
  117d5d:	8b 40 74             	mov    0x74(%eax),%eax
  117d60:	85 c0                	test   %eax,%eax
  117d62:	74 16                	je     117d7a <do_write+0xba>
  117d64:	8b 45 08             	mov    0x8(%ebp),%eax
  117d67:	8b 00                	mov    (%eax),%eax
  117d69:	8b 40 08             	mov    0x8(%eax),%eax
  117d6c:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  117d70:	0f b6 c0             	movzbl %al,%eax
  117d73:	83 e0 40             	and    $0x40,%eax
  117d76:	85 c0                	test   %eax,%eax
  117d78:	74 10                	je     117d8a <do_write+0xca>
  tcp_output(msg->conn->pcb.tcp);
  117d7a:	8b 45 08             	mov    0x8(%ebp),%eax
  117d7d:	8b 00                	mov    (%eax),%eax
  117d7f:	8b 40 08             	mov    0x8(%eax),%eax
  117d82:	89 04 24             	mov    %eax,(%esp)
  117d85:	e8 b6 a0 ff ff       	call   111e40 <tcp_output>
      }
      msg->conn->err = err;
  117d8a:	8b 45 08             	mov    0x8(%ebp),%eax
  117d8d:	8b 10                	mov    (%eax),%edx
  117d8f:	0f b6 45 fb          	movzbl 0xfffffffb(%ebp),%eax
  117d93:	88 42 0c             	mov    %al,0xc(%edx)
      if (msg->conn->callback)
  117d96:	8b 45 08             	mov    0x8(%ebp),%eax
  117d99:	8b 00                	mov    (%eax),%eax
  117d9b:	8b 40 28             	mov    0x28(%eax),%eax
  117d9e:	85 c0                	test   %eax,%eax
  117da0:	74 40                	je     117de2 <do_write+0x122>
          if (err == ERR_OK)
  117da2:	80 7d fb 00          	cmpb   $0x0,0xfffffffb(%ebp)
  117da6:	75 3a                	jne    117de2 <do_write+0x122>
          {
              if (tcp_sndbuf(msg->conn->pcb.tcp) <= TCP_SNDLOWAT)
  117da8:	8b 45 08             	mov    0x8(%ebp),%eax
  117dab:	8b 00                	mov    (%eax),%eax
  117dad:	8b 40 08             	mov    0x8(%eax),%eax
  117db0:	0f b7 40 6a          	movzwl 0x6a(%eax),%eax
  117db4:	66 3d 00 04          	cmp    $0x400,%ax
  117db8:	77 28                	ja     117de2 <do_write+0x122>
                  (*msg->conn->callback)(msg->conn, NETCONN_EVT_SENDMINUS, msg->msg.w.len);
  117dba:	8b 45 08             	mov    0x8(%ebp),%eax
  117dbd:	8b 00                	mov    (%eax),%eax
  117dbf:	8b 48 28             	mov    0x28(%eax),%ecx
  117dc2:	8b 45 08             	mov    0x8(%ebp),%eax
  117dc5:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  117dc9:	0f b7 d0             	movzwl %ax,%edx
  117dcc:	8b 45 08             	mov    0x8(%ebp),%eax
  117dcf:	8b 00                	mov    (%eax),%eax
  117dd1:	89 54 24 08          	mov    %edx,0x8(%esp)
  117dd5:	c7 44 24 04 03 00 00 	movl   $0x3,0x4(%esp)
  117ddc:	00 
  117ddd:	89 04 24             	mov    %eax,(%esp)
  117de0:	ff d1                	call   *%ecx
          }
#endif
    default:
      break;
    }
  }
  sys_mbox_post(msg->conn->mbox, NULL);
  117de2:	8b 45 08             	mov    0x8(%ebp),%eax
  117de5:	8b 00                	mov    (%eax),%eax
  117de7:	8b 40 10             	mov    0x10(%eax),%eax
  117dea:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  117df1:	00 
  117df2:	89 04 24             	mov    %eax,(%esp)
  117df5:	e8 86 21 00 00       	call   119f80 <sys_mbox_post>
}
  117dfa:	83 c4 24             	add    $0x24,%esp
  117dfd:	5b                   	pop    %ebx
  117dfe:	5d                   	pop    %ebp
  117dff:	c3                   	ret    

00117e00 <do_close>:

static void
do_close(struct api_msg_msg *msg)
{
  117e00:	55                   	push   %ebp
  117e01:	89 e5                	mov    %esp,%ebp
  117e03:	83 ec 28             	sub    $0x28,%esp
  err_t err;

  err = ERR_OK;
  117e06:	c6 45 ff 00          	movb   $0x0,0xffffffff(%ebp)

  if (msg->conn->pcb.tcp != NULL) {
  117e0a:	8b 45 08             	mov    0x8(%ebp),%eax
  117e0d:	8b 00                	mov    (%eax),%eax
  117e0f:	8b 40 08             	mov    0x8(%eax),%eax
  117e12:	85 c0                	test   %eax,%eax
  117e14:	74 49                	je     117e5f <do_close+0x5f>
    switch (msg->conn->type) {
  117e16:	8b 45 08             	mov    0x8(%ebp),%eax
  117e19:	8b 00                	mov    (%eax),%eax
  117e1b:	8b 00                	mov    (%eax),%eax
  117e1d:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  117e20:	83 7d ec 03          	cmpl   $0x3,0xffffffec(%ebp)
  117e24:	77 08                	ja     117e2e <do_close+0x2e>
  117e26:	83 7d ec 01          	cmpl   $0x1,0xffffffec(%ebp)
  117e2a:	73 33                	jae    117e5f <do_close+0x5f>
  117e2c:	eb 02                	jmp    117e30 <do_close+0x30>
  117e2e:	eb 2f                	jmp    117e5f <do_close+0x5f>
#if LWIP_RAW
    case NETCONN_RAW:
      break;
#endif
#if LWIP_UDP
    case NETCONN_UDPLITE:
      /* FALLTHROUGH */
    case NETCONN_UDPNOCHKSUM:
      /* FALLTHROUGH */
    case NETCONN_UDP:
      break;
#endif /* LWIP_UDP */
#if LWIP_TCP
    case NETCONN_TCP:
      if (msg->conn->pcb.tcp->state == LISTEN) {
  117e30:	8b 45 08             	mov    0x8(%ebp),%eax
  117e33:	8b 00                	mov    (%eax),%eax
  117e35:	8b 40 08             	mov    0x8(%eax),%eax
  117e38:	8b 40 10             	mov    0x10(%eax),%eax
  117e3b:	83 f8 01             	cmp    $0x1,%eax
  117e3e:	75 13                	jne    117e53 <do_close+0x53>
  err = tcp_close(msg->conn->pcb.tcp);
  117e40:	8b 45 08             	mov    0x8(%ebp),%eax
  117e43:	8b 00                	mov    (%eax),%eax
  117e45:	8b 40 08             	mov    0x8(%eax),%eax
  117e48:	89 04 24             	mov    %eax,(%esp)
  117e4b:	e8 e0 83 ff ff       	call   110230 <tcp_close>
  117e50:	88 45 ff             	mov    %al,0xffffffff(%ebp)
      }
      msg->conn->err = err;      
  117e53:	8b 45 08             	mov    0x8(%ebp),%eax
  117e56:	8b 10                	mov    (%eax),%edx
  117e58:	0f b6 45 ff          	movzbl 0xffffffff(%ebp),%eax
  117e5c:	88 42 0c             	mov    %al,0xc(%edx)
#endif
    default:      
      break;
    }
  }
  sys_mbox_post(msg->conn->mbox, NULL);
  117e5f:	8b 45 08             	mov    0x8(%ebp),%eax
  117e62:	8b 00                	mov    (%eax),%eax
  117e64:	8b 40 10             	mov    0x10(%eax),%eax
  117e67:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  117e6e:	00 
  117e6f:	89 04 24             	mov    %eax,(%esp)
  117e72:	e8 09 21 00 00       	call   119f80 <sys_mbox_post>
}
  117e77:	c9                   	leave  
  117e78:	c3                   	ret    
  117e79:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

00117e80 <api_msg_input>:

typedef void (* api_msg_decode)(struct api_msg_msg *msg);
static api_msg_decode decode[API_MSG_MAX] = {
  do_newconn,
  do_delconn,
  do_bind,
  do_connect,
  do_disconnect,
  do_listen,
  do_accept,
  do_send,
  do_recv,
  do_write,
  do_close
  };
void
api_msg_input(struct api_msg *msg)
{  
  117e80:	55                   	push   %ebp
  117e81:	89 e5                	mov    %esp,%ebp
  117e83:	83 ec 08             	sub    $0x8,%esp
  decode[msg->type](&(msg->msg));
  117e86:	8b 45 08             	mov    0x8(%ebp),%eax
  117e89:	8b 00                	mov    (%eax),%eax
  117e8b:	8b 14 85 c0 cb 11 00 	mov    0x11cbc0(,%eax,4),%edx
  117e92:	8b 45 08             	mov    0x8(%ebp),%eax
  117e95:	83 c0 04             	add    $0x4,%eax
  117e98:	89 04 24             	mov    %eax,(%esp)
  117e9b:	ff d2                	call   *%edx
}
  117e9d:	c9                   	leave  
  117e9e:	c3                   	ret    
  117e9f:	90                   	nop    

00117ea0 <api_msg_post>:

void
api_msg_post(struct api_msg *msg)
{
  117ea0:	55                   	push   %ebp
  117ea1:	89 e5                	mov    %esp,%ebp
  117ea3:	83 ec 08             	sub    $0x8,%esp
  tcpip_apimsg(msg);
  117ea6:	8b 45 08             	mov    0x8(%ebp),%eax
  117ea9:	89 04 24             	mov    %eax,(%esp)
  117eac:	e8 ef 1d 00 00       	call   119ca0 <tcpip_apimsg>
}
  117eb1:	c9                   	leave  
  117eb2:	c3                   	ret    
  117eb3:	90                   	nop    
  117eb4:	90                   	nop    
  117eb5:	90                   	nop    
  117eb6:	90                   	nop    
  117eb7:	90                   	nop    
  117eb8:	90                   	nop    
  117eb9:	90                   	nop    
  117eba:	90                   	nop    
  117ebb:	90                   	nop    
  117ebc:	90                   	nop    
  117ebd:	90                   	nop    
  117ebe:	90                   	nop    
  117ebf:	90                   	nop    

00117ec0 <lwip_strerr>:


char *
lwip_strerr(err_t err)
{
  117ec0:	55                   	push   %ebp
  117ec1:	89 e5                	mov    %esp,%ebp
  117ec3:	83 ec 04             	sub    $0x4,%esp
  117ec6:	8b 45 08             	mov    0x8(%ebp),%eax
  117ec9:	88 45 fc             	mov    %al,0xfffffffc(%ebp)
  return err_strerr[-err];
  117ecc:	0f be 45 fc          	movsbl 0xfffffffc(%ebp),%eax
  117ed0:	f7 d8                	neg    %eax
  117ed2:	8b 04 85 00 cc 11 00 	mov    0x11cc00(,%eax,4),%eax

}
  117ed9:	c9                   	leave  
  117eda:	c3                   	ret    
  117edb:	90                   	nop    
  117edc:	90                   	nop    
  117edd:	90                   	nop    
  117ede:	90                   	nop    
  117edf:	90                   	nop    

00117ee0 <get_socket>:


static struct lwip_socket *
get_socket(int s)
{
  117ee0:	55                   	push   %ebp
  117ee1:	89 e5                	mov    %esp,%ebp
  117ee3:	83 ec 14             	sub    $0x14,%esp
  struct lwip_socket *sock;

  if ((s < 0) || (s > NUM_SOCKETS)) {
  117ee6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  117eea:	78 06                	js     117ef2 <get_socket+0x12>
  117eec:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
  117ef0:	7e 09                	jle    117efb <get_socket+0x1b>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("get_socket(%d): invalid\n", s));
    set_errno(EBADF);
    return NULL;
  117ef2:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  117ef9:	eb 2d                	jmp    117f28 <get_socket+0x48>
  }

  sock = &sockets[s];
  117efb:	8b 55 08             	mov    0x8(%ebp),%edx
  117efe:	89 d0                	mov    %edx,%eax
  117f00:	c1 e0 02             	shl    $0x2,%eax
  117f03:	01 d0                	add    %edx,%eax
  117f05:	c1 e0 02             	shl    $0x2,%eax
  117f08:	05 60 99 13 00       	add    $0x139960,%eax
  117f0d:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)

  if (!sock->conn) {
  117f10:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  117f13:	8b 00                	mov    (%eax),%eax
  117f15:	85 c0                	test   %eax,%eax
  117f17:	75 09                	jne    117f22 <get_socket+0x42>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("get_socket(%d): not active\n", s));
    set_errno(EBADF);
    return NULL;
  117f19:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  117f20:	eb 06                	jmp    117f28 <get_socket+0x48>
  }

  return sock;
  117f22:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  117f25:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  117f28:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  117f2b:	c9                   	leave  
  117f2c:	c3                   	ret    
  117f2d:	8d 76 00             	lea    0x0(%esi),%esi

00117f30 <alloc_socket>:

static int
alloc_socket(struct netconn *newconn)
{
  117f30:	55                   	push   %ebp
  117f31:	89 e5                	mov    %esp,%ebp
  117f33:	83 ec 18             	sub    $0x18,%esp
  int i;

  if (!socksem)
  117f36:	a1 44 99 13 00       	mov    0x139944,%eax
  117f3b:	85 c0                	test   %eax,%eax
  117f3d:	75 11                	jne    117f50 <alloc_socket+0x20>
      socksem = sys_sem_new(1);
  117f3f:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  117f46:	e8 f5 1d 00 00       	call   119d40 <sys_sem_new>
  117f4b:	a3 44 99 13 00       	mov    %eax,0x139944

  /* Protect socket array */
  sys_sem_wait(socksem);
  117f50:	a1 44 99 13 00       	mov    0x139944,%eax
  117f55:	89 04 24             	mov    %eax,(%esp)
  117f58:	e8 a3 7e ff ff       	call   10fe00 <sys_sem_wait>

  /* allocate a new socket identifier */
  for(i = 0; i < NUM_SOCKETS; ++i) {
  117f5d:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
  117f64:	e9 d4 00 00 00       	jmp    11803d <alloc_socket+0x10d>
    if (!sockets[i].conn) {
  117f69:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  117f6c:	89 d0                	mov    %edx,%eax
  117f6e:	c1 e0 02             	shl    $0x2,%eax
  117f71:	01 d0                	add    %edx,%eax
  117f73:	c1 e0 02             	shl    $0x2,%eax
  117f76:	8b 80 60 99 13 00    	mov    0x139960(%eax),%eax
  117f7c:	85 c0                	test   %eax,%eax
  117f7e:	0f 85 b5 00 00 00    	jne    118039 <alloc_socket+0x109>
      sockets[i].conn = newconn;
  117f84:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  117f87:	89 d0                	mov    %edx,%eax
  117f89:	c1 e0 02             	shl    $0x2,%eax
  117f8c:	01 d0                	add    %edx,%eax
  117f8e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  117f95:	8b 45 08             	mov    0x8(%ebp),%eax
  117f98:	89 82 60 99 13 00    	mov    %eax,0x139960(%edx)
      sockets[i].lastdata = NULL;
  117f9e:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  117fa1:	89 d0                	mov    %edx,%eax
  117fa3:	c1 e0 02             	shl    $0x2,%eax
  117fa6:	01 d0                	add    %edx,%eax
  117fa8:	c1 e0 02             	shl    $0x2,%eax
  117fab:	c7 80 64 99 13 00 00 	movl   $0x0,0x139964(%eax)
  117fb2:	00 00 00 
      sockets[i].lastoffset = 0;
  117fb5:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  117fb8:	89 d0                	mov    %edx,%eax
  117fba:	c1 e0 02             	shl    $0x2,%eax
  117fbd:	01 d0                	add    %edx,%eax
  117fbf:	c1 e0 02             	shl    $0x2,%eax
  117fc2:	66 c7 80 68 99 13 00 	movw   $0x0,0x139968(%eax)
  117fc9:	00 00 
      sockets[i].rcvevent = 0;
  117fcb:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  117fce:	89 d0                	mov    %edx,%eax
  117fd0:	c1 e0 02             	shl    $0x2,%eax
  117fd3:	01 d0                	add    %edx,%eax
  117fd5:	c1 e0 02             	shl    $0x2,%eax
  117fd8:	66 c7 80 6a 99 13 00 	movw   $0x0,0x13996a(%eax)
  117fdf:	00 00 
      sockets[i].sendevent = 1; /* TCP send buf is empty */
  117fe1:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  117fe4:	89 d0                	mov    %edx,%eax
  117fe6:	c1 e0 02             	shl    $0x2,%eax
  117fe9:	01 d0                	add    %edx,%eax
  117feb:	c1 e0 02             	shl    $0x2,%eax
  117fee:	66 c7 80 6c 99 13 00 	movw   $0x1,0x13996c(%eax)
  117ff5:	01 00 
      sockets[i].flags = 0;
  117ff7:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  117ffa:	89 d0                	mov    %edx,%eax
  117ffc:	c1 e0 02             	shl    $0x2,%eax
  117fff:	01 d0                	add    %edx,%eax
  118001:	c1 e0 02             	shl    $0x2,%eax
  118004:	66 c7 80 6e 99 13 00 	movw   $0x0,0x13996e(%eax)
  11800b:	00 00 
      sockets[i].err = 0;
  11800d:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  118010:	89 d0                	mov    %edx,%eax
  118012:	c1 e0 02             	shl    $0x2,%eax
  118015:	01 d0                	add    %edx,%eax
  118017:	c1 e0 02             	shl    $0x2,%eax
  11801a:	c7 80 70 99 13 00 00 	movl   $0x0,0x139970(%eax)
  118021:	00 00 00 
      sys_sem_signal(socksem);
  118024:	a1 44 99 13 00       	mov    0x139944,%eax
  118029:	89 04 24             	mov    %eax,(%esp)
  11802c:	e8 8f 1d 00 00       	call   119dc0 <sys_sem_signal>
      return i;
  118031:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  118034:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  118037:	eb 22                	jmp    11805b <alloc_socket+0x12b>
  118039:	83 45 fc 01          	addl   $0x1,0xfffffffc(%ebp)
  11803d:	83 7d fc 03          	cmpl   $0x3,0xfffffffc(%ebp)
  118041:	0f 8e 22 ff ff ff    	jle    117f69 <alloc_socket+0x39>
    }
  }
  sys_sem_signal(socksem);
  118047:	a1 44 99 13 00       	mov    0x139944,%eax
  11804c:	89 04 24             	mov    %eax,(%esp)
  11804f:	e8 6c 1d 00 00       	call   119dc0 <sys_sem_signal>
  return -1;
  118054:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  11805b:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  11805e:	c9                   	leave  
  11805f:	c3                   	ret    

00118060 <lwip_accept>:

int
lwip_accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
  118060:	55                   	push   %ebp
  118061:	89 e5                	mov    %esp,%ebp
  118063:	83 ec 48             	sub    $0x48,%esp
  struct lwip_socket *sock;
  struct netconn *newconn;
  struct ip_addr naddr;
  u16_t port;
  int newsock;
  struct sockaddr_in sin;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d)...\n", s));
  sock = get_socket(s);
  118066:	8b 45 08             	mov    0x8(%ebp),%eax
  118069:	89 04 24             	mov    %eax,(%esp)
  11806c:	e8 6f fe ff ff       	call   117ee0 <get_socket>
  118071:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  if (!sock) {
  118074:	83 7d f4 00          	cmpl   $0x0,0xfffffff4(%ebp)
  118078:	75 0c                	jne    118086 <lwip_accept+0x26>
    set_errno(EBADF);
    return -1;
  11807a:	c7 45 cc ff ff ff ff 	movl   $0xffffffff,0xffffffcc(%ebp)
  118081:	e9 28 01 00 00       	jmp    1181ae <lwip_accept+0x14e>
  }

  newconn = netconn_accept(sock->conn);
  118086:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  118089:	8b 00                	mov    (%eax),%eax
  11808b:	89 04 24             	mov    %eax,(%esp)
  11808e:	e8 ad e3 ff ff       	call   116440 <netconn_accept>
  118093:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)

  /* get the IP address and port of the remote host */
  netconn_peer(newconn, &naddr, &port);
  118096:	8d 45 ee             	lea    0xffffffee(%ebp),%eax
  118099:	89 44 24 08          	mov    %eax,0x8(%esp)
  11809d:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
  1180a0:	89 44 24 04          	mov    %eax,0x4(%esp)
  1180a4:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1180a7:	89 04 24             	mov    %eax,(%esp)
  1180aa:	e8 21 df ff ff       	call   115fd0 <netconn_peer>

  memset(&sin, 0, sizeof(sin));
  1180af:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
  1180b6:	00 
  1180b7:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  1180be:	00 
  1180bf:	8d 45 dc             	lea    0xffffffdc(%ebp),%eax
  1180c2:	89 04 24             	mov    %eax,(%esp)
  1180c5:	e8 36 de fe ff       	call   105f00 <memset>
  sin.sin_len = sizeof(sin);
  1180ca:	c6 45 dc 10          	movb   $0x10,0xffffffdc(%ebp)
  sin.sin_family = AF_INET;
  1180ce:	c6 45 dd 02          	movb   $0x2,0xffffffdd(%ebp)
  sin.sin_port = htons(port);
  1180d2:	0f b7 45 ee          	movzwl 0xffffffee(%ebp),%eax
  1180d6:	0f b7 c0             	movzwl %ax,%eax
  1180d9:	89 04 24             	mov    %eax,(%esp)
  1180dc:	e8 8f 61 ff ff       	call   10e270 <htons>
  1180e1:	66 89 45 de          	mov    %ax,0xffffffde(%ebp)
  sin.sin_addr.s_addr = naddr.addr;
  1180e5:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  1180e8:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)

  if (*addrlen > sizeof(sin))
  1180eb:	8b 45 10             	mov    0x10(%ebp),%eax
  1180ee:	8b 00                	mov    (%eax),%eax
  1180f0:	83 f8 10             	cmp    $0x10,%eax
  1180f3:	76 09                	jbe    1180fe <lwip_accept+0x9e>
      *addrlen = sizeof(sin);
  1180f5:	8b 45 10             	mov    0x10(%ebp),%eax
  1180f8:	c7 00 10 00 00 00    	movl   $0x10,(%eax)

  memcpy(addr, &sin, *addrlen);
  1180fe:	8b 45 10             	mov    0x10(%ebp),%eax
  118101:	8b 00                	mov    (%eax),%eax
  118103:	89 44 24 08          	mov    %eax,0x8(%esp)
  118107:	8d 45 dc             	lea    0xffffffdc(%ebp),%eax
  11810a:	89 44 24 04          	mov    %eax,0x4(%esp)
  11810e:	8b 45 0c             	mov    0xc(%ebp),%eax
  118111:	89 04 24             	mov    %eax,(%esp)
  118114:	e8 a7 dd fe ff       	call   105ec0 <memcpy>

  newsock = alloc_socket(newconn);
  118119:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  11811c:	89 04 24             	mov    %eax,(%esp)
  11811f:	e8 0c fe ff ff       	call   117f30 <alloc_socket>
  118124:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  if (newsock == -1) {
  118127:	83 7d fc ff          	cmpl   $0xffffffff,0xfffffffc(%ebp)
  11812b:	75 1e                	jne    11814b <lwip_accept+0xeb>
    netconn_delete(newconn);
  11812d:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  118130:	89 04 24             	mov    %eax,(%esp)
  118133:	e8 f8 dc ff ff       	call   115e30 <netconn_delete>
  sock_set_errno(sock, ENOBUFS);
  118138:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  11813b:	c7 40 10 69 00 00 00 	movl   $0x69,0x10(%eax)
  return -1;
  118142:	c7 45 cc ff ff ff ff 	movl   $0xffffffff,0xffffffcc(%ebp)
  118149:	eb 63                	jmp    1181ae <lwip_accept+0x14e>
  }
  newconn->callback = event_callback;
  11814b:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  11814e:	c7 40 28 10 90 11 00 	movl   $0x119010,0x28(%eax)
  sock = get_socket(newsock);
  118155:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  118158:	89 04 24             	mov    %eax,(%esp)
  11815b:	e8 80 fd ff ff       	call   117ee0 <get_socket>
  118160:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)

  sys_sem_wait(socksem);
  118163:	a1 44 99 13 00       	mov    0x139944,%eax
  118168:	89 04 24             	mov    %eax,(%esp)
  11816b:	e8 90 7c ff ff       	call   10fe00 <sys_sem_wait>
  sock->rcvevent += -1 - newconn->socket;
  118170:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  118173:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
  118177:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  11817a:	8b 40 20             	mov    0x20(%eax),%eax
  11817d:	f7 d0                	not    %eax
  11817f:	01 c2                	add    %eax,%edx
  118181:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  118184:	66 89 50 0a          	mov    %dx,0xa(%eax)
  newconn->socket = newsock;
  118188:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  11818b:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  11818e:	89 42 20             	mov    %eax,0x20(%edx)
  sys_sem_signal(socksem);
  118191:	a1 44 99 13 00       	mov    0x139944,%eax
  118196:	89 04 24             	mov    %eax,(%esp)
  118199:	e8 22 1c 00 00       	call   119dc0 <sys_sem_signal>

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d) returning new sock=%d addr=", s, newsock));
  ip_addr_debug_print(SOCKETS_DEBUG, &naddr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u\n", port));

  sock_set_errno(sock, 0);
  11819e:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  1181a1:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  return newsock;
  1181a8:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1181ab:	89 45 cc             	mov    %eax,0xffffffcc(%ebp)
  1181ae:	8b 45 cc             	mov    0xffffffcc(%ebp),%eax
}
  1181b1:	c9                   	leave  
  1181b2:	c3                   	ret    
  1181b3:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  1181b9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

001181c0 <lwip_bind>:

int
lwip_bind(int s, struct sockaddr *name, socklen_t namelen)
{
  1181c0:	55                   	push   %ebp
  1181c1:	89 e5                	mov    %esp,%ebp
  1181c3:	83 ec 28             	sub    $0x28,%esp
  struct lwip_socket *sock;
  struct ip_addr local_addr;
  u16_t local_port;
  err_t err;

  sock = get_socket(s);
  1181c6:	8b 45 08             	mov    0x8(%ebp),%eax
  1181c9:	89 04 24             	mov    %eax,(%esp)
  1181cc:	e8 0f fd ff ff       	call   117ee0 <get_socket>
  1181d1:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  if (!sock) {
  1181d4:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  1181d8:	75 0c                	jne    1181e6 <lwip_bind+0x26>
    set_errno(EBADF);
    return -1;
  1181da:	c7 45 e8 ff ff ff ff 	movl   $0xffffffff,0xffffffe8(%ebp)
  1181e1:	e9 88 00 00 00       	jmp    11826e <lwip_bind+0xae>
  }

  local_addr.addr = ((struct sockaddr_in *)name)->sin_addr.s_addr;
  1181e6:	8b 45 0c             	mov    0xc(%ebp),%eax
  1181e9:	8b 40 04             	mov    0x4(%eax),%eax
  1181ec:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  local_port = ((struct sockaddr_in *)name)->sin_port;
  1181ef:	8b 45 0c             	mov    0xc(%ebp),%eax
  1181f2:	0f b7 40 02          	movzwl 0x2(%eax),%eax
  1181f6:	66 89 45 fc          	mov    %ax,0xfffffffc(%ebp)

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d, addr=", s));
  ip_addr_debug_print(SOCKETS_DEBUG, &local_addr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u)\n", ntohs(local_port)));

  err = netconn_bind(sock->conn, &local_addr, ntohs(local_port));
  1181fa:	0f b7 45 fc          	movzwl 0xfffffffc(%ebp),%eax
  1181fe:	89 04 24             	mov    %eax,(%esp)
  118201:	e8 9a 60 ff ff       	call   10e2a0 <ntohs>
  118206:	0f b7 d0             	movzwl %ax,%edx
  118209:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  11820c:	8b 08                	mov    (%eax),%ecx
  11820e:	89 54 24 08          	mov    %edx,0x8(%esp)
  118212:	8d 45 f4             	lea    0xfffffff4(%ebp),%eax
  118215:	89 44 24 04          	mov    %eax,0x4(%esp)
  118219:	89 0c 24             	mov    %ecx,(%esp)
  11821c:	e8 ff de ff ff       	call   116120 <netconn_bind>
  118221:	88 45 ff             	mov    %al,0xffffffff(%ebp)

  if (err != ERR_OK) {
  118224:	80 7d ff 00          	cmpb   $0x0,0xffffffff(%ebp)
  118228:	74 33                	je     11825d <lwip_bind+0x9d>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d) failed, err=%d\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
  11822a:	0f b6 45 ff          	movzbl 0xffffffff(%ebp),%eax
  11822e:	3c 0a                	cmp    $0xa,%al
  118230:	77 12                	ja     118244 <lwip_bind+0x84>
  118232:	0f be 45 ff          	movsbl 0xffffffff(%ebp),%eax
  118236:	f7 d8                	neg    %eax
  118238:	8b 04 85 40 cc 11 00 	mov    0x11cc40(,%eax,4),%eax
  11823f:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  118242:	eb 07                	jmp    11824b <lwip_bind+0x8b>
  118244:	c7 45 ec 05 00 00 00 	movl   $0x5,0xffffffec(%ebp)
  11824b:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  11824e:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
  118251:	89 50 10             	mov    %edx,0x10(%eax)
    return -1;
  118254:	c7 45 e8 ff ff ff ff 	movl   $0xffffffff,0xffffffe8(%ebp)
  11825b:	eb 11                	jmp    11826e <lwip_bind+0xae>
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d) succeeded\n", s));
  sock_set_errno(sock, 0);
  11825d:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  118260:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  return 0;
  118267:	c7 45 e8 00 00 00 00 	movl   $0x0,0xffffffe8(%ebp)
  11826e:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
}
  118271:	c9                   	leave  
  118272:	c3                   	ret    
  118273:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  118279:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00118280 <lwip_close>:

int
lwip_close(int s)
{
  118280:	55                   	push   %ebp
  118281:	89 e5                	mov    %esp,%ebp
  118283:	83 ec 18             	sub    $0x18,%esp
  struct lwip_socket *sock;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_close(%d)\n", s));
  if (!socksem)
  118286:	a1 44 99 13 00       	mov    0x139944,%eax
  11828b:	85 c0                	test   %eax,%eax
  11828d:	75 11                	jne    1182a0 <lwip_close+0x20>
      socksem = sys_sem_new(1);
  11828f:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  118296:	e8 a5 1a 00 00       	call   119d40 <sys_sem_new>
  11829b:	a3 44 99 13 00       	mov    %eax,0x139944

  /* We cannot allow multiple closes of the same socket. */
  sys_sem_wait(socksem);
  1182a0:	a1 44 99 13 00       	mov    0x139944,%eax
  1182a5:	89 04 24             	mov    %eax,(%esp)
  1182a8:	e8 53 7b ff ff       	call   10fe00 <sys_sem_wait>

  sock = get_socket(s);
  1182ad:	8b 45 08             	mov    0x8(%ebp),%eax
  1182b0:	89 04 24             	mov    %eax,(%esp)
  1182b3:	e8 28 fc ff ff       	call   117ee0 <get_socket>
  1182b8:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  if (!sock) {
  1182bb:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  1182bf:	75 16                	jne    1182d7 <lwip_close+0x57>
      sys_sem_signal(socksem);
  1182c1:	a1 44 99 13 00       	mov    0x139944,%eax
  1182c6:	89 04 24             	mov    %eax,(%esp)
  1182c9:	e8 f2 1a 00 00       	call   119dc0 <sys_sem_signal>
      set_errno(EBADF);
      return -1;
  1182ce:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  1182d5:	eb 5f                	jmp    118336 <lwip_close+0xb6>
  }

  netconn_delete(sock->conn);
  1182d7:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1182da:	8b 00                	mov    (%eax),%eax
  1182dc:	89 04 24             	mov    %eax,(%esp)
  1182df:	e8 4c db ff ff       	call   115e30 <netconn_delete>
  if (sock->lastdata) {
  1182e4:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1182e7:	8b 40 04             	mov    0x4(%eax),%eax
  1182ea:	85 c0                	test   %eax,%eax
  1182ec:	74 0e                	je     1182fc <lwip_close+0x7c>
    netbuf_delete(sock->lastdata);
  1182ee:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1182f1:	8b 40 04             	mov    0x4(%eax),%eax
  1182f4:	89 04 24             	mov    %eax,(%esp)
  1182f7:	e8 84 d5 ff ff       	call   115880 <netbuf_delete>
  }
  sock->lastdata = NULL;
  1182fc:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1182ff:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  sock->lastoffset = 0;
  118306:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  118309:	66 c7 40 08 00 00    	movw   $0x0,0x8(%eax)
  sock->conn = NULL;
  11830f:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  118312:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  sys_sem_signal(socksem);
  118318:	a1 44 99 13 00       	mov    0x139944,%eax
  11831d:	89 04 24             	mov    %eax,(%esp)
  118320:	e8 9b 1a 00 00       	call   119dc0 <sys_sem_signal>
  sock_set_errno(sock, 0);
  118325:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  118328:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  return 0;
  11832f:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  118336:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  118339:	c9                   	leave  
  11833a:	c3                   	ret    
  11833b:	90                   	nop    
  11833c:	8d 74 26 00          	lea    0x0(%esi),%esi

00118340 <lwip_connect>:

int
lwip_connect(int s, struct sockaddr *name, socklen_t namelen)
{
  118340:	55                   	push   %ebp
  118341:	89 e5                	mov    %esp,%ebp
  118343:	83 ec 28             	sub    $0x28,%esp
  struct lwip_socket *sock;
  err_t err;

  sock = get_socket(s);
  118346:	8b 45 08             	mov    0x8(%ebp),%eax
  118349:	89 04 24             	mov    %eax,(%esp)
  11834c:	e8 8f fb ff ff       	call   117ee0 <get_socket>
  118351:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  if (!sock) {
  118354:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  118358:	75 0c                	jne    118366 <lwip_connect+0x26>
    set_errno(EBADF);
    return -1;
  11835a:	c7 45 e8 ff ff ff ff 	movl   $0xffffffff,0xffffffe8(%ebp)
  118361:	e9 a5 00 00 00       	jmp    11840b <lwip_connect+0xcb>
  }

  if (((struct sockaddr_in *)name)->sin_family == AF_UNSPEC) {
  118366:	8b 45 0c             	mov    0xc(%ebp),%eax
  118369:	0f b6 40 01          	movzbl 0x1(%eax),%eax
  11836d:	84 c0                	test   %al,%al
  11836f:	75 12                	jne    118383 <lwip_connect+0x43>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d, AF_UNSPEC)\n", s));
    err = netconn_disconnect(sock->conn);
  118371:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  118374:	8b 00                	mov    (%eax),%eax
  118376:	89 04 24             	mov    %eax,(%esp)
  118379:	e8 72 df ff ff       	call   1162f0 <netconn_disconnect>
  11837e:	88 45 fd             	mov    %al,0xfffffffd(%ebp)
  118381:	eb 3e                	jmp    1183c1 <lwip_connect+0x81>
  } else {
    struct ip_addr remote_addr;
    u16_t remote_port;

    remote_addr.addr = ((struct sockaddr_in *)name)->sin_addr.s_addr;
  118383:	8b 45 0c             	mov    0xc(%ebp),%eax
  118386:	8b 40 04             	mov    0x4(%eax),%eax
  118389:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
    remote_port = ((struct sockaddr_in *)name)->sin_port;
  11838c:	8b 45 0c             	mov    0xc(%ebp),%eax
  11838f:	0f b7 40 02          	movzwl 0x2(%eax),%eax
  118393:	66 89 45 fe          	mov    %ax,0xfffffffe(%ebp)

    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d, addr=", s));
    ip_addr_debug_print(SOCKETS_DEBUG, &remote_addr);
    LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u)\n", ntohs(remote_port)));

    err = netconn_connect(sock->conn, &remote_addr, ntohs(remote_port));
  118397:	0f b7 45 fe          	movzwl 0xfffffffe(%ebp),%eax
  11839b:	89 04 24             	mov    %eax,(%esp)
  11839e:	e8 fd 5e ff ff       	call   10e2a0 <ntohs>
  1183a3:	0f b7 d0             	movzwl %ax,%edx
  1183a6:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1183a9:	8b 08                	mov    (%eax),%ecx
  1183ab:	89 54 24 08          	mov    %edx,0x8(%esp)
  1183af:	8d 45 f4             	lea    0xfffffff4(%ebp),%eax
  1183b2:	89 44 24 04          	mov    %eax,0x4(%esp)
  1183b6:	89 0c 24             	mov    %ecx,(%esp)
  1183b9:	e8 52 de ff ff       	call   116210 <netconn_connect>
  1183be:	88 45 fd             	mov    %al,0xfffffffd(%ebp)
   }

  if (err != ERR_OK) {
  1183c1:	80 7d fd 00          	cmpb   $0x0,0xfffffffd(%ebp)
  1183c5:	74 33                	je     1183fa <lwip_connect+0xba>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d) failed, err=%d\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
  1183c7:	0f b6 45 fd          	movzbl 0xfffffffd(%ebp),%eax
  1183cb:	3c 0a                	cmp    $0xa,%al
  1183cd:	77 12                	ja     1183e1 <lwip_connect+0xa1>
  1183cf:	0f be 45 fd          	movsbl 0xfffffffd(%ebp),%eax
  1183d3:	f7 d8                	neg    %eax
  1183d5:	8b 04 85 40 cc 11 00 	mov    0x11cc40(,%eax,4),%eax
  1183dc:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  1183df:	eb 07                	jmp    1183e8 <lwip_connect+0xa8>
  1183e1:	c7 45 ec 05 00 00 00 	movl   $0x5,0xffffffec(%ebp)
  1183e8:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1183eb:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
  1183ee:	89 50 10             	mov    %edx,0x10(%eax)
    return -1;
  1183f1:	c7 45 e8 ff ff ff ff 	movl   $0xffffffff,0xffffffe8(%ebp)
  1183f8:	eb 11                	jmp    11840b <lwip_connect+0xcb>
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d) succeeded\n", s));
  sock_set_errno(sock, 0);
  1183fa:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1183fd:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  return 0;
  118404:	c7 45 e8 00 00 00 00 	movl   $0x0,0xffffffe8(%ebp)
  11840b:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
}
  11840e:	c9                   	leave  
  11840f:	c3                   	ret    

00118410 <lwip_listen>:

int
lwip_listen(int s, int backlog)
{
  118410:	55                   	push   %ebp
  118411:	89 e5                	mov    %esp,%ebp
  118413:	83 ec 28             	sub    $0x28,%esp
  struct lwip_socket *sock;
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_listen(%d, backlog=%d)\n", s, backlog));
  sock = get_socket(s);
  118416:	8b 45 08             	mov    0x8(%ebp),%eax
  118419:	89 04 24             	mov    %eax,(%esp)
  11841c:	e8 bf fa ff ff       	call   117ee0 <get_socket>
  118421:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  if (!sock) {
  118424:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  118428:	75 09                	jne    118433 <lwip_listen+0x23>
    set_errno(EBADF);
    return -1;
  11842a:	c7 45 e8 ff ff ff ff 	movl   $0xffffffff,0xffffffe8(%ebp)
  118431:	eb 5a                	jmp    11848d <lwip_listen+0x7d>
  }

  err = netconn_listen(sock->conn);
  118433:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  118436:	8b 00                	mov    (%eax),%eax
  118438:	89 04 24             	mov    %eax,(%esp)
  11843b:	e8 40 df ff ff       	call   116380 <netconn_listen>
  118440:	88 45 ff             	mov    %al,0xffffffff(%ebp)

  if (err != ERR_OK) {
  118443:	80 7d ff 00          	cmpb   $0x0,0xffffffff(%ebp)
  118447:	74 33                	je     11847c <lwip_listen+0x6c>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_listen(%d) failed, err=%d\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
  118449:	0f b6 45 ff          	movzbl 0xffffffff(%ebp),%eax
  11844d:	3c 0a                	cmp    $0xa,%al
  11844f:	77 12                	ja     118463 <lwip_listen+0x53>
  118451:	0f be 45 ff          	movsbl 0xffffffff(%ebp),%eax
  118455:	f7 d8                	neg    %eax
  118457:	8b 04 85 40 cc 11 00 	mov    0x11cc40(,%eax,4),%eax
  11845e:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  118461:	eb 07                	jmp    11846a <lwip_listen+0x5a>
  118463:	c7 45 ec 05 00 00 00 	movl   $0x5,0xffffffec(%ebp)
  11846a:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  11846d:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
  118470:	89 50 10             	mov    %edx,0x10(%eax)
    return -1;
  118473:	c7 45 e8 ff ff ff ff 	movl   $0xffffffff,0xffffffe8(%ebp)
  11847a:	eb 11                	jmp    11848d <lwip_listen+0x7d>
  }

  sock_set_errno(sock, 0);
  11847c:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  11847f:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  return 0;
  118486:	c7 45 e8 00 00 00 00 	movl   $0x0,0xffffffe8(%ebp)
  11848d:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
}
  118490:	c9                   	leave  
  118491:	c3                   	ret    
  118492:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi
  118499:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

001184a0 <lwip_recvfrom>:

int
lwip_recvfrom(int s, void *mem, int len, unsigned int flags,
        struct sockaddr *from, socklen_t *fromlen)
{
  1184a0:	55                   	push   %ebp
  1184a1:	89 e5                	mov    %esp,%ebp
  1184a3:	83 ec 48             	sub    $0x48,%esp
  struct lwip_socket *sock;
  struct netbuf *buf;
  u16_t buflen, copylen;
  struct ip_addr *addr;
  u16_t port;


  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d, %p, %d, 0x%x, ..)\n", s, mem, len, flags));
  sock = get_socket(s);
  1184a6:	8b 45 08             	mov    0x8(%ebp),%eax
  1184a9:	89 04 24             	mov    %eax,(%esp)
  1184ac:	e8 2f fa ff ff       	call   117ee0 <get_socket>
  1184b1:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  if (!sock) {
  1184b4:	83 7d ec 00          	cmpl   $0x0,0xffffffec(%ebp)
  1184b8:	75 0c                	jne    1184c6 <lwip_recvfrom+0x26>
    set_errno(EBADF);
    return -1;
  1184ba:	c7 45 cc ff ff ff ff 	movl   $0xffffffff,0xffffffcc(%ebp)
  1184c1:	e9 e3 01 00 00       	jmp    1186a9 <lwip_recvfrom+0x209>
  }

  /* Check if there is data left from the last recv operation. */
  if (sock->lastdata) {
  1184c6:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  1184c9:	8b 40 04             	mov    0x4(%eax),%eax
  1184cc:	85 c0                	test   %eax,%eax
  1184ce:	74 0b                	je     1184db <lwip_recvfrom+0x3b>
    buf = sock->lastdata;
  1184d0:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  1184d3:	8b 40 04             	mov    0x4(%eax),%eax
  1184d6:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
  1184d9:	eb 6b                	jmp    118546 <lwip_recvfrom+0xa6>
  } else {
    /* If this is non-blocking call, then check first */
    if (((flags & MSG_DONTWAIT) || (sock->flags & O_NONBLOCK))
  1184db:	8b 45 14             	mov    0x14(%ebp),%eax
  1184de:	83 e0 40             	and    $0x40,%eax
  1184e1:	85 c0                	test   %eax,%eax
  1184e3:	75 13                	jne    1184f8 <lwip_recvfrom+0x58>
  1184e5:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  1184e8:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
  1184ec:	0f b7 c0             	movzwl %ax,%eax
  1184ef:	25 00 08 00 00       	and    $0x800,%eax
  1184f4:	85 c0                	test   %eax,%eax
  1184f6:	74 22                	je     11851a <lwip_recvfrom+0x7a>
  1184f8:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  1184fb:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  1184ff:	66 85 c0             	test   %ax,%ax
  118502:	75 16                	jne    11851a <lwip_recvfrom+0x7a>
  && !sock->rcvevent)
    {
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d): returning EWOULDBLOCK\n", s));
      sock_set_errno(sock, EWOULDBLOCK);
  118504:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  118507:	c7 40 10 0b 00 00 00 	movl   $0xb,0x10(%eax)
      return -1;
  11850e:	c7 45 cc ff ff ff ff 	movl   $0xffffffff,0xffffffcc(%ebp)
  118515:	e9 8f 01 00 00       	jmp    1186a9 <lwip_recvfrom+0x209>
    }

    /* No data was left from the previous operation, so we try to get
       some from the network. */
    buf = netconn_recv(sock->conn);
  11851a:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  11851d:	8b 00                	mov    (%eax),%eax
  11851f:	89 04 24             	mov    %eax,(%esp)
  118522:	e8 79 df ff ff       	call   1164a0 <netconn_recv>
  118527:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)

    if (!buf) {
  11852a:	83 7d f0 00          	cmpl   $0x0,0xfffffff0(%ebp)
  11852e:	75 16                	jne    118546 <lwip_recvfrom+0xa6>
      /* We should really do some error checking here. */
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d): buf == NULL!\n", s));
      sock_set_errno(sock, 0);
  118530:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  118533:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
      return 0;
  11853a:	c7 45 cc 00 00 00 00 	movl   $0x0,0xffffffcc(%ebp)
  118541:	e9 63 01 00 00       	jmp    1186a9 <lwip_recvfrom+0x209>
    }
  }

  buflen = netbuf_len(buf);
  118546:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  118549:	89 04 24             	mov    %eax,(%esp)
  11854c:	e8 ff d4 ff ff       	call   115a50 <netbuf_len>
  118551:	66 89 45 f4          	mov    %ax,0xfffffff4(%ebp)

  buflen -= sock->lastoffset;
  118555:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  118558:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  11855c:	66 29 45 f4          	sub    %ax,0xfffffff4(%ebp)

  if (len > buflen) {
  118560:	0f b7 45 f4          	movzwl 0xfffffff4(%ebp),%eax
  118564:	3b 45 10             	cmp    0x10(%ebp),%eax
  118567:	7d 0a                	jge    118573 <lwip_recvfrom+0xd3>
    copylen = buflen;
  118569:	0f b7 45 f4          	movzwl 0xfffffff4(%ebp),%eax
  11856d:	66 89 45 f6          	mov    %ax,0xfffffff6(%ebp)
  118571:	eb 07                	jmp    11857a <lwip_recvfrom+0xda>
  } else {
    copylen = len;
  118573:	8b 45 10             	mov    0x10(%ebp),%eax
  118576:	66 89 45 f6          	mov    %ax,0xfffffff6(%ebp)
  }

  /* copy the contents of the received buffer into
     the supplied memory pointer mem */
  netbuf_copy_partial(buf, mem, copylen, sock->lastoffset);
  11857a:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  11857d:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  118581:	0f b7 c0             	movzwl %ax,%eax
  118584:	0f b7 55 f6          	movzwl 0xfffffff6(%ebp),%edx
  118588:	89 44 24 0c          	mov    %eax,0xc(%esp)
  11858c:	89 54 24 08          	mov    %edx,0x8(%esp)
  118590:	8b 45 0c             	mov    0xc(%ebp),%eax
  118593:	89 44 24 04          	mov    %eax,0x4(%esp)
  118597:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  11859a:	89 04 24             	mov    %eax,(%esp)
  11859d:	e8 7e d5 ff ff       	call   115b20 <netbuf_copy_partial>

  /* Check to see from where the data was. */
  if (from && fromlen) {
  1185a2:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
  1185a6:	0f 84 90 00 00 00    	je     11863c <lwip_recvfrom+0x19c>
  1185ac:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  1185b0:	0f 84 86 00 00 00    	je     11863c <lwip_recvfrom+0x19c>
    struct sockaddr_in sin;

    addr = netbuf_fromaddr(buf);
  1185b6:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  1185b9:	89 04 24             	mov    %eax,(%esp)
  1185bc:	e8 6f d6 ff ff       	call   115c30 <netbuf_fromaddr>
  1185c1:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
    port = netbuf_fromport(buf);
  1185c4:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  1185c7:	89 04 24             	mov    %eax,(%esp)
  1185ca:	e8 71 d6 ff ff       	call   115c40 <netbuf_fromport>
  1185cf:	66 89 45 fe          	mov    %ax,0xfffffffe(%ebp)

    memset(&sin, 0, sizeof(sin));
  1185d3:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
  1185da:	00 
  1185db:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  1185e2:	00 
  1185e3:	8d 45 dc             	lea    0xffffffdc(%ebp),%eax
  1185e6:	89 04 24             	mov    %eax,(%esp)
  1185e9:	e8 12 d9 fe ff       	call   105f00 <memset>
    sin.sin_len = sizeof(sin);
  1185ee:	c6 45 dc 10          	movb   $0x10,0xffffffdc(%ebp)
    sin.sin_family = AF_INET;
  1185f2:	c6 45 dd 02          	movb   $0x2,0xffffffdd(%ebp)
    sin.sin_port = htons(port);
  1185f6:	0f b7 45 fe          	movzwl 0xfffffffe(%ebp),%eax
  1185fa:	89 04 24             	mov    %eax,(%esp)
  1185fd:	e8 6e 5c ff ff       	call   10e270 <htons>
  118602:	66 89 45 de          	mov    %ax,0xffffffde(%ebp)
    sin.sin_addr.s_addr = addr->addr;
  118606:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  118609:	8b 00                	mov    (%eax),%eax
  11860b:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)

    if (*fromlen > sizeof(sin))
  11860e:	8b 45 1c             	mov    0x1c(%ebp),%eax
  118611:	8b 00                	mov    (%eax),%eax
  118613:	83 f8 10             	cmp    $0x10,%eax
  118616:	76 09                	jbe    118621 <lwip_recvfrom+0x181>
      *fromlen = sizeof(sin);
  118618:	8b 45 1c             	mov    0x1c(%ebp),%eax
  11861b:	c7 00 10 00 00 00    	movl   $0x10,(%eax)

    memcpy(from, &sin, *fromlen);
  118621:	8b 45 1c             	mov    0x1c(%ebp),%eax
  118624:	8b 00                	mov    (%eax),%eax
  118626:	89 44 24 08          	mov    %eax,0x8(%esp)
  11862a:	8d 45 dc             	lea    0xffffffdc(%ebp),%eax
  11862d:	89 44 24 04          	mov    %eax,0x4(%esp)
  118631:	8b 45 18             	mov    0x18(%ebp),%eax
  118634:	89 04 24             	mov    %eax,(%esp)
  118637:	e8 84 d8 fe ff       	call   105ec0 <memcpy>

    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d): addr=", s));
    ip_addr_debug_print(SOCKETS_DEBUG, addr);
    LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u len=%u\n", port, copylen));
  } else {
#if SOCKETS_DEBUG > 0
    addr = netbuf_fromaddr(buf);
    port = netbuf_fromport(buf);

    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d): addr=", s));
    ip_addr_debug_print(SOCKETS_DEBUG, addr);
    LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u len=%u\n", port, copylen));
#endif

  }

  /* If this is a TCP socket, check if there is data left in the
     buffer. If so, it should be saved in the sock structure for next
     time around. */
  if (netconn_type(sock->conn) == NETCONN_TCP && buflen - copylen > 0) {
  11863c:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  11863f:	8b 00                	mov    (%eax),%eax
  118641:	89 04 24             	mov    %eax,(%esp)
  118644:	e8 77 d9 ff ff       	call   115fc0 <netconn_type>
  118649:	85 c0                	test   %eax,%eax
  11864b:	75 2d                	jne    11867a <lwip_recvfrom+0x1da>
  11864d:	0f b7 45 f4          	movzwl 0xfffffff4(%ebp),%eax
  118651:	0f b7 55 f6          	movzwl 0xfffffff6(%ebp),%edx
  118655:	29 d0                	sub    %edx,%eax
  118657:	85 c0                	test   %eax,%eax
  118659:	7e 1f                	jle    11867a <lwip_recvfrom+0x1da>
    sock->lastdata = buf;
  11865b:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
  11865e:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  118661:	89 42 04             	mov    %eax,0x4(%edx)
    sock->lastoffset += copylen;
  118664:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  118667:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  11866b:	89 c2                	mov    %eax,%edx
  11866d:	66 03 55 f6          	add    0xfffffff6(%ebp),%dx
  118671:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  118674:	66 89 50 08          	mov    %dx,0x8(%eax)
  118678:	eb 1e                	jmp    118698 <lwip_recvfrom+0x1f8>
  } else {
    sock->lastdata = NULL;
  11867a:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  11867d:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    sock->lastoffset = 0;
  118684:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  118687:	66 c7 40 08 00 00    	movw   $0x0,0x8(%eax)
    netbuf_delete(buf);
  11868d:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  118690:	89 04 24             	mov    %eax,(%esp)
  118693:	e8 e8 d1 ff ff       	call   115880 <netbuf_delete>
  }


  sock_set_errno(sock, 0);
  118698:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  11869b:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  return copylen;
  1186a2:	0f b7 45 f6          	movzwl 0xfffffff6(%ebp),%eax
  1186a6:	89 45 cc             	mov    %eax,0xffffffcc(%ebp)
  1186a9:	8b 45 cc             	mov    0xffffffcc(%ebp),%eax
}
  1186ac:	c9                   	leave  
  1186ad:	c3                   	ret    
  1186ae:	89 f6                	mov    %esi,%esi

001186b0 <lwip_read>:

int
lwip_read(int s, void *mem, int len)
{
  1186b0:	55                   	push   %ebp
  1186b1:	89 e5                	mov    %esp,%ebp
  1186b3:	83 ec 18             	sub    $0x18,%esp
  return lwip_recvfrom(s, mem, len, 0, NULL, NULL);
  1186b6:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
  1186bd:	00 
  1186be:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  1186c5:	00 
  1186c6:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  1186cd:	00 
  1186ce:	8b 45 10             	mov    0x10(%ebp),%eax
  1186d1:	89 44 24 08          	mov    %eax,0x8(%esp)
  1186d5:	8b 45 0c             	mov    0xc(%ebp),%eax
  1186d8:	89 44 24 04          	mov    %eax,0x4(%esp)
  1186dc:	8b 45 08             	mov    0x8(%ebp),%eax
  1186df:	89 04 24             	mov    %eax,(%esp)
  1186e2:	e8 b9 fd ff ff       	call   1184a0 <lwip_recvfrom>
}
  1186e7:	c9                   	leave  
  1186e8:	c3                   	ret    
  1186e9:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

001186f0 <lwip_recv>:

int
lwip_recv(int s, void *mem, int len, unsigned int flags)
{
  1186f0:	55                   	push   %ebp
  1186f1:	89 e5                	mov    %esp,%ebp
  1186f3:	83 ec 18             	sub    $0x18,%esp
  return lwip_recvfrom(s, mem, len, flags, NULL, NULL);
  1186f6:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
  1186fd:	00 
  1186fe:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  118705:	00 
  118706:	8b 45 14             	mov    0x14(%ebp),%eax
  118709:	89 44 24 0c          	mov    %eax,0xc(%esp)
  11870d:	8b 45 10             	mov    0x10(%ebp),%eax
  118710:	89 44 24 08          	mov    %eax,0x8(%esp)
  118714:	8b 45 0c             	mov    0xc(%ebp),%eax
  118717:	89 44 24 04          	mov    %eax,0x4(%esp)
  11871b:	8b 45 08             	mov    0x8(%ebp),%eax
  11871e:	89 04 24             	mov    %eax,(%esp)
  118721:	e8 7a fd ff ff       	call   1184a0 <lwip_recvfrom>
}
  118726:	c9                   	leave  
  118727:	c3                   	ret    
  118728:	90                   	nop    
  118729:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

00118730 <lwip_send>:

int
lwip_send(int s, void *data, int size, unsigned int flags)
{
  118730:	55                   	push   %ebp
  118731:	89 e5                	mov    %esp,%ebp
  118733:	83 ec 38             	sub    $0x38,%esp
  struct lwip_socket *sock;
  struct netbuf *buf;
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d, data=%p, size=%d, flags=0x%x)\n", s, data, size, flags));

  sock = get_socket(s);
  118736:	8b 45 08             	mov    0x8(%ebp),%eax
  118739:	89 04 24             	mov    %eax,(%esp)
  11873c:	e8 9f f7 ff ff       	call   117ee0 <get_socket>
  118741:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  if (!sock) {
  118744:	83 7d f4 00          	cmpl   $0x0,0xfffffff4(%ebp)
  118748:	75 0c                	jne    118756 <lwip_send+0x26>
    set_errno(EBADF);
    return -1;
  11874a:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,0xffffffe4(%ebp)
  118751:	e9 fc 00 00 00       	jmp    118852 <lwip_send+0x122>
  }

  switch (netconn_type(sock->conn)) {
  118756:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  118759:	8b 00                	mov    (%eax),%eax
  11875b:	89 04 24             	mov    %eax,(%esp)
  11875e:	e8 5d d8 ff ff       	call   115fc0 <netconn_type>
  118763:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
  118766:	83 7d e8 00          	cmpl   $0x0,0xffffffe8(%ebp)
  11876a:	74 6e                	je     1187da <lwip_send+0xaa>
  11876c:	83 7d e8 04          	cmpl   $0x4,0xffffffe8(%ebp)
  118770:	0f 87 8f 00 00 00    	ja     118805 <lwip_send+0xd5>
  case NETCONN_RAW:
  case NETCONN_UDP:
  case NETCONN_UDPLITE:
  case NETCONN_UDPNOCHKSUM:
    /* create a buffer */
    buf = netbuf_new();
  118776:	e8 b5 d0 ff ff       	call   115830 <netbuf_new>
  11877b:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)

    if (!buf) {
  11877e:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  118782:	75 16                	jne    11879a <lwip_send+0x6a>
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d) ENOBUFS\n", s));
      sock_set_errno(sock, ENOBUFS);
  118784:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  118787:	c7 40 10 69 00 00 00 	movl   $0x69,0x10(%eax)
      return -1;
  11878e:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,0xffffffe4(%ebp)
  118795:	e9 b8 00 00 00       	jmp    118852 <lwip_send+0x122>
    }

    /* make the buffer point to the data that should
       be sent */
    netbuf_ref(buf, data, size);
  11879a:	8b 45 10             	mov    0x10(%ebp),%eax
  11879d:	0f b7 c0             	movzwl %ax,%eax
  1187a0:	89 44 24 08          	mov    %eax,0x8(%esp)
  1187a4:	8b 45 0c             	mov    0xc(%ebp),%eax
  1187a7:	89 44 24 04          	mov    %eax,0x4(%esp)
  1187ab:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1187ae:	89 04 24             	mov    %eax,(%esp)
  1187b1:	e8 da d1 ff ff       	call   115990 <netbuf_ref>

    /* send the data */
    err = netconn_send(sock->conn, buf);
  1187b6:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  1187b9:	8b 10                	mov    (%eax),%edx
  1187bb:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1187be:	89 44 24 04          	mov    %eax,0x4(%esp)
  1187c2:	89 14 24             	mov    %edx,(%esp)
  1187c5:	e8 46 df ff ff       	call   116710 <netconn_send>
  1187ca:	88 45 ff             	mov    %al,0xffffffff(%ebp)

    /* deallocated the buffer */
    netbuf_delete(buf);
  1187cd:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1187d0:	89 04 24             	mov    %eax,(%esp)
  1187d3:	e8 a8 d0 ff ff       	call   115880 <netbuf_delete>
    break;
  1187d8:	eb 2f                	jmp    118809 <lwip_send+0xd9>
  case NETCONN_TCP:
    err = netconn_write(sock->conn, data, size, NETCONN_COPY);
  1187da:	8b 45 10             	mov    0x10(%ebp),%eax
  1187dd:	0f b7 d0             	movzwl %ax,%edx
  1187e0:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  1187e3:	8b 08                	mov    (%eax),%ecx
  1187e5:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
  1187ec:	00 
  1187ed:	89 54 24 08          	mov    %edx,0x8(%esp)
  1187f1:	8b 45 0c             	mov    0xc(%ebp),%eax
  1187f4:	89 44 24 04          	mov    %eax,0x4(%esp)
  1187f8:	89 0c 24             	mov    %ecx,(%esp)
  1187fb:	e8 d0 df ff ff       	call   1167d0 <netconn_write>
  118800:	88 45 ff             	mov    %al,0xffffffff(%ebp)
    break;
  118803:	eb 04                	jmp    118809 <lwip_send+0xd9>
  default:
    err = ERR_ARG;
  118805:	c6 45 ff f8          	movb   $0xf8,0xffffffff(%ebp)
    break;
  }
  if (err != ERR_OK) {
  118809:	80 7d ff 00          	cmpb   $0x0,0xffffffff(%ebp)
  11880d:	74 33                	je     118842 <lwip_send+0x112>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d) err=%d\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
  11880f:	0f b6 45 ff          	movzbl 0xffffffff(%ebp),%eax
  118813:	3c 0a                	cmp    $0xa,%al
  118815:	77 12                	ja     118829 <lwip_send+0xf9>
  118817:	0f be 45 ff          	movsbl 0xffffffff(%ebp),%eax
  11881b:	f7 d8                	neg    %eax
  11881d:	8b 04 85 40 cc 11 00 	mov    0x11cc40(,%eax,4),%eax
  118824:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  118827:	eb 07                	jmp    118830 <lwip_send+0x100>
  118829:	c7 45 ec 05 00 00 00 	movl   $0x5,0xffffffec(%ebp)
  118830:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  118833:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
  118836:	89 50 10             	mov    %edx,0x10(%eax)
    return -1;
  118839:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,0xffffffe4(%ebp)
  118840:	eb 10                	jmp    118852 <lwip_send+0x122>
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d) ok size=%d\n", s, size));
  sock_set_errno(sock, 0);
  118842:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  118845:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  return size;
  11884c:	8b 45 10             	mov    0x10(%ebp),%eax
  11884f:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
  118852:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
}
  118855:	c9                   	leave  
  118856:	c3                   	ret    
  118857:	89 f6                	mov    %esi,%esi
  118859:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00118860 <lwip_sendto>:

int
lwip_sendto(int s, void *data, int size, unsigned int flags,
       struct sockaddr *to, socklen_t tolen)
{
  118860:	55                   	push   %ebp
  118861:	89 e5                	mov    %esp,%ebp
  118863:	83 ec 38             	sub    $0x38,%esp
  struct lwip_socket *sock;
  struct ip_addr remote_addr, addr;
  u16_t remote_port, port;
  int ret,connected;

  sock = get_socket(s);
  118866:	8b 45 08             	mov    0x8(%ebp),%eax
  118869:	89 04 24             	mov    %eax,(%esp)
  11886c:	e8 6f f6 ff ff       	call   117ee0 <get_socket>
  118871:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
  if (!sock) {
  118874:	83 7d f0 00          	cmpl   $0x0,0xfffffff0(%ebp)
  118878:	75 0c                	jne    118886 <lwip_sendto+0x26>
    set_errno(EBADF);
    return -1;
  11887a:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,0xffffffdc(%ebp)
  118881:	e9 be 00 00 00       	jmp    118944 <lwip_sendto+0xe4>
  }

  /* get the peer if currently connected */
  connected = (netconn_peer(sock->conn, &addr, &port) == ERR_OK);
  118886:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  118889:	8b 10                	mov    (%eax),%edx
  11888b:	8d 45 e6             	lea    0xffffffe6(%ebp),%eax
  11888e:	89 44 24 08          	mov    %eax,0x8(%esp)
  118892:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
  118895:	89 44 24 04          	mov    %eax,0x4(%esp)
  118899:	89 14 24             	mov    %edx,(%esp)
  11889c:	e8 2f d7 ff ff       	call   115fd0 <netconn_peer>
  1188a1:	84 c0                	test   %al,%al
  1188a3:	0f 94 c0             	sete   %al
  1188a6:	0f b6 c0             	movzbl %al,%eax
  1188a9:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)

  remote_addr.addr = ((struct sockaddr_in *)to)->sin_addr.s_addr;
  1188ac:	8b 45 18             	mov    0x18(%ebp),%eax
  1188af:	8b 40 04             	mov    0x4(%eax),%eax
  1188b2:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  remote_port = ((struct sockaddr_in *)to)->sin_port;
  1188b5:	8b 45 18             	mov    0x18(%ebp),%eax
  1188b8:	0f b7 40 02          	movzwl 0x2(%eax),%eax
  1188bc:	66 89 45 f6          	mov    %ax,0xfffffff6(%ebp)

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_sendto(%d, data=%p, size=%d, flags=0x%x to=", s, data, size, flags));
  ip_addr_debug_print(SOCKETS_DEBUG, &remote_addr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u\n", ntohs(remote_port)));

  netconn_connect(sock->conn, &remote_addr, ntohs(remote_port));
  1188c0:	0f b7 45 f6          	movzwl 0xfffffff6(%ebp),%eax
  1188c4:	89 04 24             	mov    %eax,(%esp)
  1188c7:	e8 d4 59 ff ff       	call   10e2a0 <ntohs>
  1188cc:	0f b7 d0             	movzwl %ax,%edx
  1188cf:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  1188d2:	8b 08                	mov    (%eax),%ecx
  1188d4:	89 54 24 08          	mov    %edx,0x8(%esp)
  1188d8:	8d 45 ec             	lea    0xffffffec(%ebp),%eax
  1188db:	89 44 24 04          	mov    %eax,0x4(%esp)
  1188df:	89 0c 24             	mov    %ecx,(%esp)
  1188e2:	e8 29 d9 ff ff       	call   116210 <netconn_connect>

  ret = lwip_send(s, data, size, flags);
  1188e7:	8b 45 14             	mov    0x14(%ebp),%eax
  1188ea:	89 44 24 0c          	mov    %eax,0xc(%esp)
  1188ee:	8b 45 10             	mov    0x10(%ebp),%eax
  1188f1:	89 44 24 08          	mov    %eax,0x8(%esp)
  1188f5:	8b 45 0c             	mov    0xc(%ebp),%eax
  1188f8:	89 44 24 04          	mov    %eax,0x4(%esp)
  1188fc:	8b 45 08             	mov    0x8(%ebp),%eax
  1188ff:	89 04 24             	mov    %eax,(%esp)
  118902:	e8 29 fe ff ff       	call   118730 <lwip_send>
  118907:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)

  /* reset the remote address and port number
     of the connection */
  if (connected)
  11890a:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  11890e:	74 21                	je     118931 <lwip_sendto+0xd1>
    netconn_connect(sock->conn, &addr, port);
  118910:	0f b7 45 e6          	movzwl 0xffffffe6(%ebp),%eax
  118914:	0f b7 d0             	movzwl %ax,%edx
  118917:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  11891a:	8b 08                	mov    (%eax),%ecx
  11891c:	89 54 24 08          	mov    %edx,0x8(%esp)
  118920:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
  118923:	89 44 24 04          	mov    %eax,0x4(%esp)
  118927:	89 0c 24             	mov    %ecx,(%esp)
  11892a:	e8 e1 d8 ff ff       	call   116210 <netconn_connect>
  11892f:	eb 0d                	jmp    11893e <lwip_sendto+0xde>
  else
  netconn_disconnect(sock->conn);
  118931:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  118934:	8b 00                	mov    (%eax),%eax
  118936:	89 04 24             	mov    %eax,(%esp)
  118939:	e8 b2 d9 ff ff       	call   1162f0 <netconn_disconnect>
  return ret;
  11893e:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  118941:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
  118944:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
}
  118947:	c9                   	leave  
  118948:	c3                   	ret    
  118949:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

00118950 <lwip_socket>:

int
lwip_socket(int domain, int type, int protocol)
{
  118950:	55                   	push   %ebp
  118951:	89 e5                	mov    %esp,%ebp
  118953:	83 ec 28             	sub    $0x28,%esp
  struct netconn *conn;
  int i;

  /* create a netconn */
  switch (type) {
  118956:	8b 45 0c             	mov    0xc(%ebp),%eax
  118959:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
  11895c:	83 7d e8 02          	cmpl   $0x2,0xffffffe8(%ebp)
  118960:	74 31                	je     118993 <lwip_socket+0x43>
  118962:	83 7d e8 03          	cmpl   $0x3,0xffffffe8(%ebp)
  118966:	74 08                	je     118970 <lwip_socket+0x20>
  118968:	83 7d e8 01          	cmpl   $0x1,0xffffffe8(%ebp)
  11896c:	74 3e                	je     1189ac <lwip_socket+0x5c>
  11896e:	eb 55                	jmp    1189c5 <lwip_socket+0x75>
  case SOCK_RAW:
    conn = netconn_new_with_proto_and_callback(NETCONN_RAW, protocol, event_callback);
  118970:	8b 45 10             	mov    0x10(%ebp),%eax
  118973:	0f b7 c0             	movzwl %ax,%eax
  118976:	c7 44 24 08 10 90 11 	movl   $0x119010,0x8(%esp)
  11897d:	00 
  11897e:	89 44 24 04          	mov    %eax,0x4(%esp)
  118982:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  118989:	e8 c2 d2 ff ff       	call   115c50 <netconn_new_with_proto_and_callback>
  11898e:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_RAW, %d) = ", domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    break;
  118991:	eb 3b                	jmp    1189ce <lwip_socket+0x7e>
  case SOCK_DGRAM:
    conn = netconn_new_with_callback(NETCONN_UDP, event_callback);
  118993:	c7 44 24 04 10 90 11 	movl   $0x119010,0x4(%esp)
  11899a:	00 
  11899b:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  1189a2:	e8 59 d4 ff ff       	call   115e00 <netconn_new_with_callback>
  1189a7:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_DGRAM, %d) = ", domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    break;
  1189aa:	eb 22                	jmp    1189ce <lwip_socket+0x7e>
  case SOCK_STREAM:
    conn = netconn_new_with_callback(NETCONN_TCP, event_callback);
  1189ac:	c7 44 24 04 10 90 11 	movl   $0x119010,0x4(%esp)
  1189b3:	00 
  1189b4:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  1189bb:	e8 40 d4 ff ff       	call   115e00 <netconn_new_with_callback>
  1189c0:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_STREAM, %d) = ", domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    break;
  1189c3:	eb 09                	jmp    1189ce <lwip_socket+0x7e>
  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%d, %d/UNKNOWN, %d) = -1\n", domain, type, protocol));
    set_errno(EINVAL);
    return -1;
  1189c5:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  1189cc:	eb 46                	jmp    118a14 <lwip_socket+0xc4>
  }

  if (!conn) {
  1189ce:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  1189d2:	75 09                	jne    1189dd <lwip_socket+0x8d>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("-1 / ENOBUFS (could not create netconn)\n"));
    set_errno(ENOBUFS);
    return -1;
  1189d4:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  1189db:	eb 37                	jmp    118a14 <lwip_socket+0xc4>
  }

  i = alloc_socket(conn);
  1189dd:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1189e0:	89 04 24             	mov    %eax,(%esp)
  1189e3:	e8 48 f5 ff ff       	call   117f30 <alloc_socket>
  1189e8:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)

  if (i == -1) {
  1189eb:	83 7d fc ff          	cmpl   $0xffffffff,0xfffffffc(%ebp)
  1189ef:	75 14                	jne    118a05 <lwip_socket+0xb5>
    netconn_delete(conn);
  1189f1:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1189f4:	89 04 24             	mov    %eax,(%esp)
  1189f7:	e8 34 d4 ff ff       	call   115e30 <netconn_delete>
  set_errno(ENOBUFS);
  return -1;
  1189fc:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  118a03:	eb 0f                	jmp    118a14 <lwip_socket+0xc4>
  }
  conn->socket = i;
  118a05:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  118a08:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  118a0b:	89 42 20             	mov    %eax,0x20(%edx)
  LWIP_DEBUGF(SOCKETS_DEBUG, ("%d\n", i));
  set_errno(0);
  return i;
  118a0e:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  118a11:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  118a14:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  118a17:	c9                   	leave  
  118a18:	c3                   	ret    
  118a19:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

00118a20 <lwip_write>:

int
lwip_write(int s, void *data, int size)
{
  118a20:	55                   	push   %ebp
  118a21:	89 e5                	mov    %esp,%ebp
  118a23:	83 ec 18             	sub    $0x18,%esp
   return lwip_send(s, data, size, 0);
  118a26:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  118a2d:	00 
  118a2e:	8b 45 10             	mov    0x10(%ebp),%eax
  118a31:	89 44 24 08          	mov    %eax,0x8(%esp)
  118a35:	8b 45 0c             	mov    0xc(%ebp),%eax
  118a38:	89 44 24 04          	mov    %eax,0x4(%esp)
  118a3c:	8b 45 08             	mov    0x8(%ebp),%eax
  118a3f:	89 04 24             	mov    %eax,(%esp)
  118a42:	e8 e9 fc ff ff       	call   118730 <lwip_send>
}
  118a47:	c9                   	leave  
  118a48:	c3                   	ret    
  118a49:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

00118a50 <lwip_selscan>:


static int
lwip_selscan(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset)
{
  118a50:	55                   	push   %ebp
  118a51:	89 e5                	mov    %esp,%ebp
  118a53:	53                   	push   %ebx
  118a54:	83 ec 34             	sub    $0x34,%esp
    int i, nready = 0;
  118a57:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
    fd_set lreadset, lwriteset, lexceptset;
    struct lwip_socket *p_sock;

    FD_ZERO(&lreadset);
  118a5e:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
  118a65:	00 
  118a66:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  118a6d:	00 
  118a6e:	8d 45 ee             	lea    0xffffffee(%ebp),%eax
  118a71:	89 04 24             	mov    %eax,(%esp)
  118a74:	e8 87 d4 fe ff       	call   105f00 <memset>
    FD_ZERO(&lwriteset);
  118a79:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
  118a80:	00 
  118a81:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  118a88:	00 
  118a89:	8d 45 ec             	lea    0xffffffec(%ebp),%eax
  118a8c:	89 04 24             	mov    %eax,(%esp)
  118a8f:	e8 6c d4 fe ff       	call   105f00 <memset>
    FD_ZERO(&lexceptset);
  118a94:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
  118a9b:	00 
  118a9c:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  118aa3:	00 
  118aa4:	8d 45 ea             	lea    0xffffffea(%ebp),%eax
  118aa7:	89 04 24             	mov    %eax,(%esp)
  118aaa:	e8 51 d4 fe ff       	call   105f00 <memset>

    /* Go through each socket in each list to count number of sockets which
       currently match */
    for(i = 0; i < maxfdp1; i++)
  118aaf:	c7 45 f0 00 00 00 00 	movl   $0x0,0xfffffff0(%ebp)
  118ab6:	e9 04 01 00 00       	jmp    118bbf <lwip_selscan+0x16f>
    {
        if (FD_ISSET(i, readset))
  118abb:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
  118abe:	89 d0                	mov    %edx,%eax
  118ac0:	c1 f8 1f             	sar    $0x1f,%eax
  118ac3:	c1 e8 1d             	shr    $0x1d,%eax
  118ac6:	01 d0                	add    %edx,%eax
  118ac8:	c1 f8 03             	sar    $0x3,%eax
  118acb:	89 c2                	mov    %eax,%edx
  118acd:	8b 45 0c             	mov    0xc(%ebp),%eax
  118ad0:	0f b6 04 10          	movzbl (%eax,%edx,1),%eax
  118ad4:	0f b6 c0             	movzbl %al,%eax
  118ad7:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
  118ada:	83 e1 07             	and    $0x7,%ecx
  118add:	d3 f8                	sar    %cl,%eax
  118adf:	83 e0 01             	and    $0x1,%eax
  118ae2:	84 c0                	test   %al,%al
  118ae4:	74 5a                	je     118b40 <lwip_selscan+0xf0>
        {
            /* See if netconn of this socket is ready for read */
            p_sock = get_socket(i);
  118ae6:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  118ae9:	89 04 24             	mov    %eax,(%esp)
  118aec:	e8 ef f3 ff ff       	call   117ee0 <get_socket>
  118af1:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
            if (p_sock && (p_sock->lastdata || p_sock->rcvevent))
  118af4:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  118af8:	74 46                	je     118b40 <lwip_selscan+0xf0>
  118afa:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  118afd:	8b 40 04             	mov    0x4(%eax),%eax
  118b00:	85 c0                	test   %eax,%eax
  118b02:	75 0c                	jne    118b10 <lwip_selscan+0xc0>
  118b04:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  118b07:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  118b0b:	66 85 c0             	test   %ax,%ax
  118b0e:	74 30                	je     118b40 <lwip_selscan+0xf0>
            {
                FD_SET(i, &lreadset);
  118b10:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
  118b13:	89 d0                	mov    %edx,%eax
  118b15:	c1 f8 1f             	sar    $0x1f,%eax
  118b18:	c1 e8 1d             	shr    $0x1d,%eax
  118b1b:	01 d0                	add    %edx,%eax
  118b1d:	c1 f8 03             	sar    $0x3,%eax
  118b20:	89 c3                	mov    %eax,%ebx
  118b22:	0f b6 44 05 ee       	movzbl 0xffffffee(%ebp,%eax,1),%eax
  118b27:	89 c2                	mov    %eax,%edx
  118b29:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
  118b2c:	83 e1 07             	and    $0x7,%ecx
  118b2f:	b8 01 00 00 00       	mov    $0x1,%eax
  118b34:	d3 e0                	shl    %cl,%eax
  118b36:	09 d0                	or     %edx,%eax
  118b38:	88 44 1d ee          	mov    %al,0xffffffee(%ebp,%ebx,1)
		LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for reading\n", i));
                nready++;
  118b3c:	83 45 f4 01          	addl   $0x1,0xfffffff4(%ebp)
            }
        }
        if (FD_ISSET(i, writeset))
  118b40:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
  118b43:	89 d0                	mov    %edx,%eax
  118b45:	c1 f8 1f             	sar    $0x1f,%eax
  118b48:	c1 e8 1d             	shr    $0x1d,%eax
  118b4b:	01 d0                	add    %edx,%eax
  118b4d:	c1 f8 03             	sar    $0x3,%eax
  118b50:	89 c2                	mov    %eax,%edx
  118b52:	8b 45 10             	mov    0x10(%ebp),%eax
  118b55:	0f b6 04 10          	movzbl (%eax,%edx,1),%eax
  118b59:	0f b6 c0             	movzbl %al,%eax
  118b5c:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
  118b5f:	83 e1 07             	and    $0x7,%ecx
  118b62:	d3 f8                	sar    %cl,%eax
  118b64:	83 e0 01             	and    $0x1,%eax
  118b67:	84 c0                	test   %al,%al
  118b69:	74 50                	je     118bbb <lwip_selscan+0x16b>
        {
            /* See if netconn of this socket is ready for write */
            p_sock = get_socket(i);
  118b6b:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  118b6e:	89 04 24             	mov    %eax,(%esp)
  118b71:	e8 6a f3 ff ff       	call   117ee0 <get_socket>
  118b76:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
            if (p_sock && p_sock->sendevent)
  118b79:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  118b7d:	74 3c                	je     118bbb <lwip_selscan+0x16b>
  118b7f:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  118b82:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  118b86:	66 85 c0             	test   %ax,%ax
  118b89:	74 30                	je     118bbb <lwip_selscan+0x16b>
            {
                FD_SET(i, &lwriteset);
  118b8b:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
  118b8e:	89 d0                	mov    %edx,%eax
  118b90:	c1 f8 1f             	sar    $0x1f,%eax
  118b93:	c1 e8 1d             	shr    $0x1d,%eax
  118b96:	01 d0                	add    %edx,%eax
  118b98:	c1 f8 03             	sar    $0x3,%eax
  118b9b:	89 c3                	mov    %eax,%ebx
  118b9d:	0f b6 44 05 ec       	movzbl 0xffffffec(%ebp,%eax,1),%eax
  118ba2:	89 c2                	mov    %eax,%edx
  118ba4:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
  118ba7:	83 e1 07             	and    $0x7,%ecx
  118baa:	b8 01 00 00 00       	mov    $0x1,%eax
  118baf:	d3 e0                	shl    %cl,%eax
  118bb1:	09 d0                	or     %edx,%eax
  118bb3:	88 44 1d ec          	mov    %al,0xffffffec(%ebp,%ebx,1)
		LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for writing\n", i));
                nready++;
  118bb7:	83 45 f4 01          	addl   $0x1,0xfffffff4(%ebp)
  118bbb:	83 45 f0 01          	addl   $0x1,0xfffffff0(%ebp)
  118bbf:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  118bc2:	3b 45 08             	cmp    0x8(%ebp),%eax
  118bc5:	0f 8c f0 fe ff ff    	jl     118abb <lwip_selscan+0x6b>
            }
        }
    }
    *readset = lreadset;
  118bcb:	8b 55 0c             	mov    0xc(%ebp),%edx
  118bce:	0f b7 45 ee          	movzwl 0xffffffee(%ebp),%eax
  118bd2:	66 89 02             	mov    %ax,(%edx)
    *writeset = lwriteset;
  118bd5:	8b 55 10             	mov    0x10(%ebp),%edx
  118bd8:	0f b7 45 ec          	movzwl 0xffffffec(%ebp),%eax
  118bdc:	66 89 02             	mov    %ax,(%edx)
    FD_ZERO(exceptset);
  118bdf:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
  118be6:	00 
  118be7:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  118bee:	00 
  118bef:	8b 45 14             	mov    0x14(%ebp),%eax
  118bf2:	89 04 24             	mov    %eax,(%esp)
  118bf5:	e8 06 d3 fe ff       	call   105f00 <memset>

    return nready;
  118bfa:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
}
  118bfd:	83 c4 34             	add    $0x34,%esp
  118c00:	5b                   	pop    %ebx
  118c01:	5d                   	pop    %ebp
  118c02:	c3                   	ret    
  118c03:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  118c09:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00118c10 <lwip_select>:



int
lwip_select(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset,
               struct timeval *timeout)
{
  118c10:	55                   	push   %ebp
  118c11:	89 e5                	mov    %esp,%ebp
  118c13:	53                   	push   %ebx
  118c14:	83 ec 54             	sub    $0x54,%esp
    int i;
    int nready;
    fd_set lreadset, lwriteset, lexceptset;
    u32_t msectimeout;
    struct lwip_select_cb select_cb;
    struct lwip_select_cb *p_selcb;

    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select(%d, %p, %p, %p, tvsec=%ld tvusec=%ld)\n", maxfdp1, (void *)readset, (void *) writeset, (void *) exceptset, timeout ? timeout->tv_sec : -1L, timeout ? timeout->tv_usec : -1L));

    select_cb.next = 0;
  118c17:	c7 45 cc 00 00 00 00 	movl   $0x0,0xffffffcc(%ebp)
    select_cb.readset = readset;
  118c1e:	8b 45 0c             	mov    0xc(%ebp),%eax
  118c21:	89 45 d0             	mov    %eax,0xffffffd0(%ebp)
    select_cb.writeset = writeset;
  118c24:	8b 45 10             	mov    0x10(%ebp),%eax
  118c27:	89 45 d4             	mov    %eax,0xffffffd4(%ebp)
    select_cb.exceptset = exceptset;
  118c2a:	8b 45 14             	mov    0x14(%ebp),%eax
  118c2d:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
    select_cb.sem_signalled = 0;
  118c30:	c7 45 dc 00 00 00 00 	movl   $0x0,0xffffffdc(%ebp)

    /* Protect ourselves searching through the list */
    if (!selectsem)
  118c37:	a1 48 99 13 00       	mov    0x139948,%eax
  118c3c:	85 c0                	test   %eax,%eax
  118c3e:	75 11                	jne    118c51 <lwip_select+0x41>
        selectsem = sys_sem_new(1);
  118c40:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  118c47:	e8 f4 10 00 00       	call   119d40 <sys_sem_new>
  118c4c:	a3 48 99 13 00       	mov    %eax,0x139948
    sys_sem_wait(selectsem);
  118c51:	a1 48 99 13 00       	mov    0x139948,%eax
  118c56:	89 04 24             	mov    %eax,(%esp)
  118c59:	e8 a2 71 ff ff       	call   10fe00 <sys_sem_wait>

    if (readset)
  118c5e:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  118c62:	74 0c                	je     118c70 <lwip_select+0x60>
        lreadset = *readset;
  118c64:	8b 45 0c             	mov    0xc(%ebp),%eax
  118c67:	0f b7 00             	movzwl (%eax),%eax
  118c6a:	66 89 45 ea          	mov    %ax,0xffffffea(%ebp)
  118c6e:	eb 1b                	jmp    118c8b <lwip_select+0x7b>
    else
        FD_ZERO(&lreadset);
  118c70:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
  118c77:	00 
  118c78:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  118c7f:	00 
  118c80:	8d 45 ea             	lea    0xffffffea(%ebp),%eax
  118c83:	89 04 24             	mov    %eax,(%esp)
  118c86:	e8 75 d2 fe ff       	call   105f00 <memset>
    if (writeset)
  118c8b:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  118c8f:	74 0c                	je     118c9d <lwip_select+0x8d>
        lwriteset = *writeset;
  118c91:	8b 45 10             	mov    0x10(%ebp),%eax
  118c94:	0f b7 00             	movzwl (%eax),%eax
  118c97:	66 89 45 e8          	mov    %ax,0xffffffe8(%ebp)
  118c9b:	eb 1b                	jmp    118cb8 <lwip_select+0xa8>
    else
        FD_ZERO(&lwriteset);
  118c9d:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
  118ca4:	00 
  118ca5:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  118cac:	00 
  118cad:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
  118cb0:	89 04 24             	mov    %eax,(%esp)
  118cb3:	e8 48 d2 fe ff       	call   105f00 <memset>
    if (exceptset)
  118cb8:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
  118cbc:	74 0c                	je     118cca <lwip_select+0xba>
        lexceptset = *exceptset;
  118cbe:	8b 45 14             	mov    0x14(%ebp),%eax
  118cc1:	0f b7 00             	movzwl (%eax),%eax
  118cc4:	66 89 45 e6          	mov    %ax,0xffffffe6(%ebp)
  118cc8:	eb 1b                	jmp    118ce5 <lwip_select+0xd5>
    else
        FD_ZERO(&lexceptset);
  118cca:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
  118cd1:	00 
  118cd2:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  118cd9:	00 
  118cda:	8d 45 e6             	lea    0xffffffe6(%ebp),%eax
  118cdd:	89 04 24             	mov    %eax,(%esp)
  118ce0:	e8 1b d2 fe ff       	call   105f00 <memset>

    /* Go through each socket in each list to count number of sockets which
       currently match */
    nready = lwip_selscan(maxfdp1, &lreadset, &lwriteset, &lexceptset);
  118ce5:	8d 45 e6             	lea    0xffffffe6(%ebp),%eax
  118ce8:	89 44 24 0c          	mov    %eax,0xc(%esp)
  118cec:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
  118cef:	89 44 24 08          	mov    %eax,0x8(%esp)
  118cf3:	8d 45 ea             	lea    0xffffffea(%ebp),%eax
  118cf6:	89 44 24 04          	mov    %eax,0x4(%esp)
  118cfa:	8b 45 08             	mov    0x8(%ebp),%eax
  118cfd:	89 04 24             	mov    %eax,(%esp)
  118d00:	e8 4b fd ff ff       	call   118a50 <lwip_selscan>
  118d05:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)

    /* If we don't have any current events, then suspend if we are supposed to */
    if (!nready)
  118d08:	83 7d f0 00          	cmpl   $0x0,0xfffffff0(%ebp)
  118d0c:	0f 85 af 02 00 00    	jne    118fc1 <lwip_select+0x3b1>
    {
        if (timeout && timeout->tv_sec == 0 && timeout->tv_usec == 0)
  118d12:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
  118d16:	0f 84 93 00 00 00    	je     118daf <lwip_select+0x19f>
  118d1c:	8b 45 18             	mov    0x18(%ebp),%eax
  118d1f:	8b 00                	mov    (%eax),%eax
  118d21:	85 c0                	test   %eax,%eax
  118d23:	0f 85 86 00 00 00    	jne    118daf <lwip_select+0x19f>
  118d29:	8b 45 18             	mov    0x18(%ebp),%eax
  118d2c:	8b 40 04             	mov    0x4(%eax),%eax
  118d2f:	85 c0                	test   %eax,%eax
  118d31:	75 7c                	jne    118daf <lwip_select+0x19f>
        {
            sys_sem_signal(selectsem);
  118d33:	a1 48 99 13 00       	mov    0x139948,%eax
  118d38:	89 04 24             	mov    %eax,(%esp)
  118d3b:	e8 80 10 00 00       	call   119dc0 <sys_sem_signal>
            if (readset)
  118d40:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  118d44:	74 1b                	je     118d61 <lwip_select+0x151>
                FD_ZERO(readset);
  118d46:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
  118d4d:	00 
  118d4e:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  118d55:	00 
  118d56:	8b 45 0c             	mov    0xc(%ebp),%eax
  118d59:	89 04 24             	mov    %eax,(%esp)
  118d5c:	e8 9f d1 fe ff       	call   105f00 <memset>
            if (writeset)
  118d61:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  118d65:	74 1b                	je     118d82 <lwip_select+0x172>
                FD_ZERO(writeset);
  118d67:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
  118d6e:	00 
  118d6f:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  118d76:	00 
  118d77:	8b 45 10             	mov    0x10(%ebp),%eax
  118d7a:	89 04 24             	mov    %eax,(%esp)
  118d7d:	e8 7e d1 fe ff       	call   105f00 <memset>
            if (exceptset)
  118d82:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
  118d86:	74 1b                	je     118da3 <lwip_select+0x193>
                FD_ZERO(exceptset);
  118d88:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
  118d8f:	00 
  118d90:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  118d97:	00 
  118d98:	8b 45 14             	mov    0x14(%ebp),%eax
  118d9b:	89 04 24             	mov    %eax,(%esp)
  118d9e:	e8 5d d1 fe ff       	call   105f00 <memset>

	    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: no timeout, returning 0\n"));
	    set_errno(0);

            return 0;
  118da3:	c7 45 c8 00 00 00 00 	movl   $0x0,0xffffffc8(%ebp)
  118daa:	e9 55 02 00 00       	jmp    119004 <lwip_select+0x3f4>
        }

        /* add our semaphore to list */
        /* We don't actually need any dynamic memory. Our entry on the
         * list is only valid while we are in this function, so it's ok
         * to use local variables */

        select_cb.sem = sys_sem_new(0);
  118daf:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  118db6:	e8 85 0f 00 00       	call   119d40 <sys_sem_new>
  118dbb:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
        /* Note that we are still protected */
        /* Put this select_cb on top of list */
        select_cb.next = select_cb_list;
  118dbe:	a1 40 99 13 00       	mov    0x139940,%eax
  118dc3:	89 45 cc             	mov    %eax,0xffffffcc(%ebp)
        select_cb_list = &select_cb;
  118dc6:	8d 45 cc             	lea    0xffffffcc(%ebp),%eax
  118dc9:	a3 40 99 13 00       	mov    %eax,0x139940

        /* Now we can safely unprotect */
        sys_sem_signal(selectsem);
  118dce:	a1 48 99 13 00       	mov    0x139948,%eax
  118dd3:	89 04 24             	mov    %eax,(%esp)
  118dd6:	e8 e5 0f 00 00       	call   119dc0 <sys_sem_signal>

        /* Now just wait to be woken */
        if (timeout == 0)
  118ddb:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
  118ddf:	75 09                	jne    118dea <lwip_select+0x1da>
            /* Wait forever */
            msectimeout = 0;
  118de1:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
  118de8:	eb 37                	jmp    118e21 <lwip_select+0x211>
        else
            msectimeout =  ((timeout->tv_sec * 1000) + ((timeout->tv_usec + 500)/1000));
  118dea:	8b 45 18             	mov    0x18(%ebp),%eax
  118ded:	8b 00                	mov    (%eax),%eax
  118def:	69 d8 e8 03 00 00    	imul   $0x3e8,%eax,%ebx
  118df5:	8b 45 18             	mov    0x18(%ebp),%eax
  118df8:	8b 40 04             	mov    0x4(%eax),%eax
  118dfb:	8d 88 f4 01 00 00    	lea    0x1f4(%eax),%ecx
  118e01:	c7 45 c4 d3 4d 62 10 	movl   $0x10624dd3,0xffffffc4(%ebp)
  118e08:	8b 45 c4             	mov    0xffffffc4(%ebp),%eax
  118e0b:	f7 e9                	imul   %ecx
  118e0d:	c1 fa 06             	sar    $0x6,%edx
  118e10:	89 c8                	mov    %ecx,%eax
  118e12:	c1 f8 1f             	sar    $0x1f,%eax
  118e15:	89 d1                	mov    %edx,%ecx
  118e17:	29 c1                	sub    %eax,%ecx
  118e19:	89 c8                	mov    %ecx,%eax
  118e1b:	8d 04 03             	lea    (%ebx,%eax,1),%eax
  118e1e:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)

        i = sys_sem_wait_timeout(select_cb.sem, msectimeout);
  118e21:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
  118e24:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  118e27:	89 44 24 04          	mov    %eax,0x4(%esp)
  118e2b:	89 14 24             	mov    %edx,(%esp)
  118e2e:	e8 cd 72 ff ff       	call   110100 <sys_sem_wait_timeout>
  118e33:	89 45 ec             	mov    %eax,0xffffffec(%ebp)

        /* Take us off the list */
        sys_sem_wait(selectsem);
  118e36:	a1 48 99 13 00       	mov    0x139948,%eax
  118e3b:	89 04 24             	mov    %eax,(%esp)
  118e3e:	e8 bd 6f ff ff       	call   10fe00 <sys_sem_wait>
        if (select_cb_list == &select_cb)
  118e43:	8b 15 40 99 13 00    	mov    0x139940,%edx
  118e49:	8d 45 cc             	lea    0xffffffcc(%ebp),%eax
  118e4c:	39 d0                	cmp    %edx,%eax
  118e4e:	75 0a                	jne    118e5a <lwip_select+0x24a>
            select_cb_list = select_cb.next;
  118e50:	8b 45 cc             	mov    0xffffffcc(%ebp),%eax
  118e53:	a3 40 99 13 00       	mov    %eax,0x139940
  118e58:	eb 2e                	jmp    118e88 <lwip_select+0x278>
        else
            for (p_selcb = select_cb_list; p_selcb; p_selcb = p_selcb->next)
  118e5a:	a1 40 99 13 00       	mov    0x139940,%eax
  118e5f:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  118e62:	eb 1e                	jmp    118e82 <lwip_select+0x272>
                if (p_selcb->next == &select_cb)
  118e64:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  118e67:	8b 10                	mov    (%eax),%edx
  118e69:	8d 45 cc             	lea    0xffffffcc(%ebp),%eax
  118e6c:	39 c2                	cmp    %eax,%edx
  118e6e:	75 0a                	jne    118e7a <lwip_select+0x26a>
                {
                    p_selcb->next = select_cb.next;
  118e70:	8b 55 cc             	mov    0xffffffcc(%ebp),%edx
  118e73:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  118e76:	89 10                	mov    %edx,(%eax)
                    break;
  118e78:	eb 0e                	jmp    118e88 <lwip_select+0x278>
  118e7a:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  118e7d:	8b 00                	mov    (%eax),%eax
  118e7f:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  118e82:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  118e86:	75 dc                	jne    118e64 <lwip_select+0x254>
                }

        sys_sem_signal(selectsem);
  118e88:	a1 48 99 13 00       	mov    0x139948,%eax
  118e8d:	89 04 24             	mov    %eax,(%esp)
  118e90:	e8 2b 0f 00 00       	call   119dc0 <sys_sem_signal>

        sys_sem_free(select_cb.sem);
  118e95:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  118e98:	89 04 24             	mov    %eax,(%esp)
  118e9b:	e8 f0 0e 00 00       	call   119d90 <sys_sem_free>
        if (i == 0)             /* Timeout */
  118ea0:	83 7d ec 00          	cmpl   $0x0,0xffffffec(%ebp)
  118ea4:	75 6f                	jne    118f15 <lwip_select+0x305>
        {
            if (readset)
  118ea6:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  118eaa:	74 1b                	je     118ec7 <lwip_select+0x2b7>
                FD_ZERO(readset);
  118eac:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
  118eb3:	00 
  118eb4:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  118ebb:	00 
  118ebc:	8b 45 0c             	mov    0xc(%ebp),%eax
  118ebf:	89 04 24             	mov    %eax,(%esp)
  118ec2:	e8 39 d0 fe ff       	call   105f00 <memset>
            if (writeset)
  118ec7:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  118ecb:	74 1b                	je     118ee8 <lwip_select+0x2d8>
                FD_ZERO(writeset);
  118ecd:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
  118ed4:	00 
  118ed5:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  118edc:	00 
  118edd:	8b 45 10             	mov    0x10(%ebp),%eax
  118ee0:	89 04 24             	mov    %eax,(%esp)
  118ee3:	e8 18 d0 fe ff       	call   105f00 <memset>
            if (exceptset)
  118ee8:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
  118eec:	74 1b                	je     118f09 <lwip_select+0x2f9>
                FD_ZERO(exceptset);
  118eee:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
  118ef5:	00 
  118ef6:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  118efd:	00 
  118efe:	8b 45 14             	mov    0x14(%ebp),%eax
  118f01:	89 04 24             	mov    %eax,(%esp)
  118f04:	e8 f7 cf fe ff       	call   105f00 <memset>

	    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: timeout expired\n"));
	    set_errno(0);

            return 0;
  118f09:	c7 45 c8 00 00 00 00 	movl   $0x0,0xffffffc8(%ebp)
  118f10:	e9 ef 00 00 00       	jmp    119004 <lwip_select+0x3f4>
        }

        if (readset)
  118f15:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  118f19:	74 0c                	je     118f27 <lwip_select+0x317>
            lreadset = *readset;
  118f1b:	8b 45 0c             	mov    0xc(%ebp),%eax
  118f1e:	0f b7 00             	movzwl (%eax),%eax
  118f21:	66 89 45 ea          	mov    %ax,0xffffffea(%ebp)
  118f25:	eb 1b                	jmp    118f42 <lwip_select+0x332>
        else
            FD_ZERO(&lreadset);
  118f27:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
  118f2e:	00 
  118f2f:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  118f36:	00 
  118f37:	8d 45 ea             	lea    0xffffffea(%ebp),%eax
  118f3a:	89 04 24             	mov    %eax,(%esp)
  118f3d:	e8 be cf fe ff       	call   105f00 <memset>
        if (writeset)
  118f42:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  118f46:	74 0c                	je     118f54 <lwip_select+0x344>
            lwriteset = *writeset;
  118f48:	8b 45 10             	mov    0x10(%ebp),%eax
  118f4b:	0f b7 00             	movzwl (%eax),%eax
  118f4e:	66 89 45 e8          	mov    %ax,0xffffffe8(%ebp)
  118f52:	eb 1b                	jmp    118f6f <lwip_select+0x35f>
        else
            FD_ZERO(&lwriteset);
  118f54:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
  118f5b:	00 
  118f5c:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  118f63:	00 
  118f64:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
  118f67:	89 04 24             	mov    %eax,(%esp)
  118f6a:	e8 91 cf fe ff       	call   105f00 <memset>
        if (exceptset)
  118f6f:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
  118f73:	74 0c                	je     118f81 <lwip_select+0x371>
            lexceptset = *exceptset;
  118f75:	8b 45 14             	mov    0x14(%ebp),%eax
  118f78:	0f b7 00             	movzwl (%eax),%eax
  118f7b:	66 89 45 e6          	mov    %ax,0xffffffe6(%ebp)
  118f7f:	eb 1b                	jmp    118f9c <lwip_select+0x38c>
        else
            FD_ZERO(&lexceptset);
  118f81:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
  118f88:	00 
  118f89:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  118f90:	00 
  118f91:	8d 45 e6             	lea    0xffffffe6(%ebp),%eax
  118f94:	89 04 24             	mov    %eax,(%esp)
  118f97:	e8 64 cf fe ff       	call   105f00 <memset>

        /* See what's set */
        nready = lwip_selscan(maxfdp1, &lreadset, &lwriteset, &lexceptset);
  118f9c:	8d 45 e6             	lea    0xffffffe6(%ebp),%eax
  118f9f:	89 44 24 0c          	mov    %eax,0xc(%esp)
  118fa3:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
  118fa6:	89 44 24 08          	mov    %eax,0x8(%esp)
  118faa:	8d 45 ea             	lea    0xffffffea(%ebp),%eax
  118fad:	89 44 24 04          	mov    %eax,0x4(%esp)
  118fb1:	8b 45 08             	mov    0x8(%ebp),%eax
  118fb4:	89 04 24             	mov    %eax,(%esp)
  118fb7:	e8 94 fa ff ff       	call   118a50 <lwip_selscan>
  118fbc:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
  118fbf:	eb 0d                	jmp    118fce <lwip_select+0x3be>
    }
    else
        sys_sem_signal(selectsem);
  118fc1:	a1 48 99 13 00       	mov    0x139948,%eax
  118fc6:	89 04 24             	mov    %eax,(%esp)
  118fc9:	e8 f2 0d 00 00       	call   119dc0 <sys_sem_signal>

    if (readset)
  118fce:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  118fd2:	74 0a                	je     118fde <lwip_select+0x3ce>
        *readset = lreadset;
  118fd4:	8b 55 0c             	mov    0xc(%ebp),%edx
  118fd7:	0f b7 45 ea          	movzwl 0xffffffea(%ebp),%eax
  118fdb:	66 89 02             	mov    %ax,(%edx)
    if (writeset)
  118fde:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  118fe2:	74 0a                	je     118fee <lwip_select+0x3de>
        *writeset = lwriteset;
  118fe4:	8b 55 10             	mov    0x10(%ebp),%edx
  118fe7:	0f b7 45 e8          	movzwl 0xffffffe8(%ebp),%eax
  118feb:	66 89 02             	mov    %ax,(%edx)
    if (exceptset)
  118fee:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
  118ff2:	74 0a                	je     118ffe <lwip_select+0x3ee>
        *exceptset = lexceptset;
  118ff4:	8b 55 14             	mov    0x14(%ebp),%edx
  118ff7:	0f b7 45 e6          	movzwl 0xffffffe6(%ebp),%eax
  118ffb:	66 89 02             	mov    %ax,(%edx)

    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: nready=%d\n", nready));
    set_errno(0);

    return nready;
  118ffe:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  119001:	89 45 c8             	mov    %eax,0xffffffc8(%ebp)
  119004:	8b 45 c8             	mov    0xffffffc8(%ebp),%eax
}
  119007:	83 c4 54             	add    $0x54,%esp
  11900a:	5b                   	pop    %ebx
  11900b:	5d                   	pop    %ebp
  11900c:	c3                   	ret    
  11900d:	8d 76 00             	lea    0x0(%esi),%esi

00119010 <event_callback>:


static void
event_callback(struct netconn *conn, enum netconn_evt evt, u16_t len)
{
  119010:	55                   	push   %ebp
  119011:	89 e5                	mov    %esp,%ebp
  119013:	83 ec 28             	sub    $0x28,%esp
  119016:	8b 45 10             	mov    0x10(%ebp),%eax
  119019:	66 89 45 ec          	mov    %ax,0xffffffec(%ebp)
    int s;
    struct lwip_socket *sock;
    struct lwip_select_cb *scb;

    /* Get socket */
    if (conn)
  11901d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  119021:	0f 84 ce 01 00 00    	je     1191f5 <event_callback+0x1e5>
    {
        s = conn->socket;
  119027:	8b 45 08             	mov    0x8(%ebp),%eax
  11902a:	8b 40 20             	mov    0x20(%eax),%eax
  11902d:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
        if (s < 0)
  119030:	83 7d f4 00          	cmpl   $0x0,0xfffffff4(%ebp)
  119034:	79 1e                	jns    119054 <event_callback+0x44>
        {
            /* Data comes in right away after an accept, even though
             * the server task might not have created a new socket yet.
             * Just count down (or up) if that's the case and we
             * will use the data later. Note that only receive events
             * can happen before the new socket is set up. */
            if (evt == NETCONN_EVT_RCVPLUS)
  119036:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  11903a:	0f 85 b5 01 00 00    	jne    1191f5 <event_callback+0x1e5>
                conn->socket--;
  119040:	8b 45 08             	mov    0x8(%ebp),%eax
  119043:	8b 40 20             	mov    0x20(%eax),%eax
  119046:	8d 50 ff             	lea    0xffffffff(%eax),%edx
  119049:	8b 45 08             	mov    0x8(%ebp),%eax
  11904c:	89 50 20             	mov    %edx,0x20(%eax)
            return;
  11904f:	e9 a1 01 00 00       	jmp    1191f5 <event_callback+0x1e5>
        }

        sock = get_socket(s);
  119054:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  119057:	89 04 24             	mov    %eax,(%esp)
  11905a:	e8 81 ee ff ff       	call   117ee0 <get_socket>
  11905f:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
        if (!sock)
  119062:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  119066:	0f 84 89 01 00 00    	je     1191f5 <event_callback+0x1e5>
            return;
    }
    else
        return;

    if (!selectsem)
  11906c:	a1 48 99 13 00       	mov    0x139948,%eax
  119071:	85 c0                	test   %eax,%eax
  119073:	75 11                	jne    119086 <event_callback+0x76>
        selectsem = sys_sem_new(1);
  119075:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  11907c:	e8 bf 0c 00 00       	call   119d40 <sys_sem_new>
  119081:	a3 48 99 13 00       	mov    %eax,0x139948

    sys_sem_wait(selectsem);
  119086:	a1 48 99 13 00       	mov    0x139948,%eax
  11908b:	89 04 24             	mov    %eax,(%esp)
  11908e:	e8 6d 6d ff ff       	call   10fe00 <sys_sem_wait>
    /* Set event as required */
    switch (evt)
  119093:	8b 45 0c             	mov    0xc(%ebp),%eax
  119096:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
  119099:	83 7d e8 01          	cmpl   $0x1,0xffffffe8(%ebp)
  11909d:	74 27                	je     1190c6 <event_callback+0xb6>
  11909f:	83 7d e8 01          	cmpl   $0x1,0xffffffe8(%ebp)
  1190a3:	72 0e                	jb     1190b3 <event_callback+0xa3>
  1190a5:	83 7d e8 02          	cmpl   $0x2,0xffffffe8(%ebp)
  1190a9:	74 2e                	je     1190d9 <event_callback+0xc9>
  1190ab:	83 7d e8 03          	cmpl   $0x3,0xffffffe8(%ebp)
  1190af:	74 33                	je     1190e4 <event_callback+0xd4>
  1190b1:	eb 3a                	jmp    1190ed <event_callback+0xdd>
    {
      case NETCONN_EVT_RCVPLUS:
        sock->rcvevent++;
  1190b3:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1190b6:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  1190ba:	8d 50 01             	lea    0x1(%eax),%edx
  1190bd:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1190c0:	66 89 50 0a          	mov    %dx,0xa(%eax)
        break;
  1190c4:	eb 27                	jmp    1190ed <event_callback+0xdd>
      case NETCONN_EVT_RCVMINUS:
        sock->rcvevent--;
  1190c6:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1190c9:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  1190cd:	8d 50 ff             	lea    0xffffffff(%eax),%edx
  1190d0:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1190d3:	66 89 50 0a          	mov    %dx,0xa(%eax)
        break;
  1190d7:	eb 14                	jmp    1190ed <event_callback+0xdd>
      case NETCONN_EVT_SENDPLUS:
        sock->sendevent = 1;
  1190d9:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1190dc:	66 c7 40 0c 01 00    	movw   $0x1,0xc(%eax)
        break;
  1190e2:	eb 09                	jmp    1190ed <event_callback+0xdd>
      case NETCONN_EVT_SENDMINUS:
        sock->sendevent = 0;
  1190e4:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1190e7:	66 c7 40 0c 00 00    	movw   $0x0,0xc(%eax)
        break;
    }
    sys_sem_signal(selectsem);
  1190ed:	a1 48 99 13 00       	mov    0x139948,%eax
  1190f2:	89 04 24             	mov    %eax,(%esp)
  1190f5:	e8 c6 0c 00 00       	call   119dc0 <sys_sem_signal>

    /* Now decide if anyone is waiting for this socket */
    /* NOTE: This code is written this way to protect the select link list
       but to avoid a deadlock situation by releasing socksem before
       signalling for the select. This means we need to go through the list
       multiple times ONLY IF a select was actually waiting. We go through
       the list the number of waiting select calls + 1. This list is
       expected to be small. */
    while (1)
    {
        sys_sem_wait(selectsem);
  1190fa:	a1 48 99 13 00       	mov    0x139948,%eax
  1190ff:	89 04 24             	mov    %eax,(%esp)
  119102:	e8 f9 6c ff ff       	call   10fe00 <sys_sem_wait>
        for (scb = select_cb_list; scb; scb = scb->next)
  119107:	a1 40 99 13 00       	mov    0x139940,%eax
  11910c:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  11910f:	e9 9a 00 00 00       	jmp    1191ae <event_callback+0x19e>
        {
            if (scb->sem_signalled == 0)
  119114:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  119117:	8b 40 10             	mov    0x10(%eax),%eax
  11911a:	85 c0                	test   %eax,%eax
  11911c:	0f 85 84 00 00 00    	jne    1191a6 <event_callback+0x196>
            {
                /* Test this select call for our socket */
                if (scb->readset && FD_ISSET(s, scb->readset))
  119122:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  119125:	8b 40 04             	mov    0x4(%eax),%eax
  119128:	85 c0                	test   %eax,%eax
  11912a:	74 38                	je     119164 <event_callback+0x154>
  11912c:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  11912f:	8b 48 04             	mov    0x4(%eax),%ecx
  119132:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
  119135:	89 d0                	mov    %edx,%eax
  119137:	c1 f8 1f             	sar    $0x1f,%eax
  11913a:	c1 e8 1d             	shr    $0x1d,%eax
  11913d:	01 d0                	add    %edx,%eax
  11913f:	c1 f8 03             	sar    $0x3,%eax
  119142:	0f b6 04 01          	movzbl (%ecx,%eax,1),%eax
  119146:	0f b6 c0             	movzbl %al,%eax
  119149:	8b 4d f4             	mov    0xfffffff4(%ebp),%ecx
  11914c:	83 e1 07             	and    $0x7,%ecx
  11914f:	d3 f8                	sar    %cl,%eax
  119151:	83 e0 01             	and    $0x1,%eax
  119154:	84 c0                	test   %al,%al
  119156:	74 0c                	je     119164 <event_callback+0x154>
                    if (sock->rcvevent)
  119158:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  11915b:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  11915f:	66 85 c0             	test   %ax,%ax
  119162:	75 54                	jne    1191b8 <event_callback+0x1a8>
                        break;
                if (scb->writeset && FD_ISSET(s, scb->writeset))
  119164:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  119167:	8b 40 08             	mov    0x8(%eax),%eax
  11916a:	85 c0                	test   %eax,%eax
  11916c:	74 38                	je     1191a6 <event_callback+0x196>
  11916e:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  119171:	8b 48 08             	mov    0x8(%eax),%ecx
  119174:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
  119177:	89 d0                	mov    %edx,%eax
  119179:	c1 f8 1f             	sar    $0x1f,%eax
  11917c:	c1 e8 1d             	shr    $0x1d,%eax
  11917f:	01 d0                	add    %edx,%eax
  119181:	c1 f8 03             	sar    $0x3,%eax
  119184:	0f b6 04 01          	movzbl (%ecx,%eax,1),%eax
  119188:	0f b6 c0             	movzbl %al,%eax
  11918b:	8b 4d f4             	mov    0xfffffff4(%ebp),%ecx
  11918e:	83 e1 07             	and    $0x7,%ecx
  119191:	d3 f8                	sar    %cl,%eax
  119193:	83 e0 01             	and    $0x1,%eax
  119196:	84 c0                	test   %al,%al
  119198:	74 0c                	je     1191a6 <event_callback+0x196>
                    if (sock->sendevent)
  11919a:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  11919d:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  1191a1:	66 85 c0             	test   %ax,%ax
  1191a4:	75 12                	jne    1191b8 <event_callback+0x1a8>
  1191a6:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1191a9:	8b 00                	mov    (%eax),%eax
  1191ab:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  1191ae:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  1191b2:	0f 85 5c ff ff ff    	jne    119114 <event_callback+0x104>
                        break;
            }
        }
        if (scb)
  1191b8:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  1191bc:	74 2a                	je     1191e8 <event_callback+0x1d8>
        {
            scb->sem_signalled = 1;
  1191be:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1191c1:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
            sys_sem_signal(selectsem);
  1191c8:	a1 48 99 13 00       	mov    0x139948,%eax
  1191cd:	89 04 24             	mov    %eax,(%esp)
  1191d0:	e8 eb 0b 00 00       	call   119dc0 <sys_sem_signal>
            sys_sem_signal(scb->sem);
  1191d5:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1191d8:	8b 40 14             	mov    0x14(%eax),%eax
  1191db:	89 04 24             	mov    %eax,(%esp)
  1191de:	e8 dd 0b 00 00       	call   119dc0 <sys_sem_signal>
        } else {
            sys_sem_signal(selectsem);
            break;
        }
    }
  1191e3:	e9 12 ff ff ff       	jmp    1190fa <event_callback+0xea>
  1191e8:	a1 48 99 13 00       	mov    0x139948,%eax
  1191ed:	89 04 24             	mov    %eax,(%esp)
  1191f0:	e8 cb 0b 00 00       	call   119dc0 <sys_sem_signal>

}
  1191f5:	c9                   	leave  
  1191f6:	c3                   	ret    
  1191f7:	89 f6                	mov    %esi,%esi
  1191f9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00119200 <lwip_shutdown>:




int lwip_shutdown(int s, int how)
{
  119200:	55                   	push   %ebp
  119201:	89 e5                	mov    %esp,%ebp
  119203:	83 ec 08             	sub    $0x8,%esp
  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_shutdown(%d, how=%d)\n", s, how));
  return lwip_close(s); /* XXX temporary hack until proper implementation */
  119206:	8b 45 08             	mov    0x8(%ebp),%eax
  119209:	89 04 24             	mov    %eax,(%esp)
  11920c:	e8 6f f0 ff ff       	call   118280 <lwip_close>
}
  119211:	c9                   	leave  
  119212:	c3                   	ret    
  119213:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  119219:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00119220 <lwip_getpeername>:

int lwip_getpeername (int s, struct sockaddr *name, socklen_t *namelen)
{
  119220:	55                   	push   %ebp
  119221:	89 e5                	mov    %esp,%ebp
  119223:	83 ec 38             	sub    $0x38,%esp
  struct lwip_socket *sock;
  struct sockaddr_in sin;
  struct ip_addr naddr;

  sock = get_socket(s);
  119226:	8b 45 08             	mov    0x8(%ebp),%eax
  119229:	89 04 24             	mov    %eax,(%esp)
  11922c:	e8 af ec ff ff       	call   117ee0 <get_socket>
  119231:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  if (!sock) {
  119234:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  119238:	75 0c                	jne    119246 <lwip_getpeername+0x26>
    set_errno(EBADF);
    return -1;
  11923a:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,0xffffffdc(%ebp)
  119241:	e9 99 00 00 00       	jmp    1192df <lwip_getpeername+0xbf>
  }

  memset(&sin, 0, sizeof(sin));
  119246:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
  11924d:	00 
  11924e:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  119255:	00 
  119256:	8d 45 ec             	lea    0xffffffec(%ebp),%eax
  119259:	89 04 24             	mov    %eax,(%esp)
  11925c:	e8 9f cc fe ff       	call   105f00 <memset>
  sin.sin_len = sizeof(sin);
  119261:	c6 45 ec 10          	movb   $0x10,0xffffffec(%ebp)
  sin.sin_family = AF_INET;
  119265:	c6 45 ed 02          	movb   $0x2,0xffffffed(%ebp)

  /* get the IP address and port of the remote host */
  netconn_peer(sock->conn, &naddr, &sin.sin_port);
  119269:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  11926c:	8b 10                	mov    (%eax),%edx
  11926e:	8d 45 ec             	lea    0xffffffec(%ebp),%eax
  119271:	83 c0 02             	add    $0x2,%eax
  119274:	89 44 24 08          	mov    %eax,0x8(%esp)
  119278:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
  11927b:	89 44 24 04          	mov    %eax,0x4(%esp)
  11927f:	89 14 24             	mov    %edx,(%esp)
  119282:	e8 49 cd ff ff       	call   115fd0 <netconn_peer>

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getpeername(%d, addr=", s));
  ip_addr_debug_print(SOCKETS_DEBUG, &naddr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%d)\n", sin.sin_port));

  sin.sin_port = htons(sin.sin_port);
  119287:	0f b7 45 ee          	movzwl 0xffffffee(%ebp),%eax
  11928b:	0f b7 c0             	movzwl %ax,%eax
  11928e:	89 04 24             	mov    %eax,(%esp)
  119291:	e8 da 4f ff ff       	call   10e270 <htons>
  119296:	66 89 45 ee          	mov    %ax,0xffffffee(%ebp)
  sin.sin_addr.s_addr = naddr.addr;
  11929a:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  11929d:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)

  if (*namelen > sizeof(sin))
  1192a0:	8b 45 10             	mov    0x10(%ebp),%eax
  1192a3:	8b 00                	mov    (%eax),%eax
  1192a5:	83 f8 10             	cmp    $0x10,%eax
  1192a8:	76 09                	jbe    1192b3 <lwip_getpeername+0x93>
      *namelen = sizeof(sin);
  1192aa:	8b 45 10             	mov    0x10(%ebp),%eax
  1192ad:	c7 00 10 00 00 00    	movl   $0x10,(%eax)

  memcpy(name, &sin, *namelen);
  1192b3:	8b 45 10             	mov    0x10(%ebp),%eax
  1192b6:	8b 00                	mov    (%eax),%eax
  1192b8:	89 44 24 08          	mov    %eax,0x8(%esp)
  1192bc:	8d 45 ec             	lea    0xffffffec(%ebp),%eax
  1192bf:	89 44 24 04          	mov    %eax,0x4(%esp)
  1192c3:	8b 45 0c             	mov    0xc(%ebp),%eax
  1192c6:	89 04 24             	mov    %eax,(%esp)
  1192c9:	e8 f2 cb fe ff       	call   105ec0 <memcpy>
  sock_set_errno(sock, 0);
  1192ce:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1192d1:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  return 0;
  1192d8:	c7 45 dc 00 00 00 00 	movl   $0x0,0xffffffdc(%ebp)
  1192df:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
}
  1192e2:	c9                   	leave  
  1192e3:	c3                   	ret    
  1192e4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  1192ea:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

001192f0 <lwip_getsockname>:

int lwip_getsockname (int s, struct sockaddr *name, socklen_t *namelen)
{
  1192f0:	55                   	push   %ebp
  1192f1:	89 e5                	mov    %esp,%ebp
  1192f3:	83 ec 38             	sub    $0x38,%esp
  struct lwip_socket *sock;
  struct sockaddr_in sin;
  struct ip_addr *naddr;

  sock = get_socket(s);
  1192f6:	8b 45 08             	mov    0x8(%ebp),%eax
  1192f9:	89 04 24             	mov    %eax,(%esp)
  1192fc:	e8 df eb ff ff       	call   117ee0 <get_socket>
  119301:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  if (!sock) {
  119304:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  119308:	75 0c                	jne    119316 <lwip_getsockname+0x26>
    set_errno(EBADF);
    return -1;
  11930a:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,0xffffffdc(%ebp)
  119311:	e9 9b 00 00 00       	jmp    1193b1 <lwip_getsockname+0xc1>
  }

  memset(&sin, 0, sizeof(sin));
  119316:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
  11931d:	00 
  11931e:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  119325:	00 
  119326:	8d 45 ec             	lea    0xffffffec(%ebp),%eax
  119329:	89 04 24             	mov    %eax,(%esp)
  11932c:	e8 cf cb fe ff       	call   105f00 <memset>
  sin.sin_len = sizeof(sin);
  119331:	c6 45 ec 10          	movb   $0x10,0xffffffec(%ebp)
  sin.sin_family = AF_INET;
  119335:	c6 45 ed 02          	movb   $0x2,0xffffffed(%ebp)

  /* get the IP address and port of the remote host */
  netconn_addr(sock->conn, &naddr, &sin.sin_port);
  119339:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  11933c:	8b 10                	mov    (%eax),%edx
  11933e:	8d 45 ec             	lea    0xffffffec(%ebp),%eax
  119341:	83 c0 02             	add    $0x2,%eax
  119344:	89 44 24 08          	mov    %eax,0x8(%esp)
  119348:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
  11934b:	89 44 24 04          	mov    %eax,0x4(%esp)
  11934f:	89 14 24             	mov    %edx,(%esp)
  119352:	e8 39 cd ff ff       	call   116090 <netconn_addr>

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockname(%d, addr=", s));
  ip_addr_debug_print(SOCKETS_DEBUG, naddr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%d)\n", sin.sin_port));

  sin.sin_port = htons(sin.sin_port);
  119357:	0f b7 45 ee          	movzwl 0xffffffee(%ebp),%eax
  11935b:	0f b7 c0             	movzwl %ax,%eax
  11935e:	89 04 24             	mov    %eax,(%esp)
  119361:	e8 0a 4f ff ff       	call   10e270 <htons>
  119366:	66 89 45 ee          	mov    %ax,0xffffffee(%ebp)
  sin.sin_addr.s_addr = naddr->addr;
  11936a:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  11936d:	8b 00                	mov    (%eax),%eax
  11936f:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)

  if (*namelen > sizeof(sin))
  119372:	8b 45 10             	mov    0x10(%ebp),%eax
  119375:	8b 00                	mov    (%eax),%eax
  119377:	83 f8 10             	cmp    $0x10,%eax
  11937a:	76 09                	jbe    119385 <lwip_getsockname+0x95>
      *namelen = sizeof(sin);
  11937c:	8b 45 10             	mov    0x10(%ebp),%eax
  11937f:	c7 00 10 00 00 00    	movl   $0x10,(%eax)

  memcpy(name, &sin, *namelen);
  119385:	8b 45 10             	mov    0x10(%ebp),%eax
  119388:	8b 00                	mov    (%eax),%eax
  11938a:	89 44 24 08          	mov    %eax,0x8(%esp)
  11938e:	8d 45 ec             	lea    0xffffffec(%ebp),%eax
  119391:	89 44 24 04          	mov    %eax,0x4(%esp)
  119395:	8b 45 0c             	mov    0xc(%ebp),%eax
  119398:	89 04 24             	mov    %eax,(%esp)
  11939b:	e8 20 cb fe ff       	call   105ec0 <memcpy>
  sock_set_errno(sock, 0);
  1193a0:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1193a3:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  return 0;
  1193aa:	c7 45 dc 00 00 00 00 	movl   $0x0,0xffffffdc(%ebp)
  1193b1:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
}
  1193b4:	c9                   	leave  
  1193b5:	c3                   	ret    
  1193b6:	8d 76 00             	lea    0x0(%esi),%esi
  1193b9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

001193c0 <lwip_getsockopt>:

int lwip_getsockopt (int s, int level, int optname, void *optval, socklen_t *optlen)
{
  1193c0:	55                   	push   %ebp
  1193c1:	89 e5                	mov    %esp,%ebp
  1193c3:	83 ec 38             	sub    $0x38,%esp
  int err = 0;
  1193c6:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)
  struct lwip_socket *sock = get_socket(s);
  1193cd:	8b 45 08             	mov    0x8(%ebp),%eax
  1193d0:	89 04 24             	mov    %eax,(%esp)
  1193d3:	e8 08 eb ff ff       	call   117ee0 <get_socket>
  1193d8:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)

  if(!sock) {
  1193db:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  1193df:	75 0c                	jne    1193ed <lwip_getsockopt+0x2d>
   	set_errno(EBADF);
    return -1;
  1193e1:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,0xffffffe4(%ebp)
  1193e8:	e9 df 02 00 00       	jmp    1196cc <lwip_getsockopt+0x30c>
  }

  if( NULL == optval || NULL == optlen ) {
  1193ed:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
  1193f1:	74 06                	je     1193f9 <lwip_getsockopt+0x39>
  1193f3:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
  1193f7:	75 16                	jne    11940f <lwip_getsockopt+0x4f>
    sock_set_errno( sock, EFAULT );
  1193f9:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1193fc:	c7 40 10 0e 00 00 00 	movl   $0xe,0x10(%eax)
    return -1;
  119403:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,0xffffffe4(%ebp)
  11940a:	e9 bd 02 00 00       	jmp    1196cc <lwip_getsockopt+0x30c>
  }

  /* Do length and type checks for the various options first, to keep it readable. */
  switch( level ) {
  11940f:	8b 45 0c             	mov    0xc(%ebp),%eax
  119412:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
  119415:	83 7d e0 06          	cmpl   $0x6,0xffffffe0(%ebp)
  119419:	0f 84 a0 00 00 00    	je     1194bf <lwip_getsockopt+0xff>
  11941f:	81 7d e0 ff 0f 00 00 	cmpl   $0xfff,0xffffffe0(%ebp)
  119426:	74 0b                	je     119433 <lwip_getsockopt+0x73>
  119428:	83 7d e0 00          	cmpl   $0x0,0xffffffe0(%ebp)
  11942c:	74 6a                	je     119498 <lwip_getsockopt+0xd8>
  11942e:	e9 cc 00 00 00       	jmp    1194ff <lwip_getsockopt+0x13f>
   
/* Level: SOL_SOCKET */
  case SOL_SOCKET:
      switch(optname) {
  119433:	8b 45 10             	mov    0x10(%ebp),%eax
  119436:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
  119439:	83 7d dc 20          	cmpl   $0x20,0xffffffdc(%ebp)
  11943d:	74 39                	je     119478 <lwip_getsockopt+0xb8>
  11943f:	83 7d dc 20          	cmpl   $0x20,0xffffffdc(%ebp)
  119443:	7f 14                	jg     119459 <lwip_getsockopt+0x99>
  119445:	83 7d dc 04          	cmpl   $0x4,0xffffffdc(%ebp)
  119449:	74 2d                	je     119478 <lwip_getsockopt+0xb8>
  11944b:	83 7d dc 08          	cmpl   $0x8,0xffffffdc(%ebp)
  11944f:	74 27                	je     119478 <lwip_getsockopt+0xb8>
  119451:	83 7d dc 02          	cmpl   $0x2,0xffffffdc(%ebp)
  119455:	74 21                	je     119478 <lwip_getsockopt+0xb8>
  119457:	eb 36                	jmp    11948f <lwip_getsockopt+0xcf>
  119459:	81 7d dc 00 02 00 00 	cmpl   $0x200,0xffffffdc(%ebp)
  119460:	74 16                	je     119478 <lwip_getsockopt+0xb8>
  119462:	81 7d dc 00 02 00 00 	cmpl   $0x200,0xffffffdc(%ebp)
  119469:	7c 24                	jl     11948f <lwip_getsockopt+0xcf>
  11946b:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  11946e:	2d 07 10 00 00       	sub    $0x1007,%eax
  119473:	83 f8 01             	cmp    $0x1,%eax
  119476:	77 17                	ja     11948f <lwip_getsockopt+0xcf>
         
      case SO_ACCEPTCONN:
      case SO_BROADCAST:
      /* UNIMPL case SO_DEBUG: */
      /* UNIMPL case SO_DONTROUTE: */
      case SO_ERROR:
      case SO_KEEPALIVE:
      /* UNIMPL case SO_OOBINLINE: */
      /* UNIMPL case SO_RCVBUF: */
      /* UNIMPL case SO_SNDBUF: */
      /* UNIMPL case SO_RCVLOWAT: */
      /* UNIMPL case SO_SNDLOWAT: */
#if SO_REUSE
      case SO_REUSEADDR:
      case SO_REUSEPORT:
#endif /* SO_REUSE */
      case SO_TYPE:
      /* UNIMPL case SO_USELOOPBACK: */
        if( *optlen < sizeof(int) ) {
  119478:	8b 45 18             	mov    0x18(%ebp),%eax
  11947b:	8b 00                	mov    (%eax),%eax
  11947d:	83 f8 03             	cmp    $0x3,%eax
  119480:	0f 87 80 00 00 00    	ja     119506 <lwip_getsockopt+0x146>
          err = EINVAL;
  119486:	c7 45 f8 16 00 00 00 	movl   $0x16,0xfffffff8(%ebp)
        }
          break;
  11948d:	eb 77                	jmp    119506 <lwip_getsockopt+0x146>

      default:
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, UNIMPL: optname=0x%x, ..)\n", s, optname));
        err = ENOPROTOOPT;
  11948f:	c7 45 f8 5c 00 00 00 	movl   $0x5c,0xfffffff8(%ebp)
      }  /* switch */
      break;
  119496:	eb 6e                	jmp    119506 <lwip_getsockopt+0x146>
                     
/* Level: IPPROTO_IP */
  case IPPROTO_IP:
      switch(optname) {
  119498:	8b 45 10             	mov    0x10(%ebp),%eax
  11949b:	83 e8 01             	sub    $0x1,%eax
  11949e:	83 f8 01             	cmp    $0x1,%eax
  1194a1:	77 13                	ja     1194b6 <lwip_getsockopt+0xf6>
      /* UNIMPL case IP_HDRINCL: */
      /* UNIMPL case IP_RCVDSTADDR: */
      /* UNIMPL case IP_RCVIF: */
      case IP_TTL:
      case IP_TOS:
        if( *optlen < sizeof(int) ) {
  1194a3:	8b 45 18             	mov    0x18(%ebp),%eax
  1194a6:	8b 00                	mov    (%eax),%eax
  1194a8:	83 f8 03             	cmp    $0x3,%eax
  1194ab:	77 59                	ja     119506 <lwip_getsockopt+0x146>
          err = EINVAL;
  1194ad:	c7 45 f8 16 00 00 00 	movl   $0x16,0xfffffff8(%ebp)
        }
        break;
  1194b4:	eb 50                	jmp    119506 <lwip_getsockopt+0x146>

      default:
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, UNIMPL: optname=0x%x, ..)\n", s, optname));
        err = ENOPROTOOPT;
  1194b6:	c7 45 f8 5c 00 00 00 	movl   $0x5c,0xfffffff8(%ebp)
      }  /* switch */
      break;
  1194bd:	eb 47                	jmp    119506 <lwip_getsockopt+0x146>
         
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
      if( *optlen < sizeof(int) ) {
  1194bf:	8b 45 18             	mov    0x18(%ebp),%eax
  1194c2:	8b 00                	mov    (%eax),%eax
  1194c4:	83 f8 03             	cmp    $0x3,%eax
  1194c7:	77 09                	ja     1194d2 <lwip_getsockopt+0x112>
        err = EINVAL;
  1194c9:	c7 45 f8 16 00 00 00 	movl   $0x16,0xfffffff8(%ebp)
        break;
  1194d0:	eb 34                	jmp    119506 <lwip_getsockopt+0x146>
    }
      
      /* If this is no TCP socket, ignore any options. */
      if ( sock->conn->type != NETCONN_TCP ) return 0;
  1194d2:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1194d5:	8b 00                	mov    (%eax),%eax
  1194d7:	8b 00                	mov    (%eax),%eax
  1194d9:	85 c0                	test   %eax,%eax
  1194db:	74 0c                	je     1194e9 <lwip_getsockopt+0x129>
  1194dd:	c7 45 e4 00 00 00 00 	movl   $0x0,0xffffffe4(%ebp)
  1194e4:	e9 e3 01 00 00       	jmp    1196cc <lwip_getsockopt+0x30c>

      switch( optname ) {
  1194e9:	8b 45 10             	mov    0x10(%ebp),%eax
  1194ec:	83 e8 01             	sub    $0x1,%eax
  1194ef:	83 f8 01             	cmp    $0x1,%eax
  1194f2:	77 02                	ja     1194f6 <lwip_getsockopt+0x136>
      case TCP_NODELAY:
      case TCP_KEEPALIVE:
        break;
  1194f4:	eb 10                	jmp    119506 <lwip_getsockopt+0x146>
         
      default:
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_TCP, UNIMPL: optname=0x%x, ..)\n", s, optname));
        err = ENOPROTOOPT;
  1194f6:	c7 45 f8 5c 00 00 00 	movl   $0x5c,0xfffffff8(%ebp)
      }  /* switch */
      break;
  1194fd:	eb 07                	jmp    119506 <lwip_getsockopt+0x146>

/* UNDEFINED LEVEL */
  default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, level=0x%x, UNIMPL: optname=0x%x, ..)\n", s, level, optname));
      err = ENOPROTOOPT;
  1194ff:	c7 45 f8 5c 00 00 00 	movl   $0x5c,0xfffffff8(%ebp)
  }  /* switch */

   
  if( 0 != err ) {
  119506:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  11950a:	74 15                	je     119521 <lwip_getsockopt+0x161>
    sock_set_errno(sock, err);
  11950c:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  11950f:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  119512:	89 42 10             	mov    %eax,0x10(%edx)
    return -1;
  119515:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,0xffffffe4(%ebp)
  11951c:	e9 ab 01 00 00       	jmp    1196cc <lwip_getsockopt+0x30c>
  }
   


  /* Now do the actual option processing */

  switch(level) {
  119521:	8b 45 0c             	mov    0xc(%ebp),%eax
  119524:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
  119527:	83 7d d8 06          	cmpl   $0x6,0xffffffd8(%ebp)
  11952b:	0f 84 36 01 00 00    	je     119667 <lwip_getsockopt+0x2a7>
  119531:	81 7d d8 ff 0f 00 00 	cmpl   $0xfff,0xffffffd8(%ebp)
  119538:	74 0f                	je     119549 <lwip_getsockopt+0x189>
  11953a:	83 7d d8 00          	cmpl   $0x0,0xffffffd8(%ebp)
  11953e:	0f 84 e3 00 00 00    	je     119627 <lwip_getsockopt+0x267>
  119544:	e9 5e 01 00 00       	jmp    1196a7 <lwip_getsockopt+0x2e7>
   
/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch( optname ) {
  119549:	8b 45 10             	mov    0x10(%ebp),%eax
  11954c:	89 45 d4             	mov    %eax,0xffffffd4(%ebp)
  11954f:	83 7d d4 20          	cmpl   $0x20,0xffffffd4(%ebp)
  119553:	74 41                	je     119596 <lwip_getsockopt+0x1d6>
  119555:	83 7d d4 20          	cmpl   $0x20,0xffffffd4(%ebp)
  119559:	7f 17                	jg     119572 <lwip_getsockopt+0x1b2>
  11955b:	83 7d d4 04          	cmpl   $0x4,0xffffffd4(%ebp)
  11955f:	74 35                	je     119596 <lwip_getsockopt+0x1d6>
  119561:	83 7d d4 08          	cmpl   $0x8,0xffffffd4(%ebp)
  119565:	74 2f                	je     119596 <lwip_getsockopt+0x1d6>
  119567:	83 7d d4 02          	cmpl   $0x2,0xffffffd4(%ebp)
  11956b:	74 29                	je     119596 <lwip_getsockopt+0x1d6>
  11956d:	e9 35 01 00 00       	jmp    1196a7 <lwip_getsockopt+0x2e7>
  119572:	81 7d d4 07 10 00 00 	cmpl   $0x1007,0xffffffd4(%ebp)
  119579:	0f 84 8e 00 00 00    	je     11960d <lwip_getsockopt+0x24d>
  11957f:	81 7d d4 08 10 00 00 	cmpl   $0x1008,0xffffffd4(%ebp)
  119586:	74 2a                	je     1195b2 <lwip_getsockopt+0x1f2>
  119588:	81 7d d4 00 02 00 00 	cmpl   $0x200,0xffffffd4(%ebp)
  11958f:	74 05                	je     119596 <lwip_getsockopt+0x1d6>
  119591:	e9 11 01 00 00       	jmp    1196a7 <lwip_getsockopt+0x2e7>

    /* The option flags */
    case SO_ACCEPTCONN:
    case SO_BROADCAST:
    /* UNIMPL case SO_DEBUG: */
    /* UNIMPL case SO_DONTROUTE: */
    case SO_KEEPALIVE:
    /* UNIMPL case SO_OOBINCLUDE: */
#if SO_REUSE
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /*case SO_USELOOPBACK: UNIMPL */
      *(int*)optval = sock->conn->pcb.tcp->so_options & optname;
  119596:	8b 55 14             	mov    0x14(%ebp),%edx
  119599:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  11959c:	8b 00                	mov    (%eax),%eax
  11959e:	8b 40 08             	mov    0x8(%eax),%eax
  1195a1:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  1195a5:	0f b7 c0             	movzwl %ax,%eax
  1195a8:	23 45 10             	and    0x10(%ebp),%eax
  1195ab:	89 02                	mov    %eax,(%edx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, optname=0x%x, ..) = %s\n", s, optname, (*(int*)optval?"on":"off")));
      break;
  1195ad:	e9 f5 00 00 00       	jmp    1196a7 <lwip_getsockopt+0x2e7>

    case SO_TYPE:
      switch (sock->conn->type) {
  1195b2:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1195b5:	8b 00                	mov    (%eax),%eax
  1195b7:	8b 00                	mov    (%eax),%eax
  1195b9:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
  1195bc:	83 7d e8 03          	cmpl   $0x3,0xffffffe8(%ebp)
  1195c0:	77 08                	ja     1195ca <lwip_getsockopt+0x20a>
  1195c2:	83 7d e8 01          	cmpl   $0x1,0xffffffe8(%ebp)
  1195c6:	73 26                	jae    1195ee <lwip_getsockopt+0x22e>
  1195c8:	eb 16                	jmp    1195e0 <lwip_getsockopt+0x220>
  1195ca:	83 7d e8 04          	cmpl   $0x4,0xffffffe8(%ebp)
  1195ce:	74 02                	je     1195d2 <lwip_getsockopt+0x212>
  1195d0:	eb 2a                	jmp    1195fc <lwip_getsockopt+0x23c>
      case NETCONN_RAW:
        *(int*)optval = SOCK_RAW;
  1195d2:	8b 45 14             	mov    0x14(%ebp),%eax
  1195d5:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
        break;
  1195db:	e9 c7 00 00 00       	jmp    1196a7 <lwip_getsockopt+0x2e7>
      case NETCONN_TCP:
        *(int*)optval = SOCK_STREAM;
  1195e0:	8b 45 14             	mov    0x14(%ebp),%eax
  1195e3:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
        break;
  1195e9:	e9 b9 00 00 00       	jmp    1196a7 <lwip_getsockopt+0x2e7>
      case NETCONN_UDP:
      case NETCONN_UDPLITE:
      case NETCONN_UDPNOCHKSUM:
        *(int*)optval = SOCK_DGRAM;
  1195ee:	8b 45 14             	mov    0x14(%ebp),%eax
  1195f1:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
        break;
  1195f7:	e9 ab 00 00 00       	jmp    1196a7 <lwip_getsockopt+0x2e7>
      default: /* unrecognized socket type */
        *(int*)optval = sock->conn->type;
  1195fc:	8b 55 14             	mov    0x14(%ebp),%edx
  1195ff:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  119602:	8b 00                	mov    (%eax),%eax
  119604:	8b 00                	mov    (%eax),%eax
  119606:	89 02                	mov    %eax,(%edx)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, SO_TYPE): unrecognized socket type %d\n", s, *(int *)optval));
      }  /* switch */
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, SO_TYPE) = %d\n", s, *(int *)optval));
      break;
  119608:	e9 9a 00 00 00       	jmp    1196a7 <lwip_getsockopt+0x2e7>

    case SO_ERROR:
      *(int *)optval = sock->err;
  11960d:	8b 55 14             	mov    0x14(%ebp),%edx
  119610:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  119613:	8b 40 10             	mov    0x10(%eax),%eax
  119616:	89 02                	mov    %eax,(%edx)
      sock->err = 0;
  119618:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  11961b:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, SO_ERROR) = %d\n", s, *(int *)optval));
      break;
    }  /* switch */
    break;
  119622:	e9 80 00 00 00       	jmp    1196a7 <lwip_getsockopt+0x2e7>

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch( optname ) {
  119627:	8b 45 10             	mov    0x10(%ebp),%eax
  11962a:	89 45 d0             	mov    %eax,0xffffffd0(%ebp)
  11962d:	83 7d d0 01          	cmpl   $0x1,0xffffffd0(%ebp)
  119631:	74 1e                	je     119651 <lwip_getsockopt+0x291>
  119633:	83 7d d0 02          	cmpl   $0x2,0xffffffd0(%ebp)
  119637:	74 02                	je     11963b <lwip_getsockopt+0x27b>
  119639:	eb 6c                	jmp    1196a7 <lwip_getsockopt+0x2e7>
    case IP_TTL:
      *(int*)optval = sock->conn->pcb.tcp->ttl;
  11963b:	8b 55 14             	mov    0x14(%ebp),%edx
  11963e:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  119641:	8b 00                	mov    (%eax),%eax
  119643:	8b 40 08             	mov    0x8(%eax),%eax
  119646:	0f b6 40 0b          	movzbl 0xb(%eax),%eax
  11964a:	0f b6 c0             	movzbl %al,%eax
  11964d:	89 02                	mov    %eax,(%edx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_TTL) = %d\n", s, *(int *)optval));
      break;
  11964f:	eb 56                	jmp    1196a7 <lwip_getsockopt+0x2e7>
    case IP_TOS:
      *(int*)optval = sock->conn->pcb.tcp->tos;
  119651:	8b 55 14             	mov    0x14(%ebp),%edx
  119654:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  119657:	8b 00                	mov    (%eax),%eax
  119659:	8b 40 08             	mov    0x8(%eax),%eax
  11965c:	0f b6 40 0a          	movzbl 0xa(%eax),%eax
  119660:	0f b6 c0             	movzbl %al,%eax
  119663:	89 02                	mov    %eax,(%edx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_TOS) = %d\n", s, *(int *)optval));
      break;
    }  /* switch */
    break;
  119665:	eb 40                	jmp    1196a7 <lwip_getsockopt+0x2e7>

/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    switch( optname ) {
  119667:	8b 45 10             	mov    0x10(%ebp),%eax
  11966a:	89 45 cc             	mov    %eax,0xffffffcc(%ebp)
  11966d:	83 7d cc 01          	cmpl   $0x1,0xffffffcc(%ebp)
  119671:	74 08                	je     11967b <lwip_getsockopt+0x2bb>
  119673:	83 7d cc 02          	cmpl   $0x2,0xffffffcc(%ebp)
  119677:	74 1b                	je     119694 <lwip_getsockopt+0x2d4>
  119679:	eb 2c                	jmp    1196a7 <lwip_getsockopt+0x2e7>
    case TCP_NODELAY:
      *(int*)optval = (sock->conn->pcb.tcp->flags & TF_NODELAY);
  11967b:	8b 55 14             	mov    0x14(%ebp),%edx
  11967e:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  119681:	8b 00                	mov    (%eax),%eax
  119683:	8b 40 08             	mov    0x8(%eax),%eax
  119686:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  11968a:	0f b6 c0             	movzbl %al,%eax
  11968d:	83 e0 40             	and    $0x40,%eax
  119690:	89 02                	mov    %eax,(%edx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_TCP, TCP_NODELAY) = %s\n", s, (*(int*)optval)?"on":"off") );
      break;
  119692:	eb 13                	jmp    1196a7 <lwip_getsockopt+0x2e7>
    case TCP_KEEPALIVE:
      *(int*)optval = sock->conn->pcb.tcp->keepalive;
  119694:	8b 55 14             	mov    0x14(%ebp),%edx
  119697:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  11969a:	8b 00                	mov    (%eax),%eax
  11969c:	8b 40 08             	mov    0x8(%eax),%eax
  11969f:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
  1196a5:	89 02                	mov    %eax,(%edx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, TCP_KEEPALIVE) = %d\n", s, *(int *)optval));
      break;
    }  /* switch */
    break;
  }


  sock_set_errno(sock, err);
  1196a7:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  1196aa:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1196ad:	89 42 10             	mov    %eax,0x10(%edx)
  return err ? -1 : 0;
  1196b0:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  1196b4:	74 09                	je     1196bf <lwip_getsockopt+0x2ff>
  1196b6:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  1196bd:	eb 07                	jmp    1196c6 <lwip_getsockopt+0x306>
  1196bf:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  1196c6:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  1196c9:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
  1196cc:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
}
  1196cf:	c9                   	leave  
  1196d0:	c3                   	ret    
  1196d1:	eb 0d                	jmp    1196e0 <lwip_setsockopt>
  1196d3:	90                   	nop    
  1196d4:	90                   	nop    
  1196d5:	90                   	nop    
  1196d6:	90                   	nop    
  1196d7:	90                   	nop    
  1196d8:	90                   	nop    
  1196d9:	90                   	nop    
  1196da:	90                   	nop    
  1196db:	90                   	nop    
  1196dc:	90                   	nop    
  1196dd:	90                   	nop    
  1196de:	90                   	nop    
  1196df:	90                   	nop    

001196e0 <lwip_setsockopt>:

int lwip_setsockopt (int s, int level, int optname, const void *optval, socklen_t optlen)
{
  1196e0:	55                   	push   %ebp
  1196e1:	89 e5                	mov    %esp,%ebp
  1196e3:	83 ec 34             	sub    $0x34,%esp
  struct lwip_socket *sock = get_socket(s);
  1196e6:	8b 45 08             	mov    0x8(%ebp),%eax
  1196e9:	89 04 24             	mov    %eax,(%esp)
  1196ec:	e8 ef e7 ff ff       	call   117ee0 <get_socket>
  1196f1:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  int err = 0;
  1196f4:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)

  if(!sock) {
  1196fb:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  1196ff:	75 0c                	jne    11970d <lwip_setsockopt+0x2d>
   	set_errno(EBADF);
    return -1;
  119701:	c7 45 e8 ff ff ff ff 	movl   $0xffffffff,0xffffffe8(%ebp)
  119708:	e9 7a 02 00 00       	jmp    119987 <lwip_setsockopt+0x2a7>
  }

  if( NULL == optval ) {
  11970d:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
  119711:	75 16                	jne    119729 <lwip_setsockopt+0x49>
    sock_set_errno( sock, EFAULT );
  119713:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  119716:	c7 40 10 0e 00 00 00 	movl   $0xe,0x10(%eax)
    return -1;
  11971d:	c7 45 e8 ff ff ff ff 	movl   $0xffffffff,0xffffffe8(%ebp)
  119724:	e9 5e 02 00 00       	jmp    119987 <lwip_setsockopt+0x2a7>
  }


  /* Do length and type checks for the various options first, to keep it readable. */
  switch( level ) {
  119729:	8b 45 0c             	mov    0xc(%ebp),%eax
  11972c:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
  11972f:	83 7d e4 06          	cmpl   $0x6,0xffffffe4(%ebp)
  119733:	74 7e                	je     1197b3 <lwip_setsockopt+0xd3>
  119735:	81 7d e4 ff 0f 00 00 	cmpl   $0xfff,0xffffffe4(%ebp)
  11973c:	74 0b                	je     119749 <lwip_setsockopt+0x69>
  11973e:	83 7d e4 00          	cmpl   $0x0,0xffffffe4(%ebp)
  119742:	74 4a                	je     11978e <lwip_setsockopt+0xae>
  119744:	e9 a8 00 00 00       	jmp    1197f1 <lwip_setsockopt+0x111>

/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch(optname) {
  119749:	8b 45 10             	mov    0x10(%ebp),%eax
  11974c:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
  11974f:	83 7d e0 08          	cmpl   $0x8,0xffffffe0(%ebp)
  119753:	74 1f                	je     119774 <lwip_setsockopt+0x94>
  119755:	83 7d e0 08          	cmpl   $0x8,0xffffffe0(%ebp)
  119759:	7f 08                	jg     119763 <lwip_setsockopt+0x83>
  11975b:	83 7d e0 04          	cmpl   $0x4,0xffffffe0(%ebp)
  11975f:	74 13                	je     119774 <lwip_setsockopt+0x94>
  119761:	eb 22                	jmp    119785 <lwip_setsockopt+0xa5>
  119763:	83 7d e0 20          	cmpl   $0x20,0xffffffe0(%ebp)
  119767:	74 0b                	je     119774 <lwip_setsockopt+0x94>
  119769:	81 7d e0 00 02 00 00 	cmpl   $0x200,0xffffffe0(%ebp)
  119770:	74 02                	je     119774 <lwip_setsockopt+0x94>
  119772:	eb 11                	jmp    119785 <lwip_setsockopt+0xa5>

    case SO_BROADCAST:
    /* UNIMPL case SO_DEBUG: */
    /* UNIMPL case SO_DONTROUTE: */
    case SO_KEEPALIVE:
    /* UNIMPL case SO_OOBINLINE: */
    /* UNIMPL case SO_RCVBUF: */
    /* UNIMPL case SO_SNDBUF: */
    /* UNIMPL case SO_RCVLOWAT: */
    /* UNIMPL case SO_SNDLOWAT: */
#if SO_REUSE
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /* UNIMPL case SO_USELOOPBACK: */
      if( optlen < sizeof(int) ) {
  119774:	8b 45 18             	mov    0x18(%ebp),%eax
  119777:	83 f8 03             	cmp    $0x3,%eax
  11977a:	77 7c                	ja     1197f8 <lwip_setsockopt+0x118>
        err = EINVAL;
  11977c:	c7 45 fc 16 00 00 00 	movl   $0x16,0xfffffffc(%ebp)
      }
      break;
  119783:	eb 73                	jmp    1197f8 <lwip_setsockopt+0x118>
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, SOL_SOCKET, UNIMPL: optname=0x%x, ..)\n", s, optname));
      err = ENOPROTOOPT;
  119785:	c7 45 fc 5c 00 00 00 	movl   $0x5c,0xfffffffc(%ebp)
    }  /* switch */
    break;
  11978c:	eb 6a                	jmp    1197f8 <lwip_setsockopt+0x118>

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch(optname) {
  11978e:	8b 45 10             	mov    0x10(%ebp),%eax
  119791:	83 e8 01             	sub    $0x1,%eax
  119794:	83 f8 01             	cmp    $0x1,%eax
  119797:	77 11                	ja     1197aa <lwip_setsockopt+0xca>
    /* UNIMPL case IP_HDRINCL: */
    /* UNIMPL case IP_RCVDSTADDR: */
    /* UNIMPL case IP_RCVIF: */
    case IP_TTL:
    case IP_TOS:
      if( optlen < sizeof(int) ) {
  119799:	8b 45 18             	mov    0x18(%ebp),%eax
  11979c:	83 f8 03             	cmp    $0x3,%eax
  11979f:	77 57                	ja     1197f8 <lwip_setsockopt+0x118>
        err = EINVAL;
  1197a1:	c7 45 fc 16 00 00 00 	movl   $0x16,0xfffffffc(%ebp)
      }
        break;
  1197a8:	eb 4e                	jmp    1197f8 <lwip_setsockopt+0x118>
      default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, UNIMPL: optname=0x%x, ..)\n", s, optname));
      err = ENOPROTOOPT;
  1197aa:	c7 45 fc 5c 00 00 00 	movl   $0x5c,0xfffffffc(%ebp)
    }  /* switch */
    break;
  1197b1:	eb 45                	jmp    1197f8 <lwip_setsockopt+0x118>

/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    if( optlen < sizeof(int) ) {
  1197b3:	8b 45 18             	mov    0x18(%ebp),%eax
  1197b6:	83 f8 03             	cmp    $0x3,%eax
  1197b9:	77 09                	ja     1197c4 <lwip_setsockopt+0xe4>
      err = EINVAL;
  1197bb:	c7 45 fc 16 00 00 00 	movl   $0x16,0xfffffffc(%ebp)
        break;
  1197c2:	eb 34                	jmp    1197f8 <lwip_setsockopt+0x118>
    }

    /* If this is no TCP socket, ignore any options. */
    if ( sock->conn->type != NETCONN_TCP ) return 0;
  1197c4:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1197c7:	8b 00                	mov    (%eax),%eax
  1197c9:	8b 00                	mov    (%eax),%eax
  1197cb:	85 c0                	test   %eax,%eax
  1197cd:	74 0c                	je     1197db <lwip_setsockopt+0xfb>
  1197cf:	c7 45 e8 00 00 00 00 	movl   $0x0,0xffffffe8(%ebp)
  1197d6:	e9 ac 01 00 00       	jmp    119987 <lwip_setsockopt+0x2a7>

    switch( optname ) {
  1197db:	8b 45 10             	mov    0x10(%ebp),%eax
  1197de:	83 e8 01             	sub    $0x1,%eax
  1197e1:	83 f8 01             	cmp    $0x1,%eax
  1197e4:	77 02                	ja     1197e8 <lwip_setsockopt+0x108>
    case TCP_NODELAY:
    case TCP_KEEPALIVE:
      break;
  1197e6:	eb 10                	jmp    1197f8 <lwip_setsockopt+0x118>

    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, UNIMPL: optname=0x%x, ..)\n", s, optname));
      err = ENOPROTOOPT;
  1197e8:	c7 45 fc 5c 00 00 00 	movl   $0x5c,0xfffffffc(%ebp)
    }  /* switch */
    break;
  1197ef:	eb 07                	jmp    1197f8 <lwip_setsockopt+0x118>

/* UNDEFINED LEVEL */      
  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, level=0x%x, UNIMPL: optname=0x%x, ..)\n", s, level, optname));
    err = ENOPROTOOPT;
  1197f1:	c7 45 fc 5c 00 00 00 	movl   $0x5c,0xfffffffc(%ebp)
  }  /* switch */


  if( 0 != err ) {
  1197f8:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  1197fc:	74 15                	je     119813 <lwip_setsockopt+0x133>
    sock_set_errno(sock, err);
  1197fe:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  119801:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  119804:	89 42 10             	mov    %eax,0x10(%edx)
    return -1;
  119807:	c7 45 e8 ff ff ff ff 	movl   $0xffffffff,0xffffffe8(%ebp)
  11980e:	e9 74 01 00 00       	jmp    119987 <lwip_setsockopt+0x2a7>
  }



  /* Now do the actual option processing */

  switch(level) {
  119813:	8b 45 0c             	mov    0xc(%ebp),%eax
  119816:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
  119819:	83 7d dc 06          	cmpl   $0x6,0xffffffdc(%ebp)
  11981d:	0f 84 d7 00 00 00    	je     1198fa <lwip_setsockopt+0x21a>
  119823:	81 7d dc ff 0f 00 00 	cmpl   $0xfff,0xffffffdc(%ebp)
  11982a:	74 0f                	je     11983b <lwip_setsockopt+0x15b>
  11982c:	83 7d dc 00          	cmpl   $0x0,0xffffffdc(%ebp)
  119830:	0f 84 89 00 00 00    	je     1198bf <lwip_setsockopt+0x1df>
  119836:	e9 27 01 00 00       	jmp    119962 <lwip_setsockopt+0x282>

/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch(optname) {
  11983b:	8b 45 10             	mov    0x10(%ebp),%eax
  11983e:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
  119841:	83 7d d8 08          	cmpl   $0x8,0xffffffd8(%ebp)
  119845:	74 25                	je     11986c <lwip_setsockopt+0x18c>
  119847:	83 7d d8 08          	cmpl   $0x8,0xffffffd8(%ebp)
  11984b:	7f 0b                	jg     119858 <lwip_setsockopt+0x178>
  11984d:	83 7d d8 04          	cmpl   $0x4,0xffffffd8(%ebp)
  119851:	74 19                	je     11986c <lwip_setsockopt+0x18c>
  119853:	e9 0a 01 00 00       	jmp    119962 <lwip_setsockopt+0x282>
  119858:	83 7d d8 20          	cmpl   $0x20,0xffffffd8(%ebp)
  11985c:	74 0e                	je     11986c <lwip_setsockopt+0x18c>
  11985e:	81 7d d8 00 02 00 00 	cmpl   $0x200,0xffffffd8(%ebp)
  119865:	74 05                	je     11986c <lwip_setsockopt+0x18c>
  119867:	e9 f6 00 00 00       	jmp    119962 <lwip_setsockopt+0x282>

    /* The option flags */
    case SO_BROADCAST:
    /* UNIMPL case SO_DEBUG: */
    /* UNIMPL case SO_DONTROUTE: */
    case SO_KEEPALIVE:
    /* UNIMPL case SO_OOBINCLUDE: */
#if SO_REUSE
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /* UNIMPL case SO_USELOOPBACK: */
      if ( *(int*)optval ) {
  11986c:	8b 45 14             	mov    0x14(%ebp),%eax
  11986f:	8b 00                	mov    (%eax),%eax
  119871:	85 c0                	test   %eax,%eax
  119873:	74 24                	je     119899 <lwip_setsockopt+0x1b9>
        sock->conn->pcb.tcp->so_options |= optname;
  119875:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  119878:	8b 00                	mov    (%eax),%eax
  11987a:	8b 48 08             	mov    0x8(%eax),%ecx
  11987d:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  119880:	8b 00                	mov    (%eax),%eax
  119882:	8b 40 08             	mov    0x8(%eax),%eax
  119885:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  119889:	89 c2                	mov    %eax,%edx
  11988b:	8b 45 10             	mov    0x10(%ebp),%eax
  11988e:	09 d0                	or     %edx,%eax
  119890:	66 89 41 08          	mov    %ax,0x8(%ecx)
  119894:	e9 c9 00 00 00       	jmp    119962 <lwip_setsockopt+0x282>
      } else {
        sock->conn->pcb.tcp->so_options &= ~optname;
  119899:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  11989c:	8b 00                	mov    (%eax),%eax
  11989e:	8b 48 08             	mov    0x8(%eax),%ecx
  1198a1:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1198a4:	8b 00                	mov    (%eax),%eax
  1198a6:	8b 40 08             	mov    0x8(%eax),%eax
  1198a9:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  1198ad:	89 c2                	mov    %eax,%edx
  1198af:	8b 45 10             	mov    0x10(%ebp),%eax
  1198b2:	f7 d0                	not    %eax
  1198b4:	21 d0                	and    %edx,%eax
  1198b6:	66 89 41 08          	mov    %ax,0x8(%ecx)
      }
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, SOL_SOCKET, optname=0x%x, ..) -> %s\n", s, optname, (*(int*)optval?"on":"off")));
      break;
    }  /* switch */
    break;
  1198ba:	e9 a3 00 00 00       	jmp    119962 <lwip_setsockopt+0x282>

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch( optname ) {
  1198bf:	8b 45 10             	mov    0x10(%ebp),%eax
  1198c2:	89 45 d4             	mov    %eax,0xffffffd4(%ebp)
  1198c5:	83 7d d4 01          	cmpl   $0x1,0xffffffd4(%ebp)
  1198c9:	74 1d                	je     1198e8 <lwip_setsockopt+0x208>
  1198cb:	83 7d d4 02          	cmpl   $0x2,0xffffffd4(%ebp)
  1198cf:	74 05                	je     1198d6 <lwip_setsockopt+0x1f6>
  1198d1:	e9 8c 00 00 00       	jmp    119962 <lwip_setsockopt+0x282>
    case IP_TTL:
      sock->conn->pcb.tcp->ttl = (u8_t)(*(int*)optval);
  1198d6:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1198d9:	8b 00                	mov    (%eax),%eax
  1198db:	8b 50 08             	mov    0x8(%eax),%edx
  1198de:	8b 45 14             	mov    0x14(%ebp),%eax
  1198e1:	8b 00                	mov    (%eax),%eax
  1198e3:	88 42 0b             	mov    %al,0xb(%edx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, IP_TTL, ..) -> %u\n", s, sock->conn->pcb.tcp->ttl));
      break;
  1198e6:	eb 7a                	jmp    119962 <lwip_setsockopt+0x282>
    case IP_TOS:
      sock->conn->pcb.tcp->tos = (u8_t)(*(int*)optval);
  1198e8:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1198eb:	8b 00                	mov    (%eax),%eax
  1198ed:	8b 50 08             	mov    0x8(%eax),%edx
  1198f0:	8b 45 14             	mov    0x14(%ebp),%eax
  1198f3:	8b 00                	mov    (%eax),%eax
  1198f5:	88 42 0a             	mov    %al,0xa(%edx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, IP_TOS, ..)-> %u\n", s, sock->conn->pcb.tcp->tos));
      break;
    }  /* switch */
    break;
  1198f8:	eb 68                	jmp    119962 <lwip_setsockopt+0x282>

/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    switch( optname ) {
  1198fa:	8b 45 10             	mov    0x10(%ebp),%eax
  1198fd:	89 45 d0             	mov    %eax,0xffffffd0(%ebp)
  119900:	83 7d d0 01          	cmpl   $0x1,0xffffffd0(%ebp)
  119904:	74 08                	je     11990e <lwip_setsockopt+0x22e>
  119906:	83 7d d0 02          	cmpl   $0x2,0xffffffd0(%ebp)
  11990a:	74 43                	je     11994f <lwip_setsockopt+0x26f>
  11990c:	eb 54                	jmp    119962 <lwip_setsockopt+0x282>
    case TCP_NODELAY:
      if ( *(int*)optval ) {
  11990e:	8b 45 14             	mov    0x14(%ebp),%eax
  119911:	8b 00                	mov    (%eax),%eax
  119913:	85 c0                	test   %eax,%eax
  119915:	74 1c                	je     119933 <lwip_setsockopt+0x253>
        sock->conn->pcb.tcp->flags |= TF_NODELAY;
  119917:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  11991a:	8b 00                	mov    (%eax),%eax
  11991c:	8b 50 08             	mov    0x8(%eax),%edx
  11991f:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  119922:	8b 00                	mov    (%eax),%eax
  119924:	8b 40 08             	mov    0x8(%eax),%eax
  119927:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  11992b:	83 c8 40             	or     $0x40,%eax
  11992e:	88 42 20             	mov    %al,0x20(%edx)
  119931:	eb 2f                	jmp    119962 <lwip_setsockopt+0x282>
      } else {
        sock->conn->pcb.tcp->flags &= ~TF_NODELAY;
  119933:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  119936:	8b 00                	mov    (%eax),%eax
  119938:	8b 50 08             	mov    0x8(%eax),%edx
  11993b:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  11993e:	8b 00                	mov    (%eax),%eax
  119940:	8b 40 08             	mov    0x8(%eax),%eax
  119943:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  119947:	83 e0 bf             	and    $0xffffffbf,%eax
  11994a:	88 42 20             	mov    %al,0x20(%edx)
      }
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_NODELAY) -> %s\n", s, (*(int *)optval)?"on":"off") );
      break;
  11994d:	eb 13                	jmp    119962 <lwip_setsockopt+0x282>
    case TCP_KEEPALIVE:
      sock->conn->pcb.tcp->keepalive = (u32_t)(*(int*)optval);
  11994f:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  119952:	8b 00                	mov    (%eax),%eax
  119954:	8b 50 08             	mov    0x8(%eax),%edx
  119957:	8b 45 14             	mov    0x14(%ebp),%eax
  11995a:	8b 00                	mov    (%eax),%eax
  11995c:	89 82 94 00 00 00    	mov    %eax,0x94(%edx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_KEEPALIVE) -> %u\n", s, sock->conn->pcb.tcp->keepalive));
      break;
    }  /* switch */
    break;
  }  /* switch */

  sock_set_errno(sock, err);
  119962:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  119965:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  119968:	89 42 10             	mov    %eax,0x10(%edx)
  return err ? -1 : 0;
  11996b:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  11996f:	74 09                	je     11997a <lwip_setsockopt+0x29a>
  119971:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  119978:	eb 07                	jmp    119981 <lwip_setsockopt+0x2a1>
  11997a:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  119981:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  119984:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
  119987:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
}
  11998a:	c9                   	leave  
  11998b:	c3                   	ret    
  11998c:	8d 74 26 00          	lea    0x0(%esi),%esi

00119990 <lwip_ioctl>:

int lwip_ioctl(int s, long cmd, void *argp)
{
  119990:	55                   	push   %ebp
  119991:	89 e5                	mov    %esp,%ebp
  119993:	83 ec 1c             	sub    $0x1c,%esp
  struct lwip_socket *sock = get_socket(s);
  119996:	8b 45 08             	mov    0x8(%ebp),%eax
  119999:	89 04 24             	mov    %eax,(%esp)
  11999c:	e8 3f e5 ff ff       	call   117ee0 <get_socket>
  1199a1:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)

  if(!sock) {
  1199a4:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  1199a8:	75 0c                	jne    1199b6 <lwip_ioctl+0x26>
   	set_errno(EBADF);
    return -1;
  1199aa:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  1199b1:	e9 b3 00 00 00       	jmp    119a69 <lwip_ioctl+0xd9>
  }

  switch (cmd) {
  1199b6:	8b 45 0c             	mov    0xc(%ebp),%eax
  1199b9:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
  1199bc:	81 7d e8 7e 66 04 80 	cmpl   $0x8004667e,0xffffffe8(%ebp)
  1199c3:	74 49                	je     119a0e <lwip_ioctl+0x7e>
  1199c5:	81 7d e8 7f 66 04 40 	cmpl   $0x4004667f,0xffffffe8(%ebp)
  1199cc:	74 05                	je     1199d3 <lwip_ioctl+0x43>
  1199ce:	e9 85 00 00 00       	jmp    119a58 <lwip_ioctl+0xc8>
  case FIONREAD:
    if (!argp) {
  1199d3:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  1199d7:	75 13                	jne    1199ec <lwip_ioctl+0x5c>
      sock_set_errno(sock, EINVAL);
  1199d9:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1199dc:	c7 40 10 16 00 00 00 	movl   $0x16,0x10(%eax)
      return -1;
  1199e3:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  1199ea:	eb 7d                	jmp    119a69 <lwip_ioctl+0xd9>
    }

    *((u16_t*)argp) = sock->conn->recv_avail;
  1199ec:	8b 55 10             	mov    0x10(%ebp),%edx
  1199ef:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1199f2:	8b 00                	mov    (%eax),%eax
  1199f4:	0f b7 40 24          	movzwl 0x24(%eax),%eax
  1199f8:	66 89 02             	mov    %ax,(%edx)

    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONREAD, %p) = %u\n", s, argp, *((u16_t*)argp)));
    sock_set_errno(sock, 0);
  1199fb:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1199fe:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
    return 0;
  119a05:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  119a0c:	eb 5b                	jmp    119a69 <lwip_ioctl+0xd9>

  case FIONBIO:
    if (argp && *(u32_t*)argp)
  119a0e:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  119a12:	74 1e                	je     119a32 <lwip_ioctl+0xa2>
  119a14:	8b 45 10             	mov    0x10(%ebp),%eax
  119a17:	8b 00                	mov    (%eax),%eax
  119a19:	85 c0                	test   %eax,%eax
  119a1b:	74 15                	je     119a32 <lwip_ioctl+0xa2>
      sock->flags |= O_NONBLOCK;
  119a1d:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  119a20:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
  119a24:	89 c2                	mov    %eax,%edx
  119a26:	80 ce 08             	or     $0x8,%dh
  119a29:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  119a2c:	66 89 50 0e          	mov    %dx,0xe(%eax)
  119a30:	eb 13                	jmp    119a45 <lwip_ioctl+0xb5>
    else
      sock->flags &= ~O_NONBLOCK;
  119a32:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  119a35:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
  119a39:	89 c2                	mov    %eax,%edx
  119a3b:	80 e6 f7             	and    $0xf7,%dh
  119a3e:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  119a41:	66 89 50 0e          	mov    %dx,0xe(%eax)
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONBIO, %d)\n", s, !!(sock->flags & O_NONBLOCK)));
    sock_set_errno(sock, 0);
  119a45:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  119a48:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
    return 0;
  119a4f:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  119a56:	eb 11                	jmp    119a69 <lwip_ioctl+0xd9>

  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, UNIMPL: 0x%lx, %p)\n", s, cmd, argp));
    sock_set_errno(sock, ENOSYS); /* not yet implemented */
  119a58:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  119a5b:	c7 40 10 26 00 00 00 	movl   $0x26,0x10(%eax)
    return -1;
  119a62:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  119a69:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  }
}
  119a6c:	c9                   	leave  
  119a6d:	c3                   	ret    
  119a6e:	90                   	nop    
  119a6f:	90                   	nop    

00119a70 <tcpip_tcp_timer>:


static void
tcpip_tcp_timer(void *arg)
{
  119a70:	55                   	push   %ebp
  119a71:	89 e5                	mov    %esp,%ebp
  119a73:	83 ec 18             	sub    $0x18,%esp
  (void)arg;

  tcp_tmr();
  119a76:	e8 75 67 ff ff       	call   1101f0 <tcp_tmr>
  if (tcp_active_pcbs || tcp_tw_pcbs) {
  119a7b:	a1 54 16 14 00       	mov    0x141654,%eax
  119a80:	85 c0                	test   %eax,%eax
  119a82:	75 09                	jne    119a8d <tcpip_tcp_timer+0x1d>
  119a84:	a1 64 16 14 00       	mov    0x141664,%eax
  119a89:	85 c0                	test   %eax,%eax
  119a8b:	74 1e                	je     119aab <tcpip_tcp_timer+0x3b>
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
  119a8d:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  119a94:	00 
  119a95:	c7 44 24 04 70 9a 11 	movl   $0x119a70,0x4(%esp)
  119a9c:	00 
  119a9d:	c7 04 24 fa 00 00 00 	movl   $0xfa,(%esp)
  119aa4:	e8 47 64 ff ff       	call   10fef0 <sys_timeout>
  119aa9:	eb 0a                	jmp    119ab5 <tcpip_tcp_timer+0x45>
  } else {
  tcpip_tcp_timer_active = 0;
  119aab:	c7 05 b4 99 13 00 00 	movl   $0x0,0x1399b4
  119ab2:	00 00 00 
  }
}
  119ab5:	c9                   	leave  
  119ab6:	c3                   	ret    
  119ab7:	89 f6                	mov    %esi,%esi
  119ab9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00119ac0 <tcp_timer_needed>:

void
tcp_timer_needed(void)
{
  119ac0:	55                   	push   %ebp
  119ac1:	89 e5                	mov    %esp,%ebp
  119ac3:	83 ec 18             	sub    $0x18,%esp
  if (!tcpip_tcp_timer_active && (tcp_active_pcbs || tcp_tw_pcbs)) {
  119ac6:	a1 b4 99 13 00       	mov    0x1399b4,%eax
  119acb:	85 c0                	test   %eax,%eax
  119acd:	75 38                	jne    119b07 <tcp_timer_needed+0x47>
  119acf:	a1 54 16 14 00       	mov    0x141654,%eax
  119ad4:	85 c0                	test   %eax,%eax
  119ad6:	75 09                	jne    119ae1 <tcp_timer_needed+0x21>
  119ad8:	a1 64 16 14 00       	mov    0x141664,%eax
  119add:	85 c0                	test   %eax,%eax
  119adf:	74 26                	je     119b07 <tcp_timer_needed+0x47>
  tcpip_tcp_timer_active = 1;
  119ae1:	c7 05 b4 99 13 00 01 	movl   $0x1,0x1399b4
  119ae8:	00 00 00 
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
  119aeb:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  119af2:	00 
  119af3:	c7 44 24 04 70 9a 11 	movl   $0x119a70,0x4(%esp)
  119afa:	00 
  119afb:	c7 04 24 fa 00 00 00 	movl   $0xfa,(%esp)
  119b02:	e8 e9 63 ff ff       	call   10fef0 <sys_timeout>
  }
}
  119b07:	c9                   	leave  
  119b08:	c3                   	ret    
  119b09:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

00119b10 <tcpip_thread>:
#endif /* LWIP_TCP */

static void
tcpip_thread(void *arg)
{
  119b10:	55                   	push   %ebp
  119b11:	89 e5                	mov    %esp,%ebp
  119b13:	83 ec 28             	sub    $0x28,%esp
  struct tcpip_msg *msg;

  (void)arg;

  ip_init();
  119b16:	e8 c5 2f ff ff       	call   10cae0 <ip_init>
#if LWIP_UDP  
  udp_init();
  119b1b:	e8 b0 b0 ff ff       	call   114bd0 <udp_init>
#endif
#if LWIP_TCP
  tcp_init();
  119b20:	e8 8b 66 ff ff       	call   1101b0 <tcp_init>
#endif
  if (tcpip_init_done != NULL) {
  119b25:	a1 b0 99 13 00       	mov    0x1399b0,%eax
  119b2a:	85 c0                	test   %eax,%eax
  119b2c:	74 10                	je     119b3e <tcpip_thread+0x2e>
    tcpip_init_done(tcpip_init_done_arg);
  119b2e:	8b 15 b0 99 13 00    	mov    0x1399b0,%edx
  119b34:	a1 b8 99 13 00       	mov    0x1399b8,%eax
  119b39:	89 04 24             	mov    %eax,(%esp)
  119b3c:	ff d2                	call   *%edx
  }

  while (1) {                          /* MAIN Loop */
    sys_mbox_fetch(mbox, (void *)&msg);
  119b3e:	8d 45 fc             	lea    0xfffffffc(%ebp),%eax
  119b41:	8b 15 bc 99 13 00    	mov    0x1399bc,%edx
  119b47:	89 44 24 04          	mov    %eax,0x4(%esp)
  119b4b:	89 14 24             	mov    %edx,(%esp)
  119b4e:	e8 ad 61 ff ff       	call   10fd00 <sys_mbox_fetch>
    switch (msg->type) {
  119b53:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  119b56:	8b 00                	mov    (%eax),%eax
  119b58:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  119b5b:	83 7d ec 01          	cmpl   $0x1,0xffffffec(%ebp)
  119b5f:	74 1e                	je     119b7f <tcpip_thread+0x6f>
  119b61:	83 7d ec 01          	cmpl   $0x1,0xffffffec(%ebp)
  119b65:	72 08                	jb     119b6f <tcpip_thread+0x5f>
  119b67:	83 7d ec 02          	cmpl   $0x2,0xffffffec(%ebp)
  119b6b:	74 2c                	je     119b99 <tcpip_thread+0x89>
  119b6d:	eb 3b                	jmp    119baa <tcpip_thread+0x9a>
    case TCPIP_MSG_API:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: API message %p\n", (void *)msg));
      api_msg_input(msg->msg.apimsg);
  119b6f:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  119b72:	8b 40 08             	mov    0x8(%eax),%eax
  119b75:	89 04 24             	mov    %eax,(%esp)
  119b78:	e8 03 e3 ff ff       	call   117e80 <api_msg_input>
      break;
  119b7d:	eb 2b                	jmp    119baa <tcpip_thread+0x9a>
    case TCPIP_MSG_INPUT:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: IP packet %p\n", (void *)msg));
      ip_input(msg->msg.inp.p, msg->msg.inp.netif);
  119b7f:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  119b82:	8b 50 0c             	mov    0xc(%eax),%edx
  119b85:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  119b88:	8b 40 08             	mov    0x8(%eax),%eax
  119b8b:	89 54 24 04          	mov    %edx,0x4(%esp)
  119b8f:	89 04 24             	mov    %eax,(%esp)
  119b92:	e8 b9 2f ff ff       	call   10cb50 <ip_input>
      break;
  119b97:	eb 11                	jmp    119baa <tcpip_thread+0x9a>
    case TCPIP_MSG_CALLBACK:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: CALLBACK %p\n", (void *)msg));
      msg->msg.cb.f(msg->msg.cb.ctx);
  119b99:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  119b9c:	8b 50 08             	mov    0x8(%eax),%edx
  119b9f:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  119ba2:	8b 40 0c             	mov    0xc(%eax),%eax
  119ba5:	89 04 24             	mov    %eax,(%esp)
  119ba8:	ff d2                	call   *%edx
      break;
    default:
      break;
    }
    memp_free(MEMP_TCPIP_MSG, msg);
  119baa:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  119bad:	89 44 24 04          	mov    %eax,0x4(%esp)
  119bb1:	c7 04 24 09 00 00 00 	movl   $0x9,(%esp)
  119bb8:	e8 f3 4e ff ff       	call   10eab0 <memp_free>
  }
  119bbd:	e9 7c ff ff ff       	jmp    119b3e <tcpip_thread+0x2e>
  119bc2:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi
  119bc9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00119bd0 <tcpip_input>:
}

err_t
tcpip_input(struct pbuf *p, struct netif *inp)
{
  119bd0:	55                   	push   %ebp
  119bd1:	89 e5                	mov    %esp,%ebp
  119bd3:	83 ec 28             	sub    $0x28,%esp
  struct tcpip_msg *msg;
  
  msg = memp_malloc(MEMP_TCPIP_MSG);
  119bd6:	c7 04 24 09 00 00 00 	movl   $0x9,(%esp)
  119bdd:	e8 de 4d ff ff       	call   10e9c0 <memp_malloc>
  119be2:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  if (msg == NULL) {
  119be5:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  119be9:	75 14                	jne    119bff <tcpip_input+0x2f>
    pbuf_free(p);    
  119beb:	8b 45 08             	mov    0x8(%ebp),%eax
  119bee:	89 04 24             	mov    %eax,(%esp)
  119bf1:	e8 ba 58 ff ff       	call   10f4b0 <pbuf_free>
    return ERR_MEM;  
  119bf6:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  119bfd:	eb 37                	jmp    119c36 <tcpip_input+0x66>
  }
  
  msg->type = TCPIP_MSG_INPUT;
  119bff:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  119c02:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
  msg->msg.inp.p = p;
  119c08:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  119c0b:	8b 45 08             	mov    0x8(%ebp),%eax
  119c0e:	89 42 08             	mov    %eax,0x8(%edx)
  msg->msg.inp.netif = inp;
  119c11:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  119c14:	8b 45 0c             	mov    0xc(%ebp),%eax
  119c17:	89 42 0c             	mov    %eax,0xc(%edx)
  sys_mbox_post(mbox, msg);
  119c1a:	8b 15 bc 99 13 00    	mov    0x1399bc,%edx
  119c20:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  119c23:	89 44 24 04          	mov    %eax,0x4(%esp)
  119c27:	89 14 24             	mov    %edx,(%esp)
  119c2a:	e8 51 03 00 00       	call   119f80 <sys_mbox_post>
  return ERR_OK;
  119c2f:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  119c36:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  119c39:	c9                   	leave  
  119c3a:	c3                   	ret    
  119c3b:	90                   	nop    
  119c3c:	8d 74 26 00          	lea    0x0(%esi),%esi

00119c40 <tcpip_callback>:

err_t
tcpip_callback(void (*f)(void *ctx), void *ctx)
{
  119c40:	55                   	push   %ebp
  119c41:	89 e5                	mov    %esp,%ebp
  119c43:	83 ec 28             	sub    $0x28,%esp
  struct tcpip_msg *msg;
  
  msg = memp_malloc(MEMP_TCPIP_MSG);
  119c46:	c7 04 24 09 00 00 00 	movl   $0x9,(%esp)
  119c4d:	e8 6e 4d ff ff       	call   10e9c0 <memp_malloc>
  119c52:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  if (msg == NULL) {
  119c55:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  119c59:	75 09                	jne    119c64 <tcpip_callback+0x24>
    return ERR_MEM;  
  119c5b:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  119c62:	eb 37                	jmp    119c9b <tcpip_callback+0x5b>
  }
  
  msg->type = TCPIP_MSG_CALLBACK;
  119c64:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  119c67:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
  msg->msg.cb.f = f;
  119c6d:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  119c70:	8b 45 08             	mov    0x8(%ebp),%eax
  119c73:	89 42 08             	mov    %eax,0x8(%edx)
  msg->msg.cb.ctx = ctx;
  119c76:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  119c79:	8b 45 0c             	mov    0xc(%ebp),%eax
  119c7c:	89 42 0c             	mov    %eax,0xc(%edx)
  sys_mbox_post(mbox, msg);
  119c7f:	8b 15 bc 99 13 00    	mov    0x1399bc,%edx
  119c85:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  119c88:	89 44 24 04          	mov    %eax,0x4(%esp)
  119c8c:	89 14 24             	mov    %edx,(%esp)
  119c8f:	e8 ec 02 00 00       	call   119f80 <sys_mbox_post>
  return ERR_OK;
  119c94:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  119c9b:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  119c9e:	c9                   	leave  
  119c9f:	c3                   	ret    

00119ca0 <tcpip_apimsg>:

void
tcpip_apimsg(struct api_msg *apimsg)
{
  119ca0:	55                   	push   %ebp
  119ca1:	89 e5                	mov    %esp,%ebp
  119ca3:	83 ec 18             	sub    $0x18,%esp
  struct tcpip_msg *msg;
  msg = memp_malloc(MEMP_TCPIP_MSG);
  119ca6:	c7 04 24 09 00 00 00 	movl   $0x9,(%esp)
  119cad:	e8 0e 4d ff ff       	call   10e9c0 <memp_malloc>
  119cb2:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  if (msg == NULL) {
  119cb5:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  119cb9:	75 15                	jne    119cd0 <tcpip_apimsg+0x30>
    memp_free(MEMP_API_MSG, apimsg);
  119cbb:	8b 45 08             	mov    0x8(%ebp),%eax
  119cbe:	89 44 24 04          	mov    %eax,0x4(%esp)
  119cc2:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  119cc9:	e8 e2 4d ff ff       	call   10eab0 <memp_free>
    return;
  119cce:	eb 27                	jmp    119cf7 <tcpip_apimsg+0x57>
  }
  msg->type = TCPIP_MSG_API;
  119cd0:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  119cd3:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  msg->msg.apimsg = apimsg;
  119cd9:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  119cdc:	8b 45 08             	mov    0x8(%ebp),%eax
  119cdf:	89 42 08             	mov    %eax,0x8(%edx)
  sys_mbox_post(mbox, msg);
  119ce2:	8b 15 bc 99 13 00    	mov    0x1399bc,%edx
  119ce8:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  119ceb:	89 44 24 04          	mov    %eax,0x4(%esp)
  119cef:	89 14 24             	mov    %edx,(%esp)
  119cf2:	e8 89 02 00 00       	call   119f80 <sys_mbox_post>
}
  119cf7:	c9                   	leave  
  119cf8:	c3                   	ret    
  119cf9:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

00119d00 <tcpip_init>:

void
tcpip_init(void (* initfunc)(void *), void *arg)
{
  119d00:	55                   	push   %ebp
  119d01:	89 e5                	mov    %esp,%ebp
  119d03:	83 ec 18             	sub    $0x18,%esp
  tcpip_init_done = initfunc;
  119d06:	8b 45 08             	mov    0x8(%ebp),%eax
  119d09:	a3 b0 99 13 00       	mov    %eax,0x1399b0
  tcpip_init_done_arg = arg;
  119d0e:	8b 45 0c             	mov    0xc(%ebp),%eax
  119d11:	a3 b8 99 13 00       	mov    %eax,0x1399b8
  mbox = sys_mbox_new();
  119d16:	e8 35 01 00 00       	call   119e50 <sys_mbox_new>
  119d1b:	a3 bc 99 13 00       	mov    %eax,0x1399bc
  sys_thread_new(tcpip_thread, NULL, TCPIP_THREAD_PRIO);
  119d20:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  119d27:	00 
  119d28:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  119d2f:	00 
  119d30:	c7 04 24 10 9b 11 00 	movl   $0x119b10,(%esp)
  119d37:	e8 f4 03 00 00       	call   11a130 <sys_thread_new>
}
  119d3c:	c9                   	leave  
  119d3d:	c3                   	ret    
  119d3e:	90                   	nop    
  119d3f:	90                   	nop    

00119d40 <sys_sem_new>:

struct sys_timeouts sys_touts;

sys_sem_t sys_sem_new(u8_t count)
{
  119d40:	55                   	push   %ebp
  119d41:	89 e5                	mov    %esp,%ebp
  119d43:	83 ec 28             	sub    $0x28,%esp
  119d46:	8b 45 08             	mov    0x8(%ebp),%eax
  119d49:	88 45 ec             	mov    %al,0xffffffec(%ebp)
    sys_sem_t sem = (sys_sem_t)kmalloc(sem_size());
  119d4c:	e8 4f fe fe ff       	call   109ba0 <sem_size>
  119d51:	89 04 24             	mov    %eax,(%esp)
  119d54:	e8 27 98 fe ff       	call   103580 <kmalloc>
  119d59:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
    if (!sem)
  119d5c:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  119d60:	75 09                	jne    119d6b <sys_sem_new+0x2b>
        return SYS_SEM_NULL;
  119d62:	c7 45 e8 00 00 00 00 	movl   $0x0,0xffffffe8(%ebp)
  119d69:	eb 19                	jmp    119d84 <sys_sem_new+0x44>
    sem_init(sem, count);
  119d6b:	0f b6 45 ec          	movzbl 0xffffffec(%ebp),%eax
  119d6f:	89 44 24 04          	mov    %eax,0x4(%esp)
  119d73:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  119d76:	89 04 24             	mov    %eax,(%esp)
  119d79:	e8 c2 fb fe ff       	call   109940 <sem_init>
    return sem;
  119d7e:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  119d81:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
  119d84:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
}
  119d87:	c9                   	leave  
  119d88:	c3                   	ret    
  119d89:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

00119d90 <sys_sem_free>:

void sys_sem_free(sys_sem_t sem)
{
  119d90:	55                   	push   %ebp
  119d91:	89 e5                	mov    %esp,%ebp
  119d93:	83 ec 08             	sub    $0x8,%esp
    sem_destroy(sem);
  119d96:	8b 45 08             	mov    0x8(%ebp),%eax
  119d99:	89 04 24             	mov    %eax,(%esp)
  119d9c:	e8 df fb fe ff       	call   109980 <sem_destroy>
    kmfree((char*)sem, sem_size());
  119da1:	e8 fa fd fe ff       	call   109ba0 <sem_size>
  119da6:	89 44 24 04          	mov    %eax,0x4(%esp)
  119daa:	8b 45 08             	mov    0x8(%ebp),%eax
  119dad:	89 04 24             	mov    %eax,(%esp)
  119db0:	e8 fb 97 fe ff       	call   1035b0 <kmfree>
}
  119db5:	c9                   	leave  
  119db6:	c3                   	ret    
  119db7:	89 f6                	mov    %esi,%esi
  119db9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00119dc0 <sys_sem_signal>:

void sys_sem_signal(sys_sem_t sem)
{
  119dc0:	55                   	push   %ebp
  119dc1:	89 e5                	mov    %esp,%ebp
  119dc3:	83 ec 08             	sub    $0x8,%esp
    sem_post(sem);
  119dc6:	8b 45 08             	mov    0x8(%ebp),%eax
  119dc9:	89 04 24             	mov    %eax,(%esp)
  119dcc:	e8 ef fb fe ff       	call   1099c0 <sem_post>
}
  119dd1:	c9                   	leave  
  119dd2:	c3                   	ret    
  119dd3:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  119dd9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00119de0 <sys_arch_sem_wait>:

u32_t sys_arch_sem_wait(sys_sem_t sem, u32_t timeout)
{
  119de0:	55                   	push   %ebp
  119de1:	89 e5                	mov    %esp,%ebp
  119de3:	83 ec 28             	sub    $0x28,%esp
    int s = millitime(), p;
  119de6:	e8 a5 e1 fe ff       	call   107f90 <millitime>
  119deb:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
    int ret;

    if (timeout == 0)
  119dee:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  119df2:	75 14                	jne    119e08 <sys_arch_sem_wait+0x28>
    {
        sem_wait(sem);
  119df4:	8b 45 08             	mov    0x8(%ebp),%eax
  119df7:	89 04 24             	mov    %eax,(%esp)
  119dfa:	e8 11 fc fe ff       	call   109a10 <sem_wait>
        return 0; // What should I return?...
  119dff:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  119e06:	eb 35                	jmp    119e3d <sys_arch_sem_wait+0x5d>
    }

    ret = sem_timedwait(sem, timeout);
  119e08:	8b 45 0c             	mov    0xc(%ebp),%eax
  119e0b:	89 44 24 04          	mov    %eax,0x4(%esp)
  119e0f:	8b 45 08             	mov    0x8(%ebp),%eax
  119e12:	89 04 24             	mov    %eax,(%esp)
  119e15:	e8 66 fc fe ff       	call   109a80 <sem_timedwait>
  119e1a:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
    
    p = millitime() - s;
  119e1d:	e8 6e e1 fe ff       	call   107f90 <millitime>
  119e22:	2b 45 f4             	sub    0xfffffff4(%ebp),%eax
  119e25:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
    if (ret == 0)
  119e28:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  119e2c:	75 08                	jne    119e36 <sys_arch_sem_wait+0x56>
        return p;
  119e2e:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  119e31:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  119e34:	eb 07                	jmp    119e3d <sys_arch_sem_wait+0x5d>
    else
        return SYS_ARCH_TIMEOUT;
  119e36:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  119e3d:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  119e40:	c9                   	leave  
  119e41:	c3                   	ret    
  119e42:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi
  119e49:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00119e50 <sys_mbox_new>:

#define NSLOTS 128

struct mbox {
    struct spinlock lock;
    sys_sem_t free, queued;
    int count, head, next;
    void *slots[NSLOTS];
};

sys_mbox_t sys_mbox_new(void)
{
  119e50:	55                   	push   %ebp
  119e51:	89 e5                	mov    %esp,%ebp
  119e53:	83 ec 28             	sub    $0x28,%esp
    sys_mbox_t mbox = (sys_mbox_t)kmalloc(sizeof(struct mbox));
  119e56:	c7 04 24 48 02 00 00 	movl   $0x248,(%esp)
  119e5d:	e8 1e 97 fe ff       	call   103580 <kmalloc>
  119e62:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
    if (!mbox)
  119e65:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  119e69:	75 0c                	jne    119e77 <sys_mbox_new+0x27>
        return SYS_MBOX_NULL;
  119e6b:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  119e72:	e9 8d 00 00 00       	jmp    119f04 <sys_mbox_new+0xb4>
    initlock(&mbox->lock, "mbox");
  119e77:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  119e7a:	c7 44 24 04 48 b0 11 	movl   $0x11b048,0x4(%esp)
  119e81:	00 
  119e82:	89 04 24             	mov    %eax,(%esp)
  119e85:	e8 86 bc fe ff       	call   105b10 <initlock>
    mbox->free = (sem_t *)kmalloc(sem_size());
  119e8a:	e8 11 fd fe ff       	call   109ba0 <sem_size>
  119e8f:	89 04 24             	mov    %eax,(%esp)
  119e92:	e8 e9 96 fe ff       	call   103580 <kmalloc>
  119e97:	89 c2                	mov    %eax,%edx
  119e99:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  119e9c:	89 50 34             	mov    %edx,0x34(%eax)
    mbox->queued = (sem_t *)kmalloc(sem_size());
  119e9f:	e8 fc fc fe ff       	call   109ba0 <sem_size>
  119ea4:	89 04 24             	mov    %eax,(%esp)
  119ea7:	e8 d4 96 fe ff       	call   103580 <kmalloc>
  119eac:	89 c2                	mov    %eax,%edx
  119eae:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  119eb1:	89 50 38             	mov    %edx,0x38(%eax)
    sem_init(mbox->free, NSLOTS);
  119eb4:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  119eb7:	8b 40 34             	mov    0x34(%eax),%eax
  119eba:	c7 44 24 04 80 00 00 	movl   $0x80,0x4(%esp)
  119ec1:	00 
  119ec2:	89 04 24             	mov    %eax,(%esp)
  119ec5:	e8 76 fa fe ff       	call   109940 <sem_init>
    sem_init(mbox->queued, 0);
  119eca:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  119ecd:	8b 40 38             	mov    0x38(%eax),%eax
  119ed0:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  119ed7:	00 
  119ed8:	89 04 24             	mov    %eax,(%esp)
  119edb:	e8 60 fa fe ff       	call   109940 <sem_init>
    mbox->count = 0;
  119ee0:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  119ee3:	c7 40 3c 00 00 00 00 	movl   $0x0,0x3c(%eax)
    mbox->head = -1;
  119eea:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  119eed:	c7 40 40 ff ff ff ff 	movl   $0xffffffff,0x40(%eax)
    mbox->next = 0;
  119ef4:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  119ef7:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
    return mbox;
  119efe:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  119f01:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  119f04:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
};
  119f07:	c9                   	leave  
  119f08:	c3                   	ret    
  119f09:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

00119f10 <sys_mbox_free>:

void sys_mbox_free(sys_mbox_t mbox)
{
  119f10:	55                   	push   %ebp
  119f11:	89 e5                	mov    %esp,%ebp
  119f13:	83 ec 08             	sub    $0x8,%esp
    acquire(&mbox->lock);
  119f16:	8b 45 08             	mov    0x8(%ebp),%eax
  119f19:	89 04 24             	mov    %eax,(%esp)
  119f1c:	e8 1f bc fe ff       	call   105b40 <acquire>
    sem_destroy(mbox->free);
  119f21:	8b 45 08             	mov    0x8(%ebp),%eax
  119f24:	8b 40 34             	mov    0x34(%eax),%eax
  119f27:	89 04 24             	mov    %eax,(%esp)
  119f2a:	e8 51 fa fe ff       	call   109980 <sem_destroy>
    sem_destroy(mbox->queued);
  119f2f:	8b 45 08             	mov    0x8(%ebp),%eax
  119f32:	8b 40 38             	mov    0x38(%eax),%eax
  119f35:	89 04 24             	mov    %eax,(%esp)
  119f38:	e8 43 fa fe ff       	call   109980 <sem_destroy>
    if (mbox->count != 0)
  119f3d:	8b 45 08             	mov    0x8(%ebp),%eax
  119f40:	8b 40 3c             	mov    0x3c(%eax),%eax
  119f43:	85 c0                	test   %eax,%eax
  119f45:	74 0c                	je     119f53 <sys_mbox_free+0x43>
        cprintf("sys_mbox_free: Warning: mbox not free\n");
  119f47:	c7 04 24 50 b0 11 00 	movl   $0x11b050,(%esp)
  119f4e:	e8 bd 67 fe ff       	call   100710 <cprintf>
    release(&mbox->lock);
  119f53:	8b 45 08             	mov    0x8(%ebp),%eax
  119f56:	89 04 24             	mov    %eax,(%esp)
  119f59:	e8 e2 bd fe ff       	call   105d40 <release>
    kmfree((char*)mbox, sizeof(struct mbox));
  119f5e:	c7 44 24 04 48 02 00 	movl   $0x248,0x4(%esp)
  119f65:	00 
  119f66:	8b 45 08             	mov    0x8(%ebp),%eax
  119f69:	89 04 24             	mov    %eax,(%esp)
  119f6c:	e8 3f 96 fe ff       	call   1035b0 <kmfree>
}
  119f71:	c9                   	leave  
  119f72:	c3                   	ret    
  119f73:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  119f79:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00119f80 <sys_mbox_post>:

void sys_mbox_post(sys_mbox_t mbox, void *msg)
{
  119f80:	55                   	push   %ebp
  119f81:	89 e5                	mov    %esp,%ebp
  119f83:	83 ec 18             	sub    $0x18,%esp
    sem_wait(mbox->free);
  119f86:	8b 45 08             	mov    0x8(%ebp),%eax
  119f89:	8b 40 34             	mov    0x34(%eax),%eax
  119f8c:	89 04 24             	mov    %eax,(%esp)
  119f8f:	e8 7c fa fe ff       	call   109a10 <sem_wait>
    acquire(&mbox->lock);
  119f94:	8b 45 08             	mov    0x8(%ebp),%eax
  119f97:	89 04 24             	mov    %eax,(%esp)
  119f9a:	e8 a1 bb fe ff       	call   105b40 <acquire>
    if (mbox->count == NSLOTS)
  119f9f:	8b 45 08             	mov    0x8(%ebp),%eax
  119fa2:	8b 40 3c             	mov    0x3c(%eax),%eax
  119fa5:	3d 80 00 00 00       	cmp    $0x80,%eax
  119faa:	75 0d                	jne    119fb9 <sys_mbox_post+0x39>
    {
        release(&mbox->lock);
  119fac:	8b 45 08             	mov    0x8(%ebp),%eax
  119faf:	89 04 24             	mov    %eax,(%esp)
  119fb2:	e8 89 bd fe ff       	call   105d40 <release>
        return;
  119fb7:	eb 72                	jmp    11a02b <sys_mbox_post+0xab>
    }
    int slot = mbox->next;
  119fb9:	8b 45 08             	mov    0x8(%ebp),%eax
  119fbc:	8b 40 44             	mov    0x44(%eax),%eax
  119fbf:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
    mbox->next = (slot + 1) % NSLOTS;
  119fc2:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  119fc5:	83 c2 01             	add    $0x1,%edx
  119fc8:	89 d0                	mov    %edx,%eax
  119fca:	c1 f8 1f             	sar    $0x1f,%eax
  119fcd:	89 c1                	mov    %eax,%ecx
  119fcf:	c1 e9 19             	shr    $0x19,%ecx
  119fd2:	8d 04 0a             	lea    (%edx,%ecx,1),%eax
  119fd5:	83 e0 7f             	and    $0x7f,%eax
  119fd8:	29 c8                	sub    %ecx,%eax
  119fda:	89 c2                	mov    %eax,%edx
  119fdc:	8b 45 08             	mov    0x8(%ebp),%eax
  119fdf:	89 50 44             	mov    %edx,0x44(%eax)
    mbox->slots[slot] = msg;
  119fe2:	8b 4d fc             	mov    0xfffffffc(%ebp),%ecx
  119fe5:	8b 55 08             	mov    0x8(%ebp),%edx
  119fe8:	8b 45 0c             	mov    0xc(%ebp),%eax
  119feb:	89 44 8a 48          	mov    %eax,0x48(%edx,%ecx,4)
    mbox->count++;
  119fef:	8b 45 08             	mov    0x8(%ebp),%eax
  119ff2:	8b 40 3c             	mov    0x3c(%eax),%eax
  119ff5:	8d 50 01             	lea    0x1(%eax),%edx
  119ff8:	8b 45 08             	mov    0x8(%ebp),%eax
  119ffb:	89 50 3c             	mov    %edx,0x3c(%eax)
    if (mbox->head == -1)
  119ffe:	8b 45 08             	mov    0x8(%ebp),%eax
  11a001:	8b 40 40             	mov    0x40(%eax),%eax
  11a004:	83 f8 ff             	cmp    $0xffffffff,%eax
  11a007:	75 09                	jne    11a012 <sys_mbox_post+0x92>
        mbox->head = slot;
  11a009:	8b 55 08             	mov    0x8(%ebp),%edx
  11a00c:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  11a00f:	89 42 40             	mov    %eax,0x40(%edx)

    sem_post(mbox->queued);
  11a012:	8b 45 08             	mov    0x8(%ebp),%eax
  11a015:	8b 40 38             	mov    0x38(%eax),%eax
  11a018:	89 04 24             	mov    %eax,(%esp)
  11a01b:	e8 a0 f9 fe ff       	call   1099c0 <sem_post>
    release(&mbox->lock);
  11a020:	8b 45 08             	mov    0x8(%ebp),%eax
  11a023:	89 04 24             	mov    %eax,(%esp)
  11a026:	e8 15 bd fe ff       	call   105d40 <release>
}
  11a02b:	c9                   	leave  
  11a02c:	c3                   	ret    
  11a02d:	8d 76 00             	lea    0x0(%esi),%esi

0011a030 <sys_arch_mbox_fetch>:

u32_t sys_arch_mbox_fetch(sys_mbox_t mbox, void **msg, u32_t timeout)
{
  11a030:	55                   	push   %ebp
  11a031:	89 e5                	mov    %esp,%ebp
  11a033:	83 ec 28             	sub    $0x28,%esp
    u32_t waited = sys_arch_sem_wait(mbox->queued, timeout);
  11a036:	8b 45 08             	mov    0x8(%ebp),%eax
  11a039:	8b 50 38             	mov    0x38(%eax),%edx
  11a03c:	8b 45 10             	mov    0x10(%ebp),%eax
  11a03f:	89 44 24 04          	mov    %eax,0x4(%esp)
  11a043:	89 14 24             	mov    %edx,(%esp)
  11a046:	e8 95 fd ff ff       	call   119de0 <sys_arch_sem_wait>
  11a04b:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
    acquire(&mbox->lock);
  11a04e:	8b 45 08             	mov    0x8(%ebp),%eax
  11a051:	89 04 24             	mov    %eax,(%esp)
  11a054:	e8 e7 ba fe ff       	call   105b40 <acquire>
    if (waited == SYS_ARCH_TIMEOUT)
  11a059:	83 7d f8 ff          	cmpl   $0xffffffff,0xfffffff8(%ebp)
  11a05d:	75 16                	jne    11a075 <sys_arch_mbox_fetch+0x45>
    {
        release(&mbox->lock);
  11a05f:	8b 45 08             	mov    0x8(%ebp),%eax
  11a062:	89 04 24             	mov    %eax,(%esp)
  11a065:	e8 d6 bc fe ff       	call   105d40 <release>
        return waited;
  11a06a:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  11a06d:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  11a070:	e9 a6 00 00 00       	jmp    11a11b <sys_arch_mbox_fetch+0xeb>
    }

    int slot = mbox->head;
  11a075:	8b 45 08             	mov    0x8(%ebp),%eax
  11a078:	8b 40 40             	mov    0x40(%eax),%eax
  11a07b:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
    if (slot == -1)
  11a07e:	83 7d fc ff          	cmpl   $0xffffffff,0xfffffffc(%ebp)
  11a082:	75 20                	jne    11a0a4 <sys_arch_mbox_fetch+0x74>
    {
        release(&mbox->lock);
  11a084:	8b 45 08             	mov    0x8(%ebp),%eax
  11a087:	89 04 24             	mov    %eax,(%esp)
  11a08a:	e8 b1 bc fe ff       	call   105d40 <release>
        cprintf("fetch failed!\n");
  11a08f:	c7 04 24 77 b0 11 00 	movl   $0x11b077,(%esp)
  11a096:	e8 75 66 fe ff       	call   100710 <cprintf>
        return SYS_ARCH_TIMEOUT; // XXX panic is not good...
  11a09b:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  11a0a2:	eb 77                	jmp    11a11b <sys_arch_mbox_fetch+0xeb>
    }

    if (msg)
  11a0a4:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  11a0a8:	74 0f                	je     11a0b9 <sys_arch_mbox_fetch+0x89>
        *msg = mbox->slots[slot];
  11a0aa:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  11a0ad:	8b 45 08             	mov    0x8(%ebp),%eax
  11a0b0:	8b 54 90 48          	mov    0x48(%eax,%edx,4),%edx
  11a0b4:	8b 45 0c             	mov    0xc(%ebp),%eax
  11a0b7:	89 10                	mov    %edx,(%eax)

    mbox->head = (slot + 1) % NSLOTS;
  11a0b9:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  11a0bc:	83 c2 01             	add    $0x1,%edx
  11a0bf:	89 d0                	mov    %edx,%eax
  11a0c1:	c1 f8 1f             	sar    $0x1f,%eax
  11a0c4:	89 c1                	mov    %eax,%ecx
  11a0c6:	c1 e9 19             	shr    $0x19,%ecx
  11a0c9:	8d 04 0a             	lea    (%edx,%ecx,1),%eax
  11a0cc:	83 e0 7f             	and    $0x7f,%eax
  11a0cf:	29 c8                	sub    %ecx,%eax
  11a0d1:	89 c2                	mov    %eax,%edx
  11a0d3:	8b 45 08             	mov    0x8(%ebp),%eax
  11a0d6:	89 50 40             	mov    %edx,0x40(%eax)
    mbox->count--;
  11a0d9:	8b 45 08             	mov    0x8(%ebp),%eax
  11a0dc:	8b 40 3c             	mov    0x3c(%eax),%eax
  11a0df:	8d 50 ff             	lea    0xffffffff(%eax),%edx
  11a0e2:	8b 45 08             	mov    0x8(%ebp),%eax
  11a0e5:	89 50 3c             	mov    %edx,0x3c(%eax)
    if (mbox->count == 0)
  11a0e8:	8b 45 08             	mov    0x8(%ebp),%eax
  11a0eb:	8b 40 3c             	mov    0x3c(%eax),%eax
  11a0ee:	85 c0                	test   %eax,%eax
  11a0f0:	75 0a                	jne    11a0fc <sys_arch_mbox_fetch+0xcc>
        mbox->head = -1;
  11a0f2:	8b 45 08             	mov    0x8(%ebp),%eax
  11a0f5:	c7 40 40 ff ff ff ff 	movl   $0xffffffff,0x40(%eax)

    sem_post(mbox->free);
  11a0fc:	8b 45 08             	mov    0x8(%ebp),%eax
  11a0ff:	8b 40 34             	mov    0x34(%eax),%eax
  11a102:	89 04 24             	mov    %eax,(%esp)
  11a105:	e8 b6 f8 fe ff       	call   1099c0 <sem_post>
    release(&mbox->lock);
  11a10a:	8b 45 08             	mov    0x8(%ebp),%eax
  11a10d:	89 04 24             	mov    %eax,(%esp)
  11a110:	e8 2b bc fe ff       	call   105d40 <release>
    return waited;
  11a115:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  11a118:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  11a11b:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  11a11e:	c9                   	leave  
  11a11f:	c3                   	ret    

0011a120 <sys_jiffies>:

u32_t sys_jiffies(void)
{
  11a120:	55                   	push   %ebp
  11a121:	89 e5                	mov    %esp,%ebp
  11a123:	83 ec 08             	sub    $0x8,%esp
    return millitime();
  11a126:	e8 65 de fe ff       	call   107f90 <millitime>
}
  11a12b:	c9                   	leave  
  11a12c:	c3                   	ret    
  11a12d:	8d 76 00             	lea    0x0(%esi),%esi

0011a130 <sys_thread_new>:

sys_thread_t sys_thread_new(void (* thread)(void *arg), void *arg, int prio)
{
  11a130:	55                   	push   %ebp
  11a131:	89 e5                	mov    %esp,%ebp
  11a133:	83 ec 18             	sub    $0x18,%esp
    return kproc_start(thread, arg, prio, 0, 0);;
  11a136:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  11a13d:	00 
  11a13e:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  11a145:	00 
  11a146:	8b 45 10             	mov    0x10(%ebp),%eax
  11a149:	89 44 24 08          	mov    %eax,0x8(%esp)
  11a14d:	8b 45 0c             	mov    0xc(%ebp),%eax
  11a150:	89 44 24 04          	mov    %eax,0x4(%esp)
  11a154:	8b 45 08             	mov    0x8(%ebp),%eax
  11a157:	89 04 24             	mov    %eax,(%esp)
  11a15a:	e8 51 fa fe ff       	call   109bb0 <kproc_start>
}
  11a15f:	c9                   	leave  
  11a160:	c3                   	ret    
  11a161:	eb 0d                	jmp    11a170 <sys_arch_timeouts>
  11a163:	90                   	nop    
  11a164:	90                   	nop    
  11a165:	90                   	nop    
  11a166:	90                   	nop    
  11a167:	90                   	nop    
  11a168:	90                   	nop    
  11a169:	90                   	nop    
  11a16a:	90                   	nop    
  11a16b:	90                   	nop    
  11a16c:	90                   	nop    
  11a16d:	90                   	nop    
  11a16e:	90                   	nop    
  11a16f:	90                   	nop    

0011a170 <sys_arch_timeouts>:

struct sys_timeouts *
sys_arch_timeouts(void)
{
  11a170:	55                   	push   %ebp
  11a171:	89 e5                	mov    %esp,%ebp
  11a173:	83 ec 08             	sub    $0x8,%esp
    if (cp)
  11a176:	e8 45 97 fe ff       	call   1038c0 <cpu>
  11a17b:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  11a182:	85 c0                	test   %eax,%eax
  11a184:	74 1a                	je     11a1a0 <sys_arch_timeouts+0x30>
        return &cp->thr->timeouts;
  11a186:	e8 35 97 fe ff       	call   1038c0 <cpu>
  11a18b:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  11a192:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
  11a198:	83 c0 08             	add    $0x8,%eax
  11a19b:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  11a19e:	eb 07                	jmp    11a1a7 <sys_arch_timeouts+0x37>
    else
        return &sys_touts;
  11a1a0:	c7 45 fc 6c 16 14 00 	movl   $0x14166c,0xfffffffc(%ebp)
  11a1a7:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
}
  11a1aa:	c9                   	leave  
  11a1ab:	c3                   	ret    
