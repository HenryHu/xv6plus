
kernel:     file format elf32-i386-freebsd

Disassembly of section .text:

00100000 <binit>:
struct buf bufhead;

void
binit(void)
{
  100000:	55                   	push   %ebp
  100001:	89 e5                	mov    %esp,%ebp
  100003:	83 ec 18             	sub    $0x18,%esp
  struct buf *b;

  initlock(&buf_table_lock, "buf_table");
  100006:	c7 44 24 04 bc a1 11 	movl   $0x11a1bc,0x4(%esp)
  10000d:	00 
  10000e:	c7 04 24 e0 b0 13 00 	movl   $0x13b0e0,(%esp)
  100015:	e8 c6 5a 00 00       	call   105ae0 <initlock>

  // Create linked list of buffers
  bufhead.prev = &bufhead;
  10001a:	c7 05 cc 99 13 00 c0 	movl   $0x1399c0,0x1399cc
  100021:	99 13 00 
  bufhead.next = &bufhead;
  100024:	c7 05 d0 99 13 00 c0 	movl   $0x1399c0,0x1399d0
  10002b:	99 13 00 
  for(b = buf; b < buf+NBUF; b++){
  10002e:	c7 45 fc e0 9b 13 00 	movl   $0x139be0,0xfffffffc(%ebp)
  100035:	eb 31                	jmp    100068 <binit+0x68>
    b->next = bufhead.next;
  100037:	8b 15 d0 99 13 00    	mov    0x1399d0,%edx
  10003d:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  100040:	89 50 10             	mov    %edx,0x10(%eax)
    b->prev = &bufhead;
  100043:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  100046:	c7 40 0c c0 99 13 00 	movl   $0x1399c0,0xc(%eax)
    bufhead.next->prev = b;
  10004d:	8b 15 d0 99 13 00    	mov    0x1399d0,%edx
  100053:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  100056:	89 42 0c             	mov    %eax,0xc(%edx)
    bufhead.next = b;
  100059:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10005c:	a3 d0 99 13 00       	mov    %eax,0x1399d0
  100061:	81 45 fc 18 02 00 00 	addl   $0x218,0xfffffffc(%ebp)
  100068:	b8 d0 b0 13 00       	mov    $0x13b0d0,%eax
  10006d:	39 45 fc             	cmp    %eax,0xfffffffc(%ebp)
  100070:	72 c5                	jb     100037 <binit+0x37>
  }
}
  100072:	c9                   	leave  
  100073:	c3                   	ret    
  100074:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  10007a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

00100080 <bget>:

// Look through buffer cache for sector on device dev.
// If not found, allocate fresh block.
// In either case, return locked buffer.
static struct buf*
bget(uint dev, uint sector)
{
  100080:	55                   	push   %ebp
  100081:	89 e5                	mov    %esp,%ebp
  100083:	83 ec 28             	sub    $0x28,%esp
  struct buf *b;

  acquire(&buf_table_lock);
  100086:	c7 04 24 e0 b0 13 00 	movl   $0x13b0e0,(%esp)
  10008d:	e8 7e 5a 00 00       	call   105b10 <acquire>

 loop:
  // Try for cached block.
  for(b = bufhead.next; b != &bufhead; b = b->next){
  100092:	a1 d0 99 13 00       	mov    0x1399d0,%eax
  100097:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  10009a:	eb 70                	jmp    10010c <bget+0x8c>
    if((b->flags & (B_BUSY|B_VALID)) &&
  10009c:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10009f:	8b 00                	mov    (%eax),%eax
  1000a1:	83 e0 03             	and    $0x3,%eax
  1000a4:	85 c0                	test   %eax,%eax
  1000a6:	74 5b                	je     100103 <bget+0x83>
  1000a8:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1000ab:	8b 40 04             	mov    0x4(%eax),%eax
  1000ae:	3b 45 08             	cmp    0x8(%ebp),%eax
  1000b1:	75 50                	jne    100103 <bget+0x83>
  1000b3:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1000b6:	8b 40 08             	mov    0x8(%eax),%eax
  1000b9:	3b 45 0c             	cmp    0xc(%ebp),%eax
  1000bc:	75 45                	jne    100103 <bget+0x83>
       b->dev == dev && b->sector == sector){
      if(b->flags & B_BUSY){
  1000be:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1000c1:	8b 00                	mov    (%eax),%eax
  1000c3:	83 e0 01             	and    $0x1,%eax
  1000c6:	84 c0                	test   %al,%al
  1000c8:	74 16                	je     1000e0 <bget+0x60>
        sleep(buf, &buf_table_lock);
  1000ca:	c7 44 24 04 e0 b0 13 	movl   $0x13b0e0,0x4(%esp)
  1000d1:	00 
  1000d2:	c7 04 24 e0 9b 13 00 	movl   $0x139be0,(%esp)
  1000d9:	e8 82 53 00 00       	call   105460 <sleep>
        goto loop;
  1000de:	eb b2                	jmp    100092 <bget+0x12>
      }
      b->flags |= B_BUSY;
  1000e0:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1000e3:	8b 00                	mov    (%eax),%eax
  1000e5:	89 c2                	mov    %eax,%edx
  1000e7:	83 ca 01             	or     $0x1,%edx
  1000ea:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1000ed:	89 10                	mov    %edx,(%eax)
      release(&buf_table_lock);
  1000ef:	c7 04 24 e0 b0 13 00 	movl   $0x13b0e0,(%esp)
  1000f6:	e8 15 5c 00 00       	call   105d10 <release>
      return b;
  1000fb:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1000fe:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  100101:	eb 75                	jmp    100178 <bget+0xf8>
  100103:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  100106:	8b 40 10             	mov    0x10(%eax),%eax
  100109:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  10010c:	81 7d fc c0 99 13 00 	cmpl   $0x1399c0,0xfffffffc(%ebp)
  100113:	75 87                	jne    10009c <bget+0x1c>
    }
  }

  // Allocate fresh block.
  for(b = bufhead.prev; b != &bufhead; b = b->prev){
  100115:	a1 cc 99 13 00       	mov    0x1399cc,%eax
  10011a:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  10011d:	eb 44                	jmp    100163 <bget+0xe3>
    if((b->flags & B_BUSY) == 0){
  10011f:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  100122:	8b 00                	mov    (%eax),%eax
  100124:	83 e0 01             	and    $0x1,%eax
  100127:	85 c0                	test   %eax,%eax
  100129:	75 2f                	jne    10015a <bget+0xda>
      b->flags = B_BUSY;
  10012b:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10012e:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
      b->dev = dev;
  100134:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  100137:	8b 45 08             	mov    0x8(%ebp),%eax
  10013a:	89 42 04             	mov    %eax,0x4(%edx)
      b->sector = sector;
  10013d:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  100140:	8b 45 0c             	mov    0xc(%ebp),%eax
  100143:	89 42 08             	mov    %eax,0x8(%edx)
      release(&buf_table_lock);
  100146:	c7 04 24 e0 b0 13 00 	movl   $0x13b0e0,(%esp)
  10014d:	e8 be 5b 00 00       	call   105d10 <release>
      return b;
  100152:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  100155:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  100158:	eb 1e                	jmp    100178 <bget+0xf8>
  10015a:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10015d:	8b 40 0c             	mov    0xc(%eax),%eax
  100160:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  100163:	81 7d fc c0 99 13 00 	cmpl   $0x1399c0,0xfffffffc(%ebp)
  10016a:	75 b3                	jne    10011f <bget+0x9f>
    }
  }
  panic("bget: no buffers");
  10016c:	c7 04 24 c6 a1 11 00 	movl   $0x11a1c6,(%esp)
  100173:	e8 88 0e 00 00       	call   101000 <panic>
  100178:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  10017b:	c9                   	leave  
  10017c:	c3                   	ret    
  10017d:	8d 76 00             	lea    0x0(%esi),%esi

00100180 <bread>:

// Return a B_BUSY buf with the contents of the indicated disk sector.
struct buf*
bread(uint dev, uint sector)
{
  100180:	55                   	push   %ebp
  100181:	89 e5                	mov    %esp,%ebp
  100183:	83 ec 18             	sub    $0x18,%esp
  struct buf *b;

  b = bget(dev, sector);
  100186:	8b 45 0c             	mov    0xc(%ebp),%eax
  100189:	89 44 24 04          	mov    %eax,0x4(%esp)
  10018d:	8b 45 08             	mov    0x8(%ebp),%eax
  100190:	89 04 24             	mov    %eax,(%esp)
  100193:	e8 e8 fe ff ff       	call   100080 <bget>
  100198:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  if(!(b->flags & B_VALID))
  10019b:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10019e:	8b 00                	mov    (%eax),%eax
  1001a0:	83 e0 02             	and    $0x2,%eax
  1001a3:	85 c0                	test   %eax,%eax
  1001a5:	75 0b                	jne    1001b2 <bread+0x32>
    ide_rw(b);
  1001a7:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1001aa:	89 04 24             	mov    %eax,(%esp)
  1001ad:	e8 ae 2e 00 00       	call   103060 <ide_rw>
  return b;
  1001b2:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
}
  1001b5:	c9                   	leave  
  1001b6:	c3                   	ret    
  1001b7:	89 f6                	mov    %esi,%esi
  1001b9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

001001c0 <bwrite>:

// Write buf's contents to disk.  Must be locked.
void
bwrite(struct buf *b)
{
  1001c0:	55                   	push   %ebp
  1001c1:	89 e5                	mov    %esp,%ebp
  1001c3:	83 ec 08             	sub    $0x8,%esp
  if((b->flags & B_BUSY) == 0)
  1001c6:	8b 45 08             	mov    0x8(%ebp),%eax
  1001c9:	8b 00                	mov    (%eax),%eax
  1001cb:	83 e0 01             	and    $0x1,%eax
  1001ce:	85 c0                	test   %eax,%eax
  1001d0:	75 0c                	jne    1001de <bwrite+0x1e>
    panic("bwrite");
  1001d2:	c7 04 24 d7 a1 11 00 	movl   $0x11a1d7,(%esp)
  1001d9:	e8 22 0e 00 00       	call   101000 <panic>
  b->flags |= B_DIRTY;
  1001de:	8b 45 08             	mov    0x8(%ebp),%eax
  1001e1:	8b 00                	mov    (%eax),%eax
  1001e3:	89 c2                	mov    %eax,%edx
  1001e5:	83 ca 04             	or     $0x4,%edx
  1001e8:	8b 45 08             	mov    0x8(%ebp),%eax
  1001eb:	89 10                	mov    %edx,(%eax)
  ide_rw(b);
  1001ed:	8b 45 08             	mov    0x8(%ebp),%eax
  1001f0:	89 04 24             	mov    %eax,(%esp)
  1001f3:	e8 68 2e 00 00       	call   103060 <ide_rw>
}
  1001f8:	c9                   	leave  
  1001f9:	c3                   	ret    
  1001fa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

00100200 <brelse>:

// Release the buffer buf.
void
brelse(struct buf *b)
{
  100200:	55                   	push   %ebp
  100201:	89 e5                	mov    %esp,%ebp
  100203:	83 ec 08             	sub    $0x8,%esp
  if((b->flags & B_BUSY) == 0)
  100206:	8b 45 08             	mov    0x8(%ebp),%eax
  100209:	8b 00                	mov    (%eax),%eax
  10020b:	83 e0 01             	and    $0x1,%eax
  10020e:	85 c0                	test   %eax,%eax
  100210:	75 0c                	jne    10021e <brelse+0x1e>
    panic("brelse");
  100212:	c7 04 24 de a1 11 00 	movl   $0x11a1de,(%esp)
  100219:	e8 e2 0d 00 00       	call   101000 <panic>

  acquire(&buf_table_lock);
  10021e:	c7 04 24 e0 b0 13 00 	movl   $0x13b0e0,(%esp)
  100225:	e8 e6 58 00 00       	call   105b10 <acquire>

  b->next->prev = b->prev;
  10022a:	8b 45 08             	mov    0x8(%ebp),%eax
  10022d:	8b 50 10             	mov    0x10(%eax),%edx
  100230:	8b 45 08             	mov    0x8(%ebp),%eax
  100233:	8b 40 0c             	mov    0xc(%eax),%eax
  100236:	89 42 0c             	mov    %eax,0xc(%edx)
  b->prev->next = b->next;
  100239:	8b 45 08             	mov    0x8(%ebp),%eax
  10023c:	8b 50 0c             	mov    0xc(%eax),%edx
  10023f:	8b 45 08             	mov    0x8(%ebp),%eax
  100242:	8b 40 10             	mov    0x10(%eax),%eax
  100245:	89 42 10             	mov    %eax,0x10(%edx)
  b->next = bufhead.next;
  100248:	8b 15 d0 99 13 00    	mov    0x1399d0,%edx
  10024e:	8b 45 08             	mov    0x8(%ebp),%eax
  100251:	89 50 10             	mov    %edx,0x10(%eax)
  b->prev = &bufhead;
  100254:	8b 45 08             	mov    0x8(%ebp),%eax
  100257:	c7 40 0c c0 99 13 00 	movl   $0x1399c0,0xc(%eax)
  bufhead.next->prev = b;
  10025e:	8b 15 d0 99 13 00    	mov    0x1399d0,%edx
  100264:	8b 45 08             	mov    0x8(%ebp),%eax
  100267:	89 42 0c             	mov    %eax,0xc(%edx)
  bufhead.next = b;
  10026a:	8b 45 08             	mov    0x8(%ebp),%eax
  10026d:	a3 d0 99 13 00       	mov    %eax,0x1399d0

  b->flags &= ~B_BUSY;
  100272:	8b 45 08             	mov    0x8(%ebp),%eax
  100275:	8b 00                	mov    (%eax),%eax
  100277:	89 c2                	mov    %eax,%edx
  100279:	83 e2 fe             	and    $0xfffffffe,%edx
  10027c:	8b 45 08             	mov    0x8(%ebp),%eax
  10027f:	89 10                	mov    %edx,(%eax)
  wakeup(buf);
  100281:	c7 04 24 e0 9b 13 00 	movl   $0x139be0,(%esp)
  100288:	e8 63 53 00 00       	call   1055f0 <wakeup>

  release(&buf_table_lock);
  10028d:	c7 04 24 e0 b0 13 00 	movl   $0x13b0e0,(%esp)
  100294:	e8 77 5a 00 00       	call   105d10 <release>
}
  100299:	c9                   	leave  
  10029a:	c3                   	ret    
  10029b:	90                   	nop    
  10029c:	90                   	nop    
  10029d:	90                   	nop    
  10029e:	90                   	nop    
  10029f:	90                   	nop    

001002a0 <lpt_putc>:
// .bochsrc to copy to the stdout:
//   parport1: enabled=1, file="/dev/stdout"
static void
lpt_putc(int c)
{
  1002a0:	55                   	push   %ebp
  1002a1:	89 e5                	mov    %esp,%ebp
  1002a3:	83 ec 18             	sub    $0x18,%esp
  int i;

  for(i = 0; !(inb(LPTPORT+1) & 0x80) && i < 12800; i++)
  1002a6:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
  1002ad:	eb 04                	jmp    1002b3 <lpt_putc+0x13>
  1002af:	83 45 fc 01          	addl   $0x1,0xfffffffc(%ebp)
  1002b3:	c7 04 24 79 03 00 00 	movl   $0x379,(%esp)
  1002ba:	e8 61 00 00 00       	call   100320 <inb>
  1002bf:	84 c0                	test   %al,%al
  1002c1:	78 09                	js     1002cc <lpt_putc+0x2c>
  1002c3:	81 7d fc ff 31 00 00 	cmpl   $0x31ff,0xfffffffc(%ebp)
  1002ca:	7e e3                	jle    1002af <lpt_putc+0xf>
    ;
  if(c == BACKSPACE)
  1002cc:	81 7d 08 00 01 00 00 	cmpl   $0x100,0x8(%ebp)
  1002d3:	75 07                	jne    1002dc <lpt_putc+0x3c>
    c = '\b';
  1002d5:	c7 45 08 08 00 00 00 	movl   $0x8,0x8(%ebp)
  outb(LPTPORT+0, c);
  1002dc:	8b 45 08             	mov    0x8(%ebp),%eax
  1002df:	0f b6 c0             	movzbl %al,%eax
  1002e2:	89 44 24 04          	mov    %eax,0x4(%esp)
  1002e6:	c7 04 24 78 03 00 00 	movl   $0x378,(%esp)
  1002ed:	e8 4e 00 00 00       	call   100340 <outb>
  outb(LPTPORT+2, 0x08|0x04|0x01);
  1002f2:	c7 44 24 04 0d 00 00 	movl   $0xd,0x4(%esp)
  1002f9:	00 
  1002fa:	c7 04 24 7a 03 00 00 	movl   $0x37a,(%esp)
  100301:	e8 3a 00 00 00       	call   100340 <outb>
  outb(LPTPORT+2, 0x08);
  100306:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
  10030d:	00 
  10030e:	c7 04 24 7a 03 00 00 	movl   $0x37a,(%esp)
  100315:	e8 26 00 00 00       	call   100340 <outb>
}
  10031a:	c9                   	leave  
  10031b:	c3                   	ret    
  10031c:	8d 74 26 00          	lea    0x0(%esi),%esi

00100320 <inb>:
// Routines to let C code use special x86 instructions.

static inline uchar
inb(ushort port)
{
  100320:	55                   	push   %ebp
  100321:	89 e5                	mov    %esp,%ebp
  100323:	83 ec 14             	sub    $0x14,%esp
  100326:	8b 45 08             	mov    0x8(%ebp),%eax
  100329:	66 89 45 ec          	mov    %ax,0xffffffec(%ebp)
  uchar data;

  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
  10032d:	0f b7 55 ec          	movzwl 0xffffffec(%ebp),%edx
  100331:	ec                   	in     (%dx),%al
  100332:	88 45 ff             	mov    %al,0xffffffff(%ebp)
  return data;
  100335:	0f b6 45 ff          	movzbl 0xffffffff(%ebp),%eax
}
  100339:	c9                   	leave  
  10033a:	c3                   	ret    
  10033b:	90                   	nop    
  10033c:	8d 74 26 00          	lea    0x0(%esi),%esi

00100340 <outb>:

static inline uint
inl(ushort port)
{
    uint data;

    asm volatile("in %1,%0" : "=a" (data) : "d" (port));
    return data;
}

static inline ushort
inw(ushort port)
{
    ushort data;

    asm volatile("in %1,%0" : "=a" (data) : "d" (port));
    return data;
}

static inline void
insl(int port, void *addr, int cnt)
{
  asm volatile("cld\n\trepne\n\tinsl"     :
                   "=D" (addr), "=c" (cnt)    :
                   "d" (port), "0" (addr), "1" (cnt)  :
                   "memory", "cc");
}

static inline void
outb(ushort port, uchar data)
{
  100340:	55                   	push   %ebp
  100341:	89 e5                	mov    %esp,%ebp
  100343:	83 ec 08             	sub    $0x8,%esp
  100346:	8b 45 08             	mov    0x8(%ebp),%eax
  100349:	8b 55 0c             	mov    0xc(%ebp),%edx
  10034c:	66 89 45 fc          	mov    %ax,0xfffffffc(%ebp)
  100350:	88 55 f8             	mov    %dl,0xfffffff8(%ebp)
  asm volatile("out %0,%1" : : "a" (data), "d" (port));
  100353:	0f b6 45 f8          	movzbl 0xfffffff8(%ebp),%eax
  100357:	0f b7 55 fc          	movzwl 0xfffffffc(%ebp),%edx
  10035b:	ee                   	out    %al,(%dx)
}
  10035c:	c9                   	leave  
  10035d:	c3                   	ret    
  10035e:	89 f6                	mov    %esi,%esi

00100360 <cga_putc>:

static void
cga_putc(int c)
{
  100360:	55                   	push   %ebp
  100361:	89 e5                	mov    %esp,%ebp
  100363:	53                   	push   %ebx
  100364:	83 ec 24             	sub    $0x24,%esp
  int pos;
  
  // Cursor position: col + 80*row.
  outb(CRTPORT, 14);
  100367:	c7 44 24 04 0e 00 00 	movl   $0xe,0x4(%esp)
  10036e:	00 
  10036f:	c7 04 24 d4 03 00 00 	movl   $0x3d4,(%esp)
  100376:	e8 c5 ff ff ff       	call   100340 <outb>
  pos = inb(CRTPORT+1) << 8;
  10037b:	c7 04 24 d5 03 00 00 	movl   $0x3d5,(%esp)
  100382:	e8 99 ff ff ff       	call   100320 <inb>
  100387:	0f b6 c0             	movzbl %al,%eax
  10038a:	c1 e0 08             	shl    $0x8,%eax
  10038d:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  outb(CRTPORT, 15);
  100390:	c7 44 24 04 0f 00 00 	movl   $0xf,0x4(%esp)
  100397:	00 
  100398:	c7 04 24 d4 03 00 00 	movl   $0x3d4,(%esp)
  10039f:	e8 9c ff ff ff       	call   100340 <outb>
  pos |= inb(CRTPORT+1);
  1003a4:	c7 04 24 d5 03 00 00 	movl   $0x3d5,(%esp)
  1003ab:	e8 70 ff ff ff       	call   100320 <inb>
  1003b0:	0f b6 c0             	movzbl %al,%eax
  1003b3:	09 45 f8             	or     %eax,0xfffffff8(%ebp)

  if(c == '\n')
  1003b6:	83 7d 08 0a          	cmpl   $0xa,0x8(%ebp)
  1003ba:	75 3e                	jne    1003fa <cga_putc+0x9a>
    pos += 80 - pos%80;
  1003bc:	8b 4d f8             	mov    0xfffffff8(%ebp),%ecx
  1003bf:	c7 45 e4 67 66 66 66 	movl   $0x66666667,0xffffffe4(%ebp)
  1003c6:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
  1003c9:	f7 e9                	imul   %ecx
  1003cb:	c1 fa 05             	sar    $0x5,%edx
  1003ce:	89 c8                	mov    %ecx,%eax
  1003d0:	c1 f8 1f             	sar    $0x1f,%eax
  1003d3:	89 d3                	mov    %edx,%ebx
  1003d5:	29 c3                	sub    %eax,%ebx
  1003d7:	89 5d e8             	mov    %ebx,0xffffffe8(%ebp)
  1003da:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  1003dd:	c1 e0 02             	shl    $0x2,%eax
  1003e0:	03 45 e8             	add    0xffffffe8(%ebp),%eax
  1003e3:	c1 e0 04             	shl    $0x4,%eax
  1003e6:	89 ca                	mov    %ecx,%edx
  1003e8:	29 c2                	sub    %eax,%edx
  1003ea:	89 55 e8             	mov    %edx,0xffffffe8(%ebp)
  1003ed:	b8 50 00 00 00       	mov    $0x50,%eax
  1003f2:	2b 45 e8             	sub    0xffffffe8(%ebp),%eax
  1003f5:	01 45 f8             	add    %eax,0xfffffff8(%ebp)
  1003f8:	eb 48                	jmp    100442 <cga_putc+0xe2>
  else if(c == BACKSPACE){
  1003fa:	81 7d 08 00 01 00 00 	cmpl   $0x100,0x8(%ebp)
  100401:	75 20                	jne    100423 <cga_putc+0xc3>
    if(pos > 0)
  100403:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  100407:	7e 39                	jle    100442 <cga_putc+0xe2>
      crt[--pos] = ' ' | 0x0700;
  100409:	83 6d f8 01          	subl   $0x1,0xfffffff8(%ebp)
  10040d:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  100410:	01 c0                	add    %eax,%eax
  100412:	89 c2                	mov    %eax,%edx
  100414:	a1 a0 c0 11 00       	mov    0x11c0a0,%eax
  100419:	8d 04 02             	lea    (%edx,%eax,1),%eax
  10041c:	66 c7 00 20 07       	movw   $0x720,(%eax)
  100421:	eb 1f                	jmp    100442 <cga_putc+0xe2>
  } else
    crt[pos++] = (c&0xff) | 0x0700;  // black on white
  100423:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  100426:	01 c0                	add    %eax,%eax
  100428:	89 c2                	mov    %eax,%edx
  10042a:	a1 a0 c0 11 00       	mov    0x11c0a0,%eax
  10042f:	01 c2                	add    %eax,%edx
  100431:	8b 45 08             	mov    0x8(%ebp),%eax
  100434:	66 25 ff 00          	and    $0xff,%ax
  100438:	80 cc 07             	or     $0x7,%ah
  10043b:	66 89 02             	mov    %ax,(%edx)
  10043e:	83 45 f8 01          	addl   $0x1,0xfffffff8(%ebp)
  
  if((pos/80) >= 24){  // Scroll up.
  100442:	81 7d f8 7f 07 00 00 	cmpl   $0x77f,0xfffffff8(%ebp)
  100449:	7e 4f                	jle    10049a <cga_putc+0x13a>
    memmove(crt, crt+80, sizeof(crt[0])*23*80);
  10044b:	a1 a0 c0 11 00       	mov    0x11c0a0,%eax
  100450:	05 a0 00 00 00       	add    $0xa0,%eax
  100455:	8b 15 a0 c0 11 00    	mov    0x11c0a0,%edx
  10045b:	c7 44 24 08 60 0e 00 	movl   $0xe60,0x8(%esp)
  100462:	00 
  100463:	89 44 24 04          	mov    %eax,0x4(%esp)
  100467:	89 14 24             	mov    %edx,(%esp)
  10046a:	e8 f1 5a 00 00       	call   105f60 <memmove>
    pos -= 80;
  10046f:	83 6d f8 50          	subl   $0x50,0xfffffff8(%ebp)
    memset(crt + pos, 0, sizeof(crt[0])*80);
  100473:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  100476:	01 c0                	add    %eax,%eax
  100478:	89 c2                	mov    %eax,%edx
  10047a:	a1 a0 c0 11 00       	mov    0x11c0a0,%eax
  10047f:	8d 04 02             	lea    (%edx,%eax,1),%eax
  100482:	c7 44 24 08 a0 00 00 	movl   $0xa0,0x8(%esp)
  100489:	00 
  10048a:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  100491:	00 
  100492:	89 04 24             	mov    %eax,(%esp)
  100495:	e8 36 5a 00 00       	call   105ed0 <memset>
  }
  
  outb(CRTPORT, 14);
  10049a:	c7 44 24 04 0e 00 00 	movl   $0xe,0x4(%esp)
  1004a1:	00 
  1004a2:	c7 04 24 d4 03 00 00 	movl   $0x3d4,(%esp)
  1004a9:	e8 92 fe ff ff       	call   100340 <outb>
  outb(CRTPORT+1, pos>>8);
  1004ae:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1004b1:	c1 f8 08             	sar    $0x8,%eax
  1004b4:	0f b6 c0             	movzbl %al,%eax
  1004b7:	89 44 24 04          	mov    %eax,0x4(%esp)
  1004bb:	c7 04 24 d5 03 00 00 	movl   $0x3d5,(%esp)
  1004c2:	e8 79 fe ff ff       	call   100340 <outb>
  outb(CRTPORT, 15);
  1004c7:	c7 44 24 04 0f 00 00 	movl   $0xf,0x4(%esp)
  1004ce:	00 
  1004cf:	c7 04 24 d4 03 00 00 	movl   $0x3d4,(%esp)
  1004d6:	e8 65 fe ff ff       	call   100340 <outb>
  outb(CRTPORT+1, pos);
  1004db:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1004de:	0f b6 c0             	movzbl %al,%eax
  1004e1:	89 44 24 04          	mov    %eax,0x4(%esp)
  1004e5:	c7 04 24 d5 03 00 00 	movl   $0x3d5,(%esp)
  1004ec:	e8 4f fe ff ff       	call   100340 <outb>
  crt[pos] = ' ' | 0x0700;
  1004f1:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1004f4:	01 c0                	add    %eax,%eax
  1004f6:	89 c2                	mov    %eax,%edx
  1004f8:	a1 a0 c0 11 00       	mov    0x11c0a0,%eax
  1004fd:	8d 04 02             	lea    (%edx,%eax,1),%eax
  100500:	66 c7 00 20 07       	movw   $0x720,(%eax)
}
  100505:	83 c4 24             	add    $0x24,%esp
  100508:	5b                   	pop    %ebx
  100509:	5d                   	pop    %ebp
  10050a:	c3                   	ret    
  10050b:	90                   	nop    
  10050c:	8d 74 26 00          	lea    0x0(%esi),%esi

00100510 <cons_putc>:

void
cons_putc(int c)
{
  100510:	55                   	push   %ebp
  100511:	89 e5                	mov    %esp,%ebp
  100513:	83 ec 08             	sub    $0x8,%esp
  if(panicked){
  100516:	a1 00 cd 11 00       	mov    0x11cd00,%eax
  10051b:	85 c0                	test   %eax,%eax
  10051d:	74 07                	je     100526 <cons_putc+0x16>
    cli();
  10051f:	e8 1c 00 00 00       	call   100540 <cli>
    for(;;)
      ;
  100524:	eb fe                	jmp    100524 <cons_putc+0x14>
  }

  lpt_putc(c);
  100526:	8b 45 08             	mov    0x8(%ebp),%eax
  100529:	89 04 24             	mov    %eax,(%esp)
  10052c:	e8 6f fd ff ff       	call   1002a0 <lpt_putc>
  cga_putc(c);
  100531:	8b 45 08             	mov    0x8(%ebp),%eax
  100534:	89 04 24             	mov    %eax,(%esp)
  100537:	e8 24 fe ff ff       	call   100360 <cga_putc>
}
  10053c:	c9                   	leave  
  10053d:	c3                   	ret    
  10053e:	89 f6                	mov    %esi,%esi

00100540 <cli>:
}

static inline void
cli(void)
{
  100540:	55                   	push   %ebp
  100541:	89 e5                	mov    %esp,%ebp
  asm volatile("cli");
  100543:	fa                   	cli    
}
  100544:	5d                   	pop    %ebp
  100545:	c3                   	ret    
  100546:	8d 76 00             	lea    0x0(%esi),%esi
  100549:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00100550 <printintlen>:

void
printintlen(int xx, int base, int sgn, int len, char fill)
{
  100550:	55                   	push   %ebp
  100551:	89 e5                	mov    %esp,%ebp
  100553:	53                   	push   %ebx
  100554:	83 ec 34             	sub    $0x34,%esp
  100557:	8b 45 18             	mov    0x18(%ebp),%eax
  10055a:	88 45 d8             	mov    %al,0xffffffd8(%ebp)
  static char digits[] = "0123456789ABCDEF";
  char buf[16];
  int i = 0, neg = 0, j = 0;
  10055d:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  100564:	c7 45 f0 00 00 00 00 	movl   $0x0,0xfffffff0(%ebp)
  10056b:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
  uint x;

  if(sgn && xx < 0){
  100572:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  100576:	74 17                	je     10058f <printintlen+0x3f>
  100578:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  10057c:	79 11                	jns    10058f <printintlen+0x3f>
    neg = 1;
  10057e:	c7 45 f0 01 00 00 00 	movl   $0x1,0xfffffff0(%ebp)
    x = 0 - xx;
  100585:	8b 45 08             	mov    0x8(%ebp),%eax
  100588:	f7 d8                	neg    %eax
  10058a:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  10058d:	eb 06                	jmp    100595 <printintlen+0x45>
  } else {
    x = xx;
  10058f:	8b 45 08             	mov    0x8(%ebp),%eax
  100592:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  }

  do{
    buf[i++] = digits[x % base];
  100595:	8b 4d ec             	mov    0xffffffec(%ebp),%ecx
  100598:	8b 55 0c             	mov    0xc(%ebp),%edx
  10059b:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10059e:	89 d3                	mov    %edx,%ebx
  1005a0:	ba 00 00 00 00       	mov    $0x0,%edx
  1005a5:	f7 f3                	div    %ebx
  1005a7:	89 d0                	mov    %edx,%eax
  1005a9:	0f b6 80 a4 c0 11 00 	movzbl 0x11c0a4(%eax),%eax
  1005b0:	88 44 0d dc          	mov    %al,0xffffffdc(%ebp,%ecx,1)
  1005b4:	83 45 ec 01          	addl   $0x1,0xffffffec(%ebp)
  }while((x /= base) != 0);
  1005b8:	8b 55 0c             	mov    0xc(%ebp),%edx
  1005bb:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1005be:	89 d1                	mov    %edx,%ecx
  1005c0:	ba 00 00 00 00       	mov    $0x0,%edx
  1005c5:	f7 f1                	div    %ecx
  1005c7:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  1005ca:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  1005ce:	75 c5                	jne    100595 <printintlen+0x45>
  if(neg)
  1005d0:	83 7d f0 00          	cmpl   $0x0,0xfffffff0(%ebp)
  1005d4:	74 0c                	je     1005e2 <printintlen+0x92>
    buf[i++] = '-';
  1005d6:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  1005d9:	c6 44 05 dc 2d       	movb   $0x2d,0xffffffdc(%ebp,%eax,1)
  1005de:	83 45 ec 01          	addl   $0x1,0xffffffec(%ebp)

  if (i < len)
  1005e2:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  1005e5:	3b 45 14             	cmp    0x14(%ebp),%eax
  1005e8:	7d 57                	jge    100641 <printintlen+0xf1>
  {
      if (neg)
  1005ea:	83 7d f0 00          	cmpl   $0x0,0xfffffff0(%ebp)
  1005ee:	74 10                	je     100600 <printintlen+0xb0>
      {
          cons_putc('-');
  1005f0:	c7 04 24 2d 00 00 00 	movl   $0x2d,(%esp)
  1005f7:	e8 14 ff ff ff       	call   100510 <cons_putc>
          i--;
  1005fc:	83 6d ec 01          	subl   $0x1,0xffffffec(%ebp)
      }
      j = len - i;
  100600:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  100603:	8b 55 14             	mov    0x14(%ebp),%edx
  100606:	89 d3                	mov    %edx,%ebx
  100608:	29 c3                	sub    %eax,%ebx
  10060a:	89 d8                	mov    %ebx,%eax
  10060c:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
      while (j-- > 0)
  10060f:	eb 0c                	jmp    10061d <printintlen+0xcd>
          cons_putc(fill);
  100611:	0f be 45 d8          	movsbl 0xffffffd8(%ebp),%eax
  100615:	89 04 24             	mov    %eax,(%esp)
  100618:	e8 f3 fe ff ff       	call   100510 <cons_putc>
  10061d:	83 7d f4 00          	cmpl   $0x0,0xfffffff4(%ebp)
  100621:	0f 9f c0             	setg   %al
  100624:	83 6d f4 01          	subl   $0x1,0xfffffff4(%ebp)
  100628:	84 c0                	test   %al,%al
  10062a:	75 e5                	jne    100611 <printintlen+0xc1>
  }
  while(--i >= 0)
  10062c:	eb 13                	jmp    100641 <printintlen+0xf1>
    cons_putc(buf[i]);
  10062e:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  100631:	0f b6 44 05 dc       	movzbl 0xffffffdc(%ebp,%eax,1),%eax
  100636:	0f be c0             	movsbl %al,%eax
  100639:	89 04 24             	mov    %eax,(%esp)
  10063c:	e8 cf fe ff ff       	call   100510 <cons_putc>
  100641:	83 6d ec 01          	subl   $0x1,0xffffffec(%ebp)
  100645:	83 7d ec 00          	cmpl   $0x0,0xffffffec(%ebp)
  100649:	79 e3                	jns    10062e <printintlen+0xde>
}
  10064b:	83 c4 34             	add    $0x34,%esp
  10064e:	5b                   	pop    %ebx
  10064f:	5d                   	pop    %ebp
  100650:	c3                   	ret    
  100651:	eb 0d                	jmp    100660 <printint>
  100653:	90                   	nop    
  100654:	90                   	nop    
  100655:	90                   	nop    
  100656:	90                   	nop    
  100657:	90                   	nop    
  100658:	90                   	nop    
  100659:	90                   	nop    
  10065a:	90                   	nop    
  10065b:	90                   	nop    
  10065c:	90                   	nop    
  10065d:	90                   	nop    
  10065e:	90                   	nop    
  10065f:	90                   	nop    

00100660 <printint>:

void
printint(int xx, int base, int sgn)
{
  100660:	55                   	push   %ebp
  100661:	89 e5                	mov    %esp,%ebp
  100663:	53                   	push   %ebx
  100664:	83 ec 24             	sub    $0x24,%esp
  static char digits[] = "0123456789ABCDEF";
  char buf[16];
  int i = 0, neg = 0;
  100667:	c7 45 f0 00 00 00 00 	movl   $0x0,0xfffffff0(%ebp)
  10066e:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
  uint x;

  if(sgn && xx < 0){
  100675:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  100679:	74 17                	je     100692 <printint+0x32>
  10067b:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  10067f:	79 11                	jns    100692 <printint+0x32>
    neg = 1;
  100681:	c7 45 f4 01 00 00 00 	movl   $0x1,0xfffffff4(%ebp)
    x = 0 - xx;
  100688:	8b 45 08             	mov    0x8(%ebp),%eax
  10068b:	f7 d8                	neg    %eax
  10068d:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  100690:	eb 06                	jmp    100698 <printint+0x38>
  } else {
    x = xx;
  100692:	8b 45 08             	mov    0x8(%ebp),%eax
  100695:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  }

  do{
    buf[i++] = digits[x % base];
  100698:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
  10069b:	8b 55 0c             	mov    0xc(%ebp),%edx
  10069e:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1006a1:	89 d3                	mov    %edx,%ebx
  1006a3:	ba 00 00 00 00       	mov    $0x0,%edx
  1006a8:	f7 f3                	div    %ebx
  1006aa:	89 d0                	mov    %edx,%eax
  1006ac:	0f b6 80 b5 c0 11 00 	movzbl 0x11c0b5(%eax),%eax
  1006b3:	88 44 0d e0          	mov    %al,0xffffffe0(%ebp,%ecx,1)
  1006b7:	83 45 f0 01          	addl   $0x1,0xfffffff0(%ebp)
  }while((x /= base) != 0);
  1006bb:	8b 55 0c             	mov    0xc(%ebp),%edx
  1006be:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1006c1:	89 d1                	mov    %edx,%ecx
  1006c3:	ba 00 00 00 00       	mov    $0x0,%edx
  1006c8:	f7 f1                	div    %ecx
  1006ca:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  1006cd:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  1006d1:	75 c5                	jne    100698 <printint+0x38>
  if(neg)
  1006d3:	83 7d f4 00          	cmpl   $0x0,0xfffffff4(%ebp)
  1006d7:	74 21                	je     1006fa <printint+0x9a>
    buf[i++] = '-';
  1006d9:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  1006dc:	c6 44 05 e0 2d       	movb   $0x2d,0xffffffe0(%ebp,%eax,1)
  1006e1:	83 45 f0 01          	addl   $0x1,0xfffffff0(%ebp)

  while(--i >= 0)
  1006e5:	eb 13                	jmp    1006fa <printint+0x9a>
    cons_putc(buf[i]);
  1006e7:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  1006ea:	0f b6 44 05 e0       	movzbl 0xffffffe0(%ebp,%eax,1),%eax
  1006ef:	0f be c0             	movsbl %al,%eax
  1006f2:	89 04 24             	mov    %eax,(%esp)
  1006f5:	e8 16 fe ff ff       	call   100510 <cons_putc>
  1006fa:	83 6d f0 01          	subl   $0x1,0xfffffff0(%ebp)
  1006fe:	83 7d f0 00          	cmpl   $0x0,0xfffffff0(%ebp)
  100702:	79 e3                	jns    1006e7 <printint+0x87>
}
  100704:	83 c4 24             	add    $0x24,%esp
  100707:	5b                   	pop    %ebx
  100708:	5d                   	pop    %ebp
  100709:	c3                   	ret    
  10070a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

00100710 <cprintf>:

enum fmt_types {
    CHAR,
    SHORT,
    LONG,
    LONGLONG,
};

// Print to the console. only understands %d, %x, %p, %s.
void
cprintf(char *fmt, ...)
{
  100710:	55                   	push   %ebp
  100711:	89 e5                	mov    %esp,%ebp
  100713:	83 ec 58             	sub    $0x58,%esp
  int i, c, state, locking, len = 0;
  100716:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  uint *argp;
  char *s, last, fill;
  enum fmt_types type;

  locking = use_console_lock;
  10071d:	a1 04 cd 11 00       	mov    0x11cd04,%eax
  100722:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
  if(locking)
  100725:	83 7d e8 00          	cmpl   $0x0,0xffffffe8(%ebp)
  100729:	74 0c                	je     100737 <cprintf+0x27>
    acquire(&console_lock);
  10072b:	c7 04 24 20 cd 11 00 	movl   $0x11cd20,(%esp)
  100732:	e8 d9 53 00 00       	call   105b10 <acquire>

  argp = (uint*)(void*)&fmt + 1;
  100737:	8d 45 08             	lea    0x8(%ebp),%eax
  10073a:	83 c0 04             	add    $0x4,%eax
  10073d:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
  state = 0;
  100740:	c7 45 e4 00 00 00 00 	movl   $0x0,0xffffffe4(%ebp)
  c = 0;
  100747:	c7 45 e0 00 00 00 00 	movl   $0x0,0xffffffe0(%ebp)
  fill = ' ';
  10074e:	c6 45 fb 20          	movb   $0x20,0xfffffffb(%ebp)
  len = -1;
  100752:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  for(i = 0; fmt[i]; i++){
  100759:	c7 45 dc 00 00 00 00 	movl   $0x0,0xffffffdc(%ebp)
  100760:	e9 f2 02 00 00       	jmp    100a57 <cprintf+0x347>
    last = c;
  100765:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  100768:	88 45 fa             	mov    %al,0xfffffffa(%ebp)
    c = fmt[i] & 0xff;
  10076b:	8b 55 08             	mov    0x8(%ebp),%edx
  10076e:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  100771:	8d 04 02             	lea    (%edx,%eax,1),%eax
  100774:	0f b6 00             	movzbl (%eax),%eax
  100777:	0f be c0             	movsbl %al,%eax
  10077a:	25 ff 00 00 00       	and    $0xff,%eax
  10077f:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
    switch(state){
  100782:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
  100785:	89 45 cc             	mov    %eax,0xffffffcc(%ebp)
  100788:	83 7d cc 00          	cmpl   $0x0,0xffffffcc(%ebp)
  10078c:	74 0b                	je     100799 <cprintf+0x89>
  10078e:	83 7d cc 25          	cmpl   $0x25,0xffffffcc(%ebp)
  100792:	74 27                	je     1007bb <cprintf+0xab>
  100794:	e9 ba 02 00 00       	jmp    100a53 <cprintf+0x343>
    case 0:
      if(c == '%')
  100799:	83 7d e0 25          	cmpl   $0x25,0xffffffe0(%ebp)
  10079d:	75 0c                	jne    1007ab <cprintf+0x9b>
        state = '%';
  10079f:	c7 45 e4 25 00 00 00 	movl   $0x25,0xffffffe4(%ebp)
  1007a6:	e9 a8 02 00 00       	jmp    100a53 <cprintf+0x343>
      else
        cons_putc(c);
  1007ab:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  1007ae:	89 04 24             	mov    %eax,(%esp)
  1007b1:	e8 5a fd ff ff       	call   100510 <cons_putc>
      break;
  1007b6:	e9 98 02 00 00       	jmp    100a53 <cprintf+0x343>
    
    case '%':
      switch(c){
  1007bb:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
  1007be:	83 ea 25             	sub    $0x25,%edx
  1007c1:	89 55 c8             	mov    %edx,0xffffffc8(%ebp)
  1007c4:	83 7d c8 53          	cmpl   $0x53,0xffffffc8(%ebp)
  1007c8:	0f 87 6e 02 00 00    	ja     100a3c <cprintf+0x32c>
  1007ce:	8b 55 c8             	mov    0xffffffc8(%ebp),%edx
  1007d1:	8b 04 95 f0 a1 11 00 	mov    0x11a1f0(,%edx,4),%eax
  1007d8:	ff e0                	jmp    *%eax
      case 'l':
        if (last == 'l')
  1007da:	80 7d fa 6c          	cmpb   $0x6c,0xfffffffa(%ebp)
  1007de:	75 0c                	jne    1007ec <cprintf+0xdc>
        {
            // ll: long long
            type = LONGLONG;
  1007e0:	c7 45 fc 03 00 00 00 	movl   $0x3,0xfffffffc(%ebp)
  1007e7:	e9 67 02 00 00       	jmp    100a53 <cprintf+0x343>
        } else {
            type = LONG;
  1007ec:	c7 45 fc 02 00 00 00 	movl   $0x2,0xfffffffc(%ebp)
        }
        break;
  1007f3:	e9 5b 02 00 00       	jmp    100a53 <cprintf+0x343>
      case 'h':
        if (last == 'h')
  1007f8:	80 7d fa 68          	cmpb   $0x68,0xfffffffa(%ebp)
  1007fc:	75 0c                	jne    10080a <cprintf+0xfa>
        {
            // hh: char
            type = CHAR;
  1007fe:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
  100805:	e9 49 02 00 00       	jmp    100a53 <cprintf+0x343>
        } else {
            type = SHORT;
  10080a:	c7 45 fc 01 00 00 00 	movl   $0x1,0xfffffffc(%ebp)
        }
        break;
  100811:	e9 3d 02 00 00       	jmp    100a53 <cprintf+0x343>
      case 'c':
        cons_putc(*argp++);
  100816:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  100819:	8b 00                	mov    (%eax),%eax
  10081b:	83 45 f0 04          	addl   $0x4,0xfffffff0(%ebp)
  10081f:	89 04 24             	mov    %eax,(%esp)
  100822:	e8 e9 fc ff ff       	call   100510 <cons_putc>
        len = -1;
  100827:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
        state = 0;
  10082e:	c7 45 e4 00 00 00 00 	movl   $0x0,0xffffffe4(%ebp)
        break;
  100835:	e9 19 02 00 00       	jmp    100a53 <cprintf+0x343>
      case 'd':
      case 'i':
        if (len != -1)
  10083a:	83 7d ec ff          	cmpl   $0xffffffff,0xffffffec(%ebp)
  10083e:	74 34                	je     100874 <cprintf+0x164>
            printintlen(*argp++, 10, 1, len, fill);
  100840:	0f be 55 fb          	movsbl 0xfffffffb(%ebp),%edx
  100844:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  100847:	8b 00                	mov    (%eax),%eax
  100849:	89 c1                	mov    %eax,%ecx
  10084b:	83 45 f0 04          	addl   $0x4,0xfffffff0(%ebp)
  10084f:	89 54 24 10          	mov    %edx,0x10(%esp)
  100853:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  100856:	89 44 24 0c          	mov    %eax,0xc(%esp)
  10085a:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  100861:	00 
  100862:	c7 44 24 04 0a 00 00 	movl   $0xa,0x4(%esp)
  100869:	00 
  10086a:	89 0c 24             	mov    %ecx,(%esp)
  10086d:	e8 de fc ff ff       	call   100550 <printintlen>
  100872:	eb 21                	jmp    100895 <cprintf+0x185>
        else
            printint(*argp++, 10, 1);
  100874:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  100877:	8b 00                	mov    (%eax),%eax
  100879:	83 45 f0 04          	addl   $0x4,0xfffffff0(%ebp)
  10087d:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  100884:	00 
  100885:	c7 44 24 04 0a 00 00 	movl   $0xa,0x4(%esp)
  10088c:	00 
  10088d:	89 04 24             	mov    %eax,(%esp)
  100890:	e8 cb fd ff ff       	call   100660 <printint>
        fill = ' ';
  100895:	c6 45 fb 20          	movb   $0x20,0xfffffffb(%ebp)
        len = -1;
  100899:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
        state = 0;
  1008a0:	c7 45 e4 00 00 00 00 	movl   $0x0,0xffffffe4(%ebp)
        break;
  1008a7:	e9 a7 01 00 00       	jmp    100a53 <cprintf+0x343>
      case 'u':
        if (len != -1)
  1008ac:	83 7d ec ff          	cmpl   $0xffffffff,0xffffffec(%ebp)
  1008b0:	74 34                	je     1008e6 <cprintf+0x1d6>
            printintlen(*argp++, 10, 0, len, fill);
  1008b2:	0f be 55 fb          	movsbl 0xfffffffb(%ebp),%edx
  1008b6:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  1008b9:	8b 00                	mov    (%eax),%eax
  1008bb:	89 c1                	mov    %eax,%ecx
  1008bd:	83 45 f0 04          	addl   $0x4,0xfffffff0(%ebp)
  1008c1:	89 54 24 10          	mov    %edx,0x10(%esp)
  1008c5:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  1008c8:	89 44 24 0c          	mov    %eax,0xc(%esp)
  1008cc:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  1008d3:	00 
  1008d4:	c7 44 24 04 0a 00 00 	movl   $0xa,0x4(%esp)
  1008db:	00 
  1008dc:	89 0c 24             	mov    %ecx,(%esp)
  1008df:	e8 6c fc ff ff       	call   100550 <printintlen>
  1008e4:	eb 21                	jmp    100907 <cprintf+0x1f7>
        else
            printint(*argp++, 10, 0);
  1008e6:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  1008e9:	8b 00                	mov    (%eax),%eax
  1008eb:	83 45 f0 04          	addl   $0x4,0xfffffff0(%ebp)
  1008ef:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  1008f6:	00 
  1008f7:	c7 44 24 04 0a 00 00 	movl   $0xa,0x4(%esp)
  1008fe:	00 
  1008ff:	89 04 24             	mov    %eax,(%esp)
  100902:	e8 59 fd ff ff       	call   100660 <printint>
        fill = ' ';
  100907:	c6 45 fb 20          	movb   $0x20,0xfffffffb(%ebp)
        len = -1;
  10090b:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
        state = 0;
  100912:	c7 45 e4 00 00 00 00 	movl   $0x0,0xffffffe4(%ebp)
        break;
  100919:	e9 35 01 00 00       	jmp    100a53 <cprintf+0x343>
      case 'x':
      case 'p':
        if (len != -1)
  10091e:	83 7d ec ff          	cmpl   $0xffffffff,0xffffffec(%ebp)
  100922:	74 34                	je     100958 <cprintf+0x248>
            printintlen(*argp++, 16, 0, len, fill);
  100924:	0f be 55 fb          	movsbl 0xfffffffb(%ebp),%edx
  100928:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10092b:	8b 00                	mov    (%eax),%eax
  10092d:	89 c1                	mov    %eax,%ecx
  10092f:	83 45 f0 04          	addl   $0x4,0xfffffff0(%ebp)
  100933:	89 54 24 10          	mov    %edx,0x10(%esp)
  100937:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10093a:	89 44 24 0c          	mov    %eax,0xc(%esp)
  10093e:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  100945:	00 
  100946:	c7 44 24 04 10 00 00 	movl   $0x10,0x4(%esp)
  10094d:	00 
  10094e:	89 0c 24             	mov    %ecx,(%esp)
  100951:	e8 fa fb ff ff       	call   100550 <printintlen>
  100956:	eb 21                	jmp    100979 <cprintf+0x269>
        else
            printint(*argp++, 16, 0);
  100958:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10095b:	8b 00                	mov    (%eax),%eax
  10095d:	83 45 f0 04          	addl   $0x4,0xfffffff0(%ebp)
  100961:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  100968:	00 
  100969:	c7 44 24 04 10 00 00 	movl   $0x10,0x4(%esp)
  100970:	00 
  100971:	89 04 24             	mov    %eax,(%esp)
  100974:	e8 e7 fc ff ff       	call   100660 <printint>
        fill = ' ';
  100979:	c6 45 fb 20          	movb   $0x20,0xfffffffb(%ebp)
        len = -1;
  10097d:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
        state = 0;
  100984:	c7 45 e4 00 00 00 00 	movl   $0x0,0xffffffe4(%ebp)
        break;
  10098b:	e9 c3 00 00 00       	jmp    100a53 <cprintf+0x343>
      case 's':
        s = (char*)*argp++;
  100990:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  100993:	8b 00                	mov    (%eax),%eax
  100995:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  100998:	83 45 f0 04          	addl   $0x4,0xfffffff0(%ebp)
        if(s == 0)
  10099c:	83 7d f4 00          	cmpl   $0x0,0xfffffff4(%ebp)
  1009a0:	75 1e                	jne    1009c0 <cprintf+0x2b0>
          s = "(null)";
  1009a2:	c7 45 f4 e8 a1 11 00 	movl   $0x11a1e8,0xfffffff4(%ebp)
        for(; *s; s++)
  1009a9:	eb 15                	jmp    1009c0 <cprintf+0x2b0>
          cons_putc(*s);
  1009ab:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  1009ae:	0f b6 00             	movzbl (%eax),%eax
  1009b1:	0f be c0             	movsbl %al,%eax
  1009b4:	89 04 24             	mov    %eax,(%esp)
  1009b7:	e8 54 fb ff ff       	call   100510 <cons_putc>
  1009bc:	83 45 f4 01          	addl   $0x1,0xfffffff4(%ebp)
  1009c0:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  1009c3:	0f b6 00             	movzbl (%eax),%eax
  1009c6:	84 c0                	test   %al,%al
  1009c8:	75 e1                	jne    1009ab <cprintf+0x29b>
        len = -1;
  1009ca:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
        state = 0;
  1009d1:	c7 45 e4 00 00 00 00 	movl   $0x0,0xffffffe4(%ebp)
        break;
  1009d8:	eb 79                	jmp    100a53 <cprintf+0x343>
      case '%':
        cons_putc('%');
  1009da:	c7 04 24 25 00 00 00 	movl   $0x25,(%esp)
  1009e1:	e8 2a fb ff ff       	call   100510 <cons_putc>
        state = 0;
  1009e6:	c7 45 e4 00 00 00 00 	movl   $0x0,0xffffffe4(%ebp)
        break;
  1009ed:	eb 64                	jmp    100a53 <cprintf+0x343>
      case '0':
        if (len == -1)
  1009ef:	83 7d ec ff          	cmpl   $0xffffffff,0xffffffec(%ebp)
  1009f3:	75 0d                	jne    100a02 <cprintf+0x2f2>
        {
            len = 0;
  1009f5:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
            fill = '0';
  1009fc:	c6 45 fb 30          	movb   $0x30,0xfffffffb(%ebp)
  100a00:	eb 51                	jmp    100a53 <cprintf+0x343>
        } else {
            len = len * 10;
  100a02:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  100a05:	89 c2                	mov    %eax,%edx
  100a07:	c1 e2 02             	shl    $0x2,%edx
  100a0a:	01 c2                	add    %eax,%edx
  100a0c:	8d 04 12             	lea    (%edx,%edx,1),%eax
  100a0f:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
        }
        break;
  100a12:	eb 3f                	jmp    100a53 <cprintf+0x343>
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
        if (len == -1)
  100a14:	83 7d ec ff          	cmpl   $0xffffffff,0xffffffec(%ebp)
  100a18:	75 0b                	jne    100a25 <cprintf+0x315>
            len = c - '0';
  100a1a:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  100a1d:	83 e8 30             	sub    $0x30,%eax
  100a20:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  100a23:	eb 2e                	jmp    100a53 <cprintf+0x343>
        else
            len = len * 10 + c - '0';
  100a25:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
  100a28:	89 d0                	mov    %edx,%eax
  100a2a:	c1 e0 02             	shl    $0x2,%eax
  100a2d:	01 d0                	add    %edx,%eax
  100a2f:	01 c0                	add    %eax,%eax
  100a31:	03 45 e0             	add    0xffffffe0(%ebp),%eax
  100a34:	83 e8 30             	sub    $0x30,%eax
  100a37:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
        break;
  100a3a:	eb 17                	jmp    100a53 <cprintf+0x343>
      default:
        // Print unknown % sequence to draw attention.
        cons_putc('%');
  100a3c:	c7 04 24 25 00 00 00 	movl   $0x25,(%esp)
  100a43:	e8 c8 fa ff ff       	call   100510 <cons_putc>
        cons_putc(c);
  100a48:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  100a4b:	89 04 24             	mov    %eax,(%esp)
  100a4e:	e8 bd fa ff ff       	call   100510 <cons_putc>
  100a53:	83 45 dc 01          	addl   $0x1,0xffffffdc(%ebp)
  100a57:	8b 55 08             	mov    0x8(%ebp),%edx
  100a5a:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  100a5d:	8d 04 02             	lea    (%edx,%eax,1),%eax
  100a60:	0f b6 00             	movzbl (%eax),%eax
  100a63:	84 c0                	test   %al,%al
  100a65:	0f 85 fa fc ff ff    	jne    100765 <cprintf+0x55>
        break;
      }
      break;
    }
  }

  if(locking)
  100a6b:	83 7d e8 00          	cmpl   $0x0,0xffffffe8(%ebp)
  100a6f:	74 0c                	je     100a7d <cprintf+0x36d>
    release(&console_lock);
  100a71:	c7 04 24 20 cd 11 00 	movl   $0x11cd20,(%esp)
  100a78:	e8 93 52 00 00       	call   105d10 <release>
}
  100a7d:	c9                   	leave  
  100a7e:	c3                   	ret    
  100a7f:	90                   	nop    

00100a80 <console_write>:

int
console_write(struct inode *ip, char *buf, int n)
{
  100a80:	55                   	push   %ebp
  100a81:	89 e5                	mov    %esp,%ebp
  100a83:	83 ec 18             	sub    $0x18,%esp
  int i;

  iunlock(ip);
  100a86:	8b 45 08             	mov    0x8(%ebp),%eax
  100a89:	89 04 24             	mov    %eax,(%esp)
  100a8c:	e8 7f 14 00 00       	call   101f10 <iunlock>
  acquire(&console_lock);
  100a91:	c7 04 24 20 cd 11 00 	movl   $0x11cd20,(%esp)
  100a98:	e8 73 50 00 00       	call   105b10 <acquire>
  for(i = 0; i < n; i++)
  100a9d:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
  100aa4:	eb 1d                	jmp    100ac3 <console_write+0x43>
    cons_putc(buf[i] & 0xff);
  100aa6:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  100aa9:	03 45 0c             	add    0xc(%ebp),%eax
  100aac:	0f b6 00             	movzbl (%eax),%eax
  100aaf:	0f be c0             	movsbl %al,%eax
  100ab2:	25 ff 00 00 00       	and    $0xff,%eax
  100ab7:	89 04 24             	mov    %eax,(%esp)
  100aba:	e8 51 fa ff ff       	call   100510 <cons_putc>
  100abf:	83 45 fc 01          	addl   $0x1,0xfffffffc(%ebp)
  100ac3:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  100ac6:	3b 45 10             	cmp    0x10(%ebp),%eax
  100ac9:	7c db                	jl     100aa6 <console_write+0x26>
  release(&console_lock);
  100acb:	c7 04 24 20 cd 11 00 	movl   $0x11cd20,(%esp)
  100ad2:	e8 39 52 00 00       	call   105d10 <release>
  ilock(ip);
  100ad7:	8b 45 08             	mov    0x8(%ebp),%eax
  100ada:	89 04 24             	mov    %eax,(%esp)
  100add:	e8 ce 12 00 00       	call   101db0 <ilock>

  return n;
  100ae2:	8b 45 10             	mov    0x10(%ebp),%eax
}
  100ae5:	c9                   	leave  
  100ae6:	c3                   	ret    
  100ae7:	89 f6                	mov    %esi,%esi
  100ae9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00100af0 <console_intr>:

#define INPUT_BUF 128
struct {
  struct spinlock lock;
  char buf[INPUT_BUF];
  int r;  // Read index
  int w;  // Write index
  int e;  // Edit index
} input;

#define C(x)  ((x)-'@')  // Control-x

void
console_intr(int (*getc)(void))
{
  100af0:	55                   	push   %ebp
  100af1:	89 e5                	mov    %esp,%ebp
  100af3:	83 ec 18             	sub    $0x18,%esp
  int c;

  acquire(&input.lock);
  100af6:	c7 04 24 20 b1 13 00 	movl   $0x13b120,(%esp)
  100afd:	e8 0e 50 00 00       	call   105b10 <acquire>
  while((c = getc()) >= 0){
  100b02:	e9 30 01 00 00       	jmp    100c37 <console_intr+0x147>
    switch(c){
  100b07:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  100b0a:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  100b0d:	83 7d ec 10          	cmpl   $0x10,0xffffffec(%ebp)
  100b11:	74 11                	je     100b24 <console_intr+0x34>
  100b13:	83 7d ec 15          	cmpl   $0x15,0xffffffec(%ebp)
  100b17:	74 2e                	je     100b47 <console_intr+0x57>
  100b19:	83 7d ec 08          	cmpl   $0x8,0xffffffec(%ebp)
  100b1d:	74 65                	je     100b84 <console_intr+0x94>
  100b1f:	e9 91 00 00 00       	jmp    100bb5 <console_intr+0xc5>
    case C('P'):  // Process listing.
      procdump();
  100b24:	e8 97 4e 00 00       	call   1059c0 <procdump>
      break;
  100b29:	e9 09 01 00 00       	jmp    100c37 <console_intr+0x147>
    case C('U'):  // Kill line.
      while(input.e > input.w &&
            input.buf[(input.e-1) % INPUT_BUF] != '\n'){
        input.e--;
  100b2e:	a1 dc b1 13 00       	mov    0x13b1dc,%eax
  100b33:	83 e8 01             	sub    $0x1,%eax
  100b36:	a3 dc b1 13 00       	mov    %eax,0x13b1dc
        cons_putc(BACKSPACE);
  100b3b:	c7 04 24 00 01 00 00 	movl   $0x100,(%esp)
  100b42:	e8 c9 f9 ff ff       	call   100510 <cons_putc>
  100b47:	8b 15 dc b1 13 00    	mov    0x13b1dc,%edx
  100b4d:	a1 d8 b1 13 00       	mov    0x13b1d8,%eax
  100b52:	39 c2                	cmp    %eax,%edx
  100b54:	0f 8e dd 00 00 00    	jle    100c37 <console_intr+0x147>
  100b5a:	a1 dc b1 13 00       	mov    0x13b1dc,%eax
  100b5f:	8d 50 ff             	lea    0xffffffff(%eax),%edx
  100b62:	89 d0                	mov    %edx,%eax
  100b64:	c1 f8 1f             	sar    $0x1f,%eax
  100b67:	89 c1                	mov    %eax,%ecx
  100b69:	c1 e9 19             	shr    $0x19,%ecx
  100b6c:	8d 04 0a             	lea    (%edx,%ecx,1),%eax
  100b6f:	83 e0 7f             	and    $0x7f,%eax
  100b72:	29 c8                	sub    %ecx,%eax
  100b74:	0f b6 80 54 b1 13 00 	movzbl 0x13b154(%eax),%eax
  100b7b:	3c 0a                	cmp    $0xa,%al
  100b7d:	75 af                	jne    100b2e <console_intr+0x3e>
      }
      break;
  100b7f:	e9 b3 00 00 00       	jmp    100c37 <console_intr+0x147>
    case C('H'):  // Backspace
      if(input.e > input.w){
  100b84:	8b 15 dc b1 13 00    	mov    0x13b1dc,%edx
  100b8a:	a1 d8 b1 13 00       	mov    0x13b1d8,%eax
  100b8f:	39 c2                	cmp    %eax,%edx
  100b91:	0f 8e a0 00 00 00    	jle    100c37 <console_intr+0x147>
        input.e--;
  100b97:	a1 dc b1 13 00       	mov    0x13b1dc,%eax
  100b9c:	83 e8 01             	sub    $0x1,%eax
  100b9f:	a3 dc b1 13 00       	mov    %eax,0x13b1dc
        cons_putc(BACKSPACE);
  100ba4:	c7 04 24 00 01 00 00 	movl   $0x100,(%esp)
  100bab:	e8 60 f9 ff ff       	call   100510 <cons_putc>
      }
      break;
  100bb0:	e9 82 00 00 00       	jmp    100c37 <console_intr+0x147>
    default:
      if(c != 0 && input.e < input.r+INPUT_BUF){
  100bb5:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  100bb9:	74 7c                	je     100c37 <console_intr+0x147>
  100bbb:	a1 dc b1 13 00       	mov    0x13b1dc,%eax
  100bc0:	8b 15 d4 b1 13 00    	mov    0x13b1d4,%edx
  100bc6:	83 ea 80             	sub    $0xffffff80,%edx
  100bc9:	39 d0                	cmp    %edx,%eax
  100bcb:	7d 6a                	jge    100c37 <console_intr+0x147>
        input.buf[input.e++ % INPUT_BUF] = c;
  100bcd:	8b 0d dc b1 13 00    	mov    0x13b1dc,%ecx
  100bd3:	89 c8                	mov    %ecx,%eax
  100bd5:	c1 f8 1f             	sar    $0x1f,%eax
  100bd8:	89 c2                	mov    %eax,%edx
  100bda:	c1 ea 19             	shr    $0x19,%edx
  100bdd:	8d 04 11             	lea    (%ecx,%edx,1),%eax
  100be0:	83 e0 7f             	and    $0x7f,%eax
  100be3:	29 d0                	sub    %edx,%eax
  100be5:	89 c2                	mov    %eax,%edx
  100be7:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  100bea:	88 82 54 b1 13 00    	mov    %al,0x13b154(%edx)
  100bf0:	8d 41 01             	lea    0x1(%ecx),%eax
  100bf3:	a3 dc b1 13 00       	mov    %eax,0x13b1dc
        cons_putc(c);
  100bf8:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  100bfb:	89 04 24             	mov    %eax,(%esp)
  100bfe:	e8 0d f9 ff ff       	call   100510 <cons_putc>
        if(c == '\n' || c == C('D') || input.e == input.r+INPUT_BUF){
  100c03:	83 7d fc 0a          	cmpl   $0xa,0xfffffffc(%ebp)
  100c07:	74 18                	je     100c21 <console_intr+0x131>
  100c09:	83 7d fc 04          	cmpl   $0x4,0xfffffffc(%ebp)
  100c0d:	74 12                	je     100c21 <console_intr+0x131>
  100c0f:	a1 dc b1 13 00       	mov    0x13b1dc,%eax
  100c14:	8b 15 d4 b1 13 00    	mov    0x13b1d4,%edx
  100c1a:	83 ea 80             	sub    $0xffffff80,%edx
  100c1d:	39 d0                	cmp    %edx,%eax
  100c1f:	75 16                	jne    100c37 <console_intr+0x147>
          input.w = input.e;
  100c21:	a1 dc b1 13 00       	mov    0x13b1dc,%eax
  100c26:	a3 d8 b1 13 00       	mov    %eax,0x13b1d8
          wakeup(&input.r);
  100c2b:	c7 04 24 d4 b1 13 00 	movl   $0x13b1d4,(%esp)
  100c32:	e8 b9 49 00 00       	call   1055f0 <wakeup>
  100c37:	8b 45 08             	mov    0x8(%ebp),%eax
  100c3a:	ff d0                	call   *%eax
  100c3c:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  100c3f:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  100c43:	0f 89 be fe ff ff    	jns    100b07 <console_intr+0x17>
        }
      }
      break;
    }
  }
  release(&input.lock);
  100c49:	c7 04 24 20 b1 13 00 	movl   $0x13b120,(%esp)
  100c50:	e8 bb 50 00 00       	call   105d10 <release>
}
  100c55:	c9                   	leave  
  100c56:	c3                   	ret    
  100c57:	89 f6                	mov    %esi,%esi
  100c59:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00100c60 <thread_stub>:

void
thread_stub(void * arg)
{
  100c60:	55                   	push   %ebp
  100c61:	89 e5                	mov    %esp,%ebp
  100c63:	81 ec 38 02 00 00    	sub    $0x238,%esp
/*    static int id = 0;
    id++;
//    int myid = id;
    cprintf("thread_stub started! arg: %d\n", arg);
    int i;
    for (i=0; i<100000000; i++)
    {
        if (i % 100000 == 0)
        cprintf("%d:", myid);
    }*/
  static int in = 0;
  if (in)
  100c69:	a1 08 cd 11 00       	mov    0x11cd08,%eax
  100c6e:	85 c0                	test   %eax,%eax
  100c70:	0f 85 7d 01 00 00    	jne    100df3 <thread_stub+0x193>
      return;
  in = 1;
  100c76:	c7 05 08 cd 11 00 01 	movl   $0x1,0x11cd08
  100c7d:	00 00 00 
  unsigned char data[512];
  int s;
  int len;
  s = lwip_socket(PF_INET, SOCK_STREAM, 0);
  100c80:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  100c87:	00 
  100c88:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  100c8f:	00 
  100c90:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  100c97:	e8 c4 7c 01 00       	call   118960 <lwip_socket>
  100c9c:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  struct sockaddr_in sa;
  sa.sin_family = AF_INET;
  100c9f:	c6 85 e5 fd ff ff 02 	movb   $0x2,0xfffffde5(%ebp)
  sa.sin_port = htons(80);
  100ca6:	c7 04 24 50 00 00 00 	movl   $0x50,(%esp)
  100cad:	e8 ce d5 00 00       	call   10e280 <htons>
  100cb2:	66 89 85 e6 fd ff ff 	mov    %ax,0xfffffde6(%ebp)
  sa.sin_addr.s_addr = inet_addr("192.168.1.1");
  100cb9:	c7 04 24 40 a3 11 00 	movl   $0x11a340,(%esp)
  100cc0:	e8 db d1 00 00       	call   10dea0 <inet_addr>
  100cc5:	89 85 e8 fd ff ff    	mov    %eax,0xfffffde8(%ebp)
  len = 1;
  100ccb:	c7 85 f4 fd ff ff 01 	movl   $0x1,0xfffffdf4(%ebp)
  100cd2:	00 00 00 
  lwip_setsockopt(s, SOL_SOCKET, SO_REUSEPORT, &len, sizeof(int));
  100cd5:	c7 44 24 10 04 00 00 	movl   $0x4,0x10(%esp)
  100cdc:	00 
  100cdd:	8d 85 f4 fd ff ff    	lea    0xfffffdf4(%ebp),%eax
  100ce3:	89 44 24 0c          	mov    %eax,0xc(%esp)
  100ce7:	c7 44 24 08 00 02 00 	movl   $0x200,0x8(%esp)
  100cee:	00 
  100cef:	c7 44 24 04 ff 0f 00 	movl   $0xfff,0x4(%esp)
  100cf6:	00 
  100cf7:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  100cfa:	89 04 24             	mov    %eax,(%esp)
  100cfd:	e8 ee 89 01 00       	call   1196f0 <lwip_setsockopt>
  lwip_bind(s, &sa, sizeof(sa));
  100d02:	8d 85 e4 fd ff ff    	lea    0xfffffde4(%ebp),%eax
  100d08:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
  100d0f:	00 
  100d10:	89 44 24 04          	mov    %eax,0x4(%esp)
  100d14:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  100d17:	89 04 24             	mov    %eax,(%esp)
  100d1a:	e8 b1 74 01 00       	call   1181d0 <lwip_bind>
  int addrlen = sizeof(sa);
  100d1f:	c7 85 e0 fd ff ff 10 	movl   $0x10,0xfffffde0(%ebp)
  100d26:	00 00 00 
//  len = lwip_recvfrom(s, data, sizeof(data), 0, &sa, &addrlen);
//  lwip_sendto(s, data, len, 0, &sa, addrlen);
  int client;
  lwip_listen(s, 1);
  100d29:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  100d30:	00 
  100d31:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  100d34:	89 04 24             	mov    %eax,(%esp)
  100d37:	e8 e4 76 01 00       	call   118420 <lwip_listen>
  while ((client = lwip_accept(s, &sa, &addrlen)) > 0)
  100d3c:	eb 74                	jmp    100db2 <thread_stub+0x152>
  {
      do {
        len = lwip_read(client, data, sizeof(data));
  100d3e:	c7 44 24 08 00 02 00 	movl   $0x200,0x8(%esp)
  100d45:	00 
  100d46:	8d 85 f8 fd ff ff    	lea    0xfffffdf8(%ebp),%eax
  100d4c:	89 44 24 04          	mov    %eax,0x4(%esp)
  100d50:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  100d53:	89 04 24             	mov    %eax,(%esp)
  100d56:	e8 65 79 01 00       	call   1186c0 <lwip_read>
  100d5b:	89 85 f4 fd ff ff    	mov    %eax,0xfffffdf4(%ebp)
//        cprintf("received %d bytes\n", len);
        lwip_send(client, data, len, 0);
  100d61:	8b 85 f4 fd ff ff    	mov    0xfffffdf4(%ebp),%eax
  100d67:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  100d6e:	00 
  100d6f:	89 44 24 08          	mov    %eax,0x8(%esp)
  100d73:	8d 85 f8 fd ff ff    	lea    0xfffffdf8(%ebp),%eax
  100d79:	89 44 24 04          	mov    %eax,0x4(%esp)
  100d7d:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  100d80:	89 04 24             	mov    %eax,(%esp)
  100d83:	e8 b8 79 01 00       	call   118740 <lwip_send>
        if (data[0] == '!')
  100d88:	0f b6 85 f8 fd ff ff 	movzbl 0xfffffdf8(%ebp),%eax
  100d8f:	3c 21                	cmp    $0x21,%al
  100d91:	75 0a                	jne    100d9d <thread_stub+0x13d>
            len = -1;
  100d93:	c7 85 f4 fd ff ff ff 	movl   $0xffffffff,0xfffffdf4(%ebp)
  100d9a:	ff ff ff 
      } while (len > 0);
  100d9d:	8b 85 f4 fd ff ff    	mov    0xfffffdf4(%ebp),%eax
  100da3:	85 c0                	test   %eax,%eax
  100da5:	7f 97                	jg     100d3e <thread_stub+0xde>
      lwip_close(client);
  100da7:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  100daa:	89 04 24             	mov    %eax,(%esp)
  100dad:	e8 de 74 01 00       	call   118290 <lwip_close>
  100db2:	8d 95 e4 fd ff ff    	lea    0xfffffde4(%ebp),%edx
  100db8:	8d 85 e0 fd ff ff    	lea    0xfffffde0(%ebp),%eax
  100dbe:	89 44 24 08          	mov    %eax,0x8(%esp)
  100dc2:	89 54 24 04          	mov    %edx,0x4(%esp)
  100dc6:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  100dc9:	89 04 24             	mov    %eax,(%esp)
  100dcc:	e8 9f 72 01 00       	call   118070 <lwip_accept>
  100dd1:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  100dd4:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  100dd8:	0f 8f 60 ff ff ff    	jg     100d3e <thread_stub+0xde>
  }
  lwip_close(s);
  100dde:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  100de1:	89 04 24             	mov    %eax,(%esp)
  100de4:	e8 a7 74 01 00       	call   118290 <lwip_close>
  in = 0;
  100de9:	c7 05 08 cd 11 00 00 	movl   $0x0,0x11cd08
  100df0:	00 00 00 
}
  100df3:	c9                   	leave  
  100df4:	c3                   	ret    
  100df5:	8d 74 26 00          	lea    0x0(%esi),%esi
  100df9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00100e00 <console_read>:


int
console_read(struct inode *ip, char *dst, int n)
{
  100e00:	55                   	push   %ebp
  100e01:	89 e5                	mov    %esp,%ebp
  100e03:	83 ec 28             	sub    $0x28,%esp
  uint target;
  int c;
  int ret;
//  unsigned char data[100];
  int mark;

//  kproc_start(thread_stub, 0, 0, 0, "[stub thread]");
//  for (c=0; c<10; c++)
//      data[c] = 0xda;
  iunlock(ip);
  100e06:	8b 45 08             	mov    0x8(%ebp),%eax
  100e09:	89 04 24             	mov    %eax,(%esp)
  100e0c:	e8 ff 10 00 00       	call   101f10 <iunlock>
  target = n;
  100e11:	8b 45 10             	mov    0x10(%ebp),%eax
  100e14:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
  acquire(&input.lock);
  100e17:	c7 04 24 20 b1 13 00 	movl   $0x13b120,(%esp)
  100e1e:	e8 ed 4c 00 00       	call   105b10 <acquire>
  while(n > 0){
  100e23:	e9 c2 00 00 00       	jmp    100eea <console_read+0xea>
    while(input.r == input.w){
      if(cp->killed){
  100e28:	e8 63 2a 00 00       	call   103890 <cpu>
  100e2d:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  100e34:	8b 40 1c             	mov    0x1c(%eax),%eax
  100e37:	85 c0                	test   %eax,%eax
  100e39:	74 23                	je     100e5e <console_read+0x5e>
        release(&input.lock);
  100e3b:	c7 04 24 20 b1 13 00 	movl   $0x13b120,(%esp)
  100e42:	e8 c9 4e 00 00       	call   105d10 <release>
        ilock(ip);
  100e47:	8b 45 08             	mov    0x8(%ebp),%eax
  100e4a:	89 04 24             	mov    %eax,(%esp)
  100e4d:	e8 5e 0f 00 00       	call   101db0 <ilock>
        return -1;
  100e52:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  100e59:	e9 b4 00 00 00       	jmp    100f12 <console_read+0x112>
      }
      mark = 0;
  100e5e:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
      sleep(&input.r, &input.lock);
  100e65:	c7 44 24 04 20 b1 13 	movl   $0x13b120,0x4(%esp)
  100e6c:	00 
  100e6d:	c7 04 24 d4 b1 13 00 	movl   $0x13b1d4,(%esp)
  100e74:	e8 e7 45 00 00       	call   105460 <sleep>
  100e79:	8b 15 d4 b1 13 00    	mov    0x13b1d4,%edx
  100e7f:	a1 d8 b1 13 00       	mov    0x13b1d8,%eax
  100e84:	39 c2                	cmp    %eax,%edx
  100e86:	74 a0                	je     100e28 <console_read+0x28>
/*      do {
        ret = msleep_spin(&input.r, &input.lock, 1000);
       if (ret)
        {*/
//            if ((mark = lwip_recv(s, data, 
//            sizeof(data), MSG_DONTWAIT)) > 0)
//                cprintf("received from 192.168.1.1:80: %d\n", mark);
/*            if (mark == 0)
            {
                for ( ; mark < 64; mark ++)
                    e100_send(data, sizeof(data));
            }
            int len = e100_receive(data, sizeof(data));
            cprintf("received: %d bytes\n", len);
            int i;
            for (i=0; i<len; i++)
            {
                cprintf("%02x ", data[i]);
                if ((i+1) % 10 == 0)
                    cprintf("\n");
            }
            cprintf("\n");*/
//            kproc_start(thread_stub, (void *)100, 0, 0);
//            cprintf("XXX faster!!\n");
/*        }
      } while (ret);*/
    }
    c = input.buf[input.r++ % INPUT_BUF];
  100e88:	8b 0d d4 b1 13 00    	mov    0x13b1d4,%ecx
  100e8e:	89 c8                	mov    %ecx,%eax
  100e90:	c1 f8 1f             	sar    $0x1f,%eax
  100e93:	89 c2                	mov    %eax,%edx
  100e95:	c1 ea 19             	shr    $0x19,%edx
  100e98:	8d 04 11             	lea    (%ecx,%edx,1),%eax
  100e9b:	83 e0 7f             	and    $0x7f,%eax
  100e9e:	29 d0                	sub    %edx,%eax
  100ea0:	0f b6 80 54 b1 13 00 	movzbl 0x13b154(%eax),%eax
  100ea7:	0f be c0             	movsbl %al,%eax
  100eaa:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  100ead:	8d 41 01             	lea    0x1(%ecx),%eax
  100eb0:	a3 d4 b1 13 00       	mov    %eax,0x13b1d4
    if(c == C('D')){  // EOF
  100eb5:	83 7d f4 04          	cmpl   $0x4,0xfffffff4(%ebp)
  100eb9:	75 17                	jne    100ed2 <console_read+0xd2>
      if(n < target){
  100ebb:	8b 45 10             	mov    0x10(%ebp),%eax
  100ebe:	3b 45 f0             	cmp    0xfffffff0(%ebp),%eax
  100ec1:	73 2d                	jae    100ef0 <console_read+0xf0>
        // Save ^D for next time, to make sure
        // caller gets a 0-byte result.
        input.r--;
  100ec3:	a1 d4 b1 13 00       	mov    0x13b1d4,%eax
  100ec8:	83 e8 01             	sub    $0x1,%eax
  100ecb:	a3 d4 b1 13 00       	mov    %eax,0x13b1d4
      }
      break;
  100ed0:	eb 1e                	jmp    100ef0 <console_read+0xf0>
    }
    *dst++ = c;
  100ed2:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  100ed5:	89 c2                	mov    %eax,%edx
  100ed7:	8b 45 0c             	mov    0xc(%ebp),%eax
  100eda:	88 10                	mov    %dl,(%eax)
  100edc:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
    --n;
  100ee0:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
    if(c == '\n')
  100ee4:	83 7d f4 0a          	cmpl   $0xa,0xfffffff4(%ebp)
  100ee8:	74 06                	je     100ef0 <console_read+0xf0>
  100eea:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  100eee:	7f 89                	jg     100e79 <console_read+0x79>
      break;
  }
  release(&input.lock);
  100ef0:	c7 04 24 20 b1 13 00 	movl   $0x13b120,(%esp)
  100ef7:	e8 14 4e 00 00       	call   105d10 <release>
  ilock(ip);
  100efc:	8b 45 08             	mov    0x8(%ebp),%eax
  100eff:	89 04 24             	mov    %eax,(%esp)
  100f02:	e8 a9 0e 00 00       	call   101db0 <ilock>

  return target - n;
  100f07:	8b 55 10             	mov    0x10(%ebp),%edx
  100f0a:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  100f0d:	29 d0                	sub    %edx,%eax
  100f0f:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  100f12:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  100f15:	c9                   	leave  
  100f16:	c3                   	ret    
  100f17:	89 f6                	mov    %esi,%esi
  100f19:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00100f20 <console_init>:

void
console_init(void)
{
  100f20:	55                   	push   %ebp
  100f21:	89 e5                	mov    %esp,%ebp
  100f23:	83 ec 08             	sub    $0x8,%esp
  initlock(&console_lock, "console");
  100f26:	c7 44 24 04 4c a3 11 	movl   $0x11a34c,0x4(%esp)
  100f2d:	00 
  100f2e:	c7 04 24 20 cd 11 00 	movl   $0x11cd20,(%esp)
  100f35:	e8 a6 4b 00 00       	call   105ae0 <initlock>
  initlock(&input.lock, "console input");
  100f3a:	c7 44 24 04 54 a3 11 	movl   $0x11a354,0x4(%esp)
  100f41:	00 
  100f42:	c7 04 24 20 b1 13 00 	movl   $0x13b120,(%esp)
  100f49:	e8 92 4b 00 00       	call   105ae0 <initlock>

  devsw[CONSOLE].write = console_write;
  100f4e:	c7 05 8c bb 13 00 80 	movl   $0x100a80,0x13bb8c
  100f55:	0a 10 00 
  devsw[CONSOLE].read = console_read;
  100f58:	c7 05 88 bb 13 00 00 	movl   $0x100e00,0x13bb88
  100f5f:	0e 10 00 
  //use_console_lock = 1;

  pic_enable(IRQ_KBD);
  100f62:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  100f69:	e8 82 32 00 00       	call   1041f0 <pic_enable>
  ioapic_enable(IRQ_KBD, 0);
  100f6e:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  100f75:	00 
  100f76:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  100f7d:	e8 be 22 00 00       	call   103240 <ioapic_enable>
}
  100f82:	c9                   	leave  
  100f83:	c3                   	ret    
  100f84:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  100f8a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

00100f90 <printstack>:

void
printstack()
{
  100f90:	55                   	push   %ebp
  100f91:	89 e5                	mov    %esp,%ebp
  100f93:	83 ec 38             	sub    $0x38,%esp
  int i;
  uint ebp;
  uint pcs[10];
  cprintf("Stack trace:\n");
  100f96:	c7 04 24 62 a3 11 00 	movl   $0x11a362,(%esp)
  100f9d:	e8 6e f7 ff ff       	call   100710 <cprintf>
  asm("movl %%ebp, %0" : "=r"(ebp) : );
  100fa2:	89 e8                	mov    %ebp,%eax
  100fa4:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  getcallerpcs((void*)(ebp+8), pcs);
  100fa7:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  100faa:	83 c0 08             	add    $0x8,%eax
  100fad:	89 c2                	mov    %eax,%edx
  100faf:	8d 45 d0             	lea    0xffffffd0(%ebp),%eax
  100fb2:	89 44 24 04          	mov    %eax,0x4(%esp)
  100fb6:	89 14 24             	mov    %edx,(%esp)
  100fb9:	e8 22 4e 00 00       	call   105de0 <getcallerpcs>
  for(i=0; i<10; i++)
  100fbe:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)
  100fc5:	eb 1b                	jmp    100fe2 <printstack+0x52>
    cprintf("0x%08x ", pcs[i]);
  100fc7:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  100fca:	8b 44 85 d0          	mov    0xffffffd0(%ebp,%eax,4),%eax
  100fce:	89 44 24 04          	mov    %eax,0x4(%esp)
  100fd2:	c7 04 24 70 a3 11 00 	movl   $0x11a370,(%esp)
  100fd9:	e8 32 f7 ff ff       	call   100710 <cprintf>
  100fde:	83 45 f8 01          	addl   $0x1,0xfffffff8(%ebp)
  100fe2:	83 7d f8 09          	cmpl   $0x9,0xfffffff8(%ebp)
  100fe6:	7e df                	jle    100fc7 <printstack+0x37>
  cprintf("\n");
  100fe8:	c7 04 24 78 a3 11 00 	movl   $0x11a378,(%esp)
  100fef:	e8 1c f7 ff ff       	call   100710 <cprintf>
}
  100ff4:	c9                   	leave  
  100ff5:	c3                   	ret    
  100ff6:	8d 76 00             	lea    0x0(%esi),%esi
  100ff9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00101000 <panic>:


void
panic(char *s)
{
  101000:	55                   	push   %ebp
  101001:	89 e5                	mov    %esp,%ebp
  101003:	83 ec 38             	sub    $0x38,%esp
  int i;
  uint pcs[10];
  
  __asm __volatile("cli");
  101006:	fa                   	cli    
  use_console_lock = 0;
  101007:	c7 05 04 cd 11 00 00 	movl   $0x0,0x11cd04
  10100e:	00 00 00 
  cprintf("panic (%d): ", cpu());
  101011:	e8 7a 28 00 00       	call   103890 <cpu>
  101016:	89 44 24 04          	mov    %eax,0x4(%esp)
  10101a:	c7 04 24 7a a3 11 00 	movl   $0x11a37a,(%esp)
  101021:	e8 ea f6 ff ff       	call   100710 <cprintf>
  cprintf(s, 0);
  101026:	8b 45 08             	mov    0x8(%ebp),%eax
  101029:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  101030:	00 
  101031:	89 04 24             	mov    %eax,(%esp)
  101034:	e8 d7 f6 ff ff       	call   100710 <cprintf>
  cprintf("\n", 0);
  101039:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  101040:	00 
  101041:	c7 04 24 78 a3 11 00 	movl   $0x11a378,(%esp)
  101048:	e8 c3 f6 ff ff       	call   100710 <cprintf>
  getcallerpcs(&s, pcs);
  10104d:	8d 45 d4             	lea    0xffffffd4(%ebp),%eax
  101050:	89 44 24 04          	mov    %eax,0x4(%esp)
  101054:	8d 45 08             	lea    0x8(%ebp),%eax
  101057:	89 04 24             	mov    %eax,(%esp)
  10105a:	e8 81 4d 00 00       	call   105de0 <getcallerpcs>
  for(i=0; i<10; i++)
  10105f:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
  101066:	eb 1b                	jmp    101083 <panic+0x83>
    cprintf(" %p", pcs[i]);
  101068:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10106b:	8b 44 85 d4          	mov    0xffffffd4(%ebp,%eax,4),%eax
  10106f:	89 44 24 04          	mov    %eax,0x4(%esp)
  101073:	c7 04 24 87 a3 11 00 	movl   $0x11a387,(%esp)
  10107a:	e8 91 f6 ff ff       	call   100710 <cprintf>
  10107f:	83 45 fc 01          	addl   $0x1,0xfffffffc(%ebp)
  101083:	83 7d fc 09          	cmpl   $0x9,0xfffffffc(%ebp)
  101087:	7e df                	jle    101068 <panic+0x68>
  panicked = 1; // freeze other CPU
  101089:	c7 05 00 cd 11 00 01 	movl   $0x1,0x11cd00
  101090:	00 00 00 
  for(;;)
    ;
  101093:	eb fe                	jmp    101093 <panic+0x93>
  101095:	90                   	nop    
  101096:	90                   	nop    
  101097:	90                   	nop    
  101098:	90                   	nop    
  101099:	90                   	nop    
  10109a:	90                   	nop    
  10109b:	90                   	nop    
  10109c:	90                   	nop    
  10109d:	90                   	nop    
  10109e:	90                   	nop    
  10109f:	90                   	nop    

001010a0 <exec>:
#include "elf.h"

int
exec(char *path, char **argv)
{
  1010a0:	55                   	push   %ebp
  1010a1:	89 e5                	mov    %esp,%ebp
  1010a3:	53                   	push   %ebx
  1010a4:	81 ec a4 00 00 00    	sub    $0xa4,%esp
  char *mem, *s, *last;
  int i, argc, arglen, len, off;
  uint sz, sp, argp;
  struct elfhdr elf;
  struct inode *ip;
  struct proghdr ph;

  if((ip = namei(path)) == 0)
  1010aa:	8b 45 08             	mov    0x8(%ebp),%eax
  1010ad:	89 04 24             	mov    %eax,(%esp)
  1010b0:	e8 9b 1b 00 00       	call   102c50 <namei>
  1010b5:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  1010b8:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  1010bc:	75 0f                	jne    1010cd <exec+0x2d>
    return -1;
  1010be:	c7 85 68 ff ff ff ff 	movl   $0xffffffff,0xffffff68(%ebp)
  1010c5:	ff ff ff 
  1010c8:	e9 4e 04 00 00       	jmp    10151b <exec+0x47b>
//  cprintf("XXX exec\n");
  ilock(ip);
  1010cd:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1010d0:	89 04 24             	mov    %eax,(%esp)
  1010d3:	e8 d8 0c 00 00       	call   101db0 <ilock>

  // Compute memory size of new process.
  mem = 0;
  1010d8:	c7 45 cc 00 00 00 00 	movl   $0x0,0xffffffcc(%ebp)
  sz = 0;
  1010df:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)

  // Program segments.
  if(readi(ip, (char*)&elf, 0, sizeof(elf)) < sizeof(elf))
  1010e6:	8d 45 98             	lea    0xffffff98(%ebp),%eax
  1010e9:	c7 44 24 0c 34 00 00 	movl   $0x34,0xc(%esp)
  1010f0:	00 
  1010f1:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  1010f8:	00 
  1010f9:	89 44 24 04          	mov    %eax,0x4(%esp)
  1010fd:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  101100:	89 04 24             	mov    %eax,(%esp)
  101103:	e8 b8 13 00 00       	call   1024c0 <readi>
  101108:	83 f8 33             	cmp    $0x33,%eax
  10110b:	0f 86 dd 03 00 00    	jbe    1014ee <exec+0x44e>
    goto bad;
  if(elf.magic != ELF_MAGIC)
  101111:	8b 45 98             	mov    0xffffff98(%ebp),%eax
  101114:	3d 7f 45 4c 46       	cmp    $0x464c457f,%eax
  101119:	0f 85 cf 03 00 00    	jne    1014ee <exec+0x44e>
    goto bad;
  for(i=0, off=elf.phoff; i<elf.phnum; i++, off+=sizeof(ph)){
  10111f:	c7 45 d8 00 00 00 00 	movl   $0x0,0xffffffd8(%ebp)
  101126:	8b 45 b4             	mov    0xffffffb4(%ebp),%eax
  101129:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
  10112c:	eb 59                	jmp    101187 <exec+0xe7>
    if(readi(ip, (char*)&ph, off, sizeof(ph)) != sizeof(ph))
  10112e:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  101131:	8d 95 78 ff ff ff    	lea    0xffffff78(%ebp),%edx
  101137:	c7 44 24 0c 20 00 00 	movl   $0x20,0xc(%esp)
  10113e:	00 
  10113f:	89 44 24 08          	mov    %eax,0x8(%esp)
  101143:	89 54 24 04          	mov    %edx,0x4(%esp)
  101147:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10114a:	89 04 24             	mov    %eax,(%esp)
  10114d:	e8 6e 13 00 00       	call   1024c0 <readi>
  101152:	83 f8 20             	cmp    $0x20,%eax
  101155:	0f 85 93 03 00 00    	jne    1014ee <exec+0x44e>
      goto bad;
    if(ph.type != ELF_PROG_LOAD)
  10115b:	8b 85 78 ff ff ff    	mov    0xffffff78(%ebp),%eax
  101161:	83 f8 01             	cmp    $0x1,%eax
  101164:	75 14                	jne    10117a <exec+0xda>
      continue;
    if(ph.memsz < ph.filesz)
  101166:	8b 55 8c             	mov    0xffffff8c(%ebp),%edx
  101169:	8b 45 88             	mov    0xffffff88(%ebp),%eax
  10116c:	39 c2                	cmp    %eax,%edx
  10116e:	0f 82 7a 03 00 00    	jb     1014ee <exec+0x44e>
      goto bad;
    sz += ph.memsz;
  101174:	8b 45 8c             	mov    0xffffff8c(%ebp),%eax
  101177:	01 45 ec             	add    %eax,0xffffffec(%ebp)
  10117a:	83 45 d8 01          	addl   $0x1,0xffffffd8(%ebp)
  10117e:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  101181:	83 c0 20             	add    $0x20,%eax
  101184:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
  101187:	0f b7 45 c4          	movzwl 0xffffffc4(%ebp),%eax
  10118b:	0f b7 c0             	movzwl %ax,%eax
  10118e:	3b 45 d8             	cmp    0xffffffd8(%ebp),%eax
  101191:	7f 9b                	jg     10112e <exec+0x8e>
  }
  
  // Arguments.
  arglen = 0;
  101193:	c7 45 e0 00 00 00 00 	movl   $0x0,0xffffffe0(%ebp)
  for(argc=0; argv[argc]; argc++)
  10119a:	c7 45 dc 00 00 00 00 	movl   $0x0,0xffffffdc(%ebp)
  1011a1:	eb 1d                	jmp    1011c0 <exec+0x120>
    arglen += strlen(argv[argc]) + 1;
  1011a3:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  1011a6:	c1 e0 02             	shl    $0x2,%eax
  1011a9:	03 45 0c             	add    0xc(%ebp),%eax
  1011ac:	8b 00                	mov    (%eax),%eax
  1011ae:	89 04 24             	mov    %eax,(%esp)
  1011b1:	e8 5a 4f 00 00       	call   106110 <strlen>
  1011b6:	83 c0 01             	add    $0x1,%eax
  1011b9:	01 45 e0             	add    %eax,0xffffffe0(%ebp)
  1011bc:	83 45 dc 01          	addl   $0x1,0xffffffdc(%ebp)
  1011c0:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  1011c3:	c1 e0 02             	shl    $0x2,%eax
  1011c6:	03 45 0c             	add    0xc(%ebp),%eax
  1011c9:	8b 00                	mov    (%eax),%eax
  1011cb:	85 c0                	test   %eax,%eax
  1011cd:	75 d4                	jne    1011a3 <exec+0x103>
  arglen = (arglen+3) & ~3;
  1011cf:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  1011d2:	83 c0 03             	add    $0x3,%eax
  1011d5:	83 e0 fc             	and    $0xfffffffc,%eax
  1011d8:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
  sz += arglen + 4*(argc+1);
  1011db:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  1011de:	83 c0 01             	add    $0x1,%eax
  1011e1:	c1 e0 02             	shl    $0x2,%eax
  1011e4:	03 45 e0             	add    0xffffffe0(%ebp),%eax
  1011e7:	01 45 ec             	add    %eax,0xffffffec(%ebp)

  // Stack.
  sz += PAGE;
  1011ea:	81 45 ec 00 10 00 00 	addl   $0x1000,0xffffffec(%ebp)
  
  // Allocate program memory.
  sz = (sz+PAGE-1) & ~(PAGE-1);
  1011f1:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  1011f4:	05 ff 0f 00 00       	add    $0xfff,%eax
  1011f9:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  1011fe:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  mem = kalloc(sz);
  101201:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  101204:	89 04 24             	mov    %eax,(%esp)
  101207:	e8 64 22 00 00       	call   103470 <kalloc>
  10120c:	89 45 cc             	mov    %eax,0xffffffcc(%ebp)
  if(mem == 0)
  10120f:	83 7d cc 00          	cmpl   $0x0,0xffffffcc(%ebp)
  101213:	0f 84 d5 02 00 00    	je     1014ee <exec+0x44e>
    goto bad;
  memset(mem, 0, sz);
  101219:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10121c:	89 44 24 08          	mov    %eax,0x8(%esp)
  101220:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  101227:	00 
  101228:	8b 45 cc             	mov    0xffffffcc(%ebp),%eax
  10122b:	89 04 24             	mov    %eax,(%esp)
  10122e:	e8 9d 4c 00 00       	call   105ed0 <memset>

  // Load program into memory.
  for(i=0, off=elf.phoff; i<elf.phnum; i++, off+=sizeof(ph)){
  101233:	c7 45 d8 00 00 00 00 	movl   $0x0,0xffffffd8(%ebp)
  10123a:	8b 45 b4             	mov    0xffffffb4(%ebp),%eax
  10123d:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
  101240:	e9 b5 00 00 00       	jmp    1012fa <exec+0x25a>
    if(readi(ip, (char*)&ph, off, sizeof(ph)) != sizeof(ph))
  101245:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  101248:	8d 95 78 ff ff ff    	lea    0xffffff78(%ebp),%edx
  10124e:	c7 44 24 0c 20 00 00 	movl   $0x20,0xc(%esp)
  101255:	00 
  101256:	89 44 24 08          	mov    %eax,0x8(%esp)
  10125a:	89 54 24 04          	mov    %edx,0x4(%esp)
  10125e:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  101261:	89 04 24             	mov    %eax,(%esp)
  101264:	e8 57 12 00 00       	call   1024c0 <readi>
  101269:	83 f8 20             	cmp    $0x20,%eax
  10126c:	0f 85 7c 02 00 00    	jne    1014ee <exec+0x44e>
      goto bad;
    if(ph.type != ELF_PROG_LOAD)
  101272:	8b 85 78 ff ff ff    	mov    0xffffff78(%ebp),%eax
  101278:	83 f8 01             	cmp    $0x1,%eax
  10127b:	75 70                	jne    1012ed <exec+0x24d>
      continue;
    if(ph.va + ph.memsz > sz)
  10127d:	8b 45 80             	mov    0xffffff80(%ebp),%eax
  101280:	8b 55 8c             	mov    0xffffff8c(%ebp),%edx
  101283:	01 d0                	add    %edx,%eax
  101285:	3b 45 ec             	cmp    0xffffffec(%ebp),%eax
  101288:	0f 87 60 02 00 00    	ja     1014ee <exec+0x44e>
      goto bad;
    if(readi(ip, mem + ph.va, ph.offset, ph.filesz) != ph.filesz)
  10128e:	8b 55 88             	mov    0xffffff88(%ebp),%edx
  101291:	8b 8d 7c ff ff ff    	mov    0xffffff7c(%ebp),%ecx
  101297:	8b 45 80             	mov    0xffffff80(%ebp),%eax
  10129a:	03 45 cc             	add    0xffffffcc(%ebp),%eax
  10129d:	89 54 24 0c          	mov    %edx,0xc(%esp)
  1012a1:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  1012a5:	89 44 24 04          	mov    %eax,0x4(%esp)
  1012a9:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1012ac:	89 04 24             	mov    %eax,(%esp)
  1012af:	e8 0c 12 00 00       	call   1024c0 <readi>
  1012b4:	89 c2                	mov    %eax,%edx
  1012b6:	8b 45 88             	mov    0xffffff88(%ebp),%eax
  1012b9:	39 c2                	cmp    %eax,%edx
  1012bb:	0f 85 2d 02 00 00    	jne    1014ee <exec+0x44e>
      goto bad;
    memset(mem + ph.va + ph.filesz, 0, ph.memsz - ph.filesz);
  1012c1:	8b 55 8c             	mov    0xffffff8c(%ebp),%edx
  1012c4:	8b 45 88             	mov    0xffffff88(%ebp),%eax
  1012c7:	89 d1                	mov    %edx,%ecx
  1012c9:	29 c1                	sub    %eax,%ecx
  1012cb:	8b 45 80             	mov    0xffffff80(%ebp),%eax
  1012ce:	89 c2                	mov    %eax,%edx
  1012d0:	03 55 cc             	add    0xffffffcc(%ebp),%edx
  1012d3:	8b 45 88             	mov    0xffffff88(%ebp),%eax
  1012d6:	8d 04 02             	lea    (%edx,%eax,1),%eax
  1012d9:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  1012dd:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  1012e4:	00 
  1012e5:	89 04 24             	mov    %eax,(%esp)
  1012e8:	e8 e3 4b 00 00       	call   105ed0 <memset>
  1012ed:	83 45 d8 01          	addl   $0x1,0xffffffd8(%ebp)
  1012f1:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  1012f4:	83 c0 20             	add    $0x20,%eax
  1012f7:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
  1012fa:	0f b7 45 c4          	movzwl 0xffffffc4(%ebp),%eax
  1012fe:	0f b7 c0             	movzwl %ax,%eax
  101301:	3b 45 d8             	cmp    0xffffffd8(%ebp),%eax
  101304:	0f 8f 3b ff ff ff    	jg     101245 <exec+0x1a5>
  }
  iunlockput(ip);
  10130a:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10130d:	89 04 24             	mov    %eax,(%esp)
  101310:	e8 4b 0d 00 00       	call   102060 <iunlockput>
  
  // Initialize stack.
  sp = sz;
  101315:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  101318:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
  argp = sz - arglen - 4*(argc+1);
  10131b:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
  10131e:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  101321:	89 c1                	mov    %eax,%ecx
  101323:	29 d1                	sub    %edx,%ecx
  101325:	89 ca                	mov    %ecx,%edx
  101327:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  10132a:	83 c0 01             	add    $0x1,%eax
  10132d:	c1 e0 02             	shl    $0x2,%eax
  101330:	89 d1                	mov    %edx,%ecx
  101332:	29 c1                	sub    %eax,%ecx
  101334:	89 c8                	mov    %ecx,%eax
  101336:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)

  // Copy argv strings and pointers to stack.
  *(uint*)(mem+argp + 4*argc) = 0;  // argv[argc]
  101339:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10133c:	89 c2                	mov    %eax,%edx
  10133e:	03 55 cc             	add    0xffffffcc(%ebp),%edx
  101341:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  101344:	c1 e0 02             	shl    $0x2,%eax
  101347:	8d 04 02             	lea    (%edx,%eax,1),%eax
  10134a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  for(i=argc-1; i>=0; i--){
  101350:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  101353:	83 e8 01             	sub    $0x1,%eax
  101356:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
  101359:	eb 5f                	jmp    1013ba <exec+0x31a>
    len = strlen(argv[i]) + 1;
  10135b:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  10135e:	c1 e0 02             	shl    $0x2,%eax
  101361:	03 45 0c             	add    0xc(%ebp),%eax
  101364:	8b 00                	mov    (%eax),%eax
  101366:	89 04 24             	mov    %eax,(%esp)
  101369:	e8 a2 4d 00 00       	call   106110 <strlen>
  10136e:	83 c0 01             	add    $0x1,%eax
  101371:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
    sp -= len;
  101374:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
  101377:	29 45 f0             	sub    %eax,0xfffffff0(%ebp)
    memmove(mem+sp, argv[i], len);
  10137a:	8b 4d e4             	mov    0xffffffe4(%ebp),%ecx
  10137d:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  101380:	c1 e0 02             	shl    $0x2,%eax
  101383:	03 45 0c             	add    0xc(%ebp),%eax
  101386:	8b 10                	mov    (%eax),%edx
  101388:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10138b:	03 45 cc             	add    0xffffffcc(%ebp),%eax
  10138e:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  101392:	89 54 24 04          	mov    %edx,0x4(%esp)
  101396:	89 04 24             	mov    %eax,(%esp)
  101399:	e8 c2 4b 00 00       	call   105f60 <memmove>
    *(uint*)(mem+argp + 4*i) = sp;  // argv[i]
  10139e:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  1013a1:	89 c2                	mov    %eax,%edx
  1013a3:	03 55 cc             	add    0xffffffcc(%ebp),%edx
  1013a6:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  1013a9:	c1 e0 02             	shl    $0x2,%eax
  1013ac:	8d 04 02             	lea    (%edx,%eax,1),%eax
  1013af:	89 c2                	mov    %eax,%edx
  1013b1:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  1013b4:	89 02                	mov    %eax,(%edx)
  1013b6:	83 6d d8 01          	subl   $0x1,0xffffffd8(%ebp)
  1013ba:	83 7d d8 00          	cmpl   $0x0,0xffffffd8(%ebp)
  1013be:	79 9b                	jns    10135b <exec+0x2bb>
  }

  // Stack frame for main(argc, argv), below arguments.
  sp = argp;
  1013c0:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  1013c3:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
  sp -= 4;
  1013c6:	83 6d f0 04          	subl   $0x4,0xfffffff0(%ebp)
  *(uint*)(mem+sp) = argp;
  1013ca:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  1013cd:	03 45 cc             	add    0xffffffcc(%ebp),%eax
  1013d0:	89 c2                	mov    %eax,%edx
  1013d2:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  1013d5:	89 02                	mov    %eax,(%edx)
  sp -= 4;
  1013d7:	83 6d f0 04          	subl   $0x4,0xfffffff0(%ebp)
  *(uint*)(mem+sp) = argc;
  1013db:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  1013de:	03 45 cc             	add    0xffffffcc(%ebp),%eax
  1013e1:	89 c2                	mov    %eax,%edx
  1013e3:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  1013e6:	89 02                	mov    %eax,(%edx)
  sp -= 4;
  1013e8:	83 6d f0 04          	subl   $0x4,0xfffffff0(%ebp)
  *(uint*)(mem+sp) = 0xffffffff;   // fake return pc
  1013ec:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  1013ef:	03 45 cc             	add    0xffffffcc(%ebp),%eax
  1013f2:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)

  // Save program name for debugging.
  for(last=s=path; *s; s++)
  1013f8:	8b 45 08             	mov    0x8(%ebp),%eax
  1013fb:	89 45 d0             	mov    %eax,0xffffffd0(%ebp)
  1013fe:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
  101401:	89 45 d4             	mov    %eax,0xffffffd4(%ebp)
  101404:	eb 17                	jmp    10141d <exec+0x37d>
    if(*s == '/')
  101406:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
  101409:	0f b6 00             	movzbl (%eax),%eax
  10140c:	3c 2f                	cmp    $0x2f,%al
  10140e:	75 09                	jne    101419 <exec+0x379>
      last = s+1;
  101410:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
  101413:	83 c0 01             	add    $0x1,%eax
  101416:	89 45 d4             	mov    %eax,0xffffffd4(%ebp)
  101419:	83 45 d0 01          	addl   $0x1,0xffffffd0(%ebp)
  10141d:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
  101420:	0f b6 00             	movzbl (%eax),%eax
  101423:	84 c0                	test   %al,%al
  101425:	75 df                	jne    101406 <exec+0x366>
  safestrcpy(cp->name, last, sizeof(cp->name));
  101427:	e8 64 24 00 00       	call   103890 <cpu>
  10142c:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  101433:	8d 90 88 00 00 00    	lea    0x88(%eax),%edx
  101439:	c7 44 24 08 20 00 00 	movl   $0x20,0x8(%esp)
  101440:	00 
  101441:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
  101444:	89 44 24 04          	mov    %eax,0x4(%esp)
  101448:	89 14 24             	mov    %edx,(%esp)
  10144b:	e8 60 4c 00 00       	call   1060b0 <safestrcpy>

  // Commit to the new image.
  kfree(cp->mem, cp->sz);
  101450:	e8 3b 24 00 00       	call   103890 <cpu>
  101455:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  10145c:	8b 40 04             	mov    0x4(%eax),%eax
  10145f:	89 c3                	mov    %eax,%ebx
  101461:	e8 2a 24 00 00       	call   103890 <cpu>
  101466:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  10146d:	8b 00                	mov    (%eax),%eax
  10146f:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  101473:	89 04 24             	mov    %eax,(%esp)
  101476:	e8 85 1e 00 00       	call   103300 <kfree>
  cp->mem = mem;
  10147b:	e8 10 24 00 00       	call   103890 <cpu>
  101480:	8b 14 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%edx
  101487:	8b 45 cc             	mov    0xffffffcc(%ebp),%eax
  10148a:	89 02                	mov    %eax,(%edx)
  cp->sz = sz;
  10148c:	e8 ff 23 00 00       	call   103890 <cpu>
  101491:	8b 14 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%edx
  101498:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10149b:	89 42 04             	mov    %eax,0x4(%edx)
  cp->tf->eip = elf.entry;  // main
  10149e:	e8 ed 23 00 00       	call   103890 <cpu>
  1014a3:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  1014aa:	8b 90 84 00 00 00    	mov    0x84(%eax),%edx
  1014b0:	8b 45 b0             	mov    0xffffffb0(%ebp),%eax
  1014b3:	89 42 30             	mov    %eax,0x30(%edx)
  cp->tf->esp = sp;
  1014b6:	e8 d5 23 00 00       	call   103890 <cpu>
  1014bb:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  1014c2:	8b 90 84 00 00 00    	mov    0x84(%eax),%edx
  1014c8:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  1014cb:	89 42 3c             	mov    %eax,0x3c(%edx)
  setupsegs(cp);
  1014ce:	e8 bd 23 00 00       	call   103890 <cpu>
  1014d3:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  1014da:	89 04 24             	mov    %eax,(%esp)
  1014dd:	e8 8e 34 00 00       	call   104970 <setupsegs>
  return 0;
  1014e2:	c7 85 68 ff ff ff 00 	movl   $0x0,0xffffff68(%ebp)
  1014e9:	00 00 00 
  1014ec:	eb 2d                	jmp    10151b <exec+0x47b>

 bad:
  if(mem)
  1014ee:	83 7d cc 00          	cmpl   $0x0,0xffffffcc(%ebp)
  1014f2:	74 12                	je     101506 <exec+0x466>
    kfree(mem, sz);
  1014f4:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  1014f7:	89 44 24 04          	mov    %eax,0x4(%esp)
  1014fb:	8b 45 cc             	mov    0xffffffcc(%ebp),%eax
  1014fe:	89 04 24             	mov    %eax,(%esp)
  101501:	e8 fa 1d 00 00       	call   103300 <kfree>
  iunlockput(ip);
  101506:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  101509:	89 04 24             	mov    %eax,(%esp)
  10150c:	e8 4f 0b 00 00       	call   102060 <iunlockput>
  return -1;
  101511:	c7 85 68 ff ff ff ff 	movl   $0xffffffff,0xffffff68(%ebp)
  101518:	ff ff ff 
  10151b:	8b 85 68 ff ff ff    	mov    0xffffff68(%ebp),%eax
}
  101521:	81 c4 a4 00 00 00    	add    $0xa4,%esp
  101527:	5b                   	pop    %ebx
  101528:	5d                   	pop    %ebp
  101529:	c3                   	ret    
  10152a:	90                   	nop    
  10152b:	90                   	nop    
  10152c:	90                   	nop    
  10152d:	90                   	nop    
  10152e:	90                   	nop    
  10152f:	90                   	nop    

00101530 <fileinit>:
struct file file[NFILE];

void
fileinit(void)
{
  101530:	55                   	push   %ebp
  101531:	89 e5                	mov    %esp,%ebp
  101533:	83 ec 08             	sub    $0x8,%esp
  initlock(&file_table_lock, "file_table");
  101536:	c7 44 24 04 8b a3 11 	movl   $0x11a38b,0x4(%esp)
  10153d:	00 
  10153e:	c7 04 24 40 bb 13 00 	movl   $0x13bb40,(%esp)
  101545:	e8 96 45 00 00       	call   105ae0 <initlock>
}
  10154a:	c9                   	leave  
  10154b:	c3                   	ret    
  10154c:	8d 74 26 00          	lea    0x0(%esi),%esi

00101550 <filealloc>:

// Allocate a file structure.
struct file*
filealloc(void)
{
  101550:	55                   	push   %ebp
  101551:	89 e5                	mov    %esp,%ebp
  101553:	83 ec 18             	sub    $0x18,%esp
  int i;

  acquire(&file_table_lock);
  101556:	c7 04 24 40 bb 13 00 	movl   $0x13bb40,(%esp)
  10155d:	e8 ae 45 00 00       	call   105b10 <acquire>
  for(i = 0; i < NFILE; i++){
  101562:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
  101569:	eb 68                	jmp    1015d3 <filealloc+0x83>
    if(file[i].type == FD_CLOSED){
  10156b:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  10156e:	89 d0                	mov    %edx,%eax
  101570:	01 c0                	add    %eax,%eax
  101572:	01 d0                	add    %edx,%eax
  101574:	c1 e0 03             	shl    $0x3,%eax
  101577:	8b 80 e0 b1 13 00    	mov    0x13b1e0(%eax),%eax
  10157d:	85 c0                	test   %eax,%eax
  10157f:	75 4e                	jne    1015cf <filealloc+0x7f>
      file[i].type = FD_NONE;
  101581:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  101584:	89 d0                	mov    %edx,%eax
  101586:	01 c0                	add    %eax,%eax
  101588:	01 d0                	add    %edx,%eax
  10158a:	c1 e0 03             	shl    $0x3,%eax
  10158d:	c7 80 e0 b1 13 00 01 	movl   $0x1,0x13b1e0(%eax)
  101594:	00 00 00 
      file[i].ref = 1;
  101597:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  10159a:	89 d0                	mov    %edx,%eax
  10159c:	01 c0                	add    %eax,%eax
  10159e:	01 d0                	add    %edx,%eax
  1015a0:	c1 e0 03             	shl    $0x3,%eax
  1015a3:	c7 80 e4 b1 13 00 01 	movl   $0x1,0x13b1e4(%eax)
  1015aa:	00 00 00 
      release(&file_table_lock);
  1015ad:	c7 04 24 40 bb 13 00 	movl   $0x13bb40,(%esp)
  1015b4:	e8 57 47 00 00       	call   105d10 <release>
      return file + i;
  1015b9:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  1015bc:	89 d0                	mov    %edx,%eax
  1015be:	01 c0                	add    %eax,%eax
  1015c0:	01 d0                	add    %edx,%eax
  1015c2:	c1 e0 03             	shl    $0x3,%eax
  1015c5:	05 e0 b1 13 00       	add    $0x13b1e0,%eax
  1015ca:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  1015cd:	eb 1d                	jmp    1015ec <filealloc+0x9c>
  1015cf:	83 45 fc 01          	addl   $0x1,0xfffffffc(%ebp)
  1015d3:	83 7d fc 63          	cmpl   $0x63,0xfffffffc(%ebp)
  1015d7:	7e 92                	jle    10156b <filealloc+0x1b>
    }
  }
  release(&file_table_lock);
  1015d9:	c7 04 24 40 bb 13 00 	movl   $0x13bb40,(%esp)
  1015e0:	e8 2b 47 00 00       	call   105d10 <release>
  return 0;
  1015e5:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  1015ec:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  1015ef:	c9                   	leave  
  1015f0:	c3                   	ret    
  1015f1:	eb 0d                	jmp    101600 <filedup>
  1015f3:	90                   	nop    
  1015f4:	90                   	nop    
  1015f5:	90                   	nop    
  1015f6:	90                   	nop    
  1015f7:	90                   	nop    
  1015f8:	90                   	nop    
  1015f9:	90                   	nop    
  1015fa:	90                   	nop    
  1015fb:	90                   	nop    
  1015fc:	90                   	nop    
  1015fd:	90                   	nop    
  1015fe:	90                   	nop    
  1015ff:	90                   	nop    

00101600 <filedup>:

// Increment ref count for file f.
struct file*
filedup(struct file *f)
{
  101600:	55                   	push   %ebp
  101601:	89 e5                	mov    %esp,%ebp
  101603:	83 ec 08             	sub    $0x8,%esp
  acquire(&file_table_lock);
  101606:	c7 04 24 40 bb 13 00 	movl   $0x13bb40,(%esp)
  10160d:	e8 fe 44 00 00       	call   105b10 <acquire>
  if(f->ref < 1 || f->type == FD_CLOSED)
  101612:	8b 45 08             	mov    0x8(%ebp),%eax
  101615:	8b 40 04             	mov    0x4(%eax),%eax
  101618:	85 c0                	test   %eax,%eax
  10161a:	7e 09                	jle    101625 <filedup+0x25>
  10161c:	8b 45 08             	mov    0x8(%ebp),%eax
  10161f:	8b 00                	mov    (%eax),%eax
  101621:	85 c0                	test   %eax,%eax
  101623:	75 0c                	jne    101631 <filedup+0x31>
    panic("filedup");
  101625:	c7 04 24 96 a3 11 00 	movl   $0x11a396,(%esp)
  10162c:	e8 cf f9 ff ff       	call   101000 <panic>
  f->ref++;
  101631:	8b 45 08             	mov    0x8(%ebp),%eax
  101634:	8b 40 04             	mov    0x4(%eax),%eax
  101637:	8d 50 01             	lea    0x1(%eax),%edx
  10163a:	8b 45 08             	mov    0x8(%ebp),%eax
  10163d:	89 50 04             	mov    %edx,0x4(%eax)
  release(&file_table_lock);
  101640:	c7 04 24 40 bb 13 00 	movl   $0x13bb40,(%esp)
  101647:	e8 c4 46 00 00       	call   105d10 <release>
  return f;
  10164c:	8b 45 08             	mov    0x8(%ebp),%eax
}
  10164f:	c9                   	leave  
  101650:	c3                   	ret    
  101651:	eb 0d                	jmp    101660 <fileclose>
  101653:	90                   	nop    
  101654:	90                   	nop    
  101655:	90                   	nop    
  101656:	90                   	nop    
  101657:	90                   	nop    
  101658:	90                   	nop    
  101659:	90                   	nop    
  10165a:	90                   	nop    
  10165b:	90                   	nop    
  10165c:	90                   	nop    
  10165d:	90                   	nop    
  10165e:	90                   	nop    
  10165f:	90                   	nop    

00101660 <fileclose>:

// Close file f.  (Decrement ref count, close when reaches 0.)
void
fileclose(struct file *f)
{
  101660:	55                   	push   %ebp
  101661:	89 e5                	mov    %esp,%ebp
  101663:	83 ec 38             	sub    $0x38,%esp
  struct file ff;

  acquire(&file_table_lock);
  101666:	c7 04 24 40 bb 13 00 	movl   $0x13bb40,(%esp)
  10166d:	e8 9e 44 00 00       	call   105b10 <acquire>
  if(f->ref < 1 || f->type == FD_CLOSED)
  101672:	8b 45 08             	mov    0x8(%ebp),%eax
  101675:	8b 40 04             	mov    0x4(%eax),%eax
  101678:	85 c0                	test   %eax,%eax
  10167a:	7e 09                	jle    101685 <fileclose+0x25>
  10167c:	8b 45 08             	mov    0x8(%ebp),%eax
  10167f:	8b 00                	mov    (%eax),%eax
  101681:	85 c0                	test   %eax,%eax
  101683:	75 2b                	jne    1016b0 <fileclose+0x50>
  {
      cprintf("ref: %d type: %d\n", f->ref, f->type);
  101685:	8b 45 08             	mov    0x8(%ebp),%eax
  101688:	8b 10                	mov    (%eax),%edx
  10168a:	8b 45 08             	mov    0x8(%ebp),%eax
  10168d:	8b 40 04             	mov    0x4(%eax),%eax
  101690:	89 54 24 08          	mov    %edx,0x8(%esp)
  101694:	89 44 24 04          	mov    %eax,0x4(%esp)
  101698:	c7 04 24 9e a3 11 00 	movl   $0x11a39e,(%esp)
  10169f:	e8 6c f0 ff ff       	call   100710 <cprintf>
      panic("fileclose: file closed");
  1016a4:	c7 04 24 b0 a3 11 00 	movl   $0x11a3b0,(%esp)
  1016ab:	e8 50 f9 ff ff       	call   101000 <panic>
  }
  if(--f->ref > 0){
  1016b0:	8b 45 08             	mov    0x8(%ebp),%eax
  1016b3:	8b 40 04             	mov    0x4(%eax),%eax
  1016b6:	8d 50 ff             	lea    0xffffffff(%eax),%edx
  1016b9:	8b 45 08             	mov    0x8(%ebp),%eax
  1016bc:	89 50 04             	mov    %edx,0x4(%eax)
  1016bf:	8b 45 08             	mov    0x8(%ebp),%eax
  1016c2:	8b 40 04             	mov    0x4(%eax),%eax
  1016c5:	85 c0                	test   %eax,%eax
  1016c7:	7e 11                	jle    1016da <fileclose+0x7a>
    release(&file_table_lock);
  1016c9:	c7 04 24 40 bb 13 00 	movl   $0x13bb40,(%esp)
  1016d0:	e8 3b 46 00 00       	call   105d10 <release>
    return;
  1016d5:	e9 9a 00 00 00       	jmp    101774 <fileclose+0x114>
  }
  ff = *f;
  1016da:	8b 55 08             	mov    0x8(%ebp),%edx
  1016dd:	8b 02                	mov    (%edx),%eax
  1016df:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
  1016e2:	8b 42 04             	mov    0x4(%edx),%eax
  1016e5:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  1016e8:	8b 42 08             	mov    0x8(%edx),%eax
  1016eb:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
  1016ee:	8b 42 0c             	mov    0xc(%edx),%eax
  1016f1:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  1016f4:	8b 42 10             	mov    0x10(%edx),%eax
  1016f7:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  1016fa:	8b 42 14             	mov    0x14(%edx),%eax
  1016fd:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  f->ref = 0;
  101700:	8b 45 08             	mov    0x8(%ebp),%eax
  101703:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  f->type = FD_CLOSED;
  10170a:	8b 45 08             	mov    0x8(%ebp),%eax
  10170d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  release(&file_table_lock);
  101713:	c7 04 24 40 bb 13 00 	movl   $0x13bb40,(%esp)
  10171a:	e8 f1 45 00 00       	call   105d10 <release>
  
  if(ff.type == FD_PIPE)
  10171f:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  101722:	83 f8 02             	cmp    $0x2,%eax
  101725:	75 18                	jne    10173f <fileclose+0xdf>
    pipeclose(ff.pipe, ff.writable);
  101727:	0f b6 45 f1          	movzbl 0xfffffff1(%ebp),%eax
  10172b:	0f be c0             	movsbl %al,%eax
  10172e:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
  101731:	89 44 24 04          	mov    %eax,0x4(%esp)
  101735:	89 14 24             	mov    %edx,(%esp)
  101738:	e8 b3 2d 00 00       	call   1044f0 <pipeclose>
  10173d:	eb 35                	jmp    101774 <fileclose+0x114>
  else if(ff.type == FD_INODE)
  10173f:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  101742:	83 f8 03             	cmp    $0x3,%eax
  101745:	75 0d                	jne    101754 <fileclose+0xf4>
    iput(ff.ip);
  101747:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10174a:	89 04 24             	mov    %eax,(%esp)
  10174d:	e8 2e 08 00 00       	call   101f80 <iput>
  101752:	eb 20                	jmp    101774 <fileclose+0x114>
  else if(ff.type == FD_NONE)
  101754:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  101757:	83 f8 01             	cmp    $0x1,%eax
  10175a:	74 18                	je     101774 <fileclose+0x114>
  {
      // Nothing to do: fd alloc failure
      // Do not need to panic
      //    just because too many files
      //    opened!
  }
  else
  {
      cprintf("type: %d\n");
  10175c:	c7 04 24 c7 a3 11 00 	movl   $0x11a3c7,(%esp)
  101763:	e8 a8 ef ff ff       	call   100710 <cprintf>
      panic("fileclose: file type error");
  101768:	c7 04 24 d1 a3 11 00 	movl   $0x11a3d1,(%esp)
  10176f:	e8 8c f8 ff ff       	call   101000 <panic>
  }
}
  101774:	c9                   	leave  
  101775:	c3                   	ret    
  101776:	8d 76 00             	lea    0x0(%esi),%esi
  101779:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00101780 <filestat>:

// Get metadata about file f.
int
filestat(struct file *f, struct stat *st)
{
  101780:	55                   	push   %ebp
  101781:	89 e5                	mov    %esp,%ebp
  101783:	83 ec 18             	sub    $0x18,%esp
  if(f->type == FD_INODE){
  101786:	8b 45 08             	mov    0x8(%ebp),%eax
  101789:	8b 00                	mov    (%eax),%eax
  10178b:	83 f8 03             	cmp    $0x3,%eax
  10178e:	75 3a                	jne    1017ca <filestat+0x4a>
    ilock(f->ip);
  101790:	8b 45 08             	mov    0x8(%ebp),%eax
  101793:	8b 40 10             	mov    0x10(%eax),%eax
  101796:	89 04 24             	mov    %eax,(%esp)
  101799:	e8 12 06 00 00       	call   101db0 <ilock>
    stati(f->ip, st);
  10179e:	8b 45 08             	mov    0x8(%ebp),%eax
  1017a1:	8b 50 10             	mov    0x10(%eax),%edx
  1017a4:	8b 45 0c             	mov    0xc(%ebp),%eax
  1017a7:	89 44 24 04          	mov    %eax,0x4(%esp)
  1017ab:	89 14 24             	mov    %edx,(%esp)
  1017ae:	e8 bd 0c 00 00       	call   102470 <stati>
    iunlock(f->ip);
  1017b3:	8b 45 08             	mov    0x8(%ebp),%eax
  1017b6:	8b 40 10             	mov    0x10(%eax),%eax
  1017b9:	89 04 24             	mov    %eax,(%esp)
  1017bc:	e8 4f 07 00 00       	call   101f10 <iunlock>
    return 0;
  1017c1:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
  1017c8:	eb 07                	jmp    1017d1 <filestat+0x51>
  }
  return -1;
  1017ca:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,0xfffffffc(%ebp)
  1017d1:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
}
  1017d4:	c9                   	leave  
  1017d5:	c3                   	ret    
  1017d6:	8d 76 00             	lea    0x0(%esi),%esi
  1017d9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

001017e0 <fileread>:

// Read from file f.  Addr is kernel address.
int
fileread(struct file *f, char *addr, int n)
{
  1017e0:	55                   	push   %ebp
  1017e1:	89 e5                	mov    %esp,%ebp
  1017e3:	53                   	push   %ebx
  1017e4:	83 ec 24             	sub    $0x24,%esp
  int r;

  if(f->readable == 0)
  1017e7:	8b 45 08             	mov    0x8(%ebp),%eax
  1017ea:	0f b6 40 08          	movzbl 0x8(%eax),%eax
  1017ee:	84 c0                	test   %al,%al
  1017f0:	75 0c                	jne    1017fe <fileread+0x1e>
    return -1;
  1017f2:	c7 45 e8 ff ff ff ff 	movl   $0xffffffff,0xffffffe8(%ebp)
  1017f9:	e9 a5 00 00 00       	jmp    1018a3 <fileread+0xc3>
  if(f->type == FD_PIPE)
  1017fe:	8b 45 08             	mov    0x8(%ebp),%eax
  101801:	8b 00                	mov    (%eax),%eax
  101803:	83 f8 02             	cmp    $0x2,%eax
  101806:	75 21                	jne    101829 <fileread+0x49>
    return piperead(f->pipe, addr, n);
  101808:	8b 45 08             	mov    0x8(%ebp),%eax
  10180b:	8b 50 0c             	mov    0xc(%eax),%edx
  10180e:	8b 45 10             	mov    0x10(%ebp),%eax
  101811:	89 44 24 08          	mov    %eax,0x8(%esp)
  101815:	8b 45 0c             	mov    0xc(%ebp),%eax
  101818:	89 44 24 04          	mov    %eax,0x4(%esp)
  10181c:	89 14 24             	mov    %edx,(%esp)
  10181f:	e8 7c 2e 00 00       	call   1046a0 <piperead>
  101824:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
  101827:	eb 7a                	jmp    1018a3 <fileread+0xc3>
  if(f->type == FD_INODE){
  101829:	8b 45 08             	mov    0x8(%ebp),%eax
  10182c:	8b 00                	mov    (%eax),%eax
  10182e:	83 f8 03             	cmp    $0x3,%eax
  101831:	75 64                	jne    101897 <fileread+0xb7>
    ilock(f->ip);
  101833:	8b 45 08             	mov    0x8(%ebp),%eax
  101836:	8b 40 10             	mov    0x10(%eax),%eax
  101839:	89 04 24             	mov    %eax,(%esp)
  10183c:	e8 6f 05 00 00       	call   101db0 <ilock>
    if((r = readi(f->ip, addr, f->off, n)) > 0)
  101841:	8b 55 10             	mov    0x10(%ebp),%edx
  101844:	8b 45 08             	mov    0x8(%ebp),%eax
  101847:	8b 48 14             	mov    0x14(%eax),%ecx
  10184a:	8b 45 08             	mov    0x8(%ebp),%eax
  10184d:	8b 58 10             	mov    0x10(%eax),%ebx
  101850:	89 54 24 0c          	mov    %edx,0xc(%esp)
  101854:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  101858:	8b 45 0c             	mov    0xc(%ebp),%eax
  10185b:	89 44 24 04          	mov    %eax,0x4(%esp)
  10185f:	89 1c 24             	mov    %ebx,(%esp)
  101862:	e8 59 0c 00 00       	call   1024c0 <readi>
  101867:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  10186a:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  10186e:	7e 11                	jle    101881 <fileread+0xa1>
      f->off += r;
  101870:	8b 45 08             	mov    0x8(%ebp),%eax
  101873:	8b 50 14             	mov    0x14(%eax),%edx
  101876:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  101879:	01 c2                	add    %eax,%edx
  10187b:	8b 45 08             	mov    0x8(%ebp),%eax
  10187e:	89 50 14             	mov    %edx,0x14(%eax)
    iunlock(f->ip);
  101881:	8b 45 08             	mov    0x8(%ebp),%eax
  101884:	8b 40 10             	mov    0x10(%eax),%eax
  101887:	89 04 24             	mov    %eax,(%esp)
  10188a:	e8 81 06 00 00       	call   101f10 <iunlock>
    return r;
  10188f:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  101892:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
  101895:	eb 0c                	jmp    1018a3 <fileread+0xc3>
  }
  panic("fileread");
  101897:	c7 04 24 ec a3 11 00 	movl   $0x11a3ec,(%esp)
  10189e:	e8 5d f7 ff ff       	call   101000 <panic>
  1018a3:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
}
  1018a6:	83 c4 24             	add    $0x24,%esp
  1018a9:	5b                   	pop    %ebx
  1018aa:	5d                   	pop    %ebp
  1018ab:	c3                   	ret    
  1018ac:	8d 74 26 00          	lea    0x0(%esi),%esi

001018b0 <filewrite>:

// Write to file f.  Addr is kernel address.
int
filewrite(struct file *f, char *addr, int n)
{
  1018b0:	55                   	push   %ebp
  1018b1:	89 e5                	mov    %esp,%ebp
  1018b3:	53                   	push   %ebx
  1018b4:	83 ec 24             	sub    $0x24,%esp
  int r;

  if(f->writable == 0)
  1018b7:	8b 45 08             	mov    0x8(%ebp),%eax
  1018ba:	0f b6 40 09          	movzbl 0x9(%eax),%eax
  1018be:	84 c0                	test   %al,%al
  1018c0:	75 0c                	jne    1018ce <filewrite+0x1e>
    return -1;
  1018c2:	c7 45 e8 ff ff ff ff 	movl   $0xffffffff,0xffffffe8(%ebp)
  1018c9:	e9 a5 00 00 00       	jmp    101973 <filewrite+0xc3>
  if(f->type == FD_PIPE)
  1018ce:	8b 45 08             	mov    0x8(%ebp),%eax
  1018d1:	8b 00                	mov    (%eax),%eax
  1018d3:	83 f8 02             	cmp    $0x2,%eax
  1018d6:	75 21                	jne    1018f9 <filewrite+0x49>
    return pipewrite(f->pipe, addr, n);
  1018d8:	8b 45 08             	mov    0x8(%ebp),%eax
  1018db:	8b 50 0c             	mov    0xc(%eax),%edx
  1018de:	8b 45 10             	mov    0x10(%ebp),%eax
  1018e1:	89 44 24 08          	mov    %eax,0x8(%esp)
  1018e5:	8b 45 0c             	mov    0xc(%ebp),%eax
  1018e8:	89 44 24 04          	mov    %eax,0x4(%esp)
  1018ec:	89 14 24             	mov    %edx,(%esp)
  1018ef:	e8 8c 2c 00 00       	call   104580 <pipewrite>
  1018f4:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
  1018f7:	eb 7a                	jmp    101973 <filewrite+0xc3>
  if(f->type == FD_INODE){
  1018f9:	8b 45 08             	mov    0x8(%ebp),%eax
  1018fc:	8b 00                	mov    (%eax),%eax
  1018fe:	83 f8 03             	cmp    $0x3,%eax
  101901:	75 64                	jne    101967 <filewrite+0xb7>
    ilock(f->ip);
  101903:	8b 45 08             	mov    0x8(%ebp),%eax
  101906:	8b 40 10             	mov    0x10(%eax),%eax
  101909:	89 04 24             	mov    %eax,(%esp)
  10190c:	e8 9f 04 00 00       	call   101db0 <ilock>
    if((r = writei(f->ip, addr, f->off, n)) > 0)
  101911:	8b 55 10             	mov    0x10(%ebp),%edx
  101914:	8b 45 08             	mov    0x8(%ebp),%eax
  101917:	8b 48 14             	mov    0x14(%eax),%ecx
  10191a:	8b 45 08             	mov    0x8(%ebp),%eax
  10191d:	8b 58 10             	mov    0x10(%eax),%ebx
  101920:	89 54 24 0c          	mov    %edx,0xc(%esp)
  101924:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  101928:	8b 45 0c             	mov    0xc(%ebp),%eax
  10192b:	89 44 24 04          	mov    %eax,0x4(%esp)
  10192f:	89 1c 24             	mov    %ebx,(%esp)
  101932:	e8 19 0d 00 00       	call   102650 <writei>
  101937:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  10193a:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  10193e:	7e 11                	jle    101951 <filewrite+0xa1>
      f->off += r;
  101940:	8b 45 08             	mov    0x8(%ebp),%eax
  101943:	8b 50 14             	mov    0x14(%eax),%edx
  101946:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  101949:	01 c2                	add    %eax,%edx
  10194b:	8b 45 08             	mov    0x8(%ebp),%eax
  10194e:	89 50 14             	mov    %edx,0x14(%eax)
    iunlock(f->ip);
  101951:	8b 45 08             	mov    0x8(%ebp),%eax
  101954:	8b 40 10             	mov    0x10(%eax),%eax
  101957:	89 04 24             	mov    %eax,(%esp)
  10195a:	e8 b1 05 00 00       	call   101f10 <iunlock>
    return r;
  10195f:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  101962:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
  101965:	eb 0c                	jmp    101973 <filewrite+0xc3>
  }
  panic("filewrite");
  101967:	c7 04 24 f5 a3 11 00 	movl   $0x11a3f5,(%esp)
  10196e:	e8 8d f6 ff ff       	call   101000 <panic>
  101973:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
}
  101976:	83 c4 24             	add    $0x24,%esp
  101979:	5b                   	pop    %ebx
  10197a:	5d                   	pop    %ebp
  10197b:	c3                   	ret    
  10197c:	90                   	nop    
  10197d:	90                   	nop    
  10197e:	90                   	nop    
  10197f:	90                   	nop    

00101980 <readsb>:

// Read the super block.
static void
readsb(int dev, struct superblock *sb)
{
  101980:	55                   	push   %ebp
  101981:	89 e5                	mov    %esp,%ebp
  101983:	83 ec 28             	sub    $0x28,%esp
  struct buf *bp;
  
//  cprintf("XXX %s\n",__func__);
  bp = bread(dev, 1);
  101986:	8b 45 08             	mov    0x8(%ebp),%eax
  101989:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  101990:	00 
  101991:	89 04 24             	mov    %eax,(%esp)
  101994:	e8 e7 e7 ff ff       	call   100180 <bread>
  101999:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  memmove(sb, bp->data, sizeof(*sb));
  10199c:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10199f:	83 c0 18             	add    $0x18,%eax
  1019a2:	c7 44 24 08 0c 00 00 	movl   $0xc,0x8(%esp)
  1019a9:	00 
  1019aa:	89 44 24 04          	mov    %eax,0x4(%esp)
  1019ae:	8b 45 0c             	mov    0xc(%ebp),%eax
  1019b1:	89 04 24             	mov    %eax,(%esp)
  1019b4:	e8 a7 45 00 00       	call   105f60 <memmove>
  brelse(bp);
  1019b9:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1019bc:	89 04 24             	mov    %eax,(%esp)
  1019bf:	e8 3c e8 ff ff       	call   100200 <brelse>
}
  1019c4:	c9                   	leave  
  1019c5:	c3                   	ret    
  1019c6:	8d 76 00             	lea    0x0(%esi),%esi
  1019c9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

001019d0 <bzero>:

// Zero a block.
static void
bzero(int dev, int bno)
{
  1019d0:	55                   	push   %ebp
  1019d1:	89 e5                	mov    %esp,%ebp
  1019d3:	83 ec 28             	sub    $0x28,%esp
  struct buf *bp;
  
//  cprintf("XXX %s\n",__func__);
  bp = bread(dev, bno);
  1019d6:	8b 45 0c             	mov    0xc(%ebp),%eax
  1019d9:	8b 55 08             	mov    0x8(%ebp),%edx
  1019dc:	89 44 24 04          	mov    %eax,0x4(%esp)
  1019e0:	89 14 24             	mov    %edx,(%esp)
  1019e3:	e8 98 e7 ff ff       	call   100180 <bread>
  1019e8:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  memset(bp->data, 0, BSIZE);
  1019eb:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1019ee:	83 c0 18             	add    $0x18,%eax
  1019f1:	c7 44 24 08 00 02 00 	movl   $0x200,0x8(%esp)
  1019f8:	00 
  1019f9:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  101a00:	00 
  101a01:	89 04 24             	mov    %eax,(%esp)
  101a04:	e8 c7 44 00 00       	call   105ed0 <memset>
  bwrite(bp);
  101a09:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  101a0c:	89 04 24             	mov    %eax,(%esp)
  101a0f:	e8 ac e7 ff ff       	call   1001c0 <bwrite>
  brelse(bp);
  101a14:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  101a17:	89 04 24             	mov    %eax,(%esp)
  101a1a:	e8 e1 e7 ff ff       	call   100200 <brelse>
}
  101a1f:	c9                   	leave  
  101a20:	c3                   	ret    
  101a21:	eb 0d                	jmp    101a30 <balloc>
  101a23:	90                   	nop    
  101a24:	90                   	nop    
  101a25:	90                   	nop    
  101a26:	90                   	nop    
  101a27:	90                   	nop    
  101a28:	90                   	nop    
  101a29:	90                   	nop    
  101a2a:	90                   	nop    
  101a2b:	90                   	nop    
  101a2c:	90                   	nop    
  101a2d:	90                   	nop    
  101a2e:	90                   	nop    
  101a2f:	90                   	nop    

00101a30 <balloc>:

// Blocks. 

// Allocate a disk block.
static uint
balloc(uint dev)
{
  101a30:	55                   	push   %ebp
  101a31:	89 e5                	mov    %esp,%ebp
  101a33:	83 ec 38             	sub    $0x38,%esp
  int b, bi, m;
  struct buf *bp;
  struct superblock sb;

//  cprintf("XXX %s\n",__func__);
  bp = 0;
  101a36:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
  readsb(dev, &sb);
  101a3d:	8b 55 08             	mov    0x8(%ebp),%edx
  101a40:	8d 45 e4             	lea    0xffffffe4(%ebp),%eax
  101a43:	89 44 24 04          	mov    %eax,0x4(%esp)
  101a47:	89 14 24             	mov    %edx,(%esp)
  101a4a:	e8 31 ff ff ff       	call   101980 <readsb>
  for(b = 0; b < sb.size; b += BPB){
  101a4f:	c7 45 f0 00 00 00 00 	movl   $0x0,0xfffffff0(%ebp)
  101a56:	e9 f1 00 00 00       	jmp    101b4c <balloc+0x11c>
    bp = bread(dev, BBLOCK(b, sb.ninodes));
  101a5b:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
  101a5e:	89 d0                	mov    %edx,%eax
  101a60:	c1 f8 1f             	sar    $0x1f,%eax
  101a63:	c1 e8 14             	shr    $0x14,%eax
  101a66:	01 d0                	add    %edx,%eax
  101a68:	c1 f8 0c             	sar    $0xc,%eax
  101a6b:	89 c2                	mov    %eax,%edx
  101a6d:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  101a70:	c1 e8 03             	shr    $0x3,%eax
  101a73:	8d 04 02             	lea    (%edx,%eax,1),%eax
  101a76:	83 c0 03             	add    $0x3,%eax
  101a79:	89 44 24 04          	mov    %eax,0x4(%esp)
  101a7d:	8b 45 08             	mov    0x8(%ebp),%eax
  101a80:	89 04 24             	mov    %eax,(%esp)
  101a83:	e8 f8 e6 ff ff       	call   100180 <bread>
  101a88:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
    for(bi = 0; bi < BPB; bi++){
  101a8b:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
  101a92:	e9 96 00 00 00       	jmp    101b2d <balloc+0xfd>
      m = 1 << (bi % 8);
  101a97:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
  101a9a:	89 d0                	mov    %edx,%eax
  101a9c:	c1 f8 1f             	sar    $0x1f,%eax
  101a9f:	89 c1                	mov    %eax,%ecx
  101aa1:	c1 e9 1d             	shr    $0x1d,%ecx
  101aa4:	8d 04 0a             	lea    (%edx,%ecx,1),%eax
  101aa7:	83 e0 07             	and    $0x7,%eax
  101aaa:	29 c8                	sub    %ecx,%eax
  101aac:	89 c1                	mov    %eax,%ecx
  101aae:	b8 01 00 00 00       	mov    $0x1,%eax
  101ab3:	d3 e0                	shl    %cl,%eax
  101ab5:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
      if((bp->data[bi/8] & m) == 0){  // Is block free?
  101ab8:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
  101abb:	89 d0                	mov    %edx,%eax
  101abd:	c1 f8 1f             	sar    $0x1f,%eax
  101ac0:	c1 e8 1d             	shr    $0x1d,%eax
  101ac3:	01 d0                	add    %edx,%eax
  101ac5:	c1 f8 03             	sar    $0x3,%eax
  101ac8:	89 c2                	mov    %eax,%edx
  101aca:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  101acd:	0f b6 44 02 18       	movzbl 0x18(%edx,%eax,1),%eax
  101ad2:	0f b6 c0             	movzbl %al,%eax
  101ad5:	23 45 f8             	and    0xfffffff8(%ebp),%eax
  101ad8:	85 c0                	test   %eax,%eax
  101ada:	75 4d                	jne    101b29 <balloc+0xf9>
        bp->data[bi/8] |= m;  // Mark block in use on disk.
  101adc:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
  101adf:	89 d0                	mov    %edx,%eax
  101ae1:	c1 f8 1f             	sar    $0x1f,%eax
  101ae4:	c1 e8 1d             	shr    $0x1d,%eax
  101ae7:	01 d0                	add    %edx,%eax
  101ae9:	c1 f8 03             	sar    $0x3,%eax
  101aec:	89 c1                	mov    %eax,%ecx
  101aee:	89 c2                	mov    %eax,%edx
  101af0:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  101af3:	0f b6 44 02 18       	movzbl 0x18(%edx,%eax,1),%eax
  101af8:	89 c2                	mov    %eax,%edx
  101afa:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  101afd:	09 d0                	or     %edx,%eax
  101aff:	89 c2                	mov    %eax,%edx
  101b01:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  101b04:	88 54 01 18          	mov    %dl,0x18(%ecx,%eax,1)
        bwrite(bp);
  101b08:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  101b0b:	89 04 24             	mov    %eax,(%esp)
  101b0e:	e8 ad e6 ff ff       	call   1001c0 <bwrite>
        brelse(bp);
  101b13:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  101b16:	89 04 24             	mov    %eax,(%esp)
  101b19:	e8 e2 e6 ff ff       	call   100200 <brelse>
        return b + bi;
  101b1e:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  101b21:	03 45 f0             	add    0xfffffff0(%ebp),%eax
  101b24:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
  101b27:	eb 3d                	jmp    101b66 <balloc+0x136>
  101b29:	83 45 f4 01          	addl   $0x1,0xfffffff4(%ebp)
  101b2d:	81 7d f4 ff 0f 00 00 	cmpl   $0xfff,0xfffffff4(%ebp)
  101b34:	0f 8e 5d ff ff ff    	jle    101a97 <balloc+0x67>
      }
    }
    brelse(bp);
  101b3a:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  101b3d:	89 04 24             	mov    %eax,(%esp)
  101b40:	e8 bb e6 ff ff       	call   100200 <brelse>
  101b45:	81 45 f0 00 10 00 00 	addl   $0x1000,0xfffffff0(%ebp)
  101b4c:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
  101b4f:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
  101b52:	39 c2                	cmp    %eax,%edx
  101b54:	0f 82 01 ff ff ff    	jb     101a5b <balloc+0x2b>
  }
  panic("balloc: out of blocks");
  101b5a:	c7 04 24 ff a3 11 00 	movl   $0x11a3ff,(%esp)
  101b61:	e8 9a f4 ff ff       	call   101000 <panic>
}
  101b66:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  101b69:	c9                   	leave  
  101b6a:	c3                   	ret    
  101b6b:	90                   	nop    
  101b6c:	8d 74 26 00          	lea    0x0(%esi),%esi

00101b70 <bfree>:

// Free a disk block.
static void
bfree(int dev, uint b)
{
  101b70:	55                   	push   %ebp
  101b71:	89 e5                	mov    %esp,%ebp
  101b73:	83 ec 28             	sub    $0x28,%esp
  struct buf *bp;
  struct superblock sb;
  int bi, m;

  bzero(dev, b);
  101b76:	8b 45 0c             	mov    0xc(%ebp),%eax
  101b79:	89 44 24 04          	mov    %eax,0x4(%esp)
  101b7d:	8b 45 08             	mov    0x8(%ebp),%eax
  101b80:	89 04 24             	mov    %eax,(%esp)
  101b83:	e8 48 fe ff ff       	call   1019d0 <bzero>

//  cprintf("XXX %s\n",__func__);
  readsb(dev, &sb);
  101b88:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
  101b8b:	89 44 24 04          	mov    %eax,0x4(%esp)
  101b8f:	8b 45 08             	mov    0x8(%ebp),%eax
  101b92:	89 04 24             	mov    %eax,(%esp)
  101b95:	e8 e6 fd ff ff       	call   101980 <readsb>
  bp = bread(dev, BBLOCK(b, sb.ninodes));
  101b9a:	8b 45 0c             	mov    0xc(%ebp),%eax
  101b9d:	89 c2                	mov    %eax,%edx
  101b9f:	c1 ea 0c             	shr    $0xc,%edx
  101ba2:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  101ba5:	c1 e8 03             	shr    $0x3,%eax
  101ba8:	8d 04 02             	lea    (%edx,%eax,1),%eax
  101bab:	83 c0 03             	add    $0x3,%eax
  101bae:	8b 55 08             	mov    0x8(%ebp),%edx
  101bb1:	89 44 24 04          	mov    %eax,0x4(%esp)
  101bb5:	89 14 24             	mov    %edx,(%esp)
  101bb8:	e8 c3 e5 ff ff       	call   100180 <bread>
  101bbd:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  bi = b % BPB;
  101bc0:	8b 45 0c             	mov    0xc(%ebp),%eax
  101bc3:	25 ff 0f 00 00       	and    $0xfff,%eax
  101bc8:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  m = 1 << (bi % 8);
  101bcb:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  101bce:	89 d0                	mov    %edx,%eax
  101bd0:	c1 f8 1f             	sar    $0x1f,%eax
  101bd3:	89 c1                	mov    %eax,%ecx
  101bd5:	c1 e9 1d             	shr    $0x1d,%ecx
  101bd8:	8d 04 0a             	lea    (%edx,%ecx,1),%eax
  101bdb:	83 e0 07             	and    $0x7,%eax
  101bde:	29 c8                	sub    %ecx,%eax
  101be0:	89 c1                	mov    %eax,%ecx
  101be2:	b8 01 00 00 00       	mov    $0x1,%eax
  101be7:	d3 e0                	shl    %cl,%eax
  101be9:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  if((bp->data[bi/8] & m) == 0)
  101bec:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  101bef:	89 d0                	mov    %edx,%eax
  101bf1:	c1 f8 1f             	sar    $0x1f,%eax
  101bf4:	c1 e8 1d             	shr    $0x1d,%eax
  101bf7:	01 d0                	add    %edx,%eax
  101bf9:	c1 f8 03             	sar    $0x3,%eax
  101bfc:	89 c2                	mov    %eax,%edx
  101bfe:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  101c01:	0f b6 44 02 18       	movzbl 0x18(%edx,%eax,1),%eax
  101c06:	0f b6 c0             	movzbl %al,%eax
  101c09:	23 45 fc             	and    0xfffffffc(%ebp),%eax
  101c0c:	85 c0                	test   %eax,%eax
  101c0e:	75 0c                	jne    101c1c <bfree+0xac>
    panic("freeing free block");
  101c10:	c7 04 24 15 a4 11 00 	movl   $0x11a415,(%esp)
  101c17:	e8 e4 f3 ff ff       	call   101000 <panic>
  bp->data[bi/8] &= ~m;  // Mark block free on disk.
  101c1c:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  101c1f:	89 d0                	mov    %edx,%eax
  101c21:	c1 f8 1f             	sar    $0x1f,%eax
  101c24:	c1 e8 1d             	shr    $0x1d,%eax
  101c27:	01 d0                	add    %edx,%eax
  101c29:	c1 f8 03             	sar    $0x3,%eax
  101c2c:	89 c1                	mov    %eax,%ecx
  101c2e:	89 c2                	mov    %eax,%edx
  101c30:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  101c33:	0f b6 44 02 18       	movzbl 0x18(%edx,%eax,1),%eax
  101c38:	89 c2                	mov    %eax,%edx
  101c3a:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  101c3d:	f7 d0                	not    %eax
  101c3f:	21 d0                	and    %edx,%eax
  101c41:	89 c2                	mov    %eax,%edx
  101c43:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  101c46:	88 54 01 18          	mov    %dl,0x18(%ecx,%eax,1)
  bwrite(bp);
  101c4a:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  101c4d:	89 04 24             	mov    %eax,(%esp)
  101c50:	e8 6b e5 ff ff       	call   1001c0 <bwrite>
  brelse(bp);
  101c55:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  101c58:	89 04 24             	mov    %eax,(%esp)
  101c5b:	e8 a0 e5 ff ff       	call   100200 <brelse>
}
  101c60:	c9                   	leave  
  101c61:	c3                   	ret    
  101c62:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi
  101c69:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00101c70 <iinit>:

// Inodes.
//
// An inode is a single, unnamed file in the file system.
// The inode disk structure holds metadata (the type, device numbers,
// and data size) along with a list of blocks where the associated
// data can be found.
//
// The inodes are laid out sequentially on disk immediately after
// the superblock.  The kernel keeps a cache of the in-use
// on-disk structures to provide a place for synchronizing access
// to inodes shared between multiple processes.
// 
// ip->ref counts the number of pointer references to this cached
// inode; references are typically kept in struct file and in cp->cwd.
// When ip->ref falls to zero, the inode is no longer cached.
// It is an error to use an inode without holding a reference to it.
//
// Processes are only allowed to read and write inode
// metadata and contents when holding the inode's lock,
// represented by the I_BUSY flag in the in-memory copy.
// Because inode locks are held during disk accesses, 
// they are implemented using a flag rather than with
// spin locks.  Callers are responsible for locking
// inodes before passing them to routines in this file; leaving
// this responsibility with the caller makes it possible for them
// to create arbitrarily-sized atomic operations.
//
// To give maximum control over locking to the callers, 
// the routines in this file that return inode pointers 
// return pointers to *unlocked* inodes.  It is the callers'
// responsibility to lock them before using them.  A non-zero
// ip->ref keeps these unlocked inodes in the cache.

struct {
  struct spinlock lock;
  struct inode inode[NINODE];
} icache;

void
iinit(void)
{
  101c70:	55                   	push   %ebp
  101c71:	89 e5                	mov    %esp,%ebp
  101c73:	83 ec 08             	sub    $0x8,%esp
  initlock(&icache.lock, "icache.lock");
  101c76:	c7 44 24 04 28 a4 11 	movl   $0x11a428,0x4(%esp)
  101c7d:	00 
  101c7e:	c7 04 24 e0 bb 13 00 	movl   $0x13bbe0,(%esp)
  101c85:	e8 56 3e 00 00       	call   105ae0 <initlock>
}
  101c8a:	c9                   	leave  
  101c8b:	c3                   	ret    
  101c8c:	8d 74 26 00          	lea    0x0(%esi),%esi

00101c90 <iget>:

// Find the inode with number inum on device dev
// and return the in-memory copy.
static struct inode*
iget(uint dev, uint inum)
{
  101c90:	55                   	push   %ebp
  101c91:	89 e5                	mov    %esp,%ebp
  101c93:	83 ec 18             	sub    $0x18,%esp
  struct inode *ip, *empty;

  acquire(&icache.lock);
  101c96:	c7 04 24 e0 bb 13 00 	movl   $0x13bbe0,(%esp)
  101c9d:	e8 6e 3e 00 00       	call   105b10 <acquire>

  // Try for cached inode.
  empty = 0;
  101ca2:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
  for(ip = &icache.inode[0]; ip < &icache.inode[NINODE]; ip++){
  101ca9:	c7 45 f8 14 bc 13 00 	movl   $0x13bc14,0xfffffff8(%ebp)
  101cb0:	eb 5c                	jmp    101d0e <iget+0x7e>
    if(ip->ref > 0 && ip->dev == dev && ip->inum == inum){
  101cb2:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  101cb5:	8b 40 08             	mov    0x8(%eax),%eax
  101cb8:	85 c0                	test   %eax,%eax
  101cba:	7e 38                	jle    101cf4 <iget+0x64>
  101cbc:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  101cbf:	8b 00                	mov    (%eax),%eax
  101cc1:	3b 45 08             	cmp    0x8(%ebp),%eax
  101cc4:	75 2e                	jne    101cf4 <iget+0x64>
  101cc6:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  101cc9:	8b 40 04             	mov    0x4(%eax),%eax
  101ccc:	3b 45 0c             	cmp    0xc(%ebp),%eax
  101ccf:	75 23                	jne    101cf4 <iget+0x64>
      ip->ref++;
  101cd1:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  101cd4:	8b 40 08             	mov    0x8(%eax),%eax
  101cd7:	8d 50 01             	lea    0x1(%eax),%edx
  101cda:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  101cdd:	89 50 08             	mov    %edx,0x8(%eax)
      release(&icache.lock);
  101ce0:	c7 04 24 e0 bb 13 00 	movl   $0x13bbe0,(%esp)
  101ce7:	e8 24 40 00 00       	call   105d10 <release>
//      cprintf("XXX iget: found in cache\n");
      return ip;
  101cec:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  101cef:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  101cf2:	eb 73                	jmp    101d67 <iget+0xd7>
    }
    if(empty == 0 && ip->ref == 0)    // Remember empty slot.
  101cf4:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  101cf8:	75 10                	jne    101d0a <iget+0x7a>
  101cfa:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  101cfd:	8b 40 08             	mov    0x8(%eax),%eax
  101d00:	85 c0                	test   %eax,%eax
  101d02:	75 06                	jne    101d0a <iget+0x7a>
      empty = ip;
  101d04:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  101d07:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  101d0a:	83 45 f8 50          	addl   $0x50,0xfffffff8(%ebp)
  101d0e:	b8 b4 cb 13 00       	mov    $0x13cbb4,%eax
  101d13:	39 45 f8             	cmp    %eax,0xfffffff8(%ebp)
  101d16:	72 9a                	jb     101cb2 <iget+0x22>
  }

  // Allocate fresh inode.
  if(empty == 0)
  101d18:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  101d1c:	75 0c                	jne    101d2a <iget+0x9a>
    panic("iget: no inodes");
  101d1e:	c7 04 24 34 a4 11 00 	movl   $0x11a434,(%esp)
  101d25:	e8 d6 f2 ff ff       	call   101000 <panic>

//  cprintf("XXX iget: allocating new\n");
  ip = empty;
  101d2a:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  101d2d:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  ip->dev = dev;
  101d30:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  101d33:	8b 45 08             	mov    0x8(%ebp),%eax
  101d36:	89 02                	mov    %eax,(%edx)
  ip->inum = inum;
  101d38:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  101d3b:	8b 45 0c             	mov    0xc(%ebp),%eax
  101d3e:	89 42 04             	mov    %eax,0x4(%edx)
  ip->ref = 1;
  101d41:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  101d44:	c7 40 08 01 00 00 00 	movl   $0x1,0x8(%eax)
  ip->flags = 0;
  101d4b:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  101d4e:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
  release(&icache.lock);
  101d55:	c7 04 24 e0 bb 13 00 	movl   $0x13bbe0,(%esp)
  101d5c:	e8 af 3f 00 00       	call   105d10 <release>

  return ip;
  101d61:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  101d64:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  101d67:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  101d6a:	c9                   	leave  
  101d6b:	c3                   	ret    
  101d6c:	8d 74 26 00          	lea    0x0(%esi),%esi

00101d70 <idup>:

// Increment reference count for ip.
// Returns ip to enable ip = idup(ip1) idiom.
struct inode*
idup(struct inode *ip)
{
  101d70:	55                   	push   %ebp
  101d71:	89 e5                	mov    %esp,%ebp
  101d73:	83 ec 08             	sub    $0x8,%esp
  acquire(&icache.lock);
  101d76:	c7 04 24 e0 bb 13 00 	movl   $0x13bbe0,(%esp)
  101d7d:	e8 8e 3d 00 00       	call   105b10 <acquire>
  ip->ref++;
  101d82:	8b 45 08             	mov    0x8(%ebp),%eax
  101d85:	8b 40 08             	mov    0x8(%eax),%eax
  101d88:	8d 50 01             	lea    0x1(%eax),%edx
  101d8b:	8b 45 08             	mov    0x8(%ebp),%eax
  101d8e:	89 50 08             	mov    %edx,0x8(%eax)
  release(&icache.lock);
  101d91:	c7 04 24 e0 bb 13 00 	movl   $0x13bbe0,(%esp)
  101d98:	e8 73 3f 00 00       	call   105d10 <release>
  return ip;
  101d9d:	8b 45 08             	mov    0x8(%ebp),%eax
}
  101da0:	c9                   	leave  
  101da1:	c3                   	ret    
  101da2:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi
  101da9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00101db0 <ilock>:

// Lock the given inode.
void
ilock(struct inode *ip)
{
  101db0:	55                   	push   %ebp
  101db1:	89 e5                	mov    %esp,%ebp
  101db3:	83 ec 28             	sub    $0x28,%esp
  struct buf *bp;
  struct dinode *dip;

  if(ip == 0 || ip->ref < 1)
  101db6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  101dba:	74 0a                	je     101dc6 <ilock+0x16>
  101dbc:	8b 45 08             	mov    0x8(%ebp),%eax
  101dbf:	8b 40 08             	mov    0x8(%eax),%eax
  101dc2:	85 c0                	test   %eax,%eax
  101dc4:	7f 0c                	jg     101dd2 <ilock+0x22>
    panic("ilock");
  101dc6:	c7 04 24 44 a4 11 00 	movl   $0x11a444,(%esp)
  101dcd:	e8 2e f2 ff ff       	call   101000 <panic>

  acquire(&icache.lock);
  101dd2:	c7 04 24 e0 bb 13 00 	movl   $0x13bbe0,(%esp)
  101dd9:	e8 32 3d 00 00       	call   105b10 <acquire>
  while(ip->flags & I_BUSY)
  101dde:	eb 13                	jmp    101df3 <ilock+0x43>
    sleep(ip, &icache.lock);
  101de0:	c7 44 24 04 e0 bb 13 	movl   $0x13bbe0,0x4(%esp)
  101de7:	00 
  101de8:	8b 45 08             	mov    0x8(%ebp),%eax
  101deb:	89 04 24             	mov    %eax,(%esp)
  101dee:	e8 6d 36 00 00       	call   105460 <sleep>
  101df3:	8b 45 08             	mov    0x8(%ebp),%eax
  101df6:	8b 40 0c             	mov    0xc(%eax),%eax
  101df9:	83 e0 01             	and    $0x1,%eax
  101dfc:	84 c0                	test   %al,%al
  101dfe:	75 e0                	jne    101de0 <ilock+0x30>
  ip->flags |= I_BUSY;
  101e00:	8b 45 08             	mov    0x8(%ebp),%eax
  101e03:	8b 40 0c             	mov    0xc(%eax),%eax
  101e06:	89 c2                	mov    %eax,%edx
  101e08:	83 ca 01             	or     $0x1,%edx
  101e0b:	8b 45 08             	mov    0x8(%ebp),%eax
  101e0e:	89 50 0c             	mov    %edx,0xc(%eax)
  release(&icache.lock);
  101e11:	c7 04 24 e0 bb 13 00 	movl   $0x13bbe0,(%esp)
  101e18:	e8 f3 3e 00 00       	call   105d10 <release>

  if(!(ip->flags & I_VALID)){
  101e1d:	8b 45 08             	mov    0x8(%ebp),%eax
  101e20:	8b 40 0c             	mov    0xc(%eax),%eax
  101e23:	83 e0 02             	and    $0x2,%eax
  101e26:	85 c0                	test   %eax,%eax
  101e28:	0f 85 d1 00 00 00    	jne    101eff <ilock+0x14f>
    bp = bread(ip->dev, IBLOCK(ip->inum));
  101e2e:	8b 45 08             	mov    0x8(%ebp),%eax
  101e31:	8b 40 04             	mov    0x4(%eax),%eax
  101e34:	c1 e8 03             	shr    $0x3,%eax
  101e37:	8d 50 02             	lea    0x2(%eax),%edx
  101e3a:	8b 45 08             	mov    0x8(%ebp),%eax
  101e3d:	8b 00                	mov    (%eax),%eax
  101e3f:	89 54 24 04          	mov    %edx,0x4(%esp)
  101e43:	89 04 24             	mov    %eax,(%esp)
  101e46:	e8 35 e3 ff ff       	call   100180 <bread>
  101e4b:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
//  cprintf("XXX %s:after bread \n",__func__);
    dip = (struct dinode*)bp->data + ip->inum%IPB;
  101e4e:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  101e51:	83 c0 18             	add    $0x18,%eax
  101e54:	89 c2                	mov    %eax,%edx
  101e56:	8b 45 08             	mov    0x8(%ebp),%eax
  101e59:	8b 40 04             	mov    0x4(%eax),%eax
  101e5c:	83 e0 07             	and    $0x7,%eax
  101e5f:	c1 e0 06             	shl    $0x6,%eax
  101e62:	8d 04 02             	lea    (%edx,%eax,1),%eax
  101e65:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
    ip->type = dip->type;
  101e68:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  101e6b:	0f b7 10             	movzwl (%eax),%edx
  101e6e:	8b 45 08             	mov    0x8(%ebp),%eax
  101e71:	66 89 50 10          	mov    %dx,0x10(%eax)
    ip->major = dip->major;
  101e75:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  101e78:	0f b7 50 02          	movzwl 0x2(%eax),%edx
  101e7c:	8b 45 08             	mov    0x8(%ebp),%eax
  101e7f:	66 89 50 12          	mov    %dx,0x12(%eax)
    ip->minor = dip->minor;
  101e83:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  101e86:	0f b7 50 04          	movzwl 0x4(%eax),%edx
  101e8a:	8b 45 08             	mov    0x8(%ebp),%eax
  101e8d:	66 89 50 14          	mov    %dx,0x14(%eax)
    ip->nlink = dip->nlink;
  101e91:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  101e94:	0f b7 50 06          	movzwl 0x6(%eax),%edx
  101e98:	8b 45 08             	mov    0x8(%ebp),%eax
  101e9b:	66 89 50 16          	mov    %dx,0x16(%eax)
    ip->size = dip->size;
  101e9f:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  101ea2:	8b 50 08             	mov    0x8(%eax),%edx
  101ea5:	8b 45 08             	mov    0x8(%ebp),%eax
  101ea8:	89 50 18             	mov    %edx,0x18(%eax)
    memmove(ip->addrs, dip->addrs, sizeof(ip->addrs));
  101eab:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  101eae:	83 c0 0c             	add    $0xc,%eax
  101eb1:	8b 55 08             	mov    0x8(%ebp),%edx
  101eb4:	83 c2 1c             	add    $0x1c,%edx
  101eb7:	c7 44 24 08 34 00 00 	movl   $0x34,0x8(%esp)
  101ebe:	00 
  101ebf:	89 44 24 04          	mov    %eax,0x4(%esp)
  101ec3:	89 14 24             	mov    %edx,(%esp)
  101ec6:	e8 95 40 00 00       	call   105f60 <memmove>
    brelse(bp);
  101ecb:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  101ece:	89 04 24             	mov    %eax,(%esp)
  101ed1:	e8 2a e3 ff ff       	call   100200 <brelse>
    ip->flags |= I_VALID;
  101ed6:	8b 45 08             	mov    0x8(%ebp),%eax
  101ed9:	8b 40 0c             	mov    0xc(%eax),%eax
  101edc:	89 c2                	mov    %eax,%edx
  101ede:	83 ca 02             	or     $0x2,%edx
  101ee1:	8b 45 08             	mov    0x8(%ebp),%eax
  101ee4:	89 50 0c             	mov    %edx,0xc(%eax)
    if(ip->type == 0)
  101ee7:	8b 45 08             	mov    0x8(%ebp),%eax
  101eea:	0f b7 40 10          	movzwl 0x10(%eax),%eax
  101eee:	66 85 c0             	test   %ax,%ax
  101ef1:	75 0c                	jne    101eff <ilock+0x14f>
      panic("ilock: no type");
  101ef3:	c7 04 24 4a a4 11 00 	movl   $0x11a44a,(%esp)
  101efa:	e8 01 f1 ff ff       	call   101000 <panic>
  }
}
  101eff:	c9                   	leave  
  101f00:	c3                   	ret    
  101f01:	eb 0d                	jmp    101f10 <iunlock>
  101f03:	90                   	nop    
  101f04:	90                   	nop    
  101f05:	90                   	nop    
  101f06:	90                   	nop    
  101f07:	90                   	nop    
  101f08:	90                   	nop    
  101f09:	90                   	nop    
  101f0a:	90                   	nop    
  101f0b:	90                   	nop    
  101f0c:	90                   	nop    
  101f0d:	90                   	nop    
  101f0e:	90                   	nop    
  101f0f:	90                   	nop    

00101f10 <iunlock>:

// Unlock the given inode.
void
iunlock(struct inode *ip)
{
  101f10:	55                   	push   %ebp
  101f11:	89 e5                	mov    %esp,%ebp
  101f13:	83 ec 08             	sub    $0x8,%esp
  if(ip == 0 || !(ip->flags & I_BUSY) || ip->ref < 1)
  101f16:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  101f1a:	74 17                	je     101f33 <iunlock+0x23>
  101f1c:	8b 45 08             	mov    0x8(%ebp),%eax
  101f1f:	8b 40 0c             	mov    0xc(%eax),%eax
  101f22:	83 e0 01             	and    $0x1,%eax
  101f25:	85 c0                	test   %eax,%eax
  101f27:	74 0a                	je     101f33 <iunlock+0x23>
  101f29:	8b 45 08             	mov    0x8(%ebp),%eax
  101f2c:	8b 40 08             	mov    0x8(%eax),%eax
  101f2f:	85 c0                	test   %eax,%eax
  101f31:	7f 0c                	jg     101f3f <iunlock+0x2f>
    panic("iunlock");
  101f33:	c7 04 24 59 a4 11 00 	movl   $0x11a459,(%esp)
  101f3a:	e8 c1 f0 ff ff       	call   101000 <panic>

  acquire(&icache.lock);
  101f3f:	c7 04 24 e0 bb 13 00 	movl   $0x13bbe0,(%esp)
  101f46:	e8 c5 3b 00 00       	call   105b10 <acquire>
  ip->flags &= ~I_BUSY;
  101f4b:	8b 45 08             	mov    0x8(%ebp),%eax
  101f4e:	8b 40 0c             	mov    0xc(%eax),%eax
  101f51:	89 c2                	mov    %eax,%edx
  101f53:	83 e2 fe             	and    $0xfffffffe,%edx
  101f56:	8b 45 08             	mov    0x8(%ebp),%eax
  101f59:	89 50 0c             	mov    %edx,0xc(%eax)
  wakeup(ip);
  101f5c:	8b 45 08             	mov    0x8(%ebp),%eax
  101f5f:	89 04 24             	mov    %eax,(%esp)
  101f62:	e8 89 36 00 00       	call   1055f0 <wakeup>
  release(&icache.lock);
  101f67:	c7 04 24 e0 bb 13 00 	movl   $0x13bbe0,(%esp)
  101f6e:	e8 9d 3d 00 00       	call   105d10 <release>
}
  101f73:	c9                   	leave  
  101f74:	c3                   	ret    
  101f75:	8d 74 26 00          	lea    0x0(%esi),%esi
  101f79:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00101f80 <iput>:

// Caller holds reference to unlocked ip.  Drop reference.
void
iput(struct inode *ip)
{
  101f80:	55                   	push   %ebp
  101f81:	89 e5                	mov    %esp,%ebp
  101f83:	83 ec 08             	sub    $0x8,%esp
  acquire(&icache.lock);
  101f86:	c7 04 24 e0 bb 13 00 	movl   $0x13bbe0,(%esp)
  101f8d:	e8 7e 3b 00 00       	call   105b10 <acquire>
  if(ip->ref == 1 && (ip->flags & I_VALID) && ip->nlink == 0){
  101f92:	8b 45 08             	mov    0x8(%ebp),%eax
  101f95:	8b 40 08             	mov    0x8(%eax),%eax
  101f98:	83 f8 01             	cmp    $0x1,%eax
  101f9b:	0f 85 9a 00 00 00    	jne    10203b <iput+0xbb>
  101fa1:	8b 45 08             	mov    0x8(%ebp),%eax
  101fa4:	8b 40 0c             	mov    0xc(%eax),%eax
  101fa7:	83 e0 02             	and    $0x2,%eax
  101faa:	85 c0                	test   %eax,%eax
  101fac:	0f 84 89 00 00 00    	je     10203b <iput+0xbb>
  101fb2:	8b 45 08             	mov    0x8(%ebp),%eax
  101fb5:	0f b7 40 16          	movzwl 0x16(%eax),%eax
  101fb9:	66 85 c0             	test   %ax,%ax
  101fbc:	75 7d                	jne    10203b <iput+0xbb>
    // inode is no longer used: truncate and free inode.
    if(ip->flags & I_BUSY)
  101fbe:	8b 45 08             	mov    0x8(%ebp),%eax
  101fc1:	8b 40 0c             	mov    0xc(%eax),%eax
  101fc4:	83 e0 01             	and    $0x1,%eax
  101fc7:	84 c0                	test   %al,%al
  101fc9:	74 0c                	je     101fd7 <iput+0x57>
      panic("iput busy");
  101fcb:	c7 04 24 61 a4 11 00 	movl   $0x11a461,(%esp)
  101fd2:	e8 29 f0 ff ff       	call   101000 <panic>
    ip->flags |= I_BUSY;
  101fd7:	8b 45 08             	mov    0x8(%ebp),%eax
  101fda:	8b 40 0c             	mov    0xc(%eax),%eax
  101fdd:	89 c2                	mov    %eax,%edx
  101fdf:	83 ca 01             	or     $0x1,%edx
  101fe2:	8b 45 08             	mov    0x8(%ebp),%eax
  101fe5:	89 50 0c             	mov    %edx,0xc(%eax)
    release(&icache.lock);
  101fe8:	c7 04 24 e0 bb 13 00 	movl   $0x13bbe0,(%esp)
  101fef:	e8 1c 3d 00 00       	call   105d10 <release>
    itrunc(ip);
  101ff4:	8b 45 08             	mov    0x8(%ebp),%eax
  101ff7:	89 04 24             	mov    %eax,(%esp)
  101ffa:	e8 81 03 00 00       	call   102380 <itrunc>
    ip->type = 0;
  101fff:	8b 45 08             	mov    0x8(%ebp),%eax
  102002:	66 c7 40 10 00 00    	movw   $0x0,0x10(%eax)
    iupdate(ip);
  102008:	8b 45 08             	mov    0x8(%ebp),%eax
  10200b:	89 04 24             	mov    %eax,(%esp)
  10200e:	e8 5d 01 00 00       	call   102170 <iupdate>
    acquire(&icache.lock);
  102013:	c7 04 24 e0 bb 13 00 	movl   $0x13bbe0,(%esp)
  10201a:	e8 f1 3a 00 00       	call   105b10 <acquire>
    ip->flags &= ~I_BUSY;
  10201f:	8b 45 08             	mov    0x8(%ebp),%eax
  102022:	8b 40 0c             	mov    0xc(%eax),%eax
  102025:	89 c2                	mov    %eax,%edx
  102027:	83 e2 fe             	and    $0xfffffffe,%edx
  10202a:	8b 45 08             	mov    0x8(%ebp),%eax
  10202d:	89 50 0c             	mov    %edx,0xc(%eax)
    wakeup(ip);
  102030:	8b 45 08             	mov    0x8(%ebp),%eax
  102033:	89 04 24             	mov    %eax,(%esp)
  102036:	e8 b5 35 00 00       	call   1055f0 <wakeup>
  }
  ip->ref--;
  10203b:	8b 45 08             	mov    0x8(%ebp),%eax
  10203e:	8b 40 08             	mov    0x8(%eax),%eax
  102041:	8d 50 ff             	lea    0xffffffff(%eax),%edx
  102044:	8b 45 08             	mov    0x8(%ebp),%eax
  102047:	89 50 08             	mov    %edx,0x8(%eax)
  release(&icache.lock);
  10204a:	c7 04 24 e0 bb 13 00 	movl   $0x13bbe0,(%esp)
  102051:	e8 ba 3c 00 00       	call   105d10 <release>
}
  102056:	c9                   	leave  
  102057:	c3                   	ret    
  102058:	90                   	nop    
  102059:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

00102060 <iunlockput>:

// Common idiom: unlock, then put.
void
iunlockput(struct inode *ip)
{
  102060:	55                   	push   %ebp
  102061:	89 e5                	mov    %esp,%ebp
  102063:	83 ec 08             	sub    $0x8,%esp
  iunlock(ip);
  102066:	8b 45 08             	mov    0x8(%ebp),%eax
  102069:	89 04 24             	mov    %eax,(%esp)
  10206c:	e8 9f fe ff ff       	call   101f10 <iunlock>
  iput(ip);
  102071:	8b 45 08             	mov    0x8(%ebp),%eax
  102074:	89 04 24             	mov    %eax,(%esp)
  102077:	e8 04 ff ff ff       	call   101f80 <iput>
}
  10207c:	c9                   	leave  
  10207d:	c3                   	ret    
  10207e:	89 f6                	mov    %esi,%esi

00102080 <ialloc>:

// Allocate a new inode with the given type on device dev.
struct inode*
ialloc(uint dev, short type)
{
  102080:	55                   	push   %ebp
  102081:	89 e5                	mov    %esp,%ebp
  102083:	83 ec 38             	sub    $0x38,%esp
  102086:	8b 45 0c             	mov    0xc(%ebp),%eax
  102089:	66 89 45 dc          	mov    %ax,0xffffffdc(%ebp)
  int inum;
  struct buf *bp;
  struct dinode *dip;
  struct superblock sb;

//  cprintf("XXX %s\n",__func__);
  readsb(dev, &sb);
  10208d:	8b 55 08             	mov    0x8(%ebp),%edx
  102090:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
  102093:	89 44 24 04          	mov    %eax,0x4(%esp)
  102097:	89 14 24             	mov    %edx,(%esp)
  10209a:	e8 e1 f8 ff ff       	call   101980 <readsb>
  for(inum = 1; inum < sb.ninodes; inum++){  // loop over inode blocks
  10209f:	c7 45 f4 01 00 00 00 	movl   $0x1,0xfffffff4(%ebp)
  1020a6:	e9 9e 00 00 00       	jmp    102149 <ialloc+0xc9>
    bp = bread(dev, IBLOCK(inum));
  1020ab:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  1020ae:	c1 e8 03             	shr    $0x3,%eax
  1020b1:	83 c0 02             	add    $0x2,%eax
  1020b4:	89 44 24 04          	mov    %eax,0x4(%esp)
  1020b8:	8b 45 08             	mov    0x8(%ebp),%eax
  1020bb:	89 04 24             	mov    %eax,(%esp)
  1020be:	e8 bd e0 ff ff       	call   100180 <bread>
  1020c3:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
    dip = (struct dinode*)bp->data + inum%IPB;
  1020c6:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1020c9:	83 c0 18             	add    $0x18,%eax
  1020cc:	89 c2                	mov    %eax,%edx
  1020ce:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  1020d1:	83 e0 07             	and    $0x7,%eax
  1020d4:	c1 e0 06             	shl    $0x6,%eax
  1020d7:	8d 04 02             	lea    (%edx,%eax,1),%eax
  1020da:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
    if(dip->type == 0){  // a free inode
  1020dd:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1020e0:	0f b7 00             	movzwl (%eax),%eax
  1020e3:	66 85 c0             	test   %ax,%ax
  1020e6:	75 52                	jne    10213a <ialloc+0xba>
      memset(dip, 0, sizeof(*dip));
  1020e8:	c7 44 24 08 40 00 00 	movl   $0x40,0x8(%esp)
  1020ef:	00 
  1020f0:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  1020f7:	00 
  1020f8:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1020fb:	89 04 24             	mov    %eax,(%esp)
  1020fe:	e8 cd 3d 00 00       	call   105ed0 <memset>
      dip->type = type;
  102103:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  102106:	0f b7 45 dc          	movzwl 0xffffffdc(%ebp),%eax
  10210a:	66 89 02             	mov    %ax,(%edx)
      bwrite(bp);   // mark it allocated on the disk
  10210d:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  102110:	89 04 24             	mov    %eax,(%esp)
  102113:	e8 a8 e0 ff ff       	call   1001c0 <bwrite>
      brelse(bp);
  102118:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10211b:	89 04 24             	mov    %eax,(%esp)
  10211e:	e8 dd e0 ff ff       	call   100200 <brelse>
      return iget(dev, inum);
  102123:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  102126:	89 44 24 04          	mov    %eax,0x4(%esp)
  10212a:	8b 45 08             	mov    0x8(%ebp),%eax
  10212d:	89 04 24             	mov    %eax,(%esp)
  102130:	e8 5b fb ff ff       	call   101c90 <iget>
  102135:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
  102138:	eb 29                	jmp    102163 <ialloc+0xe3>
    }
    brelse(bp);
  10213a:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10213d:	89 04 24             	mov    %eax,(%esp)
  102140:	e8 bb e0 ff ff       	call   100200 <brelse>
  102145:	83 45 f4 01          	addl   $0x1,0xfffffff4(%ebp)
  102149:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
  10214c:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10214f:	39 c2                	cmp    %eax,%edx
  102151:	0f 82 54 ff ff ff    	jb     1020ab <ialloc+0x2b>
  }
  panic("ialloc: no inodes");
  102157:	c7 04 24 6b a4 11 00 	movl   $0x11a46b,(%esp)
  10215e:	e8 9d ee ff ff       	call   101000 <panic>
}
  102163:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  102166:	c9                   	leave  
  102167:	c3                   	ret    
  102168:	90                   	nop    
  102169:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

00102170 <iupdate>:

// Copy inode, which has changed, from memory to disk.
void
iupdate(struct inode *ip)
{
  102170:	55                   	push   %ebp
  102171:	89 e5                	mov    %esp,%ebp
  102173:	83 ec 28             	sub    $0x28,%esp
  struct buf *bp;
  struct dinode *dip;

  bp = bread(ip->dev, IBLOCK(ip->inum));
  102176:	8b 45 08             	mov    0x8(%ebp),%eax
  102179:	8b 40 04             	mov    0x4(%eax),%eax
  10217c:	c1 e8 03             	shr    $0x3,%eax
  10217f:	8d 50 02             	lea    0x2(%eax),%edx
  102182:	8b 45 08             	mov    0x8(%ebp),%eax
  102185:	8b 00                	mov    (%eax),%eax
  102187:	89 54 24 04          	mov    %edx,0x4(%esp)
  10218b:	89 04 24             	mov    %eax,(%esp)
  10218e:	e8 ed df ff ff       	call   100180 <bread>
  102193:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  dip = (struct dinode*)bp->data + ip->inum%IPB;
  102196:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  102199:	83 c0 18             	add    $0x18,%eax
  10219c:	89 c2                	mov    %eax,%edx
  10219e:	8b 45 08             	mov    0x8(%ebp),%eax
  1021a1:	8b 40 04             	mov    0x4(%eax),%eax
  1021a4:	83 e0 07             	and    $0x7,%eax
  1021a7:	c1 e0 06             	shl    $0x6,%eax
  1021aa:	8d 04 02             	lea    (%edx,%eax,1),%eax
  1021ad:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  dip->type = ip->type;
  1021b0:	8b 45 08             	mov    0x8(%ebp),%eax
  1021b3:	0f b7 50 10          	movzwl 0x10(%eax),%edx
  1021b7:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1021ba:	66 89 10             	mov    %dx,(%eax)
  dip->major = ip->major;
  1021bd:	8b 45 08             	mov    0x8(%ebp),%eax
  1021c0:	0f b7 50 12          	movzwl 0x12(%eax),%edx
  1021c4:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1021c7:	66 89 50 02          	mov    %dx,0x2(%eax)
  dip->minor = ip->minor;
  1021cb:	8b 45 08             	mov    0x8(%ebp),%eax
  1021ce:	0f b7 50 14          	movzwl 0x14(%eax),%edx
  1021d2:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1021d5:	66 89 50 04          	mov    %dx,0x4(%eax)
  dip->nlink = ip->nlink;
  1021d9:	8b 45 08             	mov    0x8(%ebp),%eax
  1021dc:	0f b7 50 16          	movzwl 0x16(%eax),%edx
  1021e0:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1021e3:	66 89 50 06          	mov    %dx,0x6(%eax)
  dip->size = ip->size;
  1021e7:	8b 45 08             	mov    0x8(%ebp),%eax
  1021ea:	8b 50 18             	mov    0x18(%eax),%edx
  1021ed:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1021f0:	89 50 08             	mov    %edx,0x8(%eax)
  memmove(dip->addrs, ip->addrs, sizeof(ip->addrs));
  1021f3:	8b 45 08             	mov    0x8(%ebp),%eax
  1021f6:	83 c0 1c             	add    $0x1c,%eax
  1021f9:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  1021fc:	83 c2 0c             	add    $0xc,%edx
  1021ff:	c7 44 24 08 34 00 00 	movl   $0x34,0x8(%esp)
  102206:	00 
  102207:	89 44 24 04          	mov    %eax,0x4(%esp)
  10220b:	89 14 24             	mov    %edx,(%esp)
  10220e:	e8 4d 3d 00 00       	call   105f60 <memmove>
  bwrite(bp);
  102213:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  102216:	89 04 24             	mov    %eax,(%esp)
  102219:	e8 a2 df ff ff       	call   1001c0 <bwrite>
  brelse(bp);
  10221e:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  102221:	89 04 24             	mov    %eax,(%esp)
  102224:	e8 d7 df ff ff       	call   100200 <brelse>
}
  102229:	c9                   	leave  
  10222a:	c3                   	ret    
  10222b:	90                   	nop    
  10222c:	8d 74 26 00          	lea    0x0(%esi),%esi

00102230 <bmap>:

// Inode contents
//
// The contents (data) associated with each inode is stored
// in a sequence of blocks on the disk.  The first NDIRECT blocks
// are listed in ip->addrs[].  The next NINDIRECT blocks are 
// listed in the block ip->addrs[INDIRECT].

// Return the disk block address of the nth block in inode ip.
// If there is no such block, alloc controls whether one is allocated.
static uint
bmap(struct inode *ip, uint bn, int alloc)
{
  102230:	55                   	push   %ebp
  102231:	89 e5                	mov    %esp,%ebp
  102233:	53                   	push   %ebx
  102234:	83 ec 24             	sub    $0x24,%esp
  uint addr, *a;
  struct buf *bp;

  if(bn < NDIRECT){
  102237:	83 7d 0c 0b          	cmpl   $0xb,0xc(%ebp)
  10223b:	77 4d                	ja     10228a <bmap+0x5a>
    if((addr = ip->addrs[bn]) == 0){
  10223d:	8b 45 0c             	mov    0xc(%ebp),%eax
  102240:	8b 55 08             	mov    0x8(%ebp),%edx
  102243:	8b 44 82 1c          	mov    0x1c(%edx,%eax,4),%eax
  102247:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
  10224a:	83 7d f0 00          	cmpl   $0x0,0xfffffff0(%ebp)
  10224e:	75 2f                	jne    10227f <bmap+0x4f>
      if(!alloc)
  102250:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  102254:	75 0c                	jne    102262 <bmap+0x32>
        return -1;
  102256:	c7 45 e8 ff ff ff ff 	movl   $0xffffffff,0xffffffe8(%ebp)
  10225d:	e9 08 01 00 00       	jmp    10236a <bmap+0x13a>
      ip->addrs[bn] = addr = balloc(ip->dev);
  102262:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  102265:	8b 45 08             	mov    0x8(%ebp),%eax
  102268:	8b 00                	mov    (%eax),%eax
  10226a:	89 04 24             	mov    %eax,(%esp)
  10226d:	e8 be f7 ff ff       	call   101a30 <balloc>
  102272:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
  102275:	8b 55 08             	mov    0x8(%ebp),%edx
  102278:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10227b:	89 44 9a 1c          	mov    %eax,0x1c(%edx,%ebx,4)
    }
    return addr;
  10227f:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  102282:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
  102285:	e9 e0 00 00 00       	jmp    10236a <bmap+0x13a>
  }
  bn -= NDIRECT;
  10228a:	83 6d 0c 0c          	subl   $0xc,0xc(%ebp)

  if(bn < NINDIRECT){
  10228e:	83 7d 0c 7f          	cmpl   $0x7f,0xc(%ebp)
  102292:	0f 87 c6 00 00 00    	ja     10235e <bmap+0x12e>
    // Load indirect block, allocating if necessary.
    if((addr = ip->addrs[INDIRECT]) == 0){
  102298:	8b 45 08             	mov    0x8(%ebp),%eax
  10229b:	8b 40 4c             	mov    0x4c(%eax),%eax
  10229e:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
  1022a1:	83 7d f0 00          	cmpl   $0x0,0xfffffff0(%ebp)
  1022a5:	75 2b                	jne    1022d2 <bmap+0xa2>
      if(!alloc)
  1022a7:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  1022ab:	75 0c                	jne    1022b9 <bmap+0x89>
        return -1;
  1022ad:	c7 45 e8 ff ff ff ff 	movl   $0xffffffff,0xffffffe8(%ebp)
  1022b4:	e9 b1 00 00 00       	jmp    10236a <bmap+0x13a>
      ip->addrs[INDIRECT] = addr = balloc(ip->dev);
  1022b9:	8b 45 08             	mov    0x8(%ebp),%eax
  1022bc:	8b 00                	mov    (%eax),%eax
  1022be:	89 04 24             	mov    %eax,(%esp)
  1022c1:	e8 6a f7 ff ff       	call   101a30 <balloc>
  1022c6:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
  1022c9:	8b 55 08             	mov    0x8(%ebp),%edx
  1022cc:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  1022cf:	89 42 4c             	mov    %eax,0x4c(%edx)
    }
    bp = bread(ip->dev, addr);
  1022d2:	8b 45 08             	mov    0x8(%ebp),%eax
  1022d5:	8b 10                	mov    (%eax),%edx
  1022d7:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  1022da:	89 44 24 04          	mov    %eax,0x4(%esp)
  1022de:	89 14 24             	mov    %edx,(%esp)
  1022e1:	e8 9a de ff ff       	call   100180 <bread>
  1022e6:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
    a = (uint*)bp->data;
  1022e9:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1022ec:	83 c0 18             	add    $0x18,%eax
  1022ef:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  
    if((addr = a[bn]) == 0){
  1022f2:	8b 45 0c             	mov    0xc(%ebp),%eax
  1022f5:	c1 e0 02             	shl    $0x2,%eax
  1022f8:	03 45 f4             	add    0xfffffff4(%ebp),%eax
  1022fb:	8b 00                	mov    (%eax),%eax
  1022fd:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
  102300:	83 7d f0 00          	cmpl   $0x0,0xfffffff0(%ebp)
  102304:	75 45                	jne    10234b <bmap+0x11b>
      if(!alloc){
  102306:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  10230a:	75 14                	jne    102320 <bmap+0xf0>
        brelse(bp);
  10230c:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10230f:	89 04 24             	mov    %eax,(%esp)
  102312:	e8 e9 de ff ff       	call   100200 <brelse>
        return -1;
  102317:	c7 45 e8 ff ff ff ff 	movl   $0xffffffff,0xffffffe8(%ebp)
  10231e:	eb 4a                	jmp    10236a <bmap+0x13a>
      }
      a[bn] = addr = balloc(ip->dev);
  102320:	8b 45 0c             	mov    0xc(%ebp),%eax
  102323:	c1 e0 02             	shl    $0x2,%eax
  102326:	89 c3                	mov    %eax,%ebx
  102328:	03 5d f4             	add    0xfffffff4(%ebp),%ebx
  10232b:	8b 45 08             	mov    0x8(%ebp),%eax
  10232e:	8b 00                	mov    (%eax),%eax
  102330:	89 04 24             	mov    %eax,(%esp)
  102333:	e8 f8 f6 ff ff       	call   101a30 <balloc>
  102338:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
  10233b:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10233e:	89 03                	mov    %eax,(%ebx)
      bwrite(bp);
  102340:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  102343:	89 04 24             	mov    %eax,(%esp)
  102346:	e8 75 de ff ff       	call   1001c0 <bwrite>
    }
    brelse(bp);
  10234b:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10234e:	89 04 24             	mov    %eax,(%esp)
  102351:	e8 aa de ff ff       	call   100200 <brelse>
    return addr;
  102356:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  102359:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
  10235c:	eb 0c                	jmp    10236a <bmap+0x13a>
  }

  panic("bmap: out of range");
  10235e:	c7 04 24 7d a4 11 00 	movl   $0x11a47d,(%esp)
  102365:	e8 96 ec ff ff       	call   101000 <panic>
  10236a:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
}
  10236d:	83 c4 24             	add    $0x24,%esp
  102370:	5b                   	pop    %ebx
  102371:	5d                   	pop    %ebp
  102372:	c3                   	ret    
  102373:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  102379:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00102380 <itrunc>:

// Truncate inode (discard contents).
static void
itrunc(struct inode *ip)
{
  102380:	55                   	push   %ebp
  102381:	89 e5                	mov    %esp,%ebp
  102383:	83 ec 18             	sub    $0x18,%esp
  int i, j;
  struct buf *bp;
  uint *a;

  for(i = 0; i < NDIRECT; i++){
  102386:	c7 45 f0 00 00 00 00 	movl   $0x0,0xfffffff0(%ebp)
  10238d:	eb 3b                	jmp    1023ca <itrunc+0x4a>
    if(ip->addrs[i]){
  10238f:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  102392:	8b 55 08             	mov    0x8(%ebp),%edx
  102395:	8b 44 82 1c          	mov    0x1c(%edx,%eax,4),%eax
  102399:	85 c0                	test   %eax,%eax
  10239b:	74 29                	je     1023c6 <itrunc+0x46>
      bfree(ip->dev, ip->addrs[i]);
  10239d:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
  1023a0:	8b 45 08             	mov    0x8(%ebp),%eax
  1023a3:	8b 54 90 1c          	mov    0x1c(%eax,%edx,4),%edx
  1023a7:	8b 45 08             	mov    0x8(%ebp),%eax
  1023aa:	8b 00                	mov    (%eax),%eax
  1023ac:	89 54 24 04          	mov    %edx,0x4(%esp)
  1023b0:	89 04 24             	mov    %eax,(%esp)
  1023b3:	e8 b8 f7 ff ff       	call   101b70 <bfree>
      ip->addrs[i] = 0;
  1023b8:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
  1023bb:	8b 45 08             	mov    0x8(%ebp),%eax
  1023be:	c7 44 90 1c 00 00 00 	movl   $0x0,0x1c(%eax,%edx,4)
  1023c5:	00 
  1023c6:	83 45 f0 01          	addl   $0x1,0xfffffff0(%ebp)
  1023ca:	83 7d f0 0b          	cmpl   $0xb,0xfffffff0(%ebp)
  1023ce:	7e bf                	jle    10238f <itrunc+0xf>
    }
  }
  
  if(ip->addrs[INDIRECT]){
  1023d0:	8b 45 08             	mov    0x8(%ebp),%eax
  1023d3:	8b 40 4c             	mov    0x4c(%eax),%eax
  1023d6:	85 c0                	test   %eax,%eax
  1023d8:	74 78                	je     102452 <itrunc+0xd2>
    bp = bread(ip->dev, ip->addrs[INDIRECT]);
  1023da:	8b 45 08             	mov    0x8(%ebp),%eax
  1023dd:	8b 50 4c             	mov    0x4c(%eax),%edx
  1023e0:	8b 45 08             	mov    0x8(%ebp),%eax
  1023e3:	8b 00                	mov    (%eax),%eax
  1023e5:	89 54 24 04          	mov    %edx,0x4(%esp)
  1023e9:	89 04 24             	mov    %eax,(%esp)
  1023ec:	e8 8f dd ff ff       	call   100180 <bread>
  1023f1:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
    a = (uint*)bp->data;
  1023f4:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1023f7:	83 c0 18             	add    $0x18,%eax
  1023fa:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
    for(j = 0; j < NINDIRECT; j++){
  1023fd:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
  102404:	eb 2f                	jmp    102435 <itrunc+0xb5>
      if(a[j])
  102406:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  102409:	c1 e0 02             	shl    $0x2,%eax
  10240c:	03 45 fc             	add    0xfffffffc(%ebp),%eax
  10240f:	8b 00                	mov    (%eax),%eax
  102411:	85 c0                	test   %eax,%eax
  102413:	74 1c                	je     102431 <itrunc+0xb1>
        bfree(ip->dev, a[j]);
  102415:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  102418:	c1 e0 02             	shl    $0x2,%eax
  10241b:	03 45 fc             	add    0xfffffffc(%ebp),%eax
  10241e:	8b 10                	mov    (%eax),%edx
  102420:	8b 45 08             	mov    0x8(%ebp),%eax
  102423:	8b 00                	mov    (%eax),%eax
  102425:	89 54 24 04          	mov    %edx,0x4(%esp)
  102429:	89 04 24             	mov    %eax,(%esp)
  10242c:	e8 3f f7 ff ff       	call   101b70 <bfree>
  102431:	83 45 f4 01          	addl   $0x1,0xfffffff4(%ebp)
  102435:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  102438:	83 f8 7f             	cmp    $0x7f,%eax
  10243b:	76 c9                	jbe    102406 <itrunc+0x86>
    }
    brelse(bp);
  10243d:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  102440:	89 04 24             	mov    %eax,(%esp)
  102443:	e8 b8 dd ff ff       	call   100200 <brelse>
    ip->addrs[INDIRECT] = 0;
  102448:	8b 45 08             	mov    0x8(%ebp),%eax
  10244b:	c7 40 4c 00 00 00 00 	movl   $0x0,0x4c(%eax)
  }

  ip->size = 0;
  102452:	8b 45 08             	mov    0x8(%ebp),%eax
  102455:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
  iupdate(ip);
  10245c:	8b 45 08             	mov    0x8(%ebp),%eax
  10245f:	89 04 24             	mov    %eax,(%esp)
  102462:	e8 09 fd ff ff       	call   102170 <iupdate>
}
  102467:	c9                   	leave  
  102468:	c3                   	ret    
  102469:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

00102470 <stati>:

// Copy stat information from inode.
void
stati(struct inode *ip, struct stat *st)
{
  102470:	55                   	push   %ebp
  102471:	89 e5                	mov    %esp,%ebp
  st->dev = ip->dev;
  102473:	8b 45 08             	mov    0x8(%ebp),%eax
  102476:	8b 00                	mov    (%eax),%eax
  102478:	89 c2                	mov    %eax,%edx
  10247a:	8b 45 0c             	mov    0xc(%ebp),%eax
  10247d:	89 10                	mov    %edx,(%eax)
  st->ino = ip->inum;
  10247f:	8b 45 08             	mov    0x8(%ebp),%eax
  102482:	8b 50 04             	mov    0x4(%eax),%edx
  102485:	8b 45 0c             	mov    0xc(%ebp),%eax
  102488:	89 50 04             	mov    %edx,0x4(%eax)
  st->type = ip->type;
  10248b:	8b 45 08             	mov    0x8(%ebp),%eax
  10248e:	0f b7 50 10          	movzwl 0x10(%eax),%edx
  102492:	8b 45 0c             	mov    0xc(%ebp),%eax
  102495:	66 89 50 08          	mov    %dx,0x8(%eax)
  st->nlink = ip->nlink;
  102499:	8b 45 08             	mov    0x8(%ebp),%eax
  10249c:	0f b7 50 16          	movzwl 0x16(%eax),%edx
  1024a0:	8b 45 0c             	mov    0xc(%ebp),%eax
  1024a3:	66 89 50 0a          	mov    %dx,0xa(%eax)
  st->size = ip->size;
  1024a7:	8b 45 08             	mov    0x8(%ebp),%eax
  1024aa:	8b 50 18             	mov    0x18(%eax),%edx
  1024ad:	8b 45 0c             	mov    0xc(%ebp),%eax
  1024b0:	89 50 0c             	mov    %edx,0xc(%eax)
}
  1024b3:	5d                   	pop    %ebp
  1024b4:	c3                   	ret    
  1024b5:	8d 74 26 00          	lea    0x0(%esi),%esi
  1024b9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

001024c0 <readi>:

// Read data from inode.
int
readi(struct inode *ip, char *dst, uint off, uint n)
{
  1024c0:	55                   	push   %ebp
  1024c1:	89 e5                	mov    %esp,%ebp
  1024c3:	53                   	push   %ebx
  1024c4:	83 ec 34             	sub    $0x34,%esp
  uint tot, m;
  struct buf *bp;

//  cprintf("XXX readi %d.%d\n", ip->dev, ip->inum);
  if(ip->type == T_DEV){
  1024c7:	8b 45 08             	mov    0x8(%ebp),%eax
  1024ca:	0f b7 40 10          	movzwl 0x10(%eax),%eax
  1024ce:	66 83 f8 03          	cmp    $0x3,%ax
  1024d2:	75 65                	jne    102539 <readi+0x79>
    if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].read)
  1024d4:	8b 45 08             	mov    0x8(%ebp),%eax
  1024d7:	0f b7 40 12          	movzwl 0x12(%eax),%eax
  1024db:	66 85 c0             	test   %ax,%ax
  1024de:	78 20                	js     102500 <readi+0x40>
  1024e0:	8b 45 08             	mov    0x8(%ebp),%eax
  1024e3:	0f b7 40 12          	movzwl 0x12(%eax),%eax
  1024e7:	66 83 f8 09          	cmp    $0x9,%ax
  1024eb:	7f 13                	jg     102500 <readi+0x40>
  1024ed:	8b 45 08             	mov    0x8(%ebp),%eax
  1024f0:	0f b7 40 12          	movzwl 0x12(%eax),%eax
  1024f4:	98                   	cwtl   
  1024f5:	8b 04 c5 80 bb 13 00 	mov    0x13bb80(,%eax,8),%eax
  1024fc:	85 c0                	test   %eax,%eax
  1024fe:	75 0c                	jne    10250c <readi+0x4c>
      return -1;
  102500:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,0xffffffe4(%ebp)
  102507:	e9 37 01 00 00       	jmp    102643 <readi+0x183>
    return devsw[ip->major].read(ip, dst, n);
  10250c:	8b 45 08             	mov    0x8(%ebp),%eax
  10250f:	0f b7 40 12          	movzwl 0x12(%eax),%eax
  102513:	98                   	cwtl   
  102514:	8b 14 c5 80 bb 13 00 	mov    0x13bb80(,%eax,8),%edx
  10251b:	8b 45 14             	mov    0x14(%ebp),%eax
  10251e:	89 44 24 08          	mov    %eax,0x8(%esp)
  102522:	8b 45 0c             	mov    0xc(%ebp),%eax
  102525:	89 44 24 04          	mov    %eax,0x4(%esp)
  102529:	8b 45 08             	mov    0x8(%ebp),%eax
  10252c:	89 04 24             	mov    %eax,(%esp)
  10252f:	ff d2                	call   *%edx
  102531:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
  102534:	e9 0a 01 00 00       	jmp    102643 <readi+0x183>
  }

  if(off > ip->size || off + n < off)
  102539:	8b 45 08             	mov    0x8(%ebp),%eax
  10253c:	8b 40 18             	mov    0x18(%eax),%eax
  10253f:	3b 45 10             	cmp    0x10(%ebp),%eax
  102542:	72 0b                	jb     10254f <readi+0x8f>
  102544:	8b 45 14             	mov    0x14(%ebp),%eax
  102547:	03 45 10             	add    0x10(%ebp),%eax
  10254a:	3b 45 10             	cmp    0x10(%ebp),%eax
  10254d:	73 0c                	jae    10255b <readi+0x9b>
    return -1;
  10254f:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,0xffffffe4(%ebp)
  102556:	e9 e8 00 00 00       	jmp    102643 <readi+0x183>
  if(off + n > ip->size)
  10255b:	8b 45 14             	mov    0x14(%ebp),%eax
  10255e:	8b 55 10             	mov    0x10(%ebp),%edx
  102561:	01 c2                	add    %eax,%edx
  102563:	8b 45 08             	mov    0x8(%ebp),%eax
  102566:	8b 40 18             	mov    0x18(%eax),%eax
  102569:	39 c2                	cmp    %eax,%edx
  10256b:	76 0c                	jbe    102579 <readi+0xb9>
    n = ip->size - off;
  10256d:	8b 45 08             	mov    0x8(%ebp),%eax
  102570:	8b 40 18             	mov    0x18(%eax),%eax
  102573:	2b 45 10             	sub    0x10(%ebp),%eax
  102576:	89 45 14             	mov    %eax,0x14(%ebp)

  for(tot=0; tot<n; tot+=m, off+=m, dst+=m){
  102579:	c7 45 f0 00 00 00 00 	movl   $0x0,0xfffffff0(%ebp)
  102580:	e9 ac 00 00 00       	jmp    102631 <readi+0x171>
    bp = bread(ip->dev, bmap(ip, off/BSIZE, 0));
  102585:	8b 45 10             	mov    0x10(%ebp),%eax
  102588:	c1 e8 09             	shr    $0x9,%eax
  10258b:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  102592:	00 
  102593:	89 44 24 04          	mov    %eax,0x4(%esp)
  102597:	8b 45 08             	mov    0x8(%ebp),%eax
  10259a:	89 04 24             	mov    %eax,(%esp)
  10259d:	e8 8e fc ff ff       	call   102230 <bmap>
  1025a2:	89 c2                	mov    %eax,%edx
  1025a4:	8b 45 08             	mov    0x8(%ebp),%eax
  1025a7:	8b 00                	mov    (%eax),%eax
  1025a9:	89 54 24 04          	mov    %edx,0x4(%esp)
  1025ad:	89 04 24             	mov    %eax,(%esp)
  1025b0:	e8 cb db ff ff       	call   100180 <bread>
  1025b5:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
    m = min(n - tot, BSIZE - off%BSIZE);
  1025b8:	8b 55 10             	mov    0x10(%ebp),%edx
  1025bb:	81 e2 ff 01 00 00    	and    $0x1ff,%edx
  1025c1:	b8 00 02 00 00       	mov    $0x200,%eax
  1025c6:	89 c1                	mov    %eax,%ecx
  1025c8:	29 d1                	sub    %edx,%ecx
  1025ca:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
  1025cd:	8b 45 14             	mov    0x14(%ebp),%eax
  1025d0:	89 c3                	mov    %eax,%ebx
  1025d2:	29 d3                	sub    %edx,%ebx
  1025d4:	89 5d e8             	mov    %ebx,0xffffffe8(%ebp)
  1025d7:	89 4d e0             	mov    %ecx,0xffffffe0(%ebp)
  1025da:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  1025dd:	39 45 e0             	cmp    %eax,0xffffffe0(%ebp)
  1025e0:	76 06                	jbe    1025e8 <readi+0x128>
  1025e2:	8b 5d e8             	mov    0xffffffe8(%ebp),%ebx
  1025e5:	89 5d e0             	mov    %ebx,0xffffffe0(%ebp)
  1025e8:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  1025eb:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
    memmove(dst, bp->data + off%BSIZE, m);
  1025ee:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  1025f1:	83 c2 18             	add    $0x18,%edx
  1025f4:	8b 45 10             	mov    0x10(%ebp),%eax
  1025f7:	25 ff 01 00 00       	and    $0x1ff,%eax
  1025fc:	01 c2                	add    %eax,%edx
  1025fe:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  102601:	89 44 24 08          	mov    %eax,0x8(%esp)
  102605:	89 54 24 04          	mov    %edx,0x4(%esp)
  102609:	8b 45 0c             	mov    0xc(%ebp),%eax
  10260c:	89 04 24             	mov    %eax,(%esp)
  10260f:	e8 4c 39 00 00       	call   105f60 <memmove>
    brelse(bp);
  102614:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  102617:	89 04 24             	mov    %eax,(%esp)
  10261a:	e8 e1 db ff ff       	call   100200 <brelse>
  10261f:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  102622:	01 45 f0             	add    %eax,0xfffffff0(%ebp)
  102625:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  102628:	01 45 10             	add    %eax,0x10(%ebp)
  10262b:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10262e:	01 45 0c             	add    %eax,0xc(%ebp)
  102631:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  102634:	3b 45 14             	cmp    0x14(%ebp),%eax
  102637:	0f 82 48 ff ff ff    	jb     102585 <readi+0xc5>
  }
  return n;
  10263d:	8b 5d 14             	mov    0x14(%ebp),%ebx
  102640:	89 5d e4             	mov    %ebx,0xffffffe4(%ebp)
  102643:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
}
  102646:	83 c4 34             	add    $0x34,%esp
  102649:	5b                   	pop    %ebx
  10264a:	5d                   	pop    %ebp
  10264b:	c3                   	ret    
  10264c:	8d 74 26 00          	lea    0x0(%esi),%esi

00102650 <writei>:

// Write data to inode.
int
writei(struct inode *ip, char *src, uint off, uint n)
{
  102650:	55                   	push   %ebp
  102651:	89 e5                	mov    %esp,%ebp
  102653:	53                   	push   %ebx
  102654:	83 ec 34             	sub    $0x34,%esp
  uint tot, m;
  struct buf *bp;

  if(ip->type == T_DEV){
  102657:	8b 45 08             	mov    0x8(%ebp),%eax
  10265a:	0f b7 40 10          	movzwl 0x10(%eax),%eax
  10265e:	66 83 f8 03          	cmp    $0x3,%ax
  102662:	75 65                	jne    1026c9 <writei+0x79>
    if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].write)
  102664:	8b 45 08             	mov    0x8(%ebp),%eax
  102667:	0f b7 40 12          	movzwl 0x12(%eax),%eax
  10266b:	66 85 c0             	test   %ax,%ax
  10266e:	78 20                	js     102690 <writei+0x40>
  102670:	8b 45 08             	mov    0x8(%ebp),%eax
  102673:	0f b7 40 12          	movzwl 0x12(%eax),%eax
  102677:	66 83 f8 09          	cmp    $0x9,%ax
  10267b:	7f 13                	jg     102690 <writei+0x40>
  10267d:	8b 45 08             	mov    0x8(%ebp),%eax
  102680:	0f b7 40 12          	movzwl 0x12(%eax),%eax
  102684:	98                   	cwtl   
  102685:	8b 04 c5 84 bb 13 00 	mov    0x13bb84(,%eax,8),%eax
  10268c:	85 c0                	test   %eax,%eax
  10268e:	75 0c                	jne    10269c <writei+0x4c>
      return -1;
  102690:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,0xffffffe4(%ebp)
  102697:	e9 56 01 00 00       	jmp    1027f2 <writei+0x1a2>
    return devsw[ip->major].write(ip, src, n);
  10269c:	8b 45 08             	mov    0x8(%ebp),%eax
  10269f:	0f b7 40 12          	movzwl 0x12(%eax),%eax
  1026a3:	98                   	cwtl   
  1026a4:	8b 14 c5 84 bb 13 00 	mov    0x13bb84(,%eax,8),%edx
  1026ab:	8b 45 14             	mov    0x14(%ebp),%eax
  1026ae:	89 44 24 08          	mov    %eax,0x8(%esp)
  1026b2:	8b 45 0c             	mov    0xc(%ebp),%eax
  1026b5:	89 44 24 04          	mov    %eax,0x4(%esp)
  1026b9:	8b 45 08             	mov    0x8(%ebp),%eax
  1026bc:	89 04 24             	mov    %eax,(%esp)
  1026bf:	ff d2                	call   *%edx
  1026c1:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
  1026c4:	e9 29 01 00 00       	jmp    1027f2 <writei+0x1a2>
  }

  if(off + n < off)
  1026c9:	8b 45 14             	mov    0x14(%ebp),%eax
  1026cc:	03 45 10             	add    0x10(%ebp),%eax
  1026cf:	3b 45 10             	cmp    0x10(%ebp),%eax
  1026d2:	73 0c                	jae    1026e0 <writei+0x90>
    return -1;
  1026d4:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,0xffffffe4(%ebp)
  1026db:	e9 12 01 00 00       	jmp    1027f2 <writei+0x1a2>
  if(off + n > MAXFILE*BSIZE)
  1026e0:	8b 45 14             	mov    0x14(%ebp),%eax
  1026e3:	03 45 10             	add    0x10(%ebp),%eax
  1026e6:	3d 00 18 01 00       	cmp    $0x11800,%eax
  1026eb:	76 0b                	jbe    1026f8 <writei+0xa8>
    n = MAXFILE*BSIZE - off;
  1026ed:	b8 00 18 01 00       	mov    $0x11800,%eax
  1026f2:	2b 45 10             	sub    0x10(%ebp),%eax
  1026f5:	89 45 14             	mov    %eax,0x14(%ebp)

  for(tot=0; tot<n; tot+=m, off+=m, src+=m){
  1026f8:	c7 45 f0 00 00 00 00 	movl   $0x0,0xfffffff0(%ebp)
  1026ff:	e9 b7 00 00 00       	jmp    1027bb <writei+0x16b>
    bp = bread(ip->dev, bmap(ip, off/BSIZE, 1));
  102704:	8b 45 10             	mov    0x10(%ebp),%eax
  102707:	c1 e8 09             	shr    $0x9,%eax
  10270a:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  102711:	00 
  102712:	89 44 24 04          	mov    %eax,0x4(%esp)
  102716:	8b 45 08             	mov    0x8(%ebp),%eax
  102719:	89 04 24             	mov    %eax,(%esp)
  10271c:	e8 0f fb ff ff       	call   102230 <bmap>
  102721:	89 c2                	mov    %eax,%edx
  102723:	8b 45 08             	mov    0x8(%ebp),%eax
  102726:	8b 00                	mov    (%eax),%eax
  102728:	89 54 24 04          	mov    %edx,0x4(%esp)
  10272c:	89 04 24             	mov    %eax,(%esp)
  10272f:	e8 4c da ff ff       	call   100180 <bread>
  102734:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
    m = min(n - tot, BSIZE - off%BSIZE);
  102737:	8b 55 10             	mov    0x10(%ebp),%edx
  10273a:	81 e2 ff 01 00 00    	and    $0x1ff,%edx
  102740:	b8 00 02 00 00       	mov    $0x200,%eax
  102745:	89 c1                	mov    %eax,%ecx
  102747:	29 d1                	sub    %edx,%ecx
  102749:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
  10274c:	8b 45 14             	mov    0x14(%ebp),%eax
  10274f:	89 c3                	mov    %eax,%ebx
  102751:	29 d3                	sub    %edx,%ebx
  102753:	89 5d e8             	mov    %ebx,0xffffffe8(%ebp)
  102756:	89 4d e0             	mov    %ecx,0xffffffe0(%ebp)
  102759:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  10275c:	39 45 e0             	cmp    %eax,0xffffffe0(%ebp)
  10275f:	76 06                	jbe    102767 <writei+0x117>
  102761:	8b 5d e8             	mov    0xffffffe8(%ebp),%ebx
  102764:	89 5d e0             	mov    %ebx,0xffffffe0(%ebp)
  102767:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  10276a:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
    memmove(bp->data + off%BSIZE, src, m);
  10276d:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  102770:	83 c2 18             	add    $0x18,%edx
  102773:	8b 45 10             	mov    0x10(%ebp),%eax
  102776:	25 ff 01 00 00       	and    $0x1ff,%eax
  10277b:	01 c2                	add    %eax,%edx
  10277d:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  102780:	89 44 24 08          	mov    %eax,0x8(%esp)
  102784:	8b 45 0c             	mov    0xc(%ebp),%eax
  102787:	89 44 24 04          	mov    %eax,0x4(%esp)
  10278b:	89 14 24             	mov    %edx,(%esp)
  10278e:	e8 cd 37 00 00       	call   105f60 <memmove>
    bwrite(bp);
  102793:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  102796:	89 04 24             	mov    %eax,(%esp)
  102799:	e8 22 da ff ff       	call   1001c0 <bwrite>
    brelse(bp);
  10279e:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1027a1:	89 04 24             	mov    %eax,(%esp)
  1027a4:	e8 57 da ff ff       	call   100200 <brelse>
  1027a9:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  1027ac:	01 45 f0             	add    %eax,0xfffffff0(%ebp)
  1027af:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  1027b2:	01 45 10             	add    %eax,0x10(%ebp)
  1027b5:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  1027b8:	01 45 0c             	add    %eax,0xc(%ebp)
  1027bb:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  1027be:	3b 45 14             	cmp    0x14(%ebp),%eax
  1027c1:	0f 82 3d ff ff ff    	jb     102704 <writei+0xb4>
  }

  if(n > 0 && off > ip->size){
  1027c7:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
  1027cb:	74 1f                	je     1027ec <writei+0x19c>
  1027cd:	8b 45 08             	mov    0x8(%ebp),%eax
  1027d0:	8b 40 18             	mov    0x18(%eax),%eax
  1027d3:	3b 45 10             	cmp    0x10(%ebp),%eax
  1027d6:	73 14                	jae    1027ec <writei+0x19c>
    ip->size = off;
  1027d8:	8b 45 08             	mov    0x8(%ebp),%eax
  1027db:	8b 55 10             	mov    0x10(%ebp),%edx
  1027de:	89 50 18             	mov    %edx,0x18(%eax)
    iupdate(ip);
  1027e1:	8b 45 08             	mov    0x8(%ebp),%eax
  1027e4:	89 04 24             	mov    %eax,(%esp)
  1027e7:	e8 84 f9 ff ff       	call   102170 <iupdate>
  }
  return n;
  1027ec:	8b 5d 14             	mov    0x14(%ebp),%ebx
  1027ef:	89 5d e4             	mov    %ebx,0xffffffe4(%ebp)
  1027f2:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
}
  1027f5:	83 c4 34             	add    $0x34,%esp
  1027f8:	5b                   	pop    %ebx
  1027f9:	5d                   	pop    %ebp
  1027fa:	c3                   	ret    
  1027fb:	90                   	nop    
  1027fc:	8d 74 26 00          	lea    0x0(%esi),%esi

00102800 <namecmp>:

// Directories

int
namecmp(const char *s, const char *t)
{
  102800:	55                   	push   %ebp
  102801:	89 e5                	mov    %esp,%ebp
  102803:	83 ec 18             	sub    $0x18,%esp
  return strncmp(s, t, DIRSIZ);
  102806:	c7 44 24 08 0e 00 00 	movl   $0xe,0x8(%esp)
  10280d:	00 
  10280e:	8b 45 0c             	mov    0xc(%ebp),%eax
  102811:	89 44 24 04          	mov    %eax,0x4(%esp)
  102815:	8b 45 08             	mov    0x8(%ebp),%eax
  102818:	89 04 24             	mov    %eax,(%esp)
  10281b:	e8 c0 37 00 00       	call   105fe0 <strncmp>
}
  102820:	c9                   	leave  
  102821:	c3                   	ret    
  102822:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi
  102829:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00102830 <dirlookup>:

// Look for a directory entry in a directory.
// If found, set *poff to byte offset of entry.
// Caller must have already locked dp.
struct inode*
dirlookup(struct inode *dp, char *name, uint *poff)
{
  102830:	55                   	push   %ebp
  102831:	89 e5                	mov    %esp,%ebp
  102833:	83 ec 28             	sub    $0x28,%esp
  uint off, inum;
  struct buf *bp;
  struct dirent *de;

  if(dp->type != T_DIR)
  102836:	8b 45 08             	mov    0x8(%ebp),%eax
  102839:	0f b7 40 10          	movzwl 0x10(%eax),%eax
  10283d:	66 83 f8 01          	cmp    $0x1,%ax
  102841:	74 0c                	je     10284f <dirlookup+0x1f>
    panic("dirlookup not DIR");
  102843:	c7 04 24 90 a4 11 00 	movl   $0x11a490,(%esp)
  10284a:	e8 b1 e7 ff ff       	call   101000 <panic>

  for(off = 0; off < dp->size; off += BSIZE){
  10284f:	c7 45 f0 00 00 00 00 	movl   $0x0,0xfffffff0(%ebp)
  102856:	e9 e0 00 00 00       	jmp    10293b <dirlookup+0x10b>
    bp = bread(dp->dev, bmap(dp, off / BSIZE, 0));
  10285b:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10285e:	c1 e8 09             	shr    $0x9,%eax
  102861:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  102868:	00 
  102869:	89 44 24 04          	mov    %eax,0x4(%esp)
  10286d:	8b 45 08             	mov    0x8(%ebp),%eax
  102870:	89 04 24             	mov    %eax,(%esp)
  102873:	e8 b8 f9 ff ff       	call   102230 <bmap>
  102878:	89 c2                	mov    %eax,%edx
  10287a:	8b 45 08             	mov    0x8(%ebp),%eax
  10287d:	8b 00                	mov    (%eax),%eax
  10287f:	89 54 24 04          	mov    %edx,0x4(%esp)
  102883:	89 04 24             	mov    %eax,(%esp)
  102886:	e8 f5 d8 ff ff       	call   100180 <bread>
  10288b:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
    for(de = (struct dirent*)bp->data;
  10288e:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  102891:	83 c0 18             	add    $0x18,%eax
  102894:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
        de < (struct dirent*)(bp->data + BSIZE);
  102897:	eb 7c                	jmp    102915 <dirlookup+0xe5>
        de++){
      if(de->inum == 0)
  102899:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10289c:	0f b7 00             	movzwl (%eax),%eax
  10289f:	66 85 c0             	test   %ax,%ax
  1028a2:	74 6d                	je     102911 <dirlookup+0xe1>
        continue;
      if(namecmp(name, de->name) == 0){
  1028a4:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1028a7:	83 c0 02             	add    $0x2,%eax
  1028aa:	89 44 24 04          	mov    %eax,0x4(%esp)
  1028ae:	8b 45 0c             	mov    0xc(%ebp),%eax
  1028b1:	89 04 24             	mov    %eax,(%esp)
  1028b4:	e8 47 ff ff ff       	call   102800 <namecmp>
  1028b9:	85 c0                	test   %eax,%eax
  1028bb:	75 54                	jne    102911 <dirlookup+0xe1>
        // entry matches path element
        if(poff)
  1028bd:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  1028c1:	74 1e                	je     1028e1 <dirlookup+0xb1>
          *poff = off + (uchar*)de - bp->data;
  1028c3:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  1028c6:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  1028c9:	8d 04 02             	lea    (%edx,%eax,1),%eax
  1028cc:	89 c2                	mov    %eax,%edx
  1028ce:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1028d1:	83 c0 18             	add    $0x18,%eax
  1028d4:	89 d1                	mov    %edx,%ecx
  1028d6:	29 c1                	sub    %eax,%ecx
  1028d8:	89 c8                	mov    %ecx,%eax
  1028da:	89 c2                	mov    %eax,%edx
  1028dc:	8b 45 10             	mov    0x10(%ebp),%eax
  1028df:	89 10                	mov    %edx,(%eax)
        inum = de->inum;
  1028e1:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1028e4:	0f b7 00             	movzwl (%eax),%eax
  1028e7:	0f b7 c0             	movzwl %ax,%eax
  1028ea:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
        brelse(bp);
  1028ed:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1028f0:	89 04 24             	mov    %eax,(%esp)
  1028f3:	e8 08 d9 ff ff       	call   100200 <brelse>
        return iget(dp->dev, inum);
  1028f8:	8b 45 08             	mov    0x8(%ebp),%eax
  1028fb:	8b 10                	mov    (%eax),%edx
  1028fd:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  102900:	89 44 24 04          	mov    %eax,0x4(%esp)
  102904:	89 14 24             	mov    %edx,(%esp)
  102907:	e8 84 f3 ff ff       	call   101c90 <iget>
  10290c:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  10290f:	eb 40                	jmp    102951 <dirlookup+0x121>
  102911:	83 45 fc 10          	addl   $0x10,0xfffffffc(%ebp)
  102915:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  102918:	83 c0 18             	add    $0x18,%eax
  10291b:	05 00 02 00 00       	add    $0x200,%eax
  102920:	3b 45 fc             	cmp    0xfffffffc(%ebp),%eax
  102923:	0f 87 70 ff ff ff    	ja     102899 <dirlookup+0x69>
      }
    }
    brelse(bp);
  102929:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10292c:	89 04 24             	mov    %eax,(%esp)
  10292f:	e8 cc d8 ff ff       	call   100200 <brelse>
  102934:	81 45 f0 00 02 00 00 	addl   $0x200,0xfffffff0(%ebp)
  10293b:	8b 45 08             	mov    0x8(%ebp),%eax
  10293e:	8b 40 18             	mov    0x18(%eax),%eax
  102941:	3b 45 f0             	cmp    0xfffffff0(%ebp),%eax
  102944:	0f 87 11 ff ff ff    	ja     10285b <dirlookup+0x2b>
  }
  return 0;
  10294a:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  102951:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  102954:	c9                   	leave  
  102955:	c3                   	ret    
  102956:	8d 76 00             	lea    0x0(%esi),%esi
  102959:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00102960 <dirlink>:

// Write a new directory entry (name, ino) into the directory dp.
int
dirlink(struct inode *dp, char *name, uint ino)
{
  102960:	55                   	push   %ebp
  102961:	89 e5                	mov    %esp,%ebp
  102963:	83 ec 38             	sub    $0x38,%esp
  int off;
  struct dirent de;
  struct inode *ip;

  // Check that name is not present.
  if((ip = dirlookup(dp, name, 0)) != 0){
  102966:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  10296d:	00 
  10296e:	8b 45 0c             	mov    0xc(%ebp),%eax
  102971:	89 44 24 04          	mov    %eax,0x4(%esp)
  102975:	8b 45 08             	mov    0x8(%ebp),%eax
  102978:	89 04 24             	mov    %eax,(%esp)
  10297b:	e8 b0 fe ff ff       	call   102830 <dirlookup>
  102980:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  102983:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  102987:	74 17                	je     1029a0 <dirlink+0x40>
    iput(ip);
  102989:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10298c:	89 04 24             	mov    %eax,(%esp)
  10298f:	e8 ec f5 ff ff       	call   101f80 <iput>
    return -1;
  102994:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,0xffffffdc(%ebp)
  10299b:	e9 b7 00 00 00       	jmp    102a57 <dirlink+0xf7>
  }

  // Look for an empty dirent.
  for(off = 0; off < dp->size; off += sizeof(de)){
  1029a0:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)
  1029a7:	eb 44                	jmp    1029ed <dirlink+0x8d>
    if(readi(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
  1029a9:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1029ac:	8d 55 e8             	lea    0xffffffe8(%ebp),%edx
  1029af:	c7 44 24 0c 10 00 00 	movl   $0x10,0xc(%esp)
  1029b6:	00 
  1029b7:	89 44 24 08          	mov    %eax,0x8(%esp)
  1029bb:	89 54 24 04          	mov    %edx,0x4(%esp)
  1029bf:	8b 45 08             	mov    0x8(%ebp),%eax
  1029c2:	89 04 24             	mov    %eax,(%esp)
  1029c5:	e8 f6 fa ff ff       	call   1024c0 <readi>
  1029ca:	83 f8 10             	cmp    $0x10,%eax
  1029cd:	74 0c                	je     1029db <dirlink+0x7b>
      panic("dirlink read");
  1029cf:	c7 04 24 a2 a4 11 00 	movl   $0x11a4a2,(%esp)
  1029d6:	e8 25 e6 ff ff       	call   101000 <panic>
    if(de.inum == 0)
  1029db:	0f b7 45 e8          	movzwl 0xffffffe8(%ebp),%eax
  1029df:	66 85 c0             	test   %ax,%ax
  1029e2:	74 16                	je     1029fa <dirlink+0x9a>
  1029e4:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1029e7:	83 c0 10             	add    $0x10,%eax
  1029ea:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  1029ed:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1029f0:	8b 55 08             	mov    0x8(%ebp),%edx
  1029f3:	8b 52 18             	mov    0x18(%edx),%edx
  1029f6:	39 d0                	cmp    %edx,%eax
  1029f8:	72 af                	jb     1029a9 <dirlink+0x49>
      break;
  }

  strncpy(de.name, name, DIRSIZ);
  1029fa:	c7 44 24 08 0e 00 00 	movl   $0xe,0x8(%esp)
  102a01:	00 
  102a02:	8b 45 0c             	mov    0xc(%ebp),%eax
  102a05:	89 44 24 04          	mov    %eax,0x4(%esp)
  102a09:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
  102a0c:	83 c0 02             	add    $0x2,%eax
  102a0f:	89 04 24             	mov    %eax,(%esp)
  102a12:	e8 39 36 00 00       	call   106050 <strncpy>
  de.inum = ino;
  102a17:	8b 45 10             	mov    0x10(%ebp),%eax
  102a1a:	66 89 45 e8          	mov    %ax,0xffffffe8(%ebp)
  if(writei(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
  102a1e:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  102a21:	8d 55 e8             	lea    0xffffffe8(%ebp),%edx
  102a24:	c7 44 24 0c 10 00 00 	movl   $0x10,0xc(%esp)
  102a2b:	00 
  102a2c:	89 44 24 08          	mov    %eax,0x8(%esp)
  102a30:	89 54 24 04          	mov    %edx,0x4(%esp)
  102a34:	8b 45 08             	mov    0x8(%ebp),%eax
  102a37:	89 04 24             	mov    %eax,(%esp)
  102a3a:	e8 11 fc ff ff       	call   102650 <writei>
  102a3f:	83 f8 10             	cmp    $0x10,%eax
  102a42:	74 0c                	je     102a50 <dirlink+0xf0>
    panic("dirlink");
  102a44:	c7 04 24 af a4 11 00 	movl   $0x11a4af,(%esp)
  102a4b:	e8 b0 e5 ff ff       	call   101000 <panic>
  
  return 0;
  102a50:	c7 45 dc 00 00 00 00 	movl   $0x0,0xffffffdc(%ebp)
  102a57:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
}
  102a5a:	c9                   	leave  
  102a5b:	c3                   	ret    
  102a5c:	8d 74 26 00          	lea    0x0(%esi),%esi

00102a60 <skipelem>:

// Paths

// Copy the next path element from path into name.
// Return a pointer to the element following the copied one.
// The returned path has no leading slashes,
// so the caller can check *path=='\0' to see if the name is the last one.
// If no name to remove, return 0.
//
// Examples:
//   skipelem("a/bb/c", name) = "bb/c", setting name = "a"
//   skipelem("///a//bb", name) = "bb", setting name = "a"
//   skipelem("", name) = skipelem("////", name) = 0
//
static char*
skipelem(char *path, char *name)
{
  102a60:	55                   	push   %ebp
  102a61:	89 e5                	mov    %esp,%ebp
  102a63:	83 ec 28             	sub    $0x28,%esp
  char *s;
  int len;

  while(*path == '/')
  102a66:	eb 04                	jmp    102a6c <skipelem+0xc>
    path++;
  102a68:	83 45 08 01          	addl   $0x1,0x8(%ebp)
  102a6c:	8b 45 08             	mov    0x8(%ebp),%eax
  102a6f:	0f b6 00             	movzbl (%eax),%eax
  102a72:	3c 2f                	cmp    $0x2f,%al
  102a74:	74 f2                	je     102a68 <skipelem+0x8>
  if(*path == 0)
  102a76:	8b 45 08             	mov    0x8(%ebp),%eax
  102a79:	0f b6 00             	movzbl (%eax),%eax
  102a7c:	84 c0                	test   %al,%al
  102a7e:	75 0c                	jne    102a8c <skipelem+0x2c>
    return 0;
  102a80:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  102a87:	e9 85 00 00 00       	jmp    102b11 <skipelem+0xb1>
  s = path;
  102a8c:	8b 45 08             	mov    0x8(%ebp),%eax
  102a8f:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  while(*path != '/' && *path != 0)
  102a92:	eb 04                	jmp    102a98 <skipelem+0x38>
    path++;
  102a94:	83 45 08 01          	addl   $0x1,0x8(%ebp)
  102a98:	8b 45 08             	mov    0x8(%ebp),%eax
  102a9b:	0f b6 00             	movzbl (%eax),%eax
  102a9e:	3c 2f                	cmp    $0x2f,%al
  102aa0:	74 0a                	je     102aac <skipelem+0x4c>
  102aa2:	8b 45 08             	mov    0x8(%ebp),%eax
  102aa5:	0f b6 00             	movzbl (%eax),%eax
  102aa8:	84 c0                	test   %al,%al
  102aaa:	75 e8                	jne    102a94 <skipelem+0x34>
  len = path - s;
  102aac:	8b 45 08             	mov    0x8(%ebp),%eax
  102aaf:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  102ab2:	29 d0                	sub    %edx,%eax
  102ab4:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  if(len >= DIRSIZ)
  102ab7:	83 7d fc 0d          	cmpl   $0xd,0xfffffffc(%ebp)
  102abb:	7e 1c                	jle    102ad9 <skipelem+0x79>
    memmove(name, s, DIRSIZ);
  102abd:	c7 44 24 08 0e 00 00 	movl   $0xe,0x8(%esp)
  102ac4:	00 
  102ac5:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  102ac8:	89 44 24 04          	mov    %eax,0x4(%esp)
  102acc:	8b 45 0c             	mov    0xc(%ebp),%eax
  102acf:	89 04 24             	mov    %eax,(%esp)
  102ad2:	e8 89 34 00 00       	call   105f60 <memmove>
  102ad7:	eb 28                	jmp    102b01 <skipelem+0xa1>
  else {
    memmove(name, s, len);
  102ad9:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  102adc:	89 44 24 08          	mov    %eax,0x8(%esp)
  102ae0:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  102ae3:	89 44 24 04          	mov    %eax,0x4(%esp)
  102ae7:	8b 45 0c             	mov    0xc(%ebp),%eax
  102aea:	89 04 24             	mov    %eax,(%esp)
  102aed:	e8 6e 34 00 00       	call   105f60 <memmove>
    name[len] = 0;
  102af2:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  102af5:	03 45 0c             	add    0xc(%ebp),%eax
  102af8:	c6 00 00             	movb   $0x0,(%eax)
  }
  while(*path == '/')
  102afb:	eb 04                	jmp    102b01 <skipelem+0xa1>
    path++;
  102afd:	83 45 08 01          	addl   $0x1,0x8(%ebp)
  102b01:	8b 45 08             	mov    0x8(%ebp),%eax
  102b04:	0f b6 00             	movzbl (%eax),%eax
  102b07:	3c 2f                	cmp    $0x2f,%al
  102b09:	74 f2                	je     102afd <skipelem+0x9d>
  return path;
  102b0b:	8b 45 08             	mov    0x8(%ebp),%eax
  102b0e:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  102b11:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  102b14:	c9                   	leave  
  102b15:	c3                   	ret    
  102b16:	8d 76 00             	lea    0x0(%esi),%esi
  102b19:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00102b20 <_namei>:

// Look up and return the inode for a path name.
// If parent != 0, return the inode for the parent and copy the final
// path element into name, which must have room for DIRSIZ bytes.
static struct inode*
_namei(char *path, int parent, char *name)
{
  102b20:	55                   	push   %ebp
  102b21:	89 e5                	mov    %esp,%ebp
  102b23:	83 ec 28             	sub    $0x28,%esp
  struct inode *ip, *next;

//  cprintf("XXX _namei %s\n", path);
  if(*path == '/')
  102b26:	8b 45 08             	mov    0x8(%ebp),%eax
  102b29:	0f b6 00             	movzbl (%eax),%eax
  102b2c:	3c 2f                	cmp    $0x2f,%al
  102b2e:	75 1c                	jne    102b4c <_namei+0x2c>
    ip = iget(ROOTDEV, 1);
  102b30:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  102b37:	00 
  102b38:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  102b3f:	e8 4c f1 ff ff       	call   101c90 <iget>
  102b44:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  102b47:	e9 bc 00 00 00       	jmp    102c08 <_namei+0xe8>
  else
    ip = idup(cp->cwd);
  102b4c:	e8 3f 0d 00 00       	call   103890 <cpu>
  102b51:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  102b58:	8b 40 60             	mov    0x60(%eax),%eax
  102b5b:	89 04 24             	mov    %eax,(%esp)
  102b5e:	e8 0d f2 ff ff       	call   101d70 <idup>
  102b63:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)

  while((path = skipelem(path, name)) != 0){
  102b66:	e9 9d 00 00 00       	jmp    102c08 <_namei+0xe8>
//    cprintf("XXX ready to ilock\n");
    ilock(ip);
  102b6b:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  102b6e:	89 04 24             	mov    %eax,(%esp)
  102b71:	e8 3a f2 ff ff       	call   101db0 <ilock>
//    cprintf("XXX here %d\n", ip->type);
    if(ip->type != T_DIR){
  102b76:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  102b79:	0f b7 40 10          	movzwl 0x10(%eax),%eax
  102b7d:	66 83 f8 01          	cmp    $0x1,%ax
  102b81:	74 17                	je     102b9a <_namei+0x7a>
      iunlockput(ip);
  102b83:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  102b86:	89 04 24             	mov    %eax,(%esp)
  102b89:	e8 d2 f4 ff ff       	call   102060 <iunlockput>
      return 0;
  102b8e:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  102b95:	e9 ad 00 00 00       	jmp    102c47 <_namei+0x127>
    }
    if(parent && *path == '\0'){
  102b9a:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  102b9e:	74 20                	je     102bc0 <_namei+0xa0>
  102ba0:	8b 45 08             	mov    0x8(%ebp),%eax
  102ba3:	0f b6 00             	movzbl (%eax),%eax
  102ba6:	84 c0                	test   %al,%al
  102ba8:	75 16                	jne    102bc0 <_namei+0xa0>
      // Stop one level early.
      iunlock(ip);
  102baa:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  102bad:	89 04 24             	mov    %eax,(%esp)
  102bb0:	e8 5b f3 ff ff       	call   101f10 <iunlock>
      return ip;
  102bb5:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  102bb8:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  102bbb:	e9 87 00 00 00       	jmp    102c47 <_namei+0x127>
    }
    if((next = dirlookup(ip, name, 0)) == 0){
  102bc0:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  102bc7:	00 
  102bc8:	8b 45 10             	mov    0x10(%ebp),%eax
  102bcb:	89 44 24 04          	mov    %eax,0x4(%esp)
  102bcf:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  102bd2:	89 04 24             	mov    %eax,(%esp)
  102bd5:	e8 56 fc ff ff       	call   102830 <dirlookup>
  102bda:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  102bdd:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  102be1:	75 14                	jne    102bf7 <_namei+0xd7>
      iunlockput(ip);
  102be3:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  102be6:	89 04 24             	mov    %eax,(%esp)
  102be9:	e8 72 f4 ff ff       	call   102060 <iunlockput>
      return 0;
  102bee:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  102bf5:	eb 50                	jmp    102c47 <_namei+0x127>
    }
    iunlockput(ip);
  102bf7:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  102bfa:	89 04 24             	mov    %eax,(%esp)
  102bfd:	e8 5e f4 ff ff       	call   102060 <iunlockput>
    ip = next;
  102c02:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  102c05:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  102c08:	8b 45 10             	mov    0x10(%ebp),%eax
  102c0b:	89 44 24 04          	mov    %eax,0x4(%esp)
  102c0f:	8b 45 08             	mov    0x8(%ebp),%eax
  102c12:	89 04 24             	mov    %eax,(%esp)
  102c15:	e8 46 fe ff ff       	call   102a60 <skipelem>
  102c1a:	89 45 08             	mov    %eax,0x8(%ebp)
  102c1d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  102c21:	0f 85 44 ff ff ff    	jne    102b6b <_namei+0x4b>
  }
  if(parent){
  102c27:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  102c2b:	74 14                	je     102c41 <_namei+0x121>
    iput(ip);
  102c2d:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  102c30:	89 04 24             	mov    %eax,(%esp)
  102c33:	e8 48 f3 ff ff       	call   101f80 <iput>
    return 0;
  102c38:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  102c3f:	eb 06                	jmp    102c47 <_namei+0x127>
  }
  return ip;
  102c41:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  102c44:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  102c47:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  102c4a:	c9                   	leave  
  102c4b:	c3                   	ret    
  102c4c:	8d 74 26 00          	lea    0x0(%esi),%esi

00102c50 <namei>:

struct inode*
namei(char *path)
{
  102c50:	55                   	push   %ebp
  102c51:	89 e5                	mov    %esp,%ebp
  102c53:	83 ec 28             	sub    $0x28,%esp
  char name[DIRSIZ];
  return _namei(path, 0, name);
  102c56:	8d 45 f2             	lea    0xfffffff2(%ebp),%eax
  102c59:	89 44 24 08          	mov    %eax,0x8(%esp)
  102c5d:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  102c64:	00 
  102c65:	8b 45 08             	mov    0x8(%ebp),%eax
  102c68:	89 04 24             	mov    %eax,(%esp)
  102c6b:	e8 b0 fe ff ff       	call   102b20 <_namei>
}
  102c70:	c9                   	leave  
  102c71:	c3                   	ret    
  102c72:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi
  102c79:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00102c80 <nameiparent>:

struct inode*
nameiparent(char *path, char *name)
{
  102c80:	55                   	push   %ebp
  102c81:	89 e5                	mov    %esp,%ebp
  102c83:	83 ec 18             	sub    $0x18,%esp
  return _namei(path, 1, name);
  102c86:	8b 45 0c             	mov    0xc(%ebp),%eax
  102c89:	89 44 24 08          	mov    %eax,0x8(%esp)
  102c8d:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  102c94:	00 
  102c95:	8b 45 08             	mov    0x8(%ebp),%eax
  102c98:	89 04 24             	mov    %eax,(%esp)
  102c9b:	e8 80 fe ff ff       	call   102b20 <_namei>
}
  102ca0:	c9                   	leave  
  102ca1:	c3                   	ret    
  102ca2:	90                   	nop    
  102ca3:	90                   	nop    
  102ca4:	90                   	nop    
  102ca5:	90                   	nop    
  102ca6:	90                   	nop    
  102ca7:	90                   	nop    
  102ca8:	90                   	nop    
  102ca9:	90                   	nop    
  102caa:	90                   	nop    
  102cab:	90                   	nop    
  102cac:	90                   	nop    
  102cad:	90                   	nop    
  102cae:	90                   	nop    
  102caf:	90                   	nop    

00102cb0 <ide_wait_ready>:

// Wait for IDE disk to become ready.
static int
ide_wait_ready(int check_error)
{
  102cb0:	55                   	push   %ebp
  102cb1:	89 e5                	mov    %esp,%ebp
  102cb3:	83 ec 18             	sub    $0x18,%esp
  int r;

  while(((r = inb(0x1f7)) & IDE_BSY) || !(r & IDE_DRDY))
  102cb6:	c7 04 24 f7 01 00 00 	movl   $0x1f7,(%esp)
  102cbd:	e8 4e 00 00 00       	call   102d10 <inb>
  102cc2:	0f b6 c0             	movzbl %al,%eax
  102cc5:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  102cc8:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  102ccb:	25 80 00 00 00       	and    $0x80,%eax
  102cd0:	85 c0                	test   %eax,%eax
  102cd2:	75 e2                	jne    102cb6 <ide_wait_ready+0x6>
  102cd4:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  102cd7:	83 e0 40             	and    $0x40,%eax
  102cda:	85 c0                	test   %eax,%eax
  102cdc:	74 d8                	je     102cb6 <ide_wait_ready+0x6>
    ;
  if(check_error && (r & (IDE_DF|IDE_ERR)) != 0)
  102cde:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  102ce2:	74 13                	je     102cf7 <ide_wait_ready+0x47>
  102ce4:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  102ce7:	83 e0 21             	and    $0x21,%eax
  102cea:	85 c0                	test   %eax,%eax
  102cec:	74 09                	je     102cf7 <ide_wait_ready+0x47>
    return -1;
  102cee:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  102cf5:	eb 07                	jmp    102cfe <ide_wait_ready+0x4e>
  return 0;
  102cf7:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  102cfe:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  102d01:	c9                   	leave  
  102d02:	c3                   	ret    
  102d03:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  102d09:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00102d10 <inb>:
// Routines to let C code use special x86 instructions.

static inline uchar
inb(ushort port)
{
  102d10:	55                   	push   %ebp
  102d11:	89 e5                	mov    %esp,%ebp
  102d13:	83 ec 14             	sub    $0x14,%esp
  102d16:	8b 45 08             	mov    0x8(%ebp),%eax
  102d19:	66 89 45 ec          	mov    %ax,0xffffffec(%ebp)
  uchar data;

  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
  102d1d:	0f b7 55 ec          	movzwl 0xffffffec(%ebp),%edx
  102d21:	ec                   	in     (%dx),%al
  102d22:	88 45 ff             	mov    %al,0xffffffff(%ebp)
  return data;
  102d25:	0f b6 45 ff          	movzbl 0xffffffff(%ebp),%eax
}
  102d29:	c9                   	leave  
  102d2a:	c3                   	ret    
  102d2b:	90                   	nop    
  102d2c:	8d 74 26 00          	lea    0x0(%esi),%esi

00102d30 <dummy_ide_intr>:

void
dummy_ide_intr(struct trapframe *tf)
{
  102d30:	55                   	push   %ebp
  102d31:	89 e5                	mov    %esp,%ebp
}
  102d33:	5d                   	pop    %ebp
  102d34:	c3                   	ret    
  102d35:	8d 74 26 00          	lea    0x0(%esi),%esi
  102d39:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00102d40 <ide_init>:

void
ide_init(void)
{
  102d40:	55                   	push   %ebp
  102d41:	89 e5                	mov    %esp,%ebp
  102d43:	83 ec 18             	sub    $0x18,%esp
  int i;

  initlock(&ide_lock, "ide");
  102d46:	c7 44 24 04 b7 a4 11 	movl   $0x11a4b7,0x4(%esp)
  102d4d:	00 
  102d4e:	c7 04 24 60 cd 11 00 	movl   $0x11cd60,(%esp)
  102d55:	e8 86 2d 00 00       	call   105ae0 <initlock>
  pic_enable(IRQ_IDE);
  102d5a:	c7 04 24 0e 00 00 00 	movl   $0xe,(%esp)
  102d61:	e8 8a 14 00 00       	call   1041f0 <pic_enable>
  ioapic_enable(IRQ_IDE, ncpu - 1);
  102d66:	a1 0c dd 13 00       	mov    0x13dd0c,%eax
  102d6b:	83 e8 01             	sub    $0x1,%eax
  102d6e:	89 44 24 04          	mov    %eax,0x4(%esp)
  102d72:	c7 04 24 0e 00 00 00 	movl   $0xe,(%esp)
  102d79:	e8 c2 04 00 00       	call   103240 <ioapic_enable>
  ide_wait_ready(0);
  102d7e:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  102d85:	e8 26 ff ff ff       	call   102cb0 <ide_wait_ready>
  reg_irq_handler(IRQ_IDE_2, dummy_ide_intr);
  102d8a:	c7 44 24 04 30 2d 10 	movl   $0x102d30,0x4(%esp)
  102d91:	00 
  102d92:	c7 04 24 0f 00 00 00 	movl   $0xf,(%esp)
  102d99:	e8 c2 13 00 00       	call   104160 <reg_irq_handler>
  
  // Check if disk 1 is present
  outb(0x1f6, 0xe0 | (1<<4));
  102d9e:	c7 44 24 04 f0 00 00 	movl   $0xf0,0x4(%esp)
  102da5:	00 
  102da6:	c7 04 24 f6 01 00 00 	movl   $0x1f6,(%esp)
  102dad:	e8 5e 00 00 00       	call   102e10 <outb>
  for(i=0; i<1000; i++){
  102db2:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
  102db9:	eb 20                	jmp    102ddb <ide_init+0x9b>
    if(inb(0x1f7) != 0){
  102dbb:	c7 04 24 f7 01 00 00 	movl   $0x1f7,(%esp)
  102dc2:	e8 49 ff ff ff       	call   102d10 <inb>
  102dc7:	84 c0                	test   %al,%al
  102dc9:	74 0c                	je     102dd7 <ide_init+0x97>
      disk_1_present = 1;
  102dcb:	c7 05 98 cd 11 00 01 	movl   $0x1,0x11cd98
  102dd2:	00 00 00 
      break;
  102dd5:	eb 0d                	jmp    102de4 <ide_init+0xa4>
  102dd7:	83 45 fc 01          	addl   $0x1,0xfffffffc(%ebp)
  102ddb:	81 7d fc e7 03 00 00 	cmpl   $0x3e7,0xfffffffc(%ebp)
  102de2:	7e d7                	jle    102dbb <ide_init+0x7b>
    }
  }
  
  // Switch back to disk 0.
  outb(0x1f6, 0xe0 | (0<<4));
  102de4:	c7 44 24 04 e0 00 00 	movl   $0xe0,0x4(%esp)
  102deb:	00 
  102dec:	c7 04 24 f6 01 00 00 	movl   $0x1f6,(%esp)
  102df3:	e8 18 00 00 00       	call   102e10 <outb>
  outb(0x3f6, 0);  // generate interrupt
  102df8:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  102dff:	00 
  102e00:	c7 04 24 f6 03 00 00 	movl   $0x3f6,(%esp)
  102e07:	e8 04 00 00 00       	call   102e10 <outb>
}
  102e0c:	c9                   	leave  
  102e0d:	c3                   	ret    
  102e0e:	89 f6                	mov    %esi,%esi

00102e10 <outb>:
}

static inline void
outb(ushort port, uchar data)
{
  102e10:	55                   	push   %ebp
  102e11:	89 e5                	mov    %esp,%ebp
  102e13:	83 ec 08             	sub    $0x8,%esp
  102e16:	8b 45 08             	mov    0x8(%ebp),%eax
  102e19:	8b 55 0c             	mov    0xc(%ebp),%edx
  102e1c:	66 89 45 fc          	mov    %ax,0xfffffffc(%ebp)
  102e20:	88 55 f8             	mov    %dl,0xfffffff8(%ebp)
  asm volatile("out %0,%1" : : "a" (data), "d" (port));
  102e23:	0f b6 45 f8          	movzbl 0xfffffff8(%ebp),%eax
  102e27:	0f b7 55 fc          	movzwl 0xfffffffc(%ebp),%edx
  102e2b:	ee                   	out    %al,(%dx)
}
  102e2c:	c9                   	leave  
  102e2d:	c3                   	ret    
  102e2e:	89 f6                	mov    %esi,%esi

00102e30 <ide_start_request>:

// Start the request for b.  Caller must hold ide_lock.
static void
ide_start_request(struct buf *b)
{
  102e30:	55                   	push   %ebp
  102e31:	89 e5                	mov    %esp,%ebp
  102e33:	83 ec 18             	sub    $0x18,%esp
//    cprintf("XXX ide_start_request\n");
  if(b == 0)
  102e36:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  102e3a:	75 0c                	jne    102e48 <ide_start_request+0x18>
    panic("ide_start_request");
  102e3c:	c7 04 24 bb a4 11 00 	movl   $0x11a4bb,(%esp)
  102e43:	e8 b8 e1 ff ff       	call   101000 <panic>

  ide_wait_ready(0);
  102e48:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  102e4f:	e8 5c fe ff ff       	call   102cb0 <ide_wait_ready>
  outb(0x1f2, 1);  // number of sectors
  102e54:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  102e5b:	00 
  102e5c:	c7 04 24 f2 01 00 00 	movl   $0x1f2,(%esp)
  102e63:	e8 a8 ff ff ff       	call   102e10 <outb>
  outb(0x1f3, b->sector & 0xff);
  102e68:	8b 45 08             	mov    0x8(%ebp),%eax
  102e6b:	8b 40 08             	mov    0x8(%eax),%eax
  102e6e:	0f b6 c0             	movzbl %al,%eax
  102e71:	89 44 24 04          	mov    %eax,0x4(%esp)
  102e75:	c7 04 24 f3 01 00 00 	movl   $0x1f3,(%esp)
  102e7c:	e8 8f ff ff ff       	call   102e10 <outb>
  outb(0x1f4, (b->sector >> 8) & 0xff);
  102e81:	8b 45 08             	mov    0x8(%ebp),%eax
  102e84:	8b 40 08             	mov    0x8(%eax),%eax
  102e87:	c1 e8 08             	shr    $0x8,%eax
  102e8a:	0f b6 c0             	movzbl %al,%eax
  102e8d:	89 44 24 04          	mov    %eax,0x4(%esp)
  102e91:	c7 04 24 f4 01 00 00 	movl   $0x1f4,(%esp)
  102e98:	e8 73 ff ff ff       	call   102e10 <outb>
  outb(0x1f5, (b->sector >> 16) & 0xff);
  102e9d:	8b 45 08             	mov    0x8(%ebp),%eax
  102ea0:	8b 40 08             	mov    0x8(%eax),%eax
  102ea3:	c1 e8 10             	shr    $0x10,%eax
  102ea6:	0f b6 c0             	movzbl %al,%eax
  102ea9:	89 44 24 04          	mov    %eax,0x4(%esp)
  102ead:	c7 04 24 f5 01 00 00 	movl   $0x1f5,(%esp)
  102eb4:	e8 57 ff ff ff       	call   102e10 <outb>
  outb(0x1f6, 0xe0 | ((b->dev&1)<<4) | ((b->sector>>24)&0x0f));
  102eb9:	8b 45 08             	mov    0x8(%ebp),%eax
  102ebc:	8b 40 04             	mov    0x4(%eax),%eax
  102ebf:	83 e0 01             	and    $0x1,%eax
  102ec2:	89 c2                	mov    %eax,%edx
  102ec4:	c1 e2 04             	shl    $0x4,%edx
  102ec7:	8b 45 08             	mov    0x8(%ebp),%eax
  102eca:	8b 40 08             	mov    0x8(%eax),%eax
  102ecd:	c1 e8 18             	shr    $0x18,%eax
  102ed0:	83 e0 0f             	and    $0xf,%eax
  102ed3:	09 d0                	or     %edx,%eax
  102ed5:	83 c8 e0             	or     $0xffffffe0,%eax
  102ed8:	0f b6 c0             	movzbl %al,%eax
  102edb:	89 44 24 04          	mov    %eax,0x4(%esp)
  102edf:	c7 04 24 f6 01 00 00 	movl   $0x1f6,(%esp)
  102ee6:	e8 25 ff ff ff       	call   102e10 <outb>
  if(b->flags & B_DIRTY){
  102eeb:	8b 45 08             	mov    0x8(%ebp),%eax
  102eee:	8b 00                	mov    (%eax),%eax
  102ef0:	83 e0 04             	and    $0x4,%eax
  102ef3:	85 c0                	test   %eax,%eax
  102ef5:	74 34                	je     102f2b <ide_start_request+0xfb>
    outb(0x1f7, IDE_CMD_WRITE);
  102ef7:	c7 44 24 04 30 00 00 	movl   $0x30,0x4(%esp)
  102efe:	00 
  102eff:	c7 04 24 f7 01 00 00 	movl   $0x1f7,(%esp)
  102f06:	e8 05 ff ff ff       	call   102e10 <outb>
    outsl(0x1f0, b->data, 512/4);
  102f0b:	8b 45 08             	mov    0x8(%ebp),%eax
  102f0e:	83 c0 18             	add    $0x18,%eax
  102f11:	c7 44 24 08 80 00 00 	movl   $0x80,0x8(%esp)
  102f18:	00 
  102f19:	89 44 24 04          	mov    %eax,0x4(%esp)
  102f1d:	c7 04 24 f0 01 00 00 	movl   $0x1f0,(%esp)
  102f24:	e8 27 00 00 00       	call   102f50 <outsl>
  102f29:	eb 14                	jmp    102f3f <ide_start_request+0x10f>
  } else {
    outb(0x1f7, IDE_CMD_READ);
  102f2b:	c7 44 24 04 20 00 00 	movl   $0x20,0x4(%esp)
  102f32:	00 
  102f33:	c7 04 24 f7 01 00 00 	movl   $0x1f7,(%esp)
  102f3a:	e8 d1 fe ff ff       	call   102e10 <outb>
  }
}
  102f3f:	c9                   	leave  
  102f40:	c3                   	ret    
  102f41:	eb 0d                	jmp    102f50 <outsl>
  102f43:	90                   	nop    
  102f44:	90                   	nop    
  102f45:	90                   	nop    
  102f46:	90                   	nop    
  102f47:	90                   	nop    
  102f48:	90                   	nop    
  102f49:	90                   	nop    
  102f4a:	90                   	nop    
  102f4b:	90                   	nop    
  102f4c:	90                   	nop    
  102f4d:	90                   	nop    
  102f4e:	90                   	nop    
  102f4f:	90                   	nop    

00102f50 <outsl>:
}

static inline void
outsl(int port, const void *addr, int cnt)
{
  102f50:	55                   	push   %ebp
  102f51:	89 e5                	mov    %esp,%ebp
  102f53:	56                   	push   %esi
  asm volatile("cld\n\trepne\n\toutsl"    :
  102f54:	8b 55 08             	mov    0x8(%ebp),%edx
  102f57:	8b 75 0c             	mov    0xc(%ebp),%esi
  102f5a:	8b 4d 10             	mov    0x10(%ebp),%ecx
  102f5d:	fc                   	cld    
  102f5e:	f2 6f                	repnz outsl %ds:(%esi),(%dx)
  102f60:	89 75 0c             	mov    %esi,0xc(%ebp)
  102f63:	89 4d 10             	mov    %ecx,0x10(%ebp)
                   "=S" (addr), "=c" (cnt)    :
                   "d" (port), "0" (addr), "1" (cnt)  :
                   "cc");
}
  102f66:	5e                   	pop    %esi
  102f67:	5d                   	pop    %ebp
  102f68:	c3                   	ret    
  102f69:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

00102f70 <ide_intr>:

// Interrupt handler.
void
ide_intr(void)
{
  102f70:	55                   	push   %ebp
  102f71:	89 e5                	mov    %esp,%ebp
  102f73:	83 ec 28             	sub    $0x28,%esp
  struct buf *b;

  acquire(&ide_lock);
  102f76:	c7 04 24 60 cd 11 00 	movl   $0x11cd60,(%esp)
  102f7d:	e8 8e 2b 00 00       	call   105b10 <acquire>
  if((b = ide_queue) == 0){
  102f82:	a1 94 cd 11 00       	mov    0x11cd94,%eax
  102f87:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  102f8a:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  102f8e:	75 11                	jne    102fa1 <ide_intr+0x31>
    release(&ide_lock);
  102f90:	c7 04 24 60 cd 11 00 	movl   $0x11cd60,(%esp)
  102f97:	e8 74 2d 00 00       	call   105d10 <release>
    return;
  102f9c:	e9 90 00 00 00       	jmp    103031 <ide_intr+0xc1>
  }

  // Read data if needed.
  if(!(b->flags & B_DIRTY) && ide_wait_ready(1) >= 0)
  102fa1:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  102fa4:	8b 00                	mov    (%eax),%eax
  102fa6:	83 e0 04             	and    $0x4,%eax
  102fa9:	85 c0                	test   %eax,%eax
  102fab:	75 2e                	jne    102fdb <ide_intr+0x6b>
  102fad:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  102fb4:	e8 f7 fc ff ff       	call   102cb0 <ide_wait_ready>
  102fb9:	85 c0                	test   %eax,%eax
  102fbb:	78 1e                	js     102fdb <ide_intr+0x6b>
    insl(0x1f0, b->data, 512/4);
  102fbd:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  102fc0:	83 c0 18             	add    $0x18,%eax
  102fc3:	c7 44 24 08 80 00 00 	movl   $0x80,0x8(%esp)
  102fca:	00 
  102fcb:	89 44 24 04          	mov    %eax,0x4(%esp)
  102fcf:	c7 04 24 f0 01 00 00 	movl   $0x1f0,(%esp)
  102fd6:	e8 65 00 00 00       	call   103040 <insl>
  
  // Wake process waiting for this buf.
  b->flags |= B_VALID;
  102fdb:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  102fde:	8b 00                	mov    (%eax),%eax
  102fe0:	89 c2                	mov    %eax,%edx
  102fe2:	83 ca 02             	or     $0x2,%edx
  102fe5:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  102fe8:	89 10                	mov    %edx,(%eax)
  b->flags &= ~B_DIRTY;
  102fea:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  102fed:	8b 00                	mov    (%eax),%eax
  102fef:	89 c2                	mov    %eax,%edx
  102ff1:	83 e2 fb             	and    $0xfffffffb,%edx
  102ff4:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  102ff7:	89 10                	mov    %edx,(%eax)
  wakeup(b);
  102ff9:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  102ffc:	89 04 24             	mov    %eax,(%esp)
  102fff:	e8 ec 25 00 00       	call   1055f0 <wakeup>
  
  // Start disk on next buf in queue.
  if((ide_queue = b->qnext) != 0)
  103004:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  103007:	8b 40 14             	mov    0x14(%eax),%eax
  10300a:	a3 94 cd 11 00       	mov    %eax,0x11cd94
  10300f:	a1 94 cd 11 00       	mov    0x11cd94,%eax
  103014:	85 c0                	test   %eax,%eax
  103016:	74 0d                	je     103025 <ide_intr+0xb5>
    ide_start_request(ide_queue);
  103018:	a1 94 cd 11 00       	mov    0x11cd94,%eax
  10301d:	89 04 24             	mov    %eax,(%esp)
  103020:	e8 0b fe ff ff       	call   102e30 <ide_start_request>

  release(&ide_lock);
  103025:	c7 04 24 60 cd 11 00 	movl   $0x11cd60,(%esp)
  10302c:	e8 df 2c 00 00       	call   105d10 <release>
}
  103031:	c9                   	leave  
  103032:	c3                   	ret    
  103033:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  103039:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00103040 <insl>:
}

static inline void
insl(int port, void *addr, int cnt)
{
  103040:	55                   	push   %ebp
  103041:	89 e5                	mov    %esp,%ebp
  103043:	57                   	push   %edi
  asm volatile("cld\n\trepne\n\tinsl"     :
  103044:	8b 55 08             	mov    0x8(%ebp),%edx
  103047:	8b 7d 0c             	mov    0xc(%ebp),%edi
  10304a:	8b 4d 10             	mov    0x10(%ebp),%ecx
  10304d:	fc                   	cld    
  10304e:	f2 6d                	repnz insl (%dx),%es:(%edi)
  103050:	89 7d 0c             	mov    %edi,0xc(%ebp)
  103053:	89 4d 10             	mov    %ecx,0x10(%ebp)
                   "=D" (addr), "=c" (cnt)    :
                   "d" (port), "0" (addr), "1" (cnt)  :
                   "memory", "cc");
}
  103056:	5f                   	pop    %edi
  103057:	5d                   	pop    %ebp
  103058:	c3                   	ret    
  103059:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

00103060 <ide_rw>:

// Sync buf with disk. 
// If B_DIRTY is set, write buf to disk, clear B_DIRTY, set B_VALID.
// Else if B_VALID is not set, read buf from disk, set B_VALID.
void
ide_rw(struct buf *b)
{
  103060:	55                   	push   %ebp
  103061:	89 e5                	mov    %esp,%ebp
  103063:	83 ec 18             	sub    $0x18,%esp
  struct buf **pp;

  if(!(b->flags & B_BUSY))
  103066:	8b 45 08             	mov    0x8(%ebp),%eax
  103069:	8b 00                	mov    (%eax),%eax
  10306b:	83 e0 01             	and    $0x1,%eax
  10306e:	85 c0                	test   %eax,%eax
  103070:	75 0c                	jne    10307e <ide_rw+0x1e>
    panic("ide_rw: buf not busy");
  103072:	c7 04 24 cd a4 11 00 	movl   $0x11a4cd,(%esp)
  103079:	e8 82 df ff ff       	call   101000 <panic>
  if((b->flags & (B_VALID|B_DIRTY)) == B_VALID)
  10307e:	8b 45 08             	mov    0x8(%ebp),%eax
  103081:	8b 00                	mov    (%eax),%eax
  103083:	83 e0 06             	and    $0x6,%eax
  103086:	83 f8 02             	cmp    $0x2,%eax
  103089:	75 0c                	jne    103097 <ide_rw+0x37>
    panic("ide_rw: nothing to do");
  10308b:	c7 04 24 e2 a4 11 00 	movl   $0x11a4e2,(%esp)
  103092:	e8 69 df ff ff       	call   101000 <panic>
  if(b->dev != 0 && !disk_1_present)
  103097:	8b 45 08             	mov    0x8(%ebp),%eax
  10309a:	8b 40 04             	mov    0x4(%eax),%eax
  10309d:	85 c0                	test   %eax,%eax
  10309f:	74 15                	je     1030b6 <ide_rw+0x56>
  1030a1:	a1 98 cd 11 00       	mov    0x11cd98,%eax
  1030a6:	85 c0                	test   %eax,%eax
  1030a8:	75 0c                	jne    1030b6 <ide_rw+0x56>
    panic("ide disk 1 not present");
  1030aa:	c7 04 24 f8 a4 11 00 	movl   $0x11a4f8,(%esp)
  1030b1:	e8 4a df ff ff       	call   101000 <panic>

  acquire(&ide_lock);
  1030b6:	c7 04 24 60 cd 11 00 	movl   $0x11cd60,(%esp)
  1030bd:	e8 4e 2a 00 00       	call   105b10 <acquire>

  // Append b to ide_queue.
  b->qnext = 0;
  1030c2:	8b 45 08             	mov    0x8(%ebp),%eax
  1030c5:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
  for(pp=&ide_queue; *pp; pp=&(*pp)->qnext)
  1030cc:	c7 45 fc 94 cd 11 00 	movl   $0x11cd94,0xfffffffc(%ebp)
  1030d3:	eb 0b                	jmp    1030e0 <ide_rw+0x80>
  1030d5:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1030d8:	8b 00                	mov    (%eax),%eax
  1030da:	83 c0 14             	add    $0x14,%eax
  1030dd:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  1030e0:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1030e3:	8b 00                	mov    (%eax),%eax
  1030e5:	85 c0                	test   %eax,%eax
  1030e7:	75 ec                	jne    1030d5 <ide_rw+0x75>
    ;
  *pp = b;
  1030e9:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1030ec:	8b 55 08             	mov    0x8(%ebp),%edx
  1030ef:	89 10                	mov    %edx,(%eax)
  
  // Start disk if necessary.
  if(ide_queue == b)
  1030f1:	a1 94 cd 11 00       	mov    0x11cd94,%eax
  1030f6:	3b 45 08             	cmp    0x8(%ebp),%eax
  1030f9:	75 20                	jne    10311b <ide_rw+0xbb>
    ide_start_request(b);
  1030fb:	8b 45 08             	mov    0x8(%ebp),%eax
  1030fe:	89 04 24             	mov    %eax,(%esp)
  103101:	e8 2a fd ff ff       	call   102e30 <ide_start_request>
  
  // Wait for request to finish.
  // Assuming will not sleep too long: ignore cp->killed.
  while((b->flags & (B_VALID|B_DIRTY)) != B_VALID)
  103106:	eb 13                	jmp    10311b <ide_rw+0xbb>
  {
    sleep(b, &ide_lock);
  103108:	c7 44 24 04 60 cd 11 	movl   $0x11cd60,0x4(%esp)
  10310f:	00 
  103110:	8b 45 08             	mov    0x8(%ebp),%eax
  103113:	89 04 24             	mov    %eax,(%esp)
  103116:	e8 45 23 00 00       	call   105460 <sleep>
  10311b:	8b 45 08             	mov    0x8(%ebp),%eax
  10311e:	8b 00                	mov    (%eax),%eax
  103120:	83 e0 06             	and    $0x6,%eax
  103123:	83 f8 02             	cmp    $0x2,%eax
  103126:	75 e0                	jne    103108 <ide_rw+0xa8>
  }
//  cprintf("XXX ide_rw: finished\n");

  release(&ide_lock);
  103128:	c7 04 24 60 cd 11 00 	movl   $0x11cd60,(%esp)
  10312f:	e8 dc 2b 00 00       	call   105d10 <release>
}
  103134:	c9                   	leave  
  103135:	c3                   	ret    
  103136:	90                   	nop    
  103137:	90                   	nop    
  103138:	90                   	nop    
  103139:	90                   	nop    
  10313a:	90                   	nop    
  10313b:	90                   	nop    
  10313c:	90                   	nop    
  10313d:	90                   	nop    
  10313e:	90                   	nop    
  10313f:	90                   	nop    

00103140 <ioapic_read>:
};

static uint
ioapic_read(int reg)
{
  103140:	55                   	push   %ebp
  103141:	89 e5                	mov    %esp,%ebp
  ioapic->reg = reg;
  103143:	8b 15 b4 cb 13 00    	mov    0x13cbb4,%edx
  103149:	8b 45 08             	mov    0x8(%ebp),%eax
  10314c:	89 02                	mov    %eax,(%edx)
  return ioapic->data;
  10314e:	a1 b4 cb 13 00       	mov    0x13cbb4,%eax
  103153:	8b 40 10             	mov    0x10(%eax),%eax
}
  103156:	5d                   	pop    %ebp
  103157:	c3                   	ret    
  103158:	90                   	nop    
  103159:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

00103160 <ioapic_write>:

static void
ioapic_write(int reg, uint data)
{
  103160:	55                   	push   %ebp
  103161:	89 e5                	mov    %esp,%ebp
  ioapic->reg = reg;
  103163:	8b 15 b4 cb 13 00    	mov    0x13cbb4,%edx
  103169:	8b 45 08             	mov    0x8(%ebp),%eax
  10316c:	89 02                	mov    %eax,(%edx)
  ioapic->data = data;
  10316e:	8b 15 b4 cb 13 00    	mov    0x13cbb4,%edx
  103174:	8b 45 0c             	mov    0xc(%ebp),%eax
  103177:	89 42 10             	mov    %eax,0x10(%edx)
}
  10317a:	5d                   	pop    %ebp
  10317b:	c3                   	ret    
  10317c:	8d 74 26 00          	lea    0x0(%esi),%esi

00103180 <ioapic_init>:

void
ioapic_init(void)
{
  103180:	55                   	push   %ebp
  103181:	89 e5                	mov    %esp,%ebp
  103183:	83 ec 18             	sub    $0x18,%esp
  int i, id, maxintr;

  if(!ismp)
  103186:	a1 00 cc 13 00       	mov    0x13cc00,%eax
  10318b:	85 c0                	test   %eax,%eax
  10318d:	0f 84 9c 00 00 00    	je     10322f <ioapic_init+0xaf>
    return;

  ioapic = (volatile struct ioapic*)IOAPIC;
  103193:	c7 05 b4 cb 13 00 00 	movl   $0xfec00000,0x13cbb4
  10319a:	00 c0 fe 
  maxintr = (ioapic_read(REG_VER) >> 16) & 0xFF;
  10319d:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  1031a4:	e8 97 ff ff ff       	call   103140 <ioapic_read>
  1031a9:	c1 e8 10             	shr    $0x10,%eax
  1031ac:	25 ff 00 00 00       	and    $0xff,%eax
  1031b1:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  id = ioapic_read(REG_ID) >> 24;
  1031b4:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  1031bb:	e8 80 ff ff ff       	call   103140 <ioapic_read>
  1031c0:	c1 e8 18             	shr    $0x18,%eax
  1031c3:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  if(id != ioapic_id)
  1031c6:	0f b6 05 04 cc 13 00 	movzbl 0x13cc04,%eax
  1031cd:	0f b6 c0             	movzbl %al,%eax
  1031d0:	3b 45 f8             	cmp    0xfffffff8(%ebp),%eax
  1031d3:	74 0c                	je     1031e1 <ioapic_init+0x61>
    cprintf("ioapic_init: id isn't equal to ioapic_id; not a MP\n");
  1031d5:	c7 04 24 10 a5 11 00 	movl   $0x11a510,(%esp)
  1031dc:	e8 2f d5 ff ff       	call   100710 <cprintf>

  // Mark all interrupts edge-triggered, active high, disabled,
  // and not routed to any CPUs.
  for(i = 0; i <= maxintr; i++){
  1031e1:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
  1031e8:	eb 3d                	jmp    103227 <ioapic_init+0xa7>
    ioapic_write(REG_TABLE+2*i, INT_DISABLED | (IRQ_OFFSET + i));
  1031ea:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  1031ed:	83 c0 20             	add    $0x20,%eax
  1031f0:	0d 00 00 10 00       	or     $0x100000,%eax
  1031f5:	89 c2                	mov    %eax,%edx
  1031f7:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  1031fa:	01 c0                	add    %eax,%eax
  1031fc:	83 c0 10             	add    $0x10,%eax
  1031ff:	89 54 24 04          	mov    %edx,0x4(%esp)
  103203:	89 04 24             	mov    %eax,(%esp)
  103206:	e8 55 ff ff ff       	call   103160 <ioapic_write>
    ioapic_write(REG_TABLE+2*i+1, 0);
  10320b:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10320e:	01 c0                	add    %eax,%eax
  103210:	83 c0 11             	add    $0x11,%eax
  103213:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  10321a:	00 
  10321b:	89 04 24             	mov    %eax,(%esp)
  10321e:	e8 3d ff ff ff       	call   103160 <ioapic_write>
  103223:	83 45 f4 01          	addl   $0x1,0xfffffff4(%ebp)
  103227:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10322a:	3b 45 fc             	cmp    0xfffffffc(%ebp),%eax
  10322d:	7e bb                	jle    1031ea <ioapic_init+0x6a>
  }
}
  10322f:	c9                   	leave  
  103230:	c3                   	ret    
  103231:	eb 0d                	jmp    103240 <ioapic_enable>
  103233:	90                   	nop    
  103234:	90                   	nop    
  103235:	90                   	nop    
  103236:	90                   	nop    
  103237:	90                   	nop    
  103238:	90                   	nop    
  103239:	90                   	nop    
  10323a:	90                   	nop    
  10323b:	90                   	nop    
  10323c:	90                   	nop    
  10323d:	90                   	nop    
  10323e:	90                   	nop    
  10323f:	90                   	nop    

00103240 <ioapic_enable>:

void
ioapic_enable(int irq, int cpunum)
{
  103240:	55                   	push   %ebp
  103241:	89 e5                	mov    %esp,%ebp
  103243:	83 ec 08             	sub    $0x8,%esp
  if(!ismp)
  103246:	a1 00 cc 13 00       	mov    0x13cc00,%eax
  10324b:	85 c0                	test   %eax,%eax
  10324d:	74 38                	je     103287 <ioapic_enable+0x47>
    return;

  // Mark interrupt edge-triggered, active high,
  // enabled, and routed to the given cpunum,
  // which happens to be that cpu's APIC ID.
  ioapic_write(REG_TABLE+2*irq, IRQ_OFFSET + irq);
  10324f:	8b 45 08             	mov    0x8(%ebp),%eax
  103252:	83 c0 20             	add    $0x20,%eax
  103255:	89 c2                	mov    %eax,%edx
  103257:	8b 45 08             	mov    0x8(%ebp),%eax
  10325a:	01 c0                	add    %eax,%eax
  10325c:	83 c0 10             	add    $0x10,%eax
  10325f:	89 54 24 04          	mov    %edx,0x4(%esp)
  103263:	89 04 24             	mov    %eax,(%esp)
  103266:	e8 f5 fe ff ff       	call   103160 <ioapic_write>
  ioapic_write(REG_TABLE+2*irq+1, cpunum << 24);
  10326b:	8b 45 0c             	mov    0xc(%ebp),%eax
  10326e:	c1 e0 18             	shl    $0x18,%eax
  103271:	89 c2                	mov    %eax,%edx
  103273:	8b 45 08             	mov    0x8(%ebp),%eax
  103276:	01 c0                	add    %eax,%eax
  103278:	83 c0 11             	add    $0x11,%eax
  10327b:	89 54 24 04          	mov    %edx,0x4(%esp)
  10327f:	89 04 24             	mov    %eax,(%esp)
  103282:	e8 d9 fe ff ff       	call   103160 <ioapic_write>
}
  103287:	c9                   	leave  
  103288:	c3                   	ret    
  103289:	90                   	nop    
  10328a:	90                   	nop    
  10328b:	90                   	nop    
  10328c:	90                   	nop    
  10328d:	90                   	nop    
  10328e:	90                   	nop    
  10328f:	90                   	nop    

00103290 <kinit>:
// pages after _end.  Real systems would determine the
// amount of memory available in the system and use it all.
void
kinit(void)
{
  103290:	55                   	push   %ebp
  103291:	89 e5                	mov    %esp,%ebp
  103293:	83 ec 18             	sub    $0x18,%esp
  extern int end;
  uint mem;
  char *start;

  initlock(&kalloc_lock, "kalloc");
  103296:	c7 44 24 04 44 a5 11 	movl   $0x11a544,0x4(%esp)
  10329d:	00 
  10329e:	c7 04 24 c0 cb 13 00 	movl   $0x13cbc0,(%esp)
  1032a5:	e8 36 28 00 00       	call   105ae0 <initlock>
  start = (char*) &end;
  1032aa:	c7 45 fc 70 16 14 00 	movl   $0x141670,0xfffffffc(%ebp)
  start = (char*) (((uint)start + PAGE) & ~(PAGE-1));
  1032b1:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1032b4:	05 00 10 00 00       	add    $0x1000,%eax
  1032b9:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  1032be:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  mem = 256; // assume computer has 256 pages of RAM
  1032c1:	c7 45 f8 00 01 00 00 	movl   $0x100,0xfffffff8(%ebp)
  cprintf("mem = %d\n", mem * PAGE);
  1032c8:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1032cb:	c1 e0 0c             	shl    $0xc,%eax
  1032ce:	89 44 24 04          	mov    %eax,0x4(%esp)
  1032d2:	c7 04 24 4b a5 11 00 	movl   $0x11a54b,(%esp)
  1032d9:	e8 32 d4 ff ff       	call   100710 <cprintf>
  kfree(start, mem * PAGE);
  1032de:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1032e1:	c1 e0 0c             	shl    $0xc,%eax
  1032e4:	89 44 24 04          	mov    %eax,0x4(%esp)
  1032e8:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1032eb:	89 04 24             	mov    %eax,(%esp)
  1032ee:	e8 0d 00 00 00       	call   103300 <kfree>
}
  1032f3:	c9                   	leave  
  1032f4:	c3                   	ret    
  1032f5:	8d 74 26 00          	lea    0x0(%esi),%esi
  1032f9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00103300 <kfree>:

// Free the len bytes of memory pointed at by v,
// which normally should have been returned by a
// call to kalloc(len).  (The exception is when
// initializing the allocator; see kinit above.)
void
kfree(char *v, int len)
{
  103300:	55                   	push   %ebp
  103301:	89 e5                	mov    %esp,%ebp
  103303:	83 ec 38             	sub    $0x38,%esp
  struct run *r, *rend, **rp, *p, *pend;

#ifdef MEM_DEBUG
  cprintf("kfree: %d pages\n", len / PAGE);
#endif
  if(len <= 0 || len % PAGE)
  103306:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  10330a:	7e 0c                	jle    103318 <kfree+0x18>
  10330c:	8b 45 0c             	mov    0xc(%ebp),%eax
  10330f:	25 ff 0f 00 00       	and    $0xfff,%eax
  103314:	85 c0                	test   %eax,%eax
  103316:	74 1f                	je     103337 <kfree+0x37>
  {
    cprintf("kfree: length = %d\n", len);
  103318:	8b 45 0c             	mov    0xc(%ebp),%eax
  10331b:	89 44 24 04          	mov    %eax,0x4(%esp)
  10331f:	c7 04 24 55 a5 11 00 	movl   $0x11a555,(%esp)
  103326:	e8 e5 d3 ff ff       	call   100710 <cprintf>
    panic("kfree");
  10332b:	c7 04 24 69 a5 11 00 	movl   $0x11a569,(%esp)
  103332:	e8 c9 dc ff ff       	call   101000 <panic>
  }

  // Fill with junk to catch dangling refs.
  memset(v, 1, len);
  103337:	8b 45 0c             	mov    0xc(%ebp),%eax
  10333a:	89 44 24 08          	mov    %eax,0x8(%esp)
  10333e:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  103345:	00 
  103346:	8b 45 08             	mov    0x8(%ebp),%eax
  103349:	89 04 24             	mov    %eax,(%esp)
  10334c:	e8 7f 2b 00 00       	call   105ed0 <memset>

  acquire(&kalloc_lock);
  103351:	c7 04 24 c0 cb 13 00 	movl   $0x13cbc0,(%esp)
  103358:	e8 b3 27 00 00       	call   105b10 <acquire>
  p = (struct run*)v;
  10335d:	8b 45 08             	mov    0x8(%ebp),%eax
  103360:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  pend = (struct run*)(v + len);
  103363:	8b 45 0c             	mov    0xc(%ebp),%eax
  103366:	03 45 08             	add    0x8(%ebp),%eax
  103369:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  for(rp=&freelist; (r=*rp) != 0 && r <= pend; rp=&r->next){
  10336c:	c7 45 f4 f4 cb 13 00 	movl   $0x13cbf4,0xfffffff4(%ebp)
  103373:	e9 b3 00 00 00       	jmp    10342b <kfree+0x12b>
    rend = (struct run*)((char*)r + r->len);
  103378:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10337b:	8b 40 04             	mov    0x4(%eax),%eax
  10337e:	89 c2                	mov    %eax,%edx
  103380:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  103383:	8d 04 02             	lea    (%edx,%eax,1),%eax
  103386:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
    if(r <= p && p < rend)
  103389:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10338c:	3b 45 f8             	cmp    0xfffffff8(%ebp),%eax
  10338f:	77 14                	ja     1033a5 <kfree+0xa5>
  103391:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  103394:	3b 45 f0             	cmp    0xfffffff0(%ebp),%eax
  103397:	73 0c                	jae    1033a5 <kfree+0xa5>
      panic("freeing free page");
  103399:	c7 04 24 6f a5 11 00 	movl   $0x11a56f,(%esp)
  1033a0:	e8 5b dc ff ff       	call   101000 <panic>
    if(pend == r){  // p next to r: replace r with p
  1033a5:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1033a8:	3b 45 ec             	cmp    0xffffffec(%ebp),%eax
  1033ab:	75 28                	jne    1033d5 <kfree+0xd5>
      p->len = len + r->len;
  1033ad:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  1033b0:	8b 40 04             	mov    0x4(%eax),%eax
  1033b3:	89 c2                	mov    %eax,%edx
  1033b5:	03 55 0c             	add    0xc(%ebp),%edx
  1033b8:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1033bb:	89 50 04             	mov    %edx,0x4(%eax)
      p->next = r->next;
  1033be:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  1033c1:	8b 10                	mov    (%eax),%edx
  1033c3:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1033c6:	89 10                	mov    %edx,(%eax)
      *rp = p;
  1033c8:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
  1033cb:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1033ce:	89 02                	mov    %eax,(%edx)
      goto out;
  1033d0:	e9 89 00 00 00       	jmp    10345e <kfree+0x15e>
    }
    if(rend == p){  // r next to p: replace p with r
  1033d5:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  1033d8:	3b 45 f8             	cmp    0xfffffff8(%ebp),%eax
  1033db:	75 48                	jne    103425 <kfree+0x125>
      r->len += len;
  1033dd:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  1033e0:	8b 40 04             	mov    0x4(%eax),%eax
  1033e3:	89 c2                	mov    %eax,%edx
  1033e5:	03 55 0c             	add    0xc(%ebp),%edx
  1033e8:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  1033eb:	89 50 04             	mov    %edx,0x4(%eax)
      if(r->next && r->next == pend){  // r now next to r->next?
  1033ee:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  1033f1:	8b 00                	mov    (%eax),%eax
  1033f3:	85 c0                	test   %eax,%eax
  1033f5:	74 67                	je     10345e <kfree+0x15e>
  1033f7:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  1033fa:	8b 00                	mov    (%eax),%eax
  1033fc:	3b 45 fc             	cmp    0xfffffffc(%ebp),%eax
  1033ff:	75 5d                	jne    10345e <kfree+0x15e>
        r->len += r->next->len;
  103401:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  103404:	8b 50 04             	mov    0x4(%eax),%edx
  103407:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10340a:	8b 00                	mov    (%eax),%eax
  10340c:	8b 40 04             	mov    0x4(%eax),%eax
  10340f:	01 c2                	add    %eax,%edx
  103411:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  103414:	89 50 04             	mov    %edx,0x4(%eax)
        r->next = r->next->next;
  103417:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10341a:	8b 00                	mov    (%eax),%eax
  10341c:	8b 10                	mov    (%eax),%edx
  10341e:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  103421:	89 10                	mov    %edx,(%eax)
      }
      goto out;
  103423:	eb 39                	jmp    10345e <kfree+0x15e>
  103425:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  103428:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  10342b:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10342e:	8b 00                	mov    (%eax),%eax
  103430:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  103433:	83 7d ec 00          	cmpl   $0x0,0xffffffec(%ebp)
  103437:	74 0c                	je     103445 <kfree+0x145>
  103439:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10343c:	3b 45 fc             	cmp    0xfffffffc(%ebp),%eax
  10343f:	0f 86 33 ff ff ff    	jbe    103378 <kfree+0x78>
    }
  }
  // Insert p before r in list.
  p->len = len;
  103445:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  103448:	8b 45 0c             	mov    0xc(%ebp),%eax
  10344b:	89 42 04             	mov    %eax,0x4(%edx)
  p->next = r;
  10344e:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  103451:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  103454:	89 02                	mov    %eax,(%edx)
  *rp = p;
  103456:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
  103459:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10345c:	89 02                	mov    %eax,(%edx)

 out:
  release(&kalloc_lock);
  10345e:	c7 04 24 c0 cb 13 00 	movl   $0x13cbc0,(%esp)
  103465:	e8 a6 28 00 00       	call   105d10 <release>
}
  10346a:	c9                   	leave  
  10346b:	c3                   	ret    
  10346c:	8d 74 26 00          	lea    0x0(%esi),%esi

00103470 <kalloc>:

// Allocate n bytes of physical memory.
// Returns a kernel-segment pointer.
// Returns 0 if the memory cannot be allocated.
char*
kalloc(int n)
{
  103470:	55                   	push   %ebp
  103471:	89 e5                	mov    %esp,%ebp
  103473:	83 ec 18             	sub    $0x18,%esp
  char *p;
  struct run *r, **rp;

#ifdef MEM_DEBUG
  cprintf("kalloc: %d pages\n", n / PAGE);
  printstack();
#endif
  if(n % PAGE || n <= 0)
  103476:	8b 45 08             	mov    0x8(%ebp),%eax
  103479:	25 ff 0f 00 00       	and    $0xfff,%eax
  10347e:	85 c0                	test   %eax,%eax
  103480:	75 06                	jne    103488 <kalloc+0x18>
  103482:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  103486:	7f 0c                	jg     103494 <kalloc+0x24>
    panic("kalloc");
  103488:	c7 04 24 44 a5 11 00 	movl   $0x11a544,(%esp)
  10348f:	e8 6c db ff ff       	call   101000 <panic>

  acquire(&kalloc_lock);
  103494:	c7 04 24 c0 cb 13 00 	movl   $0x13cbc0,(%esp)
  10349b:	e8 70 26 00 00       	call   105b10 <acquire>
  for(rp=&freelist; (r=*rp) != 0; rp=&r->next){
  1034a0:	c7 45 fc f4 cb 13 00 	movl   $0x13cbf4,0xfffffffc(%ebp)
  1034a7:	eb 70                	jmp    103519 <kalloc+0xa9>
    if(r->len == n){
  1034a9:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1034ac:	8b 40 04             	mov    0x4(%eax),%eax
  1034af:	3b 45 08             	cmp    0x8(%ebp),%eax
  1034b2:	75 1e                	jne    1034d2 <kalloc+0x62>
      *rp = r->next;
  1034b4:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1034b7:	8b 10                	mov    (%eax),%edx
  1034b9:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1034bc:	89 10                	mov    %edx,(%eax)
      release(&kalloc_lock);
  1034be:	c7 04 24 c0 cb 13 00 	movl   $0x13cbc0,(%esp)
  1034c5:	e8 46 28 00 00       	call   105d10 <release>
      return (char*)r;
  1034ca:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1034cd:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  1034d0:	eb 74                	jmp    103546 <kalloc+0xd6>
    }
    if(r->len > n){
  1034d2:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1034d5:	8b 40 04             	mov    0x4(%eax),%eax
  1034d8:	3b 45 08             	cmp    0x8(%ebp),%eax
  1034db:	7e 36                	jle    103513 <kalloc+0xa3>
      r->len -= n;
  1034dd:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1034e0:	8b 40 04             	mov    0x4(%eax),%eax
  1034e3:	89 c2                	mov    %eax,%edx
  1034e5:	2b 55 08             	sub    0x8(%ebp),%edx
  1034e8:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1034eb:	89 50 04             	mov    %edx,0x4(%eax)
      p = (char*)r + r->len;
  1034ee:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1034f1:	8b 40 04             	mov    0x4(%eax),%eax
  1034f4:	89 c2                	mov    %eax,%edx
  1034f6:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1034f9:	8d 04 02             	lea    (%edx,%eax,1),%eax
  1034fc:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
      release(&kalloc_lock);
  1034ff:	c7 04 24 c0 cb 13 00 	movl   $0x13cbc0,(%esp)
  103506:	e8 05 28 00 00       	call   105d10 <release>
      return p;
  10350b:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10350e:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  103511:	eb 33                	jmp    103546 <kalloc+0xd6>
  103513:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  103516:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  103519:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10351c:	8b 00                	mov    (%eax),%eax
  10351e:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  103521:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  103525:	75 82                	jne    1034a9 <kalloc+0x39>
    }
  }
  release(&kalloc_lock);
  103527:	c7 04 24 c0 cb 13 00 	movl   $0x13cbc0,(%esp)
  10352e:	e8 dd 27 00 00       	call   105d10 <release>

  cprintf("kalloc: out of memory\n");
  103533:	c7 04 24 81 a5 11 00 	movl   $0x11a581,(%esp)
  10353a:	e8 d1 d1 ff ff       	call   100710 <cprintf>
  return 0;
  10353f:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  103546:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  103549:	c9                   	leave  
  10354a:	c3                   	ret    
  10354b:	90                   	nop    
  10354c:	8d 74 26 00          	lea    0x0(%esi),%esi

00103550 <kmalloc>:

void *
kmalloc(int n)
{
  103550:	55                   	push   %ebp
  103551:	89 e5                	mov    %esp,%ebp
  103553:	83 ec 08             	sub    $0x8,%esp
#ifdef MEM_DEBUG
    cprintf("kmalloc: %d bytes\n", n);
#endif
    return kalloc(((n - 1) / PAGE + 1) * PAGE);
  103556:	8b 55 08             	mov    0x8(%ebp),%edx
  103559:	83 ea 01             	sub    $0x1,%edx
  10355c:	89 d0                	mov    %edx,%eax
  10355e:	c1 f8 1f             	sar    $0x1f,%eax
  103561:	c1 e8 14             	shr    $0x14,%eax
  103564:	01 d0                	add    %edx,%eax
  103566:	c1 f8 0c             	sar    $0xc,%eax
  103569:	83 c0 01             	add    $0x1,%eax
  10356c:	c1 e0 0c             	shl    $0xc,%eax
  10356f:	89 04 24             	mov    %eax,(%esp)
  103572:	e8 f9 fe ff ff       	call   103470 <kalloc>
}
  103577:	c9                   	leave  
  103578:	c3                   	ret    
  103579:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

00103580 <kmfree>:

void
kmfree(void *p, int n)
{
  103580:	55                   	push   %ebp
  103581:	89 e5                	mov    %esp,%ebp
  103583:	83 ec 08             	sub    $0x8,%esp
#ifdef MEM_DEBUG
    cprintf("kmfree: %d bytes\n", n);
#endif
    return kfree(p, ((n - 1) / PAGE + 1) * PAGE);
  103586:	8b 55 0c             	mov    0xc(%ebp),%edx
  103589:	83 ea 01             	sub    $0x1,%edx
  10358c:	89 d0                	mov    %edx,%eax
  10358e:	c1 f8 1f             	sar    $0x1f,%eax
  103591:	c1 e8 14             	shr    $0x14,%eax
  103594:	01 d0                	add    %edx,%eax
  103596:	c1 f8 0c             	sar    $0xc,%eax
  103599:	83 c0 01             	add    $0x1,%eax
  10359c:	c1 e0 0c             	shl    $0xc,%eax
  10359f:	8b 55 08             	mov    0x8(%ebp),%edx
  1035a2:	89 44 24 04          	mov    %eax,0x4(%esp)
  1035a6:	89 14 24             	mov    %edx,(%esp)
  1035a9:	e8 52 fd ff ff       	call   103300 <kfree>
}
  1035ae:	c9                   	leave  
  1035af:	c3                   	ret    

001035b0 <kbd_getc>:
#include "kbd.h"

int
kbd_getc(void)
{
  1035b0:	55                   	push   %ebp
  1035b1:	89 e5                	mov    %esp,%ebp
  1035b3:	83 ec 28             	sub    $0x28,%esp
  static uint shift;
  static uchar *charcode[4] = {
    normalmap, shiftmap, ctlmap, ctlmap
  };
  uint st, data, c;

  st = inb(KBSTATP);
  1035b6:	c7 04 24 64 00 00 00 	movl   $0x64,(%esp)
  1035bd:	e8 5e 01 00 00       	call   103720 <inb>
  1035c2:	0f b6 c0             	movzbl %al,%eax
  1035c5:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  if((st & KBS_DIB) == 0)
  1035c8:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  1035cb:	83 e0 01             	and    $0x1,%eax
  1035ce:	85 c0                	test   %eax,%eax
  1035d0:	75 0c                	jne    1035de <kbd_getc+0x2e>
    return -1;
  1035d2:	c7 45 e8 ff ff ff ff 	movl   $0xffffffff,0xffffffe8(%ebp)
  1035d9:	e9 33 01 00 00       	jmp    103711 <kbd_getc+0x161>
  data = inb(KBDATAP);
  1035de:	c7 04 24 60 00 00 00 	movl   $0x60,(%esp)
  1035e5:	e8 36 01 00 00       	call   103720 <inb>
  1035ea:	0f b6 c0             	movzbl %al,%eax
  1035ed:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)

  if(data == 0xE0){
  1035f0:	81 7d f8 e0 00 00 00 	cmpl   $0xe0,0xfffffff8(%ebp)
  1035f7:	75 19                	jne    103612 <kbd_getc+0x62>
    shift |= E0ESC;
  1035f9:	a1 9c cd 11 00       	mov    0x11cd9c,%eax
  1035fe:	83 c8 40             	or     $0x40,%eax
  103601:	a3 9c cd 11 00       	mov    %eax,0x11cd9c
    return 0;
  103606:	c7 45 e8 00 00 00 00 	movl   $0x0,0xffffffe8(%ebp)
  10360d:	e9 ff 00 00 00       	jmp    103711 <kbd_getc+0x161>
  } else if(data & 0x80){
  103612:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  103615:	25 80 00 00 00       	and    $0x80,%eax
  10361a:	85 c0                	test   %eax,%eax
  10361c:	74 4f                	je     10366d <kbd_getc+0xbd>
    // Key released
    data = (shift & E0ESC ? data : data & 0x7F);
  10361e:	a1 9c cd 11 00       	mov    0x11cd9c,%eax
  103623:	83 e0 40             	and    $0x40,%eax
  103626:	85 c0                	test   %eax,%eax
  103628:	75 0b                	jne    103635 <kbd_getc+0x85>
  10362a:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10362d:	83 e0 7f             	and    $0x7f,%eax
  103630:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  103633:	eb 06                	jmp    10363b <kbd_getc+0x8b>
  103635:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  103638:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  10363b:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10363e:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
    shift &= ~(shiftcode[data] | E0ESC);
  103641:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  103644:	0f b6 80 e0 c0 11 00 	movzbl 0x11c0e0(%eax),%eax
  10364b:	83 c8 40             	or     $0x40,%eax
  10364e:	0f b6 c0             	movzbl %al,%eax
  103651:	f7 d0                	not    %eax
  103653:	89 c2                	mov    %eax,%edx
  103655:	a1 9c cd 11 00       	mov    0x11cd9c,%eax
  10365a:	21 d0                	and    %edx,%eax
  10365c:	a3 9c cd 11 00       	mov    %eax,0x11cd9c
    return 0;
  103661:	c7 45 e8 00 00 00 00 	movl   $0x0,0xffffffe8(%ebp)
  103668:	e9 a4 00 00 00       	jmp    103711 <kbd_getc+0x161>
  } else if(shift & E0ESC){
  10366d:	a1 9c cd 11 00       	mov    0x11cd9c,%eax
  103672:	83 e0 40             	and    $0x40,%eax
  103675:	85 c0                	test   %eax,%eax
  103677:	74 14                	je     10368d <kbd_getc+0xdd>
    // Last character was an E0 escape; or with 0x80
    data |= 0x80;
  103679:	81 4d f8 80 00 00 00 	orl    $0x80,0xfffffff8(%ebp)
    shift &= ~E0ESC;
  103680:	a1 9c cd 11 00       	mov    0x11cd9c,%eax
  103685:	83 e0 bf             	and    $0xffffffbf,%eax
  103688:	a3 9c cd 11 00       	mov    %eax,0x11cd9c
  }

  shift |= shiftcode[data];
  10368d:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  103690:	0f b6 80 e0 c0 11 00 	movzbl 0x11c0e0(%eax),%eax
  103697:	0f b6 d0             	movzbl %al,%edx
  10369a:	a1 9c cd 11 00       	mov    0x11cd9c,%eax
  10369f:	09 d0                	or     %edx,%eax
  1036a1:	a3 9c cd 11 00       	mov    %eax,0x11cd9c
  shift ^= togglecode[data];
  1036a6:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1036a9:	0f b6 80 e0 c1 11 00 	movzbl 0x11c1e0(%eax),%eax
  1036b0:	0f b6 d0             	movzbl %al,%edx
  1036b3:	a1 9c cd 11 00       	mov    0x11cd9c,%eax
  1036b8:	31 d0                	xor    %edx,%eax
  1036ba:	a3 9c cd 11 00       	mov    %eax,0x11cd9c
  c = charcode[shift & (CTL | SHIFT)][data];
  1036bf:	a1 9c cd 11 00       	mov    0x11cd9c,%eax
  1036c4:	83 e0 03             	and    $0x3,%eax
  1036c7:	8b 14 85 e0 c5 11 00 	mov    0x11c5e0(,%eax,4),%edx
  1036ce:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1036d1:	8d 04 02             	lea    (%edx,%eax,1),%eax
  1036d4:	0f b6 00             	movzbl (%eax),%eax
  1036d7:	0f b6 c0             	movzbl %al,%eax
  1036da:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  if(shift & CAPSLOCK){
  1036dd:	a1 9c cd 11 00       	mov    0x11cd9c,%eax
  1036e2:	83 e0 08             	and    $0x8,%eax
  1036e5:	85 c0                	test   %eax,%eax
  1036e7:	74 22                	je     10370b <kbd_getc+0x15b>
    if('a' <= c && c <= 'z')
  1036e9:	83 7d fc 60          	cmpl   $0x60,0xfffffffc(%ebp)
  1036ed:	76 0c                	jbe    1036fb <kbd_getc+0x14b>
  1036ef:	83 7d fc 7a          	cmpl   $0x7a,0xfffffffc(%ebp)
  1036f3:	77 06                	ja     1036fb <kbd_getc+0x14b>
      c += 'A' - 'a';
  1036f5:	83 6d fc 20          	subl   $0x20,0xfffffffc(%ebp)
  1036f9:	eb 10                	jmp    10370b <kbd_getc+0x15b>
    else if('A' <= c && c <= 'Z')
  1036fb:	83 7d fc 40          	cmpl   $0x40,0xfffffffc(%ebp)
  1036ff:	76 0a                	jbe    10370b <kbd_getc+0x15b>
  103701:	83 7d fc 5a          	cmpl   $0x5a,0xfffffffc(%ebp)
  103705:	77 04                	ja     10370b <kbd_getc+0x15b>
      c += 'a' - 'A';
  103707:	83 45 fc 20          	addl   $0x20,0xfffffffc(%ebp)
  }
  return c;
  10370b:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10370e:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
  103711:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
}
  103714:	c9                   	leave  
  103715:	c3                   	ret    
  103716:	8d 76 00             	lea    0x0(%esi),%esi
  103719:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00103720 <inb>:
// Routines to let C code use special x86 instructions.

static inline uchar
inb(ushort port)
{
  103720:	55                   	push   %ebp
  103721:	89 e5                	mov    %esp,%ebp
  103723:	83 ec 14             	sub    $0x14,%esp
  103726:	8b 45 08             	mov    0x8(%ebp),%eax
  103729:	66 89 45 ec          	mov    %ax,0xffffffec(%ebp)
  uchar data;

  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
  10372d:	0f b7 55 ec          	movzwl 0xffffffec(%ebp),%edx
  103731:	ec                   	in     (%dx),%al
  103732:	88 45 ff             	mov    %al,0xffffffff(%ebp)
  return data;
  103735:	0f b6 45 ff          	movzbl 0xffffffff(%ebp),%eax
}
  103739:	c9                   	leave  
  10373a:	c3                   	ret    
  10373b:	90                   	nop    
  10373c:	8d 74 26 00          	lea    0x0(%esi),%esi

00103740 <kbd_intr>:

void
kbd_intr(void)
{
  103740:	55                   	push   %ebp
  103741:	89 e5                	mov    %esp,%ebp
  103743:	83 ec 08             	sub    $0x8,%esp
  console_intr(kbd_getc);
  103746:	c7 04 24 b0 35 10 00 	movl   $0x1035b0,(%esp)
  10374d:	e8 9e d3 ff ff       	call   100af0 <console_intr>
}
  103752:	c9                   	leave  
  103753:	c3                   	ret    
  103754:	90                   	nop    
  103755:	90                   	nop    
  103756:	90                   	nop    
  103757:	90                   	nop    
  103758:	90                   	nop    
  103759:	90                   	nop    
  10375a:	90                   	nop    
  10375b:	90                   	nop    
  10375c:	90                   	nop    
  10375d:	90                   	nop    
  10375e:	90                   	nop    
  10375f:	90                   	nop    

00103760 <lapic_init>:
volatile uint *lapic;  // Initialized in mp.c

void
lapic_init(int c)
{
  103760:	55                   	push   %ebp
  103761:	89 e5                	mov    %esp,%ebp
  if(!lapic) 
  103763:	a1 f8 cb 13 00       	mov    0x13cbf8,%eax
  103768:	85 c0                	test   %eax,%eax
  10376a:	0f 84 1a 01 00 00    	je     10388a <lapic_init+0x12a>
    return;

  // Enable local APIC; set spurious interrupt vector.
  lapic[SVR] = ENABLE | (IRQ_OFFSET+IRQ_SPURIOUS);
  103770:	a1 f8 cb 13 00       	mov    0x13cbf8,%eax
  103775:	05 f0 00 00 00       	add    $0xf0,%eax
  10377a:	c7 00 3f 01 00 00    	movl   $0x13f,(%eax)

  // The timer repeatedly counts down at bus frequency
  // from lapic[TICR] and then issues an interrupt.  
  // Lapic[TCCR] is the current counter value.
  // If xv6 cared more about precise timekeeping, the
  // values of TICR and TCCR would be calibrated using
  // an external time source.
  lapic[TDCR] = X1;
  103780:	a1 f8 cb 13 00       	mov    0x13cbf8,%eax
  103785:	05 e0 03 00 00       	add    $0x3e0,%eax
  10378a:	c7 00 0b 00 00 00    	movl   $0xb,(%eax)
  lapic[TICR] = 10000000;
  103790:	a1 f8 cb 13 00       	mov    0x13cbf8,%eax
  103795:	05 80 03 00 00       	add    $0x380,%eax
  10379a:	c7 00 80 96 98 00    	movl   $0x989680,(%eax)
  lapic[TCCR] = 10000000;
  1037a0:	a1 f8 cb 13 00       	mov    0x13cbf8,%eax
  1037a5:	05 90 03 00 00       	add    $0x390,%eax
  1037aa:	c7 00 80 96 98 00    	movl   $0x989680,(%eax)
  lapic[TIMER] = PERIODIC | (IRQ_OFFSET + IRQ_TIMER);
  1037b0:	a1 f8 cb 13 00       	mov    0x13cbf8,%eax
  1037b5:	05 20 03 00 00       	add    $0x320,%eax
  1037ba:	c7 00 20 00 02 00    	movl   $0x20020,(%eax)

  // Disable logical interrupt lines.
  lapic[LINT0] = MASKED;
  1037c0:	a1 f8 cb 13 00       	mov    0x13cbf8,%eax
  1037c5:	05 50 03 00 00       	add    $0x350,%eax
  1037ca:	c7 00 00 00 01 00    	movl   $0x10000,(%eax)
  lapic[LINT1] = MASKED;
  1037d0:	a1 f8 cb 13 00       	mov    0x13cbf8,%eax
  1037d5:	05 60 03 00 00       	add    $0x360,%eax
  1037da:	c7 00 00 00 01 00    	movl   $0x10000,(%eax)

  // Disable performance counter overflow interrupts
  // on machines that provide that interrupt entry.
  if(((lapic[VER]>>16) & 0xFF) >= 4)
  1037e0:	a1 f8 cb 13 00       	mov    0x13cbf8,%eax
  1037e5:	83 c0 30             	add    $0x30,%eax
  1037e8:	8b 00                	mov    (%eax),%eax
  1037ea:	c1 e8 10             	shr    $0x10,%eax
  1037ed:	25 ff 00 00 00       	and    $0xff,%eax
  1037f2:	83 f8 03             	cmp    $0x3,%eax
  1037f5:	76 10                	jbe    103807 <lapic_init+0xa7>
    lapic[PCINT] = MASKED;
  1037f7:	a1 f8 cb 13 00       	mov    0x13cbf8,%eax
  1037fc:	05 40 03 00 00       	add    $0x340,%eax
  103801:	c7 00 00 00 01 00    	movl   $0x10000,(%eax)

  // Map error interrupt to IRQ_ERROR.
  lapic[ERROR] = IRQ_OFFSET+IRQ_ERROR;
  103807:	a1 f8 cb 13 00       	mov    0x13cbf8,%eax
  10380c:	05 70 03 00 00       	add    $0x370,%eax
  103811:	c7 00 33 00 00 00    	movl   $0x33,(%eax)

  // Clear error status register (requires back-to-back writes).
  lapic[ESR] = 0;
  103817:	a1 f8 cb 13 00       	mov    0x13cbf8,%eax
  10381c:	05 80 02 00 00       	add    $0x280,%eax
  103821:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  lapic[ESR] = 0;
  103827:	a1 f8 cb 13 00       	mov    0x13cbf8,%eax
  10382c:	05 80 02 00 00       	add    $0x280,%eax
  103831:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

  // Ack any outstanding interrupts.
  lapic[EOI] = 0;
  103837:	a1 f8 cb 13 00       	mov    0x13cbf8,%eax
  10383c:	05 b0 00 00 00       	add    $0xb0,%eax
  103841:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

  // Send an Init Level De-Assert to synchronise arbitration ID's.
  lapic[ICRHI] = 0;
  103847:	a1 f8 cb 13 00       	mov    0x13cbf8,%eax
  10384c:	05 10 03 00 00       	add    $0x310,%eax
  103851:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  lapic[ICRLO] = BCAST | INIT | LEVEL;
  103857:	a1 f8 cb 13 00       	mov    0x13cbf8,%eax
  10385c:	05 00 03 00 00       	add    $0x300,%eax
  103861:	c7 00 00 85 08 00    	movl   $0x88500,(%eax)
  while(lapic[ICRLO] & DELIVS)
  103867:	a1 f8 cb 13 00       	mov    0x13cbf8,%eax
  10386c:	05 00 03 00 00       	add    $0x300,%eax
  103871:	8b 00                	mov    (%eax),%eax
  103873:	25 00 10 00 00       	and    $0x1000,%eax
  103878:	85 c0                	test   %eax,%eax
  10387a:	75 eb                	jne    103867 <lapic_init+0x107>
    ;

  // Enable interrupts on the APIC (but not on the processor).
  lapic[TPR] = 0;
  10387c:	a1 f8 cb 13 00       	mov    0x13cbf8,%eax
  103881:	83 e8 80             	sub    $0xffffff80,%eax
  103884:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
  10388a:	5d                   	pop    %ebp
  10388b:	c3                   	ret    
  10388c:	8d 74 26 00          	lea    0x0(%esi),%esi

00103890 <cpu>:

int
cpu(void)
{
  103890:	55                   	push   %ebp
  103891:	89 e5                	mov    %esp,%ebp
  103893:	83 ec 04             	sub    $0x4,%esp
  if(lapic)
  103896:	a1 f8 cb 13 00       	mov    0x13cbf8,%eax
  10389b:	85 c0                	test   %eax,%eax
  10389d:	74 12                	je     1038b1 <cpu+0x21>
    return lapic[ID]>>24;
  10389f:	a1 f8 cb 13 00       	mov    0x13cbf8,%eax
  1038a4:	83 c0 20             	add    $0x20,%eax
  1038a7:	8b 00                	mov    (%eax),%eax
  1038a9:	c1 e8 18             	shr    $0x18,%eax
  1038ac:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  1038af:	eb 07                	jmp    1038b8 <cpu+0x28>
  return 0;
  1038b1:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
  1038b8:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
}
  1038bb:	c9                   	leave  
  1038bc:	c3                   	ret    
  1038bd:	8d 76 00             	lea    0x0(%esi),%esi

001038c0 <lapic_eoi>:

// Acknowledge interrupt.
void
lapic_eoi(void)
{
  1038c0:	55                   	push   %ebp
  1038c1:	89 e5                	mov    %esp,%ebp
  if(lapic)
  1038c3:	a1 f8 cb 13 00       	mov    0x13cbf8,%eax
  1038c8:	85 c0                	test   %eax,%eax
  1038ca:	74 10                	je     1038dc <lapic_eoi+0x1c>
    lapic[EOI] = 0;
  1038cc:	a1 f8 cb 13 00       	mov    0x13cbf8,%eax
  1038d1:	05 b0 00 00 00       	add    $0xb0,%eax
  1038d6:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
  1038dc:	5d                   	pop    %ebp
  1038dd:	c3                   	ret    
  1038de:	89 f6                	mov    %esi,%esi

001038e0 <microdelay>:

// Spin for a given number of microseconds.
// On real hardware would want to tune this dynamically.
static void
microdelay(int us)
{
  1038e0:	55                   	push   %ebp
  1038e1:	89 e5                	mov    %esp,%ebp
  1038e3:	83 ec 10             	sub    $0x10,%esp
  volatile int j = 0;
  1038e6:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
  
  while(us-- > 0)
  1038ed:	eb 1c                	jmp    10390b <microdelay+0x2b>
    for(j=0; j<10000; j++);
  1038ef:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
  1038f6:	eb 09                	jmp    103901 <microdelay+0x21>
  1038f8:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1038fb:	83 c0 01             	add    $0x1,%eax
  1038fe:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  103901:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  103904:	3d 0f 27 00 00       	cmp    $0x270f,%eax
  103909:	7e ed                	jle    1038f8 <microdelay+0x18>
  10390b:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  10390f:	0f 9f c0             	setg   %al
  103912:	83 6d 08 01          	subl   $0x1,0x8(%ebp)
  103916:	84 c0                	test   %al,%al
  103918:	75 d5                	jne    1038ef <microdelay+0xf>
}
  10391a:	c9                   	leave  
  10391b:	c3                   	ret    
  10391c:	8d 74 26 00          	lea    0x0(%esi),%esi

00103920 <lapic_startap>:

// Start additional processor running bootstrap code at addr.
// See Appendix B of MultiProcessor Specification.
void
lapic_startap(uchar apicid, uint addr)
{
  103920:	55                   	push   %ebp
  103921:	89 e5                	mov    %esp,%ebp
  103923:	83 ec 18             	sub    $0x18,%esp
  103926:	8b 45 08             	mov    0x8(%ebp),%eax
  103929:	88 45 ec             	mov    %al,0xffffffec(%ebp)
  int i;
  volatile int j = 0;
  10392c:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)

  // Send INIT interrupt to reset other CPU.
  lapic[ICRHI] = apicid<<24;
  103933:	a1 f8 cb 13 00       	mov    0x13cbf8,%eax
  103938:	8d 90 10 03 00 00    	lea    0x310(%eax),%edx
  10393e:	0f b6 45 ec          	movzbl 0xffffffec(%ebp),%eax
  103942:	c1 e0 18             	shl    $0x18,%eax
  103945:	89 02                	mov    %eax,(%edx)
  lapic[ICRLO] = INIT | LEVEL;
  103947:	a1 f8 cb 13 00       	mov    0x13cbf8,%eax
  10394c:	05 00 03 00 00       	add    $0x300,%eax
  103951:	c7 00 00 85 00 00    	movl   $0x8500,(%eax)
  microdelay(10);
  103957:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
  10395e:	e8 7d ff ff ff       	call   1038e0 <microdelay>
  
  // Send startup IPI (twice!) to enter bootstrap code.
  for(i = 0; i < 2; i++){
  103963:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
  10396a:	eb 4a                	jmp    1039b6 <lapic_startap+0x96>
    lapic[ICRHI] = apicid<<24;
  10396c:	a1 f8 cb 13 00       	mov    0x13cbf8,%eax
  103971:	8d 90 10 03 00 00    	lea    0x310(%eax),%edx
  103977:	0f b6 45 ec          	movzbl 0xffffffec(%ebp),%eax
  10397b:	c1 e0 18             	shl    $0x18,%eax
  10397e:	89 02                	mov    %eax,(%edx)
    lapic[ICRLO] = STARTUP | (addr>>12);
  103980:	a1 f8 cb 13 00       	mov    0x13cbf8,%eax
  103985:	8d 90 00 03 00 00    	lea    0x300(%eax),%edx
  10398b:	8b 45 0c             	mov    0xc(%ebp),%eax
  10398e:	c1 e8 0c             	shr    $0xc,%eax
  103991:	80 cc 06             	or     $0x6,%ah
  103994:	89 02                	mov    %eax,(%edx)
    for(j=0; j<10000; j++);  // 200us
  103996:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)
  10399d:	eb 09                	jmp    1039a8 <lapic_startap+0x88>
  10399f:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1039a2:	83 c0 01             	add    $0x1,%eax
  1039a5:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  1039a8:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1039ab:	3d 0f 27 00 00       	cmp    $0x270f,%eax
  1039b0:	7e ed                	jle    10399f <lapic_startap+0x7f>
  1039b2:	83 45 fc 01          	addl   $0x1,0xfffffffc(%ebp)
  1039b6:	83 7d fc 01          	cmpl   $0x1,0xfffffffc(%ebp)
  1039ba:	7e b0                	jle    10396c <lapic_startap+0x4c>
  }
}
  1039bc:	c9                   	leave  
  1039bd:	c3                   	ret    
  1039be:	90                   	nop    
  1039bf:	90                   	nop    

001039c0 <main>:

// Bootstrap processor starts running C code here.
int
main(void)
{
  1039c0:	8d 4c 24 04          	lea    0x4(%esp),%ecx
  1039c4:	83 e4 f0             	and    $0xfffffff0,%esp
  1039c7:	ff 71 fc             	pushl  0xfffffffc(%ecx)
  1039ca:	55                   	push   %ebp
  1039cb:	89 e5                	mov    %esp,%ebp
  1039cd:	51                   	push   %ecx
  1039ce:	83 ec 24             	sub    $0x24,%esp
  int i;
  static volatile int bcpu;  // cannot be on stack
  extern char edata[], end[];

  // clear BSS
  memset(edata, 0, end - edata);
  1039d1:	ba 70 16 14 00       	mov    $0x141670,%edx
  1039d6:	b8 f2 cc 11 00       	mov    $0x11ccf2,%eax
  1039db:	89 d1                	mov    %edx,%ecx
  1039dd:	29 c1                	sub    %eax,%ecx
  1039df:	89 c8                	mov    %ecx,%eax
  1039e1:	89 44 24 08          	mov    %eax,0x8(%esp)
  1039e5:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  1039ec:	00 
  1039ed:	c7 04 24 f2 cc 11 00 	movl   $0x11ccf2,(%esp)
  1039f4:	e8 d7 24 00 00       	call   105ed0 <memset>

  // Prevent release() from enabling interrupts.
  for(i=0; i<NCPU; i++)
  1039f9:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)
  103a00:	eb 17                	jmp    103a19 <main+0x59>
    cpus[i].nlock = 1;
  103a02:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  103a05:	69 c0 ec 10 00 00    	imul   $0x10ec,%eax,%eax
  103a0b:	c7 80 e0 dc 13 00 01 	movl   $0x1,0x13dce0(%eax)
  103a12:	00 00 00 
  103a15:	83 45 f8 01          	addl   $0x1,0xfffffff8(%ebp)
  103a19:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  103a1d:	7e e3                	jle    103a02 <main+0x42>

//  mp_init(); // collect info about this machine
  bcpu = mp_bcpu();
  103a1f:	e8 1c 03 00 00       	call   103d40 <mp_bcpu>
  103a24:	a3 a0 cd 11 00       	mov    %eax,0x11cda0

  // Switch to bootstrap processor's stack
  asm volatile("movl %0, %%esp" : : "r" (cpus[bcpu].mpstack+MPSTACK-32));
  103a29:	a1 a0 cd 11 00       	mov    0x11cda0,%eax
  103a2e:	69 c0 ec 10 00 00    	imul   $0x10ec,%eax,%eax
  103a34:	05 b0 00 00 00       	add    $0xb0,%eax
  103a39:	05 20 cc 13 00       	add    $0x13cc20,%eax
  103a3e:	83 c0 0c             	add    $0xc,%eax
  103a41:	05 e0 0f 00 00       	add    $0xfe0,%eax
  103a46:	89 c4                	mov    %eax,%esp
  asm volatile("movl %0, %%ebp" : : "r" (cpus[bcpu].mpstack+MPSTACK));
  103a48:	a1 a0 cd 11 00       	mov    0x11cda0,%eax
  103a4d:	69 c0 ec 10 00 00    	imul   $0x10ec,%eax,%eax
  103a53:	05 b0 00 00 00       	add    $0xb0,%eax
  103a58:	05 20 cc 13 00       	add    $0x13cc20,%eax
  103a5d:	83 c0 0c             	add    $0xc,%eax
  103a60:	05 00 10 00 00       	add    $0x1000,%eax
  103a65:	89 c5                	mov    %eax,%ebp

  lapic_init(bcpu);
  103a67:	a1 a0 cd 11 00       	mov    0x11cda0,%eax
  103a6c:	89 04 24             	mov    %eax,(%esp)
  103a6f:	e8 ec fc ff ff       	call   103760 <lapic_init>
  cprintf("\ncpu%d: starting xv6\n\n", cpu());
  103a74:	e8 17 fe ff ff       	call   103890 <cpu>
  103a79:	89 44 24 04          	mov    %eax,0x4(%esp)
  103a7d:	c7 04 24 98 a5 11 00 	movl   $0x11a598,(%esp)
  103a84:	e8 87 cc ff ff       	call   100710 <cprintf>

  pinit();         // process table
  103a89:	e8 12 0d 00 00       	call   1047a0 <pinit>
  binit();         // buffer cache
  103a8e:	e8 6d c5 ff ff       	call   100000 <binit>
  pic_init();      // interrupt controller
  103a93:	e8 88 07 00 00       	call   104220 <pic_init>
  ioapic_init();   // another interrupt controller
  103a98:	e8 e3 f6 ff ff       	call   103180 <ioapic_init>
  kinit();         // physical memory allocator
  103a9d:	e8 ee f7 ff ff       	call   103290 <kinit>
  tvinit();        // trap vectors
  103aa2:	e8 f9 44 00 00       	call   107fa0 <tvinit>
  idtinit();       // interrupt descriptor table
  103aa7:	e8 74 46 00 00       	call   108120 <idtinit>
  fileinit();      // file table
  103aac:	e8 7f da ff ff       	call   101530 <fileinit>
  iinit();         // inode cache
  103ab1:	e8 ba e1 ff ff       	call   101c70 <iinit>
  setupsegs(0);    // segments & TSS
  103ab6:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  103abd:	e8 ae 0e 00 00       	call   104970 <setupsegs>
  console_init();  // I/O devices & their interrupts
  103ac2:	e8 59 d4 ff ff       	call   100f20 <console_init>
  ide_init();      // disk
  103ac7:	e8 74 f2 ff ff       	call   102d40 <ide_init>

  // lwIP init
  memp_init();
  103acc:	e8 9f ad 00 00       	call   10e870 <memp_init>
  mem_init();
  103ad1:	e8 2a a9 00 00       	call   10e400 <mem_init>
  netif_init();
  103ad6:	e8 65 b3 00 00       	call   10ee40 <netif_init>
  pbuf_init();
  103adb:	e8 80 b3 00 00       	call   10ee60 <pbuf_init>
  tcpip_init(0, 0);
  103ae0:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  103ae7:	00 
  103ae8:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  103aef:	e8 1c 62 01 00       	call   119d10 <tcpip_init>

  pci_init();      // PCI
  103af4:	e8 f7 5d 00 00       	call   1098f0 <pci_init>
  bootothers();    // boot other CPUs
  103af9:	e8 92 01 00 00       	call   103c90 <bootothers>
  if(!ismp)
  103afe:	a1 00 cc 13 00       	mov    0x13cc00,%eax
  103b03:	85 c0                	test   %eax,%eax
  103b05:	75 05                	jne    103b0c <main+0x14c>
    timer_init(); // uniprocessor timer
  103b07:	e8 e4 43 00 00       	call   107ef0 <timer_init>
  userinit();      // first user process
  103b0c:	e8 df 14 00 00       	call   104ff0 <userinit>

  // enable interrupts on this processor.
  cpus[cpu()].nlock--;
  103b11:	e8 7a fd ff ff       	call   103890 <cpu>
  103b16:	89 c1                	mov    %eax,%ecx
  103b18:	69 c1 ec 10 00 00    	imul   $0x10ec,%ecx,%eax
  103b1e:	8b 80 e0 dc 13 00    	mov    0x13dce0(%eax),%eax
  103b24:	8d 50 ff             	lea    0xffffffff(%eax),%edx
  103b27:	69 c1 ec 10 00 00    	imul   $0x10ec,%ecx,%eax
  103b2d:	89 90 e0 dc 13 00    	mov    %edx,0x13dce0(%eax)
  if (cpus[cpu()].nlock == 0)
  103b33:	e8 58 fd ff ff       	call   103890 <cpu>
  103b38:	69 c0 ec 10 00 00    	imul   $0x10ec,%eax,%eax
  103b3e:	8b 80 e0 dc 13 00    	mov    0x13dce0(%eax),%eax
  103b44:	85 c0                	test   %eax,%eax
  103b46:	75 05                	jne    103b4d <main+0x18d>
    sti();
  103b48:	e8 13 00 00 00       	call   103b60 <sti>

  scheduler();
  103b4d:	e8 1e 16 00 00       	call   105170 <scheduler>
  103b52:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi
  103b59:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00103b60 <sti>:
}

static inline void
sti(void)
{
  103b60:	55                   	push   %ebp
  103b61:	89 e5                	mov    %esp,%ebp
  asm volatile("sti");
  103b63:	fb                   	sti    
}
  103b64:	5d                   	pop    %ebp
  103b65:	c3                   	ret    
  103b66:	8d 76 00             	lea    0x0(%esi),%esi
  103b69:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00103b70 <mpmain>:
}

// Additional processors start here.
static void
mpmain(void)
{
  103b70:	55                   	push   %ebp
  103b71:	89 e5                	mov    %esp,%ebp
  103b73:	83 ec 18             	sub    $0x18,%esp
  cprintf("cpu%d: starting\n", cpu());
  103b76:	e8 15 fd ff ff       	call   103890 <cpu>
  103b7b:	89 44 24 04          	mov    %eax,0x4(%esp)
  103b7f:	c7 04 24 af a5 11 00 	movl   $0x11a5af,(%esp)
  103b86:	e8 85 cb ff ff       	call   100710 <cprintf>
  idtinit();
  103b8b:	e8 90 45 00 00       	call   108120 <idtinit>
  lapic_init(cpu());
  103b90:	e8 fb fc ff ff       	call   103890 <cpu>
  103b95:	89 04 24             	mov    %eax,(%esp)
  103b98:	e8 c3 fb ff ff       	call   103760 <lapic_init>
  setupsegs(0);
  103b9d:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  103ba4:	e8 c7 0d 00 00       	call   104970 <setupsegs>
  cpuid(0, 0, 0, 0, 0);  // memory barrier
  103ba9:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  103bb0:	00 
  103bb1:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  103bb8:	00 
  103bb9:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  103bc0:	00 
  103bc1:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  103bc8:	00 
  103bc9:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  103bd0:	e8 5b 00 00 00       	call   103c30 <cpuid>
  cpus[cpu()].booted = 1;
  103bd5:	e8 b6 fc ff ff       	call   103890 <cpu>
  103bda:	69 c0 ec 10 00 00    	imul   $0x10ec,%eax,%eax
  103be0:	c7 80 dc dc 13 00 01 	movl   $0x1,0x13dcdc(%eax)
  103be7:	00 00 00 

  // Enable interrupts on this processor.
  cpus[cpu()].nlock--;
  103bea:	e8 a1 fc ff ff       	call   103890 <cpu>
  103bef:	89 c1                	mov    %eax,%ecx
  103bf1:	69 c1 ec 10 00 00    	imul   $0x10ec,%ecx,%eax
  103bf7:	8b 80 e0 dc 13 00    	mov    0x13dce0(%eax),%eax
  103bfd:	8d 50 ff             	lea    0xffffffff(%eax),%edx
  103c00:	69 c1 ec 10 00 00    	imul   $0x10ec,%ecx,%eax
  103c06:	89 90 e0 dc 13 00    	mov    %edx,0x13dce0(%eax)
  if (cpus[cpu()].nlock == 0)
  103c0c:	e8 7f fc ff ff       	call   103890 <cpu>
  103c11:	69 c0 ec 10 00 00    	imul   $0x10ec,%eax,%eax
  103c17:	8b 80 e0 dc 13 00    	mov    0x13dce0(%eax),%eax
  103c1d:	85 c0                	test   %eax,%eax
  103c1f:	75 05                	jne    103c26 <mpmain+0xb6>
    sti();
  103c21:	e8 3a ff ff ff       	call   103b60 <sti>

  scheduler();
  103c26:	e8 45 15 00 00       	call   105170 <scheduler>
  103c2b:	90                   	nop    
  103c2c:	8d 74 26 00          	lea    0x0(%esi),%esi

00103c30 <cpuid>:
}

static inline void
cpuid(uint info, uint *eaxp, uint *ebxp, uint *ecxp, uint *edxp)
{
  103c30:	55                   	push   %ebp
  103c31:	89 e5                	mov    %esp,%ebp
  103c33:	53                   	push   %ebx
  103c34:	83 ec 10             	sub    $0x10,%esp
  uint eax, ebx, ecx, edx;

  asm volatile("cpuid" :
  103c37:	8b 45 08             	mov    0x8(%ebp),%eax
  103c3a:	0f a2                	cpuid  
  103c3c:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  103c3f:	89 5d f0             	mov    %ebx,0xfffffff0(%ebp)
  103c42:	89 4d f4             	mov    %ecx,0xfffffff4(%ebp)
  103c45:	89 55 f8             	mov    %edx,0xfffffff8(%ebp)
               "=a" (eax), "=b" (ebx), "=c" (ecx), "=d" (edx) :
               "a" (info));
  if(eaxp)
  103c48:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  103c4c:	74 08                	je     103c56 <cpuid+0x26>
    *eaxp = eax;
  103c4e:	8b 55 0c             	mov    0xc(%ebp),%edx
  103c51:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  103c54:	89 02                	mov    %eax,(%edx)
  if(ebxp)
  103c56:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  103c5a:	74 08                	je     103c64 <cpuid+0x34>
    *ebxp = ebx;
  103c5c:	8b 55 10             	mov    0x10(%ebp),%edx
  103c5f:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  103c62:	89 02                	mov    %eax,(%edx)
  if(ecxp)
  103c64:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
  103c68:	74 08                	je     103c72 <cpuid+0x42>
    *ecxp = ecx;
  103c6a:	8b 55 14             	mov    0x14(%ebp),%edx
  103c6d:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  103c70:	89 02                	mov    %eax,(%edx)
  if(edxp)
  103c72:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
  103c76:	74 08                	je     103c80 <cpuid+0x50>
    *edxp = edx;
  103c78:	8b 55 18             	mov    0x18(%ebp),%edx
  103c7b:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  103c7e:	89 02                	mov    %eax,(%edx)
}
  103c80:	83 c4 10             	add    $0x10,%esp
  103c83:	5b                   	pop    %ebx
  103c84:	5d                   	pop    %ebp
  103c85:	c3                   	ret    
  103c86:	8d 76 00             	lea    0x0(%esi),%esi
  103c89:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00103c90 <bootothers>:
}

static void
bootothers(void)
{
  103c90:	55                   	push   %ebp
  103c91:	89 e5                	mov    %esp,%ebp
  103c93:	83 ec 28             	sub    $0x28,%esp
  extern uchar _binary_bootother_start[], _binary_bootother_size[];
  uchar *code;
  struct cpu *c;

  // Write bootstrap code to unused memory at 0x7000.
  code = (uchar*)0x7000;
  103c96:	c7 45 f8 00 70 00 00 	movl   $0x7000,0xfffffff8(%ebp)
  memmove(code, _binary_bootother_start, (uint)_binary_bootother_size);
  103c9d:	b8 5a 00 00 00       	mov    $0x5a,%eax
  103ca2:	89 44 24 08          	mov    %eax,0x8(%esp)
  103ca6:	c7 44 24 04 98 cc 11 	movl   $0x11cc98,0x4(%esp)
  103cad:	00 
  103cae:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  103cb1:	89 04 24             	mov    %eax,(%esp)
  103cb4:	e8 a7 22 00 00       	call   105f60 <memmove>

  for(c = cpus; c < cpus+ncpu; c++){
  103cb9:	c7 45 fc 20 cc 13 00 	movl   $0x13cc20,0xfffffffc(%ebp)
  103cc0:	eb 66                	jmp    103d28 <bootothers+0x98>
    if(c == cpus+cpu())  // We've started already.
  103cc2:	e8 c9 fb ff ff       	call   103890 <cpu>
  103cc7:	69 c0 ec 10 00 00    	imul   $0x10ec,%eax,%eax
  103ccd:	05 20 cc 13 00       	add    $0x13cc20,%eax
  103cd2:	3b 45 fc             	cmp    0xfffffffc(%ebp),%eax
  103cd5:	74 4a                	je     103d21 <bootothers+0x91>
      continue;

    // Fill in %esp, %eip and start code on cpu.
    *(void**)(code-4) = c->mpstack + MPSTACK;
  103cd7:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  103cda:	83 e8 04             	sub    $0x4,%eax
  103cdd:	89 c2                	mov    %eax,%edx
  103cdf:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  103ce2:	05 bc 00 00 00       	add    $0xbc,%eax
  103ce7:	05 00 10 00 00       	add    $0x1000,%eax
  103cec:	89 02                	mov    %eax,(%edx)
    *(void**)(code-8) = mpmain;
  103cee:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  103cf1:	83 e8 08             	sub    $0x8,%eax
  103cf4:	c7 00 70 3b 10 00    	movl   $0x103b70,(%eax)
    lapic_startap(c->apicid, (uint)code);
  103cfa:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  103cfd:	89 c2                	mov    %eax,%edx
  103cff:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  103d02:	0f b6 00             	movzbl (%eax),%eax
  103d05:	0f b6 c0             	movzbl %al,%eax
  103d08:	89 54 24 04          	mov    %edx,0x4(%esp)
  103d0c:	89 04 24             	mov    %eax,(%esp)
  103d0f:	e8 0c fc ff ff       	call   103920 <lapic_startap>

    // Wait for cpu to get through bootstrap.
    while(c->booted == 0)
  103d14:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  103d17:	8b 80 bc 10 00 00    	mov    0x10bc(%eax),%eax
  103d1d:	85 c0                	test   %eax,%eax
  103d1f:	74 f3                	je     103d14 <bootothers+0x84>
  103d21:	81 45 fc ec 10 00 00 	addl   $0x10ec,0xfffffffc(%ebp)
  103d28:	a1 0c dd 13 00       	mov    0x13dd0c,%eax
  103d2d:	69 c0 ec 10 00 00    	imul   $0x10ec,%eax,%eax
  103d33:	05 20 cc 13 00       	add    $0x13cc20,%eax
  103d38:	3b 45 fc             	cmp    0xfffffffc(%ebp),%eax
  103d3b:	77 85                	ja     103cc2 <bootothers+0x32>
      ;
  }
}
  103d3d:	c9                   	leave  
  103d3e:	c3                   	ret    
  103d3f:	90                   	nop    

00103d40 <mp_bcpu>:
uchar ioapic_id;

int
mp_bcpu(void)
{
  103d40:	55                   	push   %ebp
  103d41:	89 e5                	mov    %esp,%ebp
  return bcpu-cpus;
  103d43:	a1 a4 cd 11 00       	mov    0x11cda4,%eax
  103d48:	89 c2                	mov    %eax,%edx
  103d4a:	b8 20 cc 13 00       	mov    $0x13cc20,%eax
  103d4f:	89 d1                	mov    %edx,%ecx
  103d51:	29 c1                	sub    %eax,%ecx
  103d53:	89 c8                	mov    %ecx,%eax
  103d55:	c1 f8 02             	sar    $0x2,%eax
  103d58:	69 c0 f3 34 60 ab    	imul   $0xab6034f3,%eax,%eax
}
  103d5e:	5d                   	pop    %ebp
  103d5f:	c3                   	ret    

00103d60 <sum>:

static uchar
sum(uchar *addr, int len)
{
  103d60:	55                   	push   %ebp
  103d61:	89 e5                	mov    %esp,%ebp
  103d63:	83 ec 10             	sub    $0x10,%esp
  int i, sum;
  
  sum = 0;
  103d66:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
  for(i=0; i<len; i++)
  103d6d:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)
  103d74:	eb 13                	jmp    103d89 <sum+0x29>
    sum += addr[i];
  103d76:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  103d79:	03 45 08             	add    0x8(%ebp),%eax
  103d7c:	0f b6 00             	movzbl (%eax),%eax
  103d7f:	0f b6 c0             	movzbl %al,%eax
  103d82:	01 45 fc             	add    %eax,0xfffffffc(%ebp)
  103d85:	83 45 f8 01          	addl   $0x1,0xfffffff8(%ebp)
  103d89:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  103d8c:	3b 45 0c             	cmp    0xc(%ebp),%eax
  103d8f:	7c e5                	jl     103d76 <sum+0x16>
  return sum;
  103d91:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  103d94:	0f b6 c0             	movzbl %al,%eax
}
  103d97:	c9                   	leave  
  103d98:	c3                   	ret    
  103d99:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

00103da0 <mp_search1>:

// Look for an MP structure in the len bytes at addr.
static struct mp*
mp_search1(uchar *addr, int len)
{
  103da0:	55                   	push   %ebp
  103da1:	89 e5                	mov    %esp,%ebp
  103da3:	83 ec 28             	sub    $0x28,%esp
  uchar *e, *p;

  e = addr+len;
  103da6:	8b 45 0c             	mov    0xc(%ebp),%eax
  103da9:	03 45 08             	add    0x8(%ebp),%eax
  103dac:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  for(p = addr; p < e; p += sizeof(struct mp))
  103daf:	8b 45 08             	mov    0x8(%ebp),%eax
  103db2:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  103db5:	eb 42                	jmp    103df9 <mp_search1+0x59>
    if(memcmp(p, "_MP_", 4) == 0 && sum(p, sizeof(struct mp)) == 0)
  103db7:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  103dbe:	00 
  103dbf:	c7 44 24 04 c0 a5 11 	movl   $0x11a5c0,0x4(%esp)
  103dc6:	00 
  103dc7:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  103dca:	89 04 24             	mov    %eax,(%esp)
  103dcd:	e8 2e 21 00 00       	call   105f00 <memcmp>
  103dd2:	85 c0                	test   %eax,%eax
  103dd4:	75 1f                	jne    103df5 <mp_search1+0x55>
  103dd6:	c7 44 24 04 10 00 00 	movl   $0x10,0x4(%esp)
  103ddd:	00 
  103dde:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  103de1:	89 04 24             	mov    %eax,(%esp)
  103de4:	e8 77 ff ff ff       	call   103d60 <sum>
  103de9:	84 c0                	test   %al,%al
  103deb:	75 08                	jne    103df5 <mp_search1+0x55>
      return (struct mp*)p;
  103ded:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  103df0:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  103df3:	eb 13                	jmp    103e08 <mp_search1+0x68>
  103df5:	83 45 fc 10          	addl   $0x10,0xfffffffc(%ebp)
  103df9:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  103dfc:	3b 45 f8             	cmp    0xfffffff8(%ebp),%eax
  103dff:	72 b6                	jb     103db7 <mp_search1+0x17>
  return 0;
  103e01:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  103e08:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  103e0b:	c9                   	leave  
  103e0c:	c3                   	ret    
  103e0d:	8d 76 00             	lea    0x0(%esi),%esi

00103e10 <mp_search>:

// Search for the MP Floating Pointer Structure, which according to the
// spec is in one of the following three locations:
// 1) in the first KB of the EBDA;
// 2) in the last KB of system base memory;
// 3) in the BIOS ROM between 0xE0000 and 0xFFFFF.
static struct mp*
mp_search(void)
{
  103e10:	55                   	push   %ebp
  103e11:	89 e5                	mov    %esp,%ebp
  103e13:	83 ec 28             	sub    $0x28,%esp
  uchar *bda;
  uint p;
  struct mp *mp;

  bda = (uchar*)0x400;
  103e16:	c7 45 f4 00 04 00 00 	movl   $0x400,0xfffffff4(%ebp)
  if((p = (bda[0x0F]<<8)|bda[0x0E])){
  103e1d:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  103e20:	83 c0 0f             	add    $0xf,%eax
  103e23:	0f b6 00             	movzbl (%eax),%eax
  103e26:	0f b6 c0             	movzbl %al,%eax
  103e29:	89 c2                	mov    %eax,%edx
  103e2b:	c1 e2 08             	shl    $0x8,%edx
  103e2e:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  103e31:	83 c0 0e             	add    $0xe,%eax
  103e34:	0f b6 00             	movzbl (%eax),%eax
  103e37:	0f b6 c0             	movzbl %al,%eax
  103e3a:	09 d0                	or     %edx,%eax
  103e3c:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  103e3f:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  103e43:	74 24                	je     103e69 <mp_search+0x59>
    if((mp = mp_search1((uchar*)p, 1024)))
  103e45:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  103e48:	c7 44 24 04 00 04 00 	movl   $0x400,0x4(%esp)
  103e4f:	00 
  103e50:	89 04 24             	mov    %eax,(%esp)
  103e53:	e8 48 ff ff ff       	call   103da0 <mp_search1>
  103e58:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  103e5b:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  103e5f:	74 56                	je     103eb7 <mp_search+0xa7>
      return mp;
  103e61:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  103e64:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  103e67:	eb 65                	jmp    103ece <mp_search+0xbe>
  } else {
    p = ((bda[0x14]<<8)|bda[0x13])*1024;
  103e69:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  103e6c:	83 c0 14             	add    $0x14,%eax
  103e6f:	0f b6 00             	movzbl (%eax),%eax
  103e72:	0f b6 c0             	movzbl %al,%eax
  103e75:	89 c2                	mov    %eax,%edx
  103e77:	c1 e2 08             	shl    $0x8,%edx
  103e7a:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  103e7d:	83 c0 13             	add    $0x13,%eax
  103e80:	0f b6 00             	movzbl (%eax),%eax
  103e83:	0f b6 c0             	movzbl %al,%eax
  103e86:	09 d0                	or     %edx,%eax
  103e88:	c1 e0 0a             	shl    $0xa,%eax
  103e8b:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
    if((mp = mp_search1((uchar*)p-1024, 1024)))
  103e8e:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  103e91:	2d 00 04 00 00       	sub    $0x400,%eax
  103e96:	c7 44 24 04 00 04 00 	movl   $0x400,0x4(%esp)
  103e9d:	00 
  103e9e:	89 04 24             	mov    %eax,(%esp)
  103ea1:	e8 fa fe ff ff       	call   103da0 <mp_search1>
  103ea6:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  103ea9:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  103ead:	74 08                	je     103eb7 <mp_search+0xa7>
      return mp;
  103eaf:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  103eb2:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  103eb5:	eb 17                	jmp    103ece <mp_search+0xbe>
  }
  return mp_search1((uchar*)0xF0000, 0x10000);
  103eb7:	c7 44 24 04 00 00 01 	movl   $0x10000,0x4(%esp)
  103ebe:	00 
  103ebf:	c7 04 24 00 00 0f 00 	movl   $0xf0000,(%esp)
  103ec6:	e8 d5 fe ff ff       	call   103da0 <mp_search1>
  103ecb:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  103ece:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  103ed1:	c9                   	leave  
  103ed2:	c3                   	ret    
  103ed3:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  103ed9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00103ee0 <mp_config>:

// Search for an MP configuration table.  For now,
// don't accept the default configurations (physaddr == 0).
// Check for correct signature, calculate the checksum and,
// if correct, check the version.
// To do: check extended table checksum.
static struct mpconf*
mp_config(struct mp **pmp)
{
  103ee0:	55                   	push   %ebp
  103ee1:	89 e5                	mov    %esp,%ebp
  103ee3:	83 ec 28             	sub    $0x28,%esp
  struct mpconf *conf;
  struct mp *mp;

  if((mp = mp_search()) == 0 || mp->physaddr == 0)
  103ee6:	e8 25 ff ff ff       	call   103e10 <mp_search>
  103eeb:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  103eee:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  103ef2:	74 0a                	je     103efe <mp_config+0x1e>
  103ef4:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  103ef7:	8b 40 04             	mov    0x4(%eax),%eax
  103efa:	85 c0                	test   %eax,%eax
  103efc:	75 0c                	jne    103f0a <mp_config+0x2a>
    return 0;
  103efe:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  103f05:	e9 84 00 00 00       	jmp    103f8e <mp_config+0xae>
  conf = (struct mpconf*)mp->physaddr;
  103f0a:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  103f0d:	8b 40 04             	mov    0x4(%eax),%eax
  103f10:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  if(memcmp(conf, "PCMP", 4) != 0)
  103f13:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  103f1a:	00 
  103f1b:	c7 44 24 04 c5 a5 11 	movl   $0x11a5c5,0x4(%esp)
  103f22:	00 
  103f23:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  103f26:	89 04 24             	mov    %eax,(%esp)
  103f29:	e8 d2 1f 00 00       	call   105f00 <memcmp>
  103f2e:	85 c0                	test   %eax,%eax
  103f30:	74 09                	je     103f3b <mp_config+0x5b>
    return 0;
  103f32:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  103f39:	eb 53                	jmp    103f8e <mp_config+0xae>
  if(conf->version != 1 && conf->version != 4)
  103f3b:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  103f3e:	0f b6 40 06          	movzbl 0x6(%eax),%eax
  103f42:	3c 01                	cmp    $0x1,%al
  103f44:	74 14                	je     103f5a <mp_config+0x7a>
  103f46:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  103f49:	0f b6 40 06          	movzbl 0x6(%eax),%eax
  103f4d:	3c 04                	cmp    $0x4,%al
  103f4f:	74 09                	je     103f5a <mp_config+0x7a>
    return 0;
  103f51:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  103f58:	eb 34                	jmp    103f8e <mp_config+0xae>
  if(sum((uchar*)conf, conf->length) != 0)
  103f5a:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  103f5d:	0f b7 40 04          	movzwl 0x4(%eax),%eax
  103f61:	0f b7 c0             	movzwl %ax,%eax
  103f64:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  103f67:	89 44 24 04          	mov    %eax,0x4(%esp)
  103f6b:	89 14 24             	mov    %edx,(%esp)
  103f6e:	e8 ed fd ff ff       	call   103d60 <sum>
  103f73:	84 c0                	test   %al,%al
  103f75:	74 09                	je     103f80 <mp_config+0xa0>
    return 0;
  103f77:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  103f7e:	eb 0e                	jmp    103f8e <mp_config+0xae>
  *pmp = mp;
  103f80:	8b 55 08             	mov    0x8(%ebp),%edx
  103f83:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  103f86:	89 02                	mov    %eax,(%edx)
  return conf;
  103f88:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  103f8b:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  103f8e:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  103f91:	c9                   	leave  
  103f92:	c3                   	ret    
  103f93:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  103f99:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00103fa0 <mp_init>:

void
mp_init(void)
{
  103fa0:	55                   	push   %ebp
  103fa1:	89 e5                	mov    %esp,%ebp
  103fa3:	83 ec 38             	sub    $0x38,%esp
  uchar *p, *e;
  struct mp *mp;
  struct mpconf *conf;
  struct mpproc *proc;
  struct mpioapic *ioapic;

  bcpu = &cpus[ncpu];
  103fa6:	a1 0c dd 13 00       	mov    0x13dd0c,%eax
  103fab:	69 c0 ec 10 00 00    	imul   $0x10ec,%eax,%eax
  103fb1:	05 20 cc 13 00       	add    $0x13cc20,%eax
  103fb6:	a3 a4 cd 11 00       	mov    %eax,0x11cda4
  if((conf = mp_config(&mp)) == 0)
  103fbb:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
  103fbe:	89 04 24             	mov    %eax,(%esp)
  103fc1:	e8 1a ff ff ff       	call   103ee0 <mp_config>
  103fc6:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  103fc9:	83 7d f4 00          	cmpl   $0x0,0xfffffff4(%ebp)
  103fcd:	0f 84 42 01 00 00    	je     104115 <mp_init+0x175>
    return;

  ismp = 1;
  103fd3:	c7 05 00 cc 13 00 01 	movl   $0x1,0x13cc00
  103fda:	00 00 00 
  lapic = (uint*)conf->lapicaddr;
  103fdd:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  103fe0:	8b 40 24             	mov    0x24(%eax),%eax
  103fe3:	a3 f8 cb 13 00       	mov    %eax,0x13cbf8

  for(p=(uchar*)(conf+1), e=(uchar*)conf+conf->length; p<e; ){
  103fe8:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  103feb:	83 c0 2c             	add    $0x2c,%eax
  103fee:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  103ff1:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  103ff4:	0f b7 40 04          	movzwl 0x4(%eax),%eax
  103ff8:	0f b7 c0             	movzwl %ax,%eax
  103ffb:	89 c2                	mov    %eax,%edx
  103ffd:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  104000:	8d 04 02             	lea    (%edx,%eax,1),%eax
  104003:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
  104006:	e9 bd 00 00 00       	jmp    1040c8 <mp_init+0x128>
    switch(*p){
  10400b:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10400e:	0f b6 00             	movzbl (%eax),%eax
  104011:	0f b6 c0             	movzbl %al,%eax
  104014:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
  104017:	83 7d dc 04          	cmpl   $0x4,0xffffffdc(%ebp)
  10401b:	0f 87 82 00 00 00    	ja     1040a3 <mp_init+0x103>
  104021:	8b 55 dc             	mov    0xffffffdc(%ebp),%edx
  104024:	8b 04 95 f8 a5 11 00 	mov    0x11a5f8(,%edx,4),%eax
  10402b:	ff e0                	jmp    *%eax
    case MPPROC:
      proc = (struct mpproc*)p;
  10402d:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  104030:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
      cpus[ncpu].apicid = proc->apicid;
  104033:	8b 0d 0c dd 13 00    	mov    0x13dd0c,%ecx
  104039:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10403c:	0f b6 50 01          	movzbl 0x1(%eax),%edx
  104040:	69 c1 ec 10 00 00    	imul   $0x10ec,%ecx,%eax
  104046:	88 90 20 cc 13 00    	mov    %dl,0x13cc20(%eax)
      if(proc->flags & MPBOOT)
  10404c:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10404f:	0f b6 40 03          	movzbl 0x3(%eax),%eax
  104053:	0f b6 c0             	movzbl %al,%eax
  104056:	83 e0 02             	and    $0x2,%eax
  104059:	85 c0                	test   %eax,%eax
  10405b:	74 15                	je     104072 <mp_init+0xd2>
        bcpu = &cpus[ncpu];
  10405d:	a1 0c dd 13 00       	mov    0x13dd0c,%eax
  104062:	69 c0 ec 10 00 00    	imul   $0x10ec,%eax,%eax
  104068:	05 20 cc 13 00       	add    $0x13cc20,%eax
  10406d:	a3 a4 cd 11 00       	mov    %eax,0x11cda4
      ncpu++;
  104072:	a1 0c dd 13 00       	mov    0x13dd0c,%eax
  104077:	83 c0 01             	add    $0x1,%eax
  10407a:	a3 0c dd 13 00       	mov    %eax,0x13dd0c
      p += sizeof(struct mpproc);
  10407f:	83 45 ec 14          	addl   $0x14,0xffffffec(%ebp)
      continue;
  104083:	eb 43                	jmp    1040c8 <mp_init+0x128>
    case MPIOAPIC:
      ioapic = (struct mpioapic*)p;
  104085:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  104088:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
      ioapic_id = ioapic->apicno;
  10408b:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10408e:	0f b6 40 01          	movzbl 0x1(%eax),%eax
  104092:	a2 04 cc 13 00       	mov    %al,0x13cc04
      p += sizeof(struct mpioapic);
  104097:	83 45 ec 08          	addl   $0x8,0xffffffec(%ebp)
      continue;
  10409b:	eb 2b                	jmp    1040c8 <mp_init+0x128>
    case MPBUS:
    case MPIOINTR:
    case MPLINTR:
      p += 8;
  10409d:	83 45 ec 08          	addl   $0x8,0xffffffec(%ebp)
      continue;
  1040a1:	eb 25                	jmp    1040c8 <mp_init+0x128>
    default:
      cprintf("mp_init: unknown config type %x\n", *p);
  1040a3:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  1040a6:	0f b6 00             	movzbl (%eax),%eax
  1040a9:	0f b6 c0             	movzbl %al,%eax
  1040ac:	89 44 24 04          	mov    %eax,0x4(%esp)
  1040b0:	c7 04 24 cc a5 11 00 	movl   $0x11a5cc,(%esp)
  1040b7:	e8 54 c6 ff ff       	call   100710 <cprintf>
      panic("mp_init");
  1040bc:	c7 04 24 ed a5 11 00 	movl   $0x11a5ed,(%esp)
  1040c3:	e8 38 cf ff ff       	call   101000 <panic>
  1040c8:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  1040cb:	3b 45 f0             	cmp    0xfffffff0(%ebp),%eax
  1040ce:	0f 82 37 ff ff ff    	jb     10400b <mp_init+0x6b>
    }
  }

  if(mp->imcrp){
  1040d4:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  1040d7:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
  1040db:	84 c0                	test   %al,%al
  1040dd:	74 36                	je     104115 <mp_init+0x175>
    // Bochs doesn't support IMCR, so this doesn't run on Bochs.
    // But it would on real hardware.
    outb(0x22, 0x70);   // Select IMCR
  1040df:	c7 44 24 04 70 00 00 	movl   $0x70,0x4(%esp)
  1040e6:	00 
  1040e7:	c7 04 24 22 00 00 00 	movl   $0x22,(%esp)
  1040ee:	e8 4d 00 00 00       	call   104140 <outb>
    outb(0x23, inb(0x23) | 1);  // Mask external interrupts.
  1040f3:	c7 04 24 23 00 00 00 	movl   $0x23,(%esp)
  1040fa:	e8 21 00 00 00       	call   104120 <inb>
  1040ff:	83 c8 01             	or     $0x1,%eax
  104102:	0f b6 c0             	movzbl %al,%eax
  104105:	89 44 24 04          	mov    %eax,0x4(%esp)
  104109:	c7 04 24 23 00 00 00 	movl   $0x23,(%esp)
  104110:	e8 2b 00 00 00       	call   104140 <outb>
  }
}
  104115:	c9                   	leave  
  104116:	c3                   	ret    
  104117:	89 f6                	mov    %esi,%esi
  104119:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00104120 <inb>:
// Routines to let C code use special x86 instructions.

static inline uchar
inb(ushort port)
{
  104120:	55                   	push   %ebp
  104121:	89 e5                	mov    %esp,%ebp
  104123:	83 ec 14             	sub    $0x14,%esp
  104126:	8b 45 08             	mov    0x8(%ebp),%eax
  104129:	66 89 45 ec          	mov    %ax,0xffffffec(%ebp)
  uchar data;

  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
  10412d:	0f b7 55 ec          	movzwl 0xffffffec(%ebp),%edx
  104131:	ec                   	in     (%dx),%al
  104132:	88 45 ff             	mov    %al,0xffffffff(%ebp)
  return data;
  104135:	0f b6 45 ff          	movzbl 0xffffffff(%ebp),%eax
}
  104139:	c9                   	leave  
  10413a:	c3                   	ret    
  10413b:	90                   	nop    
  10413c:	8d 74 26 00          	lea    0x0(%esi),%esi

00104140 <outb>:

static inline uint
inl(ushort port)
{
    uint data;

    asm volatile("in %1,%0" : "=a" (data) : "d" (port));
    return data;
}

static inline ushort
inw(ushort port)
{
    ushort data;

    asm volatile("in %1,%0" : "=a" (data) : "d" (port));
    return data;
}

static inline void
insl(int port, void *addr, int cnt)
{
  asm volatile("cld\n\trepne\n\tinsl"     :
                   "=D" (addr), "=c" (cnt)    :
                   "d" (port), "0" (addr), "1" (cnt)  :
                   "memory", "cc");
}

static inline void
outb(ushort port, uchar data)
{
  104140:	55                   	push   %ebp
  104141:	89 e5                	mov    %esp,%ebp
  104143:	83 ec 08             	sub    $0x8,%esp
  104146:	8b 45 08             	mov    0x8(%ebp),%eax
  104149:	8b 55 0c             	mov    0xc(%ebp),%edx
  10414c:	66 89 45 fc          	mov    %ax,0xfffffffc(%ebp)
  104150:	88 55 f8             	mov    %dl,0xfffffff8(%ebp)
  asm volatile("out %0,%1" : : "a" (data), "d" (port));
  104153:	0f b6 45 f8          	movzbl 0xfffffff8(%ebp),%eax
  104157:	0f b7 55 fc          	movzwl 0xfffffffc(%ebp),%edx
  10415b:	ee                   	out    %al,(%dx)
}
  10415c:	c9                   	leave  
  10415d:	c3                   	ret    
  10415e:	90                   	nop    
  10415f:	90                   	nop    

00104160 <reg_irq_handler>:
static ushort irqmask = 0xFFFF & ~(1<<IRQ_SLAVE);

void
reg_irq_handler(int irq_num, irq_handler_t handler)
{
  104160:	55                   	push   %ebp
  104161:	89 e5                	mov    %esp,%ebp
    irq_handler[irq_num] = handler;
  104163:	8b 55 08             	mov    0x8(%ebp),%edx
  104166:	8b 45 0c             	mov    0xc(%ebp),%eax
  104169:	89 04 95 20 dd 13 00 	mov    %eax,0x13dd20(,%edx,4)
}
  104170:	5d                   	pop    %ebp
  104171:	c3                   	ret    
  104172:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi
  104179:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00104180 <pic_setmask>:

static void
pic_setmask(ushort mask)
{
  104180:	55                   	push   %ebp
  104181:	89 e5                	mov    %esp,%ebp
  104183:	83 ec 18             	sub    $0x18,%esp
  104186:	8b 45 08             	mov    0x8(%ebp),%eax
  104189:	66 89 45 fc          	mov    %ax,0xfffffffc(%ebp)
  irqmask = mask;
  10418d:	0f b7 45 fc          	movzwl 0xfffffffc(%ebp),%eax
  104191:	66 a3 f0 c5 11 00    	mov    %ax,0x11c5f0
  outb(IO_PIC1+1, mask);
  104197:	0f b7 45 fc          	movzwl 0xfffffffc(%ebp),%eax
  10419b:	0f b6 c0             	movzbl %al,%eax
  10419e:	89 44 24 04          	mov    %eax,0x4(%esp)
  1041a2:	c7 04 24 21 00 00 00 	movl   $0x21,(%esp)
  1041a9:	e8 22 00 00 00       	call   1041d0 <outb>
  outb(IO_PIC2+1, mask >> 8);
  1041ae:	0f b7 45 fc          	movzwl 0xfffffffc(%ebp),%eax
  1041b2:	66 c1 e8 08          	shr    $0x8,%ax
  1041b6:	0f b6 c0             	movzbl %al,%eax
  1041b9:	89 44 24 04          	mov    %eax,0x4(%esp)
  1041bd:	c7 04 24 a1 00 00 00 	movl   $0xa1,(%esp)
  1041c4:	e8 07 00 00 00       	call   1041d0 <outb>
}
  1041c9:	c9                   	leave  
  1041ca:	c3                   	ret    
  1041cb:	90                   	nop    
  1041cc:	8d 74 26 00          	lea    0x0(%esi),%esi

001041d0 <outb>:
}

static inline void
outb(ushort port, uchar data)
{
  1041d0:	55                   	push   %ebp
  1041d1:	89 e5                	mov    %esp,%ebp
  1041d3:	83 ec 08             	sub    $0x8,%esp
  1041d6:	8b 45 08             	mov    0x8(%ebp),%eax
  1041d9:	8b 55 0c             	mov    0xc(%ebp),%edx
  1041dc:	66 89 45 fc          	mov    %ax,0xfffffffc(%ebp)
  1041e0:	88 55 f8             	mov    %dl,0xfffffff8(%ebp)
  asm volatile("out %0,%1" : : "a" (data), "d" (port));
  1041e3:	0f b6 45 f8          	movzbl 0xfffffff8(%ebp),%eax
  1041e7:	0f b7 55 fc          	movzwl 0xfffffffc(%ebp),%edx
  1041eb:	ee                   	out    %al,(%dx)
}
  1041ec:	c9                   	leave  
  1041ed:	c3                   	ret    
  1041ee:	89 f6                	mov    %esi,%esi

001041f0 <pic_enable>:

void
pic_enable(int irq)
{
  1041f0:	55                   	push   %ebp
  1041f1:	89 e5                	mov    %esp,%ebp
  1041f3:	83 ec 08             	sub    $0x8,%esp
  pic_setmask(irqmask & ~(1<<irq));
  1041f6:	8b 4d 08             	mov    0x8(%ebp),%ecx
  1041f9:	b8 01 00 00 00       	mov    $0x1,%eax
  1041fe:	d3 e0                	shl    %cl,%eax
  104200:	89 c2                	mov    %eax,%edx
  104202:	f7 d2                	not    %edx
  104204:	0f b7 05 f0 c5 11 00 	movzwl 0x11c5f0,%eax
  10420b:	21 d0                	and    %edx,%eax
  10420d:	0f b7 c0             	movzwl %ax,%eax
  104210:	89 04 24             	mov    %eax,(%esp)
  104213:	e8 68 ff ff ff       	call   104180 <pic_setmask>
}
  104218:	c9                   	leave  
  104219:	c3                   	ret    
  10421a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

00104220 <pic_init>:

// Initialize the 8259A interrupt controllers.
void
pic_init(void)
{
  104220:	55                   	push   %ebp
  104221:	89 e5                	mov    %esp,%ebp
  104223:	83 ec 18             	sub    $0x18,%esp
  // mask all interrupts
  outb(IO_PIC1+1, 0xFF);
  104226:	c7 44 24 04 ff 00 00 	movl   $0xff,0x4(%esp)
  10422d:	00 
  10422e:	c7 04 24 21 00 00 00 	movl   $0x21,(%esp)
  104235:	e8 96 ff ff ff       	call   1041d0 <outb>
  outb(IO_PIC2+1, 0xFF);
  10423a:	c7 44 24 04 ff 00 00 	movl   $0xff,0x4(%esp)
  104241:	00 
  104242:	c7 04 24 a1 00 00 00 	movl   $0xa1,(%esp)
  104249:	e8 82 ff ff ff       	call   1041d0 <outb>

  // Set up master (8259A-1)

  // ICW1:  0001g0hi
  //    g:  0 = edge triggering, 1 = level triggering
  //    h:  0 = cascaded PICs, 1 = master only
  //    i:  0 = no ICW4, 1 = ICW4 required
  outb(IO_PIC1, 0x11);
  10424e:	c7 44 24 04 11 00 00 	movl   $0x11,0x4(%esp)
  104255:	00 
  104256:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
  10425d:	e8 6e ff ff ff       	call   1041d0 <outb>

  // ICW2:  Vector offset
  outb(IO_PIC1+1, IRQ_OFFSET);
  104262:	c7 44 24 04 20 00 00 	movl   $0x20,0x4(%esp)
  104269:	00 
  10426a:	c7 04 24 21 00 00 00 	movl   $0x21,(%esp)
  104271:	e8 5a ff ff ff       	call   1041d0 <outb>

  // ICW3:  (master PIC) bit mask of IR lines connected to slaves
  //        (slave PIC) 3-bit # of slave's connection to master
  outb(IO_PIC1+1, 1<<IRQ_SLAVE);
  104276:	c7 44 24 04 04 00 00 	movl   $0x4,0x4(%esp)
  10427d:	00 
  10427e:	c7 04 24 21 00 00 00 	movl   $0x21,(%esp)
  104285:	e8 46 ff ff ff       	call   1041d0 <outb>

  // ICW4:  000nbmap
  //    n:  1 = special fully nested mode
  //    b:  1 = buffered mode
  //    m:  0 = slave PIC, 1 = master PIC
  //      (ignored when b is 0, as the master/slave role
  //      can be hardwired).
  //    a:  1 = Automatic EOI mode
  //    p:  0 = MCS-80/85 mode, 1 = intel x86 mode
  outb(IO_PIC1+1, 0x3);
  10428a:	c7 44 24 04 03 00 00 	movl   $0x3,0x4(%esp)
  104291:	00 
  104292:	c7 04 24 21 00 00 00 	movl   $0x21,(%esp)
  104299:	e8 32 ff ff ff       	call   1041d0 <outb>

  // Set up slave (8259A-2)
  outb(IO_PIC2, 0x11);                  // ICW1
  10429e:	c7 44 24 04 11 00 00 	movl   $0x11,0x4(%esp)
  1042a5:	00 
  1042a6:	c7 04 24 a0 00 00 00 	movl   $0xa0,(%esp)
  1042ad:	e8 1e ff ff ff       	call   1041d0 <outb>
  outb(IO_PIC2+1, IRQ_OFFSET + 8);      // ICW2
  1042b2:	c7 44 24 04 28 00 00 	movl   $0x28,0x4(%esp)
  1042b9:	00 
  1042ba:	c7 04 24 a1 00 00 00 	movl   $0xa1,(%esp)
  1042c1:	e8 0a ff ff ff       	call   1041d0 <outb>
  outb(IO_PIC2+1, IRQ_SLAVE);           // ICW3
  1042c6:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
  1042cd:	00 
  1042ce:	c7 04 24 a1 00 00 00 	movl   $0xa1,(%esp)
  1042d5:	e8 f6 fe ff ff       	call   1041d0 <outb>
  // NB Automatic EOI mode doesn't tend to work on the slave.
  // Linux source code says it's "to be investigated".
  outb(IO_PIC2+1, 0x3);                 // ICW4
  1042da:	c7 44 24 04 03 00 00 	movl   $0x3,0x4(%esp)
  1042e1:	00 
  1042e2:	c7 04 24 a1 00 00 00 	movl   $0xa1,(%esp)
  1042e9:	e8 e2 fe ff ff       	call   1041d0 <outb>

  // OCW3:  0ef01prs
  //   ef:  0x = NOP, 10 = clear specific mask, 11 = set specific mask
  //    p:  0 = no polling, 1 = polling mode
  //   rs:  0x = NOP, 10 = read IRR, 11 = read ISR
  outb(IO_PIC1, 0x68);             // clear specific mask
  1042ee:	c7 44 24 04 68 00 00 	movl   $0x68,0x4(%esp)
  1042f5:	00 
  1042f6:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
  1042fd:	e8 ce fe ff ff       	call   1041d0 <outb>
  outb(IO_PIC1, 0x0a);             // read IRR by default
  104302:	c7 44 24 04 0a 00 00 	movl   $0xa,0x4(%esp)
  104309:	00 
  10430a:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
  104311:	e8 ba fe ff ff       	call   1041d0 <outb>

  outb(IO_PIC2, 0x68);             // OCW3
  104316:	c7 44 24 04 68 00 00 	movl   $0x68,0x4(%esp)
  10431d:	00 
  10431e:	c7 04 24 a0 00 00 00 	movl   $0xa0,(%esp)
  104325:	e8 a6 fe ff ff       	call   1041d0 <outb>
  outb(IO_PIC2, 0x0a);             // OCW3
  10432a:	c7 44 24 04 0a 00 00 	movl   $0xa,0x4(%esp)
  104331:	00 
  104332:	c7 04 24 a0 00 00 00 	movl   $0xa0,(%esp)
  104339:	e8 92 fe ff ff       	call   1041d0 <outb>

  if(irqmask != 0xFFFF)
  10433e:	0f b7 05 f0 c5 11 00 	movzwl 0x11c5f0,%eax
  104345:	66 83 f8 ff          	cmp    $0xffffffff,%ax
  104349:	74 12                	je     10435d <pic_init+0x13d>
    pic_setmask(irqmask);
  10434b:	0f b7 05 f0 c5 11 00 	movzwl 0x11c5f0,%eax
  104352:	0f b7 c0             	movzwl %ax,%eax
  104355:	89 04 24             	mov    %eax,(%esp)
  104358:	e8 23 fe ff ff       	call   104180 <pic_setmask>
  memset(irq_handler, 0, sizeof(irq_handler));
  10435d:	c7 44 24 08 00 04 00 	movl   $0x400,0x8(%esp)
  104364:	00 
  104365:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  10436c:	00 
  10436d:	c7 04 24 20 dd 13 00 	movl   $0x13dd20,(%esp)
  104374:	e8 57 1b 00 00       	call   105ed0 <memset>
}
  104379:	c9                   	leave  
  10437a:	c3                   	ret    
  10437b:	90                   	nop    
  10437c:	90                   	nop    
  10437d:	90                   	nop    
  10437e:	90                   	nop    
  10437f:	90                   	nop    

00104380 <pipealloc>:
};

int
pipealloc(struct file **f0, struct file **f1)
{
  104380:	55                   	push   %ebp
  104381:	89 e5                	mov    %esp,%ebp
  104383:	83 ec 28             	sub    $0x28,%esp
  struct pipe *p;

  p = 0;
  104386:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
  *f0 = *f1 = 0;
  10438d:	8b 45 0c             	mov    0xc(%ebp),%eax
  104390:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  104396:	8b 45 0c             	mov    0xc(%ebp),%eax
  104399:	8b 10                	mov    (%eax),%edx
  10439b:	8b 45 08             	mov    0x8(%ebp),%eax
  10439e:	89 10                	mov    %edx,(%eax)
  if((*f0 = filealloc()) == 0 || (*f1 = filealloc()) == 0)
  1043a0:	e8 ab d1 ff ff       	call   101550 <filealloc>
  1043a5:	89 c2                	mov    %eax,%edx
  1043a7:	8b 45 08             	mov    0x8(%ebp),%eax
  1043aa:	89 10                	mov    %edx,(%eax)
  1043ac:	8b 45 08             	mov    0x8(%ebp),%eax
  1043af:	8b 00                	mov    (%eax),%eax
  1043b1:	85 c0                	test   %eax,%eax
  1043b3:	0f 84 c8 00 00 00    	je     104481 <pipealloc+0x101>
  1043b9:	e8 92 d1 ff ff       	call   101550 <filealloc>
  1043be:	89 c2                	mov    %eax,%edx
  1043c0:	8b 45 0c             	mov    0xc(%ebp),%eax
  1043c3:	89 10                	mov    %edx,(%eax)
  1043c5:	8b 45 0c             	mov    0xc(%ebp),%eax
  1043c8:	8b 00                	mov    (%eax),%eax
  1043ca:	85 c0                	test   %eax,%eax
  1043cc:	0f 84 af 00 00 00    	je     104481 <pipealloc+0x101>
    goto bad;
  if((p = (struct pipe*)kalloc(PAGE)) == 0)
  1043d2:	c7 04 24 00 10 00 00 	movl   $0x1000,(%esp)
  1043d9:	e8 92 f0 ff ff       	call   103470 <kalloc>
  1043de:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  1043e1:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  1043e5:	0f 84 96 00 00 00    	je     104481 <pipealloc+0x101>
    goto bad;
  p->readopen = 1;
  1043eb:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1043ee:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
  p->writeopen = 1;
  1043f4:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1043f7:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
  p->writep = 0;
  1043fe:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  104401:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
  p->readp = 0;
  104408:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10440b:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
  initlock(&p->lock, "pipe");
  104412:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  104415:	83 c0 10             	add    $0x10,%eax
  104418:	c7 44 24 04 0c a6 11 	movl   $0x11a60c,0x4(%esp)
  10441f:	00 
  104420:	89 04 24             	mov    %eax,(%esp)
  104423:	e8 b8 16 00 00       	call   105ae0 <initlock>
  (*f0)->type = FD_PIPE;
  104428:	8b 45 08             	mov    0x8(%ebp),%eax
  10442b:	8b 00                	mov    (%eax),%eax
  10442d:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
  (*f0)->readable = 1;
  104433:	8b 45 08             	mov    0x8(%ebp),%eax
  104436:	8b 00                	mov    (%eax),%eax
  104438:	c6 40 08 01          	movb   $0x1,0x8(%eax)
  (*f0)->writable = 0;
  10443c:	8b 45 08             	mov    0x8(%ebp),%eax
  10443f:	8b 00                	mov    (%eax),%eax
  104441:	c6 40 09 00          	movb   $0x0,0x9(%eax)
  (*f0)->pipe = p;
  104445:	8b 45 08             	mov    0x8(%ebp),%eax
  104448:	8b 10                	mov    (%eax),%edx
  10444a:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10444d:	89 42 0c             	mov    %eax,0xc(%edx)
  (*f1)->type = FD_PIPE;
  104450:	8b 45 0c             	mov    0xc(%ebp),%eax
  104453:	8b 00                	mov    (%eax),%eax
  104455:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
  (*f1)->readable = 0;
  10445b:	8b 45 0c             	mov    0xc(%ebp),%eax
  10445e:	8b 00                	mov    (%eax),%eax
  104460:	c6 40 08 00          	movb   $0x0,0x8(%eax)
  (*f1)->writable = 1;
  104464:	8b 45 0c             	mov    0xc(%ebp),%eax
  104467:	8b 00                	mov    (%eax),%eax
  104469:	c6 40 09 01          	movb   $0x1,0x9(%eax)
  (*f1)->pipe = p;
  10446d:	8b 45 0c             	mov    0xc(%ebp),%eax
  104470:	8b 10                	mov    (%eax),%edx
  104472:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  104475:	89 42 0c             	mov    %eax,0xc(%edx)
  return 0;
  104478:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  10447f:	eb 62                	jmp    1044e3 <pipealloc+0x163>

 bad:
  if(p)
  104481:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  104485:	74 13                	je     10449a <pipealloc+0x11a>
    kfree((char*)p, PAGE);
  104487:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10448a:	c7 44 24 04 00 10 00 	movl   $0x1000,0x4(%esp)
  104491:	00 
  104492:	89 04 24             	mov    %eax,(%esp)
  104495:	e8 66 ee ff ff       	call   103300 <kfree>
  if(*f0){
  10449a:	8b 45 08             	mov    0x8(%ebp),%eax
  10449d:	8b 00                	mov    (%eax),%eax
  10449f:	85 c0                	test   %eax,%eax
  1044a1:	74 18                	je     1044bb <pipealloc+0x13b>
    (*f0)->type = FD_NONE;
  1044a3:	8b 45 08             	mov    0x8(%ebp),%eax
  1044a6:	8b 00                	mov    (%eax),%eax
  1044a8:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    fileclose(*f0);
  1044ae:	8b 45 08             	mov    0x8(%ebp),%eax
  1044b1:	8b 00                	mov    (%eax),%eax
  1044b3:	89 04 24             	mov    %eax,(%esp)
  1044b6:	e8 a5 d1 ff ff       	call   101660 <fileclose>
  }
  if(*f1){
  1044bb:	8b 45 0c             	mov    0xc(%ebp),%eax
  1044be:	8b 00                	mov    (%eax),%eax
  1044c0:	85 c0                	test   %eax,%eax
  1044c2:	74 18                	je     1044dc <pipealloc+0x15c>
    (*f1)->type = FD_NONE;
  1044c4:	8b 45 0c             	mov    0xc(%ebp),%eax
  1044c7:	8b 00                	mov    (%eax),%eax
  1044c9:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    fileclose(*f1);
  1044cf:	8b 45 0c             	mov    0xc(%ebp),%eax
  1044d2:	8b 00                	mov    (%eax),%eax
  1044d4:	89 04 24             	mov    %eax,(%esp)
  1044d7:	e8 84 d1 ff ff       	call   101660 <fileclose>
  }
  return -1;
  1044dc:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  1044e3:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  1044e6:	c9                   	leave  
  1044e7:	c3                   	ret    
  1044e8:	90                   	nop    
  1044e9:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

001044f0 <pipeclose>:

void
pipeclose(struct pipe *p, int writable)
{
  1044f0:	55                   	push   %ebp
  1044f1:	89 e5                	mov    %esp,%ebp
  1044f3:	83 ec 08             	sub    $0x8,%esp
  acquire(&p->lock);
  1044f6:	8b 45 08             	mov    0x8(%ebp),%eax
  1044f9:	83 c0 10             	add    $0x10,%eax
  1044fc:	89 04 24             	mov    %eax,(%esp)
  1044ff:	e8 0c 16 00 00       	call   105b10 <acquire>
  if(writable){
  104504:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  104508:	74 1a                	je     104524 <pipeclose+0x34>
    p->writeopen = 0;
  10450a:	8b 45 08             	mov    0x8(%ebp),%eax
  10450d:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    wakeup(&p->readp);
  104514:	8b 45 08             	mov    0x8(%ebp),%eax
  104517:	83 c0 0c             	add    $0xc,%eax
  10451a:	89 04 24             	mov    %eax,(%esp)
  10451d:	e8 ce 10 00 00       	call   1055f0 <wakeup>
  104522:	eb 17                	jmp    10453b <pipeclose+0x4b>
  } else {
    p->readopen = 0;
  104524:	8b 45 08             	mov    0x8(%ebp),%eax
  104527:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    wakeup(&p->writep);
  10452d:	8b 45 08             	mov    0x8(%ebp),%eax
  104530:	83 c0 08             	add    $0x8,%eax
  104533:	89 04 24             	mov    %eax,(%esp)
  104536:	e8 b5 10 00 00       	call   1055f0 <wakeup>
  }
  release(&p->lock);
  10453b:	8b 45 08             	mov    0x8(%ebp),%eax
  10453e:	83 c0 10             	add    $0x10,%eax
  104541:	89 04 24             	mov    %eax,(%esp)
  104544:	e8 c7 17 00 00       	call   105d10 <release>

  if(p->readopen == 0 && p->writeopen == 0)
  104549:	8b 45 08             	mov    0x8(%ebp),%eax
  10454c:	8b 00                	mov    (%eax),%eax
  10454e:	85 c0                	test   %eax,%eax
  104550:	75 1d                	jne    10456f <pipeclose+0x7f>
  104552:	8b 45 08             	mov    0x8(%ebp),%eax
  104555:	8b 40 04             	mov    0x4(%eax),%eax
  104558:	85 c0                	test   %eax,%eax
  10455a:	75 13                	jne    10456f <pipeclose+0x7f>
    kfree((char*)p, PAGE);
  10455c:	8b 45 08             	mov    0x8(%ebp),%eax
  10455f:	c7 44 24 04 00 10 00 	movl   $0x1000,0x4(%esp)
  104566:	00 
  104567:	89 04 24             	mov    %eax,(%esp)
  10456a:	e8 91 ed ff ff       	call   103300 <kfree>
}
  10456f:	c9                   	leave  
  104570:	c3                   	ret    
  104571:	eb 0d                	jmp    104580 <pipewrite>
  104573:	90                   	nop    
  104574:	90                   	nop    
  104575:	90                   	nop    
  104576:	90                   	nop    
  104577:	90                   	nop    
  104578:	90                   	nop    
  104579:	90                   	nop    
  10457a:	90                   	nop    
  10457b:	90                   	nop    
  10457c:	90                   	nop    
  10457d:	90                   	nop    
  10457e:	90                   	nop    
  10457f:	90                   	nop    

00104580 <pipewrite>:

int
pipewrite(struct pipe *p, char *addr, int n)
{
  104580:	55                   	push   %ebp
  104581:	89 e5                	mov    %esp,%ebp
  104583:	83 ec 28             	sub    $0x28,%esp
  int i;

  acquire(&p->lock);
  104586:	8b 45 08             	mov    0x8(%ebp),%eax
  104589:	83 c0 10             	add    $0x10,%eax
  10458c:	89 04 24             	mov    %eax,(%esp)
  10458f:	e8 7c 15 00 00       	call   105b10 <acquire>
  for(i = 0; i < n; i++){
  104594:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
  10459b:	e9 c8 00 00 00       	jmp    104668 <pipewrite+0xe8>
    while(((p->writep + 1) % PIPESIZE) == p->readp){
      if(p->readopen == 0 || cp->killed){
  1045a0:	8b 45 08             	mov    0x8(%ebp),%eax
  1045a3:	8b 00                	mov    (%eax),%eax
  1045a5:	85 c0                	test   %eax,%eax
  1045a7:	74 13                	je     1045bc <pipewrite+0x3c>
  1045a9:	e8 e2 f2 ff ff       	call   103890 <cpu>
  1045ae:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  1045b5:	8b 40 1c             	mov    0x1c(%eax),%eax
  1045b8:	85 c0                	test   %eax,%eax
  1045ba:	74 1a                	je     1045d6 <pipewrite+0x56>
        release(&p->lock);
  1045bc:	8b 45 08             	mov    0x8(%ebp),%eax
  1045bf:	83 c0 10             	add    $0x10,%eax
  1045c2:	89 04 24             	mov    %eax,(%esp)
  1045c5:	e8 46 17 00 00       	call   105d10 <release>
        return -1;
  1045ca:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  1045d1:	e9 bc 00 00 00       	jmp    104692 <pipewrite+0x112>
      }
      wakeup(&p->readp);
  1045d6:	8b 45 08             	mov    0x8(%ebp),%eax
  1045d9:	83 c0 0c             	add    $0xc,%eax
  1045dc:	89 04 24             	mov    %eax,(%esp)
  1045df:	e8 0c 10 00 00       	call   1055f0 <wakeup>
      sleep(&p->writep, &p->lock);
  1045e4:	8b 45 08             	mov    0x8(%ebp),%eax
  1045e7:	83 c0 10             	add    $0x10,%eax
  1045ea:	8b 55 08             	mov    0x8(%ebp),%edx
  1045ed:	83 c2 08             	add    $0x8,%edx
  1045f0:	89 44 24 04          	mov    %eax,0x4(%esp)
  1045f4:	89 14 24             	mov    %edx,(%esp)
  1045f7:	e8 64 0e 00 00       	call   105460 <sleep>
  1045fc:	8b 45 08             	mov    0x8(%ebp),%eax
  1045ff:	8b 40 08             	mov    0x8(%eax),%eax
  104602:	8d 50 01             	lea    0x1(%eax),%edx
  104605:	89 d0                	mov    %edx,%eax
  104607:	c1 f8 1f             	sar    $0x1f,%eax
  10460a:	89 c1                	mov    %eax,%ecx
  10460c:	c1 e9 17             	shr    $0x17,%ecx
  10460f:	8d 04 0a             	lea    (%edx,%ecx,1),%eax
  104612:	25 ff 01 00 00       	and    $0x1ff,%eax
  104617:	29 c8                	sub    %ecx,%eax
  104619:	89 c2                	mov    %eax,%edx
  10461b:	8b 45 08             	mov    0x8(%ebp),%eax
  10461e:	8b 40 0c             	mov    0xc(%eax),%eax
  104621:	39 c2                	cmp    %eax,%edx
  104623:	0f 84 77 ff ff ff    	je     1045a0 <pipewrite+0x20>
    }
    p->data[p->writep] = addr[i];
  104629:	8b 45 08             	mov    0x8(%ebp),%eax
  10462c:	8b 48 08             	mov    0x8(%eax),%ecx
  10462f:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  104632:	03 45 0c             	add    0xc(%ebp),%eax
  104635:	0f b6 10             	movzbl (%eax),%edx
  104638:	8b 45 08             	mov    0x8(%ebp),%eax
  10463b:	88 54 01 44          	mov    %dl,0x44(%ecx,%eax,1)
    p->writep = (p->writep + 1) % PIPESIZE;
  10463f:	8b 45 08             	mov    0x8(%ebp),%eax
  104642:	8b 40 08             	mov    0x8(%eax),%eax
  104645:	8d 50 01             	lea    0x1(%eax),%edx
  104648:	89 d0                	mov    %edx,%eax
  10464a:	c1 f8 1f             	sar    $0x1f,%eax
  10464d:	89 c1                	mov    %eax,%ecx
  10464f:	c1 e9 17             	shr    $0x17,%ecx
  104652:	8d 04 0a             	lea    (%edx,%ecx,1),%eax
  104655:	25 ff 01 00 00       	and    $0x1ff,%eax
  10465a:	29 c8                	sub    %ecx,%eax
  10465c:	89 c2                	mov    %eax,%edx
  10465e:	8b 45 08             	mov    0x8(%ebp),%eax
  104661:	89 50 08             	mov    %edx,0x8(%eax)
  104664:	83 45 fc 01          	addl   $0x1,0xfffffffc(%ebp)
  104668:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10466b:	3b 45 10             	cmp    0x10(%ebp),%eax
  10466e:	7c 8c                	jl     1045fc <pipewrite+0x7c>
  }
  wakeup(&p->readp);
  104670:	8b 45 08             	mov    0x8(%ebp),%eax
  104673:	83 c0 0c             	add    $0xc,%eax
  104676:	89 04 24             	mov    %eax,(%esp)
  104679:	e8 72 0f 00 00       	call   1055f0 <wakeup>
  release(&p->lock);
  10467e:	8b 45 08             	mov    0x8(%ebp),%eax
  104681:	83 c0 10             	add    $0x10,%eax
  104684:	89 04 24             	mov    %eax,(%esp)
  104687:	e8 84 16 00 00       	call   105d10 <release>
  return i;
  10468c:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10468f:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  104692:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  104695:	c9                   	leave  
  104696:	c3                   	ret    
  104697:	89 f6                	mov    %esi,%esi
  104699:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

001046a0 <piperead>:

int
piperead(struct pipe *p, char *addr, int n)
{
  1046a0:	55                   	push   %ebp
  1046a1:	89 e5                	mov    %esp,%ebp
  1046a3:	83 ec 28             	sub    $0x28,%esp
  int i;

  acquire(&p->lock);
  1046a6:	8b 45 08             	mov    0x8(%ebp),%eax
  1046a9:	83 c0 10             	add    $0x10,%eax
  1046ac:	89 04 24             	mov    %eax,(%esp)
  1046af:	e8 5c 14 00 00       	call   105b10 <acquire>
  while(p->readp == p->writep && p->writeopen){
  1046b4:	eb 45                	jmp    1046fb <piperead+0x5b>
    if(cp->killed){
  1046b6:	e8 d5 f1 ff ff       	call   103890 <cpu>
  1046bb:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  1046c2:	8b 40 1c             	mov    0x1c(%eax),%eax
  1046c5:	85 c0                	test   %eax,%eax
  1046c7:	74 1a                	je     1046e3 <piperead+0x43>
      release(&p->lock);
  1046c9:	8b 45 08             	mov    0x8(%ebp),%eax
  1046cc:	83 c0 10             	add    $0x10,%eax
  1046cf:	89 04 24             	mov    %eax,(%esp)
  1046d2:	e8 39 16 00 00       	call   105d10 <release>
      return -1;
  1046d7:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  1046de:	e9 b6 00 00 00       	jmp    104799 <piperead+0xf9>
    }
    sleep(&p->readp, &p->lock);
  1046e3:	8b 45 08             	mov    0x8(%ebp),%eax
  1046e6:	83 c0 10             	add    $0x10,%eax
  1046e9:	8b 55 08             	mov    0x8(%ebp),%edx
  1046ec:	83 c2 0c             	add    $0xc,%edx
  1046ef:	89 44 24 04          	mov    %eax,0x4(%esp)
  1046f3:	89 14 24             	mov    %edx,(%esp)
  1046f6:	e8 65 0d 00 00       	call   105460 <sleep>
  1046fb:	8b 45 08             	mov    0x8(%ebp),%eax
  1046fe:	8b 50 0c             	mov    0xc(%eax),%edx
  104701:	8b 45 08             	mov    0x8(%ebp),%eax
  104704:	8b 40 08             	mov    0x8(%eax),%eax
  104707:	39 c2                	cmp    %eax,%edx
  104709:	75 0a                	jne    104715 <piperead+0x75>
  10470b:	8b 45 08             	mov    0x8(%ebp),%eax
  10470e:	8b 40 04             	mov    0x4(%eax),%eax
  104711:	85 c0                	test   %eax,%eax
  104713:	75 a1                	jne    1046b6 <piperead+0x16>
  }
  for(i = 0; i < n; i++){
  104715:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
  10471c:	eb 51                	jmp    10476f <piperead+0xcf>
    if(p->readp == p->writep)
  10471e:	8b 45 08             	mov    0x8(%ebp),%eax
  104721:	8b 50 0c             	mov    0xc(%eax),%edx
  104724:	8b 45 08             	mov    0x8(%ebp),%eax
  104727:	8b 40 08             	mov    0x8(%eax),%eax
  10472a:	39 c2                	cmp    %eax,%edx
  10472c:	74 49                	je     104777 <piperead+0xd7>
      break;
    addr[i] = p->data[p->readp];
  10472e:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  104731:	89 c1                	mov    %eax,%ecx
  104733:	03 4d 0c             	add    0xc(%ebp),%ecx
  104736:	8b 45 08             	mov    0x8(%ebp),%eax
  104739:	8b 50 0c             	mov    0xc(%eax),%edx
  10473c:	8b 45 08             	mov    0x8(%ebp),%eax
  10473f:	0f b6 44 02 44       	movzbl 0x44(%edx,%eax,1),%eax
  104744:	88 01                	mov    %al,(%ecx)
    p->readp = (p->readp + 1) % PIPESIZE;
  104746:	8b 45 08             	mov    0x8(%ebp),%eax
  104749:	8b 40 0c             	mov    0xc(%eax),%eax
  10474c:	8d 50 01             	lea    0x1(%eax),%edx
  10474f:	89 d0                	mov    %edx,%eax
  104751:	c1 f8 1f             	sar    $0x1f,%eax
  104754:	89 c1                	mov    %eax,%ecx
  104756:	c1 e9 17             	shr    $0x17,%ecx
  104759:	8d 04 0a             	lea    (%edx,%ecx,1),%eax
  10475c:	25 ff 01 00 00       	and    $0x1ff,%eax
  104761:	29 c8                	sub    %ecx,%eax
  104763:	89 c2                	mov    %eax,%edx
  104765:	8b 45 08             	mov    0x8(%ebp),%eax
  104768:	89 50 0c             	mov    %edx,0xc(%eax)
  10476b:	83 45 fc 01          	addl   $0x1,0xfffffffc(%ebp)
  10476f:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  104772:	3b 45 10             	cmp    0x10(%ebp),%eax
  104775:	7c a7                	jl     10471e <piperead+0x7e>
  }
  wakeup(&p->writep);
  104777:	8b 45 08             	mov    0x8(%ebp),%eax
  10477a:	83 c0 08             	add    $0x8,%eax
  10477d:	89 04 24             	mov    %eax,(%esp)
  104780:	e8 6b 0e 00 00       	call   1055f0 <wakeup>
  release(&p->lock);
  104785:	8b 45 08             	mov    0x8(%ebp),%eax
  104788:	83 c0 10             	add    $0x10,%eax
  10478b:	89 04 24             	mov    %eax,(%esp)
  10478e:	e8 7d 15 00 00       	call   105d10 <release>
  return i;
  104793:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  104796:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  104799:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  10479c:	c9                   	leave  
  10479d:	c3                   	ret    
  10479e:	90                   	nop    
  10479f:	90                   	nop    

001047a0 <pinit>:
extern void forkret1(struct trapframe*);

void
pinit(void)
{
  1047a0:	55                   	push   %ebp
  1047a1:	89 e5                	mov    %esp,%ebp
  1047a3:	83 ec 08             	sub    $0x8,%esp
  initlock(&proc_table_lock, "proc_table");
  1047a6:	c7 44 24 04 11 a6 11 	movl   $0x11a611,0x4(%esp)
  1047ad:	00 
  1047ae:	c7 04 24 40 0c 14 00 	movl   $0x140c40,(%esp)
  1047b5:	e8 26 13 00 00       	call   105ae0 <initlock>
}
  1047ba:	c9                   	leave  
  1047bb:	c3                   	ret    
  1047bc:	8d 74 26 00          	lea    0x0(%esi),%esi

001047c0 <allocproc>:

// Look in the process table for an UNUSED proc.
// If found, change state to EMBRYO and return it.
// Otherwise return 0.
struct proc*
allocproc(void)
{
  1047c0:	55                   	push   %ebp
  1047c1:	89 e5                	mov    %esp,%ebp
  1047c3:	83 ec 18             	sub    $0x18,%esp
  int i;
  struct proc *p;

  acquire(&proc_table_lock);
  1047c6:	c7 04 24 40 0c 14 00 	movl   $0x140c40,(%esp)
  1047cd:	e8 3e 13 00 00       	call   105b10 <acquire>
  for(i = 0; i < NPROC; i++){
  1047d2:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)
  1047d9:	eb 5e                	jmp    104839 <allocproc+0x79>
    p = &proc[i];
  1047db:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1047de:	69 c0 ac 00 00 00    	imul   $0xac,%eax,%eax
  1047e4:	05 20 e1 13 00       	add    $0x13e120,%eax
  1047e9:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
    if(p->state == UNUSED){
  1047ec:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1047ef:	8b 40 0c             	mov    0xc(%eax),%eax
  1047f2:	85 c0                	test   %eax,%eax
  1047f4:	75 3f                	jne    104835 <allocproc+0x75>
      p->state = EMBRYO;
  1047f6:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1047f9:	c7 40 0c 01 00 00 00 	movl   $0x1,0xc(%eax)
      p->pid = nextpid++;
  104800:	8b 15 f4 c5 11 00    	mov    0x11c5f4,%edx
  104806:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  104809:	89 50 10             	mov    %edx,0x10(%eax)
  10480c:	8d 42 01             	lea    0x1(%edx),%eax
  10480f:	a3 f4 c5 11 00       	mov    %eax,0x11c5f4
      p->thr = 0;
  104814:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  104817:	c7 80 a8 00 00 00 00 	movl   $0x0,0xa8(%eax)
  10481e:	00 00 00 
      release(&proc_table_lock);
  104821:	c7 04 24 40 0c 14 00 	movl   $0x140c40,(%esp)
  104828:	e8 e3 14 00 00       	call   105d10 <release>
      return p;
  10482d:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  104830:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  104833:	eb 1d                	jmp    104852 <allocproc+0x92>
  104835:	83 45 f8 01          	addl   $0x1,0xfffffff8(%ebp)
  104839:	83 7d f8 3f          	cmpl   $0x3f,0xfffffff8(%ebp)
  10483d:	7e 9c                	jle    1047db <allocproc+0x1b>
    }
  }
  release(&proc_table_lock);
  10483f:	c7 04 24 40 0c 14 00 	movl   $0x140c40,(%esp)
  104846:	e8 c5 14 00 00       	call   105d10 <release>
  return 0;
  10484b:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  104852:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  104855:	c9                   	leave  
  104856:	c3                   	ret    
  104857:	89 f6                	mov    %esi,%esi
  104859:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00104860 <growproc>:

// Grow current process's memory by n bytes.
// Return old size on success, -1 on failure.
int
growproc(int n)
{
  104860:	55                   	push   %ebp
  104861:	89 e5                	mov    %esp,%ebp
  104863:	53                   	push   %ebx
  104864:	83 ec 24             	sub    $0x24,%esp
  char *newmem, *oldmem;

  newmem = kalloc(cp->sz + n);
  104867:	e8 24 f0 ff ff       	call   103890 <cpu>
  10486c:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  104873:	8b 50 04             	mov    0x4(%eax),%edx
  104876:	8b 45 08             	mov    0x8(%ebp),%eax
  104879:	8d 04 02             	lea    (%edx,%eax,1),%eax
  10487c:	89 04 24             	mov    %eax,(%esp)
  10487f:	e8 ec eb ff ff       	call   103470 <kalloc>
  104884:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  if(newmem == 0)
  104887:	83 7d f4 00          	cmpl   $0x0,0xfffffff4(%ebp)
  10488b:	75 0c                	jne    104899 <growproc+0x39>
    return -1;
  10488d:	c7 45 e8 ff ff ff ff 	movl   $0xffffffff,0xffffffe8(%ebp)
  104894:	e9 cc 00 00 00       	jmp    104965 <growproc+0x105>
  memmove(newmem, cp->mem, cp->sz);
  104899:	e8 f2 ef ff ff       	call   103890 <cpu>
  10489e:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  1048a5:	8b 58 04             	mov    0x4(%eax),%ebx
  1048a8:	e8 e3 ef ff ff       	call   103890 <cpu>
  1048ad:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  1048b4:	8b 00                	mov    (%eax),%eax
  1048b6:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  1048ba:	89 44 24 04          	mov    %eax,0x4(%esp)
  1048be:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  1048c1:	89 04 24             	mov    %eax,(%esp)
  1048c4:	e8 97 16 00 00       	call   105f60 <memmove>
  memset(newmem + cp->sz, 0, n);
  1048c9:	8b 5d 08             	mov    0x8(%ebp),%ebx
  1048cc:	e8 bf ef ff ff       	call   103890 <cpu>
  1048d1:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  1048d8:	8b 40 04             	mov    0x4(%eax),%eax
  1048db:	03 45 f4             	add    0xfffffff4(%ebp),%eax
  1048de:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  1048e2:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  1048e9:	00 
  1048ea:	89 04 24             	mov    %eax,(%esp)
  1048ed:	e8 de 15 00 00       	call   105ed0 <memset>
  oldmem = cp->mem;
  1048f2:	e8 99 ef ff ff       	call   103890 <cpu>
  1048f7:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  1048fe:	8b 00                	mov    (%eax),%eax
  104900:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  cp->mem = newmem;
  104903:	e8 88 ef ff ff       	call   103890 <cpu>
  104908:	8b 14 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%edx
  10490f:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  104912:	89 02                	mov    %eax,(%edx)
  kfree(oldmem, cp->sz);
  104914:	e8 77 ef ff ff       	call   103890 <cpu>
  104919:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  104920:	8b 40 04             	mov    0x4(%eax),%eax
  104923:	89 44 24 04          	mov    %eax,0x4(%esp)
  104927:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10492a:	89 04 24             	mov    %eax,(%esp)
  10492d:	e8 ce e9 ff ff       	call   103300 <kfree>
  cp->sz += n;
  104932:	e8 59 ef ff ff       	call   103890 <cpu>
  104937:	8b 0c 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%ecx
  10493e:	8b 51 04             	mov    0x4(%ecx),%edx
  104941:	8b 45 08             	mov    0x8(%ebp),%eax
  104944:	8d 04 02             	lea    (%edx,%eax,1),%eax
  104947:	89 41 04             	mov    %eax,0x4(%ecx)
  return cp->sz - n;
  10494a:	e8 41 ef ff ff       	call   103890 <cpu>
  10494f:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  104956:	8b 50 04             	mov    0x4(%eax),%edx
  104959:	8b 45 08             	mov    0x8(%ebp),%eax
  10495c:	89 d1                	mov    %edx,%ecx
  10495e:	29 c1                	sub    %eax,%ecx
  104960:	89 c8                	mov    %ecx,%eax
  104962:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
  104965:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
}
  104968:	83 c4 24             	add    $0x24,%esp
  10496b:	5b                   	pop    %ebx
  10496c:	5d                   	pop    %ebp
  10496d:	c3                   	ret    
  10496e:	89 f6                	mov    %esi,%esi

00104970 <setupsegs>:

// Set up CPU's segment descriptors and task state for a given process.
// If p==0, set up for "idle" state for when scheduler() is running.
void
setupsegs(struct proc *p)
{
  104970:	55                   	push   %ebp
  104971:	89 e5                	mov    %esp,%ebp
  104973:	57                   	push   %edi
  104974:	56                   	push   %esi
  104975:	53                   	push   %ebx
  104976:	83 ec 5c             	sub    $0x5c,%esp
  struct cpu *c;
  
  c = &cpus[cpu()];
  104979:	e8 12 ef ff ff       	call   103890 <cpu>
  10497e:	69 c0 ec 10 00 00    	imul   $0x10ec,%eax,%eax
  104984:	05 20 cc 13 00       	add    $0x13cc20,%eax
  104989:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
  c->ts.ss0 = SEG_KDATA << 3;
  10498c:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10498f:	66 c7 40 2c 10 00    	movw   $0x10,0x2c(%eax)
  if(p)
  104995:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  104999:	74 15                	je     1049b0 <setupsegs+0x40>
    c->ts.esp0 = (uint)(p->kstack + KSTACKSIZE);
  10499b:	8b 45 08             	mov    0x8(%ebp),%eax
  10499e:	8b 40 08             	mov    0x8(%eax),%eax
  1049a1:	05 00 10 00 00       	add    $0x1000,%eax
  1049a6:	89 c2                	mov    %eax,%edx
  1049a8:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  1049ab:	89 50 28             	mov    %edx,0x28(%eax)
  1049ae:	eb 0a                	jmp    1049ba <setupsegs+0x4a>
  else
    c->ts.esp0 = 0xffffffff;
  1049b0:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  1049b3:	c7 40 28 ff ff ff ff 	movl   $0xffffffff,0x28(%eax)

  c->gdt[0] = SEG_NULL;
  1049ba:	c7 45 b0 00 00 00 00 	movl   $0x0,0xffffffb0(%ebp)
  1049c1:	c7 45 b4 00 00 00 00 	movl   $0x0,0xffffffb4(%ebp)
  1049c8:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
  1049cb:	8b 45 b0             	mov    0xffffffb0(%ebp),%eax
  1049ce:	8b 55 b4             	mov    0xffffffb4(%ebp),%edx
  1049d1:	89 81 8c 00 00 00    	mov    %eax,0x8c(%ecx)
  1049d7:	89 91 90 00 00 00    	mov    %edx,0x90(%ecx)
  c->gdt[SEG_KCODE] = SEG(STA_X|STA_R, 0, 0x100000 + 64*1024-1, 0);
  1049dd:	66 c7 45 b8 0f 01    	movw   $0x10f,0xffffffb8(%ebp)
  1049e3:	66 c7 45 ba 00 00    	movw   $0x0,0xffffffba(%ebp)
  1049e9:	c6 45 bc 00          	movb   $0x0,0xffffffbc(%ebp)
  1049ed:	0f b6 45 bd          	movzbl 0xffffffbd(%ebp),%eax
  1049f1:	83 e0 f0             	and    $0xfffffff0,%eax
  1049f4:	83 c8 0a             	or     $0xa,%eax
  1049f7:	88 45 bd             	mov    %al,0xffffffbd(%ebp)
  1049fa:	0f b6 45 bd          	movzbl 0xffffffbd(%ebp),%eax
  1049fe:	83 c8 10             	or     $0x10,%eax
  104a01:	88 45 bd             	mov    %al,0xffffffbd(%ebp)
  104a04:	0f b6 45 bd          	movzbl 0xffffffbd(%ebp),%eax
  104a08:	83 e0 9f             	and    $0xffffff9f,%eax
  104a0b:	88 45 bd             	mov    %al,0xffffffbd(%ebp)
  104a0e:	0f b6 45 bd          	movzbl 0xffffffbd(%ebp),%eax
  104a12:	83 c8 80             	or     $0xffffff80,%eax
  104a15:	88 45 bd             	mov    %al,0xffffffbd(%ebp)
  104a18:	0f b6 45 be          	movzbl 0xffffffbe(%ebp),%eax
  104a1c:	83 e0 f0             	and    $0xfffffff0,%eax
  104a1f:	88 45 be             	mov    %al,0xffffffbe(%ebp)
  104a22:	0f b6 45 be          	movzbl 0xffffffbe(%ebp),%eax
  104a26:	83 e0 ef             	and    $0xffffffef,%eax
  104a29:	88 45 be             	mov    %al,0xffffffbe(%ebp)
  104a2c:	0f b6 45 be          	movzbl 0xffffffbe(%ebp),%eax
  104a30:	83 e0 df             	and    $0xffffffdf,%eax
  104a33:	88 45 be             	mov    %al,0xffffffbe(%ebp)
  104a36:	0f b6 45 be          	movzbl 0xffffffbe(%ebp),%eax
  104a3a:	83 c8 40             	or     $0x40,%eax
  104a3d:	88 45 be             	mov    %al,0xffffffbe(%ebp)
  104a40:	0f b6 45 be          	movzbl 0xffffffbe(%ebp),%eax
  104a44:	83 c8 80             	or     $0xffffff80,%eax
  104a47:	88 45 be             	mov    %al,0xffffffbe(%ebp)
  104a4a:	c6 45 bf 00          	movb   $0x0,0xffffffbf(%ebp)
  104a4e:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
  104a51:	8b 45 b8             	mov    0xffffffb8(%ebp),%eax
  104a54:	8b 55 bc             	mov    0xffffffbc(%ebp),%edx
  104a57:	89 81 94 00 00 00    	mov    %eax,0x94(%ecx)
  104a5d:	89 91 98 00 00 00    	mov    %edx,0x98(%ecx)
  c->gdt[SEG_KDATA] = SEG(STA_W, 0, 0xffffffff, 0);
  104a63:	66 c7 45 c0 ff ff    	movw   $0xffff,0xffffffc0(%ebp)
  104a69:	66 c7 45 c2 00 00    	movw   $0x0,0xffffffc2(%ebp)
  104a6f:	c6 45 c4 00          	movb   $0x0,0xffffffc4(%ebp)
  104a73:	0f b6 45 c5          	movzbl 0xffffffc5(%ebp),%eax
  104a77:	83 e0 f0             	and    $0xfffffff0,%eax
  104a7a:	83 c8 02             	or     $0x2,%eax
  104a7d:	88 45 c5             	mov    %al,0xffffffc5(%ebp)
  104a80:	0f b6 45 c5          	movzbl 0xffffffc5(%ebp),%eax
  104a84:	83 c8 10             	or     $0x10,%eax
  104a87:	88 45 c5             	mov    %al,0xffffffc5(%ebp)
  104a8a:	0f b6 45 c5          	movzbl 0xffffffc5(%ebp),%eax
  104a8e:	83 e0 9f             	and    $0xffffff9f,%eax
  104a91:	88 45 c5             	mov    %al,0xffffffc5(%ebp)
  104a94:	0f b6 45 c5          	movzbl 0xffffffc5(%ebp),%eax
  104a98:	83 c8 80             	or     $0xffffff80,%eax
  104a9b:	88 45 c5             	mov    %al,0xffffffc5(%ebp)
  104a9e:	0f b6 45 c6          	movzbl 0xffffffc6(%ebp),%eax
  104aa2:	83 c8 0f             	or     $0xf,%eax
  104aa5:	88 45 c6             	mov    %al,0xffffffc6(%ebp)
  104aa8:	0f b6 45 c6          	movzbl 0xffffffc6(%ebp),%eax
  104aac:	83 e0 ef             	and    $0xffffffef,%eax
  104aaf:	88 45 c6             	mov    %al,0xffffffc6(%ebp)
  104ab2:	0f b6 45 c6          	movzbl 0xffffffc6(%ebp),%eax
  104ab6:	83 e0 df             	and    $0xffffffdf,%eax
  104ab9:	88 45 c6             	mov    %al,0xffffffc6(%ebp)
  104abc:	0f b6 45 c6          	movzbl 0xffffffc6(%ebp),%eax
  104ac0:	83 c8 40             	or     $0x40,%eax
  104ac3:	88 45 c6             	mov    %al,0xffffffc6(%ebp)
  104ac6:	0f b6 45 c6          	movzbl 0xffffffc6(%ebp),%eax
  104aca:	83 c8 80             	or     $0xffffff80,%eax
  104acd:	88 45 c6             	mov    %al,0xffffffc6(%ebp)
  104ad0:	c6 45 c7 00          	movb   $0x0,0xffffffc7(%ebp)
  104ad4:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
  104ad7:	8b 45 c0             	mov    0xffffffc0(%ebp),%eax
  104ada:	8b 55 c4             	mov    0xffffffc4(%ebp),%edx
  104add:	89 81 9c 00 00 00    	mov    %eax,0x9c(%ecx)
  104ae3:	89 91 a0 00 00 00    	mov    %edx,0xa0(%ecx)
  c->gdt[SEG_TSS] = SEG16(STS_T32A, (uint)&c->ts, sizeof(c->ts)-1, 0);
  104ae9:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  104aec:	83 c0 24             	add    $0x24,%eax
  104aef:	89 c1                	mov    %eax,%ecx
  104af1:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  104af4:	83 c0 24             	add    $0x24,%eax
  104af7:	c1 e8 10             	shr    $0x10,%eax
  104afa:	89 c2                	mov    %eax,%edx
  104afc:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  104aff:	83 c0 24             	add    $0x24,%eax
  104b02:	c1 e8 18             	shr    $0x18,%eax
  104b05:	89 c3                	mov    %eax,%ebx
  104b07:	66 c7 45 c8 67 00    	movw   $0x67,0xffffffc8(%ebp)
  104b0d:	66 89 4d ca          	mov    %cx,0xffffffca(%ebp)
  104b11:	88 55 cc             	mov    %dl,0xffffffcc(%ebp)
  104b14:	0f b6 45 cd          	movzbl 0xffffffcd(%ebp),%eax
  104b18:	83 e0 f0             	and    $0xfffffff0,%eax
  104b1b:	83 c8 09             	or     $0x9,%eax
  104b1e:	88 45 cd             	mov    %al,0xffffffcd(%ebp)
  104b21:	0f b6 45 cd          	movzbl 0xffffffcd(%ebp),%eax
  104b25:	83 c8 10             	or     $0x10,%eax
  104b28:	88 45 cd             	mov    %al,0xffffffcd(%ebp)
  104b2b:	0f b6 45 cd          	movzbl 0xffffffcd(%ebp),%eax
  104b2f:	83 e0 9f             	and    $0xffffff9f,%eax
  104b32:	88 45 cd             	mov    %al,0xffffffcd(%ebp)
  104b35:	0f b6 45 cd          	movzbl 0xffffffcd(%ebp),%eax
  104b39:	83 c8 80             	or     $0xffffff80,%eax
  104b3c:	88 45 cd             	mov    %al,0xffffffcd(%ebp)
  104b3f:	0f b6 45 ce          	movzbl 0xffffffce(%ebp),%eax
  104b43:	83 e0 f0             	and    $0xfffffff0,%eax
  104b46:	88 45 ce             	mov    %al,0xffffffce(%ebp)
  104b49:	0f b6 45 ce          	movzbl 0xffffffce(%ebp),%eax
  104b4d:	83 e0 ef             	and    $0xffffffef,%eax
  104b50:	88 45 ce             	mov    %al,0xffffffce(%ebp)
  104b53:	0f b6 45 ce          	movzbl 0xffffffce(%ebp),%eax
  104b57:	83 e0 df             	and    $0xffffffdf,%eax
  104b5a:	88 45 ce             	mov    %al,0xffffffce(%ebp)
  104b5d:	0f b6 45 ce          	movzbl 0xffffffce(%ebp),%eax
  104b61:	83 c8 40             	or     $0x40,%eax
  104b64:	88 45 ce             	mov    %al,0xffffffce(%ebp)
  104b67:	0f b6 45 ce          	movzbl 0xffffffce(%ebp),%eax
  104b6b:	83 e0 7f             	and    $0x7f,%eax
  104b6e:	88 45 ce             	mov    %al,0xffffffce(%ebp)
  104b71:	88 5d cf             	mov    %bl,0xffffffcf(%ebp)
  104b74:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
  104b77:	8b 45 c8             	mov    0xffffffc8(%ebp),%eax
  104b7a:	8b 55 cc             	mov    0xffffffcc(%ebp),%edx
  104b7d:	89 81 b4 00 00 00    	mov    %eax,0xb4(%ecx)
  104b83:	89 91 b8 00 00 00    	mov    %edx,0xb8(%ecx)
  c->gdt[SEG_TSS].s = 0;
  104b89:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
  104b8c:	0f b6 82 b9 00 00 00 	movzbl 0xb9(%edx),%eax
  104b93:	83 e0 ef             	and    $0xffffffef,%eax
  104b96:	88 82 b9 00 00 00    	mov    %al,0xb9(%edx)
  if(p){
  104b9c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  104ba0:	0f 84 96 01 00 00    	je     104d3c <setupsegs+0x3cc>
    c->gdt[SEG_UCODE] = SEG(STA_X|STA_R, (uint)p->mem, p->sz-1, DPL_USER);
  104ba6:	8b 45 08             	mov    0x8(%ebp),%eax
  104ba9:	8b 40 04             	mov    0x4(%eax),%eax
  104bac:	83 e8 01             	sub    $0x1,%eax
  104baf:	c1 e8 0c             	shr    $0xc,%eax
  104bb2:	89 c2                	mov    %eax,%edx
  104bb4:	8b 45 08             	mov    0x8(%ebp),%eax
  104bb7:	8b 00                	mov    (%eax),%eax
  104bb9:	89 c1                	mov    %eax,%ecx
  104bbb:	8b 45 08             	mov    0x8(%ebp),%eax
  104bbe:	8b 00                	mov    (%eax),%eax
  104bc0:	c1 e8 10             	shr    $0x10,%eax
  104bc3:	89 c3                	mov    %eax,%ebx
  104bc5:	8b 45 08             	mov    0x8(%ebp),%eax
  104bc8:	8b 40 04             	mov    0x4(%eax),%eax
  104bcb:	83 e8 01             	sub    $0x1,%eax
  104bce:	c1 e8 1c             	shr    $0x1c,%eax
  104bd1:	88 45 a3             	mov    %al,0xffffffa3(%ebp)
  104bd4:	0f b6 45 a3          	movzbl 0xffffffa3(%ebp),%eax
  104bd8:	83 e0 0f             	and    $0xf,%eax
  104bdb:	89 c6                	mov    %eax,%esi
  104bdd:	8b 45 08             	mov    0x8(%ebp),%eax
  104be0:	8b 00                	mov    (%eax),%eax
  104be2:	c1 e8 18             	shr    $0x18,%eax
  104be5:	89 c7                	mov    %eax,%edi
  104be7:	66 89 55 d0          	mov    %dx,0xffffffd0(%ebp)
  104beb:	66 89 4d d2          	mov    %cx,0xffffffd2(%ebp)
  104bef:	88 5d d4             	mov    %bl,0xffffffd4(%ebp)
  104bf2:	0f b6 45 d5          	movzbl 0xffffffd5(%ebp),%eax
  104bf6:	83 e0 f0             	and    $0xfffffff0,%eax
  104bf9:	83 c8 0a             	or     $0xa,%eax
  104bfc:	88 45 d5             	mov    %al,0xffffffd5(%ebp)
  104bff:	0f b6 45 d5          	movzbl 0xffffffd5(%ebp),%eax
  104c03:	83 c8 10             	or     $0x10,%eax
  104c06:	88 45 d5             	mov    %al,0xffffffd5(%ebp)
  104c09:	0f b6 45 d5          	movzbl 0xffffffd5(%ebp),%eax
  104c0d:	83 c8 60             	or     $0x60,%eax
  104c10:	88 45 d5             	mov    %al,0xffffffd5(%ebp)
  104c13:	0f b6 45 d5          	movzbl 0xffffffd5(%ebp),%eax
  104c17:	83 c8 80             	or     $0xffffff80,%eax
  104c1a:	88 45 d5             	mov    %al,0xffffffd5(%ebp)
  104c1d:	89 f2                	mov    %esi,%edx
  104c1f:	83 e2 0f             	and    $0xf,%edx
  104c22:	0f b6 45 d6          	movzbl 0xffffffd6(%ebp),%eax
  104c26:	83 e0 f0             	and    $0xfffffff0,%eax
  104c29:	09 d0                	or     %edx,%eax
  104c2b:	88 45 d6             	mov    %al,0xffffffd6(%ebp)
  104c2e:	0f b6 45 d6          	movzbl 0xffffffd6(%ebp),%eax
  104c32:	83 e0 ef             	and    $0xffffffef,%eax
  104c35:	88 45 d6             	mov    %al,0xffffffd6(%ebp)
  104c38:	0f b6 45 d6          	movzbl 0xffffffd6(%ebp),%eax
  104c3c:	83 e0 df             	and    $0xffffffdf,%eax
  104c3f:	88 45 d6             	mov    %al,0xffffffd6(%ebp)
  104c42:	0f b6 45 d6          	movzbl 0xffffffd6(%ebp),%eax
  104c46:	83 c8 40             	or     $0x40,%eax
  104c49:	88 45 d6             	mov    %al,0xffffffd6(%ebp)
  104c4c:	0f b6 45 d6          	movzbl 0xffffffd6(%ebp),%eax
  104c50:	83 c8 80             	or     $0xffffff80,%eax
  104c53:	88 45 d6             	mov    %al,0xffffffd6(%ebp)
  104c56:	89 f8                	mov    %edi,%eax
  104c58:	88 45 d7             	mov    %al,0xffffffd7(%ebp)
  104c5b:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
  104c5e:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
  104c61:	8b 55 d4             	mov    0xffffffd4(%ebp),%edx
  104c64:	89 81 a4 00 00 00    	mov    %eax,0xa4(%ecx)
  104c6a:	89 91 a8 00 00 00    	mov    %edx,0xa8(%ecx)
    c->gdt[SEG_UDATA] = SEG(STA_W, (uint)p->mem, p->sz-1, DPL_USER);
  104c70:	8b 45 08             	mov    0x8(%ebp),%eax
  104c73:	8b 40 04             	mov    0x4(%eax),%eax
  104c76:	83 e8 01             	sub    $0x1,%eax
  104c79:	c1 e8 0c             	shr    $0xc,%eax
  104c7c:	89 c2                	mov    %eax,%edx
  104c7e:	8b 45 08             	mov    0x8(%ebp),%eax
  104c81:	8b 00                	mov    (%eax),%eax
  104c83:	89 c1                	mov    %eax,%ecx
  104c85:	8b 45 08             	mov    0x8(%ebp),%eax
  104c88:	8b 00                	mov    (%eax),%eax
  104c8a:	c1 e8 10             	shr    $0x10,%eax
  104c8d:	89 c3                	mov    %eax,%ebx
  104c8f:	8b 45 08             	mov    0x8(%ebp),%eax
  104c92:	8b 40 04             	mov    0x4(%eax),%eax
  104c95:	83 e8 01             	sub    $0x1,%eax
  104c98:	c1 e8 1c             	shr    $0x1c,%eax
  104c9b:	88 45 a3             	mov    %al,0xffffffa3(%ebp)
  104c9e:	0f b6 45 a3          	movzbl 0xffffffa3(%ebp),%eax
  104ca2:	83 e0 0f             	and    $0xf,%eax
  104ca5:	89 c6                	mov    %eax,%esi
  104ca7:	8b 45 08             	mov    0x8(%ebp),%eax
  104caa:	8b 00                	mov    (%eax),%eax
  104cac:	c1 e8 18             	shr    $0x18,%eax
  104caf:	89 c7                	mov    %eax,%edi
  104cb1:	66 89 55 d8          	mov    %dx,0xffffffd8(%ebp)
  104cb5:	66 89 4d da          	mov    %cx,0xffffffda(%ebp)
  104cb9:	88 5d dc             	mov    %bl,0xffffffdc(%ebp)
  104cbc:	0f b6 45 dd          	movzbl 0xffffffdd(%ebp),%eax
  104cc0:	83 e0 f0             	and    $0xfffffff0,%eax
  104cc3:	83 c8 02             	or     $0x2,%eax
  104cc6:	88 45 dd             	mov    %al,0xffffffdd(%ebp)
  104cc9:	0f b6 45 dd          	movzbl 0xffffffdd(%ebp),%eax
  104ccd:	83 c8 10             	or     $0x10,%eax
  104cd0:	88 45 dd             	mov    %al,0xffffffdd(%ebp)
  104cd3:	0f b6 45 dd          	movzbl 0xffffffdd(%ebp),%eax
  104cd7:	83 c8 60             	or     $0x60,%eax
  104cda:	88 45 dd             	mov    %al,0xffffffdd(%ebp)
  104cdd:	0f b6 45 dd          	movzbl 0xffffffdd(%ebp),%eax
  104ce1:	83 c8 80             	or     $0xffffff80,%eax
  104ce4:	88 45 dd             	mov    %al,0xffffffdd(%ebp)
  104ce7:	89 f2                	mov    %esi,%edx
  104ce9:	83 e2 0f             	and    $0xf,%edx
  104cec:	0f b6 45 de          	movzbl 0xffffffde(%ebp),%eax
  104cf0:	83 e0 f0             	and    $0xfffffff0,%eax
  104cf3:	09 d0                	or     %edx,%eax
  104cf5:	88 45 de             	mov    %al,0xffffffde(%ebp)
  104cf8:	0f b6 45 de          	movzbl 0xffffffde(%ebp),%eax
  104cfc:	83 e0 ef             	and    $0xffffffef,%eax
  104cff:	88 45 de             	mov    %al,0xffffffde(%ebp)
  104d02:	0f b6 45 de          	movzbl 0xffffffde(%ebp),%eax
  104d06:	83 e0 df             	and    $0xffffffdf,%eax
  104d09:	88 45 de             	mov    %al,0xffffffde(%ebp)
  104d0c:	0f b6 45 de          	movzbl 0xffffffde(%ebp),%eax
  104d10:	83 c8 40             	or     $0x40,%eax
  104d13:	88 45 de             	mov    %al,0xffffffde(%ebp)
  104d16:	0f b6 45 de          	movzbl 0xffffffde(%ebp),%eax
  104d1a:	83 c8 80             	or     $0xffffff80,%eax
  104d1d:	88 45 de             	mov    %al,0xffffffde(%ebp)
  104d20:	89 f8                	mov    %edi,%eax
  104d22:	88 45 df             	mov    %al,0xffffffdf(%ebp)
  104d25:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
  104d28:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  104d2b:	8b 55 dc             	mov    0xffffffdc(%ebp),%edx
  104d2e:	89 81 ac 00 00 00    	mov    %eax,0xac(%ecx)
  104d34:	89 91 b0 00 00 00    	mov    %edx,0xb0(%ecx)
  104d3a:	eb 46                	jmp    104d82 <setupsegs+0x412>
  } else {
    c->gdt[SEG_UCODE] = SEG_NULL;
  104d3c:	c7 45 e0 00 00 00 00 	movl   $0x0,0xffffffe0(%ebp)
  104d43:	c7 45 e4 00 00 00 00 	movl   $0x0,0xffffffe4(%ebp)
  104d4a:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
  104d4d:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  104d50:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
  104d53:	89 81 a4 00 00 00    	mov    %eax,0xa4(%ecx)
  104d59:	89 91 a8 00 00 00    	mov    %edx,0xa8(%ecx)
    c->gdt[SEG_UDATA] = SEG_NULL;
  104d5f:	c7 45 e8 00 00 00 00 	movl   $0x0,0xffffffe8(%ebp)
  104d66:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  104d6d:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
  104d70:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  104d73:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
  104d76:	89 81 ac 00 00 00    	mov    %eax,0xac(%ecx)
  104d7c:	89 91 b0 00 00 00    	mov    %edx,0xb0(%ecx)
  }

  lgdt(c->gdt, sizeof(c->gdt));
  104d82:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  104d85:	05 8c 00 00 00       	add    $0x8c,%eax
  104d8a:	c7 44 24 04 30 00 00 	movl   $0x30,0x4(%esp)
  104d91:	00 
  104d92:	89 04 24             	mov    %eax,(%esp)
  104d95:	e8 16 00 00 00       	call   104db0 <lgdt>
  ltr(SEG_TSS << 3);
  104d9a:	c7 04 24 28 00 00 00 	movl   $0x28,(%esp)
  104da1:	e8 3a 00 00 00       	call   104de0 <ltr>
}
  104da6:	83 c4 5c             	add    $0x5c,%esp
  104da9:	5b                   	pop    %ebx
  104daa:	5e                   	pop    %esi
  104dab:	5f                   	pop    %edi
  104dac:	5d                   	pop    %ebp
  104dad:	c3                   	ret    
  104dae:	89 f6                	mov    %esi,%esi

00104db0 <lgdt>:
struct segdesc;

static inline void
lgdt(struct segdesc *p, int size)
{
  104db0:	55                   	push   %ebp
  104db1:	89 e5                	mov    %esp,%ebp
  104db3:	83 ec 10             	sub    $0x10,%esp
  volatile ushort pd[3];

  pd[0] = size-1;
  104db6:	8b 45 0c             	mov    0xc(%ebp),%eax
  104db9:	83 e8 01             	sub    $0x1,%eax
  104dbc:	66 89 45 fa          	mov    %ax,0xfffffffa(%ebp)
  pd[1] = (uint)p;
  104dc0:	8b 45 08             	mov    0x8(%ebp),%eax
  104dc3:	66 89 45 fc          	mov    %ax,0xfffffffc(%ebp)
  pd[2] = (uint)p >> 16;
  104dc7:	8b 45 08             	mov    0x8(%ebp),%eax
  104dca:	c1 e8 10             	shr    $0x10,%eax
  104dcd:	66 89 45 fe          	mov    %ax,0xfffffffe(%ebp)

  asm volatile("lgdt (%0)" : : "r" (pd));
  104dd1:	8d 45 fa             	lea    0xfffffffa(%ebp),%eax
  104dd4:	0f 01 10             	lgdtl  (%eax)
}
  104dd7:	c9                   	leave  
  104dd8:	c3                   	ret    
  104dd9:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

00104de0 <ltr>:

struct gatedesc;

static inline void
lidt(struct gatedesc *p, int size)
{
  volatile ushort pd[3];

  pd[0] = size-1;
  pd[1] = (uint)p;
  pd[2] = (uint)p >> 16;

  asm volatile("lidt (%0)" : : "r" (pd));
}

static inline void
ltr(ushort sel)
{
  104de0:	55                   	push   %ebp
  104de1:	89 e5                	mov    %esp,%ebp
  104de3:	83 ec 04             	sub    $0x4,%esp
  104de6:	8b 45 08             	mov    0x8(%ebp),%eax
  104de9:	66 89 45 fc          	mov    %ax,0xfffffffc(%ebp)
  asm volatile("ltr %0" : : "r" (sel));
  104ded:	0f b7 45 fc          	movzwl 0xfffffffc(%ebp),%eax
  104df1:	0f 00 d8             	ltr    %ax
}
  104df4:	c9                   	leave  
  104df5:	c3                   	ret    
  104df6:	8d 76 00             	lea    0x0(%esi),%esi
  104df9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00104e00 <copyproc>:

// Create a new process copying p as the parent.
// Sets up stack to return as if from system call.
// Caller must set state of returned proc to RUNNABLE.
struct proc*
copyproc(struct proc *p)
{
  104e00:	55                   	push   %ebp
  104e01:	89 e5                	mov    %esp,%ebp
  104e03:	53                   	push   %ebx
  104e04:	83 ec 24             	sub    $0x24,%esp
  int i;
  struct proc *np;

  // Allocate process.
  if((np = allocproc()) == 0)
  104e07:	e8 b4 f9 ff ff       	call   1047c0 <allocproc>
  104e0c:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  104e0f:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  104e13:	75 0c                	jne    104e21 <copyproc+0x21>
    return 0;
  104e15:	c7 45 e8 00 00 00 00 	movl   $0x0,0xffffffe8(%ebp)
  104e1c:	e9 b9 01 00 00       	jmp    104fda <copyproc+0x1da>

  // Allocate kernel stack.
  if((np->kstack = kalloc(KSTACKSIZE)) == 0){
  104e21:	c7 04 24 00 10 00 00 	movl   $0x1000,(%esp)
  104e28:	e8 43 e6 ff ff       	call   103470 <kalloc>
  104e2d:	89 c2                	mov    %eax,%edx
  104e2f:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  104e32:	89 50 08             	mov    %edx,0x8(%eax)
  104e35:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  104e38:	8b 40 08             	mov    0x8(%eax),%eax
  104e3b:	85 c0                	test   %eax,%eax
  104e3d:	75 16                	jne    104e55 <copyproc+0x55>
    np->state = UNUSED;
  104e3f:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  104e42:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
    return 0;
  104e49:	c7 45 e8 00 00 00 00 	movl   $0x0,0xffffffe8(%ebp)
  104e50:	e9 85 01 00 00       	jmp    104fda <copyproc+0x1da>
  }
  np->tf = (struct trapframe*)(np->kstack + KSTACKSIZE) - 1;
  104e55:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  104e58:	8b 40 08             	mov    0x8(%eax),%eax
  104e5b:	8d 90 bc 0f 00 00    	lea    0xfbc(%eax),%edx
  104e61:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  104e64:	89 90 84 00 00 00    	mov    %edx,0x84(%eax)

  if(p){  // Copy process state from p.
  104e6a:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  104e6e:	0f 84 16 01 00 00    	je     104f8a <copyproc+0x18a>
    np->parent = p;
  104e74:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  104e77:	8b 45 08             	mov    0x8(%ebp),%eax
  104e7a:	89 42 14             	mov    %eax,0x14(%edx)
    memmove(np->tf, p->tf, sizeof(*np->tf));
  104e7d:	8b 45 08             	mov    0x8(%ebp),%eax
  104e80:	8b 90 84 00 00 00    	mov    0x84(%eax),%edx
  104e86:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  104e89:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
  104e8f:	c7 44 24 08 44 00 00 	movl   $0x44,0x8(%esp)
  104e96:	00 
  104e97:	89 54 24 04          	mov    %edx,0x4(%esp)
  104e9b:	89 04 24             	mov    %eax,(%esp)
  104e9e:	e8 bd 10 00 00       	call   105f60 <memmove>
  
    np->sz = p->sz;
  104ea3:	8b 45 08             	mov    0x8(%ebp),%eax
  104ea6:	8b 50 04             	mov    0x4(%eax),%edx
  104ea9:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  104eac:	89 50 04             	mov    %edx,0x4(%eax)
    if((np->mem = kalloc(np->sz)) == 0){
  104eaf:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  104eb2:	8b 40 04             	mov    0x4(%eax),%eax
  104eb5:	89 04 24             	mov    %eax,(%esp)
  104eb8:	e8 b3 e5 ff ff       	call   103470 <kalloc>
  104ebd:	89 c2                	mov    %eax,%edx
  104ebf:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  104ec2:	89 10                	mov    %edx,(%eax)
  104ec4:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  104ec7:	8b 00                	mov    (%eax),%eax
  104ec9:	85 c0                	test   %eax,%eax
  104ecb:	75 36                	jne    104f03 <copyproc+0x103>
      kfree(np->kstack, KSTACKSIZE);
  104ecd:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  104ed0:	8b 40 08             	mov    0x8(%eax),%eax
  104ed3:	c7 44 24 04 00 10 00 	movl   $0x1000,0x4(%esp)
  104eda:	00 
  104edb:	89 04 24             	mov    %eax,(%esp)
  104ede:	e8 1d e4 ff ff       	call   103300 <kfree>
      np->kstack = 0;
  104ee3:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  104ee6:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
      np->state = UNUSED;
  104eed:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  104ef0:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
      return 0;
  104ef7:	c7 45 e8 00 00 00 00 	movl   $0x0,0xffffffe8(%ebp)
  104efe:	e9 d7 00 00 00       	jmp    104fda <copyproc+0x1da>
    }
    memmove(np->mem, p->mem, np->sz);
  104f03:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  104f06:	8b 50 04             	mov    0x4(%eax),%edx
  104f09:	8b 45 08             	mov    0x8(%ebp),%eax
  104f0c:	8b 08                	mov    (%eax),%ecx
  104f0e:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  104f11:	8b 00                	mov    (%eax),%eax
  104f13:	89 54 24 08          	mov    %edx,0x8(%esp)
  104f17:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  104f1b:	89 04 24             	mov    %eax,(%esp)
  104f1e:	e8 3d 10 00 00       	call   105f60 <memmove>

    for(i = 0; i < NOFILE; i++)
  104f23:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
  104f2a:	eb 30                	jmp    104f5c <copyproc+0x15c>
      if(p->ofile[i])
  104f2c:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  104f2f:	8b 55 08             	mov    0x8(%ebp),%edx
  104f32:	8b 44 82 20          	mov    0x20(%edx,%eax,4),%eax
  104f36:	85 c0                	test   %eax,%eax
  104f38:	74 1e                	je     104f58 <copyproc+0x158>
        np->ofile[i] = filedup(p->ofile[i]);
  104f3a:	8b 5d f4             	mov    0xfffffff4(%ebp),%ebx
  104f3d:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
  104f40:	8b 45 08             	mov    0x8(%ebp),%eax
  104f43:	8b 44 90 20          	mov    0x20(%eax,%edx,4),%eax
  104f47:	89 04 24             	mov    %eax,(%esp)
  104f4a:	e8 b1 c6 ff ff       	call   101600 <filedup>
  104f4f:	89 c2                	mov    %eax,%edx
  104f51:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  104f54:	89 54 98 20          	mov    %edx,0x20(%eax,%ebx,4)
  104f58:	83 45 f4 01          	addl   $0x1,0xfffffff4(%ebp)
  104f5c:	83 7d f4 0f          	cmpl   $0xf,0xfffffff4(%ebp)
  104f60:	7e ca                	jle    104f2c <copyproc+0x12c>
    np->cwd = idup(p->cwd);
  104f62:	8b 45 08             	mov    0x8(%ebp),%eax
  104f65:	8b 40 60             	mov    0x60(%eax),%eax
  104f68:	89 04 24             	mov    %eax,(%esp)
  104f6b:	e8 00 ce ff ff       	call   101d70 <idup>
  104f70:	89 c2                	mov    %eax,%edx
  104f72:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  104f75:	89 50 60             	mov    %edx,0x60(%eax)
    np->thr = p->thr;
  104f78:	8b 45 08             	mov    0x8(%ebp),%eax
  104f7b:	8b 90 a8 00 00 00    	mov    0xa8(%eax),%edx
  104f81:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  104f84:	89 90 a8 00 00 00    	mov    %edx,0xa8(%eax)
  }

  // Set up new context to start executing at forkret (see below).
  memset(&np->context, 0, sizeof(np->context));
  104f8a:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  104f8d:	83 c0 64             	add    $0x64,%eax
  104f90:	c7 44 24 08 20 00 00 	movl   $0x20,0x8(%esp)
  104f97:	00 
  104f98:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  104f9f:	00 
  104fa0:	89 04 24             	mov    %eax,(%esp)
  104fa3:	e8 28 0f 00 00       	call   105ed0 <memset>
  np->context.eip = (uint)forkret;
  104fa8:	ba 10 53 10 00       	mov    $0x105310,%edx
  104fad:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  104fb0:	89 50 64             	mov    %edx,0x64(%eax)
  np->context.esp = (uint)np->tf;
  104fb3:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  104fb6:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
  104fbc:	89 c2                	mov    %eax,%edx
  104fbe:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  104fc1:	89 50 68             	mov    %edx,0x68(%eax)

  // Clear %eax so that fork system call returns 0 in child.
  np->tf->eax = 0;
  104fc4:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  104fc7:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
  104fcd:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
  return np;
  104fd4:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  104fd7:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
  104fda:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
}
  104fdd:	83 c4 24             	add    $0x24,%esp
  104fe0:	5b                   	pop    %ebx
  104fe1:	5d                   	pop    %ebp
  104fe2:	c3                   	ret    
  104fe3:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  104fe9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00104ff0 <userinit>:

// Set up first user process.
void
userinit(void)
{
  104ff0:	55                   	push   %ebp
  104ff1:	89 e5                	mov    %esp,%ebp
  104ff3:	83 ec 28             	sub    $0x28,%esp
  struct proc *p;
  extern uchar _binary_initcode_start[], _binary_initcode_size[];
  
  p = copyproc(0);
  104ff6:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  104ffd:	e8 fe fd ff ff       	call   104e00 <copyproc>
  105002:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  p->sz = PAGE;
  105005:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  105008:	c7 40 04 00 10 00 00 	movl   $0x1000,0x4(%eax)
  p->mem = kalloc(p->sz);
  10500f:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  105012:	8b 40 04             	mov    0x4(%eax),%eax
  105015:	89 04 24             	mov    %eax,(%esp)
  105018:	e8 53 e4 ff ff       	call   103470 <kalloc>
  10501d:	89 c2                	mov    %eax,%edx
  10501f:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  105022:	89 10                	mov    %edx,(%eax)
  p->cwd = namei("/");
  105024:	c7 04 24 1c a6 11 00 	movl   $0x11a61c,(%esp)
  10502b:	e8 20 dc ff ff       	call   102c50 <namei>
  105030:	89 c2                	mov    %eax,%edx
  105032:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  105035:	89 50 60             	mov    %edx,0x60(%eax)
  memset(p->tf, 0, sizeof(*p->tf));
  105038:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10503b:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
  105041:	c7 44 24 08 44 00 00 	movl   $0x44,0x8(%esp)
  105048:	00 
  105049:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  105050:	00 
  105051:	89 04 24             	mov    %eax,(%esp)
  105054:	e8 77 0e 00 00       	call   105ed0 <memset>
  p->tf->cs = (SEG_UCODE << 3) | DPL_USER;
  105059:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10505c:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
  105062:	66 c7 40 34 1b 00    	movw   $0x1b,0x34(%eax)
  p->tf->ds = (SEG_UDATA << 3) | DPL_USER;
  105068:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10506b:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
  105071:	66 c7 40 24 23 00    	movw   $0x23,0x24(%eax)
  p->tf->es = p->tf->ds;
  105077:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10507a:	8b 90 84 00 00 00    	mov    0x84(%eax),%edx
  105080:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  105083:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
  105089:	0f b7 40 24          	movzwl 0x24(%eax),%eax
  10508d:	66 89 42 20          	mov    %ax,0x20(%edx)
  p->tf->ss = p->tf->ds;
  105091:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  105094:	8b 90 84 00 00 00    	mov    0x84(%eax),%edx
  10509a:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10509d:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
  1050a3:	0f b7 40 24          	movzwl 0x24(%eax),%eax
  1050a7:	66 89 42 40          	mov    %ax,0x40(%edx)
  p->tf->eflags = FL_IF;
  1050ab:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1050ae:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
  1050b4:	c7 40 38 00 02 00 00 	movl   $0x200,0x38(%eax)
  p->tf->esp = p->sz;
  1050bb:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1050be:	8b 90 84 00 00 00    	mov    0x84(%eax),%edx
  1050c4:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1050c7:	8b 40 04             	mov    0x4(%eax),%eax
  1050ca:	89 42 3c             	mov    %eax,0x3c(%edx)
  
  // Make return address readable; needed for some gcc.
  p->tf->esp -= 4;
  1050cd:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1050d0:	8b 90 84 00 00 00    	mov    0x84(%eax),%edx
  1050d6:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1050d9:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
  1050df:	8b 40 3c             	mov    0x3c(%eax),%eax
  1050e2:	83 e8 04             	sub    $0x4,%eax
  1050e5:	89 42 3c             	mov    %eax,0x3c(%edx)
  *(uint*)(p->mem + p->tf->esp) = 0xefefefef;
  1050e8:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1050eb:	8b 10                	mov    (%eax),%edx
  1050ed:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1050f0:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
  1050f6:	8b 40 3c             	mov    0x3c(%eax),%eax
  1050f9:	8d 04 02             	lea    (%edx,%eax,1),%eax
  1050fc:	c7 00 ef ef ef ef    	movl   $0xefefefef,(%eax)

  // On entry to user space, start executing at beginning of initcode.S.
  p->tf->eip = 0;
  105102:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  105105:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
  10510b:	c7 40 30 00 00 00 00 	movl   $0x0,0x30(%eax)
  memmove(p->mem, _binary_initcode_start, (int)_binary_initcode_size);
  105112:	b8 2c 00 00 00       	mov    $0x2c,%eax
  105117:	89 c2                	mov    %eax,%edx
  105119:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10511c:	8b 00                	mov    (%eax),%eax
  10511e:	89 54 24 08          	mov    %edx,0x8(%esp)
  105122:	c7 44 24 04 6c cc 11 	movl   $0x11cc6c,0x4(%esp)
  105129:	00 
  10512a:	89 04 24             	mov    %eax,(%esp)
  10512d:	e8 2e 0e 00 00       	call   105f60 <memmove>
  safestrcpy(p->name, "initcode", sizeof(p->name));
  105132:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  105135:	05 88 00 00 00       	add    $0x88,%eax
  10513a:	c7 44 24 08 20 00 00 	movl   $0x20,0x8(%esp)
  105141:	00 
  105142:	c7 44 24 04 1e a6 11 	movl   $0x11a61e,0x4(%esp)
  105149:	00 
  10514a:	89 04 24             	mov    %eax,(%esp)
  10514d:	e8 5e 0f 00 00       	call   1060b0 <safestrcpy>
  p->state = RUNNABLE;
  105152:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  105155:	c7 40 0c 03 00 00 00 	movl   $0x3,0xc(%eax)
  
  initproc = p;
  10515c:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10515f:	a3 24 0c 14 00       	mov    %eax,0x140c24
}
  105164:	c9                   	leave  
  105165:	c3                   	ret    
  105166:	8d 76 00             	lea    0x0(%esi),%esi
  105169:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00105170 <scheduler>:

// Per-CPU process scheduler.
// Each CPU calls scheduler() after setting itself up.
// Scheduler never returns.  It loops, doing:
//  - choose a process to run
//  - swtch to start running that process
//  - eventually that process transfers control
//      via swtch back to the scheduler.
void
scheduler(void)
{
  105170:	55                   	push   %ebp
  105171:	89 e5                	mov    %esp,%ebp
  105173:	53                   	push   %ebx
  105174:	83 ec 24             	sub    $0x24,%esp
  struct proc *p;
  int i;

  for(;;){
    // Loop over process table looking for process to run.
    acquire(&proc_table_lock);
  105177:	c7 04 24 40 0c 14 00 	movl   $0x140c40,(%esp)
  10517e:	e8 8d 09 00 00       	call   105b10 <acquire>

    for(i = 0; i < NPROC; i++){
  105183:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)
  10518a:	e9 9d 00 00 00       	jmp    10522c <scheduler+0xbc>
      p = &proc[i];
  10518f:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  105192:	69 c0 ac 00 00 00    	imul   $0xac,%eax,%eax
  105198:	05 20 e1 13 00       	add    $0x13e120,%eax
  10519d:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
      if((p->state != RUNNABLE) && (p->state != MSLEEPING))
  1051a0:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  1051a3:	8b 40 0c             	mov    0xc(%eax),%eax
  1051a6:	83 f8 03             	cmp    $0x3,%eax
  1051a9:	74 0b                	je     1051b6 <scheduler+0x46>
  1051ab:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  1051ae:	8b 40 0c             	mov    0xc(%eax),%eax
  1051b1:	83 f8 06             	cmp    $0x6,%eax
  1051b4:	75 72                	jne    105228 <scheduler+0xb8>
        continue;

//      cprintf("switch to %s eip: 0x%08x...\n", p->name, p->context.eip);
      // Switch to chosen process.  It is the process's job
      // to release proc_table_lock and then reacquire it
      // before jumping back to us.
      cp = p;
  1051b6:	e8 d5 e6 ff ff       	call   103890 <cpu>
  1051bb:	89 c2                	mov    %eax,%edx
  1051bd:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  1051c0:	89 04 95 20 0c 14 00 	mov    %eax,0x140c20(,%edx,4)
      setupsegs(p);
  1051c7:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  1051ca:	89 04 24             	mov    %eax,(%esp)
  1051cd:	e8 9e f7 ff ff       	call   104970 <setupsegs>
      if (p->state == RUNNABLE)
  1051d2:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  1051d5:	8b 40 0c             	mov    0xc(%eax),%eax
  1051d8:	83 f8 03             	cmp    $0x3,%eax
  1051db:	75 0a                	jne    1051e7 <scheduler+0x77>
        p->state = RUNNING;
  1051dd:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  1051e0:	c7 40 0c 04 00 00 00 	movl   $0x4,0xc(%eax)
      swtch(&cpus[cpu()].context, &p->context);
  1051e7:	8b 5d f4             	mov    0xfffffff4(%ebp),%ebx
  1051ea:	83 c3 64             	add    $0x64,%ebx
  1051ed:	e8 9e e6 ff ff       	call   103890 <cpu>
  1051f2:	69 c0 ec 10 00 00    	imul   $0x10ec,%eax,%eax
  1051f8:	05 20 cc 13 00       	add    $0x13cc20,%eax
  1051fd:	83 c0 04             	add    $0x4,%eax
  105200:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  105204:	89 04 24             	mov    %eax,(%esp)
  105207:	e8 2c 0f 00 00       	call   106138 <swtch>

//      cprintf("done.\n");
      // Process is done running for now.
      // It should have changed its p->state before coming back.
      cp = 0;
  10520c:	e8 7f e6 ff ff       	call   103890 <cpu>
  105211:	c7 04 85 20 0c 14 00 	movl   $0x0,0x140c20(,%eax,4)
  105218:	00 00 00 00 
      setupsegs(0);
  10521c:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  105223:	e8 48 f7 ff ff       	call   104970 <setupsegs>
  105228:	83 45 f8 01          	addl   $0x1,0xfffffff8(%ebp)
  10522c:	83 7d f8 3f          	cmpl   $0x3f,0xfffffff8(%ebp)
  105230:	0f 8e 59 ff ff ff    	jle    10518f <scheduler+0x1f>
    }

    release(&proc_table_lock);
  105236:	c7 04 24 40 0c 14 00 	movl   $0x140c40,(%esp)
  10523d:	e8 ce 0a 00 00       	call   105d10 <release>
  }
  105242:	e9 30 ff ff ff       	jmp    105177 <scheduler+0x7>
  105247:	89 f6                	mov    %esi,%esi
  105249:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00105250 <sched>:
}

// Enter scheduler.  Must already hold proc_table_lock
// and have changed curproc[cpu()]->state.
void
sched(void)
{
  105250:	55                   	push   %ebp
  105251:	89 e5                	mov    %esp,%ebp
  105253:	53                   	push   %ebx
  105254:	83 ec 14             	sub    $0x14,%esp
  if(cp->state == RUNNING)
  105257:	e8 34 e6 ff ff       	call   103890 <cpu>
  10525c:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  105263:	8b 40 0c             	mov    0xc(%eax),%eax
  105266:	83 f8 04             	cmp    $0x4,%eax
  105269:	75 0c                	jne    105277 <sched+0x27>
    panic("sched running");
  10526b:	c7 04 24 27 a6 11 00 	movl   $0x11a627,(%esp)
  105272:	e8 89 bd ff ff       	call   101000 <panic>
  if(!holding(&proc_table_lock))
  105277:	c7 04 24 40 0c 14 00 	movl   $0x140c40,(%esp)
  10527e:	e8 cd 0b 00 00       	call   105e50 <holding>
  105283:	85 c0                	test   %eax,%eax
  105285:	75 0c                	jne    105293 <sched+0x43>
    panic("sched proc_table_lock");
  105287:	c7 04 24 35 a6 11 00 	movl   $0x11a635,(%esp)
  10528e:	e8 6d bd ff ff       	call   101000 <panic>
//  if(cpus[cpu()].nlock != 1)
//    panic("sched locks");

  swtch(&cp->context, &cpus[cpu()].context);
  105293:	e8 f8 e5 ff ff       	call   103890 <cpu>
  105298:	69 c0 ec 10 00 00    	imul   $0x10ec,%eax,%eax
  10529e:	05 20 cc 13 00       	add    $0x13cc20,%eax
  1052a3:	8d 58 04             	lea    0x4(%eax),%ebx
  1052a6:	e8 e5 e5 ff ff       	call   103890 <cpu>
  1052ab:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  1052b2:	83 c0 64             	add    $0x64,%eax
  1052b5:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  1052b9:	89 04 24             	mov    %eax,(%esp)
  1052bc:	e8 77 0e 00 00       	call   106138 <swtch>
}
  1052c1:	83 c4 14             	add    $0x14,%esp
  1052c4:	5b                   	pop    %ebx
  1052c5:	5d                   	pop    %ebp
  1052c6:	c3                   	ret    
  1052c7:	89 f6                	mov    %esi,%esi
  1052c9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

001052d0 <yield>:

// Give up the CPU for one scheduling round.
void
yield(void)
{
  1052d0:	55                   	push   %ebp
  1052d1:	89 e5                	mov    %esp,%ebp
  1052d3:	83 ec 08             	sub    $0x8,%esp
  acquire(&proc_table_lock);
  1052d6:	c7 04 24 40 0c 14 00 	movl   $0x140c40,(%esp)
  1052dd:	e8 2e 08 00 00       	call   105b10 <acquire>
  cp->state = RUNNABLE;
  1052e2:	e8 a9 e5 ff ff       	call   103890 <cpu>
  1052e7:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  1052ee:	c7 40 0c 03 00 00 00 	movl   $0x3,0xc(%eax)
  sched();
  1052f5:	e8 56 ff ff ff       	call   105250 <sched>
  release(&proc_table_lock);
  1052fa:	c7 04 24 40 0c 14 00 	movl   $0x140c40,(%esp)
  105301:	e8 0a 0a 00 00       	call   105d10 <release>
}
  105306:	c9                   	leave  
  105307:	c3                   	ret    
  105308:	90                   	nop    
  105309:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

00105310 <forkret>:

// A fork child's very first scheduling by scheduler()
// will swtch here.  "Return" to user space.
void
forkret(void)
{
  105310:	55                   	push   %ebp
  105311:	89 e5                	mov    %esp,%ebp
  105313:	83 ec 08             	sub    $0x8,%esp
  // Still holding proc_table_lock from scheduler.
  release(&proc_table_lock);
  105316:	c7 04 24 40 0c 14 00 	movl   $0x140c40,(%esp)
  10531d:	e8 ee 09 00 00       	call   105d10 <release>

  // Jump into assembly, never to return.
  forkret1(cp->tf);
  105322:	e8 69 e5 ff ff       	call   103890 <cpu>
  105327:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  10532e:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
  105334:	89 04 24             	mov    %eax,(%esp)
  105337:	e8 54 2c 00 00       	call   107f90 <forkret1>
}
  10533c:	c9                   	leave  
  10533d:	c3                   	ret    
  10533e:	89 f6                	mov    %esi,%esi

00105340 <msleep_spin>:

int
msleep_spin(void *chan, struct spinlock *lk, int timo)
{
  105340:	55                   	push   %ebp
  105341:	89 e5                	mov    %esp,%ebp
  105343:	83 ec 18             	sub    $0x18,%esp
    uint32_t s = millitime();
  105346:	e8 15 2c 00 00       	call   107f60 <millitime>
  10534b:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
    uint32_t p = s;
  10534e:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  105351:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
    int ret = 1; // Time Out
  105354:	c7 45 fc 01 00 00 00 	movl   $0x1,0xfffffffc(%ebp)
    s += timo;
  10535b:	8b 45 10             	mov    0x10(%ebp),%eax
  10535e:	01 45 f4             	add    %eax,0xfffffff4(%ebp)

    if (cp == 0)
  105361:	e8 2a e5 ff ff       	call   103890 <cpu>
  105366:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  10536d:	85 c0                	test   %eax,%eax
  10536f:	75 0c                	jne    10537d <msleep_spin+0x3d>
        panic("msleep with cp == 0");
  105371:	c7 04 24 4b a6 11 00 	movl   $0x11a64b,(%esp)
  105378:	e8 83 bc ff ff       	call   101000 <panic>
    if (lk == 0)
  10537d:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  105381:	75 0c                	jne    10538f <msleep_spin+0x4f>
        panic("msleep without lock");
  105383:	c7 04 24 5f a6 11 00 	movl   $0x11a65f,(%esp)
  10538a:	e8 71 bc ff ff       	call   101000 <panic>

    if (lk != &proc_table_lock)
  10538f:	81 7d 0c 40 0c 14 00 	cmpl   $0x140c40,0xc(%ebp)
  105396:	74 17                	je     1053af <msleep_spin+0x6f>
    {
        acquire(&proc_table_lock);
  105398:	c7 04 24 40 0c 14 00 	movl   $0x140c40,(%esp)
  10539f:	e8 6c 07 00 00       	call   105b10 <acquire>
        release(lk);
  1053a4:	8b 45 0c             	mov    0xc(%ebp),%eax
  1053a7:	89 04 24             	mov    %eax,(%esp)
  1053aa:	e8 61 09 00 00       	call   105d10 <release>
    }

    cp->chan = chan;
  1053af:	e8 dc e4 ff ff       	call   103890 <cpu>
  1053b4:	8b 14 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%edx
  1053bb:	8b 45 08             	mov    0x8(%ebp),%eax
  1053be:	89 42 18             	mov    %eax,0x18(%edx)
    cp->state = MSLEEPING;
  1053c1:	e8 ca e4 ff ff       	call   103890 <cpu>
  1053c6:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  1053cd:	c7 40 0c 06 00 00 00 	movl   $0x6,0xc(%eax)
    while (p < s)
  1053d4:	eb 2a                	jmp    105400 <msleep_spin+0xc0>
    {
        sched();
  1053d6:	e8 75 fe ff ff       	call   105250 <sched>
        if (cp->state == RUNNING)
  1053db:	e8 b0 e4 ff ff       	call   103890 <cpu>
  1053e0:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  1053e7:	8b 40 0c             	mov    0xc(%eax),%eax
  1053ea:	83 f8 04             	cmp    $0x4,%eax
  1053ed:	75 09                	jne    1053f8 <msleep_spin+0xb8>
        {
            ret = 0;
  1053ef:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
            break;
  1053f6:	eb 10                	jmp    105408 <msleep_spin+0xc8>
        }
        p = millitime();
  1053f8:	e8 63 2b 00 00       	call   107f60 <millitime>
  1053fd:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  105400:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  105403:	3b 45 f4             	cmp    0xfffffff4(%ebp),%eax
  105406:	72 ce                	jb     1053d6 <msleep_spin+0x96>
    }
    cp->chan = 0;
  105408:	e8 83 e4 ff ff       	call   103890 <cpu>
  10540d:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  105414:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
    cp->state = RUNNING;
  10541b:	e8 70 e4 ff ff       	call   103890 <cpu>
  105420:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  105427:	c7 40 0c 04 00 00 00 	movl   $0x4,0xc(%eax)

    if (lk != &proc_table_lock)
  10542e:	81 7d 0c 40 0c 14 00 	cmpl   $0x140c40,0xc(%ebp)
  105435:	74 17                	je     10544e <msleep_spin+0x10e>
    {
        release(&proc_table_lock);
  105437:	c7 04 24 40 0c 14 00 	movl   $0x140c40,(%esp)
  10543e:	e8 cd 08 00 00       	call   105d10 <release>
        acquire(lk);
  105443:	8b 45 0c             	mov    0xc(%ebp),%eax
  105446:	89 04 24             	mov    %eax,(%esp)
  105449:	e8 c2 06 00 00       	call   105b10 <acquire>
    }
    return ret;
  10544e:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
}
  105451:	c9                   	leave  
  105452:	c3                   	ret    
  105453:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  105459:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00105460 <sleep>:

// Atomically release lock and sleep on chan.
// Reacquires lock when reawakened.
void
sleep(void *chan, struct spinlock *lk)
{
  105460:	55                   	push   %ebp
  105461:	89 e5                	mov    %esp,%ebp
  105463:	83 ec 08             	sub    $0x8,%esp
  if(cp == 0)
  105466:	e8 25 e4 ff ff       	call   103890 <cpu>
  10546b:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  105472:	85 c0                	test   %eax,%eax
  105474:	75 0c                	jne    105482 <sleep+0x22>
    panic("sleep");
  105476:	c7 04 24 73 a6 11 00 	movl   $0x11a673,(%esp)
  10547d:	e8 7e bb ff ff       	call   101000 <panic>

  if(lk == 0)
  105482:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  105486:	75 0c                	jne    105494 <sleep+0x34>
    panic("sleep without lk");
  105488:	c7 04 24 79 a6 11 00 	movl   $0x11a679,(%esp)
  10548f:	e8 6c bb ff ff       	call   101000 <panic>

  // Must acquire proc_table_lock in order to
  // change p->state and then call sched.
  // Once we hold proc_table_lock, we can be
  // guaranteed that we won't miss any wakeup
  // (wakeup runs with proc_table_lock locked),
  // so it's okay to release lk.
  if(lk != &proc_table_lock){
  105494:	81 7d 0c 40 0c 14 00 	cmpl   $0x140c40,0xc(%ebp)
  10549b:	74 17                	je     1054b4 <sleep+0x54>
    acquire(&proc_table_lock);
  10549d:	c7 04 24 40 0c 14 00 	movl   $0x140c40,(%esp)
  1054a4:	e8 67 06 00 00       	call   105b10 <acquire>
    release(lk);
  1054a9:	8b 45 0c             	mov    0xc(%ebp),%eax
  1054ac:	89 04 24             	mov    %eax,(%esp)
  1054af:	e8 5c 08 00 00       	call   105d10 <release>
  }

  // Go to sleep.
  cp->chan = chan;
  1054b4:	e8 d7 e3 ff ff       	call   103890 <cpu>
  1054b9:	8b 14 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%edx
  1054c0:	8b 45 08             	mov    0x8(%ebp),%eax
  1054c3:	89 42 18             	mov    %eax,0x18(%edx)
  cp->state = SLEEPING;
  1054c6:	e8 c5 e3 ff ff       	call   103890 <cpu>
  1054cb:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  1054d2:	c7 40 0c 02 00 00 00 	movl   $0x2,0xc(%eax)
  sched();
  1054d9:	e8 72 fd ff ff       	call   105250 <sched>

  // Tidy up.
  cp->chan = 0;
  1054de:	e8 ad e3 ff ff       	call   103890 <cpu>
  1054e3:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  1054ea:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)

  // Reacquire original lock.
  if(lk != &proc_table_lock){
  1054f1:	81 7d 0c 40 0c 14 00 	cmpl   $0x140c40,0xc(%ebp)
  1054f8:	74 17                	je     105511 <sleep+0xb1>
    release(&proc_table_lock);
  1054fa:	c7 04 24 40 0c 14 00 	movl   $0x140c40,(%esp)
  105501:	e8 0a 08 00 00       	call   105d10 <release>
    acquire(lk);
  105506:	8b 45 0c             	mov    0xc(%ebp),%eax
  105509:	89 04 24             	mov    %eax,(%esp)
  10550c:	e8 ff 05 00 00       	call   105b10 <acquire>
  }
}
  105511:	c9                   	leave  
  105512:	c3                   	ret    
  105513:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  105519:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00105520 <wakeup1>:

// Wake up all processes sleeping on chan.
// Proc_table_lock must be held.
static void
wakeup1(void *chan)
{
  105520:	55                   	push   %ebp
  105521:	89 e5                	mov    %esp,%ebp
  105523:	83 ec 10             	sub    $0x10,%esp
  struct proc *p;

  for(p = proc; p < &proc[NPROC]; p++)
  105526:	c7 45 fc 20 e1 13 00 	movl   $0x13e120,0xfffffffc(%ebp)
  10552d:	eb 32                	jmp    105561 <wakeup1+0x41>
    if(((p->state == SLEEPING) || 
  10552f:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  105532:	8b 40 0c             	mov    0xc(%eax),%eax
  105535:	83 f8 02             	cmp    $0x2,%eax
  105538:	74 0b                	je     105545 <wakeup1+0x25>
  10553a:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10553d:	8b 40 0c             	mov    0xc(%eax),%eax
  105540:	83 f8 06             	cmp    $0x6,%eax
  105543:	75 15                	jne    10555a <wakeup1+0x3a>
  105545:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  105548:	8b 40 18             	mov    0x18(%eax),%eax
  10554b:	3b 45 08             	cmp    0x8(%ebp),%eax
  10554e:	75 0a                	jne    10555a <wakeup1+0x3a>
                (p->state == MSLEEPING)) && p->chan == chan)
      p->state = RUNNABLE;
  105550:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  105553:	c7 40 0c 03 00 00 00 	movl   $0x3,0xc(%eax)
  10555a:	81 45 fc ac 00 00 00 	addl   $0xac,0xfffffffc(%ebp)
  105561:	b8 20 0c 14 00       	mov    $0x140c20,%eax
  105566:	39 45 fc             	cmp    %eax,0xfffffffc(%ebp)
  105569:	72 c4                	jb     10552f <wakeup1+0xf>
}
  10556b:	c9                   	leave  
  10556c:	c3                   	ret    
  10556d:	8d 76 00             	lea    0x0(%esi),%esi

00105570 <wakeup_one1>:

// Wake up all processes sleeping on chan.
// Proc_table_lock must be held.
static void
wakeup_one1(void *chan)
{
  105570:	55                   	push   %ebp
  105571:	89 e5                	mov    %esp,%ebp
  105573:	83 ec 10             	sub    $0x10,%esp
  struct proc *p;

  for(p = proc; p < &proc[NPROC]; p++)
  105576:	c7 45 fc 20 e1 13 00 	movl   $0x13e120,0xfffffffc(%ebp)
  10557d:	eb 34                	jmp    1055b3 <wakeup_one1+0x43>
    if(((p->state == SLEEPING) || 
  10557f:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  105582:	8b 40 0c             	mov    0xc(%eax),%eax
  105585:	83 f8 02             	cmp    $0x2,%eax
  105588:	74 0b                	je     105595 <wakeup_one1+0x25>
  10558a:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10558d:	8b 40 0c             	mov    0xc(%eax),%eax
  105590:	83 f8 06             	cmp    $0x6,%eax
  105593:	75 17                	jne    1055ac <wakeup_one1+0x3c>
  105595:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  105598:	8b 40 18             	mov    0x18(%eax),%eax
  10559b:	3b 45 08             	cmp    0x8(%ebp),%eax
  10559e:	75 0c                	jne    1055ac <wakeup_one1+0x3c>
                (p->state == MSLEEPING)) && p->chan == chan)
    {
      p->state = RUNNABLE;
  1055a0:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1055a3:	c7 40 0c 03 00 00 00 	movl   $0x3,0xc(%eax)
      break;
  1055aa:	eb 11                	jmp    1055bd <wakeup_one1+0x4d>
  1055ac:	81 45 fc ac 00 00 00 	addl   $0xac,0xfffffffc(%ebp)
  1055b3:	b8 20 0c 14 00       	mov    $0x140c20,%eax
  1055b8:	39 45 fc             	cmp    %eax,0xfffffffc(%ebp)
  1055bb:	72 c2                	jb     10557f <wakeup_one1+0xf>
    }
}
  1055bd:	c9                   	leave  
  1055be:	c3                   	ret    
  1055bf:	90                   	nop    

001055c0 <wakeup_one>:

void
wakeup_one(void *chan)
{
  1055c0:	55                   	push   %ebp
  1055c1:	89 e5                	mov    %esp,%ebp
  1055c3:	83 ec 08             	sub    $0x8,%esp
  acquire(&proc_table_lock);
  1055c6:	c7 04 24 40 0c 14 00 	movl   $0x140c40,(%esp)
  1055cd:	e8 3e 05 00 00       	call   105b10 <acquire>
  wakeup_one1(chan);
  1055d2:	8b 45 08             	mov    0x8(%ebp),%eax
  1055d5:	89 04 24             	mov    %eax,(%esp)
  1055d8:	e8 93 ff ff ff       	call   105570 <wakeup_one1>
  release(&proc_table_lock);
  1055dd:	c7 04 24 40 0c 14 00 	movl   $0x140c40,(%esp)
  1055e4:	e8 27 07 00 00       	call   105d10 <release>
}
  1055e9:	c9                   	leave  
  1055ea:	c3                   	ret    
  1055eb:	90                   	nop    
  1055ec:	8d 74 26 00          	lea    0x0(%esi),%esi

001055f0 <wakeup>:

// Wake up all processes sleeping on chan.
// Proc_table_lock is acquired and released.
void
wakeup(void *chan)
{
  1055f0:	55                   	push   %ebp
  1055f1:	89 e5                	mov    %esp,%ebp
  1055f3:	83 ec 08             	sub    $0x8,%esp
  acquire(&proc_table_lock);
  1055f6:	c7 04 24 40 0c 14 00 	movl   $0x140c40,(%esp)
  1055fd:	e8 0e 05 00 00       	call   105b10 <acquire>
  wakeup1(chan);
  105602:	8b 45 08             	mov    0x8(%ebp),%eax
  105605:	89 04 24             	mov    %eax,(%esp)
  105608:	e8 13 ff ff ff       	call   105520 <wakeup1>
  release(&proc_table_lock);
  10560d:	c7 04 24 40 0c 14 00 	movl   $0x140c40,(%esp)
  105614:	e8 f7 06 00 00       	call   105d10 <release>
}
  105619:	c9                   	leave  
  10561a:	c3                   	ret    
  10561b:	90                   	nop    
  10561c:	8d 74 26 00          	lea    0x0(%esi),%esi

00105620 <kill>:

// Kill the process with the given pid.
// Process won't actually exit until it returns
// to user space (see trap in trap.c).
int
kill(int pid)
{
  105620:	55                   	push   %ebp
  105621:	89 e5                	mov    %esp,%ebp
  105623:	83 ec 18             	sub    $0x18,%esp
  struct proc *p;

  acquire(&proc_table_lock);
  105626:	c7 04 24 40 0c 14 00 	movl   $0x140c40,(%esp)
  10562d:	e8 de 04 00 00       	call   105b10 <acquire>
  for(p = proc; p < &proc[NPROC]; p++){
  105632:	c7 45 fc 20 e1 13 00 	movl   $0x13e120,0xfffffffc(%ebp)
  105639:	eb 46                	jmp    105681 <kill+0x61>
    if(p->pid == pid){
  10563b:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10563e:	8b 40 10             	mov    0x10(%eax),%eax
  105641:	3b 45 08             	cmp    0x8(%ebp),%eax
  105644:	75 34                	jne    10567a <kill+0x5a>
      p->killed = 1;
  105646:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  105649:	c7 40 1c 01 00 00 00 	movl   $0x1,0x1c(%eax)
      // Wake process from sleep if necessary.
      if(p->state == SLEEPING)
  105650:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  105653:	8b 40 0c             	mov    0xc(%eax),%eax
  105656:	83 f8 02             	cmp    $0x2,%eax
  105659:	75 0a                	jne    105665 <kill+0x45>
        p->state = RUNNABLE;
  10565b:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10565e:	c7 40 0c 03 00 00 00 	movl   $0x3,0xc(%eax)
      release(&proc_table_lock);
  105665:	c7 04 24 40 0c 14 00 	movl   $0x140c40,(%esp)
  10566c:	e8 9f 06 00 00       	call   105d10 <release>
      return 0;
  105671:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  105678:	eb 24                	jmp    10569e <kill+0x7e>
  10567a:	81 45 fc ac 00 00 00 	addl   $0xac,0xfffffffc(%ebp)
  105681:	b8 20 0c 14 00       	mov    $0x140c20,%eax
  105686:	39 45 fc             	cmp    %eax,0xfffffffc(%ebp)
  105689:	72 b0                	jb     10563b <kill+0x1b>
    }
  }
  release(&proc_table_lock);
  10568b:	c7 04 24 40 0c 14 00 	movl   $0x140c40,(%esp)
  105692:	e8 79 06 00 00       	call   105d10 <release>
  return -1;
  105697:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  10569e:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  1056a1:	c9                   	leave  
  1056a2:	c3                   	ret    
  1056a3:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  1056a9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

001056b0 <exit>:

// Exit the current process.  Does not return.
// Exited processes remain in the zombie state
// until their parent calls wait() to find out they exited.
void
exit(void)
{
  1056b0:	55                   	push   %ebp
  1056b1:	89 e5                	mov    %esp,%ebp
  1056b3:	53                   	push   %ebx
  1056b4:	83 ec 14             	sub    $0x14,%esp
  struct proc *p;
  int fd;

  if(cp == initproc)
  1056b7:	e8 d4 e1 ff ff       	call   103890 <cpu>
  1056bc:	8b 14 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%edx
  1056c3:	a1 24 0c 14 00       	mov    0x140c24,%eax
  1056c8:	39 c2                	cmp    %eax,%edx
  1056ca:	75 0c                	jne    1056d8 <exit+0x28>
    panic("init exiting");
  1056cc:	c7 04 24 8a a6 11 00 	movl   $0x11a68a,(%esp)
  1056d3:	e8 28 b9 ff ff       	call   101000 <panic>

  // Close all open files.
  for(fd = 0; fd < NOFILE; fd++){
  1056d8:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)
  1056df:	eb 4d                	jmp    10572e <exit+0x7e>
    if(cp->ofile[fd]){
  1056e1:	e8 aa e1 ff ff       	call   103890 <cpu>
  1056e6:	8b 14 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%edx
  1056ed:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1056f0:	8b 44 82 20          	mov    0x20(%edx,%eax,4),%eax
  1056f4:	85 c0                	test   %eax,%eax
  1056f6:	74 32                	je     10572a <exit+0x7a>
      fileclose(cp->ofile[fd]);
  1056f8:	e8 93 e1 ff ff       	call   103890 <cpu>
  1056fd:	8b 14 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%edx
  105704:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  105707:	8b 44 82 20          	mov    0x20(%edx,%eax,4),%eax
  10570b:	89 04 24             	mov    %eax,(%esp)
  10570e:	e8 4d bf ff ff       	call   101660 <fileclose>
      cp->ofile[fd] = 0;
  105713:	e8 78 e1 ff ff       	call   103890 <cpu>
  105718:	8b 14 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%edx
  10571f:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  105722:	c7 44 82 20 00 00 00 	movl   $0x0,0x20(%edx,%eax,4)
  105729:	00 
  10572a:	83 45 f8 01          	addl   $0x1,0xfffffff8(%ebp)
  10572e:	83 7d f8 0f          	cmpl   $0xf,0xfffffff8(%ebp)
  105732:	7e ad                	jle    1056e1 <exit+0x31>
    }
  }

  iput(cp->cwd);
  105734:	e8 57 e1 ff ff       	call   103890 <cpu>
  105739:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  105740:	8b 40 60             	mov    0x60(%eax),%eax
  105743:	89 04 24             	mov    %eax,(%esp)
  105746:	e8 35 c8 ff ff       	call   101f80 <iput>
  cp->cwd = 0;
  10574b:	e8 40 e1 ff ff       	call   103890 <cpu>
  105750:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  105757:	c7 40 60 00 00 00 00 	movl   $0x0,0x60(%eax)

  acquire(&proc_table_lock);
  10575e:	c7 04 24 40 0c 14 00 	movl   $0x140c40,(%esp)
  105765:	e8 a6 03 00 00       	call   105b10 <acquire>

  // Parent might be sleeping in proc_wait.
  wakeup1(cp->parent);
  10576a:	e8 21 e1 ff ff       	call   103890 <cpu>
  10576f:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  105776:	8b 40 14             	mov    0x14(%eax),%eax
  105779:	89 04 24             	mov    %eax,(%esp)
  10577c:	e8 9f fd ff ff       	call   105520 <wakeup1>

  // Pass abandoned children to init.
  for(p = proc; p < &proc[NPROC]; p++){
  105781:	c7 45 f4 20 e1 13 00 	movl   $0x13e120,0xfffffff4(%ebp)
  105788:	eb 41                	jmp    1057cb <exit+0x11b>
    if(p->parent == cp){
  10578a:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10578d:	8b 58 14             	mov    0x14(%eax),%ebx
  105790:	e8 fb e0 ff ff       	call   103890 <cpu>
  105795:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  10579c:	39 c3                	cmp    %eax,%ebx
  10579e:	75 24                	jne    1057c4 <exit+0x114>
      p->parent = initproc;
  1057a0:	8b 15 24 0c 14 00    	mov    0x140c24,%edx
  1057a6:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  1057a9:	89 50 14             	mov    %edx,0x14(%eax)
      if(p->state == ZOMBIE)
  1057ac:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  1057af:	8b 40 0c             	mov    0xc(%eax),%eax
  1057b2:	83 f8 05             	cmp    $0x5,%eax
  1057b5:	75 0d                	jne    1057c4 <exit+0x114>
        wakeup1(initproc);
  1057b7:	a1 24 0c 14 00       	mov    0x140c24,%eax
  1057bc:	89 04 24             	mov    %eax,(%esp)
  1057bf:	e8 5c fd ff ff       	call   105520 <wakeup1>
  1057c4:	81 45 f4 ac 00 00 00 	addl   $0xac,0xfffffff4(%ebp)
  1057cb:	b8 20 0c 14 00       	mov    $0x140c20,%eax
  1057d0:	39 45 f4             	cmp    %eax,0xfffffff4(%ebp)
  1057d3:	72 b5                	jb     10578a <exit+0xda>
    }
  }

  if (cp->thr)
  1057d5:	e8 b6 e0 ff ff       	call   103890 <cpu>
  1057da:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  1057e1:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
  1057e7:	85 c0                	test   %eax,%eax
  1057e9:	74 1a                	je     105805 <exit+0x155>
      kproc_free(cp->thr);
  1057eb:	e8 a0 e0 ff ff       	call   103890 <cpu>
  1057f0:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  1057f7:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
  1057fd:	89 04 24             	mov    %eax,(%esp)
  105800:	e8 6b 45 00 00       	call   109d70 <kproc_free>

  // Jump into the scheduler, never to return.
  cp->killed = 0;
  105805:	e8 86 e0 ff ff       	call   103890 <cpu>
  10580a:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  105811:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
  cp->state = ZOMBIE;
  105818:	e8 73 e0 ff ff       	call   103890 <cpu>
  10581d:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  105824:	c7 40 0c 05 00 00 00 	movl   $0x5,0xc(%eax)
  cp->thr = 0;
  10582b:	e8 60 e0 ff ff       	call   103890 <cpu>
  105830:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  105837:	c7 80 a8 00 00 00 00 	movl   $0x0,0xa8(%eax)
  10583e:	00 00 00 
  sched();
  105841:	e8 0a fa ff ff       	call   105250 <sched>
  panic("zombie exit");
  105846:	c7 04 24 97 a6 11 00 	movl   $0x11a697,(%esp)
  10584d:	e8 ae b7 ff ff       	call   101000 <panic>
  105852:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi
  105859:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00105860 <wait>:
}

// Wait for a child process to exit and return its pid.
// Return -1 if this process has no children.
int
wait(void)
{
  105860:	55                   	push   %ebp
  105861:	89 e5                	mov    %esp,%ebp
  105863:	53                   	push   %ebx
  105864:	83 ec 24             	sub    $0x24,%esp
  struct proc *p;
  int i, havekids, pid;

  acquire(&proc_table_lock);
  105867:	c7 04 24 40 0c 14 00 	movl   $0x140c40,(%esp)
  10586e:	e8 9d 02 00 00       	call   105b10 <acquire>
  for(;;){
    // Scan through table looking for zombie children.
    havekids = 0;
  105873:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
    for(i = 0; i < NPROC; i++){
  10587a:	c7 45 f0 00 00 00 00 	movl   $0x0,0xfffffff0(%ebp)
  105881:	e9 cd 00 00 00       	jmp    105953 <wait+0xf3>
      p = &proc[i];
  105886:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  105889:	69 c0 ac 00 00 00    	imul   $0xac,%eax,%eax
  10588f:	05 20 e1 13 00       	add    $0x13e120,%eax
  105894:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
      if(p->state == UNUSED)
  105897:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10589a:	8b 40 0c             	mov    0xc(%eax),%eax
  10589d:	85 c0                	test   %eax,%eax
  10589f:	0f 84 aa 00 00 00    	je     10594f <wait+0xef>
        continue;
      if(p->parent == cp){
  1058a5:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  1058a8:	8b 58 14             	mov    0x14(%eax),%ebx
  1058ab:	e8 e0 df ff ff       	call   103890 <cpu>
  1058b0:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  1058b7:	39 c3                	cmp    %eax,%ebx
  1058b9:	0f 85 90 00 00 00    	jne    10594f <wait+0xef>
        if(p->state == ZOMBIE){
  1058bf:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  1058c2:	8b 40 0c             	mov    0xc(%eax),%eax
  1058c5:	83 f8 05             	cmp    $0x5,%eax
  1058c8:	75 7e                	jne    105948 <wait+0xe8>
          // Found one.
#ifdef PROC_DEBUG
          cprintf("wait: freeing ZOMBIE %d %s\n", p->pid, p->name);
          cprintf("      freeing mem\n");
#endif
          if (p->sz != 0) // kernel thread doesn't have mem
  1058ca:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  1058cd:	8b 40 04             	mov    0x4(%eax),%eax
  1058d0:	85 c0                	test   %eax,%eax
  1058d2:	74 19                	je     1058ed <wait+0x8d>
            kfree(p->mem, p->sz);
  1058d4:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  1058d7:	8b 40 04             	mov    0x4(%eax),%eax
  1058da:	89 c2                	mov    %eax,%edx
  1058dc:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  1058df:	8b 00                	mov    (%eax),%eax
  1058e1:	89 54 24 04          	mov    %edx,0x4(%esp)
  1058e5:	89 04 24             	mov    %eax,(%esp)
  1058e8:	e8 13 da ff ff       	call   103300 <kfree>
#ifdef PROC_DEBUG
          cprintf("      freeing kstack\n");
#endif
          kfree(p->kstack, KSTACKSIZE);
  1058ed:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  1058f0:	8b 40 08             	mov    0x8(%eax),%eax
  1058f3:	c7 44 24 04 00 10 00 	movl   $0x1000,0x4(%esp)
  1058fa:	00 
  1058fb:	89 04 24             	mov    %eax,(%esp)
  1058fe:	e8 fd d9 ff ff       	call   103300 <kfree>
          pid = p->pid;
  105903:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  105906:	8b 40 10             	mov    0x10(%eax),%eax
  105909:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
          p->state = UNUSED;
  10590c:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10590f:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
          p->pid = 0;
  105916:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  105919:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
          p->parent = 0;
  105920:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  105923:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
          p->name[0] = 0;
  10592a:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10592d:	c6 80 88 00 00 00 00 	movb   $0x0,0x88(%eax)
          release(&proc_table_lock);
  105934:	c7 04 24 40 0c 14 00 	movl   $0x140c40,(%esp)
  10593b:	e8 d0 03 00 00       	call   105d10 <release>
          return pid;
  105940:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  105943:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
  105946:	eb 64                	jmp    1059ac <wait+0x14c>
        }
        havekids = 1;
  105948:	c7 45 f4 01 00 00 00 	movl   $0x1,0xfffffff4(%ebp)
  10594f:	83 45 f0 01          	addl   $0x1,0xfffffff0(%ebp)
  105953:	83 7d f0 3f          	cmpl   $0x3f,0xfffffff0(%ebp)
  105957:	0f 8e 29 ff ff ff    	jle    105886 <wait+0x26>
      }
    }

    // No point waiting if we don't have any children.
    if(!havekids || cp->killed){
  10595d:	83 7d f4 00          	cmpl   $0x0,0xfffffff4(%ebp)
  105961:	74 13                	je     105976 <wait+0x116>
  105963:	e8 28 df ff ff       	call   103890 <cpu>
  105968:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  10596f:	8b 40 1c             	mov    0x1c(%eax),%eax
  105972:	85 c0                	test   %eax,%eax
  105974:	74 15                	je     10598b <wait+0x12b>
      release(&proc_table_lock);
  105976:	c7 04 24 40 0c 14 00 	movl   $0x140c40,(%esp)
  10597d:	e8 8e 03 00 00       	call   105d10 <release>
      return -1;
  105982:	c7 45 e8 ff ff ff ff 	movl   $0xffffffff,0xffffffe8(%ebp)
  105989:	eb 21                	jmp    1059ac <wait+0x14c>
    }

    // Wait for children to exit.  (See wakeup1 call in proc_exit.)
    sleep(cp, &proc_table_lock);
  10598b:	e8 00 df ff ff       	call   103890 <cpu>
  105990:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  105997:	c7 44 24 04 40 0c 14 	movl   $0x140c40,0x4(%esp)
  10599e:	00 
  10599f:	89 04 24             	mov    %eax,(%esp)
  1059a2:	e8 b9 fa ff ff       	call   105460 <sleep>
  }
  1059a7:	e9 c7 fe ff ff       	jmp    105873 <wait+0x13>
  1059ac:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
}
  1059af:	83 c4 24             	add    $0x24,%esp
  1059b2:	5b                   	pop    %ebx
  1059b3:	5d                   	pop    %ebp
  1059b4:	c3                   	ret    
  1059b5:	8d 74 26 00          	lea    0x0(%esi),%esi
  1059b9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

001059c0 <procdump>:

// Print a process listing to console.  For debugging.
// Runs when user types ^P on console.
// No lock to avoid wedging a stuck machine further.
void
procdump(void)
{
  1059c0:	55                   	push   %ebp
  1059c1:	89 e5                	mov    %esp,%ebp
  1059c3:	83 ec 58             	sub    $0x58,%esp
  static char *states[] = {
  [UNUSED]    "unused",
  [EMBRYO]    "embryo",
  [SLEEPING]  "sleep ",
  [RUNNABLE]  "runble",
  [RUNNING]   "run   ",
  [ZOMBIE]    "zombie",
  [MSLEEPING] "msleep"
  };
  int i, j;
  struct proc *p;
  char *state;
  uint pc[10];
  
  for(i = 0; i < NPROC; i++){
  1059c6:	c7 45 f0 00 00 00 00 	movl   $0x0,0xfffffff0(%ebp)
  1059cd:	e9 f4 00 00 00       	jmp    105ac6 <procdump+0x106>
    p = &proc[i];
  1059d2:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  1059d5:	69 c0 ac 00 00 00    	imul   $0xac,%eax,%eax
  1059db:	05 20 e1 13 00       	add    $0x13e120,%eax
  1059e0:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
    if(p->state == UNUSED)
  1059e3:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1059e6:	8b 40 0c             	mov    0xc(%eax),%eax
  1059e9:	85 c0                	test   %eax,%eax
  1059eb:	0f 84 d1 00 00 00    	je     105ac2 <procdump+0x102>
      continue;
    if(p->state >= 0 && p->state < NELEM(states) && states[p->state])
  1059f1:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1059f4:	8b 40 0c             	mov    0xc(%eax),%eax
  1059f7:	83 f8 06             	cmp    $0x6,%eax
  1059fa:	77 23                	ja     105a1f <procdump+0x5f>
  1059fc:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1059ff:	8b 40 0c             	mov    0xc(%eax),%eax
  105a02:	8b 04 85 f8 c5 11 00 	mov    0x11c5f8(,%eax,4),%eax
  105a09:	85 c0                	test   %eax,%eax
  105a0b:	74 12                	je     105a1f <procdump+0x5f>
      state = states[p->state];
  105a0d:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  105a10:	8b 40 0c             	mov    0xc(%eax),%eax
  105a13:	8b 04 85 f8 c5 11 00 	mov    0x11c5f8(,%eax,4),%eax
  105a1a:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  105a1d:	eb 07                	jmp    105a26 <procdump+0x66>
    else
      state = "???";
  105a1f:	c7 45 fc d4 a6 11 00 	movl   $0x11a6d4,0xfffffffc(%ebp)
    cprintf("%d %s %s", p->pid, state, p->name);
  105a26:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  105a29:	81 c2 88 00 00 00    	add    $0x88,%edx
  105a2f:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  105a32:	8b 48 10             	mov    0x10(%eax),%ecx
  105a35:	89 54 24 0c          	mov    %edx,0xc(%esp)
  105a39:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  105a3c:	89 44 24 08          	mov    %eax,0x8(%esp)
  105a40:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  105a44:	c7 04 24 d8 a6 11 00 	movl   $0x11a6d8,(%esp)
  105a4b:	e8 c0 ac ff ff       	call   100710 <cprintf>
    if((p->state == SLEEPING) || (p->state == MSLEEPING)){
  105a50:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  105a53:	8b 40 0c             	mov    0xc(%eax),%eax
  105a56:	83 f8 02             	cmp    $0x2,%eax
  105a59:	74 0b                	je     105a66 <procdump+0xa6>
  105a5b:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  105a5e:	8b 40 0c             	mov    0xc(%eax),%eax
  105a61:	83 f8 06             	cmp    $0x6,%eax
  105a64:	75 50                	jne    105ab6 <procdump+0xf6>
      getcallerpcs((uint*)p->context.ebp+2, pc);
  105a66:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  105a69:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
  105a6f:	8d 50 08             	lea    0x8(%eax),%edx
  105a72:	8d 45 c8             	lea    0xffffffc8(%ebp),%eax
  105a75:	89 44 24 04          	mov    %eax,0x4(%esp)
  105a79:	89 14 24             	mov    %edx,(%esp)
  105a7c:	e8 5f 03 00 00       	call   105de0 <getcallerpcs>
      for(j=0; j<10 && pc[j] != 0; j++)
  105a81:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
  105a88:	eb 1b                	jmp    105aa5 <procdump+0xe5>
        cprintf(" %p", pc[j]);
  105a8a:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  105a8d:	8b 44 85 c8          	mov    0xffffffc8(%ebp,%eax,4),%eax
  105a91:	89 44 24 04          	mov    %eax,0x4(%esp)
  105a95:	c7 04 24 e1 a6 11 00 	movl   $0x11a6e1,(%esp)
  105a9c:	e8 6f ac ff ff       	call   100710 <cprintf>
  105aa1:	83 45 f4 01          	addl   $0x1,0xfffffff4(%ebp)
  105aa5:	83 7d f4 09          	cmpl   $0x9,0xfffffff4(%ebp)
  105aa9:	7f 0b                	jg     105ab6 <procdump+0xf6>
  105aab:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  105aae:	8b 44 85 c8          	mov    0xffffffc8(%ebp,%eax,4),%eax
  105ab2:	85 c0                	test   %eax,%eax
  105ab4:	75 d4                	jne    105a8a <procdump+0xca>
    }
    cprintf("\n");
  105ab6:	c7 04 24 e5 a6 11 00 	movl   $0x11a6e5,(%esp)
  105abd:	e8 4e ac ff ff       	call   100710 <cprintf>
  105ac2:	83 45 f0 01          	addl   $0x1,0xfffffff0(%ebp)
  105ac6:	83 7d f0 3f          	cmpl   $0x3f,0xfffffff0(%ebp)
  105aca:	0f 8e 02 ff ff ff    	jle    1059d2 <procdump+0x12>
  }
}
  105ad0:	c9                   	leave  
  105ad1:	c3                   	ret    
  105ad2:	90                   	nop    
  105ad3:	90                   	nop    
  105ad4:	90                   	nop    
  105ad5:	90                   	nop    
  105ad6:	90                   	nop    
  105ad7:	90                   	nop    
  105ad8:	90                   	nop    
  105ad9:	90                   	nop    
  105ada:	90                   	nop    
  105adb:	90                   	nop    
  105adc:	90                   	nop    
  105add:	90                   	nop    
  105ade:	90                   	nop    
  105adf:	90                   	nop    

00105ae0 <initlock>:
extern int use_console_lock;

void
initlock(struct spinlock *lock, char *name)
{
  105ae0:	55                   	push   %ebp
  105ae1:	89 e5                	mov    %esp,%ebp
  lock->name = name;
  105ae3:	8b 55 08             	mov    0x8(%ebp),%edx
  105ae6:	8b 45 0c             	mov    0xc(%ebp),%eax
  105ae9:	89 42 04             	mov    %eax,0x4(%edx)
  lock->locked = 0;
  105aec:	8b 45 08             	mov    0x8(%ebp),%eax
  105aef:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  lock->cpu = 0xffffffff;
  105af5:	8b 45 08             	mov    0x8(%ebp),%eax
  105af8:	c7 40 08 ff ff ff ff 	movl   $0xffffffff,0x8(%eax)
}
  105aff:	5d                   	pop    %ebp
  105b00:	c3                   	ret    
  105b01:	eb 0d                	jmp    105b10 <acquire>
  105b03:	90                   	nop    
  105b04:	90                   	nop    
  105b05:	90                   	nop    
  105b06:	90                   	nop    
  105b07:	90                   	nop    
  105b08:	90                   	nop    
  105b09:	90                   	nop    
  105b0a:	90                   	nop    
  105b0b:	90                   	nop    
  105b0c:	90                   	nop    
  105b0d:	90                   	nop    
  105b0e:	90                   	nop    
  105b0f:	90                   	nop    

00105b10 <acquire>:

int int_enabled;
// Acquire the lock.
// Loops (spins) until the lock is acquired.
// Holding a lock for a long time may cause
// other CPUs to waste time spinning to acquire it.
void
acquire(struct spinlock *lock)
{
  105b10:	55                   	push   %ebp
  105b11:	89 e5                	mov    %esp,%ebp
  105b13:	53                   	push   %ebx
  105b14:	83 ec 24             	sub    $0x24,%esp
  if(holding(lock))
  105b17:	8b 45 08             	mov    0x8(%ebp),%eax
  105b1a:	89 04 24             	mov    %eax,(%esp)
  105b1d:	e8 2e 03 00 00       	call   105e50 <holding>
  105b22:	85 c0                	test   %eax,%eax
  105b24:	74 6e                	je     105b94 <acquire+0x84>
  {
    cprintf("lock already acquired by:\n");
  105b26:	c7 04 24 e8 a6 11 00 	movl   $0x11a6e8,(%esp)
  105b2d:	e8 de ab ff ff       	call   100710 <cprintf>
    int i;
    for (i=0; i<10; i++)
  105b32:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)
  105b39:	eb 3b                	jmp    105b76 <acquire+0x66>
    {
        if ((lock->pcs[i] == 0) || (lock->pcs[i] == 0xffffffff))
  105b3b:	8b 45 08             	mov    0x8(%ebp),%eax
  105b3e:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  105b41:	8b 44 90 0c          	mov    0xc(%eax,%edx,4),%eax
  105b45:	85 c0                	test   %eax,%eax
  105b47:	74 33                	je     105b7c <acquire+0x6c>
  105b49:	8b 45 08             	mov    0x8(%ebp),%eax
  105b4c:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  105b4f:	8b 44 90 0c          	mov    0xc(%eax,%edx,4),%eax
  105b53:	83 f8 ff             	cmp    $0xffffffff,%eax
  105b56:	74 24                	je     105b7c <acquire+0x6c>
            break;
        cprintf("0x%08x ", lock->pcs[i]);
  105b58:	8b 45 08             	mov    0x8(%ebp),%eax
  105b5b:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  105b5e:	8b 44 90 0c          	mov    0xc(%eax,%edx,4),%eax
  105b62:	89 44 24 04          	mov    %eax,0x4(%esp)
  105b66:	c7 04 24 03 a7 11 00 	movl   $0x11a703,(%esp)
  105b6d:	e8 9e ab ff ff       	call   100710 <cprintf>
  105b72:	83 45 f8 01          	addl   $0x1,0xfffffff8(%ebp)
  105b76:	83 7d f8 09          	cmpl   $0x9,0xfffffff8(%ebp)
  105b7a:	7e bf                	jle    105b3b <acquire+0x2b>
    }
    cprintf("\n");
  105b7c:	c7 04 24 0b a7 11 00 	movl   $0x11a70b,(%esp)
  105b83:	e8 88 ab ff ff       	call   100710 <cprintf>
    panic("acquire");
  105b88:	c7 04 24 0d a7 11 00 	movl   $0x11a70d,(%esp)
  105b8f:	e8 6c b4 ff ff       	call   101000 <panic>
  }

//  if(cpus[cpu()].nlock == 0)
//  {
//    int_enabled = 0;
    cli();
  105b94:	e8 c7 00 00 00       	call   105c60 <cli>
//    cprintf("!D");
// }
  cpus[cpu()].nlock++;
  105b99:	e8 f2 dc ff ff       	call   103890 <cpu>
  105b9e:	89 c1                	mov    %eax,%ecx
  105ba0:	69 c1 ec 10 00 00    	imul   $0x10ec,%ecx,%eax
  105ba6:	8b 80 e0 dc 13 00    	mov    0x13dce0(%eax),%eax
  105bac:	8d 50 01             	lea    0x1(%eax),%edx
  105baf:	69 c1 ec 10 00 00    	imul   $0x10ec,%ecx,%eax
  105bb5:	89 90 e0 dc 13 00    	mov    %edx,0x13dce0(%eax)
  cpus[cpu()].locks[cpus[cpu()].nlock] = lock;
  105bbb:	e8 d0 dc ff ff       	call   103890 <cpu>
  105bc0:	89 c3                	mov    %eax,%ebx
  105bc2:	e8 c9 dc ff ff       	call   103890 <cpu>
  105bc7:	69 c0 ec 10 00 00    	imul   $0x10ec,%eax,%eax
  105bcd:	8b 90 e0 dc 13 00    	mov    0x13dce0(%eax),%edx
  105bd3:	8b 4d 08             	mov    0x8(%ebp),%ecx
  105bd6:	69 c3 3b 04 00 00    	imul   $0x43b,%ebx,%eax
  105bdc:	01 d0                	add    %edx,%eax
  105bde:	89 0c 85 e4 dc 13 00 	mov    %ecx,0x13dce4(,%eax,4)

  while(cmpxchg(0, 1, &lock->locked) == 1)
  105be5:	8b 45 08             	mov    0x8(%ebp),%eax
  105be8:	89 44 24 08          	mov    %eax,0x8(%esp)
  105bec:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  105bf3:	00 
  105bf4:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  105bfb:	e8 70 00 00 00       	call   105c70 <cmpxchg>
  105c00:	83 f8 01             	cmp    $0x1,%eax
  105c03:	74 e0                	je     105be5 <acquire+0xd5>
    ;

  // Serialize instructions: now that lock is acquired, make sure 
  // we wait for all pending writes from other processors.
  cpuid(0, 0, 0, 0, 0);  // memory barrier (see Ch 7, IA-32 manual vol 3)
  105c05:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  105c0c:	00 
  105c0d:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  105c14:	00 
  105c15:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  105c1c:	00 
  105c1d:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  105c24:	00 
  105c25:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  105c2c:	e8 7f 00 00 00       	call   105cb0 <cpuid>
  
  // Record info about lock acquisition for debugging.
  // The +10 is only so that we can tell the difference
  // between forgetting to initialize lock->cpu
  // and holding a lock on cpu 0.
  lock->cpu = cpu() + 10;
  105c31:	8b 5d 08             	mov    0x8(%ebp),%ebx
  105c34:	e8 57 dc ff ff       	call   103890 <cpu>
  105c39:	83 c0 0a             	add    $0xa,%eax
  105c3c:	89 43 08             	mov    %eax,0x8(%ebx)
  getcallerpcs(&lock, lock->pcs);
  105c3f:	8b 45 08             	mov    0x8(%ebp),%eax
  105c42:	83 c0 0c             	add    $0xc,%eax
  105c45:	89 44 24 04          	mov    %eax,0x4(%esp)
  105c49:	8d 45 08             	lea    0x8(%ebp),%eax
  105c4c:	89 04 24             	mov    %eax,(%esp)
  105c4f:	e8 8c 01 00 00       	call   105de0 <getcallerpcs>
}
  105c54:	83 c4 24             	add    $0x24,%esp
  105c57:	5b                   	pop    %ebx
  105c58:	5d                   	pop    %ebp
  105c59:	c3                   	ret    
  105c5a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

00105c60 <cli>:
}

static inline void
cli(void)
{
  105c60:	55                   	push   %ebp
  105c61:	89 e5                	mov    %esp,%ebp
  asm volatile("cli");
  105c63:	fa                   	cli    
}
  105c64:	5d                   	pop    %ebp
  105c65:	c3                   	ret    
  105c66:	8d 76 00             	lea    0x0(%esi),%esi
  105c69:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00105c70 <cmpxchg>:
  105c70:	55                   	push   %ebp
  105c71:	89 e5                	mov    %esp,%ebp
  105c73:	56                   	push   %esi
  105c74:	53                   	push   %ebx
  105c75:	83 ec 14             	sub    $0x14,%esp
  105c78:	8b 5d 10             	mov    0x10(%ebp),%ebx
  105c7b:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  105c7e:	8b 55 08             	mov    0x8(%ebp),%edx
  105c81:	8b 45 10             	mov    0x10(%ebp),%eax
  105c84:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
  105c87:	89 d0                	mov    %edx,%eax
  105c89:	8b 75 e4             	mov    0xffffffe4(%ebp),%esi
  105c8c:	f0 0f b1 0b          	lock cmpxchg %ecx,(%ebx)
  105c90:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
  105c93:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
  105c96:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  105c99:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  105c9c:	83 c4 14             	add    $0x14,%esp
  105c9f:	5b                   	pop    %ebx
  105ca0:	5e                   	pop    %esi
  105ca1:	5d                   	pop    %ebp
  105ca2:	c3                   	ret    
  105ca3:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  105ca9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00105cb0 <cpuid>:
  105cb0:	55                   	push   %ebp
  105cb1:	89 e5                	mov    %esp,%ebp
  105cb3:	53                   	push   %ebx
  105cb4:	83 ec 10             	sub    $0x10,%esp
  105cb7:	8b 45 08             	mov    0x8(%ebp),%eax
  105cba:	0f a2                	cpuid  
  105cbc:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  105cbf:	89 5d f0             	mov    %ebx,0xfffffff0(%ebp)
  105cc2:	89 4d f4             	mov    %ecx,0xfffffff4(%ebp)
  105cc5:	89 55 f8             	mov    %edx,0xfffffff8(%ebp)
  105cc8:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  105ccc:	74 08                	je     105cd6 <cpuid+0x26>
  105cce:	8b 55 0c             	mov    0xc(%ebp),%edx
  105cd1:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  105cd4:	89 02                	mov    %eax,(%edx)
  105cd6:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  105cda:	74 08                	je     105ce4 <cpuid+0x34>
  105cdc:	8b 55 10             	mov    0x10(%ebp),%edx
  105cdf:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  105ce2:	89 02                	mov    %eax,(%edx)
  105ce4:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
  105ce8:	74 08                	je     105cf2 <cpuid+0x42>
  105cea:	8b 55 14             	mov    0x14(%ebp),%edx
  105ced:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  105cf0:	89 02                	mov    %eax,(%edx)
  105cf2:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
  105cf6:	74 08                	je     105d00 <cpuid+0x50>
  105cf8:	8b 55 18             	mov    0x18(%ebp),%edx
  105cfb:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  105cfe:	89 02                	mov    %eax,(%edx)
  105d00:	83 c4 10             	add    $0x10,%esp
  105d03:	5b                   	pop    %ebx
  105d04:	5d                   	pop    %ebp
  105d05:	c3                   	ret    
  105d06:	8d 76 00             	lea    0x0(%esi),%esi
  105d09:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00105d10 <release>:

// Release the lock.
void
release(struct spinlock *lock)
{
  105d10:	55                   	push   %ebp
  105d11:	89 e5                	mov    %esp,%ebp
  105d13:	83 ec 18             	sub    $0x18,%esp
  if(!holding(lock))
  105d16:	8b 45 08             	mov    0x8(%ebp),%eax
  105d19:	89 04 24             	mov    %eax,(%esp)
  105d1c:	e8 2f 01 00 00       	call   105e50 <holding>
  105d21:	85 c0                	test   %eax,%eax
  105d23:	75 0c                	jne    105d31 <release+0x21>
    panic("release");
  105d25:	c7 04 24 15 a7 11 00 	movl   $0x11a715,(%esp)
  105d2c:	e8 cf b2 ff ff       	call   101000 <panic>

  lock->pcs[0] = 0;
  105d31:	8b 45 08             	mov    0x8(%ebp),%eax
  105d34:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
  lock->cpu = 0xffffffff;
  105d3b:	8b 45 08             	mov    0x8(%ebp),%eax
  105d3e:	c7 40 08 ff ff ff ff 	movl   $0xffffffff,0x8(%eax)
  
  // Serialize instructions: before unlocking the lock, make sure
  // to flush any pending memory writes from this processor.
  cpuid(0, 0, 0, 0, 0);  // memory barrier (see Ch 7, IA-32 manual vol 3)
  105d45:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  105d4c:	00 
  105d4d:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  105d54:	00 
  105d55:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  105d5c:	00 
  105d5d:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  105d64:	00 
  105d65:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  105d6c:	e8 3f ff ff ff       	call   105cb0 <cpuid>

  if (int_enabled)
  105d71:	a1 74 0c 14 00       	mov    0x140c74,%eax
  105d76:	85 c0                	test   %eax,%eax
  105d78:	74 0c                	je     105d86 <release+0x76>
      panic("release when interrupts enabled");
  105d7a:	c7 04 24 20 a7 11 00 	movl   $0x11a720,(%esp)
  105d81:	e8 7a b2 ff ff       	call   101000 <panic>
  lock->locked = 0;
  105d86:	8b 45 08             	mov    0x8(%ebp),%eax
  105d89:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  if(--cpus[cpu()].nlock == 0)
  105d8f:	e8 fc da ff ff       	call   103890 <cpu>
  105d94:	89 c2                	mov    %eax,%edx
  105d96:	69 c2 ec 10 00 00    	imul   $0x10ec,%edx,%eax
  105d9c:	8b 80 e0 dc 13 00    	mov    0x13dce0(%eax),%eax
  105da2:	8d 48 ff             	lea    0xffffffff(%eax),%ecx
  105da5:	69 c2 ec 10 00 00    	imul   $0x10ec,%edx,%eax
  105dab:	89 88 e0 dc 13 00    	mov    %ecx,0x13dce0(%eax)
  105db1:	69 c2 ec 10 00 00    	imul   $0x10ec,%edx,%eax
  105db7:	8b 80 e0 dc 13 00    	mov    0x13dce0(%eax),%eax
  105dbd:	85 c0                	test   %eax,%eax
  105dbf:	75 05                	jne    105dc6 <release+0xb6>
  {
//      int_enabled = 1;
    sti();
  105dc1:	e8 0a 00 00 00       	call   105dd0 <sti>
 //   cprintf("!E");
  }
}
  105dc6:	c9                   	leave  
  105dc7:	c3                   	ret    
  105dc8:	90                   	nop    
  105dc9:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

00105dd0 <sti>:
}

static inline void
sti(void)
{
  105dd0:	55                   	push   %ebp
  105dd1:	89 e5                	mov    %esp,%ebp
  asm volatile("sti");
  105dd3:	fb                   	sti    
}
  105dd4:	5d                   	pop    %ebp
  105dd5:	c3                   	ret    
  105dd6:	8d 76 00             	lea    0x0(%esi),%esi
  105dd9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00105de0 <getcallerpcs>:

// Record the current call stack in pcs[] by following the %ebp chain.
void
getcallerpcs(void *v, uint pcs[])
{
  105de0:	55                   	push   %ebp
  105de1:	89 e5                	mov    %esp,%ebp
  105de3:	83 ec 10             	sub    $0x10,%esp
  uint *ebp;
  int i;
  
  ebp = (uint*)v - 2;
  105de6:	8b 45 08             	mov    0x8(%ebp),%eax
  105de9:	83 e8 08             	sub    $0x8,%eax
  105dec:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  for(i = 0; i < 10; i++){
  105def:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
  105df6:	eb 2d                	jmp    105e25 <getcallerpcs+0x45>
    if(ebp == 0 || ebp == (uint*)0xffffffff)
  105df8:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  105dfc:	74 42                	je     105e40 <getcallerpcs+0x60>
  105dfe:	83 7d f8 ff          	cmpl   $0xffffffff,0xfffffff8(%ebp)
  105e02:	74 3c                	je     105e40 <getcallerpcs+0x60>
      break;
    pcs[i] = ebp[1];     // saved %eip
  105e04:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  105e07:	c1 e0 02             	shl    $0x2,%eax
  105e0a:	89 c2                	mov    %eax,%edx
  105e0c:	03 55 0c             	add    0xc(%ebp),%edx
  105e0f:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  105e12:	83 c0 04             	add    $0x4,%eax
  105e15:	8b 00                	mov    (%eax),%eax
  105e17:	89 02                	mov    %eax,(%edx)
    ebp = (uint*)ebp[0]; // saved %ebp
  105e19:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  105e1c:	8b 00                	mov    (%eax),%eax
  105e1e:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  105e21:	83 45 fc 01          	addl   $0x1,0xfffffffc(%ebp)
  105e25:	83 7d fc 09          	cmpl   $0x9,0xfffffffc(%ebp)
  105e29:	7e cd                	jle    105df8 <getcallerpcs+0x18>
  }
  for(; i < 10; i++)
  105e2b:	eb 13                	jmp    105e40 <getcallerpcs+0x60>
    pcs[i] = 0;
  105e2d:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  105e30:	c1 e0 02             	shl    $0x2,%eax
  105e33:	03 45 0c             	add    0xc(%ebp),%eax
  105e36:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  105e3c:	83 45 fc 01          	addl   $0x1,0xfffffffc(%ebp)
  105e40:	83 7d fc 09          	cmpl   $0x9,0xfffffffc(%ebp)
  105e44:	7e e7                	jle    105e2d <getcallerpcs+0x4d>
}
  105e46:	c9                   	leave  
  105e47:	c3                   	ret    
  105e48:	90                   	nop    
  105e49:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

00105e50 <holding>:

// Check whether this cpu is holding the lock.
int
holding(struct spinlock *lock)
{
  105e50:	55                   	push   %ebp
  105e51:	89 e5                	mov    %esp,%ebp
  105e53:	53                   	push   %ebx
  105e54:	83 ec 04             	sub    $0x4,%esp
  return lock->locked && lock->cpu == cpu() + 10;
  105e57:	8b 45 08             	mov    0x8(%ebp),%eax
  105e5a:	8b 00                	mov    (%eax),%eax
  105e5c:	85 c0                	test   %eax,%eax
  105e5e:	74 1b                	je     105e7b <holding+0x2b>
  105e60:	8b 45 08             	mov    0x8(%ebp),%eax
  105e63:	8b 58 08             	mov    0x8(%eax),%ebx
  105e66:	e8 25 da ff ff       	call   103890 <cpu>
  105e6b:	83 c0 0a             	add    $0xa,%eax
  105e6e:	39 c3                	cmp    %eax,%ebx
  105e70:	75 09                	jne    105e7b <holding+0x2b>
  105e72:	c7 45 f8 01 00 00 00 	movl   $0x1,0xfffffff8(%ebp)
  105e79:	eb 07                	jmp    105e82 <holding+0x32>
  105e7b:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)
  105e82:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
}
  105e85:	83 c4 04             	add    $0x4,%esp
  105e88:	5b                   	pop    %ebx
  105e89:	5d                   	pop    %ebp
  105e8a:	c3                   	ret    
  105e8b:	90                   	nop    
  105e8c:	90                   	nop    
  105e8d:	90                   	nop    
  105e8e:	90                   	nop    
  105e8f:	90                   	nop    

00105e90 <memcpy>:
#include "types.h"

void*
memcpy(void *dst, const void *src, uint n)
{
  105e90:	55                   	push   %ebp
  105e91:	89 e5                	mov    %esp,%ebp
  105e93:	83 ec 10             	sub    $0x10,%esp
    const uchar *s1;
    uchar *s2;
    
    s1 = src;
  105e96:	8b 45 0c             	mov    0xc(%ebp),%eax
  105e99:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
    s2 = dst;
  105e9c:	8b 45 08             	mov    0x8(%ebp),%eax
  105e9f:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
    while(n-- > 0){
  105ea2:	eb 13                	jmp    105eb7 <memcpy+0x27>
        *s2 = *s1;
  105ea4:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  105ea7:	0f b6 10             	movzbl (%eax),%edx
  105eaa:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  105ead:	88 10                	mov    %dl,(%eax)
        s1++;
  105eaf:	83 45 f8 01          	addl   $0x1,0xfffffff8(%ebp)
        s2++;
  105eb3:	83 45 fc 01          	addl   $0x1,0xfffffffc(%ebp)
  105eb7:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
  105ebb:	83 7d 10 ff          	cmpl   $0xffffffff,0x10(%ebp)
  105ebf:	75 e3                	jne    105ea4 <memcpy+0x14>
    }

    return 0;
  105ec1:	b8 00 00 00 00       	mov    $0x0,%eax
}
  105ec6:	c9                   	leave  
  105ec7:	c3                   	ret    
  105ec8:	90                   	nop    
  105ec9:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

00105ed0 <memset>:

void*
memset(void *dst, int c, uint n)
{
  105ed0:	55                   	push   %ebp
  105ed1:	89 e5                	mov    %esp,%ebp
  105ed3:	83 ec 10             	sub    $0x10,%esp
  char *d;

  d = (char*)dst;
  105ed6:	8b 45 08             	mov    0x8(%ebp),%eax
  105ed9:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  while(n-- > 0)
  105edc:	eb 0e                	jmp    105eec <memset+0x1c>
    *d++ = c;
  105ede:	8b 45 0c             	mov    0xc(%ebp),%eax
  105ee1:	89 c2                	mov    %eax,%edx
  105ee3:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  105ee6:	88 10                	mov    %dl,(%eax)
  105ee8:	83 45 fc 01          	addl   $0x1,0xfffffffc(%ebp)
  105eec:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
  105ef0:	83 7d 10 ff          	cmpl   $0xffffffff,0x10(%ebp)
  105ef4:	75 e8                	jne    105ede <memset+0xe>

  return dst;
  105ef6:	8b 45 08             	mov    0x8(%ebp),%eax
}
  105ef9:	c9                   	leave  
  105efa:	c3                   	ret    
  105efb:	90                   	nop    
  105efc:	8d 74 26 00          	lea    0x0(%esi),%esi

00105f00 <memcmp>:

int
memcmp(const void *v1, const void *v2, uint n)
{
  105f00:	55                   	push   %ebp
  105f01:	89 e5                	mov    %esp,%ebp
  105f03:	83 ec 14             	sub    $0x14,%esp
  const uchar *s1, *s2;
  
  s1 = v1;
  105f06:	8b 45 08             	mov    0x8(%ebp),%eax
  105f09:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  s2 = v2;
  105f0c:	8b 45 0c             	mov    0xc(%ebp),%eax
  105f0f:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  while(n-- > 0){
  105f12:	eb 33                	jmp    105f47 <memcmp+0x47>
    if(*s1 != *s2)
  105f14:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  105f17:	0f b6 10             	movzbl (%eax),%edx
  105f1a:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  105f1d:	0f b6 00             	movzbl (%eax),%eax
  105f20:	38 c2                	cmp    %al,%dl
  105f22:	74 1b                	je     105f3f <memcmp+0x3f>
      return *s1 - *s2;
  105f24:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  105f27:	0f b6 00             	movzbl (%eax),%eax
  105f2a:	0f b6 d0             	movzbl %al,%edx
  105f2d:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  105f30:	0f b6 00             	movzbl (%eax),%eax
  105f33:	0f b6 c0             	movzbl %al,%eax
  105f36:	89 d1                	mov    %edx,%ecx
  105f38:	29 c1                	sub    %eax,%ecx
  105f3a:	89 4d ec             	mov    %ecx,0xffffffec(%ebp)
  105f3d:	eb 19                	jmp    105f58 <memcmp+0x58>
    s1++, s2++;
  105f3f:	83 45 f8 01          	addl   $0x1,0xfffffff8(%ebp)
  105f43:	83 45 fc 01          	addl   $0x1,0xfffffffc(%ebp)
  105f47:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
  105f4b:	83 7d 10 ff          	cmpl   $0xffffffff,0x10(%ebp)
  105f4f:	75 c3                	jne    105f14 <memcmp+0x14>
  }

  return 0;
  105f51:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  105f58:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  105f5b:	c9                   	leave  
  105f5c:	c3                   	ret    
  105f5d:	8d 76 00             	lea    0x0(%esi),%esi

00105f60 <memmove>:

void*
memmove(void *dst, const void *src, uint n)
{
  105f60:	55                   	push   %ebp
  105f61:	89 e5                	mov    %esp,%ebp
  105f63:	83 ec 10             	sub    $0x10,%esp
  const char *s;
  char *d;

  s = src;
  105f66:	8b 45 0c             	mov    0xc(%ebp),%eax
  105f69:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  d = dst;
  105f6c:	8b 45 08             	mov    0x8(%ebp),%eax
  105f6f:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  if(s < d && s + n > d){
  105f72:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  105f75:	3b 45 fc             	cmp    0xfffffffc(%ebp),%eax
  105f78:	73 4b                	jae    105fc5 <memmove+0x65>
  105f7a:	8b 45 10             	mov    0x10(%ebp),%eax
  105f7d:	03 45 f8             	add    0xfffffff8(%ebp),%eax
  105f80:	3b 45 fc             	cmp    0xfffffffc(%ebp),%eax
  105f83:	76 40                	jbe    105fc5 <memmove+0x65>
    s += n;
  105f85:	8b 45 10             	mov    0x10(%ebp),%eax
  105f88:	01 45 f8             	add    %eax,0xfffffff8(%ebp)
    d += n;
  105f8b:	8b 45 10             	mov    0x10(%ebp),%eax
  105f8e:	01 45 fc             	add    %eax,0xfffffffc(%ebp)
    while(n-- > 0)
  105f91:	eb 13                	jmp    105fa6 <memmove+0x46>
      *--d = *--s;
  105f93:	83 6d fc 01          	subl   $0x1,0xfffffffc(%ebp)
  105f97:	83 6d f8 01          	subl   $0x1,0xfffffff8(%ebp)
  105f9b:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  105f9e:	0f b6 10             	movzbl (%eax),%edx
  105fa1:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  105fa4:	88 10                	mov    %dl,(%eax)
  105fa6:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
  105faa:	83 7d 10 ff          	cmpl   $0xffffffff,0x10(%ebp)
  105fae:	75 e3                	jne    105f93 <memmove+0x33>
  105fb0:	eb 1d                	jmp    105fcf <memmove+0x6f>
  } else
    while(n-- > 0)
      *d++ = *s++;
  105fb2:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  105fb5:	0f b6 10             	movzbl (%eax),%edx
  105fb8:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  105fbb:	88 10                	mov    %dl,(%eax)
  105fbd:	83 45 fc 01          	addl   $0x1,0xfffffffc(%ebp)
  105fc1:	83 45 f8 01          	addl   $0x1,0xfffffff8(%ebp)
  105fc5:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
  105fc9:	83 7d 10 ff          	cmpl   $0xffffffff,0x10(%ebp)
  105fcd:	75 e3                	jne    105fb2 <memmove+0x52>

  return dst;
  105fcf:	8b 45 08             	mov    0x8(%ebp),%eax
}
  105fd2:	c9                   	leave  
  105fd3:	c3                   	ret    
  105fd4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  105fda:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

00105fe0 <strncmp>:

int
strncmp(const char *p, const char *q, uint n)
{
  105fe0:	55                   	push   %ebp
  105fe1:	89 e5                	mov    %esp,%ebp
  105fe3:	83 ec 04             	sub    $0x4,%esp
  while(n > 0 && *p && *p == *q)
  105fe6:	eb 0c                	jmp    105ff4 <strncmp+0x14>
    n--, p++, q++;
  105fe8:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
  105fec:	83 45 08 01          	addl   $0x1,0x8(%ebp)
  105ff0:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
  105ff4:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  105ff8:	74 1a                	je     106014 <strncmp+0x34>
  105ffa:	8b 45 08             	mov    0x8(%ebp),%eax
  105ffd:	0f b6 00             	movzbl (%eax),%eax
  106000:	84 c0                	test   %al,%al
  106002:	74 10                	je     106014 <strncmp+0x34>
  106004:	8b 45 08             	mov    0x8(%ebp),%eax
  106007:	0f b6 10             	movzbl (%eax),%edx
  10600a:	8b 45 0c             	mov    0xc(%ebp),%eax
  10600d:	0f b6 00             	movzbl (%eax),%eax
  106010:	38 c2                	cmp    %al,%dl
  106012:	74 d4                	je     105fe8 <strncmp+0x8>
  if(n == 0)
  106014:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  106018:	75 09                	jne    106023 <strncmp+0x43>
    return 0;
  10601a:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
  106021:	eb 19                	jmp    10603c <strncmp+0x5c>
  return (uchar)*p - (uchar)*q;
  106023:	8b 45 08             	mov    0x8(%ebp),%eax
  106026:	0f b6 00             	movzbl (%eax),%eax
  106029:	0f b6 d0             	movzbl %al,%edx
  10602c:	8b 45 0c             	mov    0xc(%ebp),%eax
  10602f:	0f b6 00             	movzbl (%eax),%eax
  106032:	0f b6 c0             	movzbl %al,%eax
  106035:	89 d1                	mov    %edx,%ecx
  106037:	29 c1                	sub    %eax,%ecx
  106039:	89 4d fc             	mov    %ecx,0xfffffffc(%ebp)
  10603c:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
}
  10603f:	c9                   	leave  
  106040:	c3                   	ret    
  106041:	eb 0d                	jmp    106050 <strncpy>
  106043:	90                   	nop    
  106044:	90                   	nop    
  106045:	90                   	nop    
  106046:	90                   	nop    
  106047:	90                   	nop    
  106048:	90                   	nop    
  106049:	90                   	nop    
  10604a:	90                   	nop    
  10604b:	90                   	nop    
  10604c:	90                   	nop    
  10604d:	90                   	nop    
  10604e:	90                   	nop    
  10604f:	90                   	nop    

00106050 <strncpy>:

char*
strncpy(char *s, const char *t, int n)
{
  106050:	55                   	push   %ebp
  106051:	89 e5                	mov    %esp,%ebp
  106053:	83 ec 10             	sub    $0x10,%esp
  char *os;
  
  os = s;
  106056:	8b 45 08             	mov    0x8(%ebp),%eax
  106059:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  while(n-- > 0 && (*s++ = *t++) != 0)
  10605c:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  106060:	0f 9f c0             	setg   %al
  106063:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
  106067:	83 f0 01             	xor    $0x1,%eax
  10606a:	84 c0                	test   %al,%al
  10606c:	75 2e                	jne    10609c <strncpy+0x4c>
  10606e:	8b 45 0c             	mov    0xc(%ebp),%eax
  106071:	0f b6 10             	movzbl (%eax),%edx
  106074:	8b 45 08             	mov    0x8(%ebp),%eax
  106077:	88 10                	mov    %dl,(%eax)
  106079:	8b 45 08             	mov    0x8(%ebp),%eax
  10607c:	0f b6 00             	movzbl (%eax),%eax
  10607f:	84 c0                	test   %al,%al
  106081:	0f 95 c0             	setne  %al
  106084:	83 45 08 01          	addl   $0x1,0x8(%ebp)
  106088:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
  10608c:	84 c0                	test   %al,%al
  10608e:	75 cc                	jne    10605c <strncpy+0xc>
    ;
  while(n-- > 0)
  106090:	eb 0a                	jmp    10609c <strncpy+0x4c>
    *s++ = 0;
  106092:	8b 45 08             	mov    0x8(%ebp),%eax
  106095:	c6 00 00             	movb   $0x0,(%eax)
  106098:	83 45 08 01          	addl   $0x1,0x8(%ebp)
  10609c:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  1060a0:	0f 9f c0             	setg   %al
  1060a3:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
  1060a7:	84 c0                	test   %al,%al
  1060a9:	75 e7                	jne    106092 <strncpy+0x42>
  return os;
  1060ab:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
}
  1060ae:	c9                   	leave  
  1060af:	c3                   	ret    

001060b0 <safestrcpy>:

// Like strncpy but guaranteed to NUL-terminate.
char*
safestrcpy(char *s, const char *t, int n)
{
  1060b0:	55                   	push   %ebp
  1060b1:	89 e5                	mov    %esp,%ebp
  1060b3:	83 ec 14             	sub    $0x14,%esp
  char *os;
  
  os = s;
  1060b6:	8b 45 08             	mov    0x8(%ebp),%eax
  1060b9:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  if(n <= 0)
  1060bc:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  1060c0:	7f 08                	jg     1060ca <safestrcpy+0x1a>
    return os;
  1060c2:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1060c5:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  1060c8:	eb 38                	jmp    106102 <safestrcpy+0x52>
  while(--n > 0 && (*s++ = *t++) != 0)
  1060ca:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
  1060ce:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  1060d2:	7e 22                	jle    1060f6 <safestrcpy+0x46>
  1060d4:	8b 45 0c             	mov    0xc(%ebp),%eax
  1060d7:	0f b6 10             	movzbl (%eax),%edx
  1060da:	8b 45 08             	mov    0x8(%ebp),%eax
  1060dd:	88 10                	mov    %dl,(%eax)
  1060df:	8b 45 08             	mov    0x8(%ebp),%eax
  1060e2:	0f b6 00             	movzbl (%eax),%eax
  1060e5:	84 c0                	test   %al,%al
  1060e7:	0f 95 c0             	setne  %al
  1060ea:	83 45 08 01          	addl   $0x1,0x8(%ebp)
  1060ee:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
  1060f2:	84 c0                	test   %al,%al
  1060f4:	75 d4                	jne    1060ca <safestrcpy+0x1a>
    ;
  *s = 0;
  1060f6:	8b 45 08             	mov    0x8(%ebp),%eax
  1060f9:	c6 00 00             	movb   $0x0,(%eax)
  return os;
  1060fc:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1060ff:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  106102:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  106105:	c9                   	leave  
  106106:	c3                   	ret    
  106107:	89 f6                	mov    %esi,%esi
  106109:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00106110 <strlen>:

int
strlen(const char *s)
{
  106110:	55                   	push   %ebp
  106111:	89 e5                	mov    %esp,%ebp
  106113:	83 ec 10             	sub    $0x10,%esp
  int n;

  for(n = 0; s[n]; n++)
  106116:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
  10611d:	eb 04                	jmp    106123 <strlen+0x13>
  10611f:	83 45 fc 01          	addl   $0x1,0xfffffffc(%ebp)
  106123:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  106126:	03 45 08             	add    0x8(%ebp),%eax
  106129:	0f b6 00             	movzbl (%eax),%eax
  10612c:	84 c0                	test   %al,%al
  10612e:	75 ef                	jne    10611f <strlen+0xf>
    ;
  return n;
  106130:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
}
  106133:	c9                   	leave  
  106134:	c3                   	ret    
  106135:	90                   	nop    
  106136:	90                   	nop    
  106137:	90                   	nop    

00106138 <swtch>:
  106138:	8b 44 24 04          	mov    0x4(%esp),%eax
  10613c:	8f 40 00             	popl   0x0(%eax)
  10613f:	89 60 04             	mov    %esp,0x4(%eax)
  106142:	89 58 08             	mov    %ebx,0x8(%eax)
  106145:	89 48 0c             	mov    %ecx,0xc(%eax)
  106148:	89 50 10             	mov    %edx,0x10(%eax)
  10614b:	89 70 14             	mov    %esi,0x14(%eax)
  10614e:	89 78 18             	mov    %edi,0x18(%eax)
  106151:	89 68 1c             	mov    %ebp,0x1c(%eax)
  106154:	8b 44 24 04          	mov    0x4(%esp),%eax
  106158:	8b 68 1c             	mov    0x1c(%eax),%ebp
  10615b:	8b 78 18             	mov    0x18(%eax),%edi
  10615e:	8b 70 14             	mov    0x14(%eax),%esi
  106161:	8b 50 10             	mov    0x10(%eax),%edx
  106164:	8b 48 0c             	mov    0xc(%eax),%ecx
  106167:	8b 58 08             	mov    0x8(%eax),%ebx
  10616a:	8b 60 04             	mov    0x4(%eax),%esp
  10616d:	ff 70 00             	pushl  0x0(%eax)
  106170:	c3                   	ret    
  106171:	90                   	nop    
  106172:	90                   	nop    
  106173:	90                   	nop    
  106174:	90                   	nop    
  106175:	90                   	nop    
  106176:	90                   	nop    
  106177:	90                   	nop    
  106178:	90                   	nop    
  106179:	90                   	nop    
  10617a:	90                   	nop    
  10617b:	90                   	nop    
  10617c:	90                   	nop    
  10617d:	90                   	nop    
  10617e:	90                   	nop    
  10617f:	90                   	nop    

00106180 <fetchint>:

// Fetch the int at addr from process p.
int
fetchint(struct proc *p, uint addr, int *ip)
{
  106180:	55                   	push   %ebp
  106181:	89 e5                	mov    %esp,%ebp
  106183:	83 ec 04             	sub    $0x4,%esp
  if(addr >= p->sz || addr+4 > p->sz)
  106186:	8b 45 08             	mov    0x8(%ebp),%eax
  106189:	8b 40 04             	mov    0x4(%eax),%eax
  10618c:	3b 45 0c             	cmp    0xc(%ebp),%eax
  10618f:	76 10                	jbe    1061a1 <fetchint+0x21>
  106191:	8b 45 0c             	mov    0xc(%ebp),%eax
  106194:	83 c0 04             	add    $0x4,%eax
  106197:	8b 55 08             	mov    0x8(%ebp),%edx
  10619a:	8b 52 04             	mov    0x4(%edx),%edx
  10619d:	39 d0                	cmp    %edx,%eax
  10619f:	76 09                	jbe    1061aa <fetchint+0x2a>
    return -1;
  1061a1:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,0xfffffffc(%ebp)
  1061a8:	eb 19                	jmp    1061c3 <fetchint+0x43>
  *ip = *(int*)(p->mem + addr);
  1061aa:	8b 45 08             	mov    0x8(%ebp),%eax
  1061ad:	8b 10                	mov    (%eax),%edx
  1061af:	8b 45 0c             	mov    0xc(%ebp),%eax
  1061b2:	8d 04 02             	lea    (%edx,%eax,1),%eax
  1061b5:	8b 10                	mov    (%eax),%edx
  1061b7:	8b 45 10             	mov    0x10(%ebp),%eax
  1061ba:	89 10                	mov    %edx,(%eax)
  return 0;
  1061bc:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
  1061c3:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
}
  1061c6:	c9                   	leave  
  1061c7:	c3                   	ret    
  1061c8:	90                   	nop    
  1061c9:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

001061d0 <fetchstr>:

// Fetch the nul-terminated string at addr from process p.
// Doesn't actually copy the string - just sets *pp to point at it.
// Returns length of string, not including nul.
int
fetchstr(struct proc *p, uint addr, char **pp)
{
  1061d0:	55                   	push   %ebp
  1061d1:	89 e5                	mov    %esp,%ebp
  1061d3:	83 ec 14             	sub    $0x14,%esp
  char *s, *ep;

  if(addr >= p->sz)
  1061d6:	8b 45 08             	mov    0x8(%ebp),%eax
  1061d9:	8b 40 04             	mov    0x4(%eax),%eax
  1061dc:	3b 45 0c             	cmp    0xc(%ebp),%eax
  1061df:	77 09                	ja     1061ea <fetchstr+0x1a>
    return -1;
  1061e1:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  1061e8:	eb 58                	jmp    106242 <fetchstr+0x72>
  *pp = p->mem + addr;
  1061ea:	8b 45 08             	mov    0x8(%ebp),%eax
  1061ed:	8b 10                	mov    (%eax),%edx
  1061ef:	8b 45 0c             	mov    0xc(%ebp),%eax
  1061f2:	01 c2                	add    %eax,%edx
  1061f4:	8b 45 10             	mov    0x10(%ebp),%eax
  1061f7:	89 10                	mov    %edx,(%eax)
  ep = p->mem + p->sz;
  1061f9:	8b 45 08             	mov    0x8(%ebp),%eax
  1061fc:	8b 10                	mov    (%eax),%edx
  1061fe:	8b 45 08             	mov    0x8(%ebp),%eax
  106201:	8b 40 04             	mov    0x4(%eax),%eax
  106204:	8d 04 02             	lea    (%edx,%eax,1),%eax
  106207:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  for(s = *pp; s < ep; s++)
  10620a:	8b 45 10             	mov    0x10(%ebp),%eax
  10620d:	8b 00                	mov    (%eax),%eax
  10620f:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  106212:	eb 1f                	jmp    106233 <fetchstr+0x63>
    if(*s == 0)
  106214:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  106217:	0f b6 00             	movzbl (%eax),%eax
  10621a:	84 c0                	test   %al,%al
  10621c:	75 11                	jne    10622f <fetchstr+0x5f>
      return s - *pp;
  10621e:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  106221:	8b 45 10             	mov    0x10(%ebp),%eax
  106224:	8b 00                	mov    (%eax),%eax
  106226:	89 d1                	mov    %edx,%ecx
  106228:	29 c1                	sub    %eax,%ecx
  10622a:	89 4d ec             	mov    %ecx,0xffffffec(%ebp)
  10622d:	eb 13                	jmp    106242 <fetchstr+0x72>
  10622f:	83 45 f8 01          	addl   $0x1,0xfffffff8(%ebp)
  106233:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  106236:	3b 45 fc             	cmp    0xfffffffc(%ebp),%eax
  106239:	72 d9                	jb     106214 <fetchstr+0x44>
  return -1;
  10623b:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  106242:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  106245:	c9                   	leave  
  106246:	c3                   	ret    
  106247:	89 f6                	mov    %esi,%esi
  106249:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00106250 <argint>:

// Fetch the nth 32-bit system call argument.
int
argint(int n, int *ip)
{
  106250:	55                   	push   %ebp
  106251:	89 e5                	mov    %esp,%ebp
  106253:	53                   	push   %ebx
  106254:	83 ec 14             	sub    $0x14,%esp
  return fetchint(cp, cp->tf->esp + 4 + 4*n, ip);
  106257:	e8 34 d6 ff ff       	call   103890 <cpu>
  10625c:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  106263:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
  106269:	8b 50 3c             	mov    0x3c(%eax),%edx
  10626c:	8b 45 08             	mov    0x8(%ebp),%eax
  10626f:	c1 e0 02             	shl    $0x2,%eax
  106272:	8d 04 02             	lea    (%edx,%eax,1),%eax
  106275:	8d 58 04             	lea    0x4(%eax),%ebx
  106278:	e8 13 d6 ff ff       	call   103890 <cpu>
  10627d:	8b 14 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%edx
  106284:	8b 45 0c             	mov    0xc(%ebp),%eax
  106287:	89 44 24 08          	mov    %eax,0x8(%esp)
  10628b:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  10628f:	89 14 24             	mov    %edx,(%esp)
  106292:	e8 e9 fe ff ff       	call   106180 <fetchint>
}
  106297:	83 c4 14             	add    $0x14,%esp
  10629a:	5b                   	pop    %ebx
  10629b:	5d                   	pop    %ebp
  10629c:	c3                   	ret    
  10629d:	8d 76 00             	lea    0x0(%esi),%esi

001062a0 <argptr>:

// Fetch the nth word-sized system call argument as a pointer
// to a block of memory of size n bytes.  Check that the pointer
// lies within the process address space.
int
argptr(int n, char **pp, int size)
{
  1062a0:	55                   	push   %ebp
  1062a1:	89 e5                	mov    %esp,%ebp
  1062a3:	53                   	push   %ebx
  1062a4:	83 ec 24             	sub    $0x24,%esp
  int i;
  
  if(argint(n, &i) < 0)
  1062a7:	8d 45 f8             	lea    0xfffffff8(%ebp),%eax
  1062aa:	89 44 24 04          	mov    %eax,0x4(%esp)
  1062ae:	8b 45 08             	mov    0x8(%ebp),%eax
  1062b1:	89 04 24             	mov    %eax,(%esp)
  1062b4:	e8 97 ff ff ff       	call   106250 <argint>
  1062b9:	85 c0                	test   %eax,%eax
  1062bb:	79 09                	jns    1062c6 <argptr+0x26>
    return -1;
  1062bd:	c7 45 e8 ff ff ff ff 	movl   $0xffffffff,0xffffffe8(%ebp)
  1062c4:	eb 5e                	jmp    106324 <argptr+0x84>
  if((uint)i >= cp->sz || (uint)i+size >= cp->sz)
  1062c6:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1062c9:	89 c3                	mov    %eax,%ebx
  1062cb:	e8 c0 d5 ff ff       	call   103890 <cpu>
  1062d0:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  1062d7:	8b 40 04             	mov    0x4(%eax),%eax
  1062da:	39 c3                	cmp    %eax,%ebx
  1062dc:	73 1e                	jae    1062fc <argptr+0x5c>
  1062de:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1062e1:	89 c2                	mov    %eax,%edx
  1062e3:	8b 45 10             	mov    0x10(%ebp),%eax
  1062e6:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
  1062e9:	e8 a2 d5 ff ff       	call   103890 <cpu>
  1062ee:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  1062f5:	8b 40 04             	mov    0x4(%eax),%eax
  1062f8:	39 c3                	cmp    %eax,%ebx
  1062fa:	72 09                	jb     106305 <argptr+0x65>
    return -1;
  1062fc:	c7 45 e8 ff ff ff ff 	movl   $0xffffffff,0xffffffe8(%ebp)
  106303:	eb 1f                	jmp    106324 <argptr+0x84>
  *pp = cp->mem + i;
  106305:	e8 86 d5 ff ff       	call   103890 <cpu>
  10630a:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  106311:	8b 10                	mov    (%eax),%edx
  106313:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  106316:	01 c2                	add    %eax,%edx
  106318:	8b 45 0c             	mov    0xc(%ebp),%eax
  10631b:	89 10                	mov    %edx,(%eax)
  return 0;
  10631d:	c7 45 e8 00 00 00 00 	movl   $0x0,0xffffffe8(%ebp)
  106324:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
}
  106327:	83 c4 24             	add    $0x24,%esp
  10632a:	5b                   	pop    %ebx
  10632b:	5d                   	pop    %ebp
  10632c:	c3                   	ret    
  10632d:	8d 76 00             	lea    0x0(%esi),%esi

00106330 <argstr>:

// Fetch the nth word-sized system call argument as a string pointer.
// Check that the pointer is valid and the string is nul-terminated.
// (There is no shared writable memory, so the string can't change
// between this check and being used by the kernel.)
int
argstr(int n, char **pp)
{
  106330:	55                   	push   %ebp
  106331:	89 e5                	mov    %esp,%ebp
  106333:	53                   	push   %ebx
  106334:	83 ec 24             	sub    $0x24,%esp
  int addr;
  if(argint(n, &addr) < 0)
  106337:	8d 45 f8             	lea    0xfffffff8(%ebp),%eax
  10633a:	89 44 24 04          	mov    %eax,0x4(%esp)
  10633e:	8b 45 08             	mov    0x8(%ebp),%eax
  106341:	89 04 24             	mov    %eax,(%esp)
  106344:	e8 07 ff ff ff       	call   106250 <argint>
  106349:	85 c0                	test   %eax,%eax
  10634b:	79 09                	jns    106356 <argstr+0x26>
    return -1;
  10634d:	c7 45 e8 ff ff ff ff 	movl   $0xffffffff,0xffffffe8(%ebp)
  106354:	eb 27                	jmp    10637d <argstr+0x4d>
  return fetchstr(cp, addr, pp);
  106356:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  106359:	89 c3                	mov    %eax,%ebx
  10635b:	e8 30 d5 ff ff       	call   103890 <cpu>
  106360:	8b 14 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%edx
  106367:	8b 45 0c             	mov    0xc(%ebp),%eax
  10636a:	89 44 24 08          	mov    %eax,0x8(%esp)
  10636e:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  106372:	89 14 24             	mov    %edx,(%esp)
  106375:	e8 56 fe ff ff       	call   1061d0 <fetchstr>
  10637a:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
  10637d:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
}
  106380:	83 c4 24             	add    $0x24,%esp
  106383:	5b                   	pop    %ebx
  106384:	5d                   	pop    %ebp
  106385:	c3                   	ret    
  106386:	8d 76 00             	lea    0x0(%esi),%esi
  106389:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00106390 <syscall>:

extern int sys_chdir(void);
extern int sys_close(void);
extern int sys_dup(void);
extern int sys_exec(void);
extern int sys_exit(void);
extern int sys_fork(void);
extern int sys_fstat(void);
extern int sys_getpid(void);
extern int sys_kill(void);
extern int sys_link(void);
extern int sys_mkdir(void);
extern int sys_mknod(void);
extern int sys_open(void);
extern int sys_pipe(void);
extern int sys_read(void);
extern int sys_sbrk(void);
extern int sys_sleep(void);
extern int sys_unlink(void);
extern int sys_wait(void);
extern int sys_write(void);
extern int sys_upmsec(void);
// BSD sockets
extern int sys_accept(void);
extern int sys_bind(void);
extern int sys_shutdown(void);
extern int sys_getsockopt(void);
extern int sys_setsockopt(void);
extern int sys_sockclose(void);
extern int sys_connect(void);
extern int sys_listen(void);
extern int sys_recv(void);
extern int sys_recvfrom(void);
extern int sys_send(void);
extern int sys_sendto(void);
extern int sys_socket(void);
extern int sys_getpeername (void);
extern int sys_getsockname (void);
//int lwip_read(int s, void *mem, int len);
//int lwip_write(int s, void *dataptr, int size);
//int lwip_select(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset,
//                struct timeval *timeout);
//extern int sys_sockioctl(void);

static int (*syscalls[])(void) = {
[SYS_chdir]   sys_chdir,
[SYS_close]   sys_close,
[SYS_dup]     sys_dup,
[SYS_exec]    sys_exec,
[SYS_exit]    sys_exit,
[SYS_fork]    sys_fork,
[SYS_fstat]   sys_fstat,
[SYS_getpid]  sys_getpid,
[SYS_kill]    sys_kill,
[SYS_link]    sys_link,
[SYS_mkdir]   sys_mkdir,
[SYS_mknod]   sys_mknod,
[SYS_open]    sys_open,
[SYS_pipe]    sys_pipe,
[SYS_read]    sys_read,
[SYS_sbrk]    sys_sbrk,
[SYS_sleep]   sys_sleep,
[SYS_unlink]  sys_unlink,
[SYS_wait]    sys_wait,
[SYS_write]   sys_write,
[SYS_upmsec]  sys_upmsec,
// BSD socket
[SYS_socket]  sys_socket,
[SYS_bind]    sys_bind,
[SYS_listen]  sys_listen,
[SYS_accept]  sys_accept,
[SYS_recv]    sys_recv,
[SYS_recvfrom] sys_recvfrom,
[SYS_send]    sys_send,
[SYS_sendto]  sys_sendto,
[SYS_shutdown] sys_shutdown,
[SYS_getsockopt] sys_getsockopt,
[SYS_setsockopt] sys_setsockopt,
[SYS_sockclose] sys_sockclose,
[SYS_connect] sys_connect,
[SYS_getpeername] sys_getpeername,
[SYS_getsockname] sys_getsockname,
};

void
syscall(void)
{
  106390:	55                   	push   %ebp
  106391:	89 e5                	mov    %esp,%ebp
  106393:	53                   	push   %ebx
  106394:	83 ec 24             	sub    $0x24,%esp
  int num;
  
  num = cp->tf->eax;
  106397:	e8 f4 d4 ff ff       	call   103890 <cpu>
  10639c:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  1063a3:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
  1063a9:	8b 40 1c             	mov    0x1c(%eax),%eax
  1063ac:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  if(num >= 0 && num < NELEM(syscalls) && syscalls[num])
  1063af:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  1063b3:	78 39                	js     1063ee <syscall+0x5e>
  1063b5:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1063b8:	83 f8 24             	cmp    $0x24,%eax
  1063bb:	77 31                	ja     1063ee <syscall+0x5e>
  1063bd:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1063c0:	8b 04 85 20 c6 11 00 	mov    0x11c620(,%eax,4),%eax
  1063c7:	85 c0                	test   %eax,%eax
  1063c9:	74 23                	je     1063ee <syscall+0x5e>
    cp->tf->eax = syscalls[num]();
  1063cb:	e8 c0 d4 ff ff       	call   103890 <cpu>
  1063d0:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  1063d7:	8b 98 84 00 00 00    	mov    0x84(%eax),%ebx
  1063dd:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1063e0:	8b 04 85 20 c6 11 00 	mov    0x11c620(,%eax,4),%eax
  1063e7:	ff d0                	call   *%eax
  1063e9:	89 43 1c             	mov    %eax,0x1c(%ebx)
  1063ec:	eb 55                	jmp    106443 <syscall+0xb3>
  else {
    cprintf("%d %s: unknown sys call %d\n",
  1063ee:	e8 9d d4 ff ff       	call   103890 <cpu>
  1063f3:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  1063fa:	8d 98 88 00 00 00    	lea    0x88(%eax),%ebx
  106400:	e8 8b d4 ff ff       	call   103890 <cpu>
  106405:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  10640c:	8b 50 10             	mov    0x10(%eax),%edx
  10640f:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  106412:	89 44 24 0c          	mov    %eax,0xc(%esp)
  106416:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  10641a:	89 54 24 04          	mov    %edx,0x4(%esp)
  10641e:	c7 04 24 40 a7 11 00 	movl   $0x11a740,(%esp)
  106425:	e8 e6 a2 ff ff       	call   100710 <cprintf>
            cp->pid, cp->name, num);
    cp->tf->eax = -1;
  10642a:	e8 61 d4 ff ff       	call   103890 <cpu>
  10642f:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  106436:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
  10643c:	c7 40 1c ff ff ff ff 	movl   $0xffffffff,0x1c(%eax)
  }
}
  106443:	83 c4 24             	add    $0x24,%esp
  106446:	5b                   	pop    %ebx
  106447:	5d                   	pop    %ebp
  106448:	c3                   	ret    
  106449:	90                   	nop    
  10644a:	90                   	nop    
  10644b:	90                   	nop    
  10644c:	90                   	nop    
  10644d:	90                   	nop    
  10644e:	90                   	nop    
  10644f:	90                   	nop    

00106450 <argfd>:
// Fetch the nth word-sized system call argument as a file descriptor
// and return both the descriptor and the corresponding struct file.
static int
argfd(int n, int *pfd, struct file **pf)
{
  106450:	55                   	push   %ebp
  106451:	89 e5                	mov    %esp,%ebp
  106453:	83 ec 28             	sub    $0x28,%esp
  int fd;
  struct file *f;

  if(argint(n, &fd) < 0)
  106456:	8d 45 f8             	lea    0xfffffff8(%ebp),%eax
  106459:	89 44 24 04          	mov    %eax,0x4(%esp)
  10645d:	8b 45 08             	mov    0x8(%ebp),%eax
  106460:	89 04 24             	mov    %eax,(%esp)
  106463:	e8 e8 fd ff ff       	call   106250 <argint>
  106468:	85 c0                	test   %eax,%eax
  10646a:	79 09                	jns    106475 <argfd+0x25>
    return -1;
  10646c:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  106473:	eb 57                	jmp    1064cc <argfd+0x7c>
  if(fd < 0 || fd >= NOFILE || (f=cp->ofile[fd]) == 0)
  106475:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  106478:	85 c0                	test   %eax,%eax
  10647a:	78 24                	js     1064a0 <argfd+0x50>
  10647c:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10647f:	83 f8 0f             	cmp    $0xf,%eax
  106482:	7f 1c                	jg     1064a0 <argfd+0x50>
  106484:	e8 07 d4 ff ff       	call   103890 <cpu>
  106489:	8b 14 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%edx
  106490:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  106493:	8b 44 82 20          	mov    0x20(%edx,%eax,4),%eax
  106497:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  10649a:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  10649e:	75 09                	jne    1064a9 <argfd+0x59>
    return -1;
  1064a0:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  1064a7:	eb 23                	jmp    1064cc <argfd+0x7c>
  if(pfd)
  1064a9:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  1064ad:	74 08                	je     1064b7 <argfd+0x67>
    *pfd = fd;
  1064af:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  1064b2:	8b 45 0c             	mov    0xc(%ebp),%eax
  1064b5:	89 10                	mov    %edx,(%eax)
  if(pf)
  1064b7:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  1064bb:	74 08                	je     1064c5 <argfd+0x75>
    *pf = f;
  1064bd:	8b 55 10             	mov    0x10(%ebp),%edx
  1064c0:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1064c3:	89 02                	mov    %eax,(%edx)
  return 0;
  1064c5:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  1064cc:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  1064cf:	c9                   	leave  
  1064d0:	c3                   	ret    
  1064d1:	eb 0d                	jmp    1064e0 <fdalloc>
  1064d3:	90                   	nop    
  1064d4:	90                   	nop    
  1064d5:	90                   	nop    
  1064d6:	90                   	nop    
  1064d7:	90                   	nop    
  1064d8:	90                   	nop    
  1064d9:	90                   	nop    
  1064da:	90                   	nop    
  1064db:	90                   	nop    
  1064dc:	90                   	nop    
  1064dd:	90                   	nop    
  1064de:	90                   	nop    
  1064df:	90                   	nop    

001064e0 <fdalloc>:

// Allocate a file descriptor for the given file.
// Takes over file reference from caller on success.
static int
fdalloc(struct file *f)
{
  1064e0:	55                   	push   %ebp
  1064e1:	89 e5                	mov    %esp,%ebp
  1064e3:	83 ec 18             	sub    $0x18,%esp
  int fd;

  for(fd = 0; fd < NOFILE; fd++){
  1064e6:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
  1064ed:	eb 39                	jmp    106528 <fdalloc+0x48>
    if(cp->ofile[fd] == 0){
  1064ef:	e8 9c d3 ff ff       	call   103890 <cpu>
  1064f4:	8b 14 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%edx
  1064fb:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1064fe:	8b 44 82 20          	mov    0x20(%edx,%eax,4),%eax
  106502:	85 c0                	test   %eax,%eax
  106504:	75 1e                	jne    106524 <fdalloc+0x44>
      cp->ofile[fd] = f;
  106506:	e8 85 d3 ff ff       	call   103890 <cpu>
  10650b:	8b 0c 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%ecx
  106512:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  106515:	8b 45 08             	mov    0x8(%ebp),%eax
  106518:	89 44 91 20          	mov    %eax,0x20(%ecx,%edx,4)
      return fd;
  10651c:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10651f:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  106522:	eb 11                	jmp    106535 <fdalloc+0x55>
  106524:	83 45 fc 01          	addl   $0x1,0xfffffffc(%ebp)
  106528:	83 7d fc 0f          	cmpl   $0xf,0xfffffffc(%ebp)
  10652c:	7e c1                	jle    1064ef <fdalloc+0xf>
    }
  }
  return -1;
  10652e:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  106535:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  106538:	c9                   	leave  
  106539:	c3                   	ret    
  10653a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

00106540 <sys_read>:

int
sys_read(void)
{
  106540:	55                   	push   %ebp
  106541:	89 e5                	mov    %esp,%ebp
  106543:	56                   	push   %esi
  106544:	53                   	push   %ebx
  106545:	83 ec 30             	sub    $0x30,%esp
  106548:	89 e0                	mov    %esp,%eax
  10654a:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
  struct file *f;
  int n;
  char *cp;
  10654d:	e8 3e d3 ff ff       	call   103890 <cpu>
  106552:	c1 e0 02             	shl    $0x2,%eax
  106555:	83 c0 0f             	add    $0xf,%eax
  106558:	83 c0 0f             	add    $0xf,%eax
  10655b:	c1 e8 04             	shr    $0x4,%eax
  10655e:	c1 e0 04             	shl    $0x4,%eax
  106561:	29 c4                	sub    %eax,%esp
  106563:	8d 44 24 0c          	lea    0xc(%esp),%eax
  106567:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
  10656a:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  10656d:	83 c0 0f             	add    $0xf,%eax
  106570:	c1 e8 04             	shr    $0x4,%eax
  106573:	c1 e0 04             	shl    $0x4,%eax
  106576:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
  106579:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  10657c:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)

  if(argfd(0, 0, &f) < 0 || argint(2, &n) < 0 || argptr(1, &cp, n) < 0)
  10657f:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
  106582:	89 44 24 08          	mov    %eax,0x8(%esp)
  106586:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  10658d:	00 
  10658e:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  106595:	e8 b6 fe ff ff       	call   106450 <argfd>
  10659a:	85 c0                	test   %eax,%eax
  10659c:	78 40                	js     1065de <sys_read+0x9e>
  10659e:	8d 45 ec             	lea    0xffffffec(%ebp),%eax
  1065a1:	89 44 24 04          	mov    %eax,0x4(%esp)
  1065a5:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  1065ac:	e8 9f fc ff ff       	call   106250 <argint>
  1065b1:	85 c0                	test   %eax,%eax
  1065b3:	78 29                	js     1065de <sys_read+0x9e>
  1065b5:	8b 5d ec             	mov    0xffffffec(%ebp),%ebx
  1065b8:	8b 75 f4             	mov    0xfffffff4(%ebp),%esi
  1065bb:	e8 d0 d2 ff ff       	call   103890 <cpu>
  1065c0:	c1 e0 02             	shl    $0x2,%eax
  1065c3:	8d 04 06             	lea    (%esi,%eax,1),%eax
  1065c6:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  1065ca:	89 44 24 04          	mov    %eax,0x4(%esp)
  1065ce:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  1065d5:	e8 c6 fc ff ff       	call   1062a0 <argptr>
  1065da:	85 c0                	test   %eax,%eax
  1065dc:	79 09                	jns    1065e7 <sys_read+0xa7>
    return -1;
  1065de:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,0xffffffe0(%ebp)
  1065e5:	eb 26                	jmp    10660d <sys_read+0xcd>
  return fileread(f, cp, n);
  1065e7:	8b 5d ec             	mov    0xffffffec(%ebp),%ebx
  1065ea:	e8 a1 d2 ff ff       	call   103890 <cpu>
  1065ef:	89 c2                	mov    %eax,%edx
  1065f1:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  1065f4:	8b 04 90             	mov    (%eax,%edx,4),%eax
  1065f7:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
  1065fa:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  1065fe:	89 44 24 04          	mov    %eax,0x4(%esp)
  106602:	89 14 24             	mov    %edx,(%esp)
  106605:	e8 d6 b1 ff ff       	call   1017e0 <fileread>
  10660a:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
  10660d:	8b 65 e4             	mov    0xffffffe4(%ebp),%esp
  106610:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
}
  106613:	8d 65 f8             	lea    0xfffffff8(%ebp),%esp
  106616:	5b                   	pop    %ebx
  106617:	5e                   	pop    %esi
  106618:	5d                   	pop    %ebp
  106619:	c3                   	ret    
  10661a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

00106620 <sys_write>:

int
sys_write(void)
{
  106620:	55                   	push   %ebp
  106621:	89 e5                	mov    %esp,%ebp
  106623:	56                   	push   %esi
  106624:	53                   	push   %ebx
  106625:	83 ec 30             	sub    $0x30,%esp
  106628:	89 e0                	mov    %esp,%eax
  10662a:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
  struct file *f;
  int n;
  char *cp;
  10662d:	e8 5e d2 ff ff       	call   103890 <cpu>
  106632:	c1 e0 02             	shl    $0x2,%eax
  106635:	83 c0 0f             	add    $0xf,%eax
  106638:	83 c0 0f             	add    $0xf,%eax
  10663b:	c1 e8 04             	shr    $0x4,%eax
  10663e:	c1 e0 04             	shl    $0x4,%eax
  106641:	29 c4                	sub    %eax,%esp
  106643:	8d 44 24 0c          	lea    0xc(%esp),%eax
  106647:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
  10664a:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  10664d:	83 c0 0f             	add    $0xf,%eax
  106650:	c1 e8 04             	shr    $0x4,%eax
  106653:	c1 e0 04             	shl    $0x4,%eax
  106656:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
  106659:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  10665c:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)

  if(argfd(0, 0, &f) < 0 || argint(2, &n) < 0 || argptr(1, &cp, n) < 0)
  10665f:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
  106662:	89 44 24 08          	mov    %eax,0x8(%esp)
  106666:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  10666d:	00 
  10666e:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  106675:	e8 d6 fd ff ff       	call   106450 <argfd>
  10667a:	85 c0                	test   %eax,%eax
  10667c:	78 40                	js     1066be <sys_write+0x9e>
  10667e:	8d 45 ec             	lea    0xffffffec(%ebp),%eax
  106681:	89 44 24 04          	mov    %eax,0x4(%esp)
  106685:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  10668c:	e8 bf fb ff ff       	call   106250 <argint>
  106691:	85 c0                	test   %eax,%eax
  106693:	78 29                	js     1066be <sys_write+0x9e>
  106695:	8b 5d ec             	mov    0xffffffec(%ebp),%ebx
  106698:	8b 75 f4             	mov    0xfffffff4(%ebp),%esi
  10669b:	e8 f0 d1 ff ff       	call   103890 <cpu>
  1066a0:	c1 e0 02             	shl    $0x2,%eax
  1066a3:	8d 04 06             	lea    (%esi,%eax,1),%eax
  1066a6:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  1066aa:	89 44 24 04          	mov    %eax,0x4(%esp)
  1066ae:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  1066b5:	e8 e6 fb ff ff       	call   1062a0 <argptr>
  1066ba:	85 c0                	test   %eax,%eax
  1066bc:	79 09                	jns    1066c7 <sys_write+0xa7>
    return -1;
  1066be:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,0xffffffe0(%ebp)
  1066c5:	eb 26                	jmp    1066ed <sys_write+0xcd>
  return filewrite(f, cp, n);
  1066c7:	8b 5d ec             	mov    0xffffffec(%ebp),%ebx
  1066ca:	e8 c1 d1 ff ff       	call   103890 <cpu>
  1066cf:	89 c2                	mov    %eax,%edx
  1066d1:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  1066d4:	8b 04 90             	mov    (%eax,%edx,4),%eax
  1066d7:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
  1066da:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  1066de:	89 44 24 04          	mov    %eax,0x4(%esp)
  1066e2:	89 14 24             	mov    %edx,(%esp)
  1066e5:	e8 c6 b1 ff ff       	call   1018b0 <filewrite>
  1066ea:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
  1066ed:	8b 65 e4             	mov    0xffffffe4(%ebp),%esp
  1066f0:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
}
  1066f3:	8d 65 f8             	lea    0xfffffff8(%ebp),%esp
  1066f6:	5b                   	pop    %ebx
  1066f7:	5e                   	pop    %esi
  1066f8:	5d                   	pop    %ebp
  1066f9:	c3                   	ret    
  1066fa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

00106700 <sys_dup>:

int
sys_dup(void)
{
  106700:	55                   	push   %ebp
  106701:	89 e5                	mov    %esp,%ebp
  106703:	83 ec 28             	sub    $0x28,%esp
  struct file *f;
  int fd;
  
  if(argfd(0, 0, &f) < 0)
  106706:	8d 45 f8             	lea    0xfffffff8(%ebp),%eax
  106709:	89 44 24 08          	mov    %eax,0x8(%esp)
  10670d:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  106714:	00 
  106715:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  10671c:	e8 2f fd ff ff       	call   106450 <argfd>
  106721:	85 c0                	test   %eax,%eax
  106723:	79 09                	jns    10672e <sys_dup+0x2e>
    return -1;
  106725:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  10672c:	eb 2e                	jmp    10675c <sys_dup+0x5c>
  if((fd=fdalloc(f)) < 0)
  10672e:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  106731:	89 04 24             	mov    %eax,(%esp)
  106734:	e8 a7 fd ff ff       	call   1064e0 <fdalloc>
  106739:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  10673c:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  106740:	79 09                	jns    10674b <sys_dup+0x4b>
    return -1;
  106742:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  106749:	eb 11                	jmp    10675c <sys_dup+0x5c>
  filedup(f);
  10674b:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10674e:	89 04 24             	mov    %eax,(%esp)
  106751:	e8 aa ae ff ff       	call   101600 <filedup>
  return fd;
  106756:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  106759:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  10675c:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  10675f:	c9                   	leave  
  106760:	c3                   	ret    
  106761:	eb 0d                	jmp    106770 <sys_close>
  106763:	90                   	nop    
  106764:	90                   	nop    
  106765:	90                   	nop    
  106766:	90                   	nop    
  106767:	90                   	nop    
  106768:	90                   	nop    
  106769:	90                   	nop    
  10676a:	90                   	nop    
  10676b:	90                   	nop    
  10676c:	90                   	nop    
  10676d:	90                   	nop    
  10676e:	90                   	nop    
  10676f:	90                   	nop    

00106770 <sys_close>:

int
sys_close(void)
{
  106770:	55                   	push   %ebp
  106771:	89 e5                	mov    %esp,%ebp
  106773:	83 ec 28             	sub    $0x28,%esp
  int fd;
  struct file *f;
  
  if(argfd(0, &fd, &f) < 0)
  106776:	8d 45 f8             	lea    0xfffffff8(%ebp),%eax
  106779:	89 44 24 08          	mov    %eax,0x8(%esp)
  10677d:	8d 45 fc             	lea    0xfffffffc(%ebp),%eax
  106780:	89 44 24 04          	mov    %eax,0x4(%esp)
  106784:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  10678b:	e8 c0 fc ff ff       	call   106450 <argfd>
  106790:	85 c0                	test   %eax,%eax
  106792:	79 09                	jns    10679d <sys_close+0x2d>
    return -1;
  106794:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  10679b:	eb 29                	jmp    1067c6 <sys_close+0x56>
  cp->ofile[fd] = 0;
  10679d:	e8 ee d0 ff ff       	call   103890 <cpu>
  1067a2:	8b 14 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%edx
  1067a9:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1067ac:	c7 44 82 20 00 00 00 	movl   $0x0,0x20(%edx,%eax,4)
  1067b3:	00 
  fileclose(f);
  1067b4:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1067b7:	89 04 24             	mov    %eax,(%esp)
  1067ba:	e8 a1 ae ff ff       	call   101660 <fileclose>
  return 0;
  1067bf:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  1067c6:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  1067c9:	c9                   	leave  
  1067ca:	c3                   	ret    
  1067cb:	90                   	nop    
  1067cc:	8d 74 26 00          	lea    0x0(%esi),%esi

001067d0 <sys_fstat>:

int
sys_fstat(void)
{
  1067d0:	55                   	push   %ebp
  1067d1:	89 e5                	mov    %esp,%ebp
  1067d3:	83 ec 28             	sub    $0x28,%esp
  struct file *f;
  struct stat *st;
  
  if(argfd(0, 0, &f) < 0 || argptr(1, (void*)&st, sizeof(*st)) < 0)
  1067d6:	8d 45 fc             	lea    0xfffffffc(%ebp),%eax
  1067d9:	89 44 24 08          	mov    %eax,0x8(%esp)
  1067dd:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  1067e4:	00 
  1067e5:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  1067ec:	e8 5f fc ff ff       	call   106450 <argfd>
  1067f1:	85 c0                	test   %eax,%eax
  1067f3:	78 1f                	js     106814 <sys_fstat+0x44>
  1067f5:	8d 45 f8             	lea    0xfffffff8(%ebp),%eax
  1067f8:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
  1067ff:	00 
  106800:	89 44 24 04          	mov    %eax,0x4(%esp)
  106804:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  10680b:	e8 90 fa ff ff       	call   1062a0 <argptr>
  106810:	85 c0                	test   %eax,%eax
  106812:	79 09                	jns    10681d <sys_fstat+0x4d>
    return -1;
  106814:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  10681b:	eb 15                	jmp    106832 <sys_fstat+0x62>
  return filestat(f, st);
  10681d:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  106820:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  106823:	89 44 24 04          	mov    %eax,0x4(%esp)
  106827:	89 14 24             	mov    %edx,(%esp)
  10682a:	e8 51 af ff ff       	call   101780 <filestat>
  10682f:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  106832:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  106835:	c9                   	leave  
  106836:	c3                   	ret    
  106837:	89 f6                	mov    %esi,%esi
  106839:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00106840 <sys_link>:

// Create the path new as a link to the same inode as old.
int
sys_link(void)
{
  106840:	55                   	push   %ebp
  106841:	89 e5                	mov    %esp,%ebp
  106843:	83 ec 38             	sub    $0x38,%esp
  char name[DIRSIZ], *new, *old;
  struct inode *dp, *ip;

  if(argstr(0, &old) < 0 || argstr(1, &new) < 0)
  106846:	8d 45 e0             	lea    0xffffffe0(%ebp),%eax
  106849:	89 44 24 04          	mov    %eax,0x4(%esp)
  10684d:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  106854:	e8 d7 fa ff ff       	call   106330 <argstr>
  106859:	85 c0                	test   %eax,%eax
  10685b:	78 17                	js     106874 <sys_link+0x34>
  10685d:	8d 45 e4             	lea    0xffffffe4(%ebp),%eax
  106860:	89 44 24 04          	mov    %eax,0x4(%esp)
  106864:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  10686b:	e8 c0 fa ff ff       	call   106330 <argstr>
  106870:	85 c0                	test   %eax,%eax
  106872:	79 0c                	jns    106880 <sys_link+0x40>
    return -1;
  106874:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,0xffffffdc(%ebp)
  10687b:	e9 33 01 00 00       	jmp    1069b3 <sys_link+0x173>
  if((ip = namei(old)) == 0)
  106880:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  106883:	89 04 24             	mov    %eax,(%esp)
  106886:	e8 c5 c3 ff ff       	call   102c50 <namei>
  10688b:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  10688e:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  106892:	75 0c                	jne    1068a0 <sys_link+0x60>
    return -1;
  106894:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,0xffffffdc(%ebp)
  10689b:	e9 13 01 00 00       	jmp    1069b3 <sys_link+0x173>
  ilock(ip);
  1068a0:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1068a3:	89 04 24             	mov    %eax,(%esp)
  1068a6:	e8 05 b5 ff ff       	call   101db0 <ilock>
  if(ip->type == T_DIR){
  1068ab:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1068ae:	0f b7 40 10          	movzwl 0x10(%eax),%eax
  1068b2:	66 83 f8 01          	cmp    $0x1,%ax
  1068b6:	75 17                	jne    1068cf <sys_link+0x8f>
    iunlockput(ip);
  1068b8:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1068bb:	89 04 24             	mov    %eax,(%esp)
  1068be:	e8 9d b7 ff ff       	call   102060 <iunlockput>
    return -1;
  1068c3:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,0xffffffdc(%ebp)
  1068ca:	e9 e4 00 00 00       	jmp    1069b3 <sys_link+0x173>
  }
  ip->nlink++;
  1068cf:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1068d2:	0f b7 40 16          	movzwl 0x16(%eax),%eax
  1068d6:	8d 50 01             	lea    0x1(%eax),%edx
  1068d9:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1068dc:	66 89 50 16          	mov    %dx,0x16(%eax)
  iupdate(ip);
  1068e0:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1068e3:	89 04 24             	mov    %eax,(%esp)
  1068e6:	e8 85 b8 ff ff       	call   102170 <iupdate>
  iunlock(ip);
  1068eb:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1068ee:	89 04 24             	mov    %eax,(%esp)
  1068f1:	e8 1a b6 ff ff       	call   101f10 <iunlock>

  if((dp = nameiparent(new, name)) == 0)
  1068f6:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
  1068f9:	8d 45 ea             	lea    0xffffffea(%ebp),%eax
  1068fc:	89 44 24 04          	mov    %eax,0x4(%esp)
  106900:	89 14 24             	mov    %edx,(%esp)
  106903:	e8 78 c3 ff ff       	call   102c80 <nameiparent>
  106908:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  10690b:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  10690f:	74 58                	je     106969 <sys_link+0x129>
    goto  bad;
  ilock(dp);
  106911:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  106914:	89 04 24             	mov    %eax,(%esp)
  106917:	e8 94 b4 ff ff       	call   101db0 <ilock>
  if(dp->dev != ip->dev || dirlink(dp, name, ip->inum) < 0)
  10691c:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10691f:	8b 10                	mov    (%eax),%edx
  106921:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  106924:	8b 00                	mov    (%eax),%eax
  106926:	39 c2                	cmp    %eax,%edx
  106928:	75 3f                	jne    106969 <sys_link+0x129>
  10692a:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10692d:	8b 40 04             	mov    0x4(%eax),%eax
  106930:	89 44 24 08          	mov    %eax,0x8(%esp)
  106934:	8d 45 ea             	lea    0xffffffea(%ebp),%eax
  106937:	89 44 24 04          	mov    %eax,0x4(%esp)
  10693b:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10693e:	89 04 24             	mov    %eax,(%esp)
  106941:	e8 1a c0 ff ff       	call   102960 <dirlink>
  106946:	85 c0                	test   %eax,%eax
  106948:	78 1f                	js     106969 <sys_link+0x129>
    goto bad;
  iunlockput(dp);
  10694a:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10694d:	89 04 24             	mov    %eax,(%esp)
  106950:	e8 0b b7 ff ff       	call   102060 <iunlockput>
  iput(ip);
  106955:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  106958:	89 04 24             	mov    %eax,(%esp)
  10695b:	e8 20 b6 ff ff       	call   101f80 <iput>
  return 0;
  106960:	c7 45 dc 00 00 00 00 	movl   $0x0,0xffffffdc(%ebp)
  106967:	eb 4a                	jmp    1069b3 <sys_link+0x173>

bad:
  if(dp)
  106969:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  10696d:	74 0b                	je     10697a <sys_link+0x13a>
    iunlockput(dp);
  10696f:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  106972:	89 04 24             	mov    %eax,(%esp)
  106975:	e8 e6 b6 ff ff       	call   102060 <iunlockput>
  ilock(ip);
  10697a:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10697d:	89 04 24             	mov    %eax,(%esp)
  106980:	e8 2b b4 ff ff       	call   101db0 <ilock>
  ip->nlink--;
  106985:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  106988:	0f b7 40 16          	movzwl 0x16(%eax),%eax
  10698c:	8d 50 ff             	lea    0xffffffff(%eax),%edx
  10698f:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  106992:	66 89 50 16          	mov    %dx,0x16(%eax)
  iupdate(ip);
  106996:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  106999:	89 04 24             	mov    %eax,(%esp)
  10699c:	e8 cf b7 ff ff       	call   102170 <iupdate>
  iunlockput(ip);
  1069a1:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1069a4:	89 04 24             	mov    %eax,(%esp)
  1069a7:	e8 b4 b6 ff ff       	call   102060 <iunlockput>
  return -1;
  1069ac:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,0xffffffdc(%ebp)
  1069b3:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
}
  1069b6:	c9                   	leave  
  1069b7:	c3                   	ret    
  1069b8:	90                   	nop    
  1069b9:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

001069c0 <isdirempty>:

// Is the directory dp empty except for "." and ".." ?
static int
isdirempty(struct inode *dp)
{
  1069c0:	55                   	push   %ebp
  1069c1:	89 e5                	mov    %esp,%ebp
  1069c3:	83 ec 38             	sub    $0x38,%esp
  int off;
  struct dirent de;

  for(off=2*sizeof(de); off<dp->size; off+=sizeof(de)){
  1069c6:	c7 45 fc 20 00 00 00 	movl   $0x20,0xfffffffc(%ebp)
  1069cd:	eb 4d                	jmp    106a1c <isdirempty+0x5c>
    if(readi(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
  1069cf:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1069d2:	8d 55 ec             	lea    0xffffffec(%ebp),%edx
  1069d5:	c7 44 24 0c 10 00 00 	movl   $0x10,0xc(%esp)
  1069dc:	00 
  1069dd:	89 44 24 08          	mov    %eax,0x8(%esp)
  1069e1:	89 54 24 04          	mov    %edx,0x4(%esp)
  1069e5:	8b 45 08             	mov    0x8(%ebp),%eax
  1069e8:	89 04 24             	mov    %eax,(%esp)
  1069eb:	e8 d0 ba ff ff       	call   1024c0 <readi>
  1069f0:	83 f8 10             	cmp    $0x10,%eax
  1069f3:	74 0c                	je     106a01 <isdirempty+0x41>
      panic("isdirempty: readi");
  1069f5:	c7 04 24 5c a7 11 00 	movl   $0x11a75c,(%esp)
  1069fc:	e8 ff a5 ff ff       	call   101000 <panic>
    if(de.inum != 0)
  106a01:	0f b7 45 ec          	movzwl 0xffffffec(%ebp),%eax
  106a05:	66 85 c0             	test   %ax,%ax
  106a08:	74 09                	je     106a13 <isdirempty+0x53>
      return 0;
  106a0a:	c7 45 dc 00 00 00 00 	movl   $0x0,0xffffffdc(%ebp)
  106a11:	eb 1d                	jmp    106a30 <isdirempty+0x70>
  106a13:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  106a16:	83 c0 10             	add    $0x10,%eax
  106a19:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  106a1c:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  106a1f:	8b 55 08             	mov    0x8(%ebp),%edx
  106a22:	8b 52 18             	mov    0x18(%edx),%edx
  106a25:	39 d0                	cmp    %edx,%eax
  106a27:	72 a6                	jb     1069cf <isdirempty+0xf>
  }
  return 1;
  106a29:	c7 45 dc 01 00 00 00 	movl   $0x1,0xffffffdc(%ebp)
  106a30:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
}
  106a33:	c9                   	leave  
  106a34:	c3                   	ret    
  106a35:	8d 74 26 00          	lea    0x0(%esi),%esi
  106a39:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00106a40 <sys_unlink>:

int
sys_unlink(void)
{
  106a40:	55                   	push   %ebp
  106a41:	89 e5                	mov    %esp,%ebp
  106a43:	83 ec 48             	sub    $0x48,%esp
  struct inode *ip, *dp;
  struct dirent de;
  char name[DIRSIZ], *path;
  uint off;

  if(argstr(0, &path) < 0)
  106a46:	8d 45 d4             	lea    0xffffffd4(%ebp),%eax
  106a49:	89 44 24 04          	mov    %eax,0x4(%esp)
  106a4d:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  106a54:	e8 d7 f8 ff ff       	call   106330 <argstr>
  106a59:	85 c0                	test   %eax,%eax
  106a5b:	79 0c                	jns    106a69 <sys_unlink+0x29>
    return -1;
  106a5d:	c7 45 cc ff ff ff ff 	movl   $0xffffffff,0xffffffcc(%ebp)
  106a64:	e9 97 01 00 00       	jmp    106c00 <sys_unlink+0x1c0>
  if((dp = nameiparent(path, name)) == 0)
  106a69:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
  106a6c:	8d 55 da             	lea    0xffffffda(%ebp),%edx
  106a6f:	89 54 24 04          	mov    %edx,0x4(%esp)
  106a73:	89 04 24             	mov    %eax,(%esp)
  106a76:	e8 05 c2 ff ff       	call   102c80 <nameiparent>
  106a7b:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  106a7e:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  106a82:	75 0c                	jne    106a90 <sys_unlink+0x50>
    return -1;
  106a84:	c7 45 cc ff ff ff ff 	movl   $0xffffffff,0xffffffcc(%ebp)
  106a8b:	e9 70 01 00 00       	jmp    106c00 <sys_unlink+0x1c0>
  ilock(dp);
  106a90:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  106a93:	89 04 24             	mov    %eax,(%esp)
  106a96:	e8 15 b3 ff ff       	call   101db0 <ilock>

  // Cannot unlink "." or "..".
  if(namecmp(name, ".") == 0 || namecmp(name, "..") == 0){
  106a9b:	c7 44 24 04 6e a7 11 	movl   $0x11a76e,0x4(%esp)
  106aa2:	00 
  106aa3:	8d 45 da             	lea    0xffffffda(%ebp),%eax
  106aa6:	89 04 24             	mov    %eax,(%esp)
  106aa9:	e8 52 bd ff ff       	call   102800 <namecmp>
  106aae:	85 c0                	test   %eax,%eax
  106ab0:	74 17                	je     106ac9 <sys_unlink+0x89>
  106ab2:	c7 44 24 04 70 a7 11 	movl   $0x11a770,0x4(%esp)
  106ab9:	00 
  106aba:	8d 45 da             	lea    0xffffffda(%ebp),%eax
  106abd:	89 04 24             	mov    %eax,(%esp)
  106ac0:	e8 3b bd ff ff       	call   102800 <namecmp>
  106ac5:	85 c0                	test   %eax,%eax
  106ac7:	75 17                	jne    106ae0 <sys_unlink+0xa0>
    iunlockput(dp);
  106ac9:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  106acc:	89 04 24             	mov    %eax,(%esp)
  106acf:	e8 8c b5 ff ff       	call   102060 <iunlockput>
    return -1;
  106ad4:	c7 45 cc ff ff ff ff 	movl   $0xffffffff,0xffffffcc(%ebp)
  106adb:	e9 20 01 00 00       	jmp    106c00 <sys_unlink+0x1c0>
  }

  if((ip = dirlookup(dp, name, &off)) == 0){
  106ae0:	8d 45 d0             	lea    0xffffffd0(%ebp),%eax
  106ae3:	89 44 24 08          	mov    %eax,0x8(%esp)
  106ae7:	8d 45 da             	lea    0xffffffda(%ebp),%eax
  106aea:	89 44 24 04          	mov    %eax,0x4(%esp)
  106aee:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  106af1:	89 04 24             	mov    %eax,(%esp)
  106af4:	e8 37 bd ff ff       	call   102830 <dirlookup>
  106af9:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  106afc:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  106b00:	75 17                	jne    106b19 <sys_unlink+0xd9>
    iunlockput(dp);
  106b02:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  106b05:	89 04 24             	mov    %eax,(%esp)
  106b08:	e8 53 b5 ff ff       	call   102060 <iunlockput>
    return -1;
  106b0d:	c7 45 cc ff ff ff ff 	movl   $0xffffffff,0xffffffcc(%ebp)
  106b14:	e9 e7 00 00 00       	jmp    106c00 <sys_unlink+0x1c0>
  }
  ilock(ip);
  106b19:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  106b1c:	89 04 24             	mov    %eax,(%esp)
  106b1f:	e8 8c b2 ff ff       	call   101db0 <ilock>

  if(ip->nlink < 1)
  106b24:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  106b27:	0f b7 40 16          	movzwl 0x16(%eax),%eax
  106b2b:	66 85 c0             	test   %ax,%ax
  106b2e:	7f 0c                	jg     106b3c <sys_unlink+0xfc>
    panic("unlink: nlink < 1");
  106b30:	c7 04 24 73 a7 11 00 	movl   $0x11a773,(%esp)
  106b37:	e8 c4 a4 ff ff       	call   101000 <panic>
  if(ip->type == T_DIR && !isdirempty(ip)){
  106b3c:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  106b3f:	0f b7 40 10          	movzwl 0x10(%eax),%eax
  106b43:	66 83 f8 01          	cmp    $0x1,%ax
  106b47:	75 31                	jne    106b7a <sys_unlink+0x13a>
  106b49:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  106b4c:	89 04 24             	mov    %eax,(%esp)
  106b4f:	e8 6c fe ff ff       	call   1069c0 <isdirempty>
  106b54:	85 c0                	test   %eax,%eax
  106b56:	75 22                	jne    106b7a <sys_unlink+0x13a>
    iunlockput(ip);
  106b58:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  106b5b:	89 04 24             	mov    %eax,(%esp)
  106b5e:	e8 fd b4 ff ff       	call   102060 <iunlockput>
    iunlockput(dp);
  106b63:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  106b66:	89 04 24             	mov    %eax,(%esp)
  106b69:	e8 f2 b4 ff ff       	call   102060 <iunlockput>
    return -1;
  106b6e:	c7 45 cc ff ff ff ff 	movl   $0xffffffff,0xffffffcc(%ebp)
  106b75:	e9 86 00 00 00       	jmp    106c00 <sys_unlink+0x1c0>
  }

  memset(&de, 0, sizeof(de));
  106b7a:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
  106b81:	00 
  106b82:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  106b89:	00 
  106b8a:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
  106b8d:	89 04 24             	mov    %eax,(%esp)
  106b90:	e8 3b f3 ff ff       	call   105ed0 <memset>
  if(writei(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
  106b95:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
  106b98:	8d 55 e8             	lea    0xffffffe8(%ebp),%edx
  106b9b:	c7 44 24 0c 10 00 00 	movl   $0x10,0xc(%esp)
  106ba2:	00 
  106ba3:	89 44 24 08          	mov    %eax,0x8(%esp)
  106ba7:	89 54 24 04          	mov    %edx,0x4(%esp)
  106bab:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  106bae:	89 04 24             	mov    %eax,(%esp)
  106bb1:	e8 9a ba ff ff       	call   102650 <writei>
  106bb6:	83 f8 10             	cmp    $0x10,%eax
  106bb9:	74 0c                	je     106bc7 <sys_unlink+0x187>
    panic("unlink: writei");
  106bbb:	c7 04 24 85 a7 11 00 	movl   $0x11a785,(%esp)
  106bc2:	e8 39 a4 ff ff       	call   101000 <panic>
  iunlockput(dp);
  106bc7:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  106bca:	89 04 24             	mov    %eax,(%esp)
  106bcd:	e8 8e b4 ff ff       	call   102060 <iunlockput>

  ip->nlink--;
  106bd2:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  106bd5:	0f b7 40 16          	movzwl 0x16(%eax),%eax
  106bd9:	8d 50 ff             	lea    0xffffffff(%eax),%edx
  106bdc:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  106bdf:	66 89 50 16          	mov    %dx,0x16(%eax)
  iupdate(ip);
  106be3:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  106be6:	89 04 24             	mov    %eax,(%esp)
  106be9:	e8 82 b5 ff ff       	call   102170 <iupdate>
  iunlockput(ip);
  106bee:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  106bf1:	89 04 24             	mov    %eax,(%esp)
  106bf4:	e8 67 b4 ff ff       	call   102060 <iunlockput>
  return 0;
  106bf9:	c7 45 cc 00 00 00 00 	movl   $0x0,0xffffffcc(%ebp)
  106c00:	8b 45 cc             	mov    0xffffffcc(%ebp),%eax
}
  106c03:	c9                   	leave  
  106c04:	c3                   	ret    
  106c05:	8d 74 26 00          	lea    0x0(%esi),%esi
  106c09:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00106c10 <create>:

static struct inode*
create(char *path, int canexist, short type, short major, short minor)
{
  106c10:	55                   	push   %ebp
  106c11:	89 e5                	mov    %esp,%ebp
  106c13:	83 ec 48             	sub    $0x48,%esp
  106c16:	8b 45 10             	mov    0x10(%ebp),%eax
  106c19:	8b 55 14             	mov    0x14(%ebp),%edx
  106c1c:	8b 4d 18             	mov    0x18(%ebp),%ecx
  106c1f:	66 89 45 dc          	mov    %ax,0xffffffdc(%ebp)
  106c23:	66 89 55 d8          	mov    %dx,0xffffffd8(%ebp)
  106c27:	66 89 4d d4          	mov    %cx,0xffffffd4(%ebp)
  uint off;
  struct inode *ip, *dp;
  char name[DIRSIZ];

  if((dp = nameiparent(path, name)) == 0)
  106c2b:	8d 45 e6             	lea    0xffffffe6(%ebp),%eax
  106c2e:	89 44 24 04          	mov    %eax,0x4(%esp)
  106c32:	8b 45 08             	mov    0x8(%ebp),%eax
  106c35:	89 04 24             	mov    %eax,(%esp)
  106c38:	e8 43 c0 ff ff       	call   102c80 <nameiparent>
  106c3d:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  106c40:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  106c44:	75 0c                	jne    106c52 <create+0x42>
    return 0;
  106c46:	c7 45 d0 00 00 00 00 	movl   $0x0,0xffffffd0(%ebp)
  106c4d:	e9 cd 01 00 00       	jmp    106e1f <create+0x20f>
  ilock(dp);
  106c52:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  106c55:	89 04 24             	mov    %eax,(%esp)
  106c58:	e8 53 b1 ff ff       	call   101db0 <ilock>

  if(canexist && (ip = dirlookup(dp, name, &off)) != 0){
  106c5d:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  106c61:	0f 84 81 00 00 00    	je     106ce8 <create+0xd8>
  106c67:	8d 45 f4             	lea    0xfffffff4(%ebp),%eax
  106c6a:	89 44 24 08          	mov    %eax,0x8(%esp)
  106c6e:	8d 45 e6             	lea    0xffffffe6(%ebp),%eax
  106c71:	89 44 24 04          	mov    %eax,0x4(%esp)
  106c75:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  106c78:	89 04 24             	mov    %eax,(%esp)
  106c7b:	e8 b0 bb ff ff       	call   102830 <dirlookup>
  106c80:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  106c83:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  106c87:	74 5f                	je     106ce8 <create+0xd8>
    iunlockput(dp);
  106c89:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  106c8c:	89 04 24             	mov    %eax,(%esp)
  106c8f:	e8 cc b3 ff ff       	call   102060 <iunlockput>
    ilock(ip);
  106c94:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  106c97:	89 04 24             	mov    %eax,(%esp)
  106c9a:	e8 11 b1 ff ff       	call   101db0 <ilock>
    if(ip->type != type || ip->major != major || ip->minor != minor){
  106c9f:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  106ca2:	0f b7 40 10          	movzwl 0x10(%eax),%eax
  106ca6:	66 3b 45 dc          	cmp    0xffffffdc(%ebp),%ax
  106caa:	75 1a                	jne    106cc6 <create+0xb6>
  106cac:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  106caf:	0f b7 40 12          	movzwl 0x12(%eax),%eax
  106cb3:	66 3b 45 d8          	cmp    0xffffffd8(%ebp),%ax
  106cb7:	75 0d                	jne    106cc6 <create+0xb6>
  106cb9:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  106cbc:	0f b7 40 14          	movzwl 0x14(%eax),%eax
  106cc0:	66 3b 45 d4          	cmp    0xffffffd4(%ebp),%ax
  106cc4:	74 17                	je     106cdd <create+0xcd>
      iunlockput(ip);
  106cc6:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  106cc9:	89 04 24             	mov    %eax,(%esp)
  106ccc:	e8 8f b3 ff ff       	call   102060 <iunlockput>
      return 0;
  106cd1:	c7 45 d0 00 00 00 00 	movl   $0x0,0xffffffd0(%ebp)
  106cd8:	e9 42 01 00 00       	jmp    106e1f <create+0x20f>
    }
    return ip;
  106cdd:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  106ce0:	89 45 d0             	mov    %eax,0xffffffd0(%ebp)
  106ce3:	e9 37 01 00 00       	jmp    106e1f <create+0x20f>
  }

  if((ip = ialloc(dp->dev, type)) == 0){
  106ce8:	0f bf 55 dc          	movswl 0xffffffdc(%ebp),%edx
  106cec:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  106cef:	8b 00                	mov    (%eax),%eax
  106cf1:	89 54 24 04          	mov    %edx,0x4(%esp)
  106cf5:	89 04 24             	mov    %eax,(%esp)
  106cf8:	e8 83 b3 ff ff       	call   102080 <ialloc>
  106cfd:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  106d00:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  106d04:	75 17                	jne    106d1d <create+0x10d>
    iunlockput(dp);
  106d06:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  106d09:	89 04 24             	mov    %eax,(%esp)
  106d0c:	e8 4f b3 ff ff       	call   102060 <iunlockput>
    return 0;
  106d11:	c7 45 d0 00 00 00 00 	movl   $0x0,0xffffffd0(%ebp)
  106d18:	e9 02 01 00 00       	jmp    106e1f <create+0x20f>
  }
  ilock(ip);
  106d1d:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  106d20:	89 04 24             	mov    %eax,(%esp)
  106d23:	e8 88 b0 ff ff       	call   101db0 <ilock>
  ip->major = major;
  106d28:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  106d2b:	0f b7 45 d8          	movzwl 0xffffffd8(%ebp),%eax
  106d2f:	66 89 42 12          	mov    %ax,0x12(%edx)
  ip->minor = minor;
  106d33:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  106d36:	0f b7 45 d4          	movzwl 0xffffffd4(%ebp),%eax
  106d3a:	66 89 42 14          	mov    %ax,0x14(%edx)
  ip->nlink = 1;
  106d3e:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  106d41:	66 c7 40 16 01 00    	movw   $0x1,0x16(%eax)
  iupdate(ip);
  106d47:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  106d4a:	89 04 24             	mov    %eax,(%esp)
  106d4d:	e8 1e b4 ff ff       	call   102170 <iupdate>
  
  if(dirlink(dp, name, ip->inum) < 0){
  106d52:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  106d55:	8b 40 04             	mov    0x4(%eax),%eax
  106d58:	89 44 24 08          	mov    %eax,0x8(%esp)
  106d5c:	8d 45 e6             	lea    0xffffffe6(%ebp),%eax
  106d5f:	89 44 24 04          	mov    %eax,0x4(%esp)
  106d63:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  106d66:	89 04 24             	mov    %eax,(%esp)
  106d69:	e8 f2 bb ff ff       	call   102960 <dirlink>
  106d6e:	85 c0                	test   %eax,%eax
  106d70:	79 2b                	jns    106d9d <create+0x18d>
    ip->nlink = 0;
  106d72:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  106d75:	66 c7 40 16 00 00    	movw   $0x0,0x16(%eax)
    iunlockput(ip);
  106d7b:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  106d7e:	89 04 24             	mov    %eax,(%esp)
  106d81:	e8 da b2 ff ff       	call   102060 <iunlockput>
    iunlockput(dp);
  106d86:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  106d89:	89 04 24             	mov    %eax,(%esp)
  106d8c:	e8 cf b2 ff ff       	call   102060 <iunlockput>
    return 0;
  106d91:	c7 45 d0 00 00 00 00 	movl   $0x0,0xffffffd0(%ebp)
  106d98:	e9 82 00 00 00       	jmp    106e1f <create+0x20f>
  }

  if(type == T_DIR){  // Create . and .. entries.
  106d9d:	66 83 7d dc 01       	cmpw   $0x1,0xffffffdc(%ebp)
  106da2:	75 6a                	jne    106e0e <create+0x1fe>
    dp->nlink++;  // for ".."
  106da4:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  106da7:	0f b7 40 16          	movzwl 0x16(%eax),%eax
  106dab:	8d 50 01             	lea    0x1(%eax),%edx
  106dae:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  106db1:	66 89 50 16          	mov    %dx,0x16(%eax)
    iupdate(dp);
  106db5:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  106db8:	89 04 24             	mov    %eax,(%esp)
  106dbb:	e8 b0 b3 ff ff       	call   102170 <iupdate>
    // No ip->nlink++ for ".": avoid cyclic ref count.
    if(dirlink(ip, ".", ip->inum) < 0 || dirlink(ip, "..", dp->inum) < 0)
  106dc0:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  106dc3:	8b 40 04             	mov    0x4(%eax),%eax
  106dc6:	89 44 24 08          	mov    %eax,0x8(%esp)
  106dca:	c7 44 24 04 6e a7 11 	movl   $0x11a76e,0x4(%esp)
  106dd1:	00 
  106dd2:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  106dd5:	89 04 24             	mov    %eax,(%esp)
  106dd8:	e8 83 bb ff ff       	call   102960 <dirlink>
  106ddd:	85 c0                	test   %eax,%eax
  106ddf:	78 21                	js     106e02 <create+0x1f2>
  106de1:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  106de4:	8b 40 04             	mov    0x4(%eax),%eax
  106de7:	89 44 24 08          	mov    %eax,0x8(%esp)
  106deb:	c7 44 24 04 70 a7 11 	movl   $0x11a770,0x4(%esp)
  106df2:	00 
  106df3:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  106df6:	89 04 24             	mov    %eax,(%esp)
  106df9:	e8 62 bb ff ff       	call   102960 <dirlink>
  106dfe:	85 c0                	test   %eax,%eax
  106e00:	79 0c                	jns    106e0e <create+0x1fe>
      panic("create dots");
  106e02:	c7 04 24 94 a7 11 00 	movl   $0x11a794,(%esp)
  106e09:	e8 f2 a1 ff ff       	call   101000 <panic>
  }
  iunlockput(dp);
  106e0e:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  106e11:	89 04 24             	mov    %eax,(%esp)
  106e14:	e8 47 b2 ff ff       	call   102060 <iunlockput>
  return ip;
  106e19:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  106e1c:	89 45 d0             	mov    %eax,0xffffffd0(%ebp)
  106e1f:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
}
  106e22:	c9                   	leave  
  106e23:	c3                   	ret    
  106e24:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  106e2a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

00106e30 <sys_open>:

int
sys_open(void)
{
  106e30:	55                   	push   %ebp
  106e31:	89 e5                	mov    %esp,%ebp
  106e33:	83 ec 48             	sub    $0x48,%esp
  char *path;
  int fd, omode;
  struct file *f;
  struct inode *ip;

  if(argstr(0, &path) < 0 || argint(1, &omode) < 0)
  106e36:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
  106e39:	89 44 24 04          	mov    %eax,0x4(%esp)
  106e3d:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  106e44:	e8 e7 f4 ff ff       	call   106330 <argstr>
  106e49:	85 c0                	test   %eax,%eax
  106e4b:	78 17                	js     106e64 <sys_open+0x34>
  106e4d:	8d 45 ec             	lea    0xffffffec(%ebp),%eax
  106e50:	89 44 24 04          	mov    %eax,0x4(%esp)
  106e54:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  106e5b:	e8 f0 f3 ff ff       	call   106250 <argint>
  106e60:	85 c0                	test   %eax,%eax
  106e62:	79 0c                	jns    106e70 <sys_open+0x40>
    return -1;
  106e64:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,0xffffffd8(%ebp)
  106e6b:	e9 58 01 00 00       	jmp    106fc8 <sys_open+0x198>

  if(omode & O_CREATE){
  106e70:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  106e73:	25 00 02 00 00       	and    $0x200,%eax
  106e78:	85 c0                	test   %eax,%eax
  106e7a:	74 40                	je     106ebc <sys_open+0x8c>
    if((ip = create(path, 1, T_FILE, 0, 0)) == 0)
  106e7c:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  106e7f:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  106e86:	00 
  106e87:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  106e8e:	00 
  106e8f:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
  106e96:	00 
  106e97:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  106e9e:	00 
  106e9f:	89 04 24             	mov    %eax,(%esp)
  106ea2:	e8 69 fd ff ff       	call   106c10 <create>
  106ea7:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  106eaa:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  106eae:	75 65                	jne    106f15 <sys_open+0xe5>
      return -1;
  106eb0:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,0xffffffd8(%ebp)
  106eb7:	e9 0c 01 00 00       	jmp    106fc8 <sys_open+0x198>
  } else {
    if((ip = namei(path)) == 0)
  106ebc:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  106ebf:	89 04 24             	mov    %eax,(%esp)
  106ec2:	e8 89 bd ff ff       	call   102c50 <namei>
  106ec7:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  106eca:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  106ece:	75 0c                	jne    106edc <sys_open+0xac>
      return -1;
  106ed0:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,0xffffffd8(%ebp)
  106ed7:	e9 ec 00 00 00       	jmp    106fc8 <sys_open+0x198>
    ilock(ip);
  106edc:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  106edf:	89 04 24             	mov    %eax,(%esp)
  106ee2:	e8 c9 ae ff ff       	call   101db0 <ilock>
    if(ip->type == T_DIR && (omode & (O_RDWR|O_WRONLY))){
  106ee7:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  106eea:	0f b7 40 10          	movzwl 0x10(%eax),%eax
  106eee:	66 83 f8 01          	cmp    $0x1,%ax
  106ef2:	75 21                	jne    106f15 <sys_open+0xe5>
  106ef4:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  106ef7:	83 e0 03             	and    $0x3,%eax
  106efa:	85 c0                	test   %eax,%eax
  106efc:	74 17                	je     106f15 <sys_open+0xe5>
      iunlockput(ip);
  106efe:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  106f01:	89 04 24             	mov    %eax,(%esp)
  106f04:	e8 57 b1 ff ff       	call   102060 <iunlockput>
      return -1;
  106f09:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,0xffffffd8(%ebp)
  106f10:	e9 b3 00 00 00       	jmp    106fc8 <sys_open+0x198>
    }
  }

  if((f = filealloc()) == 0 || (fd = fdalloc(f)) < 0){
  106f15:	e8 36 a6 ff ff       	call   101550 <filealloc>
  106f1a:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  106f1d:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  106f21:	74 14                	je     106f37 <sys_open+0x107>
  106f23:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  106f26:	89 04 24             	mov    %eax,(%esp)
  106f29:	e8 b2 f5 ff ff       	call   1064e0 <fdalloc>
  106f2e:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  106f31:	83 7d f4 00          	cmpl   $0x0,0xfffffff4(%ebp)
  106f35:	79 25                	jns    106f5c <sys_open+0x12c>
    if(f)
  106f37:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  106f3b:	74 0b                	je     106f48 <sys_open+0x118>
      fileclose(f);
  106f3d:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  106f40:	89 04 24             	mov    %eax,(%esp)
  106f43:	e8 18 a7 ff ff       	call   101660 <fileclose>
    iunlockput(ip);
  106f48:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  106f4b:	89 04 24             	mov    %eax,(%esp)
  106f4e:	e8 0d b1 ff ff       	call   102060 <iunlockput>
    return -1;
  106f53:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,0xffffffd8(%ebp)
  106f5a:	eb 6c                	jmp    106fc8 <sys_open+0x198>
  }
  iunlock(ip);
  106f5c:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  106f5f:	89 04 24             	mov    %eax,(%esp)
  106f62:	e8 a9 af ff ff       	call   101f10 <iunlock>

  f->type = FD_INODE;
  106f67:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  106f6a:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
  f->ip = ip;
  106f70:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  106f73:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  106f76:	89 42 10             	mov    %eax,0x10(%edx)
  f->off = 0;
  106f79:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  106f7c:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
  f->readable = !(omode & O_WRONLY);
  106f83:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  106f86:	83 e0 01             	and    $0x1,%eax
  106f89:	85 c0                	test   %eax,%eax
  106f8b:	0f 94 c2             	sete   %dl
  106f8e:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  106f91:	88 50 08             	mov    %dl,0x8(%eax)
  f->writable = (omode & O_WRONLY) || (omode & O_RDWR);
  106f94:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  106f97:	83 e0 01             	and    $0x1,%eax
  106f9a:	84 c0                	test   %al,%al
  106f9c:	75 0a                	jne    106fa8 <sys_open+0x178>
  106f9e:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  106fa1:	83 e0 02             	and    $0x2,%eax
  106fa4:	85 c0                	test   %eax,%eax
  106fa6:	74 09                	je     106fb1 <sys_open+0x181>
  106fa8:	c7 45 dc 01 00 00 00 	movl   $0x1,0xffffffdc(%ebp)
  106faf:	eb 07                	jmp    106fb8 <sys_open+0x188>
  106fb1:	c7 45 dc 00 00 00 00 	movl   $0x0,0xffffffdc(%ebp)
  106fb8:	0f b6 55 dc          	movzbl 0xffffffdc(%ebp),%edx
  106fbc:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  106fbf:	88 50 09             	mov    %dl,0x9(%eax)

  return fd;
  106fc2:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  106fc5:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
  106fc8:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
}
  106fcb:	c9                   	leave  
  106fcc:	c3                   	ret    
  106fcd:	8d 76 00             	lea    0x0(%esi),%esi

00106fd0 <sys_mknod>:

int
sys_mknod(void)
{
  106fd0:	55                   	push   %ebp
  106fd1:	89 e5                	mov    %esp,%ebp
  106fd3:	83 ec 38             	sub    $0x38,%esp
  struct inode *ip;
  char *path;
  int len;
  int major, minor;
  
  if((len=argstr(0, &path)) < 0 ||
  106fd6:	8d 45 f4             	lea    0xfffffff4(%ebp),%eax
  106fd9:	89 44 24 04          	mov    %eax,0x4(%esp)
  106fdd:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  106fe4:	e8 47 f3 ff ff       	call   106330 <argstr>
  106fe9:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  106fec:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  106ff0:	78 64                	js     107056 <sys_mknod+0x86>
  106ff2:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
  106ff5:	89 44 24 04          	mov    %eax,0x4(%esp)
  106ff9:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  107000:	e8 4b f2 ff ff       	call   106250 <argint>
  107005:	85 c0                	test   %eax,%eax
  107007:	78 4d                	js     107056 <sys_mknod+0x86>
  107009:	8d 45 ec             	lea    0xffffffec(%ebp),%eax
  10700c:	89 44 24 04          	mov    %eax,0x4(%esp)
  107010:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  107017:	e8 34 f2 ff ff       	call   106250 <argint>
  10701c:	85 c0                	test   %eax,%eax
  10701e:	78 36                	js     107056 <sys_mknod+0x86>
  107020:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  107023:	0f bf d0             	movswl %ax,%edx
  107026:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  107029:	98                   	cwtl   
  10702a:	8b 4d f4             	mov    0xfffffff4(%ebp),%ecx
  10702d:	89 54 24 10          	mov    %edx,0x10(%esp)
  107031:	89 44 24 0c          	mov    %eax,0xc(%esp)
  107035:	c7 44 24 08 03 00 00 	movl   $0x3,0x8(%esp)
  10703c:	00 
  10703d:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  107044:	00 
  107045:	89 0c 24             	mov    %ecx,(%esp)
  107048:	e8 c3 fb ff ff       	call   106c10 <create>
  10704d:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  107050:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  107054:	75 09                	jne    10705f <sys_mknod+0x8f>
     argint(1, &major) < 0 ||
     argint(2, &minor) < 0 ||
     (ip = create(path, 0, T_DEV, major, minor)) == 0)
    return -1;
  107056:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,0xffffffdc(%ebp)
  10705d:	eb 12                	jmp    107071 <sys_mknod+0xa1>
  iunlockput(ip);
  10705f:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  107062:	89 04 24             	mov    %eax,(%esp)
  107065:	e8 f6 af ff ff       	call   102060 <iunlockput>
  return 0;
  10706a:	c7 45 dc 00 00 00 00 	movl   $0x0,0xffffffdc(%ebp)
  107071:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
}
  107074:	c9                   	leave  
  107075:	c3                   	ret    
  107076:	8d 76 00             	lea    0x0(%esi),%esi
  107079:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00107080 <sys_mkdir>:

int
sys_mkdir(void)
{
  107080:	55                   	push   %ebp
  107081:	89 e5                	mov    %esp,%ebp
  107083:	83 ec 28             	sub    $0x28,%esp
  char *path;
  struct inode *ip;

  if(argstr(0, &path) < 0 || (ip = create(path, 0, T_DIR, 0, 0)) == 0)
  107086:	8d 45 f8             	lea    0xfffffff8(%ebp),%eax
  107089:	89 44 24 04          	mov    %eax,0x4(%esp)
  10708d:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  107094:	e8 97 f2 ff ff       	call   106330 <argstr>
  107099:	85 c0                	test   %eax,%eax
  10709b:	78 34                	js     1070d1 <sys_mkdir+0x51>
  10709d:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1070a0:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  1070a7:	00 
  1070a8:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  1070af:	00 
  1070b0:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  1070b7:	00 
  1070b8:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  1070bf:	00 
  1070c0:	89 04 24             	mov    %eax,(%esp)
  1070c3:	e8 48 fb ff ff       	call   106c10 <create>
  1070c8:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  1070cb:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  1070cf:	75 09                	jne    1070da <sys_mkdir+0x5a>
    return -1;
  1070d1:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  1070d8:	eb 12                	jmp    1070ec <sys_mkdir+0x6c>
  iunlockput(ip);
  1070da:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1070dd:	89 04 24             	mov    %eax,(%esp)
  1070e0:	e8 7b af ff ff       	call   102060 <iunlockput>
  return 0;
  1070e5:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  1070ec:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  1070ef:	c9                   	leave  
  1070f0:	c3                   	ret    
  1070f1:	eb 0d                	jmp    107100 <sys_chdir>
  1070f3:	90                   	nop    
  1070f4:	90                   	nop    
  1070f5:	90                   	nop    
  1070f6:	90                   	nop    
  1070f7:	90                   	nop    
  1070f8:	90                   	nop    
  1070f9:	90                   	nop    
  1070fa:	90                   	nop    
  1070fb:	90                   	nop    
  1070fc:	90                   	nop    
  1070fd:	90                   	nop    
  1070fe:	90                   	nop    
  1070ff:	90                   	nop    

00107100 <sys_chdir>:

int
sys_chdir(void)
{
  107100:	55                   	push   %ebp
  107101:	89 e5                	mov    %esp,%ebp
  107103:	83 ec 28             	sub    $0x28,%esp
  char *path;
  struct inode *ip;

  if(argstr(0, &path) < 0 || (ip = namei(path)) == 0)
  107106:	8d 45 f8             	lea    0xfffffff8(%ebp),%eax
  107109:	89 44 24 04          	mov    %eax,0x4(%esp)
  10710d:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  107114:	e8 17 f2 ff ff       	call   106330 <argstr>
  107119:	85 c0                	test   %eax,%eax
  10711b:	78 14                	js     107131 <sys_chdir+0x31>
  10711d:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  107120:	89 04 24             	mov    %eax,(%esp)
  107123:	e8 28 bb ff ff       	call   102c50 <namei>
  107128:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  10712b:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  10712f:	75 09                	jne    10713a <sys_chdir+0x3a>
    return -1;
  107131:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  107138:	eb 67                	jmp    1071a1 <sys_chdir+0xa1>
  ilock(ip);
  10713a:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10713d:	89 04 24             	mov    %eax,(%esp)
  107140:	e8 6b ac ff ff       	call   101db0 <ilock>
  if(ip->type != T_DIR){
  107145:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  107148:	0f b7 40 10          	movzwl 0x10(%eax),%eax
  10714c:	66 83 f8 01          	cmp    $0x1,%ax
  107150:	74 14                	je     107166 <sys_chdir+0x66>
    iunlockput(ip);
  107152:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  107155:	89 04 24             	mov    %eax,(%esp)
  107158:	e8 03 af ff ff       	call   102060 <iunlockput>
    return -1;
  10715d:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  107164:	eb 3b                	jmp    1071a1 <sys_chdir+0xa1>
  }
  iunlock(ip);
  107166:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  107169:	89 04 24             	mov    %eax,(%esp)
  10716c:	e8 9f ad ff ff       	call   101f10 <iunlock>
  iput(cp->cwd);
  107171:	e8 1a c7 ff ff       	call   103890 <cpu>
  107176:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  10717d:	8b 40 60             	mov    0x60(%eax),%eax
  107180:	89 04 24             	mov    %eax,(%esp)
  107183:	e8 f8 ad ff ff       	call   101f80 <iput>
  cp->cwd = ip;
  107188:	e8 03 c7 ff ff       	call   103890 <cpu>
  10718d:	8b 14 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%edx
  107194:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  107197:	89 42 60             	mov    %eax,0x60(%edx)
  return 0;
  10719a:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  1071a1:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  1071a4:	c9                   	leave  
  1071a5:	c3                   	ret    
  1071a6:	8d 76 00             	lea    0x0(%esi),%esi
  1071a9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

001071b0 <sys_exec>:

int
sys_exec(void)
{
  1071b0:	55                   	push   %ebp
  1071b1:	89 e5                	mov    %esp,%ebp
  1071b3:	56                   	push   %esi
  1071b4:	53                   	push   %ebx
  1071b5:	83 ec 70             	sub    $0x70,%esp
  char *path, *argv[20];
  int i;
  uint uargv, uarg;

  if(argstr(0, &path) < 0 || argint(1, (int*)&uargv) < 0)
  1071b8:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
  1071bb:	89 44 24 04          	mov    %eax,0x4(%esp)
  1071bf:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  1071c6:	e8 65 f1 ff ff       	call   106330 <argstr>
  1071cb:	85 c0                	test   %eax,%eax
  1071cd:	78 17                	js     1071e6 <sys_exec+0x36>
  1071cf:	8d 45 9c             	lea    0xffffff9c(%ebp),%eax
  1071d2:	89 44 24 04          	mov    %eax,0x4(%esp)
  1071d6:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  1071dd:	e8 6e f0 ff ff       	call   106250 <argint>
  1071e2:	85 c0                	test   %eax,%eax
  1071e4:	79 0c                	jns    1071f2 <sys_exec+0x42>
    return -1;
  1071e6:	c7 45 94 ff ff ff ff 	movl   $0xffffffff,0xffffff94(%ebp)
  1071ed:	e9 d9 00 00 00       	jmp    1072cb <sys_exec+0x11b>
  memset(argv, 0, sizeof(argv));
  1071f2:	c7 44 24 08 50 00 00 	movl   $0x50,0x8(%esp)
  1071f9:	00 
  1071fa:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  107201:	00 
  107202:	8d 45 a0             	lea    0xffffffa0(%ebp),%eax
  107205:	89 04 24             	mov    %eax,(%esp)
  107208:	e8 c3 ec ff ff       	call   105ed0 <memset>
  for(i=0;; i++){
  10720d:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
    if(i >= NELEM(argv))
  107214:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  107217:	83 f8 13             	cmp    $0x13,%eax
  10721a:	76 0c                	jbe    107228 <sys_exec+0x78>
      return -1;
  10721c:	c7 45 94 ff ff ff ff 	movl   $0xffffffff,0xffffff94(%ebp)
  107223:	e9 a3 00 00 00       	jmp    1072cb <sys_exec+0x11b>
    if(fetchint(cp, uargv+4*i, (int*)&uarg) < 0)
  107228:	8d 75 98             	lea    0xffffff98(%ebp),%esi
  10722b:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10722e:	c1 e0 02             	shl    $0x2,%eax
  107231:	89 c2                	mov    %eax,%edx
  107233:	8b 45 9c             	mov    0xffffff9c(%ebp),%eax
  107236:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
  107239:	e8 52 c6 ff ff       	call   103890 <cpu>
  10723e:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  107245:	89 74 24 08          	mov    %esi,0x8(%esp)
  107249:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  10724d:	89 04 24             	mov    %eax,(%esp)
  107250:	e8 2b ef ff ff       	call   106180 <fetchint>
  107255:	85 c0                	test   %eax,%eax
  107257:	79 09                	jns    107262 <sys_exec+0xb2>
      return -1;
  107259:	c7 45 94 ff ff ff ff 	movl   $0xffffffff,0xffffff94(%ebp)
  107260:	eb 69                	jmp    1072cb <sys_exec+0x11b>
    if(uarg == 0){
  107262:	8b 45 98             	mov    0xffffff98(%ebp),%eax
  107265:	85 c0                	test   %eax,%eax
  107267:	75 22                	jne    10728b <sys_exec+0xdb>
      argv[i] = 0;
  107269:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10726c:	c7 44 85 a0 00 00 00 	movl   $0x0,0xffffffa0(%ebp,%eax,4)
  107273:	00 
      break;
    }
    if(fetchstr(cp, uarg, &argv[i]) < 0)
      return -1;
  }
  return exec(path, argv);
  107274:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
  107277:	8d 45 a0             	lea    0xffffffa0(%ebp),%eax
  10727a:	89 44 24 04          	mov    %eax,0x4(%esp)
  10727e:	89 14 24             	mov    %edx,(%esp)
  107281:	e8 1a 9e ff ff       	call   1010a0 <exec>
  107286:	89 45 94             	mov    %eax,0xffffff94(%ebp)
  107289:	eb 40                	jmp    1072cb <sys_exec+0x11b>
  10728b:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10728e:	c1 e0 02             	shl    $0x2,%eax
  107291:	8d 5d a0             	lea    0xffffffa0(%ebp),%ebx
  107294:	01 c3                	add    %eax,%ebx
  107296:	8b 75 98             	mov    0xffffff98(%ebp),%esi
  107299:	e8 f2 c5 ff ff       	call   103890 <cpu>
  10729e:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  1072a5:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  1072a9:	89 74 24 04          	mov    %esi,0x4(%esp)
  1072ad:	89 04 24             	mov    %eax,(%esp)
  1072b0:	e8 1b ef ff ff       	call   1061d0 <fetchstr>
  1072b5:	85 c0                	test   %eax,%eax
  1072b7:	79 09                	jns    1072c2 <sys_exec+0x112>
  1072b9:	c7 45 94 ff ff ff ff 	movl   $0xffffffff,0xffffff94(%ebp)
  1072c0:	eb 09                	jmp    1072cb <sys_exec+0x11b>
  1072c2:	83 45 f4 01          	addl   $0x1,0xfffffff4(%ebp)
  1072c6:	e9 49 ff ff ff       	jmp    107214 <sys_exec+0x64>
  1072cb:	8b 45 94             	mov    0xffffff94(%ebp),%eax
}
  1072ce:	83 c4 70             	add    $0x70,%esp
  1072d1:	5b                   	pop    %ebx
  1072d2:	5e                   	pop    %esi
  1072d3:	5d                   	pop    %ebp
  1072d4:	c3                   	ret    
  1072d5:	8d 74 26 00          	lea    0x0(%esi),%esi
  1072d9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

001072e0 <sys_pipe>:

int
sys_pipe(void)
{
  1072e0:	55                   	push   %ebp
  1072e1:	89 e5                	mov    %esp,%ebp
  1072e3:	83 ec 38             	sub    $0x38,%esp
  int *fd;
  struct file *rf, *wf;
  int fd0, fd1;

  if(argptr(0, (void*)&fd, 2*sizeof(fd[0])) < 0)
  1072e6:	8d 45 f4             	lea    0xfffffff4(%ebp),%eax
  1072e9:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  1072f0:	00 
  1072f1:	89 44 24 04          	mov    %eax,0x4(%esp)
  1072f5:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  1072fc:	e8 9f ef ff ff       	call   1062a0 <argptr>
  107301:	85 c0                	test   %eax,%eax
  107303:	79 0c                	jns    107311 <sys_pipe+0x31>
    return -1;
  107305:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,0xffffffdc(%ebp)
  10730c:	e9 a7 00 00 00       	jmp    1073b8 <sys_pipe+0xd8>
  if(pipealloc(&rf, &wf) < 0)
  107311:	8d 45 ec             	lea    0xffffffec(%ebp),%eax
  107314:	89 44 24 04          	mov    %eax,0x4(%esp)
  107318:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
  10731b:	89 04 24             	mov    %eax,(%esp)
  10731e:	e8 5d d0 ff ff       	call   104380 <pipealloc>
  107323:	85 c0                	test   %eax,%eax
  107325:	79 0c                	jns    107333 <sys_pipe+0x53>
    return -1;
  107327:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,0xffffffdc(%ebp)
  10732e:	e9 85 00 00 00       	jmp    1073b8 <sys_pipe+0xd8>
  fd0 = -1;
  107333:	c7 45 f8 ff ff ff ff 	movl   $0xffffffff,0xfffffff8(%ebp)
  if((fd0 = fdalloc(rf)) < 0 || (fd1 = fdalloc(wf)) < 0){
  10733a:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10733d:	89 04 24             	mov    %eax,(%esp)
  107340:	e8 9b f1 ff ff       	call   1064e0 <fdalloc>
  107345:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  107348:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  10734c:	78 14                	js     107362 <sys_pipe+0x82>
  10734e:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  107351:	89 04 24             	mov    %eax,(%esp)
  107354:	e8 87 f1 ff ff       	call   1064e0 <fdalloc>
  107359:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  10735c:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  107360:	79 3c                	jns    10739e <sys_pipe+0xbe>
    if(fd0 >= 0)
  107362:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  107366:	78 17                	js     10737f <sys_pipe+0x9f>
      cp->ofile[fd0] = 0;
  107368:	e8 23 c5 ff ff       	call   103890 <cpu>
  10736d:	8b 14 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%edx
  107374:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  107377:	c7 44 82 20 00 00 00 	movl   $0x0,0x20(%edx,%eax,4)
  10737e:	00 
    fileclose(rf);
  10737f:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  107382:	89 04 24             	mov    %eax,(%esp)
  107385:	e8 d6 a2 ff ff       	call   101660 <fileclose>
    fileclose(wf);
  10738a:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10738d:	89 04 24             	mov    %eax,(%esp)
  107390:	e8 cb a2 ff ff       	call   101660 <fileclose>
    return -1;
  107395:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,0xffffffdc(%ebp)
  10739c:	eb 1a                	jmp    1073b8 <sys_pipe+0xd8>
  }
  fd[0] = fd0;
  10739e:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
  1073a1:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1073a4:	89 02                	mov    %eax,(%edx)
  fd[1] = fd1;
  1073a6:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  1073a9:	8d 50 04             	lea    0x4(%eax),%edx
  1073ac:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1073af:	89 02                	mov    %eax,(%edx)
  return 0;
  1073b1:	c7 45 dc 00 00 00 00 	movl   $0x0,0xffffffdc(%ebp)
  1073b8:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
}
  1073bb:	c9                   	leave  
  1073bc:	c3                   	ret    
  1073bd:	90                   	nop    
  1073be:	90                   	nop    
  1073bf:	90                   	nop    

001073c0 <sys_fork>:
#include "lwip/include/lwip/sockets.h"

int
sys_fork(void)
{
  1073c0:	55                   	push   %ebp
  1073c1:	89 e5                	mov    %esp,%ebp
  1073c3:	83 ec 18             	sub    $0x18,%esp
  struct proc *np;

  if((np = copyproc(cp)) == 0)
  1073c6:	e8 c5 c4 ff ff       	call   103890 <cpu>
  1073cb:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  1073d2:	89 04 24             	mov    %eax,(%esp)
  1073d5:	e8 26 da ff ff       	call   104e00 <copyproc>
  1073da:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  1073dd:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  1073e1:	75 09                	jne    1073ec <sys_fork+0x2c>
    return -1;
  1073e3:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  1073ea:	eb 13                	jmp    1073ff <sys_fork+0x3f>
  np->state = RUNNABLE;
  1073ec:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1073ef:	c7 40 0c 03 00 00 00 	movl   $0x3,0xc(%eax)
  return np->pid;
  1073f6:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1073f9:	8b 40 10             	mov    0x10(%eax),%eax
  1073fc:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  1073ff:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  107402:	c9                   	leave  
  107403:	c3                   	ret    
  107404:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  10740a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

00107410 <sys_exit>:

int
sys_exit(void)
{
  107410:	55                   	push   %ebp
  107411:	89 e5                	mov    %esp,%ebp
  107413:	83 ec 08             	sub    $0x8,%esp
  exit();
  107416:	e8 95 e2 ff ff       	call   1056b0 <exit>
  return 0;  // not reached
  10741b:	b8 00 00 00 00       	mov    $0x0,%eax
}
  107420:	c9                   	leave  
  107421:	c3                   	ret    
  107422:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi
  107429:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00107430 <sys_wait>:

int
sys_wait(void)
{
  107430:	55                   	push   %ebp
  107431:	89 e5                	mov    %esp,%ebp
  107433:	83 ec 08             	sub    $0x8,%esp
  return wait();
  107436:	e8 25 e4 ff ff       	call   105860 <wait>
}
  10743b:	c9                   	leave  
  10743c:	c3                   	ret    
  10743d:	8d 76 00             	lea    0x0(%esi),%esi

00107440 <sys_kill>:

int
sys_kill(void)
{
  107440:	55                   	push   %ebp
  107441:	89 e5                	mov    %esp,%ebp
  107443:	83 ec 28             	sub    $0x28,%esp
  int pid;

  if(argint(0, &pid) < 0)
  107446:	8d 45 fc             	lea    0xfffffffc(%ebp),%eax
  107449:	89 44 24 04          	mov    %eax,0x4(%esp)
  10744d:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  107454:	e8 f7 ed ff ff       	call   106250 <argint>
  107459:	85 c0                	test   %eax,%eax
  10745b:	79 09                	jns    107466 <sys_kill+0x26>
    return -1;
  10745d:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  107464:	eb 0e                	jmp    107474 <sys_kill+0x34>
  return kill(pid);
  107466:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  107469:	89 04 24             	mov    %eax,(%esp)
  10746c:	e8 af e1 ff ff       	call   105620 <kill>
  107471:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  107474:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  107477:	c9                   	leave  
  107478:	c3                   	ret    
  107479:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

00107480 <sys_getpid>:

int
sys_getpid(void)
{
  107480:	55                   	push   %ebp
  107481:	89 e5                	mov    %esp,%ebp
  107483:	83 ec 08             	sub    $0x8,%esp
  return cp->pid;
  107486:	e8 05 c4 ff ff       	call   103890 <cpu>
  10748b:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  107492:	8b 40 10             	mov    0x10(%eax),%eax
}
  107495:	c9                   	leave  
  107496:	c3                   	ret    
  107497:	89 f6                	mov    %esi,%esi
  107499:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

001074a0 <sys_sbrk>:

int
sys_sbrk(void)
{
  1074a0:	55                   	push   %ebp
  1074a1:	89 e5                	mov    %esp,%ebp
  1074a3:	83 ec 28             	sub    $0x28,%esp
  int addr;
  int n;

  if(argint(0, &n) < 0)
  1074a6:	8d 45 f8             	lea    0xfffffff8(%ebp),%eax
  1074a9:	89 44 24 04          	mov    %eax,0x4(%esp)
  1074ad:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  1074b4:	e8 97 ed ff ff       	call   106250 <argint>
  1074b9:	85 c0                	test   %eax,%eax
  1074bb:	79 09                	jns    1074c6 <sys_sbrk+0x26>
    return -1;
  1074bd:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  1074c4:	eb 37                	jmp    1074fd <sys_sbrk+0x5d>
  if((addr = growproc(n)) < 0)
  1074c6:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1074c9:	89 04 24             	mov    %eax,(%esp)
  1074cc:	e8 8f d3 ff ff       	call   104860 <growproc>
  1074d1:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  1074d4:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  1074d8:	79 09                	jns    1074e3 <sys_sbrk+0x43>
    return -1;
  1074da:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  1074e1:	eb 1a                	jmp    1074fd <sys_sbrk+0x5d>
  setupsegs(cp);
  1074e3:	e8 a8 c3 ff ff       	call   103890 <cpu>
  1074e8:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  1074ef:	89 04 24             	mov    %eax,(%esp)
  1074f2:	e8 79 d4 ff ff       	call   104970 <setupsegs>
  return addr;
  1074f7:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1074fa:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  1074fd:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  107500:	c9                   	leave  
  107501:	c3                   	ret    
  107502:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi
  107509:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00107510 <sys_sleep>:

int
sys_sleep(void)
{
  107510:	55                   	push   %ebp
  107511:	89 e5                	mov    %esp,%ebp
  107513:	83 ec 28             	sub    $0x28,%esp
  int n, ticks0;
  
  if(argint(0, &n) < 0)
  107516:	8d 45 f8             	lea    0xfffffff8(%ebp),%eax
  107519:	89 44 24 04          	mov    %eax,0x4(%esp)
  10751d:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  107524:	e8 27 ed ff ff       	call   106250 <argint>
  107529:	85 c0                	test   %eax,%eax
  10752b:	79 09                	jns    107536 <sys_sleep+0x26>
    return -1;
  10752d:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  107534:	eb 76                	jmp    1075ac <sys_sleep+0x9c>
  acquire(&tickslock);
  107536:	c7 04 24 80 0c 14 00 	movl   $0x140c80,(%esp)
  10753d:	e8 ce e5 ff ff       	call   105b10 <acquire>
  ticks0 = ticks;
  107542:	a1 c0 14 14 00       	mov    0x1414c0,%eax
  107547:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  while(ticks - ticks0 < n){
  10754a:	eb 3c                	jmp    107588 <sys_sleep+0x78>
    if(cp->killed){
  10754c:	e8 3f c3 ff ff       	call   103890 <cpu>
  107551:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  107558:	8b 40 1c             	mov    0x1c(%eax),%eax
  10755b:	85 c0                	test   %eax,%eax
  10755d:	74 15                	je     107574 <sys_sleep+0x64>
      release(&tickslock);
  10755f:	c7 04 24 80 0c 14 00 	movl   $0x140c80,(%esp)
  107566:	e8 a5 e7 ff ff       	call   105d10 <release>
      return -1;
  10756b:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  107572:	eb 38                	jmp    1075ac <sys_sleep+0x9c>
    }
    sleep(&ticks, &tickslock);
  107574:	c7 44 24 04 80 0c 14 	movl   $0x140c80,0x4(%esp)
  10757b:	00 
  10757c:	c7 04 24 c0 14 14 00 	movl   $0x1414c0,(%esp)
  107583:	e8 d8 de ff ff       	call   105460 <sleep>
  107588:	a1 c0 14 14 00       	mov    0x1414c0,%eax
  10758d:	89 c2                	mov    %eax,%edx
  10758f:	2b 55 fc             	sub    0xfffffffc(%ebp),%edx
  107592:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  107595:	39 c2                	cmp    %eax,%edx
  107597:	7c b3                	jl     10754c <sys_sleep+0x3c>
  }
  release(&tickslock);
  107599:	c7 04 24 80 0c 14 00 	movl   $0x140c80,(%esp)
  1075a0:	e8 6b e7 ff ff       	call   105d10 <release>
  return 0;
  1075a5:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  1075ac:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  1075af:	c9                   	leave  
  1075b0:	c3                   	ret    
  1075b1:	eb 0d                	jmp    1075c0 <sys_upmsec>
  1075b3:	90                   	nop    
  1075b4:	90                   	nop    
  1075b5:	90                   	nop    
  1075b6:	90                   	nop    
  1075b7:	90                   	nop    
  1075b8:	90                   	nop    
  1075b9:	90                   	nop    
  1075ba:	90                   	nop    
  1075bb:	90                   	nop    
  1075bc:	90                   	nop    
  1075bd:	90                   	nop    
  1075be:	90                   	nop    
  1075bf:	90                   	nop    

001075c0 <sys_upmsec>:

int
sys_upmsec(void)
{
  1075c0:	55                   	push   %ebp
  1075c1:	89 e5                	mov    %esp,%ebp
  1075c3:	83 ec 08             	sub    $0x8,%esp
    return millitime();
  1075c6:	e8 95 09 00 00       	call   107f60 <millitime>
}
  1075cb:	c9                   	leave  
  1075cc:	c3                   	ret    
  1075cd:	8d 76 00             	lea    0x0(%esi),%esi

001075d0 <sys_accept>:

int 
sys_accept(void)
{
  1075d0:	55                   	push   %ebp
  1075d1:	89 e5                	mov    %esp,%ebp
  1075d3:	83 ec 28             	sub    $0x28,%esp
    int s;
    struct sockaddr *addr;
    socklen_t *addrlen;
    if((argint(0, &s)<0) || 
  1075d6:	8d 45 fc             	lea    0xfffffffc(%ebp),%eax
  1075d9:	89 44 24 04          	mov    %eax,0x4(%esp)
  1075dd:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  1075e4:	e8 67 ec ff ff       	call   106250 <argint>
  1075e9:	85 c0                	test   %eax,%eax
  1075eb:	78 3e                	js     10762b <sys_accept+0x5b>
  1075ed:	8d 45 f8             	lea    0xfffffff8(%ebp),%eax
  1075f0:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
  1075f7:	00 
  1075f8:	89 44 24 04          	mov    %eax,0x4(%esp)
  1075fc:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  107603:	e8 98 ec ff ff       	call   1062a0 <argptr>
  107608:	85 c0                	test   %eax,%eax
  10760a:	78 1f                	js     10762b <sys_accept+0x5b>
  10760c:	8d 45 f4             	lea    0xfffffff4(%ebp),%eax
  10760f:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  107616:	00 
  107617:	89 44 24 04          	mov    %eax,0x4(%esp)
  10761b:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  107622:	e8 79 ec ff ff       	call   1062a0 <argptr>
  107627:	85 c0                	test   %eax,%eax
  107629:	79 09                	jns    107634 <sys_accept+0x64>
            (argptr(1, &addr, sizeof(struct sockaddr))<0) ||
            (argptr(2, &addrlen, sizeof(socklen_t))<0))
        return -1;
  10762b:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  107632:	eb 1c                	jmp    107650 <sys_accept+0x80>
    return lwip_accept(s, addr, addrlen);
  107634:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  107637:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  10763a:	8b 4d fc             	mov    0xfffffffc(%ebp),%ecx
  10763d:	89 44 24 08          	mov    %eax,0x8(%esp)
  107641:	89 54 24 04          	mov    %edx,0x4(%esp)
  107645:	89 0c 24             	mov    %ecx,(%esp)
  107648:	e8 23 0a 01 00       	call   118070 <lwip_accept>
  10764d:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  107650:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  107653:	c9                   	leave  
  107654:	c3                   	ret    
  107655:	8d 74 26 00          	lea    0x0(%esi),%esi
  107659:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00107660 <sys_bind>:

int 
sys_bind(void)
{
  107660:	55                   	push   %ebp
  107661:	89 e5                	mov    %esp,%ebp
  107663:	83 ec 28             	sub    $0x28,%esp
    int s;
    struct sockaddr *name;
    socklen_t *namelen;
    if((argint(0, &s)<0) || 
  107666:	8d 45 fc             	lea    0xfffffffc(%ebp),%eax
  107669:	89 44 24 04          	mov    %eax,0x4(%esp)
  10766d:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  107674:	e8 d7 eb ff ff       	call   106250 <argint>
  107679:	85 c0                	test   %eax,%eax
  10767b:	78 3e                	js     1076bb <sys_bind+0x5b>
  10767d:	8d 45 f8             	lea    0xfffffff8(%ebp),%eax
  107680:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
  107687:	00 
  107688:	89 44 24 04          	mov    %eax,0x4(%esp)
  10768c:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  107693:	e8 08 ec ff ff       	call   1062a0 <argptr>
  107698:	85 c0                	test   %eax,%eax
  10769a:	78 1f                	js     1076bb <sys_bind+0x5b>
  10769c:	8d 45 f4             	lea    0xfffffff4(%ebp),%eax
  10769f:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  1076a6:	00 
  1076a7:	89 44 24 04          	mov    %eax,0x4(%esp)
  1076ab:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  1076b2:	e8 e9 eb ff ff       	call   1062a0 <argptr>
  1076b7:	85 c0                	test   %eax,%eax
  1076b9:	79 09                	jns    1076c4 <sys_bind+0x64>
            (argptr(1, &name, sizeof(struct sockaddr))<0) ||
            (argptr(2, &namelen, sizeof(socklen_t))<0))
        return -1;
  1076bb:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  1076c2:	eb 1c                	jmp    1076e0 <sys_bind+0x80>
    return lwip_bind(s, name, namelen);
  1076c4:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  1076c7:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  1076ca:	8b 4d fc             	mov    0xfffffffc(%ebp),%ecx
  1076cd:	89 44 24 08          	mov    %eax,0x8(%esp)
  1076d1:	89 54 24 04          	mov    %edx,0x4(%esp)
  1076d5:	89 0c 24             	mov    %ecx,(%esp)
  1076d8:	e8 f3 0a 01 00       	call   1181d0 <lwip_bind>
  1076dd:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  1076e0:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  1076e3:	c9                   	leave  
  1076e4:	c3                   	ret    
  1076e5:	8d 74 26 00          	lea    0x0(%esi),%esi
  1076e9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

001076f0 <sys_shutdown>:

int 
sys_shutdown(void)
{
  1076f0:	55                   	push   %ebp
  1076f1:	89 e5                	mov    %esp,%ebp
  1076f3:	83 ec 28             	sub    $0x28,%esp
    int s;
    int how;
    if ((argint(0, &s)<0) || (argint(1, &how) < 0))
  1076f6:	8d 45 fc             	lea    0xfffffffc(%ebp),%eax
  1076f9:	89 44 24 04          	mov    %eax,0x4(%esp)
  1076fd:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  107704:	e8 47 eb ff ff       	call   106250 <argint>
  107709:	85 c0                	test   %eax,%eax
  10770b:	78 17                	js     107724 <sys_shutdown+0x34>
  10770d:	8d 45 f8             	lea    0xfffffff8(%ebp),%eax
  107710:	89 44 24 04          	mov    %eax,0x4(%esp)
  107714:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  10771b:	e8 30 eb ff ff       	call   106250 <argint>
  107720:	85 c0                	test   %eax,%eax
  107722:	79 09                	jns    10772d <sys_shutdown+0x3d>
        return -1;
  107724:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  10772b:	eb 15                	jmp    107742 <sys_shutdown+0x52>
    return lwip_shutdown(s, how);
  10772d:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  107730:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  107733:	89 44 24 04          	mov    %eax,0x4(%esp)
  107737:	89 14 24             	mov    %edx,(%esp)
  10773a:	e8 d1 1a 01 00       	call   119210 <lwip_shutdown>
  10773f:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  107742:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  107745:	c9                   	leave  
  107746:	c3                   	ret    
  107747:	89 f6                	mov    %esi,%esi
  107749:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00107750 <sys_getsockopt>:

int 
sys_getsockopt(void)
{
  107750:	55                   	push   %ebp
  107751:	89 e5                	mov    %esp,%ebp
  107753:	56                   	push   %esi
  107754:	53                   	push   %ebx
  107755:	83 ec 40             	sub    $0x40,%esp
    int s;
    int level;
    int optname;
    void *optval;
    socklen_t *optlen;
    if ((argint(0, &s)<0) ||
  107758:	8d 45 f4             	lea    0xfffffff4(%ebp),%eax
  10775b:	89 44 24 04          	mov    %eax,0x4(%esp)
  10775f:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  107766:	e8 e5 ea ff ff       	call   106250 <argint>
  10776b:	85 c0                	test   %eax,%eax
  10776d:	78 6c                	js     1077db <sys_getsockopt+0x8b>
  10776f:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
  107772:	89 44 24 04          	mov    %eax,0x4(%esp)
  107776:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  10777d:	e8 ce ea ff ff       	call   106250 <argint>
  107782:	85 c0                	test   %eax,%eax
  107784:	78 55                	js     1077db <sys_getsockopt+0x8b>
  107786:	8d 45 ec             	lea    0xffffffec(%ebp),%eax
  107789:	89 44 24 04          	mov    %eax,0x4(%esp)
  10778d:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  107794:	e8 b7 ea ff ff       	call   106250 <argint>
  107799:	85 c0                	test   %eax,%eax
  10779b:	78 3e                	js     1077db <sys_getsockopt+0x8b>
  10779d:	8d 45 e4             	lea    0xffffffe4(%ebp),%eax
  1077a0:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  1077a7:	00 
  1077a8:	89 44 24 04          	mov    %eax,0x4(%esp)
  1077ac:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  1077b3:	e8 e8 ea ff ff       	call   1062a0 <argptr>
  1077b8:	85 c0                	test   %eax,%eax
  1077ba:	78 1f                	js     1077db <sys_getsockopt+0x8b>
  1077bc:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
  1077bf:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  1077c6:	00 
  1077c7:	89 44 24 04          	mov    %eax,0x4(%esp)
  1077cb:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  1077d2:	e8 c9 ea ff ff       	call   1062a0 <argptr>
  1077d7:	85 c0                	test   %eax,%eax
  1077d9:	79 09                	jns    1077e4 <sys_getsockopt+0x94>
        (argint(1, &level)<0) ||
        (argint(2, &optname)<0) ||
        (argptr(4, &optlen, sizeof(socklen_t))<0) ||
        (argptr(3, &optval, 0)<0))
        return -1;
  1077db:	c7 45 d4 ff ff ff ff 	movl   $0xffffffff,0xffffffd4(%ebp)
  1077e2:	eb 2a                	jmp    10780e <sys_getsockopt+0xbe>
    return lwip_getsockopt(s, level, optname, optval, optlen);
  1077e4:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
  1077e7:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
  1077ea:	8b 4d ec             	mov    0xffffffec(%ebp),%ecx
  1077ed:	8b 5d f0             	mov    0xfffffff0(%ebp),%ebx
  1077f0:	8b 75 f4             	mov    0xfffffff4(%ebp),%esi
  1077f3:	89 44 24 10          	mov    %eax,0x10(%esp)
  1077f7:	89 54 24 0c          	mov    %edx,0xc(%esp)
  1077fb:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  1077ff:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  107803:	89 34 24             	mov    %esi,(%esp)
  107806:	e8 c5 1b 01 00       	call   1193d0 <lwip_getsockopt>
  10780b:	89 45 d4             	mov    %eax,0xffffffd4(%ebp)
  10780e:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
}
  107811:	83 c4 40             	add    $0x40,%esp
  107814:	5b                   	pop    %ebx
  107815:	5e                   	pop    %esi
  107816:	5d                   	pop    %ebp
  107817:	c3                   	ret    
  107818:	90                   	nop    
  107819:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

00107820 <sys_setsockopt>:

int sys_setsockopt(void)
{
  107820:	55                   	push   %ebp
  107821:	89 e5                	mov    %esp,%ebp
  107823:	56                   	push   %esi
  107824:	53                   	push   %ebx
  107825:	83 ec 40             	sub    $0x40,%esp
    int s;
    int level;
    int optname;
    void *optval;
    socklen_t *optlen;
    if ((argint(0, &s)<0) ||
  107828:	8d 45 f4             	lea    0xfffffff4(%ebp),%eax
  10782b:	89 44 24 04          	mov    %eax,0x4(%esp)
  10782f:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  107836:	e8 15 ea ff ff       	call   106250 <argint>
  10783b:	85 c0                	test   %eax,%eax
  10783d:	78 6d                	js     1078ac <sys_setsockopt+0x8c>
  10783f:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
  107842:	89 44 24 04          	mov    %eax,0x4(%esp)
  107846:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  10784d:	e8 fe e9 ff ff       	call   106250 <argint>
  107852:	85 c0                	test   %eax,%eax
  107854:	78 56                	js     1078ac <sys_setsockopt+0x8c>
  107856:	8d 45 ec             	lea    0xffffffec(%ebp),%eax
  107859:	89 44 24 04          	mov    %eax,0x4(%esp)
  10785d:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  107864:	e8 e7 e9 ff ff       	call   106250 <argint>
  107869:	85 c0                	test   %eax,%eax
  10786b:	78 3f                	js     1078ac <sys_setsockopt+0x8c>
  10786d:	8d 45 e4             	lea    0xffffffe4(%ebp),%eax
  107870:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  107877:	00 
  107878:	89 44 24 04          	mov    %eax,0x4(%esp)
  10787c:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  107883:	e8 18 ea ff ff       	call   1062a0 <argptr>
  107888:	85 c0                	test   %eax,%eax
  10788a:	78 20                	js     1078ac <sys_setsockopt+0x8c>
  10788c:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
  10788f:	8b 00                	mov    (%eax),%eax
  107891:	8d 55 e8             	lea    0xffffffe8(%ebp),%edx
  107894:	89 44 24 08          	mov    %eax,0x8(%esp)
  107898:	89 54 24 04          	mov    %edx,0x4(%esp)
  10789c:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  1078a3:	e8 f8 e9 ff ff       	call   1062a0 <argptr>
  1078a8:	85 c0                	test   %eax,%eax
  1078aa:	79 09                	jns    1078b5 <sys_setsockopt+0x95>
        (argint(1, &level)<0) ||
        (argint(2, &optname)<0) ||
        (argptr(4, &optlen, sizeof(socklen_t))<0) ||
        (argptr(3, &optval, *optlen)<0))
        return -1;
  1078ac:	c7 45 d4 ff ff ff ff 	movl   $0xffffffff,0xffffffd4(%ebp)
  1078b3:	eb 2a                	jmp    1078df <sys_setsockopt+0xbf>
    return lwip_setsockopt(s, level, optname, optval, optlen);
  1078b5:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
  1078b8:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
  1078bb:	8b 4d ec             	mov    0xffffffec(%ebp),%ecx
  1078be:	8b 5d f0             	mov    0xfffffff0(%ebp),%ebx
  1078c1:	8b 75 f4             	mov    0xfffffff4(%ebp),%esi
  1078c4:	89 44 24 10          	mov    %eax,0x10(%esp)
  1078c8:	89 54 24 0c          	mov    %edx,0xc(%esp)
  1078cc:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  1078d0:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  1078d4:	89 34 24             	mov    %esi,(%esp)
  1078d7:	e8 14 1e 01 00       	call   1196f0 <lwip_setsockopt>
  1078dc:	89 45 d4             	mov    %eax,0xffffffd4(%ebp)
  1078df:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
}
  1078e2:	83 c4 40             	add    $0x40,%esp
  1078e5:	5b                   	pop    %ebx
  1078e6:	5e                   	pop    %esi
  1078e7:	5d                   	pop    %ebp
  1078e8:	c3                   	ret    
  1078e9:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

001078f0 <sys_sockclose>:

int sys_sockclose(void)
{
  1078f0:	55                   	push   %ebp
  1078f1:	89 e5                	mov    %esp,%ebp
  1078f3:	83 ec 28             	sub    $0x28,%esp
    int s;
    if (argint(0, &s) <0)
  1078f6:	8d 45 fc             	lea    0xfffffffc(%ebp),%eax
  1078f9:	89 44 24 04          	mov    %eax,0x4(%esp)
  1078fd:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  107904:	e8 47 e9 ff ff       	call   106250 <argint>
  107909:	85 c0                	test   %eax,%eax
  10790b:	79 09                	jns    107916 <sys_sockclose+0x26>
        return -1;
  10790d:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  107914:	eb 0e                	jmp    107924 <sys_sockclose+0x34>
    return lwip_close(s);
  107916:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  107919:	89 04 24             	mov    %eax,(%esp)
  10791c:	e8 6f 09 01 00       	call   118290 <lwip_close>
  107921:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  107924:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  107927:	c9                   	leave  
  107928:	c3                   	ret    
  107929:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

00107930 <sys_connect>:

int sys_connect(void)
{
  107930:	55                   	push   %ebp
  107931:	89 e5                	mov    %esp,%ebp
  107933:	83 ec 28             	sub    $0x28,%esp
    int s;
    struct sockaddr *name;
    socklen_t *namelen;
    if((argint(0, &s)<0) || 
  107936:	8d 45 fc             	lea    0xfffffffc(%ebp),%eax
  107939:	89 44 24 04          	mov    %eax,0x4(%esp)
  10793d:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  107944:	e8 07 e9 ff ff       	call   106250 <argint>
  107949:	85 c0                	test   %eax,%eax
  10794b:	78 3e                	js     10798b <sys_connect+0x5b>
  10794d:	8d 45 f8             	lea    0xfffffff8(%ebp),%eax
  107950:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
  107957:	00 
  107958:	89 44 24 04          	mov    %eax,0x4(%esp)
  10795c:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  107963:	e8 38 e9 ff ff       	call   1062a0 <argptr>
  107968:	85 c0                	test   %eax,%eax
  10796a:	78 1f                	js     10798b <sys_connect+0x5b>
  10796c:	8d 45 f4             	lea    0xfffffff4(%ebp),%eax
  10796f:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  107976:	00 
  107977:	89 44 24 04          	mov    %eax,0x4(%esp)
  10797b:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  107982:	e8 19 e9 ff ff       	call   1062a0 <argptr>
  107987:	85 c0                	test   %eax,%eax
  107989:	79 09                	jns    107994 <sys_connect+0x64>
            (argptr(1, &name, sizeof(struct sockaddr))<0) ||
            (argptr(2, &namelen, sizeof(socklen_t))<0))
        return -1;
  10798b:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  107992:	eb 1c                	jmp    1079b0 <sys_connect+0x80>
    return lwip_connect(s, name, namelen);
  107994:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  107997:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  10799a:	8b 4d fc             	mov    0xfffffffc(%ebp),%ecx
  10799d:	89 44 24 08          	mov    %eax,0x8(%esp)
  1079a1:	89 54 24 04          	mov    %edx,0x4(%esp)
  1079a5:	89 0c 24             	mov    %ecx,(%esp)
  1079a8:	e8 a3 09 01 00       	call   118350 <lwip_connect>
  1079ad:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  1079b0:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  1079b3:	c9                   	leave  
  1079b4:	c3                   	ret    
  1079b5:	8d 74 26 00          	lea    0x0(%esi),%esi
  1079b9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

001079c0 <sys_listen>:

int sys_listen(void)
{
  1079c0:	55                   	push   %ebp
  1079c1:	89 e5                	mov    %esp,%ebp
  1079c3:	83 ec 28             	sub    $0x28,%esp
    int s;
    int backlog;
    if ((argint(0, &s)<0) ||
  1079c6:	8d 45 fc             	lea    0xfffffffc(%ebp),%eax
  1079c9:	89 44 24 04          	mov    %eax,0x4(%esp)
  1079cd:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  1079d4:	e8 77 e8 ff ff       	call   106250 <argint>
  1079d9:	85 c0                	test   %eax,%eax
  1079db:	78 17                	js     1079f4 <sys_listen+0x34>
  1079dd:	8d 45 f8             	lea    0xfffffff8(%ebp),%eax
  1079e0:	89 44 24 04          	mov    %eax,0x4(%esp)
  1079e4:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  1079eb:	e8 60 e8 ff ff       	call   106250 <argint>
  1079f0:	85 c0                	test   %eax,%eax
  1079f2:	79 09                	jns    1079fd <sys_listen+0x3d>
        (argint(1, &backlog)<0))
        return -1;
  1079f4:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  1079fb:	eb 15                	jmp    107a12 <sys_listen+0x52>
    return lwip_listen(s, backlog);
  1079fd:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  107a00:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  107a03:	89 44 24 04          	mov    %eax,0x4(%esp)
  107a07:	89 14 24             	mov    %edx,(%esp)
  107a0a:	e8 11 0a 01 00       	call   118420 <lwip_listen>
  107a0f:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  107a12:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  107a15:	c9                   	leave  
  107a16:	c3                   	ret    
  107a17:	89 f6                	mov    %esi,%esi
  107a19:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00107a20 <sys_recv>:

int sys_recv(void)
{
  107a20:	55                   	push   %ebp
  107a21:	89 e5                	mov    %esp,%ebp
  107a23:	53                   	push   %ebx
  107a24:	83 ec 24             	sub    $0x24,%esp
    int s;
    void *mem;
    int len;
    unsigned int flags;
    if ((argint(0, &s)<0) ||
  107a27:	8d 45 f8             	lea    0xfffffff8(%ebp),%eax
  107a2a:	89 44 24 04          	mov    %eax,0x4(%esp)
  107a2e:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  107a35:	e8 16 e8 ff ff       	call   106250 <argint>
  107a3a:	85 c0                	test   %eax,%eax
  107a3c:	78 4c                	js     107a8a <sys_recv+0x6a>
  107a3e:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
  107a41:	89 44 24 04          	mov    %eax,0x4(%esp)
  107a45:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  107a4c:	e8 ff e7 ff ff       	call   106250 <argint>
  107a51:	85 c0                	test   %eax,%eax
  107a53:	78 35                	js     107a8a <sys_recv+0x6a>
  107a55:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  107a58:	8d 55 f4             	lea    0xfffffff4(%ebp),%edx
  107a5b:	89 44 24 08          	mov    %eax,0x8(%esp)
  107a5f:	89 54 24 04          	mov    %edx,0x4(%esp)
  107a63:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  107a6a:	e8 31 e8 ff ff       	call   1062a0 <argptr>
  107a6f:	85 c0                	test   %eax,%eax
  107a71:	78 17                	js     107a8a <sys_recv+0x6a>
  107a73:	8d 45 ec             	lea    0xffffffec(%ebp),%eax
  107a76:	89 44 24 04          	mov    %eax,0x4(%esp)
  107a7a:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  107a81:	e8 ca e7 ff ff       	call   106250 <argint>
  107a86:	85 c0                	test   %eax,%eax
  107a88:	79 09                	jns    107a93 <sys_recv+0x73>
        (argint(2, &len)<0) ||
        (argptr(1, &mem, len)<0) ||
        (argint(3, &flags)<0))
        return -1;
  107a8a:	c7 45 e8 ff ff ff ff 	movl   $0xffffffff,0xffffffe8(%ebp)
  107a91:	eb 23                	jmp    107ab6 <sys_recv+0x96>
    return lwip_recv(s, mem, len, flags);
  107a93:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  107a96:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
  107a99:	8b 4d f4             	mov    0xfffffff4(%ebp),%ecx
  107a9c:	8b 5d f8             	mov    0xfffffff8(%ebp),%ebx
  107a9f:	89 44 24 0c          	mov    %eax,0xc(%esp)
  107aa3:	89 54 24 08          	mov    %edx,0x8(%esp)
  107aa7:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  107aab:	89 1c 24             	mov    %ebx,(%esp)
  107aae:	e8 4d 0c 01 00       	call   118700 <lwip_recv>
  107ab3:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
  107ab6:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
}
  107ab9:	83 c4 24             	add    $0x24,%esp
  107abc:	5b                   	pop    %ebx
  107abd:	5d                   	pop    %ebp
  107abe:	c3                   	ret    
  107abf:	90                   	nop    

00107ac0 <sys_recvfrom>:

int sys_recvfrom(void)
{
  107ac0:	55                   	push   %ebp
  107ac1:	89 e5                	mov    %esp,%ebp
  107ac3:	57                   	push   %edi
  107ac4:	56                   	push   %esi
  107ac5:	53                   	push   %ebx
  107ac6:	83 ec 3c             	sub    $0x3c,%esp
    int s;
    void *mem;
    int len;
    unsigned int flags;
    struct sockaddr *from;
    socklen_t *fromlen;
    if ((argint(0, &s)<0) ||
  107ac9:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
  107acc:	89 44 24 04          	mov    %eax,0x4(%esp)
  107ad0:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  107ad7:	e8 74 e7 ff ff       	call   106250 <argint>
  107adc:	85 c0                	test   %eax,%eax
  107ade:	0f 88 8a 00 00 00    	js     107b6e <sys_recvfrom+0xae>
  107ae4:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
  107ae7:	89 44 24 04          	mov    %eax,0x4(%esp)
  107aeb:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  107af2:	e8 59 e7 ff ff       	call   106250 <argint>
  107af7:	85 c0                	test   %eax,%eax
  107af9:	78 73                	js     107b6e <sys_recvfrom+0xae>
  107afb:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  107afe:	8d 55 ec             	lea    0xffffffec(%ebp),%edx
  107b01:	89 44 24 08          	mov    %eax,0x8(%esp)
  107b05:	89 54 24 04          	mov    %edx,0x4(%esp)
  107b09:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  107b10:	e8 8b e7 ff ff       	call   1062a0 <argptr>
  107b15:	85 c0                	test   %eax,%eax
  107b17:	78 55                	js     107b6e <sys_recvfrom+0xae>
  107b19:	8d 45 e4             	lea    0xffffffe4(%ebp),%eax
  107b1c:	89 44 24 04          	mov    %eax,0x4(%esp)
  107b20:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  107b27:	e8 24 e7 ff ff       	call   106250 <argint>
  107b2c:	85 c0                	test   %eax,%eax
  107b2e:	78 3e                	js     107b6e <sys_recvfrom+0xae>
  107b30:	8d 45 e0             	lea    0xffffffe0(%ebp),%eax
  107b33:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  107b3a:	00 
  107b3b:	89 44 24 04          	mov    %eax,0x4(%esp)
  107b3f:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  107b46:	e8 55 e7 ff ff       	call   1062a0 <argptr>
  107b4b:	85 c0                	test   %eax,%eax
  107b4d:	78 1f                	js     107b6e <sys_recvfrom+0xae>
  107b4f:	8d 45 dc             	lea    0xffffffdc(%ebp),%eax
  107b52:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  107b59:	00 
  107b5a:	89 44 24 04          	mov    %eax,0x4(%esp)
  107b5e:	c7 04 24 05 00 00 00 	movl   $0x5,(%esp)
  107b65:	e8 36 e7 ff ff       	call   1062a0 <argptr>
  107b6a:	85 c0                	test   %eax,%eax
  107b6c:	79 09                	jns    107b77 <sys_recvfrom+0xb7>
        (argint(2, &len)<0) ||
        (argptr(1, &mem, len)<0) ||
        (argint(3, &flags)<0) ||
        (argptr(4, &from, 0)<0) ||
        (argptr(5, &fromlen, sizeof(socklen_t))<0))
        return -1;
  107b6e:	c7 45 d0 ff ff ff ff 	movl   $0xffffffff,0xffffffd0(%ebp)
  107b75:	eb 31                	jmp    107ba8 <sys_recvfrom+0xe8>
    return lwip_recvfrom(s, mem, len, flags, from, fromlen);
  107b77:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  107b7a:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
  107b7d:	8b 4d e4             	mov    0xffffffe4(%ebp),%ecx
  107b80:	8b 5d e8             	mov    0xffffffe8(%ebp),%ebx
  107b83:	8b 75 ec             	mov    0xffffffec(%ebp),%esi
  107b86:	8b 7d f0             	mov    0xfffffff0(%ebp),%edi
  107b89:	89 44 24 14          	mov    %eax,0x14(%esp)
  107b8d:	89 54 24 10          	mov    %edx,0x10(%esp)
  107b91:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
  107b95:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  107b99:	89 74 24 04          	mov    %esi,0x4(%esp)
  107b9d:	89 3c 24             	mov    %edi,(%esp)
  107ba0:	e8 0b 09 01 00       	call   1184b0 <lwip_recvfrom>
  107ba5:	89 45 d0             	mov    %eax,0xffffffd0(%ebp)
  107ba8:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
}
  107bab:	83 c4 3c             	add    $0x3c,%esp
  107bae:	5b                   	pop    %ebx
  107baf:	5e                   	pop    %esi
  107bb0:	5f                   	pop    %edi
  107bb1:	5d                   	pop    %ebp
  107bb2:	c3                   	ret    
  107bb3:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  107bb9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00107bc0 <sys_send>:

int sys_send(void)
{
  107bc0:	55                   	push   %ebp
  107bc1:	89 e5                	mov    %esp,%ebp
  107bc3:	53                   	push   %ebx
  107bc4:	83 ec 24             	sub    $0x24,%esp
    int s;
    void *dataptr;
    int size;
    unsigned int flags;
    if ((argint(0, &s)<0) ||
  107bc7:	8d 45 f8             	lea    0xfffffff8(%ebp),%eax
  107bca:	89 44 24 04          	mov    %eax,0x4(%esp)
  107bce:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  107bd5:	e8 76 e6 ff ff       	call   106250 <argint>
  107bda:	85 c0                	test   %eax,%eax
  107bdc:	78 4c                	js     107c2a <sys_send+0x6a>
  107bde:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
  107be1:	89 44 24 04          	mov    %eax,0x4(%esp)
  107be5:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  107bec:	e8 5f e6 ff ff       	call   106250 <argint>
  107bf1:	85 c0                	test   %eax,%eax
  107bf3:	78 35                	js     107c2a <sys_send+0x6a>
  107bf5:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  107bf8:	8d 55 f4             	lea    0xfffffff4(%ebp),%edx
  107bfb:	89 44 24 08          	mov    %eax,0x8(%esp)
  107bff:	89 54 24 04          	mov    %edx,0x4(%esp)
  107c03:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  107c0a:	e8 91 e6 ff ff       	call   1062a0 <argptr>
  107c0f:	85 c0                	test   %eax,%eax
  107c11:	78 17                	js     107c2a <sys_send+0x6a>
  107c13:	8d 45 ec             	lea    0xffffffec(%ebp),%eax
  107c16:	89 44 24 04          	mov    %eax,0x4(%esp)
  107c1a:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  107c21:	e8 2a e6 ff ff       	call   106250 <argint>
  107c26:	85 c0                	test   %eax,%eax
  107c28:	79 09                	jns    107c33 <sys_send+0x73>
        (argint(2, &size)<0) ||
        (argptr(1, &dataptr, size)<0) ||
        (argint(3, &flags)<0))
        return -1;
  107c2a:	c7 45 e8 ff ff ff ff 	movl   $0xffffffff,0xffffffe8(%ebp)
  107c31:	eb 23                	jmp    107c56 <sys_send+0x96>
    return lwip_send(s, dataptr, size, flags);
  107c33:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  107c36:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
  107c39:	8b 4d f4             	mov    0xfffffff4(%ebp),%ecx
  107c3c:	8b 5d f8             	mov    0xfffffff8(%ebp),%ebx
  107c3f:	89 44 24 0c          	mov    %eax,0xc(%esp)
  107c43:	89 54 24 08          	mov    %edx,0x8(%esp)
  107c47:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  107c4b:	89 1c 24             	mov    %ebx,(%esp)
  107c4e:	e8 ed 0a 01 00       	call   118740 <lwip_send>
  107c53:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
  107c56:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
}
  107c59:	83 c4 24             	add    $0x24,%esp
  107c5c:	5b                   	pop    %ebx
  107c5d:	5d                   	pop    %ebp
  107c5e:	c3                   	ret    
  107c5f:	90                   	nop    

00107c60 <sys_sendto>:

int sys_sendto(void)
{
  107c60:	55                   	push   %ebp
  107c61:	89 e5                	mov    %esp,%ebp
  107c63:	53                   	push   %ebx
  107c64:	83 ec 34             	sub    $0x34,%esp
    int s;
    void *dataptr;
    int size;
    unsigned int flags;
    struct sockaddr *to;
    socklen_t *tolen;
    if ((argint(0, &s)<0) ||
  107c67:	8d 45 f8             	lea    0xfffffff8(%ebp),%eax
  107c6a:	89 44 24 04          	mov    %eax,0x4(%esp)
  107c6e:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  107c75:	e8 d6 e5 ff ff       	call   106250 <argint>
  107c7a:	85 c0                	test   %eax,%eax
  107c7c:	0f 88 8b 00 00 00    	js     107d0d <sys_sendto+0xad>
  107c82:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
  107c85:	89 44 24 04          	mov    %eax,0x4(%esp)
  107c89:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  107c90:	e8 bb e5 ff ff       	call   106250 <argint>
  107c95:	85 c0                	test   %eax,%eax
  107c97:	78 74                	js     107d0d <sys_sendto+0xad>
  107c99:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  107c9c:	8d 55 f4             	lea    0xfffffff4(%ebp),%edx
  107c9f:	89 44 24 08          	mov    %eax,0x8(%esp)
  107ca3:	89 54 24 04          	mov    %edx,0x4(%esp)
  107ca7:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  107cae:	e8 ed e5 ff ff       	call   1062a0 <argptr>
  107cb3:	85 c0                	test   %eax,%eax
  107cb5:	78 56                	js     107d0d <sys_sendto+0xad>
  107cb7:	8d 45 ec             	lea    0xffffffec(%ebp),%eax
  107cba:	89 44 24 04          	mov    %eax,0x4(%esp)
  107cbe:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  107cc5:	e8 86 e5 ff ff       	call   106250 <argint>
  107cca:	85 c0                	test   %eax,%eax
  107ccc:	78 3f                	js     107d0d <sys_sendto+0xad>
  107cce:	8d 45 e4             	lea    0xffffffe4(%ebp),%eax
  107cd1:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  107cd8:	00 
  107cd9:	89 44 24 04          	mov    %eax,0x4(%esp)
  107cdd:	c7 04 24 05 00 00 00 	movl   $0x5,(%esp)
  107ce4:	e8 b7 e5 ff ff       	call   1062a0 <argptr>
  107ce9:	85 c0                	test   %eax,%eax
  107ceb:	78 20                	js     107d0d <sys_sendto+0xad>
  107ced:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
  107cf0:	8b 00                	mov    (%eax),%eax
  107cf2:	8d 55 e8             	lea    0xffffffe8(%ebp),%edx
  107cf5:	89 44 24 08          	mov    %eax,0x8(%esp)
  107cf9:	89 54 24 04          	mov    %edx,0x4(%esp)
  107cfd:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  107d04:	e8 97 e5 ff ff       	call   1062a0 <argptr>
  107d09:	85 c0                	test   %eax,%eax
  107d0b:	79 09                	jns    107d16 <sys_sendto+0xb6>
        (argint(2, &size)<0) ||
        (argptr(1, &dataptr, size)<0) ||
        (argint(3, &flags)<0) ||
        (argptr(5, &tolen, sizeof(socklen_t))<0) ||
        (argptr(4, &to, *tolen)<0))
        return -1;
  107d0d:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,0xffffffd8(%ebp)
  107d14:	eb 23                	jmp    107d39 <sys_sendto+0xd9>
    return lwip_send(s, dataptr, size, flags);
  107d16:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  107d19:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
  107d1c:	8b 4d f4             	mov    0xfffffff4(%ebp),%ecx
  107d1f:	8b 5d f8             	mov    0xfffffff8(%ebp),%ebx
  107d22:	89 44 24 0c          	mov    %eax,0xc(%esp)
  107d26:	89 54 24 08          	mov    %edx,0x8(%esp)
  107d2a:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  107d2e:	89 1c 24             	mov    %ebx,(%esp)
  107d31:	e8 0a 0a 01 00       	call   118740 <lwip_send>
  107d36:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
  107d39:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
}
  107d3c:	83 c4 34             	add    $0x34,%esp
  107d3f:	5b                   	pop    %ebx
  107d40:	5d                   	pop    %ebp
  107d41:	c3                   	ret    
  107d42:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi
  107d49:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00107d50 <sys_socket>:

int sys_socket(void)
{
  107d50:	55                   	push   %ebp
  107d51:	89 e5                	mov    %esp,%ebp
  107d53:	83 ec 28             	sub    $0x28,%esp
    int domain;
    int type;
    int protocol;
    if ((argint(0, &domain)<0) ||
  107d56:	8d 45 fc             	lea    0xfffffffc(%ebp),%eax
  107d59:	89 44 24 04          	mov    %eax,0x4(%esp)
  107d5d:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  107d64:	e8 e7 e4 ff ff       	call   106250 <argint>
  107d69:	85 c0                	test   %eax,%eax
  107d6b:	78 2e                	js     107d9b <sys_socket+0x4b>
  107d6d:	8d 45 f8             	lea    0xfffffff8(%ebp),%eax
  107d70:	89 44 24 04          	mov    %eax,0x4(%esp)
  107d74:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  107d7b:	e8 d0 e4 ff ff       	call   106250 <argint>
  107d80:	85 c0                	test   %eax,%eax
  107d82:	78 17                	js     107d9b <sys_socket+0x4b>
  107d84:	8d 45 f4             	lea    0xfffffff4(%ebp),%eax
  107d87:	89 44 24 04          	mov    %eax,0x4(%esp)
  107d8b:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  107d92:	e8 b9 e4 ff ff       	call   106250 <argint>
  107d97:	85 c0                	test   %eax,%eax
  107d99:	79 09                	jns    107da4 <sys_socket+0x54>
        (argint(1, &type)<0) ||
        (argint(2, &protocol)<0))
        return -1;
  107d9b:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  107da2:	eb 1c                	jmp    107dc0 <sys_socket+0x70>
    return lwip_socket(domain, type, protocol);
  107da4:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  107da7:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  107daa:	8b 4d fc             	mov    0xfffffffc(%ebp),%ecx
  107dad:	89 44 24 08          	mov    %eax,0x8(%esp)
  107db1:	89 54 24 04          	mov    %edx,0x4(%esp)
  107db5:	89 0c 24             	mov    %ecx,(%esp)
  107db8:	e8 a3 0b 01 00       	call   118960 <lwip_socket>
  107dbd:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  107dc0:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  107dc3:	c9                   	leave  
  107dc4:	c3                   	ret    
  107dc5:	8d 74 26 00          	lea    0x0(%esi),%esi
  107dc9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00107dd0 <sys_getpeername>:

int
sys_getpeername(void)
{
  107dd0:	55                   	push   %ebp
  107dd1:	89 e5                	mov    %esp,%ebp
  107dd3:	83 ec 28             	sub    $0x28,%esp
    int s;
    struct sockaddr *name;
    socklen_t *namelen;
    if((argint(0, &s)<0) || 
  107dd6:	8d 45 fc             	lea    0xfffffffc(%ebp),%eax
  107dd9:	89 44 24 04          	mov    %eax,0x4(%esp)
  107ddd:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  107de4:	e8 67 e4 ff ff       	call   106250 <argint>
  107de9:	85 c0                	test   %eax,%eax
  107deb:	78 3e                	js     107e2b <sys_getpeername+0x5b>
  107ded:	8d 45 f8             	lea    0xfffffff8(%ebp),%eax
  107df0:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
  107df7:	00 
  107df8:	89 44 24 04          	mov    %eax,0x4(%esp)
  107dfc:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  107e03:	e8 98 e4 ff ff       	call   1062a0 <argptr>
  107e08:	85 c0                	test   %eax,%eax
  107e0a:	78 1f                	js     107e2b <sys_getpeername+0x5b>
  107e0c:	8d 45 f4             	lea    0xfffffff4(%ebp),%eax
  107e0f:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  107e16:	00 
  107e17:	89 44 24 04          	mov    %eax,0x4(%esp)
  107e1b:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  107e22:	e8 79 e4 ff ff       	call   1062a0 <argptr>
  107e27:	85 c0                	test   %eax,%eax
  107e29:	79 09                	jns    107e34 <sys_getpeername+0x64>
            (argptr(1, &name, sizeof(struct sockaddr))<0) ||
            (argptr(2, &namelen, sizeof(socklen_t))<0))
        return -1;
  107e2b:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  107e32:	eb 1c                	jmp    107e50 <sys_getpeername+0x80>
    return lwip_getpeername(s, name, namelen);
  107e34:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  107e37:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  107e3a:	8b 4d fc             	mov    0xfffffffc(%ebp),%ecx
  107e3d:	89 44 24 08          	mov    %eax,0x8(%esp)
  107e41:	89 54 24 04          	mov    %edx,0x4(%esp)
  107e45:	89 0c 24             	mov    %ecx,(%esp)
  107e48:	e8 e3 13 01 00       	call   119230 <lwip_getpeername>
  107e4d:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  107e50:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  107e53:	c9                   	leave  
  107e54:	c3                   	ret    
  107e55:	8d 74 26 00          	lea    0x0(%esi),%esi
  107e59:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00107e60 <sys_getsockname>:

int
sys_getsockname(void)
{
  107e60:	55                   	push   %ebp
  107e61:	89 e5                	mov    %esp,%ebp
  107e63:	83 ec 28             	sub    $0x28,%esp
    int s;
    struct sockaddr *name;
    socklen_t *namelen;
    if((argint(0, &s)<0) || 
  107e66:	8d 45 fc             	lea    0xfffffffc(%ebp),%eax
  107e69:	89 44 24 04          	mov    %eax,0x4(%esp)
  107e6d:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  107e74:	e8 d7 e3 ff ff       	call   106250 <argint>
  107e79:	85 c0                	test   %eax,%eax
  107e7b:	78 3e                	js     107ebb <sys_getsockname+0x5b>
  107e7d:	8d 45 f8             	lea    0xfffffff8(%ebp),%eax
  107e80:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
  107e87:	00 
  107e88:	89 44 24 04          	mov    %eax,0x4(%esp)
  107e8c:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  107e93:	e8 08 e4 ff ff       	call   1062a0 <argptr>
  107e98:	85 c0                	test   %eax,%eax
  107e9a:	78 1f                	js     107ebb <sys_getsockname+0x5b>
  107e9c:	8d 45 f4             	lea    0xfffffff4(%ebp),%eax
  107e9f:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  107ea6:	00 
  107ea7:	89 44 24 04          	mov    %eax,0x4(%esp)
  107eab:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  107eb2:	e8 e9 e3 ff ff       	call   1062a0 <argptr>
  107eb7:	85 c0                	test   %eax,%eax
  107eb9:	79 09                	jns    107ec4 <sys_getsockname+0x64>
            (argptr(1, &name, sizeof(struct sockaddr))<0) ||
            (argptr(2, &namelen, sizeof(socklen_t))<0))
        return -1;
  107ebb:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  107ec2:	eb 1c                	jmp    107ee0 <sys_getsockname+0x80>
    return lwip_getsockname(s, name, namelen);
  107ec4:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  107ec7:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  107eca:	8b 4d fc             	mov    0xfffffffc(%ebp),%ecx
  107ecd:	89 44 24 08          	mov    %eax,0x8(%esp)
  107ed1:	89 54 24 04          	mov    %edx,0x4(%esp)
  107ed5:	89 0c 24             	mov    %ecx,(%esp)
  107ed8:	e8 23 14 01 00       	call   119300 <lwip_getsockname>
  107edd:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  107ee0:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  107ee3:	c9                   	leave  
  107ee4:	c3                   	ret    
  107ee5:	90                   	nop    
  107ee6:	90                   	nop    
  107ee7:	90                   	nop    
  107ee8:	90                   	nop    
  107ee9:	90                   	nop    
  107eea:	90                   	nop    
  107eeb:	90                   	nop    
  107eec:	90                   	nop    
  107eed:	90                   	nop    
  107eee:	90                   	nop    
  107eef:	90                   	nop    

00107ef0 <timer_init>:
#define TIMER_16BIT     0x30    // r/w counter 16 bits, LSB first

void
timer_init(void)
{
  107ef0:	55                   	push   %ebp
  107ef1:	89 e5                	mov    %esp,%ebp
  107ef3:	83 ec 08             	sub    $0x8,%esp
  // Interrupt 100 times/sec.
  outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
  107ef6:	c7 44 24 04 34 00 00 	movl   $0x34,0x4(%esp)
  107efd:	00 
  107efe:	c7 04 24 43 00 00 00 	movl   $0x43,(%esp)
  107f05:	e8 36 00 00 00       	call   107f40 <outb>
  outb(IO_TIMER1, TIMER_DIV(100) % 256);
  107f0a:	c7 44 24 04 9c 00 00 	movl   $0x9c,0x4(%esp)
  107f11:	00 
  107f12:	c7 04 24 40 00 00 00 	movl   $0x40,(%esp)
  107f19:	e8 22 00 00 00       	call   107f40 <outb>
  outb(IO_TIMER1, TIMER_DIV(100) / 256);
  107f1e:	c7 44 24 04 2e 00 00 	movl   $0x2e,0x4(%esp)
  107f25:	00 
  107f26:	c7 04 24 40 00 00 00 	movl   $0x40,(%esp)
  107f2d:	e8 0e 00 00 00       	call   107f40 <outb>
  pic_enable(IRQ_TIMER);
  107f32:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  107f39:	e8 b2 c2 ff ff       	call   1041f0 <pic_enable>
}
  107f3e:	c9                   	leave  
  107f3f:	c3                   	ret    

00107f40 <outb>:
}

static inline void
outb(ushort port, uchar data)
{
  107f40:	55                   	push   %ebp
  107f41:	89 e5                	mov    %esp,%ebp
  107f43:	83 ec 08             	sub    $0x8,%esp
  107f46:	8b 45 08             	mov    0x8(%ebp),%eax
  107f49:	8b 55 0c             	mov    0xc(%ebp),%edx
  107f4c:	66 89 45 fc          	mov    %ax,0xfffffffc(%ebp)
  107f50:	88 55 f8             	mov    %dl,0xfffffff8(%ebp)
  asm volatile("out %0,%1" : : "a" (data), "d" (port));
  107f53:	0f b6 45 f8          	movzbl 0xfffffff8(%ebp),%eax
  107f57:	0f b7 55 fc          	movzwl 0xfffffffc(%ebp),%edx
  107f5b:	ee                   	out    %al,(%dx)
}
  107f5c:	c9                   	leave  
  107f5d:	c3                   	ret    
  107f5e:	89 f6                	mov    %esi,%esi

00107f60 <millitime>:

int
millitime(void)
{
  107f60:	55                   	push   %ebp
  107f61:	89 e5                	mov    %esp,%ebp
    return ticks * 10;
  107f63:	8b 15 c0 14 14 00    	mov    0x1414c0,%edx
  107f69:	89 d0                	mov    %edx,%eax
  107f6b:	c1 e0 02             	shl    $0x2,%eax
  107f6e:	01 d0                	add    %edx,%eax
  107f70:	01 c0                	add    %eax,%eax
}
  107f72:	5d                   	pop    %ebp
  107f73:	c3                   	ret    

00107f74 <alltraps>:
  107f74:	1e                   	push   %ds
  107f75:	06                   	push   %es
  107f76:	60                   	pusha  
  107f77:	b8 10 00 00 00       	mov    $0x10,%eax
  107f7c:	8e d8                	mov    %eax,%ds
  107f7e:	8e c0                	mov    %eax,%es
  107f80:	54                   	push   %esp
  107f81:	e8 ea 01 00 00       	call   108170 <trap>
  107f86:	83 c4 04             	add    $0x4,%esp

00107f89 <trapret>:
  107f89:	61                   	popa   
  107f8a:	07                   	pop    %es
  107f8b:	1f                   	pop    %ds
  107f8c:	83 c4 08             	add    $0x8,%esp
  107f8f:	cf                   	iret   

00107f90 <forkret1>:
  107f90:	8b 64 24 04          	mov    0x4(%esp),%esp
  107f94:	e9 f0 ff ff ff       	jmp    107f89 <trapret>
  107f99:	90                   	nop    
  107f9a:	90                   	nop    
  107f9b:	90                   	nop    
  107f9c:	90                   	nop    
  107f9d:	90                   	nop    
  107f9e:	90                   	nop    
  107f9f:	90                   	nop    

00107fa0 <tvinit>:
int ticks;

void
tvinit(void)
{
  107fa0:	55                   	push   %ebp
  107fa1:	89 e5                	mov    %esp,%ebp
  107fa3:	83 ec 18             	sub    $0x18,%esp
  int i;

  for(i = 0; i < 256; i++)
  107fa6:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
  107fad:	e9 bf 00 00 00       	jmp    108071 <tvinit+0xd1>
    SETGATE(idt[i], 0, SEG_KCODE<<3, vectors[i], 0);
  107fb2:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  107fb5:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  107fb8:	8b 04 85 b4 c6 11 00 	mov    0x11c6b4(,%eax,4),%eax
  107fbf:	66 89 04 d5 c0 0c 14 	mov    %ax,0x140cc0(,%edx,8)
  107fc6:	00 
  107fc7:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  107fca:	66 c7 04 c5 c2 0c 14 	movw   $0x8,0x140cc2(,%eax,8)
  107fd1:	00 08 00 
  107fd4:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  107fd7:	0f b6 04 d5 c4 0c 14 	movzbl 0x140cc4(,%edx,8),%eax
  107fde:	00 
  107fdf:	83 e0 e0             	and    $0xffffffe0,%eax
  107fe2:	88 04 d5 c4 0c 14 00 	mov    %al,0x140cc4(,%edx,8)
  107fe9:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  107fec:	0f b6 04 d5 c4 0c 14 	movzbl 0x140cc4(,%edx,8),%eax
  107ff3:	00 
  107ff4:	83 e0 1f             	and    $0x1f,%eax
  107ff7:	88 04 d5 c4 0c 14 00 	mov    %al,0x140cc4(,%edx,8)
  107ffe:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  108001:	0f b6 04 d5 c5 0c 14 	movzbl 0x140cc5(,%edx,8),%eax
  108008:	00 
  108009:	83 e0 f0             	and    $0xfffffff0,%eax
  10800c:	83 c8 0e             	or     $0xe,%eax
  10800f:	88 04 d5 c5 0c 14 00 	mov    %al,0x140cc5(,%edx,8)
  108016:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  108019:	0f b6 04 d5 c5 0c 14 	movzbl 0x140cc5(,%edx,8),%eax
  108020:	00 
  108021:	83 e0 ef             	and    $0xffffffef,%eax
  108024:	88 04 d5 c5 0c 14 00 	mov    %al,0x140cc5(,%edx,8)
  10802b:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  10802e:	0f b6 04 d5 c5 0c 14 	movzbl 0x140cc5(,%edx,8),%eax
  108035:	00 
  108036:	83 e0 9f             	and    $0xffffff9f,%eax
  108039:	88 04 d5 c5 0c 14 00 	mov    %al,0x140cc5(,%edx,8)
  108040:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  108043:	0f b6 04 d5 c5 0c 14 	movzbl 0x140cc5(,%edx,8),%eax
  10804a:	00 
  10804b:	83 c8 80             	or     $0xffffff80,%eax
  10804e:	88 04 d5 c5 0c 14 00 	mov    %al,0x140cc5(,%edx,8)
  108055:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  108058:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10805b:	8b 04 85 b4 c6 11 00 	mov    0x11c6b4(,%eax,4),%eax
  108062:	c1 e8 10             	shr    $0x10,%eax
  108065:	66 89 04 d5 c6 0c 14 	mov    %ax,0x140cc6(,%edx,8)
  10806c:	00 
  10806d:	83 45 fc 01          	addl   $0x1,0xfffffffc(%ebp)
  108071:	81 7d fc ff 00 00 00 	cmpl   $0xff,0xfffffffc(%ebp)
  108078:	0f 8e 34 ff ff ff    	jle    107fb2 <tvinit+0x12>
  SETGATE(idt[T_SYSCALL], 0, SEG_KCODE<<3, vectors[T_SYSCALL], DPL_USER);
  10807e:	a1 74 c7 11 00       	mov    0x11c774,%eax
  108083:	66 a3 40 0e 14 00    	mov    %ax,0x140e40
  108089:	66 c7 05 42 0e 14 00 	movw   $0x8,0x140e42
  108090:	08 00 
  108092:	0f b6 05 44 0e 14 00 	movzbl 0x140e44,%eax
  108099:	83 e0 e0             	and    $0xffffffe0,%eax
  10809c:	a2 44 0e 14 00       	mov    %al,0x140e44
  1080a1:	0f b6 05 44 0e 14 00 	movzbl 0x140e44,%eax
  1080a8:	83 e0 1f             	and    $0x1f,%eax
  1080ab:	a2 44 0e 14 00       	mov    %al,0x140e44
  1080b0:	0f b6 05 45 0e 14 00 	movzbl 0x140e45,%eax
  1080b7:	83 e0 f0             	and    $0xfffffff0,%eax
  1080ba:	83 c8 0e             	or     $0xe,%eax
  1080bd:	a2 45 0e 14 00       	mov    %al,0x140e45
  1080c2:	0f b6 05 45 0e 14 00 	movzbl 0x140e45,%eax
  1080c9:	83 e0 ef             	and    $0xffffffef,%eax
  1080cc:	a2 45 0e 14 00       	mov    %al,0x140e45
  1080d1:	0f b6 05 45 0e 14 00 	movzbl 0x140e45,%eax
  1080d8:	83 c8 60             	or     $0x60,%eax
  1080db:	a2 45 0e 14 00       	mov    %al,0x140e45
  1080e0:	0f b6 05 45 0e 14 00 	movzbl 0x140e45,%eax
  1080e7:	83 c8 80             	or     $0xffffff80,%eax
  1080ea:	a2 45 0e 14 00       	mov    %al,0x140e45
  1080ef:	a1 74 c7 11 00       	mov    0x11c774,%eax
  1080f4:	c1 e8 10             	shr    $0x10,%eax
  1080f7:	66 a3 46 0e 14 00    	mov    %ax,0x140e46
  
  initlock(&tickslock, "time");
  1080fd:	c7 44 24 04 a0 a7 11 	movl   $0x11a7a0,0x4(%esp)
  108104:	00 
  108105:	c7 04 24 80 0c 14 00 	movl   $0x140c80,(%esp)
  10810c:	e8 cf d9 ff ff       	call   105ae0 <initlock>
}
  108111:	c9                   	leave  
  108112:	c3                   	ret    
  108113:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  108119:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00108120 <idtinit>:

void
idtinit(void)
{
  108120:	55                   	push   %ebp
  108121:	89 e5                	mov    %esp,%ebp
  108123:	83 ec 08             	sub    $0x8,%esp
  lidt(idt, sizeof(idt));
  108126:	c7 44 24 04 00 08 00 	movl   $0x800,0x4(%esp)
  10812d:	00 
  10812e:	c7 04 24 c0 0c 14 00 	movl   $0x140cc0,(%esp)
  108135:	e8 06 00 00 00       	call   108140 <lidt>
}
  10813a:	c9                   	leave  
  10813b:	c3                   	ret    
  10813c:	8d 74 26 00          	lea    0x0(%esi),%esi

00108140 <lidt>:
struct gatedesc;

static inline void
lidt(struct gatedesc *p, int size)
{
  108140:	55                   	push   %ebp
  108141:	89 e5                	mov    %esp,%ebp
  108143:	83 ec 10             	sub    $0x10,%esp
  volatile ushort pd[3];

  pd[0] = size-1;
  108146:	8b 45 0c             	mov    0xc(%ebp),%eax
  108149:	83 e8 01             	sub    $0x1,%eax
  10814c:	66 89 45 fa          	mov    %ax,0xfffffffa(%ebp)
  pd[1] = (uint)p;
  108150:	8b 45 08             	mov    0x8(%ebp),%eax
  108153:	66 89 45 fc          	mov    %ax,0xfffffffc(%ebp)
  pd[2] = (uint)p >> 16;
  108157:	8b 45 08             	mov    0x8(%ebp),%eax
  10815a:	c1 e8 10             	shr    $0x10,%eax
  10815d:	66 89 45 fe          	mov    %ax,0xfffffffe(%ebp)

  asm volatile("lidt (%0)" : : "r" (pd));
  108161:	8d 45 fa             	lea    0xfffffffa(%ebp),%eax
  108164:	0f 01 18             	lidtl  (%eax)
}
  108167:	c9                   	leave  
  108168:	c3                   	ret    
  108169:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

00108170 <trap>:

void
trap(struct trapframe *tf)
{
  108170:	55                   	push   %ebp
  108171:	89 e5                	mov    %esp,%ebp
  108173:	57                   	push   %edi
  108174:	56                   	push   %esi
  108175:	53                   	push   %ebx
  108176:	83 ec 2c             	sub    $0x2c,%esp
  if(tf->trapno == T_SYSCALL){
  108179:	8b 45 08             	mov    0x8(%ebp),%eax
  10817c:	8b 40 28             	mov    0x28(%eax),%eax
  10817f:	83 f8 30             	cmp    $0x30,%eax
  108182:	75 53                	jne    1081d7 <trap+0x67>
    if(cp->killed)
  108184:	e8 07 b7 ff ff       	call   103890 <cpu>
  108189:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  108190:	8b 40 1c             	mov    0x1c(%eax),%eax
  108193:	85 c0                	test   %eax,%eax
  108195:	74 05                	je     10819c <trap+0x2c>
      exit();
  108197:	e8 14 d5 ff ff       	call   1056b0 <exit>
    cp->tf = tf;
  10819c:	e8 ef b6 ff ff       	call   103890 <cpu>
  1081a1:	8b 14 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%edx
  1081a8:	8b 45 08             	mov    0x8(%ebp),%eax
  1081ab:	89 82 84 00 00 00    	mov    %eax,0x84(%edx)
    syscall();
  1081b1:	e8 da e1 ff ff       	call   106390 <syscall>
    if(cp->killed)
  1081b6:	e8 d5 b6 ff ff       	call   103890 <cpu>
  1081bb:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  1081c2:	8b 40 1c             	mov    0x1c(%eax),%eax
  1081c5:	85 c0                	test   %eax,%eax
  1081c7:	0f 84 80 02 00 00    	je     10844d <trap+0x2dd>
      exit();
  1081cd:	e8 de d4 ff ff       	call   1056b0 <exit>
    return;
  1081d2:	e9 76 02 00 00       	jmp    10844d <trap+0x2dd>
  }

  // Increment nlock to make sure interrupts stay off
  // during interrupt handler.  Decrement before returning.
  cpus[cpu()].nlock++;
  1081d7:	e8 b4 b6 ff ff       	call   103890 <cpu>
  1081dc:	89 c1                	mov    %eax,%ecx
  1081de:	69 c1 ec 10 00 00    	imul   $0x10ec,%ecx,%eax
  1081e4:	8b 80 e0 dc 13 00    	mov    0x13dce0(%eax),%eax
  1081ea:	8d 50 01             	lea    0x1(%eax),%edx
  1081ed:	69 c1 ec 10 00 00    	imul   $0x10ec,%ecx,%eax
  1081f3:	89 90 e0 dc 13 00    	mov    %edx,0x13dce0(%eax)

  switch(tf->trapno){
  1081f9:	8b 45 08             	mov    0x8(%ebp),%eax
  1081fc:	8b 40 28             	mov    0x28(%eax),%eax
  1081ff:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
  108202:	83 7d e8 21          	cmpl   $0x21,0xffffffe8(%ebp)
  108206:	74 75                	je     10827d <trap+0x10d>
  108208:	83 7d e8 21          	cmpl   $0x21,0xffffffe8(%ebp)
  10820c:	77 0b                	ja     108219 <trap+0xa9>
  10820e:	83 7d e8 20          	cmpl   $0x20,0xffffffe8(%ebp)
  108212:	74 16                	je     10822a <trap+0xba>
  108214:	e9 9c 00 00 00       	jmp    1082b5 <trap+0x145>
  108219:	83 7d e8 2e          	cmpl   $0x2e,0xffffffe8(%ebp)
  10821d:	74 4f                	je     10826e <trap+0xfe>
  10821f:	83 7d e8 3f          	cmpl   $0x3f,0xffffffe8(%ebp)
  108223:	74 67                	je     10828c <trap+0x11c>
  108225:	e9 8b 00 00 00       	jmp    1082b5 <trap+0x145>
  case IRQ_OFFSET + IRQ_TIMER:
    if(cpu() == 0){
  10822a:	e8 61 b6 ff ff       	call   103890 <cpu>
  10822f:	85 c0                	test   %eax,%eax
  108231:	75 31                	jne    108264 <trap+0xf4>
      acquire(&tickslock);
  108233:	c7 04 24 80 0c 14 00 	movl   $0x140c80,(%esp)
  10823a:	e8 d1 d8 ff ff       	call   105b10 <acquire>
      ticks++;
  10823f:	a1 c0 14 14 00       	mov    0x1414c0,%eax
  108244:	83 c0 01             	add    $0x1,%eax
  108247:	a3 c0 14 14 00       	mov    %eax,0x1414c0
      wakeup(&ticks);
  10824c:	c7 04 24 c0 14 14 00 	movl   $0x1414c0,(%esp)
  108253:	e8 98 d3 ff ff       	call   1055f0 <wakeup>
      release(&tickslock);
  108258:	c7 04 24 80 0c 14 00 	movl   $0x140c80,(%esp)
  10825f:	e8 ac da ff ff       	call   105d10 <release>
    }
    lapic_eoi();
  108264:	e8 57 b6 ff ff       	call   1038c0 <lapic_eoi>
    break;
  108269:	e9 4f 01 00 00       	jmp    1083bd <trap+0x24d>
  case IRQ_OFFSET + IRQ_IDE:
    ide_intr();
  10826e:	e8 fd ac ff ff       	call   102f70 <ide_intr>
    lapic_eoi();
  108273:	e8 48 b6 ff ff       	call   1038c0 <lapic_eoi>
    break;
  108278:	e9 40 01 00 00       	jmp    1083bd <trap+0x24d>
  case IRQ_OFFSET + IRQ_KBD:
    kbd_intr();
  10827d:	e8 be b4 ff ff       	call   103740 <kbd_intr>
    lapic_eoi();
  108282:	e8 39 b6 ff ff       	call   1038c0 <lapic_eoi>
    break;
  108287:	e9 31 01 00 00       	jmp    1083bd <trap+0x24d>
  case IRQ_OFFSET + IRQ_SPURIOUS:
    cprintf("spurious interrupt from cpu %d eip %x\n", cpu(), tf->eip);
  10828c:	8b 45 08             	mov    0x8(%ebp),%eax
  10828f:	8b 58 30             	mov    0x30(%eax),%ebx
  108292:	e8 f9 b5 ff ff       	call   103890 <cpu>
  108297:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  10829b:	89 44 24 04          	mov    %eax,0x4(%esp)
  10829f:	c7 04 24 a8 a7 11 00 	movl   $0x11a7a8,(%esp)
  1082a6:	e8 65 84 ff ff       	call   100710 <cprintf>
    lapic_eoi();
  1082ab:	e8 10 b6 ff ff       	call   1038c0 <lapic_eoi>
    break;
  1082b0:	e9 08 01 00 00       	jmp    1083bd <trap+0x24d>
    
  default:
//    if (tf->trapno <= 30)
//    {
    if ((tf->trapno >= IRQ_OFFSET) && (tf->trapno <= IRQ_MAX))
  1082b5:	8b 45 08             	mov    0x8(%ebp),%eax
  1082b8:	8b 40 28             	mov    0x28(%eax),%eax
  1082bb:	83 f8 1f             	cmp    $0x1f,%eax
  1082be:	76 43                	jbe    108303 <trap+0x193>
  1082c0:	8b 45 08             	mov    0x8(%ebp),%eax
  1082c3:	8b 40 28             	mov    0x28(%eax),%eax
  1082c6:	3d 00 01 00 00       	cmp    $0x100,%eax
  1082cb:	77 36                	ja     108303 <trap+0x193>
        if (irq_handler[tf->trapno - IRQ_OFFSET])
  1082cd:	8b 45 08             	mov    0x8(%ebp),%eax
  1082d0:	8b 40 28             	mov    0x28(%eax),%eax
  1082d3:	83 e8 20             	sub    $0x20,%eax
  1082d6:	8b 04 85 20 dd 13 00 	mov    0x13dd20(,%eax,4),%eax
  1082dd:	85 c0                	test   %eax,%eax
  1082df:	74 22                	je     108303 <trap+0x193>
        {
//            cprintf("IRQ %d goes to handler\n", tf->trapno);
            irq_handler[tf->trapno - IRQ_OFFSET](tf);
  1082e1:	8b 45 08             	mov    0x8(%ebp),%eax
  1082e4:	8b 40 28             	mov    0x28(%eax),%eax
  1082e7:	83 e8 20             	sub    $0x20,%eax
  1082ea:	8b 14 85 20 dd 13 00 	mov    0x13dd20(,%eax,4),%edx
  1082f1:	8b 45 08             	mov    0x8(%ebp),%eax
  1082f4:	89 04 24             	mov    %eax,(%esp)
  1082f7:	ff d2                	call   *%edx
            lapic_eoi();
  1082f9:	e8 c2 b5 ff ff       	call   1038c0 <lapic_eoi>
            break;
  1082fe:	e9 ba 00 00 00       	jmp    1083bd <trap+0x24d>
        }
    if(cp == 0){
  108303:	e8 88 b5 ff ff       	call   103890 <cpu>
  108308:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  10830f:	85 c0                	test   %eax,%eax
  108311:	75 2d                	jne    108340 <trap+0x1d0>
      // Otherwise it's our mistake.
      cprintf("unexpected trap %d from cpu %d eip %x\n",
  108313:	8b 45 08             	mov    0x8(%ebp),%eax
  108316:	8b 58 30             	mov    0x30(%eax),%ebx
  108319:	e8 72 b5 ff ff       	call   103890 <cpu>
  10831e:	89 c2                	mov    %eax,%edx
  108320:	8b 45 08             	mov    0x8(%ebp),%eax
  108323:	8b 40 28             	mov    0x28(%eax),%eax
  108326:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
  10832a:	89 54 24 08          	mov    %edx,0x8(%esp)
  10832e:	89 44 24 04          	mov    %eax,0x4(%esp)
  108332:	c7 04 24 d0 a7 11 00 	movl   $0x11a7d0,(%esp)
  108339:	e8 d2 83 ff ff       	call   100710 <cprintf>
  10833e:	eb 7d                	jmp    1083bd <trap+0x24d>
              tf->trapno, cpu(), tf->eip);
//      panic("trap");
    }
    else
    {
        // Assume process divided by zero or dereferenced null, etc.
        cprintf("pid %d %s: trap %d err %d"
  108340:	8b 45 08             	mov    0x8(%ebp),%eax
  108343:	8b 70 30             	mov    0x30(%eax),%esi
  108346:	e8 45 b5 ff ff       	call   103890 <cpu>
  10834b:	89 c7                	mov    %eax,%edi
  10834d:	8b 45 08             	mov    0x8(%ebp),%eax
  108350:	8b 40 2c             	mov    0x2c(%eax),%eax
  108353:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  108356:	8b 45 08             	mov    0x8(%ebp),%eax
  108359:	8b 40 28             	mov    0x28(%eax),%eax
  10835c:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
  10835f:	e8 2c b5 ff ff       	call   103890 <cpu>
  108364:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  10836b:	8d 98 88 00 00 00    	lea    0x88(%eax),%ebx
  108371:	e8 1a b5 ff ff       	call   103890 <cpu>
  108376:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  10837d:	8b 40 10             	mov    0x10(%eax),%eax
  108380:	89 74 24 18          	mov    %esi,0x18(%esp)
  108384:	89 7c 24 14          	mov    %edi,0x14(%esp)
  108388:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
  10838b:	89 54 24 10          	mov    %edx,0x10(%esp)
  10838f:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
  108392:	89 54 24 0c          	mov    %edx,0xc(%esp)
  108396:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  10839a:	89 44 24 04          	mov    %eax,0x4(%esp)
  10839e:	c7 04 24 f8 a7 11 00 	movl   $0x11a7f8,(%esp)
  1083a5:	e8 66 83 ff ff       	call   100710 <cprintf>
                "on cpu %d eip %x -- kill proc\n",
            cp->pid, cp->name, tf->trapno, tf->err, cpu(), tf->eip);
        cp->killed = 1;
  1083aa:	e8 e1 b4 ff ff       	call   103890 <cpu>
  1083af:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  1083b6:	c7 40 1c 01 00 00 00 	movl   $0x1,0x1c(%eax)
    }
//    }
  }
  cpus[cpu()].nlock--;
  1083bd:	e8 ce b4 ff ff       	call   103890 <cpu>
  1083c2:	89 c1                	mov    %eax,%ecx
  1083c4:	69 c1 ec 10 00 00    	imul   $0x10ec,%ecx,%eax
  1083ca:	8b 80 e0 dc 13 00    	mov    0x13dce0(%eax),%eax
  1083d0:	8d 50 ff             	lea    0xffffffff(%eax),%edx
  1083d3:	69 c1 ec 10 00 00    	imul   $0x10ec,%ecx,%eax
  1083d9:	89 90 e0 dc 13 00    	mov    %edx,0x13dce0(%eax)

  // Force process exit if it has been killed and is in user space.
  // (If it is still executing in the kernel, let it keep running 
  // until it gets to the regular system call return.)
  if(cp && cp->killed && (tf->cs&3) == DPL_USER)
  1083df:	e8 ac b4 ff ff       	call   103890 <cpu>
  1083e4:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  1083eb:	85 c0                	test   %eax,%eax
  1083ed:	74 2a                	je     108419 <trap+0x2a9>
  1083ef:	e8 9c b4 ff ff       	call   103890 <cpu>
  1083f4:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  1083fb:	8b 40 1c             	mov    0x1c(%eax),%eax
  1083fe:	85 c0                	test   %eax,%eax
  108400:	74 17                	je     108419 <trap+0x2a9>
  108402:	8b 45 08             	mov    0x8(%ebp),%eax
  108405:	0f b7 40 34          	movzwl 0x34(%eax),%eax
  108409:	0f b7 c0             	movzwl %ax,%eax
  10840c:	83 e0 03             	and    $0x3,%eax
  10840f:	83 f8 03             	cmp    $0x3,%eax
  108412:	75 05                	jne    108419 <trap+0x2a9>
    exit();
  108414:	e8 97 d2 ff ff       	call   1056b0 <exit>

  // Force process to give up CPU on clock tick.
  // If interrupts were on while locks held, would need to check nlock.
  if(cp && cp->state == RUNNING && tf->trapno == IRQ_OFFSET+IRQ_TIMER)
  108419:	e8 72 b4 ff ff       	call   103890 <cpu>
  10841e:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  108425:	85 c0                	test   %eax,%eax
  108427:	74 24                	je     10844d <trap+0x2dd>
  108429:	e8 62 b4 ff ff       	call   103890 <cpu>
  10842e:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  108435:	8b 40 0c             	mov    0xc(%eax),%eax
  108438:	83 f8 04             	cmp    $0x4,%eax
  10843b:	75 10                	jne    10844d <trap+0x2dd>
  10843d:	8b 45 08             	mov    0x8(%ebp),%eax
  108440:	8b 40 28             	mov    0x28(%eax),%eax
  108443:	83 f8 20             	cmp    $0x20,%eax
  108446:	75 05                	jne    10844d <trap+0x2dd>
    yield();
  108448:	e8 83 ce ff ff       	call   1052d0 <yield>
}
  10844d:	83 c4 2c             	add    $0x2c,%esp
  108450:	5b                   	pop    %ebx
  108451:	5e                   	pop    %esi
  108452:	5f                   	pop    %edi
  108453:	5d                   	pop    %ebp
  108454:	c3                   	ret    
  108455:	90                   	nop    
  108456:	90                   	nop    
  108457:	90                   	nop    

00108458 <vector0>:
  108458:	6a 00                	push   $0x0
  10845a:	6a 00                	push   $0x0
  10845c:	e9 13 fb ff ff       	jmp    107f74 <alltraps>

00108461 <vector1>:
  108461:	6a 00                	push   $0x0
  108463:	6a 01                	push   $0x1
  108465:	e9 0a fb ff ff       	jmp    107f74 <alltraps>

0010846a <vector2>:
  10846a:	6a 00                	push   $0x0
  10846c:	6a 02                	push   $0x2
  10846e:	e9 01 fb ff ff       	jmp    107f74 <alltraps>

00108473 <vector3>:
  108473:	6a 00                	push   $0x0
  108475:	6a 03                	push   $0x3
  108477:	e9 f8 fa ff ff       	jmp    107f74 <alltraps>

0010847c <vector4>:
  10847c:	6a 00                	push   $0x0
  10847e:	6a 04                	push   $0x4
  108480:	e9 ef fa ff ff       	jmp    107f74 <alltraps>

00108485 <vector5>:
  108485:	6a 00                	push   $0x0
  108487:	6a 05                	push   $0x5
  108489:	e9 e6 fa ff ff       	jmp    107f74 <alltraps>

0010848e <vector6>:
  10848e:	6a 00                	push   $0x0
  108490:	6a 06                	push   $0x6
  108492:	e9 dd fa ff ff       	jmp    107f74 <alltraps>

00108497 <vector7>:
  108497:	6a 00                	push   $0x0
  108499:	6a 07                	push   $0x7
  10849b:	e9 d4 fa ff ff       	jmp    107f74 <alltraps>

001084a0 <vector8>:
  1084a0:	6a 08                	push   $0x8
  1084a2:	e9 cd fa ff ff       	jmp    107f74 <alltraps>

001084a7 <vector9>:
  1084a7:	6a 09                	push   $0x9
  1084a9:	e9 c6 fa ff ff       	jmp    107f74 <alltraps>

001084ae <vector10>:
  1084ae:	6a 0a                	push   $0xa
  1084b0:	e9 bf fa ff ff       	jmp    107f74 <alltraps>

001084b5 <vector11>:
  1084b5:	6a 0b                	push   $0xb
  1084b7:	e9 b8 fa ff ff       	jmp    107f74 <alltraps>

001084bc <vector12>:
  1084bc:	6a 0c                	push   $0xc
  1084be:	e9 b1 fa ff ff       	jmp    107f74 <alltraps>

001084c3 <vector13>:
  1084c3:	6a 0d                	push   $0xd
  1084c5:	e9 aa fa ff ff       	jmp    107f74 <alltraps>

001084ca <vector14>:
  1084ca:	6a 0e                	push   $0xe
  1084cc:	e9 a3 fa ff ff       	jmp    107f74 <alltraps>

001084d1 <vector15>:
  1084d1:	6a 00                	push   $0x0
  1084d3:	6a 0f                	push   $0xf
  1084d5:	e9 9a fa ff ff       	jmp    107f74 <alltraps>

001084da <vector16>:
  1084da:	6a 00                	push   $0x0
  1084dc:	6a 10                	push   $0x10
  1084de:	e9 91 fa ff ff       	jmp    107f74 <alltraps>

001084e3 <vector17>:
  1084e3:	6a 11                	push   $0x11
  1084e5:	e9 8a fa ff ff       	jmp    107f74 <alltraps>

001084ea <vector18>:
  1084ea:	6a 00                	push   $0x0
  1084ec:	6a 12                	push   $0x12
  1084ee:	e9 81 fa ff ff       	jmp    107f74 <alltraps>

001084f3 <vector19>:
  1084f3:	6a 00                	push   $0x0
  1084f5:	6a 13                	push   $0x13
  1084f7:	e9 78 fa ff ff       	jmp    107f74 <alltraps>

001084fc <vector20>:
  1084fc:	6a 00                	push   $0x0
  1084fe:	6a 14                	push   $0x14
  108500:	e9 6f fa ff ff       	jmp    107f74 <alltraps>

00108505 <vector21>:
  108505:	6a 00                	push   $0x0
  108507:	6a 15                	push   $0x15
  108509:	e9 66 fa ff ff       	jmp    107f74 <alltraps>

0010850e <vector22>:
  10850e:	6a 00                	push   $0x0
  108510:	6a 16                	push   $0x16
  108512:	e9 5d fa ff ff       	jmp    107f74 <alltraps>

00108517 <vector23>:
  108517:	6a 00                	push   $0x0
  108519:	6a 17                	push   $0x17
  10851b:	e9 54 fa ff ff       	jmp    107f74 <alltraps>

00108520 <vector24>:
  108520:	6a 00                	push   $0x0
  108522:	6a 18                	push   $0x18
  108524:	e9 4b fa ff ff       	jmp    107f74 <alltraps>

00108529 <vector25>:
  108529:	6a 00                	push   $0x0
  10852b:	6a 19                	push   $0x19
  10852d:	e9 42 fa ff ff       	jmp    107f74 <alltraps>

00108532 <vector26>:
  108532:	6a 00                	push   $0x0
  108534:	6a 1a                	push   $0x1a
  108536:	e9 39 fa ff ff       	jmp    107f74 <alltraps>

0010853b <vector27>:
  10853b:	6a 00                	push   $0x0
  10853d:	6a 1b                	push   $0x1b
  10853f:	e9 30 fa ff ff       	jmp    107f74 <alltraps>

00108544 <vector28>:
  108544:	6a 00                	push   $0x0
  108546:	6a 1c                	push   $0x1c
  108548:	e9 27 fa ff ff       	jmp    107f74 <alltraps>

0010854d <vector29>:
  10854d:	6a 00                	push   $0x0
  10854f:	6a 1d                	push   $0x1d
  108551:	e9 1e fa ff ff       	jmp    107f74 <alltraps>

00108556 <vector30>:
  108556:	6a 00                	push   $0x0
  108558:	6a 1e                	push   $0x1e
  10855a:	e9 15 fa ff ff       	jmp    107f74 <alltraps>

0010855f <vector31>:
  10855f:	6a 00                	push   $0x0
  108561:	6a 1f                	push   $0x1f
  108563:	e9 0c fa ff ff       	jmp    107f74 <alltraps>

00108568 <vector32>:
  108568:	6a 00                	push   $0x0
  10856a:	6a 20                	push   $0x20
  10856c:	e9 03 fa ff ff       	jmp    107f74 <alltraps>

00108571 <vector33>:
  108571:	6a 00                	push   $0x0
  108573:	6a 21                	push   $0x21
  108575:	e9 fa f9 ff ff       	jmp    107f74 <alltraps>

0010857a <vector34>:
  10857a:	6a 00                	push   $0x0
  10857c:	6a 22                	push   $0x22
  10857e:	e9 f1 f9 ff ff       	jmp    107f74 <alltraps>

00108583 <vector35>:
  108583:	6a 00                	push   $0x0
  108585:	6a 23                	push   $0x23
  108587:	e9 e8 f9 ff ff       	jmp    107f74 <alltraps>

0010858c <vector36>:
  10858c:	6a 00                	push   $0x0
  10858e:	6a 24                	push   $0x24
  108590:	e9 df f9 ff ff       	jmp    107f74 <alltraps>

00108595 <vector37>:
  108595:	6a 00                	push   $0x0
  108597:	6a 25                	push   $0x25
  108599:	e9 d6 f9 ff ff       	jmp    107f74 <alltraps>

0010859e <vector38>:
  10859e:	6a 00                	push   $0x0
  1085a0:	6a 26                	push   $0x26
  1085a2:	e9 cd f9 ff ff       	jmp    107f74 <alltraps>

001085a7 <vector39>:
  1085a7:	6a 00                	push   $0x0
  1085a9:	6a 27                	push   $0x27
  1085ab:	e9 c4 f9 ff ff       	jmp    107f74 <alltraps>

001085b0 <vector40>:
  1085b0:	6a 00                	push   $0x0
  1085b2:	6a 28                	push   $0x28
  1085b4:	e9 bb f9 ff ff       	jmp    107f74 <alltraps>

001085b9 <vector41>:
  1085b9:	6a 00                	push   $0x0
  1085bb:	6a 29                	push   $0x29
  1085bd:	e9 b2 f9 ff ff       	jmp    107f74 <alltraps>

001085c2 <vector42>:
  1085c2:	6a 00                	push   $0x0
  1085c4:	6a 2a                	push   $0x2a
  1085c6:	e9 a9 f9 ff ff       	jmp    107f74 <alltraps>

001085cb <vector43>:
  1085cb:	6a 00                	push   $0x0
  1085cd:	6a 2b                	push   $0x2b
  1085cf:	e9 a0 f9 ff ff       	jmp    107f74 <alltraps>

001085d4 <vector44>:
  1085d4:	6a 00                	push   $0x0
  1085d6:	6a 2c                	push   $0x2c
  1085d8:	e9 97 f9 ff ff       	jmp    107f74 <alltraps>

001085dd <vector45>:
  1085dd:	6a 00                	push   $0x0
  1085df:	6a 2d                	push   $0x2d
  1085e1:	e9 8e f9 ff ff       	jmp    107f74 <alltraps>

001085e6 <vector46>:
  1085e6:	6a 00                	push   $0x0
  1085e8:	6a 2e                	push   $0x2e
  1085ea:	e9 85 f9 ff ff       	jmp    107f74 <alltraps>

001085ef <vector47>:
  1085ef:	6a 00                	push   $0x0
  1085f1:	6a 2f                	push   $0x2f
  1085f3:	e9 7c f9 ff ff       	jmp    107f74 <alltraps>

001085f8 <vector48>:
  1085f8:	6a 00                	push   $0x0
  1085fa:	6a 30                	push   $0x30
  1085fc:	e9 73 f9 ff ff       	jmp    107f74 <alltraps>

00108601 <vector49>:
  108601:	6a 00                	push   $0x0
  108603:	6a 31                	push   $0x31
  108605:	e9 6a f9 ff ff       	jmp    107f74 <alltraps>

0010860a <vector50>:
  10860a:	6a 00                	push   $0x0
  10860c:	6a 32                	push   $0x32
  10860e:	e9 61 f9 ff ff       	jmp    107f74 <alltraps>

00108613 <vector51>:
  108613:	6a 00                	push   $0x0
  108615:	6a 33                	push   $0x33
  108617:	e9 58 f9 ff ff       	jmp    107f74 <alltraps>

0010861c <vector52>:
  10861c:	6a 00                	push   $0x0
  10861e:	6a 34                	push   $0x34
  108620:	e9 4f f9 ff ff       	jmp    107f74 <alltraps>

00108625 <vector53>:
  108625:	6a 00                	push   $0x0
  108627:	6a 35                	push   $0x35
  108629:	e9 46 f9 ff ff       	jmp    107f74 <alltraps>

0010862e <vector54>:
  10862e:	6a 00                	push   $0x0
  108630:	6a 36                	push   $0x36
  108632:	e9 3d f9 ff ff       	jmp    107f74 <alltraps>

00108637 <vector55>:
  108637:	6a 00                	push   $0x0
  108639:	6a 37                	push   $0x37
  10863b:	e9 34 f9 ff ff       	jmp    107f74 <alltraps>

00108640 <vector56>:
  108640:	6a 00                	push   $0x0
  108642:	6a 38                	push   $0x38
  108644:	e9 2b f9 ff ff       	jmp    107f74 <alltraps>

00108649 <vector57>:
  108649:	6a 00                	push   $0x0
  10864b:	6a 39                	push   $0x39
  10864d:	e9 22 f9 ff ff       	jmp    107f74 <alltraps>

00108652 <vector58>:
  108652:	6a 00                	push   $0x0
  108654:	6a 3a                	push   $0x3a
  108656:	e9 19 f9 ff ff       	jmp    107f74 <alltraps>

0010865b <vector59>:
  10865b:	6a 00                	push   $0x0
  10865d:	6a 3b                	push   $0x3b
  10865f:	e9 10 f9 ff ff       	jmp    107f74 <alltraps>

00108664 <vector60>:
  108664:	6a 00                	push   $0x0
  108666:	6a 3c                	push   $0x3c
  108668:	e9 07 f9 ff ff       	jmp    107f74 <alltraps>

0010866d <vector61>:
  10866d:	6a 00                	push   $0x0
  10866f:	6a 3d                	push   $0x3d
  108671:	e9 fe f8 ff ff       	jmp    107f74 <alltraps>

00108676 <vector62>:
  108676:	6a 00                	push   $0x0
  108678:	6a 3e                	push   $0x3e
  10867a:	e9 f5 f8 ff ff       	jmp    107f74 <alltraps>

0010867f <vector63>:
  10867f:	6a 00                	push   $0x0
  108681:	6a 3f                	push   $0x3f
  108683:	e9 ec f8 ff ff       	jmp    107f74 <alltraps>

00108688 <vector64>:
  108688:	6a 00                	push   $0x0
  10868a:	6a 40                	push   $0x40
  10868c:	e9 e3 f8 ff ff       	jmp    107f74 <alltraps>

00108691 <vector65>:
  108691:	6a 00                	push   $0x0
  108693:	6a 41                	push   $0x41
  108695:	e9 da f8 ff ff       	jmp    107f74 <alltraps>

0010869a <vector66>:
  10869a:	6a 00                	push   $0x0
  10869c:	6a 42                	push   $0x42
  10869e:	e9 d1 f8 ff ff       	jmp    107f74 <alltraps>

001086a3 <vector67>:
  1086a3:	6a 00                	push   $0x0
  1086a5:	6a 43                	push   $0x43
  1086a7:	e9 c8 f8 ff ff       	jmp    107f74 <alltraps>

001086ac <vector68>:
  1086ac:	6a 00                	push   $0x0
  1086ae:	6a 44                	push   $0x44
  1086b0:	e9 bf f8 ff ff       	jmp    107f74 <alltraps>

001086b5 <vector69>:
  1086b5:	6a 00                	push   $0x0
  1086b7:	6a 45                	push   $0x45
  1086b9:	e9 b6 f8 ff ff       	jmp    107f74 <alltraps>

001086be <vector70>:
  1086be:	6a 00                	push   $0x0
  1086c0:	6a 46                	push   $0x46
  1086c2:	e9 ad f8 ff ff       	jmp    107f74 <alltraps>

001086c7 <vector71>:
  1086c7:	6a 00                	push   $0x0
  1086c9:	6a 47                	push   $0x47
  1086cb:	e9 a4 f8 ff ff       	jmp    107f74 <alltraps>

001086d0 <vector72>:
  1086d0:	6a 00                	push   $0x0
  1086d2:	6a 48                	push   $0x48
  1086d4:	e9 9b f8 ff ff       	jmp    107f74 <alltraps>

001086d9 <vector73>:
  1086d9:	6a 00                	push   $0x0
  1086db:	6a 49                	push   $0x49
  1086dd:	e9 92 f8 ff ff       	jmp    107f74 <alltraps>

001086e2 <vector74>:
  1086e2:	6a 00                	push   $0x0
  1086e4:	6a 4a                	push   $0x4a
  1086e6:	e9 89 f8 ff ff       	jmp    107f74 <alltraps>

001086eb <vector75>:
  1086eb:	6a 00                	push   $0x0
  1086ed:	6a 4b                	push   $0x4b
  1086ef:	e9 80 f8 ff ff       	jmp    107f74 <alltraps>

001086f4 <vector76>:
  1086f4:	6a 00                	push   $0x0
  1086f6:	6a 4c                	push   $0x4c
  1086f8:	e9 77 f8 ff ff       	jmp    107f74 <alltraps>

001086fd <vector77>:
  1086fd:	6a 00                	push   $0x0
  1086ff:	6a 4d                	push   $0x4d
  108701:	e9 6e f8 ff ff       	jmp    107f74 <alltraps>

00108706 <vector78>:
  108706:	6a 00                	push   $0x0
  108708:	6a 4e                	push   $0x4e
  10870a:	e9 65 f8 ff ff       	jmp    107f74 <alltraps>

0010870f <vector79>:
  10870f:	6a 00                	push   $0x0
  108711:	6a 4f                	push   $0x4f
  108713:	e9 5c f8 ff ff       	jmp    107f74 <alltraps>

00108718 <vector80>:
  108718:	6a 00                	push   $0x0
  10871a:	6a 50                	push   $0x50
  10871c:	e9 53 f8 ff ff       	jmp    107f74 <alltraps>

00108721 <vector81>:
  108721:	6a 00                	push   $0x0
  108723:	6a 51                	push   $0x51
  108725:	e9 4a f8 ff ff       	jmp    107f74 <alltraps>

0010872a <vector82>:
  10872a:	6a 00                	push   $0x0
  10872c:	6a 52                	push   $0x52
  10872e:	e9 41 f8 ff ff       	jmp    107f74 <alltraps>

00108733 <vector83>:
  108733:	6a 00                	push   $0x0
  108735:	6a 53                	push   $0x53
  108737:	e9 38 f8 ff ff       	jmp    107f74 <alltraps>

0010873c <vector84>:
  10873c:	6a 00                	push   $0x0
  10873e:	6a 54                	push   $0x54
  108740:	e9 2f f8 ff ff       	jmp    107f74 <alltraps>

00108745 <vector85>:
  108745:	6a 00                	push   $0x0
  108747:	6a 55                	push   $0x55
  108749:	e9 26 f8 ff ff       	jmp    107f74 <alltraps>

0010874e <vector86>:
  10874e:	6a 00                	push   $0x0
  108750:	6a 56                	push   $0x56
  108752:	e9 1d f8 ff ff       	jmp    107f74 <alltraps>

00108757 <vector87>:
  108757:	6a 00                	push   $0x0
  108759:	6a 57                	push   $0x57
  10875b:	e9 14 f8 ff ff       	jmp    107f74 <alltraps>

00108760 <vector88>:
  108760:	6a 00                	push   $0x0
  108762:	6a 58                	push   $0x58
  108764:	e9 0b f8 ff ff       	jmp    107f74 <alltraps>

00108769 <vector89>:
  108769:	6a 00                	push   $0x0
  10876b:	6a 59                	push   $0x59
  10876d:	e9 02 f8 ff ff       	jmp    107f74 <alltraps>

00108772 <vector90>:
  108772:	6a 00                	push   $0x0
  108774:	6a 5a                	push   $0x5a
  108776:	e9 f9 f7 ff ff       	jmp    107f74 <alltraps>

0010877b <vector91>:
  10877b:	6a 00                	push   $0x0
  10877d:	6a 5b                	push   $0x5b
  10877f:	e9 f0 f7 ff ff       	jmp    107f74 <alltraps>

00108784 <vector92>:
  108784:	6a 00                	push   $0x0
  108786:	6a 5c                	push   $0x5c
  108788:	e9 e7 f7 ff ff       	jmp    107f74 <alltraps>

0010878d <vector93>:
  10878d:	6a 00                	push   $0x0
  10878f:	6a 5d                	push   $0x5d
  108791:	e9 de f7 ff ff       	jmp    107f74 <alltraps>

00108796 <vector94>:
  108796:	6a 00                	push   $0x0
  108798:	6a 5e                	push   $0x5e
  10879a:	e9 d5 f7 ff ff       	jmp    107f74 <alltraps>

0010879f <vector95>:
  10879f:	6a 00                	push   $0x0
  1087a1:	6a 5f                	push   $0x5f
  1087a3:	e9 cc f7 ff ff       	jmp    107f74 <alltraps>

001087a8 <vector96>:
  1087a8:	6a 00                	push   $0x0
  1087aa:	6a 60                	push   $0x60
  1087ac:	e9 c3 f7 ff ff       	jmp    107f74 <alltraps>

001087b1 <vector97>:
  1087b1:	6a 00                	push   $0x0
  1087b3:	6a 61                	push   $0x61
  1087b5:	e9 ba f7 ff ff       	jmp    107f74 <alltraps>

001087ba <vector98>:
  1087ba:	6a 00                	push   $0x0
  1087bc:	6a 62                	push   $0x62
  1087be:	e9 b1 f7 ff ff       	jmp    107f74 <alltraps>

001087c3 <vector99>:
  1087c3:	6a 00                	push   $0x0
  1087c5:	6a 63                	push   $0x63
  1087c7:	e9 a8 f7 ff ff       	jmp    107f74 <alltraps>

001087cc <vector100>:
  1087cc:	6a 00                	push   $0x0
  1087ce:	6a 64                	push   $0x64
  1087d0:	e9 9f f7 ff ff       	jmp    107f74 <alltraps>

001087d5 <vector101>:
  1087d5:	6a 00                	push   $0x0
  1087d7:	6a 65                	push   $0x65
  1087d9:	e9 96 f7 ff ff       	jmp    107f74 <alltraps>

001087de <vector102>:
  1087de:	6a 00                	push   $0x0
  1087e0:	6a 66                	push   $0x66
  1087e2:	e9 8d f7 ff ff       	jmp    107f74 <alltraps>

001087e7 <vector103>:
  1087e7:	6a 00                	push   $0x0
  1087e9:	6a 67                	push   $0x67
  1087eb:	e9 84 f7 ff ff       	jmp    107f74 <alltraps>

001087f0 <vector104>:
  1087f0:	6a 00                	push   $0x0
  1087f2:	6a 68                	push   $0x68
  1087f4:	e9 7b f7 ff ff       	jmp    107f74 <alltraps>

001087f9 <vector105>:
  1087f9:	6a 00                	push   $0x0
  1087fb:	6a 69                	push   $0x69
  1087fd:	e9 72 f7 ff ff       	jmp    107f74 <alltraps>

00108802 <vector106>:
  108802:	6a 00                	push   $0x0
  108804:	6a 6a                	push   $0x6a
  108806:	e9 69 f7 ff ff       	jmp    107f74 <alltraps>

0010880b <vector107>:
  10880b:	6a 00                	push   $0x0
  10880d:	6a 6b                	push   $0x6b
  10880f:	e9 60 f7 ff ff       	jmp    107f74 <alltraps>

00108814 <vector108>:
  108814:	6a 00                	push   $0x0
  108816:	6a 6c                	push   $0x6c
  108818:	e9 57 f7 ff ff       	jmp    107f74 <alltraps>

0010881d <vector109>:
  10881d:	6a 00                	push   $0x0
  10881f:	6a 6d                	push   $0x6d
  108821:	e9 4e f7 ff ff       	jmp    107f74 <alltraps>

00108826 <vector110>:
  108826:	6a 00                	push   $0x0
  108828:	6a 6e                	push   $0x6e
  10882a:	e9 45 f7 ff ff       	jmp    107f74 <alltraps>

0010882f <vector111>:
  10882f:	6a 00                	push   $0x0
  108831:	6a 6f                	push   $0x6f
  108833:	e9 3c f7 ff ff       	jmp    107f74 <alltraps>

00108838 <vector112>:
  108838:	6a 00                	push   $0x0
  10883a:	6a 70                	push   $0x70
  10883c:	e9 33 f7 ff ff       	jmp    107f74 <alltraps>

00108841 <vector113>:
  108841:	6a 00                	push   $0x0
  108843:	6a 71                	push   $0x71
  108845:	e9 2a f7 ff ff       	jmp    107f74 <alltraps>

0010884a <vector114>:
  10884a:	6a 00                	push   $0x0
  10884c:	6a 72                	push   $0x72
  10884e:	e9 21 f7 ff ff       	jmp    107f74 <alltraps>

00108853 <vector115>:
  108853:	6a 00                	push   $0x0
  108855:	6a 73                	push   $0x73
  108857:	e9 18 f7 ff ff       	jmp    107f74 <alltraps>

0010885c <vector116>:
  10885c:	6a 00                	push   $0x0
  10885e:	6a 74                	push   $0x74
  108860:	e9 0f f7 ff ff       	jmp    107f74 <alltraps>

00108865 <vector117>:
  108865:	6a 00                	push   $0x0
  108867:	6a 75                	push   $0x75
  108869:	e9 06 f7 ff ff       	jmp    107f74 <alltraps>

0010886e <vector118>:
  10886e:	6a 00                	push   $0x0
  108870:	6a 76                	push   $0x76
  108872:	e9 fd f6 ff ff       	jmp    107f74 <alltraps>

00108877 <vector119>:
  108877:	6a 00                	push   $0x0
  108879:	6a 77                	push   $0x77
  10887b:	e9 f4 f6 ff ff       	jmp    107f74 <alltraps>

00108880 <vector120>:
  108880:	6a 00                	push   $0x0
  108882:	6a 78                	push   $0x78
  108884:	e9 eb f6 ff ff       	jmp    107f74 <alltraps>

00108889 <vector121>:
  108889:	6a 00                	push   $0x0
  10888b:	6a 79                	push   $0x79
  10888d:	e9 e2 f6 ff ff       	jmp    107f74 <alltraps>

00108892 <vector122>:
  108892:	6a 00                	push   $0x0
  108894:	6a 7a                	push   $0x7a
  108896:	e9 d9 f6 ff ff       	jmp    107f74 <alltraps>

0010889b <vector123>:
  10889b:	6a 00                	push   $0x0
  10889d:	6a 7b                	push   $0x7b
  10889f:	e9 d0 f6 ff ff       	jmp    107f74 <alltraps>

001088a4 <vector124>:
  1088a4:	6a 00                	push   $0x0
  1088a6:	6a 7c                	push   $0x7c
  1088a8:	e9 c7 f6 ff ff       	jmp    107f74 <alltraps>

001088ad <vector125>:
  1088ad:	6a 00                	push   $0x0
  1088af:	6a 7d                	push   $0x7d
  1088b1:	e9 be f6 ff ff       	jmp    107f74 <alltraps>

001088b6 <vector126>:
  1088b6:	6a 00                	push   $0x0
  1088b8:	6a 7e                	push   $0x7e
  1088ba:	e9 b5 f6 ff ff       	jmp    107f74 <alltraps>

001088bf <vector127>:
  1088bf:	6a 00                	push   $0x0
  1088c1:	6a 7f                	push   $0x7f
  1088c3:	e9 ac f6 ff ff       	jmp    107f74 <alltraps>

001088c8 <vector128>:
  1088c8:	6a 00                	push   $0x0
  1088ca:	68 80 00 00 00       	push   $0x80
  1088cf:	e9 a0 f6 ff ff       	jmp    107f74 <alltraps>

001088d4 <vector129>:
  1088d4:	6a 00                	push   $0x0
  1088d6:	68 81 00 00 00       	push   $0x81
  1088db:	e9 94 f6 ff ff       	jmp    107f74 <alltraps>

001088e0 <vector130>:
  1088e0:	6a 00                	push   $0x0
  1088e2:	68 82 00 00 00       	push   $0x82
  1088e7:	e9 88 f6 ff ff       	jmp    107f74 <alltraps>

001088ec <vector131>:
  1088ec:	6a 00                	push   $0x0
  1088ee:	68 83 00 00 00       	push   $0x83
  1088f3:	e9 7c f6 ff ff       	jmp    107f74 <alltraps>

001088f8 <vector132>:
  1088f8:	6a 00                	push   $0x0
  1088fa:	68 84 00 00 00       	push   $0x84
  1088ff:	e9 70 f6 ff ff       	jmp    107f74 <alltraps>

00108904 <vector133>:
  108904:	6a 00                	push   $0x0
  108906:	68 85 00 00 00       	push   $0x85
  10890b:	e9 64 f6 ff ff       	jmp    107f74 <alltraps>

00108910 <vector134>:
  108910:	6a 00                	push   $0x0
  108912:	68 86 00 00 00       	push   $0x86
  108917:	e9 58 f6 ff ff       	jmp    107f74 <alltraps>

0010891c <vector135>:
  10891c:	6a 00                	push   $0x0
  10891e:	68 87 00 00 00       	push   $0x87
  108923:	e9 4c f6 ff ff       	jmp    107f74 <alltraps>

00108928 <vector136>:
  108928:	6a 00                	push   $0x0
  10892a:	68 88 00 00 00       	push   $0x88
  10892f:	e9 40 f6 ff ff       	jmp    107f74 <alltraps>

00108934 <vector137>:
  108934:	6a 00                	push   $0x0
  108936:	68 89 00 00 00       	push   $0x89
  10893b:	e9 34 f6 ff ff       	jmp    107f74 <alltraps>

00108940 <vector138>:
  108940:	6a 00                	push   $0x0
  108942:	68 8a 00 00 00       	push   $0x8a
  108947:	e9 28 f6 ff ff       	jmp    107f74 <alltraps>

0010894c <vector139>:
  10894c:	6a 00                	push   $0x0
  10894e:	68 8b 00 00 00       	push   $0x8b
  108953:	e9 1c f6 ff ff       	jmp    107f74 <alltraps>

00108958 <vector140>:
  108958:	6a 00                	push   $0x0
  10895a:	68 8c 00 00 00       	push   $0x8c
  10895f:	e9 10 f6 ff ff       	jmp    107f74 <alltraps>

00108964 <vector141>:
  108964:	6a 00                	push   $0x0
  108966:	68 8d 00 00 00       	push   $0x8d
  10896b:	e9 04 f6 ff ff       	jmp    107f74 <alltraps>

00108970 <vector142>:
  108970:	6a 00                	push   $0x0
  108972:	68 8e 00 00 00       	push   $0x8e
  108977:	e9 f8 f5 ff ff       	jmp    107f74 <alltraps>

0010897c <vector143>:
  10897c:	6a 00                	push   $0x0
  10897e:	68 8f 00 00 00       	push   $0x8f
  108983:	e9 ec f5 ff ff       	jmp    107f74 <alltraps>

00108988 <vector144>:
  108988:	6a 00                	push   $0x0
  10898a:	68 90 00 00 00       	push   $0x90
  10898f:	e9 e0 f5 ff ff       	jmp    107f74 <alltraps>

00108994 <vector145>:
  108994:	6a 00                	push   $0x0
  108996:	68 91 00 00 00       	push   $0x91
  10899b:	e9 d4 f5 ff ff       	jmp    107f74 <alltraps>

001089a0 <vector146>:
  1089a0:	6a 00                	push   $0x0
  1089a2:	68 92 00 00 00       	push   $0x92
  1089a7:	e9 c8 f5 ff ff       	jmp    107f74 <alltraps>

001089ac <vector147>:
  1089ac:	6a 00                	push   $0x0
  1089ae:	68 93 00 00 00       	push   $0x93
  1089b3:	e9 bc f5 ff ff       	jmp    107f74 <alltraps>

001089b8 <vector148>:
  1089b8:	6a 00                	push   $0x0
  1089ba:	68 94 00 00 00       	push   $0x94
  1089bf:	e9 b0 f5 ff ff       	jmp    107f74 <alltraps>

001089c4 <vector149>:
  1089c4:	6a 00                	push   $0x0
  1089c6:	68 95 00 00 00       	push   $0x95
  1089cb:	e9 a4 f5 ff ff       	jmp    107f74 <alltraps>

001089d0 <vector150>:
  1089d0:	6a 00                	push   $0x0
  1089d2:	68 96 00 00 00       	push   $0x96
  1089d7:	e9 98 f5 ff ff       	jmp    107f74 <alltraps>

001089dc <vector151>:
  1089dc:	6a 00                	push   $0x0
  1089de:	68 97 00 00 00       	push   $0x97
  1089e3:	e9 8c f5 ff ff       	jmp    107f74 <alltraps>

001089e8 <vector152>:
  1089e8:	6a 00                	push   $0x0
  1089ea:	68 98 00 00 00       	push   $0x98
  1089ef:	e9 80 f5 ff ff       	jmp    107f74 <alltraps>

001089f4 <vector153>:
  1089f4:	6a 00                	push   $0x0
  1089f6:	68 99 00 00 00       	push   $0x99
  1089fb:	e9 74 f5 ff ff       	jmp    107f74 <alltraps>

00108a00 <vector154>:
  108a00:	6a 00                	push   $0x0
  108a02:	68 9a 00 00 00       	push   $0x9a
  108a07:	e9 68 f5 ff ff       	jmp    107f74 <alltraps>

00108a0c <vector155>:
  108a0c:	6a 00                	push   $0x0
  108a0e:	68 9b 00 00 00       	push   $0x9b
  108a13:	e9 5c f5 ff ff       	jmp    107f74 <alltraps>

00108a18 <vector156>:
  108a18:	6a 00                	push   $0x0
  108a1a:	68 9c 00 00 00       	push   $0x9c
  108a1f:	e9 50 f5 ff ff       	jmp    107f74 <alltraps>

00108a24 <vector157>:
  108a24:	6a 00                	push   $0x0
  108a26:	68 9d 00 00 00       	push   $0x9d
  108a2b:	e9 44 f5 ff ff       	jmp    107f74 <alltraps>

00108a30 <vector158>:
  108a30:	6a 00                	push   $0x0
  108a32:	68 9e 00 00 00       	push   $0x9e
  108a37:	e9 38 f5 ff ff       	jmp    107f74 <alltraps>

00108a3c <vector159>:
  108a3c:	6a 00                	push   $0x0
  108a3e:	68 9f 00 00 00       	push   $0x9f
  108a43:	e9 2c f5 ff ff       	jmp    107f74 <alltraps>

00108a48 <vector160>:
  108a48:	6a 00                	push   $0x0
  108a4a:	68 a0 00 00 00       	push   $0xa0
  108a4f:	e9 20 f5 ff ff       	jmp    107f74 <alltraps>

00108a54 <vector161>:
  108a54:	6a 00                	push   $0x0
  108a56:	68 a1 00 00 00       	push   $0xa1
  108a5b:	e9 14 f5 ff ff       	jmp    107f74 <alltraps>

00108a60 <vector162>:
  108a60:	6a 00                	push   $0x0
  108a62:	68 a2 00 00 00       	push   $0xa2
  108a67:	e9 08 f5 ff ff       	jmp    107f74 <alltraps>

00108a6c <vector163>:
  108a6c:	6a 00                	push   $0x0
  108a6e:	68 a3 00 00 00       	push   $0xa3
  108a73:	e9 fc f4 ff ff       	jmp    107f74 <alltraps>

00108a78 <vector164>:
  108a78:	6a 00                	push   $0x0
  108a7a:	68 a4 00 00 00       	push   $0xa4
  108a7f:	e9 f0 f4 ff ff       	jmp    107f74 <alltraps>

00108a84 <vector165>:
  108a84:	6a 00                	push   $0x0
  108a86:	68 a5 00 00 00       	push   $0xa5
  108a8b:	e9 e4 f4 ff ff       	jmp    107f74 <alltraps>

00108a90 <vector166>:
  108a90:	6a 00                	push   $0x0
  108a92:	68 a6 00 00 00       	push   $0xa6
  108a97:	e9 d8 f4 ff ff       	jmp    107f74 <alltraps>

00108a9c <vector167>:
  108a9c:	6a 00                	push   $0x0
  108a9e:	68 a7 00 00 00       	push   $0xa7
  108aa3:	e9 cc f4 ff ff       	jmp    107f74 <alltraps>

00108aa8 <vector168>:
  108aa8:	6a 00                	push   $0x0
  108aaa:	68 a8 00 00 00       	push   $0xa8
  108aaf:	e9 c0 f4 ff ff       	jmp    107f74 <alltraps>

00108ab4 <vector169>:
  108ab4:	6a 00                	push   $0x0
  108ab6:	68 a9 00 00 00       	push   $0xa9
  108abb:	e9 b4 f4 ff ff       	jmp    107f74 <alltraps>

00108ac0 <vector170>:
  108ac0:	6a 00                	push   $0x0
  108ac2:	68 aa 00 00 00       	push   $0xaa
  108ac7:	e9 a8 f4 ff ff       	jmp    107f74 <alltraps>

00108acc <vector171>:
  108acc:	6a 00                	push   $0x0
  108ace:	68 ab 00 00 00       	push   $0xab
  108ad3:	e9 9c f4 ff ff       	jmp    107f74 <alltraps>

00108ad8 <vector172>:
  108ad8:	6a 00                	push   $0x0
  108ada:	68 ac 00 00 00       	push   $0xac
  108adf:	e9 90 f4 ff ff       	jmp    107f74 <alltraps>

00108ae4 <vector173>:
  108ae4:	6a 00                	push   $0x0
  108ae6:	68 ad 00 00 00       	push   $0xad
  108aeb:	e9 84 f4 ff ff       	jmp    107f74 <alltraps>

00108af0 <vector174>:
  108af0:	6a 00                	push   $0x0
  108af2:	68 ae 00 00 00       	push   $0xae
  108af7:	e9 78 f4 ff ff       	jmp    107f74 <alltraps>

00108afc <vector175>:
  108afc:	6a 00                	push   $0x0
  108afe:	68 af 00 00 00       	push   $0xaf
  108b03:	e9 6c f4 ff ff       	jmp    107f74 <alltraps>

00108b08 <vector176>:
  108b08:	6a 00                	push   $0x0
  108b0a:	68 b0 00 00 00       	push   $0xb0
  108b0f:	e9 60 f4 ff ff       	jmp    107f74 <alltraps>

00108b14 <vector177>:
  108b14:	6a 00                	push   $0x0
  108b16:	68 b1 00 00 00       	push   $0xb1
  108b1b:	e9 54 f4 ff ff       	jmp    107f74 <alltraps>

00108b20 <vector178>:
  108b20:	6a 00                	push   $0x0
  108b22:	68 b2 00 00 00       	push   $0xb2
  108b27:	e9 48 f4 ff ff       	jmp    107f74 <alltraps>

00108b2c <vector179>:
  108b2c:	6a 00                	push   $0x0
  108b2e:	68 b3 00 00 00       	push   $0xb3
  108b33:	e9 3c f4 ff ff       	jmp    107f74 <alltraps>

00108b38 <vector180>:
  108b38:	6a 00                	push   $0x0
  108b3a:	68 b4 00 00 00       	push   $0xb4
  108b3f:	e9 30 f4 ff ff       	jmp    107f74 <alltraps>

00108b44 <vector181>:
  108b44:	6a 00                	push   $0x0
  108b46:	68 b5 00 00 00       	push   $0xb5
  108b4b:	e9 24 f4 ff ff       	jmp    107f74 <alltraps>

00108b50 <vector182>:
  108b50:	6a 00                	push   $0x0
  108b52:	68 b6 00 00 00       	push   $0xb6
  108b57:	e9 18 f4 ff ff       	jmp    107f74 <alltraps>

00108b5c <vector183>:
  108b5c:	6a 00                	push   $0x0
  108b5e:	68 b7 00 00 00       	push   $0xb7
  108b63:	e9 0c f4 ff ff       	jmp    107f74 <alltraps>

00108b68 <vector184>:
  108b68:	6a 00                	push   $0x0
  108b6a:	68 b8 00 00 00       	push   $0xb8
  108b6f:	e9 00 f4 ff ff       	jmp    107f74 <alltraps>

00108b74 <vector185>:
  108b74:	6a 00                	push   $0x0
  108b76:	68 b9 00 00 00       	push   $0xb9
  108b7b:	e9 f4 f3 ff ff       	jmp    107f74 <alltraps>

00108b80 <vector186>:
  108b80:	6a 00                	push   $0x0
  108b82:	68 ba 00 00 00       	push   $0xba
  108b87:	e9 e8 f3 ff ff       	jmp    107f74 <alltraps>

00108b8c <vector187>:
  108b8c:	6a 00                	push   $0x0
  108b8e:	68 bb 00 00 00       	push   $0xbb
  108b93:	e9 dc f3 ff ff       	jmp    107f74 <alltraps>

00108b98 <vector188>:
  108b98:	6a 00                	push   $0x0
  108b9a:	68 bc 00 00 00       	push   $0xbc
  108b9f:	e9 d0 f3 ff ff       	jmp    107f74 <alltraps>

00108ba4 <vector189>:
  108ba4:	6a 00                	push   $0x0
  108ba6:	68 bd 00 00 00       	push   $0xbd
  108bab:	e9 c4 f3 ff ff       	jmp    107f74 <alltraps>

00108bb0 <vector190>:
  108bb0:	6a 00                	push   $0x0
  108bb2:	68 be 00 00 00       	push   $0xbe
  108bb7:	e9 b8 f3 ff ff       	jmp    107f74 <alltraps>

00108bbc <vector191>:
  108bbc:	6a 00                	push   $0x0
  108bbe:	68 bf 00 00 00       	push   $0xbf
  108bc3:	e9 ac f3 ff ff       	jmp    107f74 <alltraps>

00108bc8 <vector192>:
  108bc8:	6a 00                	push   $0x0
  108bca:	68 c0 00 00 00       	push   $0xc0
  108bcf:	e9 a0 f3 ff ff       	jmp    107f74 <alltraps>

00108bd4 <vector193>:
  108bd4:	6a 00                	push   $0x0
  108bd6:	68 c1 00 00 00       	push   $0xc1
  108bdb:	e9 94 f3 ff ff       	jmp    107f74 <alltraps>

00108be0 <vector194>:
  108be0:	6a 00                	push   $0x0
  108be2:	68 c2 00 00 00       	push   $0xc2
  108be7:	e9 88 f3 ff ff       	jmp    107f74 <alltraps>

00108bec <vector195>:
  108bec:	6a 00                	push   $0x0
  108bee:	68 c3 00 00 00       	push   $0xc3
  108bf3:	e9 7c f3 ff ff       	jmp    107f74 <alltraps>

00108bf8 <vector196>:
  108bf8:	6a 00                	push   $0x0
  108bfa:	68 c4 00 00 00       	push   $0xc4
  108bff:	e9 70 f3 ff ff       	jmp    107f74 <alltraps>

00108c04 <vector197>:
  108c04:	6a 00                	push   $0x0
  108c06:	68 c5 00 00 00       	push   $0xc5
  108c0b:	e9 64 f3 ff ff       	jmp    107f74 <alltraps>

00108c10 <vector198>:
  108c10:	6a 00                	push   $0x0
  108c12:	68 c6 00 00 00       	push   $0xc6
  108c17:	e9 58 f3 ff ff       	jmp    107f74 <alltraps>

00108c1c <vector199>:
  108c1c:	6a 00                	push   $0x0
  108c1e:	68 c7 00 00 00       	push   $0xc7
  108c23:	e9 4c f3 ff ff       	jmp    107f74 <alltraps>

00108c28 <vector200>:
  108c28:	6a 00                	push   $0x0
  108c2a:	68 c8 00 00 00       	push   $0xc8
  108c2f:	e9 40 f3 ff ff       	jmp    107f74 <alltraps>

00108c34 <vector201>:
  108c34:	6a 00                	push   $0x0
  108c36:	68 c9 00 00 00       	push   $0xc9
  108c3b:	e9 34 f3 ff ff       	jmp    107f74 <alltraps>

00108c40 <vector202>:
  108c40:	6a 00                	push   $0x0
  108c42:	68 ca 00 00 00       	push   $0xca
  108c47:	e9 28 f3 ff ff       	jmp    107f74 <alltraps>

00108c4c <vector203>:
  108c4c:	6a 00                	push   $0x0
  108c4e:	68 cb 00 00 00       	push   $0xcb
  108c53:	e9 1c f3 ff ff       	jmp    107f74 <alltraps>

00108c58 <vector204>:
  108c58:	6a 00                	push   $0x0
  108c5a:	68 cc 00 00 00       	push   $0xcc
  108c5f:	e9 10 f3 ff ff       	jmp    107f74 <alltraps>

00108c64 <vector205>:
  108c64:	6a 00                	push   $0x0
  108c66:	68 cd 00 00 00       	push   $0xcd
  108c6b:	e9 04 f3 ff ff       	jmp    107f74 <alltraps>

00108c70 <vector206>:
  108c70:	6a 00                	push   $0x0
  108c72:	68 ce 00 00 00       	push   $0xce
  108c77:	e9 f8 f2 ff ff       	jmp    107f74 <alltraps>

00108c7c <vector207>:
  108c7c:	6a 00                	push   $0x0
  108c7e:	68 cf 00 00 00       	push   $0xcf
  108c83:	e9 ec f2 ff ff       	jmp    107f74 <alltraps>

00108c88 <vector208>:
  108c88:	6a 00                	push   $0x0
  108c8a:	68 d0 00 00 00       	push   $0xd0
  108c8f:	e9 e0 f2 ff ff       	jmp    107f74 <alltraps>

00108c94 <vector209>:
  108c94:	6a 00                	push   $0x0
  108c96:	68 d1 00 00 00       	push   $0xd1
  108c9b:	e9 d4 f2 ff ff       	jmp    107f74 <alltraps>

00108ca0 <vector210>:
  108ca0:	6a 00                	push   $0x0
  108ca2:	68 d2 00 00 00       	push   $0xd2
  108ca7:	e9 c8 f2 ff ff       	jmp    107f74 <alltraps>

00108cac <vector211>:
  108cac:	6a 00                	push   $0x0
  108cae:	68 d3 00 00 00       	push   $0xd3
  108cb3:	e9 bc f2 ff ff       	jmp    107f74 <alltraps>

00108cb8 <vector212>:
  108cb8:	6a 00                	push   $0x0
  108cba:	68 d4 00 00 00       	push   $0xd4
  108cbf:	e9 b0 f2 ff ff       	jmp    107f74 <alltraps>

00108cc4 <vector213>:
  108cc4:	6a 00                	push   $0x0
  108cc6:	68 d5 00 00 00       	push   $0xd5
  108ccb:	e9 a4 f2 ff ff       	jmp    107f74 <alltraps>

00108cd0 <vector214>:
  108cd0:	6a 00                	push   $0x0
  108cd2:	68 d6 00 00 00       	push   $0xd6
  108cd7:	e9 98 f2 ff ff       	jmp    107f74 <alltraps>

00108cdc <vector215>:
  108cdc:	6a 00                	push   $0x0
  108cde:	68 d7 00 00 00       	push   $0xd7
  108ce3:	e9 8c f2 ff ff       	jmp    107f74 <alltraps>

00108ce8 <vector216>:
  108ce8:	6a 00                	push   $0x0
  108cea:	68 d8 00 00 00       	push   $0xd8
  108cef:	e9 80 f2 ff ff       	jmp    107f74 <alltraps>

00108cf4 <vector217>:
  108cf4:	6a 00                	push   $0x0
  108cf6:	68 d9 00 00 00       	push   $0xd9
  108cfb:	e9 74 f2 ff ff       	jmp    107f74 <alltraps>

00108d00 <vector218>:
  108d00:	6a 00                	push   $0x0
  108d02:	68 da 00 00 00       	push   $0xda
  108d07:	e9 68 f2 ff ff       	jmp    107f74 <alltraps>

00108d0c <vector219>:
  108d0c:	6a 00                	push   $0x0
  108d0e:	68 db 00 00 00       	push   $0xdb
  108d13:	e9 5c f2 ff ff       	jmp    107f74 <alltraps>

00108d18 <vector220>:
  108d18:	6a 00                	push   $0x0
  108d1a:	68 dc 00 00 00       	push   $0xdc
  108d1f:	e9 50 f2 ff ff       	jmp    107f74 <alltraps>

00108d24 <vector221>:
  108d24:	6a 00                	push   $0x0
  108d26:	68 dd 00 00 00       	push   $0xdd
  108d2b:	e9 44 f2 ff ff       	jmp    107f74 <alltraps>

00108d30 <vector222>:
  108d30:	6a 00                	push   $0x0
  108d32:	68 de 00 00 00       	push   $0xde
  108d37:	e9 38 f2 ff ff       	jmp    107f74 <alltraps>

00108d3c <vector223>:
  108d3c:	6a 00                	push   $0x0
  108d3e:	68 df 00 00 00       	push   $0xdf
  108d43:	e9 2c f2 ff ff       	jmp    107f74 <alltraps>

00108d48 <vector224>:
  108d48:	6a 00                	push   $0x0
  108d4a:	68 e0 00 00 00       	push   $0xe0
  108d4f:	e9 20 f2 ff ff       	jmp    107f74 <alltraps>

00108d54 <vector225>:
  108d54:	6a 00                	push   $0x0
  108d56:	68 e1 00 00 00       	push   $0xe1
  108d5b:	e9 14 f2 ff ff       	jmp    107f74 <alltraps>

00108d60 <vector226>:
  108d60:	6a 00                	push   $0x0
  108d62:	68 e2 00 00 00       	push   $0xe2
  108d67:	e9 08 f2 ff ff       	jmp    107f74 <alltraps>

00108d6c <vector227>:
  108d6c:	6a 00                	push   $0x0
  108d6e:	68 e3 00 00 00       	push   $0xe3
  108d73:	e9 fc f1 ff ff       	jmp    107f74 <alltraps>

00108d78 <vector228>:
  108d78:	6a 00                	push   $0x0
  108d7a:	68 e4 00 00 00       	push   $0xe4
  108d7f:	e9 f0 f1 ff ff       	jmp    107f74 <alltraps>

00108d84 <vector229>:
  108d84:	6a 00                	push   $0x0
  108d86:	68 e5 00 00 00       	push   $0xe5
  108d8b:	e9 e4 f1 ff ff       	jmp    107f74 <alltraps>

00108d90 <vector230>:
  108d90:	6a 00                	push   $0x0
  108d92:	68 e6 00 00 00       	push   $0xe6
  108d97:	e9 d8 f1 ff ff       	jmp    107f74 <alltraps>

00108d9c <vector231>:
  108d9c:	6a 00                	push   $0x0
  108d9e:	68 e7 00 00 00       	push   $0xe7
  108da3:	e9 cc f1 ff ff       	jmp    107f74 <alltraps>

00108da8 <vector232>:
  108da8:	6a 00                	push   $0x0
  108daa:	68 e8 00 00 00       	push   $0xe8
  108daf:	e9 c0 f1 ff ff       	jmp    107f74 <alltraps>

00108db4 <vector233>:
  108db4:	6a 00                	push   $0x0
  108db6:	68 e9 00 00 00       	push   $0xe9
  108dbb:	e9 b4 f1 ff ff       	jmp    107f74 <alltraps>

00108dc0 <vector234>:
  108dc0:	6a 00                	push   $0x0
  108dc2:	68 ea 00 00 00       	push   $0xea
  108dc7:	e9 a8 f1 ff ff       	jmp    107f74 <alltraps>

00108dcc <vector235>:
  108dcc:	6a 00                	push   $0x0
  108dce:	68 eb 00 00 00       	push   $0xeb
  108dd3:	e9 9c f1 ff ff       	jmp    107f74 <alltraps>

00108dd8 <vector236>:
  108dd8:	6a 00                	push   $0x0
  108dda:	68 ec 00 00 00       	push   $0xec
  108ddf:	e9 90 f1 ff ff       	jmp    107f74 <alltraps>

00108de4 <vector237>:
  108de4:	6a 00                	push   $0x0
  108de6:	68 ed 00 00 00       	push   $0xed
  108deb:	e9 84 f1 ff ff       	jmp    107f74 <alltraps>

00108df0 <vector238>:
  108df0:	6a 00                	push   $0x0
  108df2:	68 ee 00 00 00       	push   $0xee
  108df7:	e9 78 f1 ff ff       	jmp    107f74 <alltraps>

00108dfc <vector239>:
  108dfc:	6a 00                	push   $0x0
  108dfe:	68 ef 00 00 00       	push   $0xef
  108e03:	e9 6c f1 ff ff       	jmp    107f74 <alltraps>

00108e08 <vector240>:
  108e08:	6a 00                	push   $0x0
  108e0a:	68 f0 00 00 00       	push   $0xf0
  108e0f:	e9 60 f1 ff ff       	jmp    107f74 <alltraps>

00108e14 <vector241>:
  108e14:	6a 00                	push   $0x0
  108e16:	68 f1 00 00 00       	push   $0xf1
  108e1b:	e9 54 f1 ff ff       	jmp    107f74 <alltraps>

00108e20 <vector242>:
  108e20:	6a 00                	push   $0x0
  108e22:	68 f2 00 00 00       	push   $0xf2
  108e27:	e9 48 f1 ff ff       	jmp    107f74 <alltraps>

00108e2c <vector243>:
  108e2c:	6a 00                	push   $0x0
  108e2e:	68 f3 00 00 00       	push   $0xf3
  108e33:	e9 3c f1 ff ff       	jmp    107f74 <alltraps>

00108e38 <vector244>:
  108e38:	6a 00                	push   $0x0
  108e3a:	68 f4 00 00 00       	push   $0xf4
  108e3f:	e9 30 f1 ff ff       	jmp    107f74 <alltraps>

00108e44 <vector245>:
  108e44:	6a 00                	push   $0x0
  108e46:	68 f5 00 00 00       	push   $0xf5
  108e4b:	e9 24 f1 ff ff       	jmp    107f74 <alltraps>

00108e50 <vector246>:
  108e50:	6a 00                	push   $0x0
  108e52:	68 f6 00 00 00       	push   $0xf6
  108e57:	e9 18 f1 ff ff       	jmp    107f74 <alltraps>

00108e5c <vector247>:
  108e5c:	6a 00                	push   $0x0
  108e5e:	68 f7 00 00 00       	push   $0xf7
  108e63:	e9 0c f1 ff ff       	jmp    107f74 <alltraps>

00108e68 <vector248>:
  108e68:	6a 00                	push   $0x0
  108e6a:	68 f8 00 00 00       	push   $0xf8
  108e6f:	e9 00 f1 ff ff       	jmp    107f74 <alltraps>

00108e74 <vector249>:
  108e74:	6a 00                	push   $0x0
  108e76:	68 f9 00 00 00       	push   $0xf9
  108e7b:	e9 f4 f0 ff ff       	jmp    107f74 <alltraps>

00108e80 <vector250>:
  108e80:	6a 00                	push   $0x0
  108e82:	68 fa 00 00 00       	push   $0xfa
  108e87:	e9 e8 f0 ff ff       	jmp    107f74 <alltraps>

00108e8c <vector251>:
  108e8c:	6a 00                	push   $0x0
  108e8e:	68 fb 00 00 00       	push   $0xfb
  108e93:	e9 dc f0 ff ff       	jmp    107f74 <alltraps>

00108e98 <vector252>:
  108e98:	6a 00                	push   $0x0
  108e9a:	68 fc 00 00 00       	push   $0xfc
  108e9f:	e9 d0 f0 ff ff       	jmp    107f74 <alltraps>

00108ea4 <vector253>:
  108ea4:	6a 00                	push   $0x0
  108ea6:	68 fd 00 00 00       	push   $0xfd
  108eab:	e9 c4 f0 ff ff       	jmp    107f74 <alltraps>

00108eb0 <vector254>:
  108eb0:	6a 00                	push   $0x0
  108eb2:	68 fe 00 00 00       	push   $0xfe
  108eb7:	e9 b8 f0 ff ff       	jmp    107f74 <alltraps>

00108ebc <vector255>:
  108ebc:	6a 00                	push   $0x0
  108ebe:	68 ff 00 00 00       	push   $0xff
  108ec3:	e9 ac f0 ff ff       	jmp    107f74 <alltraps>
  108ec8:	90                   	nop    
  108ec9:	90                   	nop    
  108eca:	90                   	nop    
  108ecb:	90                   	nop    
  108ecc:	90                   	nop    
  108ecd:	90                   	nop    
  108ece:	90                   	nop    
  108ecf:	90                   	nop    

00108ed0 <pci_conf1_set_addr>:
pci_conf1_set_addr(uint32_t bus,
		   uint32_t dev,
		   uint32_t func,
		   uint32_t offset)
{
  108ed0:	55                   	push   %ebp
  108ed1:	89 e5                	mov    %esp,%ebp
  108ed3:	83 ec 28             	sub    $0x28,%esp
    assert(bus < 256);
  108ed6:	81 7d 08 ff 00 00 00 	cmpl   $0xff,0x8(%ebp)
  108edd:	76 24                	jbe    108f03 <pci_conf1_set_addr+0x33>
  108edf:	c7 44 24 0c 43 a8 11 	movl   $0x11a843,0xc(%esp)
  108ee6:	00 
  108ee7:	c7 44 24 08 33 00 00 	movl   $0x33,0x8(%esp)
  108eee:	00 
  108eef:	c7 44 24 04 4d a8 11 	movl   $0x11a84d,0x4(%esp)
  108ef6:	00 
  108ef7:	c7 04 24 30 a8 11 00 	movl   $0x11a830,(%esp)
  108efe:	e8 1d 0a 00 00       	call   109920 <__assert>
    assert(dev < 32);
  108f03:	83 7d 0c 1f          	cmpl   $0x1f,0xc(%ebp)
  108f07:	76 24                	jbe    108f2d <pci_conf1_set_addr+0x5d>
  108f09:	c7 44 24 0c 53 a8 11 	movl   $0x11a853,0xc(%esp)
  108f10:	00 
  108f11:	c7 44 24 08 34 00 00 	movl   $0x34,0x8(%esp)
  108f18:	00 
  108f19:	c7 44 24 04 4d a8 11 	movl   $0x11a84d,0x4(%esp)
  108f20:	00 
  108f21:	c7 04 24 30 a8 11 00 	movl   $0x11a830,(%esp)
  108f28:	e8 f3 09 00 00       	call   109920 <__assert>
    assert(func < 8);
  108f2d:	83 7d 10 07          	cmpl   $0x7,0x10(%ebp)
  108f31:	76 24                	jbe    108f57 <pci_conf1_set_addr+0x87>
  108f33:	c7 44 24 0c 5c a8 11 	movl   $0x11a85c,0xc(%esp)
  108f3a:	00 
  108f3b:	c7 44 24 08 35 00 00 	movl   $0x35,0x8(%esp)
  108f42:	00 
  108f43:	c7 44 24 04 4d a8 11 	movl   $0x11a84d,0x4(%esp)
  108f4a:	00 
  108f4b:	c7 04 24 30 a8 11 00 	movl   $0x11a830,(%esp)
  108f52:	e8 c9 09 00 00       	call   109920 <__assert>
    assert(offset < 256);
  108f57:	81 7d 14 ff 00 00 00 	cmpl   $0xff,0x14(%ebp)
  108f5e:	76 24                	jbe    108f84 <pci_conf1_set_addr+0xb4>
  108f60:	c7 44 24 0c 65 a8 11 	movl   $0x11a865,0xc(%esp)
  108f67:	00 
  108f68:	c7 44 24 08 36 00 00 	movl   $0x36,0x8(%esp)
  108f6f:	00 
  108f70:	c7 44 24 04 4d a8 11 	movl   $0x11a84d,0x4(%esp)
  108f77:	00 
  108f78:	c7 04 24 30 a8 11 00 	movl   $0x11a830,(%esp)
  108f7f:	e8 9c 09 00 00       	call   109920 <__assert>
    assert((offset & 0x3) == 0);
  108f84:	8b 45 14             	mov    0x14(%ebp),%eax
  108f87:	83 e0 03             	and    $0x3,%eax
  108f8a:	85 c0                	test   %eax,%eax
  108f8c:	74 24                	je     108fb2 <pci_conf1_set_addr+0xe2>
  108f8e:	c7 44 24 0c 72 a8 11 	movl   $0x11a872,0xc(%esp)
  108f95:	00 
  108f96:	c7 44 24 08 37 00 00 	movl   $0x37,0x8(%esp)
  108f9d:	00 
  108f9e:	c7 44 24 04 4d a8 11 	movl   $0x11a84d,0x4(%esp)
  108fa5:	00 
  108fa6:	c7 04 24 30 a8 11 00 	movl   $0x11a830,(%esp)
  108fad:	e8 6e 09 00 00       	call   109920 <__assert>

    uint32_t v = (1 << 31) |		// config-space
		 (bus << 16) | (dev << 11) | (func << 8) | (offset);
  108fb2:	8b 45 08             	mov    0x8(%ebp),%eax
  108fb5:	89 c2                	mov    %eax,%edx
  108fb7:	c1 e2 10             	shl    $0x10,%edx
  108fba:	8b 45 0c             	mov    0xc(%ebp),%eax
  108fbd:	c1 e0 0b             	shl    $0xb,%eax
  108fc0:	09 c2                	or     %eax,%edx
  108fc2:	8b 45 10             	mov    0x10(%ebp),%eax
  108fc5:	c1 e0 08             	shl    $0x8,%eax
  108fc8:	09 d0                	or     %edx,%eax
  108fca:	0b 45 14             	or     0x14(%ebp),%eax
  108fcd:	0d 00 00 00 80       	or     $0x80000000,%eax
  108fd2:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
    outl(pci_conf1_addr_ioport, v);
  108fd5:	a1 c8 ca 11 00       	mov    0x11cac8,%eax
  108fda:	0f b7 d0             	movzwl %ax,%edx
  108fdd:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  108fe0:	89 44 24 04          	mov    %eax,0x4(%esp)
  108fe4:	89 14 24             	mov    %edx,(%esp)
  108fe7:	e8 04 00 00 00       	call   108ff0 <outl>
}
  108fec:	c9                   	leave  
  108fed:	c3                   	ret    
  108fee:	89 f6                	mov    %esi,%esi

00108ff0 <outl>:
}

static inline void
outl(ushort port, uint data)
{
  108ff0:	55                   	push   %ebp
  108ff1:	89 e5                	mov    %esp,%ebp
  108ff3:	83 ec 04             	sub    $0x4,%esp
  108ff6:	8b 45 08             	mov    0x8(%ebp),%eax
  108ff9:	66 89 45 fc          	mov    %ax,0xfffffffc(%ebp)
    asm volatile("out %0,%1" : : "a" (data), "d" (port));
  108ffd:	8b 45 0c             	mov    0xc(%ebp),%eax
  109000:	0f b7 55 fc          	movzwl 0xfffffffc(%ebp),%edx
  109004:	ef                   	out    %eax,(%dx)
}
  109005:	c9                   	leave  
  109006:	c3                   	ret    
  109007:	89 f6                	mov    %esi,%esi
  109009:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00109010 <pci_conf_read>:

static uint32_t
pci_conf_read(struct pci_func *f, uint32_t off)
{
  109010:	55                   	push   %ebp
  109011:	89 e5                	mov    %esp,%ebp
  109013:	53                   	push   %ebx
  109014:	83 ec 14             	sub    $0x14,%esp
    pci_conf1_set_addr(f->bus->busno, f->dev, f->func, off);
  109017:	8b 45 08             	mov    0x8(%ebp),%eax
  10901a:	8b 48 08             	mov    0x8(%eax),%ecx
  10901d:	8b 45 08             	mov    0x8(%ebp),%eax
  109020:	8b 58 04             	mov    0x4(%eax),%ebx
  109023:	8b 45 08             	mov    0x8(%ebp),%eax
  109026:	8b 00                	mov    (%eax),%eax
  109028:	8b 50 04             	mov    0x4(%eax),%edx
  10902b:	8b 45 0c             	mov    0xc(%ebp),%eax
  10902e:	89 44 24 0c          	mov    %eax,0xc(%esp)
  109032:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  109036:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  10903a:	89 14 24             	mov    %edx,(%esp)
  10903d:	e8 8e fe ff ff       	call   108ed0 <pci_conf1_set_addr>
    return inl(pci_conf1_data_ioport);
  109042:	a1 cc ca 11 00       	mov    0x11cacc,%eax
  109047:	0f b7 c0             	movzwl %ax,%eax
  10904a:	89 04 24             	mov    %eax,(%esp)
  10904d:	e8 0e 00 00 00       	call   109060 <inl>
}
  109052:	83 c4 14             	add    $0x14,%esp
  109055:	5b                   	pop    %ebx
  109056:	5d                   	pop    %ebp
  109057:	c3                   	ret    
  109058:	90                   	nop    
  109059:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

00109060 <inl>:
}

static inline uint
inl(ushort port)
{
  109060:	55                   	push   %ebp
  109061:	89 e5                	mov    %esp,%ebp
  109063:	83 ec 14             	sub    $0x14,%esp
  109066:	8b 45 08             	mov    0x8(%ebp),%eax
  109069:	66 89 45 ec          	mov    %ax,0xffffffec(%ebp)
    uint data;

    asm volatile("in %1,%0" : "=a" (data) : "d" (port));
  10906d:	0f b7 55 ec          	movzwl 0xffffffec(%ebp),%edx
  109071:	ed                   	in     (%dx),%eax
  109072:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
    return data;
  109075:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
}
  109078:	c9                   	leave  
  109079:	c3                   	ret    
  10907a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

00109080 <pci_conf_write>:

static void
pci_conf_write(struct pci_func *f, uint32_t off, uint32_t v)
{
  109080:	55                   	push   %ebp
  109081:	89 e5                	mov    %esp,%ebp
  109083:	53                   	push   %ebx
  109084:	83 ec 14             	sub    $0x14,%esp
    pci_conf1_set_addr(f->bus->busno, f->dev, f->func, off);
  109087:	8b 45 08             	mov    0x8(%ebp),%eax
  10908a:	8b 48 08             	mov    0x8(%eax),%ecx
  10908d:	8b 45 08             	mov    0x8(%ebp),%eax
  109090:	8b 58 04             	mov    0x4(%eax),%ebx
  109093:	8b 45 08             	mov    0x8(%ebp),%eax
  109096:	8b 00                	mov    (%eax),%eax
  109098:	8b 50 04             	mov    0x4(%eax),%edx
  10909b:	8b 45 0c             	mov    0xc(%ebp),%eax
  10909e:	89 44 24 0c          	mov    %eax,0xc(%esp)
  1090a2:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  1090a6:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  1090aa:	89 14 24             	mov    %edx,(%esp)
  1090ad:	e8 1e fe ff ff       	call   108ed0 <pci_conf1_set_addr>
    outl(pci_conf1_data_ioport, v);
  1090b2:	a1 cc ca 11 00       	mov    0x11cacc,%eax
  1090b7:	0f b7 d0             	movzwl %ax,%edx
  1090ba:	8b 45 10             	mov    0x10(%ebp),%eax
  1090bd:	89 44 24 04          	mov    %eax,0x4(%esp)
  1090c1:	89 14 24             	mov    %edx,(%esp)
  1090c4:	e8 27 ff ff ff       	call   108ff0 <outl>
}
  1090c9:	83 c4 14             	add    $0x14,%esp
  1090cc:	5b                   	pop    %ebx
  1090cd:	5d                   	pop    %ebp
  1090ce:	c3                   	ret    
  1090cf:	90                   	nop    

001090d0 <pci_attach_match>:

static int __attribute__((warn_unused_result))
pci_attach_match(uint32_t key1, uint32_t key2,
		 struct pci_driver *list, struct pci_func *pcif)
{
  1090d0:	55                   	push   %ebp
  1090d1:	89 e5                	mov    %esp,%ebp
  1090d3:	83 ec 28             	sub    $0x28,%esp
    uint32_t i;

    for (i = 0; list[i].attachfn; i++) {
  1090d6:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)
  1090dd:	e9 af 00 00 00       	jmp    109191 <pci_attach_match+0xc1>
	if (list[i].key1 == key1 )
  1090e2:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  1090e5:	89 d0                	mov    %edx,%eax
  1090e7:	01 c0                	add    %eax,%eax
  1090e9:	01 d0                	add    %edx,%eax
  1090eb:	c1 e0 02             	shl    $0x2,%eax
  1090ee:	03 45 10             	add    0x10(%ebp),%eax
  1090f1:	8b 00                	mov    (%eax),%eax
  1090f3:	3b 45 08             	cmp    0x8(%ebp),%eax
  1090f6:	0f 85 91 00 00 00    	jne    10918d <pci_attach_match+0xbd>
        if ((list[i].key2 == key2) || (list[i].key2 == 0xffff)) {
  1090fc:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  1090ff:	89 d0                	mov    %edx,%eax
  109101:	01 c0                	add    %eax,%eax
  109103:	01 d0                	add    %edx,%eax
  109105:	c1 e0 02             	shl    $0x2,%eax
  109108:	03 45 10             	add    0x10(%ebp),%eax
  10910b:	8b 40 04             	mov    0x4(%eax),%eax
  10910e:	3b 45 0c             	cmp    0xc(%ebp),%eax
  109111:	74 19                	je     10912c <pci_attach_match+0x5c>
  109113:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  109116:	89 d0                	mov    %edx,%eax
  109118:	01 c0                	add    %eax,%eax
  10911a:	01 d0                	add    %edx,%eax
  10911c:	c1 e0 02             	shl    $0x2,%eax
  10911f:	03 45 10             	add    0x10(%ebp),%eax
  109122:	8b 40 04             	mov    0x4(%eax),%eax
  109125:	3d ff ff 00 00       	cmp    $0xffff,%eax
  10912a:	75 61                	jne    10918d <pci_attach_match+0xbd>
	        int r = list[i].attachfn(pcif);
  10912c:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  10912f:	89 d0                	mov    %edx,%eax
  109131:	01 c0                	add    %eax,%eax
  109133:	01 d0                	add    %edx,%eax
  109135:	c1 e0 02             	shl    $0x2,%eax
  109138:	03 45 10             	add    0x10(%ebp),%eax
  10913b:	8b 50 08             	mov    0x8(%eax),%edx
  10913e:	8b 45 14             	mov    0x14(%ebp),%eax
  109141:	89 04 24             	mov    %eax,(%esp)
  109144:	ff d2                	call   *%edx
  109146:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
	        if (r > 0)
  109149:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  10914d:	7e 08                	jle    109157 <pci_attach_match+0x87>
		        return r;
  10914f:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  109152:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  109155:	eb 5b                	jmp    1091b2 <pci_attach_match+0xe2>
	        if (r < 0)
  109157:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  10915b:	79 30                	jns    10918d <pci_attach_match+0xbd>
		///cprintf("pci_attach_match: attaching %x.%x (%p): %s\n",
		//	key1, key2, list[i].attachfn, e2s(r));
		        cprintf("pci_attach_match: attaching %x.%x (%p): SOME ERROR\n",
  10915d:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  109160:	89 d0                	mov    %edx,%eax
  109162:	01 c0                	add    %eax,%eax
  109164:	01 d0                	add    %edx,%eax
  109166:	c1 e0 02             	shl    $0x2,%eax
  109169:	03 45 10             	add    0x10(%ebp),%eax
  10916c:	8b 40 08             	mov    0x8(%eax),%eax
  10916f:	89 44 24 0c          	mov    %eax,0xc(%esp)
  109173:	8b 45 0c             	mov    0xc(%ebp),%eax
  109176:	89 44 24 08          	mov    %eax,0x8(%esp)
  10917a:	8b 45 08             	mov    0x8(%ebp),%eax
  10917d:	89 44 24 04          	mov    %eax,0x4(%esp)
  109181:	c7 04 24 88 a8 11 00 	movl   $0x11a888,(%esp)
  109188:	e8 83 75 ff ff       	call   100710 <cprintf>
  10918d:	83 45 f8 01          	addl   $0x1,0xfffffff8(%ebp)
  109191:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  109194:	89 d0                	mov    %edx,%eax
  109196:	01 c0                	add    %eax,%eax
  109198:	01 d0                	add    %edx,%eax
  10919a:	c1 e0 02             	shl    $0x2,%eax
  10919d:	03 45 10             	add    0x10(%ebp),%eax
  1091a0:	8b 40 08             	mov    0x8(%eax),%eax
  1091a3:	85 c0                	test   %eax,%eax
  1091a5:	0f 85 37 ff ff ff    	jne    1090e2 <pci_attach_match+0x12>
			        key1, key2, list[i].attachfn);
	    }
    }

    return 0;
  1091ab:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  1091b2:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  1091b5:	c9                   	leave  
  1091b6:	c3                   	ret    
  1091b7:	89 f6                	mov    %esi,%esi
  1091b9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

001091c0 <pci_attach>:

static int
pci_attach(struct pci_func *f)
{
  1091c0:	55                   	push   %ebp
  1091c1:	89 e5                	mov    %esp,%ebp
  1091c3:	83 ec 18             	sub    $0x18,%esp
    return
  1091c6:	8b 45 08             	mov    0x8(%ebp),%eax
  1091c9:	8b 40 10             	mov    0x10(%eax),%eax
  1091cc:	c1 e8 10             	shr    $0x10,%eax
  1091cf:	0f b6 c8             	movzbl %al,%ecx
  1091d2:	8b 45 08             	mov    0x8(%ebp),%eax
  1091d5:	8b 40 10             	mov    0x10(%eax),%eax
  1091d8:	c1 e8 18             	shr    $0x18,%eax
  1091db:	0f b6 d0             	movzbl %al,%edx
  1091de:	8b 45 08             	mov    0x8(%ebp),%eax
  1091e1:	89 44 24 0c          	mov    %eax,0xc(%esp)
  1091e5:	c7 44 24 08 e0 ca 11 	movl   $0x11cae0,0x8(%esp)
  1091ec:	00 
  1091ed:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1091f1:	89 14 24             	mov    %edx,(%esp)
  1091f4:	e8 d7 fe ff ff       	call   1090d0 <pci_attach_match>
  1091f9:	85 c0                	test   %eax,%eax
  1091fb:	75 34                	jne    109231 <pci_attach+0x71>
  1091fd:	8b 45 08             	mov    0x8(%ebp),%eax
  109200:	8b 40 0c             	mov    0xc(%eax),%eax
  109203:	c1 e8 10             	shr    $0x10,%eax
  109206:	0f b7 c8             	movzwl %ax,%ecx
  109209:	8b 45 08             	mov    0x8(%ebp),%eax
  10920c:	8b 40 0c             	mov    0xc(%eax),%eax
  10920f:	0f b7 d0             	movzwl %ax,%edx
  109212:	8b 45 08             	mov    0x8(%ebp),%eax
  109215:	89 44 24 0c          	mov    %eax,0xc(%esp)
  109219:	c7 44 24 08 1c cb 11 	movl   $0x11cb1c,0x8(%esp)
  109220:	00 
  109221:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  109225:	89 14 24             	mov    %edx,(%esp)
  109228:	e8 a3 fe ff ff       	call   1090d0 <pci_attach_match>
  10922d:	85 c0                	test   %eax,%eax
  10922f:	74 09                	je     10923a <pci_attach+0x7a>
  109231:	c7 45 fc 01 00 00 00 	movl   $0x1,0xfffffffc(%ebp)
  109238:	eb 07                	jmp    109241 <pci_attach+0x81>
  10923a:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
  109241:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
	pci_attach_match(PCI_CLASS(f->dev_class), PCI_SUBCLASS(f->dev_class),
			 &pci_attach_class[0], f) ||
	pci_attach_match(PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
			 &pci_attach_vendor[0], f);
}
  109244:	c9                   	leave  
  109245:	c3                   	ret    
  109246:	8d 76 00             	lea    0x0(%esi),%esi
  109249:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00109250 <pci_scan_bus>:

static int 
pci_scan_bus(struct pci_bus *bus)
{
  109250:	55                   	push   %ebp
  109251:	89 e5                	mov    %esp,%ebp
  109253:	57                   	push   %edi
  109254:	56                   	push   %esi
  109255:	53                   	push   %ebx
  109256:	81 ec 2c 01 00 00    	sub    $0x12c,%esp
    int totaldev = 0;
  10925c:	c7 45 e8 00 00 00 00 	movl   $0x0,0xffffffe8(%ebp)
    struct pci_func df;
    memset(&df, 0, sizeof(df));
  109263:	c7 44 24 08 48 00 00 	movl   $0x48,0x8(%esp)
  10926a:	00 
  10926b:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  109272:	00 
  109273:	8d 45 a0             	lea    0xffffffa0(%ebp),%eax
  109276:	89 04 24             	mov    %eax,(%esp)
  109279:	e8 52 cc ff ff       	call   105ed0 <memset>
    df.bus = bus;
  10927e:	8b 45 08             	mov    0x8(%ebp),%eax
  109281:	89 45 a0             	mov    %eax,0xffffffa0(%ebp)

    for (df.dev = 0; df.dev < 32; df.dev++) {
  109284:	c7 45 a4 00 00 00 00 	movl   $0x0,0xffffffa4(%ebp)
  10928b:	e9 f1 01 00 00       	jmp    109481 <pci_scan_bus+0x231>
	uint32_t bhlc = pci_conf_read(&df, PCI_BHLC_REG);
  109290:	c7 44 24 04 0c 00 00 	movl   $0xc,0x4(%esp)
  109297:	00 
  109298:	8d 45 a0             	lea    0xffffffa0(%ebp),%eax
  10929b:	89 04 24             	mov    %eax,(%esp)
  10929e:	e8 6d fd ff ff       	call   109010 <pci_conf_read>
  1092a3:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
	if (PCI_HDRTYPE_TYPE(bhlc) > 1)	    // Unsupported or no device
  1092a6:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  1092a9:	c1 e8 10             	shr    $0x10,%eax
  1092ac:	83 e0 7f             	and    $0x7f,%eax
  1092af:	83 f8 01             	cmp    $0x1,%eax
  1092b2:	0f 87 c0 01 00 00    	ja     109478 <pci_scan_bus+0x228>
	    continue;

	totaldev++;
  1092b8:	83 45 e8 01          	addl   $0x1,0xffffffe8(%ebp)

	struct pci_func f = df;
  1092bc:	8d 8d 58 ff ff ff    	lea    0xffffff58(%ebp),%ecx
  1092c2:	8d 55 a0             	lea    0xffffffa0(%ebp),%edx
  1092c5:	b8 48 00 00 00       	mov    $0x48,%eax
  1092ca:	89 44 24 08          	mov    %eax,0x8(%esp)
  1092ce:	89 54 24 04          	mov    %edx,0x4(%esp)
  1092d2:	89 0c 24             	mov    %ecx,(%esp)
  1092d5:	e8 b6 cb ff ff       	call   105e90 <memcpy>
	for (f.func = 0; f.func < (PCI_HDRTYPE_MULTIFN(bhlc) ? 8 : 1);
  1092da:	c7 85 60 ff ff ff 00 	movl   $0x0,0xffffff60(%ebp)
  1092e1:	00 00 00 
  1092e4:	e9 4f 01 00 00       	jmp    109438 <pci_scan_bus+0x1e8>
			 f.func++) {
	    struct pci_func af = f;
  1092e9:	8d 8d 10 ff ff ff    	lea    0xffffff10(%ebp),%ecx
  1092ef:	8d 95 58 ff ff ff    	lea    0xffffff58(%ebp),%edx
  1092f5:	b8 48 00 00 00       	mov    $0x48,%eax
  1092fa:	89 44 24 08          	mov    %eax,0x8(%esp)
  1092fe:	89 54 24 04          	mov    %edx,0x4(%esp)
  109302:	89 0c 24             	mov    %ecx,(%esp)
  109305:	e8 86 cb ff ff       	call   105e90 <memcpy>

	    af.dev_id = pci_conf_read(&f, PCI_ID_REG);
  10930a:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  109311:	00 
  109312:	8d 85 58 ff ff ff    	lea    0xffffff58(%ebp),%eax
  109318:	89 04 24             	mov    %eax,(%esp)
  10931b:	e8 f0 fc ff ff       	call   109010 <pci_conf_read>
  109320:	89 85 1c ff ff ff    	mov    %eax,0xffffff1c(%ebp)
	    if (PCI_VENDOR(af.dev_id) == 0xffff)
  109326:	8b 85 1c ff ff ff    	mov    0xffffff1c(%ebp),%eax
  10932c:	25 ff ff 00 00       	and    $0xffff,%eax
  109331:	3d ff ff 00 00       	cmp    $0xffff,%eax
  109336:	0f 84 ed 00 00 00    	je     109429 <pci_scan_bus+0x1d9>
		continue;

	    uint32_t intr = pci_conf_read(&af, PCI_INTERRUPT_REG);
  10933c:	c7 44 24 04 3c 00 00 	movl   $0x3c,0x4(%esp)
  109343:	00 
  109344:	8d 85 10 ff ff ff    	lea    0xffffff10(%ebp),%eax
  10934a:	89 04 24             	mov    %eax,(%esp)
  10934d:	e8 be fc ff ff       	call   109010 <pci_conf_read>
  109352:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
	    af.irq_line = PCI_INTERRUPT_LINE(intr);
  109355:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  109358:	88 85 54 ff ff ff    	mov    %al,0xffffff54(%ebp)

	    af.dev_class = pci_conf_read(&af, PCI_CLASS_REG);
  10935e:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
  109365:	00 
  109366:	8d 85 10 ff ff ff    	lea    0xffffff10(%ebp),%eax
  10936c:	89 04 24             	mov    %eax,(%esp)
  10936f:	e8 9c fc ff ff       	call   109010 <pci_conf_read>
  109374:	89 85 20 ff ff ff    	mov    %eax,0xffffff20(%ebp)
	    if (pci_show_devs)
  10937a:	a1 c0 ca 11 00       	mov    0x11cac0,%eax
  10937f:	85 c0                	test   %eax,%eax
  109381:	0f 84 94 00 00 00    	je     10941b <pci_scan_bus+0x1cb>
		cprintf("PCI: %02x:%02x.%d: %04x:%04x: class %x.%x irq %d\n",
  109387:	0f b6 85 54 ff ff ff 	movzbl 0xffffff54(%ebp),%eax
  10938e:	0f b6 f8             	movzbl %al,%edi
  109391:	8b 85 20 ff ff ff    	mov    0xffffff20(%ebp),%eax
  109397:	c1 e8 10             	shr    $0x10,%eax
  10939a:	25 ff 00 00 00       	and    $0xff,%eax
  10939f:	89 85 f4 fe ff ff    	mov    %eax,0xfffffef4(%ebp)
  1093a5:	8b 85 20 ff ff ff    	mov    0xffffff20(%ebp),%eax
  1093ab:	c1 e8 18             	shr    $0x18,%eax
  1093ae:	25 ff 00 00 00       	and    $0xff,%eax
  1093b3:	89 85 f8 fe ff ff    	mov    %eax,0xfffffef8(%ebp)
  1093b9:	8b 85 1c ff ff ff    	mov    0xffffff1c(%ebp),%eax
  1093bf:	c1 e8 10             	shr    $0x10,%eax
  1093c2:	0f b7 d0             	movzwl %ax,%edx
  1093c5:	8b 85 1c ff ff ff    	mov    0xffffff1c(%ebp),%eax
  1093cb:	0f b7 c8             	movzwl %ax,%ecx
  1093ce:	8b 9d 18 ff ff ff    	mov    0xffffff18(%ebp),%ebx
  1093d4:	8b b5 14 ff ff ff    	mov    0xffffff14(%ebp),%esi
  1093da:	8b 85 10 ff ff ff    	mov    0xffffff10(%ebp),%eax
  1093e0:	8b 40 04             	mov    0x4(%eax),%eax
  1093e3:	89 7c 24 20          	mov    %edi,0x20(%esp)
  1093e7:	8b bd f4 fe ff ff    	mov    0xfffffef4(%ebp),%edi
  1093ed:	89 7c 24 1c          	mov    %edi,0x1c(%esp)
  1093f1:	8b bd f8 fe ff ff    	mov    0xfffffef8(%ebp),%edi
  1093f7:	89 7c 24 18          	mov    %edi,0x18(%esp)
  1093fb:	89 54 24 14          	mov    %edx,0x14(%esp)
  1093ff:	89 4c 24 10          	mov    %ecx,0x10(%esp)
  109403:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
  109407:	89 74 24 08          	mov    %esi,0x8(%esp)
  10940b:	89 44 24 04          	mov    %eax,0x4(%esp)
  10940f:	c7 04 24 bc a8 11 00 	movl   $0x11a8bc,(%esp)
  109416:	e8 f5 72 ff ff       	call   100710 <cprintf>
			af.bus->busno, af.dev, af.func,
			PCI_VENDOR(af.dev_id), PCI_PRODUCT(af.dev_id),
			PCI_CLASS(af.dev_class), PCI_SUBCLASS(af.dev_class),
			af.irq_line);

	    pci_attach(&af);
  10941b:	8d 85 10 ff ff ff    	lea    0xffffff10(%ebp),%eax
  109421:	89 04 24             	mov    %eax,(%esp)
  109424:	e8 97 fd ff ff       	call   1091c0 <pci_attach>
  109429:	8b 85 60 ff ff ff    	mov    0xffffff60(%ebp),%eax
  10942f:	83 c0 01             	add    $0x1,%eax
  109432:	89 85 60 ff ff ff    	mov    %eax,0xffffff60(%ebp)
  109438:	8b 85 60 ff ff ff    	mov    0xffffff60(%ebp),%eax
  10943e:	89 85 fc fe ff ff    	mov    %eax,0xfffffefc(%ebp)
  109444:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  109447:	25 00 00 80 00       	and    $0x800000,%eax
  10944c:	85 c0                	test   %eax,%eax
  10944e:	74 0c                	je     10945c <pci_scan_bus+0x20c>
  109450:	c7 85 00 ff ff ff 08 	movl   $0x8,0xffffff00(%ebp)
  109457:	00 00 00 
  10945a:	eb 0a                	jmp    109466 <pci_scan_bus+0x216>
  10945c:	c7 85 00 ff ff ff 01 	movl   $0x1,0xffffff00(%ebp)
  109463:	00 00 00 
  109466:	8b bd 00 ff ff ff    	mov    0xffffff00(%ebp),%edi
  10946c:	39 bd fc fe ff ff    	cmp    %edi,0xfffffefc(%ebp)
  109472:	0f 82 71 fe ff ff    	jb     1092e9 <pci_scan_bus+0x99>
  109478:	8b 45 a4             	mov    0xffffffa4(%ebp),%eax
  10947b:	83 c0 01             	add    $0x1,%eax
  10947e:	89 45 a4             	mov    %eax,0xffffffa4(%ebp)
  109481:	8b 45 a4             	mov    0xffffffa4(%ebp),%eax
  109484:	83 f8 1f             	cmp    $0x1f,%eax
  109487:	0f 86 03 fe ff ff    	jbe    109290 <pci_scan_bus+0x40>
	}
    }

    return totaldev;
  10948d:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
}
  109490:	81 c4 2c 01 00 00    	add    $0x12c,%esp
  109496:	5b                   	pop    %ebx
  109497:	5e                   	pop    %esi
  109498:	5f                   	pop    %edi
  109499:	5d                   	pop    %ebp
  10949a:	c3                   	ret    
  10949b:	90                   	nop    
  10949c:	8d 74 26 00          	lea    0x0(%esi),%esi

001094a0 <pci_net_ether_attach>:

static int
pci_net_ether_attach(struct pci_func *pcif)
{	
  1094a0:	55                   	push   %ebp
  1094a1:	89 e5                	mov    %esp,%ebp
  1094a3:	56                   	push   %esi
  1094a4:	53                   	push   %ebx
  1094a5:	83 ec 20             	sub    $0x20,%esp
    cprintf("PCI: %02x:%02x.%d: Network (ethernet) %04x:%04x\n",
  1094a8:	8b 45 08             	mov    0x8(%ebp),%eax
  1094ab:	8b 40 0c             	mov    0xc(%eax),%eax
  1094ae:	c1 e8 10             	shr    $0x10,%eax
  1094b1:	0f b7 f0             	movzwl %ax,%esi
  1094b4:	8b 45 08             	mov    0x8(%ebp),%eax
  1094b7:	8b 40 0c             	mov    0xc(%eax),%eax
  1094ba:	0f b7 d0             	movzwl %ax,%edx
  1094bd:	8b 45 08             	mov    0x8(%ebp),%eax
  1094c0:	8b 48 08             	mov    0x8(%eax),%ecx
  1094c3:	8b 45 08             	mov    0x8(%ebp),%eax
  1094c6:	8b 58 04             	mov    0x4(%eax),%ebx
  1094c9:	8b 45 08             	mov    0x8(%ebp),%eax
  1094cc:	8b 00                	mov    (%eax),%eax
  1094ce:	8b 40 04             	mov    0x4(%eax),%eax
  1094d1:	89 74 24 14          	mov    %esi,0x14(%esp)
  1094d5:	89 54 24 10          	mov    %edx,0x10(%esp)
  1094d9:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
  1094dd:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  1094e1:	89 44 24 04          	mov    %eax,0x4(%esp)
  1094e5:	c7 04 24 f0 a8 11 00 	movl   $0x11a8f0,(%esp)
  1094ec:	e8 1f 72 ff ff       	call   100710 <cprintf>
		pcif->bus->busno, pcif->dev, pcif->func,
        PCI_VENDOR(pcif->dev_id), PCI_PRODUCT(pcif->dev_id));
    return 0;
  1094f1:	b8 00 00 00 00       	mov    $0x0,%eax
}
  1094f6:	83 c4 20             	add    $0x20,%esp
  1094f9:	5b                   	pop    %ebx
  1094fa:	5e                   	pop    %esi
  1094fb:	5d                   	pop    %ebp
  1094fc:	c3                   	ret    
  1094fd:	8d 76 00             	lea    0x0(%esi),%esi

00109500 <pci_bridge_attach>:

static int
pci_bridge_attach(struct pci_func *pcif)
{
  109500:	55                   	push   %ebp
  109501:	89 e5                	mov    %esp,%ebp
  109503:	56                   	push   %esi
  109504:	53                   	push   %ebx
  109505:	83 ec 20             	sub    $0x20,%esp
    cprintf("PCI: %02x:%02x.%d: Bridge %04x:%04x\n",
  109508:	8b 45 08             	mov    0x8(%ebp),%eax
  10950b:	8b 40 0c             	mov    0xc(%eax),%eax
  10950e:	c1 e8 10             	shr    $0x10,%eax
  109511:	0f b7 f0             	movzwl %ax,%esi
  109514:	8b 45 08             	mov    0x8(%ebp),%eax
  109517:	8b 40 0c             	mov    0xc(%eax),%eax
  10951a:	0f b7 d0             	movzwl %ax,%edx
  10951d:	8b 45 08             	mov    0x8(%ebp),%eax
  109520:	8b 48 08             	mov    0x8(%eax),%ecx
  109523:	8b 45 08             	mov    0x8(%ebp),%eax
  109526:	8b 58 04             	mov    0x4(%eax),%ebx
  109529:	8b 45 08             	mov    0x8(%ebp),%eax
  10952c:	8b 00                	mov    (%eax),%eax
  10952e:	8b 40 04             	mov    0x4(%eax),%eax
  109531:	89 74 24 14          	mov    %esi,0x14(%esp)
  109535:	89 54 24 10          	mov    %edx,0x10(%esp)
  109539:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
  10953d:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  109541:	89 44 24 04          	mov    %eax,0x4(%esp)
  109545:	c7 04 24 24 a9 11 00 	movl   $0x11a924,(%esp)
  10954c:	e8 bf 71 ff ff       	call   100710 <cprintf>
		pcif->bus->busno, pcif->dev, pcif->func,
        PCI_VENDOR(pcif->dev_id), PCI_PRODUCT(pcif->dev_id));
    return 0;
  109551:	b8 00 00 00 00       	mov    $0x0,%eax
}
  109556:	83 c4 20             	add    $0x20,%esp
  109559:	5b                   	pop    %ebx
  10955a:	5e                   	pop    %esi
  10955b:	5d                   	pop    %ebp
  10955c:	c3                   	ret    
  10955d:	8d 76 00             	lea    0x0(%esi),%esi

00109560 <pci_bridge_pci_attach>:

static int
pci_bridge_pci_attach(struct pci_func *pcif)
{
  109560:	55                   	push   %ebp
  109561:	89 e5                	mov    %esp,%ebp
  109563:	56                   	push   %esi
  109564:	53                   	push   %ebx
  109565:	83 ec 30             	sub    $0x30,%esp
    uint32_t ioreg  = pci_conf_read(pcif, PCI_BRIDGE_STATIO_REG);
  109568:	c7 44 24 04 1c 00 00 	movl   $0x1c,0x4(%esp)
  10956f:	00 
  109570:	8b 45 08             	mov    0x8(%ebp),%eax
  109573:	89 04 24             	mov    %eax,(%esp)
  109576:	e8 95 fa ff ff       	call   109010 <pci_conf_read>
  10957b:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
    uint32_t busreg = pci_conf_read(pcif, PCI_BRIDGE_BUS_REG);
  10957e:	c7 44 24 04 18 00 00 	movl   $0x18,0x4(%esp)
  109585:	00 
  109586:	8b 45 08             	mov    0x8(%ebp),%eax
  109589:	89 04 24             	mov    %eax,(%esp)
  10958c:	e8 7f fa ff ff       	call   109010 <pci_conf_read>
  109591:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)

    if (PCI_BRIDGE_IO_32BITS(ioreg)) {
  109594:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  109597:	83 e0 0f             	and    $0xf,%eax
  10959a:	83 f8 01             	cmp    $0x1,%eax
  10959d:	75 38                	jne    1095d7 <pci_bridge_pci_attach+0x77>
	cprintf("PCI: %02x:%02x.%d: 32-bit bridge IO not supported.\n",
  10959f:	8b 45 08             	mov    0x8(%ebp),%eax
  1095a2:	8b 48 08             	mov    0x8(%eax),%ecx
  1095a5:	8b 45 08             	mov    0x8(%ebp),%eax
  1095a8:	8b 50 04             	mov    0x4(%eax),%edx
  1095ab:	8b 45 08             	mov    0x8(%ebp),%eax
  1095ae:	8b 00                	mov    (%eax),%eax
  1095b0:	8b 40 04             	mov    0x4(%eax),%eax
  1095b3:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
  1095b7:	89 54 24 08          	mov    %edx,0x8(%esp)
  1095bb:	89 44 24 04          	mov    %eax,0x4(%esp)
  1095bf:	c7 04 24 4c a9 11 00 	movl   $0x11a94c,(%esp)
  1095c6:	e8 45 71 ff ff       	call   100710 <cprintf>
		pcif->bus->busno, pcif->dev, pcif->func);
	return 0;
  1095cb:	c7 45 e4 00 00 00 00 	movl   $0x0,0xffffffe4(%ebp)
  1095d2:	e9 8a 00 00 00       	jmp    109661 <pci_bridge_pci_attach+0x101>
    }

    struct pci_bus nbus;
    memset(&nbus, 0, sizeof(nbus));
  1095d7:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  1095de:	00 
  1095df:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  1095e6:	00 
  1095e7:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
  1095ea:	89 04 24             	mov    %eax,(%esp)
  1095ed:	e8 de c8 ff ff       	call   105ed0 <memset>
    nbus.parent_bridge = pcif;
  1095f2:	8b 45 08             	mov    0x8(%ebp),%eax
  1095f5:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
    nbus.busno = (busreg >> PCI_BRIDGE_BUS_SECONDARY_SHIFT) & 0xff;
  1095f8:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  1095fb:	c1 e8 08             	shr    $0x8,%eax
  1095fe:	25 ff 00 00 00       	and    $0xff,%eax
  109603:	89 45 ec             	mov    %eax,0xffffffec(%ebp)

    if (pci_show_devs)
  109606:	a1 c0 ca 11 00       	mov    0x11cac0,%eax
  10960b:	85 c0                	test   %eax,%eax
  10960d:	74 40                	je     10964f <pci_bridge_pci_attach+0xef>
	cprintf("PCI: %02x:%02x.%d: bridge to PCI bus %d--%d\n",
  10960f:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  109612:	c1 e8 10             	shr    $0x10,%eax
  109615:	0f b6 d0             	movzbl %al,%edx
  109618:	8b 4d ec             	mov    0xffffffec(%ebp),%ecx
  10961b:	8b 45 08             	mov    0x8(%ebp),%eax
  10961e:	8b 58 08             	mov    0x8(%eax),%ebx
  109621:	8b 45 08             	mov    0x8(%ebp),%eax
  109624:	8b 70 04             	mov    0x4(%eax),%esi
  109627:	8b 45 08             	mov    0x8(%ebp),%eax
  10962a:	8b 00                	mov    (%eax),%eax
  10962c:	8b 40 04             	mov    0x4(%eax),%eax
  10962f:	89 54 24 14          	mov    %edx,0x14(%esp)
  109633:	89 4c 24 10          	mov    %ecx,0x10(%esp)
  109637:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
  10963b:	89 74 24 08          	mov    %esi,0x8(%esp)
  10963f:	89 44 24 04          	mov    %eax,0x4(%esp)
  109643:	c7 04 24 80 a9 11 00 	movl   $0x11a980,(%esp)
  10964a:	e8 c1 70 ff ff       	call   100710 <cprintf>
		pcif->bus->busno, pcif->dev, pcif->func,
		nbus.busno,
		(busreg >> PCI_BRIDGE_BUS_SUBORDINATE_SHIFT) & 0xff);

    pci_scan_bus(&nbus);
  10964f:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
  109652:	89 04 24             	mov    %eax,(%esp)
  109655:	e8 f6 fb ff ff       	call   109250 <pci_scan_bus>
    return 1;
  10965a:	c7 45 e4 01 00 00 00 	movl   $0x1,0xffffffe4(%ebp)
  109661:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
}
  109664:	83 c4 30             	add    $0x30,%esp
  109667:	5b                   	pop    %ebx
  109668:	5e                   	pop    %esi
  109669:	5d                   	pop    %ebp
  10966a:	c3                   	ret    
  10966b:	90                   	nop    
  10966c:	8d 74 26 00          	lea    0x0(%esi),%esi

00109670 <pci_display_attach>:

static int
pci_display_attach(struct pci_func *pcif)
{
  109670:	55                   	push   %ebp
  109671:	89 e5                	mov    %esp,%ebp
  109673:	56                   	push   %esi
  109674:	53                   	push   %ebx
  109675:	83 ec 20             	sub    $0x20,%esp
    cprintf("PCI: %02x:%02x.%d: Display %04x:%04x\n",
  109678:	8b 45 08             	mov    0x8(%ebp),%eax
  10967b:	8b 40 0c             	mov    0xc(%eax),%eax
  10967e:	c1 e8 10             	shr    $0x10,%eax
  109681:	0f b7 f0             	movzwl %ax,%esi
  109684:	8b 45 08             	mov    0x8(%ebp),%eax
  109687:	8b 40 0c             	mov    0xc(%eax),%eax
  10968a:	0f b7 d0             	movzwl %ax,%edx
  10968d:	8b 45 08             	mov    0x8(%ebp),%eax
  109690:	8b 48 08             	mov    0x8(%eax),%ecx
  109693:	8b 45 08             	mov    0x8(%ebp),%eax
  109696:	8b 58 04             	mov    0x4(%eax),%ebx
  109699:	8b 45 08             	mov    0x8(%ebp),%eax
  10969c:	8b 00                	mov    (%eax),%eax
  10969e:	8b 40 04             	mov    0x4(%eax),%eax
  1096a1:	89 74 24 14          	mov    %esi,0x14(%esp)
  1096a5:	89 54 24 10          	mov    %edx,0x10(%esp)
  1096a9:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
  1096ad:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  1096b1:	89 44 24 04          	mov    %eax,0x4(%esp)
  1096b5:	c7 04 24 b0 a9 11 00 	movl   $0x11a9b0,(%esp)
  1096bc:	e8 4f 70 ff ff       	call   100710 <cprintf>
		pcif->bus->busno, pcif->dev, pcif->func,
        PCI_VENDOR(pcif->dev_id), PCI_PRODUCT(pcif->dev_id));
    return 0;
  1096c1:	b8 00 00 00 00       	mov    $0x0,%eax
}
  1096c6:	83 c4 20             	add    $0x20,%esp
  1096c9:	5b                   	pop    %ebx
  1096ca:	5e                   	pop    %esi
  1096cb:	5d                   	pop    %ebp
  1096cc:	c3                   	ret    
  1096cd:	8d 76 00             	lea    0x0(%esi),%esi

001096d0 <pci_func_enable>:

// External PCI subsystem interface

void
pci_func_enable(struct pci_func *f)
{
  1096d0:	55                   	push   %ebp
  1096d1:	89 e5                	mov    %esp,%ebp
  1096d3:	57                   	push   %edi
  1096d4:	56                   	push   %esi
  1096d5:	53                   	push   %ebx
  1096d6:	83 ec 4c             	sub    $0x4c,%esp
    pci_conf_write(f, PCI_COMMAND_STATUS_REG,
  1096d9:	c7 44 24 08 07 00 00 	movl   $0x7,0x8(%esp)
  1096e0:	00 
  1096e1:	c7 44 24 04 04 00 00 	movl   $0x4,0x4(%esp)
  1096e8:	00 
  1096e9:	8b 45 08             	mov    0x8(%ebp),%eax
  1096ec:	89 04 24             	mov    %eax,(%esp)
  1096ef:	e8 8c f9 ff ff       	call   109080 <pci_conf_write>
		   PCI_COMMAND_IO_ENABLE |
		   PCI_COMMAND_MEM_ENABLE |
		   PCI_COMMAND_MASTER_ENABLE);

    uint32_t bar_width;
    uint32_t bar;
    for (bar = PCI_MAPREG_START; bar < PCI_MAPREG_END;
  1096f4:	c7 45 dc 10 00 00 00 	movl   $0x10,0xffffffdc(%ebp)
  1096fb:	e9 de 01 00 00       	jmp    1098de <pci_func_enable+0x20e>
	 bar += bar_width)
    {
	uint32_t oldv = pci_conf_read(f, bar);
  109700:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  109703:	89 44 24 04          	mov    %eax,0x4(%esp)
  109707:	8b 45 08             	mov    0x8(%ebp),%eax
  10970a:	89 04 24             	mov    %eax,(%esp)
  10970d:	e8 fe f8 ff ff       	call   109010 <pci_conf_read>
  109712:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)

	bar_width = 4;
  109715:	c7 45 d8 04 00 00 00 	movl   $0x4,0xffffffd8(%ebp)
	pci_conf_write(f, bar, 0xffffffff);
  10971c:	c7 44 24 08 ff ff ff 	movl   $0xffffffff,0x8(%esp)
  109723:	ff 
  109724:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  109727:	89 44 24 04          	mov    %eax,0x4(%esp)
  10972b:	8b 45 08             	mov    0x8(%ebp),%eax
  10972e:	89 04 24             	mov    %eax,(%esp)
  109731:	e8 4a f9 ff ff       	call   109080 <pci_conf_write>
	uint32_t rv = pci_conf_read(f, bar);
  109736:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  109739:	89 44 24 04          	mov    %eax,0x4(%esp)
  10973d:	8b 45 08             	mov    0x8(%ebp),%eax
  109740:	89 04 24             	mov    %eax,(%esp)
  109743:	e8 c8 f8 ff ff       	call   109010 <pci_conf_read>
  109748:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)

	if (rv == 0)
  10974b:	83 7d e4 00          	cmpl   $0x0,0xffffffe4(%ebp)
  10974f:	0f 84 83 01 00 00    	je     1098d8 <pci_func_enable+0x208>
	    continue;

	int regnum = PCI_MAPREG_NUM(bar);
  109755:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  109758:	83 e8 10             	sub    $0x10,%eax
  10975b:	c1 e8 02             	shr    $0x2,%eax
  10975e:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
	uint32_t base, size;
	if (PCI_MAPREG_TYPE(rv) == PCI_MAPREG_TYPE_MEM) {
  109761:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
  109764:	83 e0 01             	and    $0x1,%eax
  109767:	85 c0                	test   %eax,%eax
  109769:	75 58                	jne    1097c3 <pci_func_enable+0xf3>
	    if (PCI_MAPREG_MEM_TYPE(rv) == PCI_MAPREG_MEM_TYPE_64BIT)
  10976b:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
  10976e:	83 e0 06             	and    $0x6,%eax
  109771:	83 f8 04             	cmp    $0x4,%eax
  109774:	75 07                	jne    10977d <pci_func_enable+0xad>
		bar_width = 8;
  109776:	c7 45 d8 08 00 00 00 	movl   $0x8,0xffffffd8(%ebp)

	    size = PCI_MAPREG_MEM_SIZE(rv);
  10977d:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
  109780:	83 e0 f0             	and    $0xfffffff0,%eax
  109783:	f7 d8                	neg    %eax
  109785:	23 45 e4             	and    0xffffffe4(%ebp),%eax
  109788:	83 e0 f0             	and    $0xfffffff0,%eax
  10978b:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
	    base = PCI_MAPREG_MEM_ADDR(oldv);
  10978e:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  109791:	83 e0 f0             	and    $0xfffffff0,%eax
  109794:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
	    if (pci_show_addrs)
  109797:	a1 c4 ca 11 00       	mov    0x11cac4,%eax
  10979c:	85 c0                	test   %eax,%eax
  10979e:	74 67                	je     109807 <pci_func_enable+0x137>
		cprintf("  mem region %d: %d bytes at 0x%x\n",
  1097a0:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  1097a3:	89 44 24 0c          	mov    %eax,0xc(%esp)
  1097a7:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  1097aa:	89 44 24 08          	mov    %eax,0x8(%esp)
  1097ae:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  1097b1:	89 44 24 04          	mov    %eax,0x4(%esp)
  1097b5:	c7 04 24 d8 a9 11 00 	movl   $0x11a9d8,(%esp)
  1097bc:	e8 4f 6f ff ff       	call   100710 <cprintf>
  1097c1:	eb 44                	jmp    109807 <pci_func_enable+0x137>
			regnum, size, base);
	} else {
	    size = PCI_MAPREG_IO_SIZE(rv);
  1097c3:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
  1097c6:	83 e0 fc             	and    $0xfffffffc,%eax
  1097c9:	f7 d8                	neg    %eax
  1097cb:	23 45 e4             	and    0xffffffe4(%ebp),%eax
  1097ce:	83 e0 fc             	and    $0xfffffffc,%eax
  1097d1:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
	    base = PCI_MAPREG_IO_ADDR(oldv);
  1097d4:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  1097d7:	83 e0 fc             	and    $0xfffffffc,%eax
  1097da:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
	    if (pci_show_addrs)
  1097dd:	a1 c4 ca 11 00       	mov    0x11cac4,%eax
  1097e2:	85 c0                	test   %eax,%eax
  1097e4:	74 21                	je     109807 <pci_func_enable+0x137>
		cprintf("  io region %d: %d bytes at 0x%x\n",
  1097e6:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  1097e9:	89 44 24 0c          	mov    %eax,0xc(%esp)
  1097ed:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  1097f0:	89 44 24 08          	mov    %eax,0x8(%esp)
  1097f4:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  1097f7:	89 44 24 04          	mov    %eax,0x4(%esp)
  1097fb:	c7 04 24 fc a9 11 00 	movl   $0x11a9fc,(%esp)
  109802:	e8 09 6f ff ff       	call   100710 <cprintf>
			regnum, size, base);
	}

	pci_conf_write(f, bar, oldv);
  109807:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  10980a:	89 44 24 08          	mov    %eax,0x8(%esp)
  10980e:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  109811:	89 44 24 04          	mov    %eax,0x4(%esp)
  109815:	8b 45 08             	mov    0x8(%ebp),%eax
  109818:	89 04 24             	mov    %eax,(%esp)
  10981b:	e8 60 f8 ff ff       	call   109080 <pci_conf_write>
	f->reg_base[regnum] = base;
  109820:	8b 4d e8             	mov    0xffffffe8(%ebp),%ecx
  109823:	8b 55 08             	mov    0x8(%ebp),%edx
  109826:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  109829:	89 44 8a 14          	mov    %eax,0x14(%edx,%ecx,4)
	f->reg_size[regnum] = size;
  10982d:	8b 4d e8             	mov    0xffffffe8(%ebp),%ecx
  109830:	8b 55 08             	mov    0x8(%ebp),%edx
  109833:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  109836:	89 44 8a 2c          	mov    %eax,0x2c(%edx,%ecx,4)

	cprintf("  -> reg_base[%d] = %08x\n", regnum, base);
  10983a:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10983d:	89 44 24 08          	mov    %eax,0x8(%esp)
  109841:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  109844:	89 44 24 04          	mov    %eax,0x4(%esp)
  109848:	c7 04 24 1e aa 11 00 	movl   $0x11aa1e,(%esp)
  10984f:	e8 bc 6e ff ff       	call   100710 <cprintf>
	cprintf("  -> reg_size[%d] = %08x\n", regnum, size);
  109854:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  109857:	89 44 24 08          	mov    %eax,0x8(%esp)
  10985b:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  10985e:	89 44 24 04          	mov    %eax,0x4(%esp)
  109862:	c7 04 24 38 aa 11 00 	movl   $0x11aa38,(%esp)
  109869:	e8 a2 6e ff ff       	call   100710 <cprintf>

	if (size && !base)
  10986e:	83 7d f0 00          	cmpl   $0x0,0xfffffff0(%ebp)
  109872:	74 64                	je     1098d8 <pci_func_enable+0x208>
  109874:	83 7d ec 00          	cmpl   $0x0,0xffffffec(%ebp)
  109878:	75 5e                	jne    1098d8 <pci_func_enable+0x208>
	    cprintf("PCI device %02x:%02x.%d (%04x:%04x) may be misconfigured: "
  10987a:	8b 45 08             	mov    0x8(%ebp),%eax
  10987d:	8b 40 0c             	mov    0xc(%eax),%eax
  109880:	c1 e8 10             	shr    $0x10,%eax
  109883:	0f b7 d0             	movzwl %ax,%edx
  109886:	8b 45 08             	mov    0x8(%ebp),%eax
  109889:	8b 40 0c             	mov    0xc(%eax),%eax
  10988c:	0f b7 c8             	movzwl %ax,%ecx
  10988f:	8b 45 08             	mov    0x8(%ebp),%eax
  109892:	8b 58 08             	mov    0x8(%eax),%ebx
  109895:	8b 45 08             	mov    0x8(%ebp),%eax
  109898:	8b 70 04             	mov    0x4(%eax),%esi
  10989b:	8b 45 08             	mov    0x8(%ebp),%eax
  10989e:	8b 00                	mov    (%eax),%eax
  1098a0:	8b 78 04             	mov    0x4(%eax),%edi
  1098a3:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  1098a6:	89 44 24 20          	mov    %eax,0x20(%esp)
  1098aa:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  1098ad:	89 44 24 1c          	mov    %eax,0x1c(%esp)
  1098b1:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  1098b4:	89 44 24 18          	mov    %eax,0x18(%esp)
  1098b8:	89 54 24 14          	mov    %edx,0x14(%esp)
  1098bc:	89 4c 24 10          	mov    %ecx,0x10(%esp)
  1098c0:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
  1098c4:	89 74 24 08          	mov    %esi,0x8(%esp)
  1098c8:	89 7c 24 04          	mov    %edi,0x4(%esp)
  1098cc:	c7 04 24 54 aa 11 00 	movl   $0x11aa54,(%esp)
  1098d3:	e8 38 6e ff ff       	call   100710 <cprintf>
  1098d8:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  1098db:	01 45 dc             	add    %eax,0xffffffdc(%ebp)
  1098de:	83 7d dc 27          	cmpl   $0x27,0xffffffdc(%ebp)
  1098e2:	0f 86 18 fe ff ff    	jbe    109700 <pci_func_enable+0x30>
		    "region %d: base 0x%x, size %d\n",
		    f->bus->busno, f->dev, f->func,
		    PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
		    regnum, base, size);
    }
}
  1098e8:	83 c4 4c             	add    $0x4c,%esp
  1098eb:	5b                   	pop    %ebx
  1098ec:	5e                   	pop    %esi
  1098ed:	5f                   	pop    %edi
  1098ee:	5d                   	pop    %ebp
  1098ef:	c3                   	ret    

001098f0 <pci_init>:

int
pci_init(void)
{
  1098f0:	55                   	push   %ebp
  1098f1:	89 e5                	mov    %esp,%ebp
  1098f3:	83 ec 18             	sub    $0x18,%esp
    static struct pci_bus root_bus;
    memset(&root_bus, 0, sizeof(root_bus));
  1098f6:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  1098fd:	00 
  1098fe:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  109905:	00 
  109906:	c7 04 24 a8 cd 11 00 	movl   $0x11cda8,(%esp)
  10990d:	e8 be c5 ff ff       	call   105ed0 <memset>

    return pci_scan_bus(&root_bus);
  109912:	c7 04 24 a8 cd 11 00 	movl   $0x11cda8,(%esp)
  109919:	e8 32 f9 ff ff       	call   109250 <pci_scan_bus>
}
  10991e:	c9                   	leave  
  10991f:	c3                   	ret    

00109920 <__assert>:
#include "defs.h"

void __assert(const char *func, const char *file, 
        int line, const char *expr)
{
  109920:	55                   	push   %ebp
  109921:	89 e5                	mov    %esp,%ebp
  109923:	83 ec 18             	sub    $0x18,%esp
    cprintf("assert failed: %s at %s:%d, expression %s\n",
  109926:	8b 45 14             	mov    0x14(%ebp),%eax
  109929:	89 44 24 10          	mov    %eax,0x10(%esp)
  10992d:	8b 45 10             	mov    0x10(%ebp),%eax
  109930:	89 44 24 0c          	mov    %eax,0xc(%esp)
  109934:	8b 45 0c             	mov    0xc(%ebp),%eax
  109937:	89 44 24 08          	mov    %eax,0x8(%esp)
  10993b:	8b 45 08             	mov    0x8(%ebp),%eax
  10993e:	89 44 24 04          	mov    %eax,0x4(%esp)
  109942:	c7 04 24 b0 aa 11 00 	movl   $0x11aab0,(%esp)
  109949:	e8 c2 6d ff ff       	call   100710 <cprintf>
            func, file, line, expr);
}
  10994e:	c9                   	leave  
  10994f:	c3                   	ret    

00109950 <sem_init>:
    int waiters;
};

int sem_init(sem_t *sem, unsigned int value)
{
  109950:	55                   	push   %ebp
  109951:	89 e5                	mov    %esp,%ebp
  109953:	83 ec 08             	sub    $0x8,%esp
    assert(value >= 0);
    initlock(&sem->lock, "sem lock");
  109956:	8b 45 08             	mov    0x8(%ebp),%eax
  109959:	c7 44 24 04 e4 aa 11 	movl   $0x11aae4,0x4(%esp)
  109960:	00 
  109961:	89 04 24             	mov    %eax,(%esp)
  109964:	e8 77 c1 ff ff       	call   105ae0 <initlock>
    sem->val = value;
  109969:	8b 55 0c             	mov    0xc(%ebp),%edx
  10996c:	8b 45 08             	mov    0x8(%ebp),%eax
  10996f:	89 50 34             	mov    %edx,0x34(%eax)
    sem->waiters = 0;
  109972:	8b 45 08             	mov    0x8(%ebp),%eax
  109975:	c7 40 38 00 00 00 00 	movl   $0x0,0x38(%eax)
    return 0;
  10997c:	b8 00 00 00 00       	mov    $0x0,%eax
}
  109981:	c9                   	leave  
  109982:	c3                   	ret    
  109983:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  109989:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00109990 <sem_destroy>:

int sem_destroy(sem_t *sem)
{
  109990:	55                   	push   %ebp
  109991:	89 e5                	mov    %esp,%ebp
  109993:	83 ec 18             	sub    $0x18,%esp
    assert(sem->waiters == 0);
  109996:	8b 45 08             	mov    0x8(%ebp),%eax
  109999:	8b 40 38             	mov    0x38(%eax),%eax
  10999c:	85 c0                	test   %eax,%eax
  10999e:	74 24                	je     1099c4 <sem_destroy+0x34>
  1099a0:	c7 44 24 0c f9 aa 11 	movl   $0x11aaf9,0xc(%esp)
  1099a7:	00 
  1099a8:	c7 44 24 08 18 00 00 	movl   $0x18,0x8(%esp)
  1099af:	00 
  1099b0:	c7 44 24 04 0b ab 11 	movl   $0x11ab0b,0x4(%esp)
  1099b7:	00 
  1099b8:	c7 04 24 ed aa 11 00 	movl   $0x11aaed,(%esp)
  1099bf:	e8 5c ff ff ff       	call   109920 <__assert>
    return 0;
  1099c4:	b8 00 00 00 00       	mov    $0x0,%eax
}
  1099c9:	c9                   	leave  
  1099ca:	c3                   	ret    
  1099cb:	90                   	nop    
  1099cc:	8d 74 26 00          	lea    0x0(%esi),%esi

001099d0 <sem_post>:

void sem_post(sem_t *sem)
{
  1099d0:	55                   	push   %ebp
  1099d1:	89 e5                	mov    %esp,%ebp
  1099d3:	83 ec 08             	sub    $0x8,%esp
    acquire(&sem->lock);
  1099d6:	8b 45 08             	mov    0x8(%ebp),%eax
  1099d9:	89 04 24             	mov    %eax,(%esp)
  1099dc:	e8 2f c1 ff ff       	call   105b10 <acquire>
    sem->val++;
  1099e1:	8b 45 08             	mov    0x8(%ebp),%eax
  1099e4:	8b 40 34             	mov    0x34(%eax),%eax
  1099e7:	8d 50 01             	lea    0x1(%eax),%edx
  1099ea:	8b 45 08             	mov    0x8(%ebp),%eax
  1099ed:	89 50 34             	mov    %edx,0x34(%eax)
    if ((sem->waiters) && (sem->val > 0))
  1099f0:	8b 45 08             	mov    0x8(%ebp),%eax
  1099f3:	8b 40 38             	mov    0x38(%eax),%eax
  1099f6:	85 c0                	test   %eax,%eax
  1099f8:	74 15                	je     109a0f <sem_post+0x3f>
  1099fa:	8b 45 08             	mov    0x8(%ebp),%eax
  1099fd:	8b 40 34             	mov    0x34(%eax),%eax
  109a00:	85 c0                	test   %eax,%eax
  109a02:	7e 0b                	jle    109a0f <sem_post+0x3f>
    {
        wakeup_one(sem); // XXX maybe wakeup?
  109a04:	8b 45 08             	mov    0x8(%ebp),%eax
  109a07:	89 04 24             	mov    %eax,(%esp)
  109a0a:	e8 b1 bb ff ff       	call   1055c0 <wakeup_one>
    }
    release(&sem->lock);
  109a0f:	8b 45 08             	mov    0x8(%ebp),%eax
  109a12:	89 04 24             	mov    %eax,(%esp)
  109a15:	e8 f6 c2 ff ff       	call   105d10 <release>
}
  109a1a:	c9                   	leave  
  109a1b:	c3                   	ret    
  109a1c:	8d 74 26 00          	lea    0x0(%esi),%esi

00109a20 <sem_wait>:

void sem_wait(sem_t *sem)
{
  109a20:	55                   	push   %ebp
  109a21:	89 e5                	mov    %esp,%ebp
  109a23:	83 ec 08             	sub    $0x8,%esp
    acquire(&sem->lock);
  109a26:	8b 45 08             	mov    0x8(%ebp),%eax
  109a29:	89 04 24             	mov    %eax,(%esp)
  109a2c:	e8 df c0 ff ff       	call   105b10 <acquire>
    while (sem->val == 0)
  109a31:	eb 30                	jmp    109a63 <sem_wait+0x43>
    {
        sem->waiters++;
  109a33:	8b 45 08             	mov    0x8(%ebp),%eax
  109a36:	8b 40 38             	mov    0x38(%eax),%eax
  109a39:	8d 50 01             	lea    0x1(%eax),%edx
  109a3c:	8b 45 08             	mov    0x8(%ebp),%eax
  109a3f:	89 50 38             	mov    %edx,0x38(%eax)
        sleep(sem, &sem->lock);
  109a42:	8b 45 08             	mov    0x8(%ebp),%eax
  109a45:	89 44 24 04          	mov    %eax,0x4(%esp)
  109a49:	8b 45 08             	mov    0x8(%ebp),%eax
  109a4c:	89 04 24             	mov    %eax,(%esp)
  109a4f:	e8 0c ba ff ff       	call   105460 <sleep>
        sem->waiters--;
  109a54:	8b 45 08             	mov    0x8(%ebp),%eax
  109a57:	8b 40 38             	mov    0x38(%eax),%eax
  109a5a:	8d 50 ff             	lea    0xffffffff(%eax),%edx
  109a5d:	8b 45 08             	mov    0x8(%ebp),%eax
  109a60:	89 50 38             	mov    %edx,0x38(%eax)
  109a63:	8b 45 08             	mov    0x8(%ebp),%eax
  109a66:	8b 40 34             	mov    0x34(%eax),%eax
  109a69:	85 c0                	test   %eax,%eax
  109a6b:	74 c6                	je     109a33 <sem_wait+0x13>
    }
    sem->val--;
  109a6d:	8b 45 08             	mov    0x8(%ebp),%eax
  109a70:	8b 40 34             	mov    0x34(%eax),%eax
  109a73:	8d 50 ff             	lea    0xffffffff(%eax),%edx
  109a76:	8b 45 08             	mov    0x8(%ebp),%eax
  109a79:	89 50 34             	mov    %edx,0x34(%eax)
    release(&sem->lock);
  109a7c:	8b 45 08             	mov    0x8(%ebp),%eax
  109a7f:	89 04 24             	mov    %eax,(%esp)
  109a82:	e8 89 c2 ff ff       	call   105d10 <release>
}
  109a87:	c9                   	leave  
  109a88:	c3                   	ret    
  109a89:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

00109a90 <sem_timedwait>:

int sem_timedwait(sem_t *sem, int timo)
{
  109a90:	55                   	push   %ebp
  109a91:	89 e5                	mov    %esp,%ebp
  109a93:	83 ec 28             	sub    $0x28,%esp
    int ret;

    acquire(&sem->lock);
  109a96:	8b 45 08             	mov    0x8(%ebp),%eax
  109a99:	89 04 24             	mov    %eax,(%esp)
  109a9c:	e8 6f c0 ff ff       	call   105b10 <acquire>
    for (ret = 0; sem->val == 0 && ret == 0;)
  109aa1:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
  109aa8:	eb 3a                	jmp    109ae4 <sem_timedwait+0x54>
    {
        sem->waiters++;
  109aaa:	8b 45 08             	mov    0x8(%ebp),%eax
  109aad:	8b 40 38             	mov    0x38(%eax),%eax
  109ab0:	8d 50 01             	lea    0x1(%eax),%edx
  109ab3:	8b 45 08             	mov    0x8(%ebp),%eax
  109ab6:	89 50 38             	mov    %edx,0x38(%eax)
        ret = msleep_spin(sem, &sem->lock, timo);
  109ab9:	8b 55 08             	mov    0x8(%ebp),%edx
  109abc:	8b 45 0c             	mov    0xc(%ebp),%eax
  109abf:	89 44 24 08          	mov    %eax,0x8(%esp)
  109ac3:	89 54 24 04          	mov    %edx,0x4(%esp)
  109ac7:	8b 45 08             	mov    0x8(%ebp),%eax
  109aca:	89 04 24             	mov    %eax,(%esp)
  109acd:	e8 6e b8 ff ff       	call   105340 <msleep_spin>
  109ad2:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
        sem->waiters--;
  109ad5:	8b 45 08             	mov    0x8(%ebp),%eax
  109ad8:	8b 40 38             	mov    0x38(%eax),%eax
  109adb:	8d 50 ff             	lea    0xffffffff(%eax),%edx
  109ade:	8b 45 08             	mov    0x8(%ebp),%eax
  109ae1:	89 50 38             	mov    %edx,0x38(%eax)
  109ae4:	8b 45 08             	mov    0x8(%ebp),%eax
  109ae7:	8b 40 34             	mov    0x34(%eax),%eax
  109aea:	85 c0                	test   %eax,%eax
  109aec:	75 06                	jne    109af4 <sem_timedwait+0x64>
  109aee:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  109af2:	74 b6                	je     109aaa <sem_timedwait+0x1a>
    }
    if (sem->val > 0)
  109af4:	8b 45 08             	mov    0x8(%ebp),%eax
  109af7:	8b 40 34             	mov    0x34(%eax),%eax
  109afa:	85 c0                	test   %eax,%eax
  109afc:	7e 16                	jle    109b14 <sem_timedwait+0x84>
    {
        sem->val--;
  109afe:	8b 45 08             	mov    0x8(%ebp),%eax
  109b01:	8b 40 34             	mov    0x34(%eax),%eax
  109b04:	8d 50 ff             	lea    0xffffffff(%eax),%edx
  109b07:	8b 45 08             	mov    0x8(%ebp),%eax
  109b0a:	89 50 34             	mov    %edx,0x34(%eax)
        ret = 0;
  109b0d:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
    }
    release(&sem->lock);
  109b14:	8b 45 08             	mov    0x8(%ebp),%eax
  109b17:	89 04 24             	mov    %eax,(%esp)
  109b1a:	e8 f1 c1 ff ff       	call   105d10 <release>

    return ret;
  109b1f:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
}
  109b22:	c9                   	leave  
  109b23:	c3                   	ret    
  109b24:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  109b2a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

00109b30 <sem_trywait>:

int sem_trywait(sem_t *sem)
{
  109b30:	55                   	push   %ebp
  109b31:	89 e5                	mov    %esp,%ebp
  109b33:	83 ec 18             	sub    $0x18,%esp
    int ret;

    acquire(&sem->lock);
  109b36:	8b 45 08             	mov    0x8(%ebp),%eax
  109b39:	89 04 24             	mov    %eax,(%esp)
  109b3c:	e8 cf bf ff ff       	call   105b10 <acquire>
    if (sem->val > 0)
  109b41:	8b 45 08             	mov    0x8(%ebp),%eax
  109b44:	8b 40 34             	mov    0x34(%eax),%eax
  109b47:	85 c0                	test   %eax,%eax
  109b49:	7e 18                	jle    109b63 <sem_trywait+0x33>
    {
        sem->val--;
  109b4b:	8b 45 08             	mov    0x8(%ebp),%eax
  109b4e:	8b 40 34             	mov    0x34(%eax),%eax
  109b51:	8d 50 ff             	lea    0xffffffff(%eax),%edx
  109b54:	8b 45 08             	mov    0x8(%ebp),%eax
  109b57:	89 50 34             	mov    %edx,0x34(%eax)
        ret = 1;
  109b5a:	c7 45 fc 01 00 00 00 	movl   $0x1,0xfffffffc(%ebp)
  109b61:	eb 07                	jmp    109b6a <sem_trywait+0x3a>
    } else {
        ret = 0;
  109b63:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
    }
    release(&sem->lock);
  109b6a:	8b 45 08             	mov    0x8(%ebp),%eax
  109b6d:	89 04 24             	mov    %eax,(%esp)
  109b70:	e8 9b c1 ff ff       	call   105d10 <release>
    return ret;
  109b75:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
}
  109b78:	c9                   	leave  
  109b79:	c3                   	ret    
  109b7a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

00109b80 <sem_value>:

int sem_value(sem_t *sem)
{
  109b80:	55                   	push   %ebp
  109b81:	89 e5                	mov    %esp,%ebp
  109b83:	83 ec 18             	sub    $0x18,%esp
    int ret;

    acquire(&sem->lock);
  109b86:	8b 45 08             	mov    0x8(%ebp),%eax
  109b89:	89 04 24             	mov    %eax,(%esp)
  109b8c:	e8 7f bf ff ff       	call   105b10 <acquire>
    ret = sem->val;
  109b91:	8b 45 08             	mov    0x8(%ebp),%eax
  109b94:	8b 40 34             	mov    0x34(%eax),%eax
  109b97:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
    release(&sem->lock);
  109b9a:	8b 45 08             	mov    0x8(%ebp),%eax
  109b9d:	89 04 24             	mov    %eax,(%esp)
  109ba0:	e8 6b c1 ff ff       	call   105d10 <release>
    return ret;
  109ba5:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
}
  109ba8:	c9                   	leave  
  109ba9:	c3                   	ret    
  109baa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

00109bb0 <sem_size>:

int sem_size()
{
  109bb0:	55                   	push   %ebp
  109bb1:	89 e5                	mov    %esp,%ebp
    return sizeof(struct sem);
  109bb3:	b8 3c 00 00 00       	mov    $0x3c,%eax
}
  109bb8:	5d                   	pop    %ebp
  109bb9:	c3                   	ret    
  109bba:	90                   	nop    
  109bbb:	90                   	nop    
  109bbc:	90                   	nop    
  109bbd:	90                   	nop    
  109bbe:	90                   	nop    
  109bbf:	90                   	nop    

00109bc0 <kproc_start>:
extern struct proc *initproc;

kproc_t kproc_start(void (* proc)(void *arg), 
        void *arg, int prio, void *data, char *name)
{
  109bc0:	55                   	push   %ebp
  109bc1:	89 e5                	mov    %esp,%ebp
  109bc3:	83 ec 28             	sub    $0x28,%esp
    kproc_t thr = (kproc_t)kmalloc(sizeof(struct thread));
  109bc6:	c7 04 24 0c 00 00 00 	movl   $0xc,(%esp)
  109bcd:	e8 7e 99 ff ff       	call   103550 <kmalloc>
  109bd2:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
    if (!thr)
  109bd5:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  109bd9:	75 0c                	jne    109be7 <kproc_start+0x27>
        return NULL;
  109bdb:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  109be2:	e9 77 01 00 00       	jmp    109d5e <kproc_start+0x19e>
    thr->p = allocproc();
  109be7:	e8 d4 ab ff ff       	call   1047c0 <allocproc>
  109bec:	89 c2                	mov    %eax,%edx
  109bee:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  109bf1:	89 10                	mov    %edx,(%eax)
    struct proc *np = thr->p;
  109bf3:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  109bf6:	8b 00                	mov    (%eax),%eax
  109bf8:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
    if (!np)
  109bfb:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  109bff:	75 0c                	jne    109c0d <kproc_start+0x4d>
        return NULL;
  109c01:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  109c08:	e9 51 01 00 00       	jmp    109d5e <kproc_start+0x19e>
    if((np->kstack = kmalloc(KSTACKSIZE)) == 0){
  109c0d:	c7 04 24 00 10 00 00 	movl   $0x1000,(%esp)
  109c14:	e8 37 99 ff ff       	call   103550 <kmalloc>
  109c19:	89 c2                	mov    %eax,%edx
  109c1b:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  109c1e:	89 50 08             	mov    %edx,0x8(%eax)
  109c21:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  109c24:	8b 40 08             	mov    0x8(%eax),%eax
  109c27:	85 c0                	test   %eax,%eax
  109c29:	75 16                	jne    109c41 <kproc_start+0x81>
      np->state = UNUSED;
  109c2b:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  109c2e:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
      return NULL;
  109c35:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  109c3c:	e9 1d 01 00 00       	jmp    109d5e <kproc_start+0x19e>
    }
    np->thr = thr;
  109c41:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  109c44:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  109c47:	89 82 a8 00 00 00    	mov    %eax,0xa8(%edx)
    np->parent = initproc;
  109c4d:	8b 15 24 0c 14 00    	mov    0x140c24,%edx
  109c53:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  109c56:	89 50 14             	mov    %edx,0x14(%eax)
    np->sz = 0;
  109c59:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  109c5c:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    np->chan = 0;
  109c63:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  109c66:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
    np->killed = 0;
  109c6d:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  109c70:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
    thr->data = data;
  109c77:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  109c7a:	8b 45 14             	mov    0x14(%ebp),%eax
  109c7d:	89 42 04             	mov    %eax,0x4(%edx)
    memset(&np->context, 0, sizeof(np->context));
  109c80:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  109c83:	83 c0 64             	add    $0x64,%eax
  109c86:	c7 44 24 08 20 00 00 	movl   $0x20,0x8(%esp)
  109c8d:	00 
  109c8e:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  109c95:	00 
  109c96:	89 04 24             	mov    %eax,(%esp)
  109c99:	e8 32 c2 ff ff       	call   105ed0 <memset>
    thr->timeouts.next = 0;
  109c9e:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  109ca1:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    if (name == 0)
  109ca8:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
  109cac:	75 22                	jne    109cd0 <kproc_start+0x110>
        safestrcpy(np->name,"[kernel thread]",sizeof(np->name));
  109cae:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  109cb1:	05 88 00 00 00       	add    $0x88,%eax
  109cb6:	c7 44 24 08 20 00 00 	movl   $0x20,0x8(%esp)
  109cbd:	00 
  109cbe:	c7 44 24 04 11 ab 11 	movl   $0x11ab11,0x4(%esp)
  109cc5:	00 
  109cc6:	89 04 24             	mov    %eax,(%esp)
  109cc9:	e8 e2 c3 ff ff       	call   1060b0 <safestrcpy>
  109cce:	eb 20                	jmp    109cf0 <kproc_start+0x130>
    else
        safestrcpy(np->name, name, sizeof(np->name));
  109cd0:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  109cd3:	81 c2 88 00 00 00    	add    $0x88,%edx
  109cd9:	c7 44 24 08 20 00 00 	movl   $0x20,0x8(%esp)
  109ce0:	00 
  109ce1:	8b 45 18             	mov    0x18(%ebp),%eax
  109ce4:	89 44 24 04          	mov    %eax,0x4(%esp)
  109ce8:	89 14 24             	mov    %edx,(%esp)
  109ceb:	e8 c0 c3 ff ff       	call   1060b0 <safestrcpy>
    np->context.eip = (uint)thread_wrap;
  109cf0:	ba a0 9d 10 00       	mov    $0x109da0,%edx
  109cf5:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  109cf8:	89 50 64             	mov    %edx,0x64(%eax)
    np->context.esp = (uint)np->kstack + KSTACKSIZE - 1;
  109cfb:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  109cfe:	8b 40 08             	mov    0x8(%eax),%eax
  109d01:	05 ff 0f 00 00       	add    $0xfff,%eax
  109d06:	89 c2                	mov    %eax,%edx
  109d08:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  109d0b:	89 50 68             	mov    %edx,0x68(%eax)
    *(void**)(np->context.esp+8) = arg;
  109d0e:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  109d11:	8b 40 68             	mov    0x68(%eax),%eax
  109d14:	83 c0 08             	add    $0x8,%eax
  109d17:	89 c2                	mov    %eax,%edx
  109d19:	8b 45 0c             	mov    0xc(%ebp),%eax
  109d1c:	89 02                	mov    %eax,(%edx)
    *(void**)(np->context.esp+4) = proc;
  109d1e:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  109d21:	8b 40 68             	mov    0x68(%eax),%eax
  109d24:	83 c0 04             	add    $0x4,%eax
  109d27:	89 c2                	mov    %eax,%edx
  109d29:	8b 45 08             	mov    0x8(%ebp),%eax
  109d2c:	89 02                	mov    %eax,(%edx)
    *(void**)(np->context.esp) = exit;
  109d2e:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  109d31:	8b 40 68             	mov    0x68(%eax),%eax
  109d34:	c7 00 b0 56 10 00    	movl   $0x1056b0,(%eax)
    np->cwd = namei("/");
  109d3a:	c7 04 24 21 ab 11 00 	movl   $0x11ab21,(%esp)
  109d41:	e8 0a 8f ff ff       	call   102c50 <namei>
  109d46:	89 c2                	mov    %eax,%edx
  109d48:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  109d4b:	89 50 60             	mov    %edx,0x60(%eax)
    np->state = RUNNABLE;
  109d4e:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  109d51:	c7 40 0c 03 00 00 00 	movl   $0x3,0xc(%eax)
    return thr;
  109d58:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  109d5b:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  109d5e:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  109d61:	c9                   	leave  
  109d62:	c3                   	ret    
  109d63:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  109d69:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00109d70 <kproc_free>:

void kproc_free(kproc_t thread)
{
  109d70:	55                   	push   %ebp
  109d71:	89 e5                	mov    %esp,%ebp
  109d73:	83 ec 18             	sub    $0x18,%esp
    struct proc *p = thread->p;
  109d76:	8b 45 08             	mov    0x8(%ebp),%eax
  109d79:	8b 00                	mov    (%eax),%eax
  109d7b:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
    p->thr = 0;
  109d7e:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  109d81:	c7 80 a8 00 00 00 00 	movl   $0x0,0xa8(%eax)
  109d88:	00 00 00 
    kmfree(thread, sizeof(struct thread));
  109d8b:	c7 44 24 04 0c 00 00 	movl   $0xc,0x4(%esp)
  109d92:	00 
  109d93:	8b 45 08             	mov    0x8(%ebp),%eax
  109d96:	89 04 24             	mov    %eax,(%esp)
  109d99:	e8 e2 97 ff ff       	call   103580 <kmfree>
}
  109d9e:	c9                   	leave  
  109d9f:	c3                   	ret    

00109da0 <thread_wrap>:

void thread_wrap(void (* thread)(void *arg), void *arg)
{
  109da0:	55                   	push   %ebp
  109da1:	89 e5                	mov    %esp,%ebp
  109da3:	83 ec 08             	sub    $0x8,%esp
    release(&proc_table_lock);
  109da6:	c7 04 24 40 0c 14 00 	movl   $0x140c40,(%esp)
  109dad:	e8 5e bf ff ff       	call   105d10 <release>
    thread(arg);
  109db2:	8b 45 0c             	mov    0xc(%ebp),%eax
  109db5:	89 04 24             	mov    %eax,(%esp)
  109db8:	8b 45 08             	mov    0x8(%ebp),%eax
  109dbb:	ff d0                	call   *%eax
}
  109dbd:	c9                   	leave  
  109dbe:	c3                   	ret    
  109dbf:	90                   	nop    

00109dc0 <ether_e100_attach>:
char *ru_state_name[];

int
ether_e100_attach(struct pci_func *pcif)
{	
  109dc0:	55                   	push   %ebp
  109dc1:	89 e5                	mov    %esp,%ebp
  109dc3:	57                   	push   %edi
  109dc4:	56                   	push   %esi
  109dc5:	53                   	push   %ebx
  109dc6:	83 ec 5c             	sub    $0x5c,%esp
    cprintf("PCI: %02x:%02x.%d: "
  109dc9:	8b 45 08             	mov    0x8(%ebp),%eax
  109dcc:	8b 40 0c             	mov    0xc(%eax),%eax
  109dcf:	c1 e8 10             	shr    $0x10,%eax
  109dd2:	0f b7 f0             	movzwl %ax,%esi
  109dd5:	8b 45 08             	mov    0x8(%ebp),%eax
  109dd8:	8b 40 0c             	mov    0xc(%eax),%eax
  109ddb:	0f b7 d0             	movzwl %ax,%edx
  109dde:	8b 45 08             	mov    0x8(%ebp),%eax
  109de1:	8b 48 08             	mov    0x8(%eax),%ecx
  109de4:	8b 45 08             	mov    0x8(%ebp),%eax
  109de7:	8b 58 04             	mov    0x4(%eax),%ebx
  109dea:	8b 45 08             	mov    0x8(%ebp),%eax
  109ded:	8b 00                	mov    (%eax),%eax
  109def:	8b 40 04             	mov    0x4(%eax),%eax
  109df2:	89 74 24 14          	mov    %esi,0x14(%esp)
  109df6:	89 54 24 10          	mov    %edx,0x10(%esp)
  109dfa:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
  109dfe:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  109e02:	89 44 24 04          	mov    %eax,0x4(%esp)
  109e06:	c7 04 24 24 ab 11 00 	movl   $0x11ab24,(%esp)
  109e0d:	e8 fe 68 ff ff       	call   100710 <cprintf>
            "Intel 82559ER Fast Ethernet PCI Controller %04x:%04x\n",
		pcif->bus->busno, pcif->dev, pcif->func,
        PCI_VENDOR(pcif->dev_id), PCI_PRODUCT(pcif->dev_id));
    dev_count++;
  109e12:	a1 c0 cd 11 00       	mov    0x11cdc0,%eax
  109e17:	83 c0 01             	add    $0x1,%eax
  109e1a:	a3 c0 cd 11 00       	mov    %eax,0x11cdc0
    int index = dev_count-1;
  109e1f:	a1 c0 cd 11 00       	mov    0x11cdc0,%eax
  109e24:	83 e8 01             	sub    $0x1,%eax
  109e27:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
    e100_dev *dev = &e100_devs[index];
  109e2a:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
  109e2d:	69 c0 48 01 00 00    	imul   $0x148,%eax,%eax
  109e33:	05 e0 cd 11 00       	add    $0x11cde0,%eax
  109e38:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)

    dev->cubase = (uint32_t)kalloc(E100_CU_RING_SIZE * PAGE); // 128K
  109e3b:	c7 04 24 00 00 02 00 	movl   $0x20000,(%esp)
  109e42:	e8 29 96 ff ff       	call   103470 <kalloc>
  109e47:	89 c2                	mov    %eax,%edx
  109e49:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  109e4c:	89 90 9c 00 00 00    	mov    %edx,0x9c(%eax)
    if (!dev->cubase)
  109e52:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  109e55:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
  109e5b:	85 c0                	test   %eax,%eax
  109e5d:	75 25                	jne    109e84 <ether_e100_attach+0xc4>
    {
        cprintf("   Failed to allocate CU ring\n");
  109e5f:	c7 04 24 70 ab 11 00 	movl   $0x11ab70,(%esp)
  109e66:	e8 a5 68 ff ff       	call   100710 <cprintf>
        dev_count--;
  109e6b:	a1 c0 cd 11 00       	mov    0x11cdc0,%eax
  109e70:	83 e8 01             	sub    $0x1,%eax
  109e73:	a3 c0 cd 11 00       	mov    %eax,0x11cdc0
        return -1;
  109e78:	c7 45 c0 ff ff ff ff 	movl   $0xffffffff,0xffffffc0(%ebp)
  109e7f:	e9 94 03 00 00       	jmp    10a218 <ether_e100_attach+0x458>
    }
    dev->rubase = (uint32_t)kalloc(E100_RU_RING_SIZE * PAGE); // 128K
  109e84:	c7 04 24 00 00 02 00 	movl   $0x20000,(%esp)
  109e8b:	e8 e0 95 ff ff       	call   103470 <kalloc>
  109e90:	89 c2                	mov    %eax,%edx
  109e92:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  109e95:	89 90 ec 00 00 00    	mov    %edx,0xec(%eax)
    if (!dev->rubase)
  109e9b:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  109e9e:	8b 80 ec 00 00 00    	mov    0xec(%eax),%eax
  109ea4:	85 c0                	test   %eax,%eax
  109ea6:	75 25                	jne    109ecd <ether_e100_attach+0x10d>
    {
        cprintf("   Failed to allocate RU ring\n");
  109ea8:	c7 04 24 90 ab 11 00 	movl   $0x11ab90,(%esp)
  109eaf:	e8 5c 68 ff ff       	call   100710 <cprintf>
        dev_count--;
  109eb4:	a1 c0 cd 11 00       	mov    0x11cdc0,%eax
  109eb9:	83 e8 01             	sub    $0x1,%eax
  109ebc:	a3 c0 cd 11 00       	mov    %eax,0x11cdc0
        return -1;
  109ec1:	c7 45 c0 ff ff ff ff 	movl   $0xffffffff,0xffffffc0(%ebp)
  109ec8:	e9 4b 03 00 00       	jmp    10a218 <ether_e100_attach+0x458>
    }
    dev->cusize = E100_CU_RING_SIZE * PAGE;
  109ecd:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  109ed0:	c7 80 a0 00 00 00 00 	movl   $0x20000,0xa0(%eax)
  109ed7:	00 02 00 
    dev->rusize = E100_RU_RING_SIZE * PAGE;
  109eda:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  109edd:	c7 80 f0 00 00 00 00 	movl   $0x20000,0xf0(%eax)
  109ee4:	00 02 00 
    dev->eeprom_size = 6;
  109ee7:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  109eea:	c7 80 3c 01 00 00 06 	movl   $0x6,0x13c(%eax)
  109ef1:	00 00 00 
    ring_init(dev);
  109ef4:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  109ef7:	89 04 24             	mov    %eax,(%esp)
  109efa:	e8 81 09 00 00       	call   10a880 <ring_init>
//    dev->cuhead = 0;
//    dev->cuend = 0;

    pci_func_enable(pcif);
  109eff:	8b 45 08             	mov    0x8(%ebp),%eax
  109f02:	89 04 24             	mov    %eax,(%esp)
  109f05:	e8 c6 f7 ff ff       	call   1096d0 <pci_func_enable>
    initlock(&dev->culock, "e100 CU lock");
  109f0a:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  109f0d:	83 c0 68             	add    $0x68,%eax
  109f10:	c7 44 24 04 af ab 11 	movl   $0x11abaf,0x4(%esp)
  109f17:	00 
  109f18:	89 04 24             	mov    %eax,(%esp)
  109f1b:	e8 c0 bb ff ff       	call   105ae0 <initlock>
    initlock(&dev->rulock, "e100 RU lock");
  109f20:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  109f23:	05 b8 00 00 00       	add    $0xb8,%eax
  109f28:	c7 44 24 04 bc ab 11 	movl   $0x11abbc,0x4(%esp)
  109f2f:	00 
  109f30:	89 04 24             	mov    %eax,(%esp)
  109f33:	e8 a8 bb ff ff       	call   105ae0 <initlock>
    initlock(&dev->rxlock, "e100 RX lock");
  109f38:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  109f3b:	05 08 01 00 00       	add    $0x108,%eax
  109f40:	c7 44 24 04 c9 ab 11 	movl   $0x11abc9,0x4(%esp)
  109f47:	00 
  109f48:	89 04 24             	mov    %eax,(%esp)
  109f4b:	e8 90 bb ff ff       	call   105ae0 <initlock>
    dev->irq = pcif->irq_line;
  109f50:	8b 45 08             	mov    0x8(%ebp),%eax
  109f53:	0f b6 40 44          	movzbl 0x44(%eax),%eax
  109f57:	0f b6 d0             	movzbl %al,%edx
  109f5a:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  109f5d:	89 10                	mov    %edx,(%eax)
    int i;
    for (i=0; i<6; i++)
  109f5f:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  109f66:	eb 4b                	jmp    109fb3 <ether_e100_attach+0x1f3>
    {
        dev->regbase[i] = pcif->reg_base[i];
  109f68:	8b 4d ec             	mov    0xffffffec(%ebp),%ecx
  109f6b:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
  109f6e:	8b 45 08             	mov    0x8(%ebp),%eax
  109f71:	8b 54 90 14          	mov    0x14(%eax,%edx,4),%edx
  109f75:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  109f78:	89 54 88 04          	mov    %edx,0x4(%eax,%ecx,4)
        dev->regsize[i] = pcif->reg_size[i];
  109f7c:	8b 4d ec             	mov    0xffffffec(%ebp),%ecx
  109f7f:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
  109f82:	8b 45 08             	mov    0x8(%ebp),%eax
  109f85:	8b 54 90 2c          	mov    0x2c(%eax,%edx,4),%edx
  109f89:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  109f8c:	89 54 88 1c          	mov    %edx,0x1c(%eax,%ecx,4)
        if (dev->regsize[i] == E100_IOPORT_SIZE)
  109f90:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
  109f93:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  109f96:	8b 44 90 1c          	mov    0x1c(%eax,%edx,4),%eax
  109f9a:	83 f8 40             	cmp    $0x40,%eax
  109f9d:	75 10                	jne    109faf <ether_e100_attach+0x1ef>
            dev->iobase = dev->regbase[i];
  109f9f:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
  109fa2:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  109fa5:	8b 54 90 04          	mov    0x4(%eax,%edx,4),%edx
  109fa9:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  109fac:	89 50 34             	mov    %edx,0x34(%eax)
  109faf:	83 45 ec 01          	addl   $0x1,0xffffffec(%ebp)
  109fb3:	83 7d ec 05          	cmpl   $0x5,0xffffffec(%ebp)
  109fb7:	7e af                	jle    109f68 <ether_e100_attach+0x1a8>
    }
    e100_reset(dev);
  109fb9:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  109fbc:	89 04 24             	mov    %eax,(%esp)
  109fbf:	e8 ac 02 00 00       	call   10a270 <e100_reset>
    dev->cufirst = 1;
  109fc4:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  109fc7:	c7 80 a8 00 00 00 01 	movl   $0x1,0xa8(%eax)
  109fce:	00 00 00 
    dev->cuidle = 1;
  109fd1:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  109fd4:	c7 80 ac 00 00 00 01 	movl   $0x1,0xac(%eax)
  109fdb:	00 00 00 
    e100_print_state(dev);
  109fde:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  109fe1:	89 04 24             	mov    %eax,(%esp)
  109fe4:	e8 b7 03 00 00       	call   10a3a0 <e100_print_state>

    uint16_t ma[3];
    e100_read_eeprom(dev, ma, 0, 3);
  109fe9:	c7 44 24 0c 03 00 00 	movl   $0x3,0xc(%esp)
  109ff0:	00 
  109ff1:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  109ff8:	00 
  109ff9:	8d 45 de             	lea    0xffffffde(%ebp),%eax
  109ffc:	89 44 24 04          	mov    %eax,0x4(%esp)
  10a000:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  10a003:	89 04 24             	mov    %eax,(%esp)
  10a006:	e8 e5 11 00 00       	call   10b1f0 <e100_read_eeprom>
    dev->macaddr[0] = ma[0] & 0xff;
  10a00b:	0f b7 45 de          	movzwl 0xffffffde(%ebp),%eax
  10a00f:	89 c2                	mov    %eax,%edx
  10a011:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  10a014:	88 90 40 01 00 00    	mov    %dl,0x140(%eax)
    dev->macaddr[1] = (ma[0] >> 8) & 0xff;
  10a01a:	0f b7 45 de          	movzwl 0xffffffde(%ebp),%eax
  10a01e:	66 c1 e8 08          	shr    $0x8,%ax
  10a022:	89 c2                	mov    %eax,%edx
  10a024:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  10a027:	88 90 41 01 00 00    	mov    %dl,0x141(%eax)
    dev->macaddr[2] = ma[1] & 0xff;
  10a02d:	0f b7 45 e0          	movzwl 0xffffffe0(%ebp),%eax
  10a031:	89 c2                	mov    %eax,%edx
  10a033:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  10a036:	88 90 42 01 00 00    	mov    %dl,0x142(%eax)
    dev->macaddr[3] = (ma[1] >> 8) & 0xff;
  10a03c:	0f b7 45 e0          	movzwl 0xffffffe0(%ebp),%eax
  10a040:	66 c1 e8 08          	shr    $0x8,%ax
  10a044:	89 c2                	mov    %eax,%edx
  10a046:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  10a049:	88 90 43 01 00 00    	mov    %dl,0x143(%eax)
    dev->macaddr[4] = ma[2] & 0xff;
  10a04f:	0f b7 45 e2          	movzwl 0xffffffe2(%ebp),%eax
  10a053:	89 c2                	mov    %eax,%edx
  10a055:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  10a058:	88 90 44 01 00 00    	mov    %dl,0x144(%eax)
    dev->macaddr[5] = (ma[2] >> 8) & 0xff;
  10a05e:	0f b7 45 e2          	movzwl 0xffffffe2(%ebp),%eax
  10a062:	66 c1 e8 08          	shr    $0x8,%ax
  10a066:	89 c2                	mov    %eax,%edx
  10a068:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  10a06b:	88 90 45 01 00 00    	mov    %dl,0x145(%eax)
    cprintf("   MAC Address: %02x:%02x:%02x:%02x:%02x:%02x\n",
  10a071:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  10a074:	0f b6 80 45 01 00 00 	movzbl 0x145(%eax),%eax
  10a07b:	0f be d8             	movsbl %al,%ebx
  10a07e:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  10a081:	0f b6 80 44 01 00 00 	movzbl 0x144(%eax),%eax
  10a088:	0f be f0             	movsbl %al,%esi
  10a08b:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  10a08e:	0f b6 80 43 01 00 00 	movzbl 0x143(%eax),%eax
  10a095:	0f be f8             	movsbl %al,%edi
  10a098:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  10a09b:	0f b6 80 42 01 00 00 	movzbl 0x142(%eax),%eax
  10a0a2:	0f be d0             	movsbl %al,%edx
  10a0a5:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  10a0a8:	0f b6 80 41 01 00 00 	movzbl 0x141(%eax),%eax
  10a0af:	0f be c8             	movsbl %al,%ecx
  10a0b2:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  10a0b5:	0f b6 80 40 01 00 00 	movzbl 0x140(%eax),%eax
  10a0bc:	0f be c0             	movsbl %al,%eax
  10a0bf:	89 5c 24 18          	mov    %ebx,0x18(%esp)
  10a0c3:	89 74 24 14          	mov    %esi,0x14(%esp)
  10a0c7:	89 7c 24 10          	mov    %edi,0x10(%esp)
  10a0cb:	89 54 24 0c          	mov    %edx,0xc(%esp)
  10a0cf:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  10a0d3:	89 44 24 04          	mov    %eax,0x4(%esp)
  10a0d7:	c7 04 24 d8 ab 11 00 	movl   $0x11abd8,(%esp)
  10a0de:	e8 2d 66 ff ff       	call   100710 <cprintf>
            dev->macaddr[0],
            dev->macaddr[1],
            dev->macaddr[2],
            dev->macaddr[3],
            dev->macaddr[4],
            dev->macaddr[5]);

    struct ip_addr ipaddr;
    IP4_ADDR(&ipaddr, 192, 168, 1, 1);
  10a0e3:	c7 04 24 01 01 a8 c0 	movl   $0xc0a80101,(%esp)
  10a0ea:	e8 e1 41 00 00       	call   10e2d0 <htonl>
  10a0ef:	89 45 da             	mov    %eax,0xffffffda(%ebp)
    struct ip_addr netmask;
    IP4_ADDR(&netmask, 255, 255, 255, 0);
  10a0f2:	c7 04 24 00 ff ff ff 	movl   $0xffffff00,(%esp)
  10a0f9:	e8 d2 41 00 00       	call   10e2d0 <htonl>
  10a0fe:	89 45 d6             	mov    %eax,0xffffffd6(%ebp)
    struct ip_addr gw;
    IP4_ADDR(&gw, 192, 168, 1, 2);
  10a101:	c7 04 24 02 01 a8 c0 	movl   $0xc0a80102,(%esp)
  10a108:	e8 c3 41 00 00       	call   10e2d0 <htonl>
  10a10d:	89 45 d2             	mov    %eax,0xffffffd2(%ebp)

    netif_add(&dev->netif, &ipaddr, &netmask, &gw, 0, ethernetif_init, ip_input);
  10a110:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
  10a113:	83 c2 38             	add    $0x38,%edx
  10a116:	c7 44 24 18 60 cb 10 	movl   $0x10cb60,0x18(%esp)
  10a11d:	00 
  10a11e:	c7 44 24 14 e0 c4 10 	movl   $0x10c4e0,0x14(%esp)
  10a125:	00 
  10a126:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  10a12d:	00 
  10a12e:	8d 45 d2             	lea    0xffffffd2(%ebp),%eax
  10a131:	89 44 24 0c          	mov    %eax,0xc(%esp)
  10a135:	8d 45 d6             	lea    0xffffffd6(%ebp),%eax
  10a138:	89 44 24 08          	mov    %eax,0x8(%esp)
  10a13c:	8d 45 da             	lea    0xffffffda(%ebp),%eax
  10a13f:	89 44 24 04          	mov    %eax,0x4(%esp)
  10a143:	89 14 24             	mov    %edx,(%esp)
  10a146:	e8 e5 49 00 00       	call   10eb30 <netif_add>
    struct ethernetif *eif = dev->netif.state;
  10a14b:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  10a14e:	8b 40 54             	mov    0x54(%eax),%eax
  10a151:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
    eif->receive = e100_receive;
  10a154:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10a157:	c7 40 08 70 ad 10 00 	movl   $0x10ad70,0x8(%eax)
    eif->send = e100_send;
  10a15e:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10a161:	c7 40 04 f0 ac 10 00 	movl   $0x10acf0,0x4(%eax)
    eif->ethaddr = dev->macaddr;
  10a168:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  10a16b:	05 40 01 00 00       	add    $0x140,%eax
  10a170:	89 c2                	mov    %eax,%edx
  10a172:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10a175:	89 10                	mov    %edx,(%eax)
    dev->netif.hwaddr_len = 6;
  10a177:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  10a17a:	c6 40 58 06          	movb   $0x6,0x58(%eax)
    memcpy(dev->netif.hwaddr, dev->macaddr, 6);
  10a17e:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  10a181:	05 40 01 00 00       	add    $0x140,%eax
  10a186:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
  10a189:	83 c2 59             	add    $0x59,%edx
  10a18c:	c7 44 24 08 06 00 00 	movl   $0x6,0x8(%esp)
  10a193:	00 
  10a194:	89 44 24 04          	mov    %eax,0x4(%esp)
  10a198:	89 14 24             	mov    %edx,(%esp)
  10a19b:	e8 f0 bc ff ff       	call   105e90 <memcpy>
    reg_irq_handler(dev->irq, e100_intr);
  10a1a0:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  10a1a3:	8b 00                	mov    (%eax),%eax
  10a1a5:	c7 44 24 04 00 a6 10 	movl   $0x10a600,0x4(%esp)
  10a1ac:	00 
  10a1ad:	89 04 24             	mov    %eax,(%esp)
  10a1b0:	e8 ab 9f ff ff       	call   104160 <reg_irq_handler>
    pic_enable(dev->irq);
  10a1b5:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  10a1b8:	8b 00                	mov    (%eax),%eax
  10a1ba:	89 04 24             	mov    %eax,(%esp)
  10a1bd:	e8 2e a0 ff ff       	call   1041f0 <pic_enable>
    ioapic_enable(dev->irq, ncpu-1);
  10a1c2:	a1 0c dd 13 00       	mov    0x13dd0c,%eax
  10a1c7:	8d 50 ff             	lea    0xffffffff(%eax),%edx
  10a1ca:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  10a1cd:	8b 00                	mov    (%eax),%eax
  10a1cf:	89 54 24 04          	mov    %edx,0x4(%esp)
  10a1d3:	89 04 24             	mov    %eax,(%esp)
  10a1d6:	e8 65 90 ff ff       	call   103240 <ioapic_enable>
    kproc_start(e100_rx_thread, dev, 0, 0, "[e100 rx thread]");
  10a1db:	c7 44 24 10 07 ac 11 	movl   $0x11ac07,0x10(%esp)
  10a1e2:	00 
  10a1e3:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  10a1ea:	00 
  10a1eb:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  10a1f2:	00 
  10a1f3:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  10a1f6:	89 44 24 04          	mov    %eax,0x4(%esp)
  10a1fa:	c7 04 24 60 af 10 00 	movl   $0x10af60,(%esp)
  10a201:	e8 ba f9 ff ff       	call   109bc0 <kproc_start>
    e100_ru_start(dev);
  10a206:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  10a209:	89 04 24             	mov    %eax,(%esp)
  10a20c:	e8 1f 0b 00 00       	call   10ad30 <e100_ru_start>
    return 1;
  10a211:	c7 45 c0 01 00 00 00 	movl   $0x1,0xffffffc0(%ebp)
  10a218:	8b 45 c0             	mov    0xffffffc0(%ebp),%eax
}
  10a21b:	83 c4 5c             	add    $0x5c,%esp
  10a21e:	5b                   	pop    %ebx
  10a21f:	5e                   	pop    %esi
  10a220:	5f                   	pop    %edi
  10a221:	5d                   	pop    %ebp
  10a222:	c3                   	ret    
  10a223:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  10a229:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

0010a230 <delay>:

static void
delay(int n)
{
  10a230:	55                   	push   %ebp
  10a231:	89 e5                	mov    %esp,%ebp
  10a233:	83 ec 10             	sub    $0x10,%esp
    volatile int i;
    int j;
    for (j=0; j<n; j++)
  10a236:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
  10a23d:	eb 20                	jmp    10a25f <delay+0x2f>
    {
    for (i=0; i<1000; i++)
  10a23f:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)
  10a246:	eb 09                	jmp    10a251 <delay+0x21>
  10a248:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10a24b:	83 c0 01             	add    $0x1,%eax
  10a24e:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  10a251:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10a254:	3d e7 03 00 00       	cmp    $0x3e7,%eax
  10a259:	7e ed                	jle    10a248 <delay+0x18>
  10a25b:	83 45 fc 01          	addl   $0x1,0xfffffffc(%ebp)
  10a25f:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10a262:	3b 45 08             	cmp    0x8(%ebp),%eax
  10a265:	7c d8                	jl     10a23f <delay+0xf>
        ;
    }
}
  10a267:	c9                   	leave  
  10a268:	c3                   	ret    
  10a269:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

0010a270 <e100_reset>:

int
e100_reset(e100_dev *dev)
{
  10a270:	55                   	push   %ebp
  10a271:	89 e5                	mov    %esp,%ebp
  10a273:	83 ec 18             	sub    $0x18,%esp
    outl(dev->iobase + SCB_PORT, PORT_SOFT_RESET);
  10a276:	8b 45 08             	mov    0x8(%ebp),%eax
  10a279:	8b 40 34             	mov    0x34(%eax),%eax
  10a27c:	83 c0 08             	add    $0x8,%eax
  10a27f:	0f b7 c0             	movzwl %ax,%eax
  10a282:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  10a289:	00 
  10a28a:	89 04 24             	mov    %eax,(%esp)
  10a28d:	e8 4e 00 00 00       	call   10a2e0 <outl>
    delay(10);
  10a292:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
  10a299:	e8 92 ff ff ff       	call   10a230 <delay>
    scb_command_word cmd;
    cmd.word = 0;
  10a29e:	66 c7 45 fe 00 00    	movw   $0x0,0xfffffffe(%ebp)
    cmd.cmd.cu_command = CUC_DUMP_RESET;
  10a2a4:	0f b6 45 fe          	movzbl 0xfffffffe(%ebp),%eax
  10a2a8:	83 e0 0f             	and    $0xf,%eax
  10a2ab:	83 c8 70             	or     $0x70,%eax
  10a2ae:	88 45 fe             	mov    %al,0xfffffffe(%ebp)
    outw(dev->iobase + SCB_COMMAND, cmd.word);
  10a2b1:	0f b7 45 fe          	movzwl 0xfffffffe(%ebp),%eax
  10a2b5:	0f b7 d0             	movzwl %ax,%edx
  10a2b8:	8b 45 08             	mov    0x8(%ebp),%eax
  10a2bb:	8b 40 34             	mov    0x34(%eax),%eax
  10a2be:	83 c0 02             	add    $0x2,%eax
  10a2c1:	0f b7 c0             	movzwl %ax,%eax
  10a2c4:	89 54 24 04          	mov    %edx,0x4(%esp)
  10a2c8:	89 04 24             	mov    %eax,(%esp)
  10a2cb:	e8 30 00 00 00       	call   10a300 <outw>
    return 0;
  10a2d0:	b8 00 00 00 00       	mov    $0x0,%eax
}
  10a2d5:	c9                   	leave  
  10a2d6:	c3                   	ret    
  10a2d7:	89 f6                	mov    %esi,%esi
  10a2d9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

0010a2e0 <outl>:
}

static inline void
outl(ushort port, uint data)
{
  10a2e0:	55                   	push   %ebp
  10a2e1:	89 e5                	mov    %esp,%ebp
  10a2e3:	83 ec 04             	sub    $0x4,%esp
  10a2e6:	8b 45 08             	mov    0x8(%ebp),%eax
  10a2e9:	66 89 45 fc          	mov    %ax,0xfffffffc(%ebp)
    asm volatile("out %0,%1" : : "a" (data), "d" (port));
  10a2ed:	8b 45 0c             	mov    0xc(%ebp),%eax
  10a2f0:	0f b7 55 fc          	movzwl 0xfffffffc(%ebp),%edx
  10a2f4:	ef                   	out    %eax,(%dx)
}
  10a2f5:	c9                   	leave  
  10a2f6:	c3                   	ret    
  10a2f7:	89 f6                	mov    %esi,%esi
  10a2f9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

0010a300 <outw>:
  10a300:	55                   	push   %ebp
  10a301:	89 e5                	mov    %esp,%ebp
  10a303:	83 ec 08             	sub    $0x8,%esp
  10a306:	8b 45 08             	mov    0x8(%ebp),%eax
  10a309:	8b 55 0c             	mov    0xc(%ebp),%edx
  10a30c:	66 89 45 fc          	mov    %ax,0xfffffffc(%ebp)
  10a310:	66 89 55 f8          	mov    %dx,0xfffffff8(%ebp)
  10a314:	0f b7 45 f8          	movzwl 0xfffffff8(%ebp),%eax
  10a318:	0f b7 55 fc          	movzwl 0xfffffffc(%ebp),%edx
  10a31c:	66 ef                	out    %ax,(%dx)
  10a31e:	c9                   	leave  
  10a31f:	c3                   	ret    

0010a320 <e100_get_state>:

scb_status_word
e100_get_state(e100_dev *dev)
{
  10a320:	55                   	push   %ebp
  10a321:	89 e5                	mov    %esp,%ebp
  10a323:	83 ec 18             	sub    $0x18,%esp
    scb_status_word st;
    st.word = inw(dev->iobase + SCB_STATUS);
  10a326:	8b 45 08             	mov    0x8(%ebp),%eax
  10a329:	8b 40 34             	mov    0x34(%eax),%eax
  10a32c:	0f b7 c0             	movzwl %ax,%eax
  10a32f:	89 04 24             	mov    %eax,(%esp)
  10a332:	e8 19 00 00 00       	call   10a350 <inw>
  10a337:	66 89 45 fe          	mov    %ax,0xfffffffe(%ebp)
    return st;
  10a33b:	0f b7 45 fe          	movzwl 0xfffffffe(%ebp),%eax
}
  10a33f:	c9                   	leave  
  10a340:	c3                   	ret    
  10a341:	eb 0d                	jmp    10a350 <inw>
  10a343:	90                   	nop    
  10a344:	90                   	nop    
  10a345:	90                   	nop    
  10a346:	90                   	nop    
  10a347:	90                   	nop    
  10a348:	90                   	nop    
  10a349:	90                   	nop    
  10a34a:	90                   	nop    
  10a34b:	90                   	nop    
  10a34c:	90                   	nop    
  10a34d:	90                   	nop    
  10a34e:	90                   	nop    
  10a34f:	90                   	nop    

0010a350 <inw>:
}

static inline ushort
inw(ushort port)
{
  10a350:	55                   	push   %ebp
  10a351:	89 e5                	mov    %esp,%ebp
  10a353:	83 ec 14             	sub    $0x14,%esp
  10a356:	8b 45 08             	mov    0x8(%ebp),%eax
  10a359:	66 89 45 ec          	mov    %ax,0xffffffec(%ebp)
    ushort data;

    asm volatile("in %1,%0" : "=a" (data) : "d" (port));
  10a35d:	0f b7 55 ec          	movzwl 0xffffffec(%ebp),%edx
  10a361:	66 ed                	in     (%dx),%ax
  10a363:	66 89 45 fe          	mov    %ax,0xfffffffe(%ebp)
    return data;
  10a367:	0f b7 45 fe          	movzwl 0xfffffffe(%ebp),%eax
}
  10a36b:	c9                   	leave  
  10a36c:	c3                   	ret    
  10a36d:	8d 76 00             	lea    0x0(%esi),%esi

0010a370 <e100_put_state>:

void
e100_put_state(e100_dev *dev, scb_status_word stat)
{
  10a370:	55                   	push   %ebp
  10a371:	89 e5                	mov    %esp,%ebp
  10a373:	83 ec 08             	sub    $0x8,%esp
    outw(dev->iobase + SCB_STATUS, stat.word);
  10a376:	0f b7 45 0c          	movzwl 0xc(%ebp),%eax
  10a37a:	0f b7 d0             	movzwl %ax,%edx
  10a37d:	8b 45 08             	mov    0x8(%ebp),%eax
  10a380:	8b 40 34             	mov    0x34(%eax),%eax
  10a383:	0f b7 c0             	movzwl %ax,%eax
  10a386:	89 54 24 04          	mov    %edx,0x4(%esp)
  10a38a:	89 04 24             	mov    %eax,(%esp)
  10a38d:	e8 6e ff ff ff       	call   10a300 <outw>
}
  10a392:	c9                   	leave  
  10a393:	c3                   	ret    
  10a394:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  10a39a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

0010a3a0 <e100_print_state>:

scb_status_word
e100_print_state(e100_dev *dev)
{
  10a3a0:	55                   	push   %ebp
  10a3a1:	89 e5                	mov    %esp,%ebp
  10a3a3:	83 ec 18             	sub    $0x18,%esp
    scb_status_word state = e100_get_state(dev);
  10a3a6:	8b 45 08             	mov    0x8(%ebp),%eax
  10a3a9:	89 04 24             	mov    %eax,(%esp)
  10a3ac:	e8 6f ff ff ff       	call   10a320 <e100_get_state>
  10a3b1:	66 89 45 fe          	mov    %ax,0xfffffffe(%ebp)
    cprintf("   RU Status: %s\n", ru_state_name[state.status.rus]);
  10a3b5:	0f b6 45 fe          	movzbl 0xfffffffe(%ebp),%eax
  10a3b9:	c1 e0 02             	shl    $0x2,%eax
  10a3bc:	c0 f8 04             	sar    $0x4,%al
  10a3bf:	0f be c0             	movsbl %al,%eax
  10a3c2:	8b 04 85 60 cb 11 00 	mov    0x11cb60(,%eax,4),%eax
  10a3c9:	89 44 24 04          	mov    %eax,0x4(%esp)
  10a3cd:	c7 04 24 18 ac 11 00 	movl   $0x11ac18,(%esp)
  10a3d4:	e8 37 63 ff ff       	call   100710 <cprintf>
    cprintf("   CU Status: %s\n", cu_state_name[state.status.cus]);
  10a3d9:	0f b6 45 fe          	movzbl 0xfffffffe(%ebp),%eax
  10a3dd:	c0 f8 06             	sar    $0x6,%al
  10a3e0:	0f be c0             	movsbl %al,%eax
  10a3e3:	8b 04 85 40 cb 11 00 	mov    0x11cb40(,%eax,4),%eax
  10a3ea:	89 44 24 04          	mov    %eax,0x4(%esp)
  10a3ee:	c7 04 24 2a ac 11 00 	movl   $0x11ac2a,(%esp)
  10a3f5:	e8 16 63 ff ff       	call   100710 <cprintf>

    struct scb_status_word stat = state.status;
  10a3fa:	0f b7 45 fe          	movzwl 0xfffffffe(%ebp),%eax
  10a3fe:	66 89 45 fc          	mov    %ax,0xfffffffc(%ebp)
    if (stat.cx) cprintf("   CU executed\n");
  10a402:	0f b6 45 fd          	movzbl 0xfffffffd(%ebp),%eax
  10a406:	83 e0 80             	and    $0xffffff80,%eax
  10a409:	84 c0                	test   %al,%al
  10a40b:	74 0c                	je     10a419 <e100_print_state+0x79>
  10a40d:	c7 04 24 3c ac 11 00 	movl   $0x11ac3c,(%esp)
  10a414:	e8 f7 62 ff ff       	call   100710 <cprintf>
    if (stat.fr)
  10a419:	0f b6 45 fd          	movzbl 0xfffffffd(%ebp),%eax
  10a41d:	83 e0 40             	and    $0x40,%eax
  10a420:	84 c0                	test   %al,%al
  10a422:	74 0c                	je     10a430 <e100_print_state+0x90>
        cprintf("   RU received\n");
  10a424:	c7 04 24 4c ac 11 00 	movl   $0x11ac4c,(%esp)
  10a42b:	e8 e0 62 ff ff       	call   100710 <cprintf>
    if (stat.cna)
  10a430:	0f b6 45 fd          	movzbl 0xfffffffd(%ebp),%eax
  10a434:	83 e0 20             	and    $0x20,%eax
  10a437:	84 c0                	test   %al,%al
  10a439:	74 0c                	je     10a447 <e100_print_state+0xa7>
        cprintf("   CU state change\n");
  10a43b:	c7 04 24 5c ac 11 00 	movl   $0x11ac5c,(%esp)
  10a442:	e8 c9 62 ff ff       	call   100710 <cprintf>
    if (stat.rnr)
  10a447:	0f b6 45 fd          	movzbl 0xfffffffd(%ebp),%eax
  10a44b:	83 e0 10             	and    $0x10,%eax
  10a44e:	84 c0                	test   %al,%al
  10a450:	74 0c                	je     10a45e <e100_print_state+0xbe>
        cprintf("   RU not ready\n");
  10a452:	c7 04 24 70 ac 11 00 	movl   $0x11ac70,(%esp)
  10a459:	e8 b2 62 ff ff       	call   100710 <cprintf>
    if (stat.mdi)
  10a45e:	0f b6 45 fd          	movzbl 0xfffffffd(%ebp),%eax
  10a462:	83 e0 08             	and    $0x8,%eax
  10a465:	84 c0                	test   %al,%al
  10a467:	74 0c                	je     10a475 <e100_print_state+0xd5>
        cprintf("   MDI operation completed\n");
  10a469:	c7 04 24 81 ac 11 00 	movl   $0x11ac81,(%esp)
  10a470:	e8 9b 62 ff ff       	call   100710 <cprintf>
    if (stat.swi)
  10a475:	0f b6 45 fd          	movzbl 0xfffffffd(%ebp),%eax
  10a479:	83 e0 04             	and    $0x4,%eax
  10a47c:	84 c0                	test   %al,%al
  10a47e:	74 0c                	je     10a48c <e100_print_state+0xec>
        cprintf("   Software Interrupt\n");
  10a480:	c7 04 24 9d ac 11 00 	movl   $0x11ac9d,(%esp)
  10a487:	e8 84 62 ff ff       	call   100710 <cprintf>
    if (stat.fcp)
  10a48c:	0f b6 45 fd          	movzbl 0xfffffffd(%ebp),%eax
  10a490:	83 e0 01             	and    $0x1,%eax
  10a493:	84 c0                	test   %al,%al
  10a495:	74 0c                	je     10a4a3 <e100_print_state+0x103>
        cprintf("   Flow Control Pause\n");
  10a497:	c7 04 24 b4 ac 11 00 	movl   $0x11acb4,(%esp)
  10a49e:	e8 6d 62 ff ff       	call   100710 <cprintf>

    return state;
  10a4a3:	0f b7 45 fe          	movzwl 0xfffffffe(%ebp),%eax
}
  10a4a7:	c9                   	leave  
  10a4a8:	c3                   	ret    
  10a4a9:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

0010a4b0 <e100_read_scb_command>:

char *cu_state_name[4] = {
    "Idle",
    "Suspended",
    "LPQ Active",
    "HQP Active",
};

char *ru_state_name[16] = {
    "Idle",
    "Suspended",
    "No resources",
    "Reserved",
    "Ready",
    "Reserved",
    "Reserved",
    "Reserved",
    "Reserved",
    "Reserved",
    "Reserved",
    "Reserved",
    "Reserved",
    "Reserved",
    "Reserved",
    "Reserved",
};

uint8_t
e100_read_scb_command(e100_dev *dev)
{
  10a4b0:	55                   	push   %ebp
  10a4b1:	89 e5                	mov    %esp,%ebp
  10a4b3:	83 ec 08             	sub    $0x8,%esp
    return inb(dev->iobase + SCB_COMMAND + 1);
  10a4b6:	8b 45 08             	mov    0x8(%ebp),%eax
  10a4b9:	8b 40 34             	mov    0x34(%eax),%eax
  10a4bc:	83 c0 03             	add    $0x3,%eax
  10a4bf:	0f b7 c0             	movzwl %ax,%eax
  10a4c2:	89 04 24             	mov    %eax,(%esp)
  10a4c5:	e8 06 00 00 00       	call   10a4d0 <inb>
  10a4ca:	0f b6 c0             	movzbl %al,%eax
}
  10a4cd:	c9                   	leave  
  10a4ce:	c3                   	ret    
  10a4cf:	90                   	nop    

0010a4d0 <inb>:
// Routines to let C code use special x86 instructions.

static inline uchar
inb(ushort port)
{
  10a4d0:	55                   	push   %ebp
  10a4d1:	89 e5                	mov    %esp,%ebp
  10a4d3:	83 ec 14             	sub    $0x14,%esp
  10a4d6:	8b 45 08             	mov    0x8(%ebp),%eax
  10a4d9:	66 89 45 ec          	mov    %ax,0xffffffec(%ebp)
  uchar data;

  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
  10a4dd:	0f b7 55 ec          	movzwl 0xffffffec(%ebp),%edx
  10a4e1:	ec                   	in     (%dx),%al
  10a4e2:	88 45 ff             	mov    %al,0xffffffff(%ebp)
  return data;
  10a4e5:	0f b6 45 ff          	movzbl 0xffffffff(%ebp),%eax
}
  10a4e9:	c9                   	leave  
  10a4ea:	c3                   	ret    
  10a4eb:	90                   	nop    
  10a4ec:	8d 74 26 00          	lea    0x0(%esi),%esi

0010a4f0 <e100_set_gp>:

void
e100_set_gp(e100_dev *dev, void *addr)
{
  10a4f0:	55                   	push   %ebp
  10a4f1:	89 e5                	mov    %esp,%ebp
  10a4f3:	83 ec 08             	sub    $0x8,%esp
    outl(dev->iobase + SCB_GENPTR, (uint32_t)addr);
  10a4f6:	8b 45 0c             	mov    0xc(%ebp),%eax
  10a4f9:	89 c2                	mov    %eax,%edx
  10a4fb:	8b 45 08             	mov    0x8(%ebp),%eax
  10a4fe:	8b 40 34             	mov    0x34(%eax),%eax
  10a501:	83 c0 04             	add    $0x4,%eax
  10a504:	0f b7 c0             	movzwl %ax,%eax
  10a507:	89 54 24 04          	mov    %edx,0x4(%esp)
  10a50b:	89 04 24             	mov    %eax,(%esp)
  10a50e:	e8 cd fd ff ff       	call   10a2e0 <outl>
}
  10a513:	c9                   	leave  
  10a514:	c3                   	ret    
  10a515:	8d 74 26 00          	lea    0x0(%esi),%esi
  10a519:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

0010a520 <e100_cu_command>:

void
e100_cu_command(e100_dev *dev, int command, void *cmd_addr)
{
  10a520:	55                   	push   %ebp
  10a521:	89 e5                	mov    %esp,%ebp
  10a523:	83 ec 18             	sub    $0x18,%esp
    scb_command_word cmd;
    cmd.word = 0;
  10a526:	66 c7 45 fe 00 00    	movw   $0x0,0xfffffffe(%ebp)
    cmd.cmd.cu_command = command;
  10a52c:	8b 45 0c             	mov    0xc(%ebp),%eax
  10a52f:	c1 e0 04             	shl    $0x4,%eax
  10a532:	c0 f8 04             	sar    $0x4,%al
  10a535:	89 c2                	mov    %eax,%edx
  10a537:	c1 e2 04             	shl    $0x4,%edx
  10a53a:	0f b6 45 fe          	movzbl 0xfffffffe(%ebp),%eax
  10a53e:	83 e0 0f             	and    $0xf,%eax
  10a541:	09 d0                	or     %edx,%eax
  10a543:	88 45 fe             	mov    %al,0xfffffffe(%ebp)
    e100_set_gp(dev, cmd_addr);
  10a546:	8b 45 10             	mov    0x10(%ebp),%eax
  10a549:	89 44 24 04          	mov    %eax,0x4(%esp)
  10a54d:	8b 45 08             	mov    0x8(%ebp),%eax
  10a550:	89 04 24             	mov    %eax,(%esp)
  10a553:	e8 98 ff ff ff       	call   10a4f0 <e100_set_gp>
    outw(dev->iobase + SCB_COMMAND, cmd.word);
  10a558:	0f b7 45 fe          	movzwl 0xfffffffe(%ebp),%eax
  10a55c:	0f b7 d0             	movzwl %ax,%edx
  10a55f:	8b 45 08             	mov    0x8(%ebp),%eax
  10a562:	8b 40 34             	mov    0x34(%eax),%eax
  10a565:	83 c0 02             	add    $0x2,%eax
  10a568:	0f b7 c0             	movzwl %ax,%eax
  10a56b:	89 54 24 04          	mov    %edx,0x4(%esp)
  10a56f:	89 04 24             	mov    %eax,(%esp)
  10a572:	e8 89 fd ff ff       	call   10a300 <outw>
    while (e100_read_scb_command(dev)) ;
  10a577:	8b 45 08             	mov    0x8(%ebp),%eax
  10a57a:	89 04 24             	mov    %eax,(%esp)
  10a57d:	e8 2e ff ff ff       	call   10a4b0 <e100_read_scb_command>
  10a582:	84 c0                	test   %al,%al
  10a584:	75 f1                	jne    10a577 <e100_cu_command+0x57>
}
  10a586:	c9                   	leave  
  10a587:	c3                   	ret    
  10a588:	90                   	nop    
  10a589:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

0010a590 <e100_ru_command>:

void
e100_ru_command(e100_dev *dev, int command, void *cmd_addr)
{
  10a590:	55                   	push   %ebp
  10a591:	89 e5                	mov    %esp,%ebp
  10a593:	83 ec 18             	sub    $0x18,%esp
    scb_command_word cmd;
    cmd.word = 0;
  10a596:	66 c7 45 fe 00 00    	movw   $0x0,0xfffffffe(%ebp)
    cmd.cmd.ru_command = command;
  10a59c:	8b 45 0c             	mov    0xc(%ebp),%eax
  10a59f:	c1 e0 05             	shl    $0x5,%eax
  10a5a2:	c0 f8 05             	sar    $0x5,%al
  10a5a5:	89 c2                	mov    %eax,%edx
  10a5a7:	83 e2 07             	and    $0x7,%edx
  10a5aa:	0f b6 45 fe          	movzbl 0xfffffffe(%ebp),%eax
  10a5ae:	83 e0 f8             	and    $0xfffffff8,%eax
  10a5b1:	09 d0                	or     %edx,%eax
  10a5b3:	88 45 fe             	mov    %al,0xfffffffe(%ebp)
    e100_set_gp(dev, cmd_addr);
  10a5b6:	8b 45 10             	mov    0x10(%ebp),%eax
  10a5b9:	89 44 24 04          	mov    %eax,0x4(%esp)
  10a5bd:	8b 45 08             	mov    0x8(%ebp),%eax
  10a5c0:	89 04 24             	mov    %eax,(%esp)
  10a5c3:	e8 28 ff ff ff       	call   10a4f0 <e100_set_gp>
    outw(dev->iobase + SCB_COMMAND, cmd.word);
  10a5c8:	0f b7 45 fe          	movzwl 0xfffffffe(%ebp),%eax
  10a5cc:	0f b7 d0             	movzwl %ax,%edx
  10a5cf:	8b 45 08             	mov    0x8(%ebp),%eax
  10a5d2:	8b 40 34             	mov    0x34(%eax),%eax
  10a5d5:	83 c0 02             	add    $0x2,%eax
  10a5d8:	0f b7 c0             	movzwl %ax,%eax
  10a5db:	89 54 24 04          	mov    %edx,0x4(%esp)
  10a5df:	89 04 24             	mov    %eax,(%esp)
  10a5e2:	e8 19 fd ff ff       	call   10a300 <outw>
    while (e100_read_scb_command(dev)) ;
  10a5e7:	8b 45 08             	mov    0x8(%ebp),%eax
  10a5ea:	89 04 24             	mov    %eax,(%esp)
  10a5ed:	e8 be fe ff ff       	call   10a4b0 <e100_read_scb_command>
  10a5f2:	84 c0                	test   %al,%al
  10a5f4:	75 f1                	jne    10a5e7 <e100_ru_command+0x57>
}
  10a5f6:	c9                   	leave  
  10a5f7:	c3                   	ret    
  10a5f8:	90                   	nop    
  10a5f9:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

0010a600 <e100_intr>:

// Interrupt
void
e100_intr(struct trapframe *tf)
{
  10a600:	55                   	push   %ebp
  10a601:	89 e5                	mov    %esp,%ebp
  10a603:	83 ec 28             	sub    $0x28,%esp
//    cprintf("e100_intr\n");
    int i;
    int index = -1;
  10a606:	c7 45 f8 ff ff ff ff 	movl   $0xffffffff,0xfffffff8(%ebp)
    for (i=0; i< dev_count; i++)
  10a60d:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
  10a614:	eb 28                	jmp    10a63e <e100_intr+0x3e>
    {
        if (tf->trapno == IRQ_OFFSET + e100_devs[i].irq)
  10a616:	8b 45 08             	mov    0x8(%ebp),%eax
  10a619:	8b 50 28             	mov    0x28(%eax),%edx
  10a61c:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10a61f:	69 c0 48 01 00 00    	imul   $0x148,%eax,%eax
  10a625:	8b 80 e0 cd 11 00    	mov    0x11cde0(%eax),%eax
  10a62b:	83 c0 20             	add    $0x20,%eax
  10a62e:	39 c2                	cmp    %eax,%edx
  10a630:	75 08                	jne    10a63a <e100_intr+0x3a>
        {
            index = i;
  10a632:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10a635:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
            break;
  10a638:	eb 0e                	jmp    10a648 <e100_intr+0x48>
  10a63a:	83 45 f4 01          	addl   $0x1,0xfffffff4(%ebp)
  10a63e:	a1 c0 cd 11 00       	mov    0x11cdc0,%eax
  10a643:	39 45 f4             	cmp    %eax,0xfffffff4(%ebp)
  10a646:	7c ce                	jl     10a616 <e100_intr+0x16>
        }
    }
    if (index == -1)
  10a648:	83 7d f8 ff          	cmpl   $0xffffffff,0xfffffff8(%ebp)
  10a64c:	75 11                	jne    10a65f <e100_intr+0x5f>
    {
        cprintf("e100_intr: can't find corresponding device\n");
  10a64e:	c7 04 24 0c ad 11 00 	movl   $0x11ad0c,(%esp)
  10a655:	e8 b6 60 ff ff       	call   100710 <cprintf>
        return;
  10a65a:	e9 ce 01 00 00       	jmp    10a82d <e100_intr+0x22d>
    }
    e100_dev *dev = &e100_devs[index];
  10a65f:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10a662:	69 c0 48 01 00 00    	imul   $0x148,%eax,%eax
  10a668:	05 e0 cd 11 00       	add    $0x11cde0,%eax
  10a66d:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
//    e100_print_state(dev);
    scb_status_word state = e100_get_state(dev);
  10a670:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10a673:	89 04 24             	mov    %eax,(%esp)
  10a676:	e8 a5 fc ff ff       	call   10a320 <e100_get_state>
  10a67b:	66 89 45 f2          	mov    %ax,0xfffffff2(%ebp)
    struct scb_status_word stat = state.status;
  10a67f:	0f b7 45 f2          	movzwl 0xfffffff2(%ebp),%eax
  10a683:	66 89 45 f0          	mov    %ax,0xfffffff0(%ebp)
    state.word |= 0xff00;
  10a687:	0f b7 45 f2          	movzwl 0xfffffff2(%ebp),%eax
  10a68b:	66 0d 00 ff          	or     $0xff00,%ax
  10a68f:	66 89 45 f2          	mov    %ax,0xfffffff2(%ebp)
    e100_put_state(dev, state);
  10a693:	0f b7 45 f2          	movzwl 0xfffffff2(%ebp),%eax
  10a697:	66 89 44 24 04       	mov    %ax,0x4(%esp)
  10a69c:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10a69f:	89 04 24             	mov    %eax,(%esp)
  10a6a2:	e8 c9 fc ff ff       	call   10a370 <e100_put_state>

    if (stat.cx)
    {
//        cprintf("   CU executed\n");
    }
    if (stat.fr)
  10a6a7:	0f b6 45 f1          	movzbl 0xfffffff1(%ebp),%eax
  10a6ab:	83 e0 40             	and    $0x40,%eax
  10a6ae:	84 c0                	test   %al,%al
  10a6b0:	74 3f                	je     10a6f1 <e100_intr+0xf1>
    {
        if (!dev->ru_first)
  10a6b2:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10a6b5:	8b 80 f8 00 00 00    	mov    0xf8(%eax),%eax
  10a6bb:	85 c0                	test   %eax,%eax
  10a6bd:	75 22                	jne    10a6e1 <e100_intr+0xe1>
        {
            dev->ru_first = dev->ru_last;
  10a6bf:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10a6c2:	8b 90 fc 00 00 00    	mov    0xfc(%eax),%edx
  10a6c8:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10a6cb:	89 90 f8 00 00 00    	mov    %edx,0xf8(%eax)
            wakeup(&dev->ru_first);
  10a6d1:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10a6d4:	05 f8 00 00 00       	add    $0xf8,%eax
  10a6d9:	89 04 24             	mov    %eax,(%esp)
  10a6dc:	e8 0f af ff ff       	call   1055f0 <wakeup>
        }
        wakeup(&dev->rxlock);
  10a6e1:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10a6e4:	05 08 01 00 00       	add    $0x108,%eax
  10a6e9:	89 04 24             	mov    %eax,(%esp)
  10a6ec:	e8 ff ae ff ff       	call   1055f0 <wakeup>
/*        while (dev->ru_last->eof)
        {
            ethernetif_input(&dev->netif);
            dev->ru_last = (void*)dev->ru_last->head.link;
        }*/
    }
    if (stat.cna)
  10a6f1:	0f b6 45 f1          	movzbl 0xfffffff1(%ebp),%eax
  10a6f5:	83 e0 20             	and    $0x20,%eax
  10a6f8:	84 c0                	test   %al,%al
  10a6fa:	0f 84 c4 00 00 00    	je     10a7c4 <e100_intr+0x1c4>
    {
/*        if (dev->cu_next_pkt != 0)
        {
            cprintf("   finished 0x%08x\n", dev->cu_next_pkt);
            if (dev->cu_next_pkt->link != 0)
            {
                cprintf("   starting next packet: "
                        "0x%08x\n", dev->cu_next_pkt->link);
                e100_cu_command(dev, CUC_START, 
                        (void*)dev->cu_next_pkt->link);
                dev->cuhead = dev->cu_next_pkt->link - dev->cubase;
                dev->cu_next_pkt = (command_block *)dev->cu_next_pkt->link;
            }
            else
            {
                dev->cuhead = dev->cuend;
                dev->cu_last_pkt = 0;
                dev->cu_next_pkt = 0;
            }
            ring_printinfo(dev);
        }*/
        if (dev->cu_last_pkt)
  10a700:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10a703:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
  10a709:	85 c0                	test   %eax,%eax
  10a70b:	0f 84 b3 00 00 00    	je     10a7c4 <e100_intr+0x1c4>
        {
            if (dev->cu_last_pkt->c)
  10a711:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10a714:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
  10a71a:	8b 00                	mov    (%eax),%eax
  10a71c:	25 00 80 00 00       	and    $0x8000,%eax
  10a721:	85 c0                	test   %eax,%eax
  10a723:	74 1f                	je     10a744 <e100_intr+0x144>
            {
                dev->cuidle = 1;
  10a725:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10a728:	c7 80 ac 00 00 00 01 	movl   $0x1,0xac(%eax)
  10a72f:	00 00 00 
//                dev->cuhead = dev->cuend;
                dev->cu_next_pkt = 0;
  10a732:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10a735:	c7 80 b4 00 00 00 00 	movl   $0x0,0xb4(%eax)
  10a73c:	00 00 00 
  10a73f:	e9 80 00 00 00       	jmp    10a7c4 <e100_intr+0x1c4>
//                dev->cu_last_pkt = 0;
            } else {
                dev->cuidle = 0;
  10a744:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10a747:	c7 80 ac 00 00 00 00 	movl   $0x0,0xac(%eax)
  10a74e:	00 00 00 
                while (dev->cu_next_pkt->c)
  10a751:	eb 42                	jmp    10a795 <e100_intr+0x195>
                {
                    if (!dev->cu_next_pkt->ok)
  10a753:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10a756:	8b 80 b4 00 00 00    	mov    0xb4(%eax),%eax
  10a75c:	8b 00                	mov    (%eax),%eax
  10a75e:	25 00 20 00 00       	and    $0x2000,%eax
  10a763:	85 c0                	test   %eax,%eax
  10a765:	75 19                	jne    10a780 <e100_intr+0x180>
                        cprintf("send error 0x%08x\n", dev->cu_next_pkt);
  10a767:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10a76a:	8b 80 b4 00 00 00    	mov    0xb4(%eax),%eax
  10a770:	89 44 24 04          	mov    %eax,0x4(%esp)
  10a774:	c7 04 24 38 ad 11 00 	movl   $0x11ad38,(%esp)
  10a77b:	e8 90 5f ff ff       	call   100710 <cprintf>
                    dev->cu_next_pkt = (void*)dev->cu_next_pkt->link;
  10a780:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10a783:	8b 80 b4 00 00 00    	mov    0xb4(%eax),%eax
  10a789:	8b 50 04             	mov    0x4(%eax),%edx
  10a78c:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10a78f:	89 90 b4 00 00 00    	mov    %edx,0xb4(%eax)
  10a795:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10a798:	8b 80 b4 00 00 00    	mov    0xb4(%eax),%eax
  10a79e:	8b 00                	mov    (%eax),%eax
  10a7a0:	25 00 80 00 00       	and    $0x8000,%eax
  10a7a5:	85 c0                	test   %eax,%eax
  10a7a7:	75 aa                	jne    10a753 <e100_intr+0x153>
                }
                e100_cu_command(dev, CUC_RESUME, 0);
  10a7a9:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  10a7b0:	00 
  10a7b1:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
  10a7b8:	00 
  10a7b9:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10a7bc:	89 04 24             	mov    %eax,(%esp)
  10a7bf:	e8 5c fd ff ff       	call   10a520 <e100_cu_command>
//                dev->cuhead = (uint32_t)dev->cu_next_pkt - dev->cubase;
            }
        }
//        ring_printinfo(dev);
    }
    if (stat.rnr)
  10a7c4:	0f b6 45 f1          	movzbl 0xfffffff1(%ebp),%eax
  10a7c8:	83 e0 10             	and    $0x10,%eax
  10a7cb:	84 c0                	test   %al,%al
  10a7cd:	74 19                	je     10a7e8 <e100_intr+0x1e8>
    {
        cprintf("e100: RU overrun!\n");
  10a7cf:	c7 04 24 4b ad 11 00 	movl   $0x11ad4b,(%esp)
  10a7d6:	e8 35 5f ff ff       	call   100710 <cprintf>
        dev->ru_full = 1;
  10a7db:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10a7de:	c7 80 04 01 00 00 01 	movl   $0x1,0x104(%eax)
  10a7e5:	00 00 00 
    }
    if (stat.mdi)
  10a7e8:	0f b6 45 f1          	movzbl 0xfffffff1(%ebp),%eax
  10a7ec:	83 e0 08             	and    $0x8,%eax
  10a7ef:	84 c0                	test   %al,%al
  10a7f1:	74 0c                	je     10a7ff <e100_intr+0x1ff>
        cprintf("   MDI operation completed\n");
  10a7f3:	c7 04 24 81 ac 11 00 	movl   $0x11ac81,(%esp)
  10a7fa:	e8 11 5f ff ff       	call   100710 <cprintf>
    if (stat.swi)
  10a7ff:	0f b6 45 f1          	movzbl 0xfffffff1(%ebp),%eax
  10a803:	83 e0 04             	and    $0x4,%eax
  10a806:	84 c0                	test   %al,%al
  10a808:	74 0c                	je     10a816 <e100_intr+0x216>
        cprintf("   Software Interrupt\n");
  10a80a:	c7 04 24 9d ac 11 00 	movl   $0x11ac9d,(%esp)
  10a811:	e8 fa 5e ff ff       	call   100710 <cprintf>
    if (stat.fcp)
  10a816:	0f b6 45 f1          	movzbl 0xfffffff1(%ebp),%eax
  10a81a:	83 e0 01             	and    $0x1,%eax
  10a81d:	84 c0                	test   %al,%al
  10a81f:	74 0c                	je     10a82d <e100_intr+0x22d>
        cprintf("   Flow Control Pause\n");
  10a821:	c7 04 24 b4 ac 11 00 	movl   $0x11acb4,(%esp)
  10a828:	e8 e3 5e ff ff       	call   100710 <cprintf>

}
  10a82d:	c9                   	leave  
  10a82e:	c3                   	ret    
  10a82f:	90                   	nop    

0010a830 <ring_printinfo>:

// Ring management
void
ring_printinfo(e100_dev *dev)
{
  10a830:	55                   	push   %ebp
  10a831:	89 e5                	mov    %esp,%ebp
  10a833:	83 ec 08             	sub    $0x8,%esp
    cprintf("Ring Info:   ");
  10a836:	c7 04 24 5e ad 11 00 	movl   $0x11ad5e,(%esp)
  10a83d:	e8 ce 5e ff ff       	call   100710 <cprintf>
    cprintf("head: 0x%08x  ", dev->cu_next_pkt);
  10a842:	8b 45 08             	mov    0x8(%ebp),%eax
  10a845:	8b 80 b4 00 00 00    	mov    0xb4(%eax),%eax
  10a84b:	89 44 24 04          	mov    %eax,0x4(%esp)
  10a84f:	c7 04 24 6c ad 11 00 	movl   $0x11ad6c,(%esp)
  10a856:	e8 b5 5e ff ff       	call   100710 <cprintf>
    cprintf("end:  0x%08x\n", dev->cu_last_pkt);
  10a85b:	8b 45 08             	mov    0x8(%ebp),%eax
  10a85e:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
  10a864:	89 44 24 04          	mov    %eax,0x4(%esp)
  10a868:	c7 04 24 7b ad 11 00 	movl   $0x11ad7b,(%esp)
  10a86f:	e8 9c 5e ff ff       	call   100710 <cprintf>
}
  10a874:	c9                   	leave  
  10a875:	c3                   	ret    
  10a876:	8d 76 00             	lea    0x0(%esi),%esi
  10a879:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

0010a880 <ring_init>:

void
ring_init(e100_dev *dev)
{
  10a880:	55                   	push   %ebp
  10a881:	89 e5                	mov    %esp,%ebp
  10a883:	83 ec 10             	sub    $0x10,%esp
    int i;
    dev->cucount = dev->cusize / E100_CB_SIZE;
  10a886:	8b 45 08             	mov    0x8(%ebp),%eax
  10a889:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
  10a88f:	89 c2                	mov    %eax,%edx
  10a891:	c1 ea 0b             	shr    $0xb,%edx
  10a894:	8b 45 08             	mov    0x8(%ebp),%eax
  10a897:	89 90 a4 00 00 00    	mov    %edx,0xa4(%eax)
    dev->cu_next_pkt = 0;
  10a89d:	8b 45 08             	mov    0x8(%ebp),%eax
  10a8a0:	c7 80 b4 00 00 00 00 	movl   $0x0,0xb4(%eax)
  10a8a7:	00 00 00 
    for (i=0; i<dev->cucount ; i++)
  10a8aa:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
  10a8b1:	e9 83 00 00 00       	jmp    10a939 <ring_init+0xb9>
    {
        command_block *cmd = (void*)(dev->cubase + i * E100_CB_SIZE);
  10a8b6:	8b 45 08             	mov    0x8(%ebp),%eax
  10a8b9:	8b 90 9c 00 00 00    	mov    0x9c(%eax),%edx
  10a8bf:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10a8c2:	c1 e0 0b             	shl    $0xb,%eax
  10a8c5:	8d 04 02             	lea    (%edx,%eax,1),%eax
  10a8c8:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
        cmd->cmd_word = 0;
  10a8cb:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10a8ce:	66 c7 40 02 00 00    	movw   $0x0,0x2(%eax)
        cmd->status_word = 0;
  10a8d4:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10a8d7:	66 c7 00 00 00       	movw   $0x0,(%eax)
        cmd->c = 1;
  10a8dc:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  10a8df:	8b 02                	mov    (%edx),%eax
  10a8e1:	80 cc 80             	or     $0x80,%ah
  10a8e4:	89 02                	mov    %eax,(%edx)
        cmd->el = 1;
  10a8e6:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  10a8e9:	0f b6 42 03          	movzbl 0x3(%edx),%eax
  10a8ed:	83 c8 80             	or     $0xffffff80,%eax
  10a8f0:	88 42 03             	mov    %al,0x3(%edx)
        if (i == dev->cucount - 1)
  10a8f3:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
  10a8f6:	8b 45 08             	mov    0x8(%ebp),%eax
  10a8f9:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
  10a8ff:	83 e8 01             	sub    $0x1,%eax
  10a902:	39 c2                	cmp    %eax,%edx
  10a904:	75 1f                	jne    10a925 <ring_init+0xa5>
        {
            cmd->link = (void*)dev->cubase;
  10a906:	8b 45 08             	mov    0x8(%ebp),%eax
  10a909:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
  10a90f:	89 c2                	mov    %eax,%edx
  10a911:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10a914:	89 50 04             	mov    %edx,0x4(%eax)
            dev->cu_last_pkt = cmd;
  10a917:	8b 55 08             	mov    0x8(%ebp),%edx
  10a91a:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10a91d:	89 82 b0 00 00 00    	mov    %eax,0xb0(%edx)
  10a923:	eb 10                	jmp    10a935 <ring_init+0xb5>
        }
        else
        {
            cmd->link = (void*)((uint32_t)cmd + E100_CB_SIZE);
  10a925:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10a928:	05 00 08 00 00       	add    $0x800,%eax
  10a92d:	89 c2                	mov    %eax,%edx
  10a92f:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10a932:	89 50 04             	mov    %edx,0x4(%eax)
  10a935:	83 45 f4 01          	addl   $0x1,0xfffffff4(%ebp)
  10a939:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10a93c:	8b 55 08             	mov    0x8(%ebp),%edx
  10a93f:	8b 92 a4 00 00 00    	mov    0xa4(%edx),%edx
  10a945:	39 d0                	cmp    %edx,%eax
  10a947:	0f 82 69 ff ff ff    	jb     10a8b6 <ring_init+0x36>
        }
//        cprintf("CB %d: start 0x%08x next 0x%08x\n", i, cmd, cmd->link);
    }
    dev->rucount = dev->rusize / E100_RFD_SIZE;
  10a94d:	8b 45 08             	mov    0x8(%ebp),%eax
  10a950:	8b 80 f0 00 00 00    	mov    0xf0(%eax),%eax
  10a956:	89 c2                	mov    %eax,%edx
  10a958:	c1 ea 0b             	shr    $0xb,%edx
  10a95b:	8b 45 08             	mov    0x8(%ebp),%eax
  10a95e:	89 90 f4 00 00 00    	mov    %edx,0xf4(%eax)
    for (i=0; i<dev->rucount; i++)
  10a964:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
  10a96b:	e9 eb 00 00 00       	jmp    10aa5b <ring_init+0x1db>
    {
        rf_desc *rfd = (void*)(dev->rubase + i * E100_RFD_SIZE);
  10a970:	8b 45 08             	mov    0x8(%ebp),%eax
  10a973:	8b 90 ec 00 00 00    	mov    0xec(%eax),%edx
  10a979:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10a97c:	c1 e0 0b             	shl    $0xb,%eax
  10a97f:	8d 04 02             	lea    (%edx,%eax,1),%eax
  10a982:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
        rfd->head.cmd_word = 0;
  10a985:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10a988:	66 c7 40 02 00 00    	movw   $0x0,0x2(%eax)
        rfd->head.status_word = 0;
  10a98e:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10a991:	66 c7 00 00 00       	movw   $0x0,(%eax)
        rfd->size = E100_RFD_SIZE - sizeof(rf_desc);
  10a996:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  10a999:	8b 42 0c             	mov    0xc(%edx),%eax
  10a99c:	25 ff ff 00 c0       	and    $0xc000ffff,%eax
  10a9a1:	0d 00 00 f0 07       	or     $0x7f00000,%eax
  10a9a6:	89 42 0c             	mov    %eax,0xc(%edx)
        if (rfd->size & 1)
  10a9a9:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10a9ac:	8b 40 0c             	mov    0xc(%eax),%eax
  10a9af:	c1 e8 10             	shr    $0x10,%eax
  10a9b2:	66 25 ff 3f          	and    $0x3fff,%ax
  10a9b6:	0f b7 c0             	movzwl %ax,%eax
  10a9b9:	83 e0 01             	and    $0x1,%eax
  10a9bc:	84 c0                	test   %al,%al
  10a9be:	74 31                	je     10a9f1 <ring_init+0x171>
            rfd->size--;
  10a9c0:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10a9c3:	8b 40 0c             	mov    0xc(%eax),%eax
  10a9c6:	c1 e8 10             	shr    $0x10,%eax
  10a9c9:	66 25 ff 3f          	and    $0x3fff,%ax
  10a9cd:	83 e8 01             	sub    $0x1,%eax
  10a9d0:	66 25 ff 3f          	and    $0x3fff,%ax
  10a9d4:	8b 4d fc             	mov    0xfffffffc(%ebp),%ecx
  10a9d7:	0f b7 c0             	movzwl %ax,%eax
  10a9da:	25 ff 3f 00 00       	and    $0x3fff,%eax
  10a9df:	89 c2                	mov    %eax,%edx
  10a9e1:	c1 e2 10             	shl    $0x10,%edx
  10a9e4:	8b 41 0c             	mov    0xc(%ecx),%eax
  10a9e7:	25 ff ff 00 c0       	and    $0xc000ffff,%eax
  10a9ec:	09 d0                	or     %edx,%eax
  10a9ee:	89 41 0c             	mov    %eax,0xc(%ecx)
        rfd->eof = 0;
  10a9f1:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  10a9f4:	8b 42 0c             	mov    0xc(%edx),%eax
  10a9f7:	80 e4 7f             	and    $0x7f,%ah
  10a9fa:	89 42 0c             	mov    %eax,0xc(%edx)
        rfd->f = 0;
  10a9fd:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  10aa00:	8b 42 0c             	mov    0xc(%edx),%eax
  10aa03:	80 e4 bf             	and    $0xbf,%ah
  10aa06:	89 42 0c             	mov    %eax,0xc(%edx)
        if (i == dev->rucount - 1)
  10aa09:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
  10aa0c:	8b 45 08             	mov    0x8(%ebp),%eax
  10aa0f:	8b 80 f4 00 00 00    	mov    0xf4(%eax),%eax
  10aa15:	83 e8 01             	sub    $0x1,%eax
  10aa18:	39 c2                	cmp    %eax,%edx
  10aa1a:	75 2b                	jne    10aa47 <ring_init+0x1c7>
        {
            rfd->head.link = (void*)dev->rubase;
  10aa1c:	8b 45 08             	mov    0x8(%ebp),%eax
  10aa1f:	8b 80 ec 00 00 00    	mov    0xec(%eax),%eax
  10aa25:	89 c2                	mov    %eax,%edx
  10aa27:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10aa2a:	89 50 04             	mov    %edx,0x4(%eax)
            rfd->head.el = 1;
  10aa2d:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  10aa30:	8b 02                	mov    (%edx),%eax
  10aa32:	0d 00 00 00 80       	or     $0x80000000,%eax
  10aa37:	89 02                	mov    %eax,(%edx)
            dev->ru_prev = rfd;
  10aa39:	8b 55 08             	mov    0x8(%ebp),%edx
  10aa3c:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10aa3f:	89 82 00 01 00 00    	mov    %eax,0x100(%edx)
  10aa45:	eb 10                	jmp    10aa57 <ring_init+0x1d7>
        }
        else
        {
            rfd->head.link = (void*)((uint32_t)rfd + E100_RFD_SIZE);
  10aa47:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10aa4a:	05 00 08 00 00       	add    $0x800,%eax
  10aa4f:	89 c2                	mov    %eax,%edx
  10aa51:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10aa54:	89 50 04             	mov    %edx,0x4(%eax)
  10aa57:	83 45 f4 01          	addl   $0x1,0xfffffff4(%ebp)
  10aa5b:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10aa5e:	8b 55 08             	mov    0x8(%ebp),%edx
  10aa61:	8b 92 f4 00 00 00    	mov    0xf4(%edx),%edx
  10aa67:	39 d0                	cmp    %edx,%eax
  10aa69:	0f 82 01 ff ff ff    	jb     10a970 <ring_init+0xf0>
        }
    }
    dev->ru_first = 0;
  10aa6f:	8b 45 08             	mov    0x8(%ebp),%eax
  10aa72:	c7 80 f8 00 00 00 00 	movl   $0x0,0xf8(%eax)
  10aa79:	00 00 00 
    dev->ru_last = (void*)dev->rubase;
  10aa7c:	8b 45 08             	mov    0x8(%ebp),%eax
  10aa7f:	8b 80 ec 00 00 00    	mov    0xec(%eax),%eax
  10aa85:	89 c2                	mov    %eax,%edx
  10aa87:	8b 45 08             	mov    0x8(%ebp),%eax
  10aa8a:	89 90 fc 00 00 00    	mov    %edx,0xfc(%eax)
    
}
  10aa90:	c9                   	leave  
  10aa91:	c3                   	ret    
  10aa92:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi
  10aa99:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

0010aaa0 <ring_alloc>:

void *
ring_alloc(e100_dev *dev, uint32_t len)
{
  10aaa0:	55                   	push   %ebp
  10aaa1:	89 e5                	mov    %esp,%ebp
  10aaa3:	83 ec 04             	sub    $0x4,%esp
    if (len > E100_CB_SIZE)
  10aaa6:	81 7d 0c 00 08 00 00 	cmpl   $0x800,0xc(%ebp)
  10aaad:	76 09                	jbe    10aab8 <ring_alloc+0x18>
        return (void*) 0;
  10aaaf:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
  10aab6:	eb 4f                	jmp    10ab07 <ring_alloc+0x67>
    if (dev->cu_next_pkt)
  10aab8:	8b 45 08             	mov    0x8(%ebp),%eax
  10aabb:	8b 80 b4 00 00 00    	mov    0xb4(%eax),%eax
  10aac1:	85 c0                	test   %eax,%eax
  10aac3:	74 33                	je     10aaf8 <ring_alloc+0x58>
    {
        if ((void*)dev->cu_last_pkt->link == dev->cu_next_pkt)
  10aac5:	8b 45 08             	mov    0x8(%ebp),%eax
  10aac8:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
  10aace:	8b 50 04             	mov    0x4(%eax),%edx
  10aad1:	8b 45 08             	mov    0x8(%ebp),%eax
  10aad4:	8b 80 b4 00 00 00    	mov    0xb4(%eax),%eax
  10aada:	39 c2                	cmp    %eax,%edx
  10aadc:	75 09                	jne    10aae7 <ring_alloc+0x47>
            return (void*) 0;
  10aade:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
  10aae5:	eb 20                	jmp    10ab07 <ring_alloc+0x67>
        return (void*)dev->cu_last_pkt->link;
  10aae7:	8b 45 08             	mov    0x8(%ebp),%eax
  10aaea:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
  10aaf0:	8b 40 04             	mov    0x4(%eax),%eax
  10aaf3:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  10aaf6:	eb 0f                	jmp    10ab07 <ring_alloc+0x67>
    } else {
        return (void*)dev->cu_last_pkt->link;
  10aaf8:	8b 45 08             	mov    0x8(%ebp),%eax
  10aafb:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
  10ab01:	8b 40 04             	mov    0x4(%eax),%eax
  10ab04:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  10ab07:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    }
/*    
    len = E100_CB_SIZE;
    if (dev->cuhead <= dev->cuend)
    {
        uint32_t newend = dev->cuend + len;
        uint32_t oldend = dev->cuend;
        if (newend >= dev->cusize)
        {
            newend = len; // Start from base
            if (newend < dev->cuhead)
            {
                dev->cuend = newend;
                return (void*)dev->cubase;
            }
            else
                return (void*)0;
        }
        else
        {
            dev->cuend = newend;
            return (void*)(oldend + dev->cubase);
        }
    }
    else
    {
        uint32_t newend = dev->cuend + len;
        uint32_t oldend = dev->cuend;
        if (newend < dev->cuhead)
        {
            dev->cuend = newend;
            return (void*)(oldend + dev->cubase);
        }
        else
            return (void*)0;
    }*/
}
  10ab0a:	c9                   	leave  
  10ab0b:	c3                   	ret    
  10ab0c:	8d 74 26 00          	lea    0x0(%esi),%esi

0010ab10 <e100_send_dev>:

// Send
int
e100_send_dev(e100_dev *dev, void *buffer, uint32_t len)
{
  10ab10:	55                   	push   %ebp
  10ab11:	89 e5                	mov    %esp,%ebp
  10ab13:	83 ec 28             	sub    $0x28,%esp
//    cprintf("e100_send_dev\n");
    if (len > TBD_DATA_LIMIT)
  10ab16:	81 7d 10 40 06 00 00 	cmpl   $0x640,0x10(%ebp)
  10ab1d:	76 0c                	jbe    10ab2b <e100_send_dev+0x1b>
        return -1; // ETOOBIG
  10ab1f:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  10ab26:	e9 b2 01 00 00       	jmp    10acdd <e100_send_dev+0x1cd>
    acquire(&dev->culock);
  10ab2b:	8b 45 08             	mov    0x8(%ebp),%eax
  10ab2e:	83 c0 68             	add    $0x68,%eax
  10ab31:	89 04 24             	mov    %eax,(%esp)
  10ab34:	e8 d7 af ff ff       	call   105b10 <acquire>
    op_transmit_cmd *start = 
        ring_alloc(dev, sizeof(op_transmit_cmd) + len);
  10ab39:	8b 45 10             	mov    0x10(%ebp),%eax
  10ab3c:	83 c0 10             	add    $0x10,%eax
  10ab3f:	89 44 24 04          	mov    %eax,0x4(%esp)
  10ab43:	8b 45 08             	mov    0x8(%ebp),%eax
  10ab46:	89 04 24             	mov    %eax,(%esp)
  10ab49:	e8 52 ff ff ff       	call   10aaa0 <ring_alloc>
  10ab4e:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
//    cprintf("   start: 0x%08x\n", start);
    if (!start)
  10ab51:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  10ab55:	75 1a                	jne    10ab71 <e100_send_dev+0x61>
    {
        release(&dev->culock);
  10ab57:	8b 45 08             	mov    0x8(%ebp),%eax
  10ab5a:	83 c0 68             	add    $0x68,%eax
  10ab5d:	89 04 24             	mov    %eax,(%esp)
  10ab60:	e8 ab b1 ff ff       	call   105d10 <release>
        return -1; // No space in buffer
  10ab65:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  10ab6c:	e9 6c 01 00 00       	jmp    10acdd <e100_send_dev+0x1cd>
    }
    op_transmit_cmd_cmd cmd_word;
    cmd_word.word = 0;
  10ab71:	66 c7 45 fa 00 00    	movw   $0x0,0xfffffffa(%ebp)
    cmd_word.cmd = OP_TRANSMIT;
  10ab77:	0f b6 45 fa          	movzbl 0xfffffffa(%ebp),%eax
  10ab7b:	83 e0 f8             	and    $0xfffffff8,%eax
  10ab7e:	83 c8 04             	or     $0x4,%eax
  10ab81:	88 45 fa             	mov    %al,0xfffffffa(%ebp)
//    cmd_word.el = 0;
    cmd_word.cid = 0xe;
  10ab84:	0f b6 45 fb          	movzbl 0xfffffffb(%ebp),%eax
  10ab88:	83 e0 e0             	and    $0xffffffe0,%eax
  10ab8b:	83 c8 0e             	or     $0xe,%eax
  10ab8e:	88 45 fb             	mov    %al,0xfffffffb(%ebp)
    cmd_word.i = 1;
  10ab91:	0f b6 45 fb          	movzbl 0xfffffffb(%ebp),%eax
  10ab95:	83 c8 20             	or     $0x20,%eax
  10ab98:	88 45 fb             	mov    %al,0xfffffffb(%ebp)
    cmd_word.s = 1;
  10ab9b:	0f b6 45 fb          	movzbl 0xfffffffb(%ebp),%eax
  10ab9f:	83 c8 40             	or     $0x40,%eax
  10aba2:	88 45 fb             	mov    %al,0xfffffffb(%ebp)
    if (!dev->cuidle)
  10aba5:	8b 45 08             	mov    0x8(%ebp),%eax
  10aba8:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
  10abae:	85 c0                	test   %eax,%eax
  10abb0:	75 13                	jne    10abc5 <e100_send_dev+0xb5>
        dev->cu_last_pkt->s = 0;
  10abb2:	8b 45 08             	mov    0x8(%ebp),%eax
  10abb5:	8b 90 b0 00 00 00    	mov    0xb0(%eax),%edx
  10abbb:	0f b6 42 03          	movzbl 0x3(%edx),%eax
  10abbf:	83 e0 bf             	and    $0xffffffbf,%eax
  10abc2:	88 42 03             	mov    %al,0x3(%edx)
    start->base_cmd.cmd_word = cmd_word.word;
  10abc5:	0f b7 55 fa          	movzwl 0xfffffffa(%ebp),%edx
  10abc9:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10abcc:	66 89 50 02          	mov    %dx,0x2(%eax)
    start->base_cmd.status_word = 0;
  10abd0:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10abd3:	66 c7 00 00 00       	movw   $0x0,(%eax)
//    start->base_cmd.link = 0;
    start->tbd_addr = 0xffffffff;
  10abd8:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10abdb:	c7 40 08 ff ff ff ff 	movl   $0xffffffff,0x8(%eax)
    start->byte_count = len;
  10abe2:	8b 45 10             	mov    0x10(%ebp),%eax
  10abe5:	c1 e0 02             	shl    $0x2,%eax
  10abe8:	66 c1 f8 02          	sar    $0x2,%ax
  10abec:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  10abef:	89 c1                	mov    %eax,%ecx
  10abf1:	66 81 e1 ff 3f       	and    $0x3fff,%cx
  10abf6:	0f b7 42 0c          	movzwl 0xc(%edx),%eax
  10abfa:	66 25 00 c0          	and    $0xc000,%ax
  10abfe:	09 c8                	or     %ecx,%eax
  10ac00:	66 89 42 0c          	mov    %ax,0xc(%edx)
    start->eof = 1;
  10ac04:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  10ac07:	0f b6 42 0d          	movzbl 0xd(%edx),%eax
  10ac0b:	83 c8 80             	or     $0xffffff80,%eax
  10ac0e:	88 42 0d             	mov    %al,0xd(%edx)
    start->trans_thres = 0xE0;
  10ac11:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10ac14:	c6 40 0e e0          	movb   $0xe0,0xe(%eax)
    start->tbd_num = 0;
  10ac18:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10ac1b:	c6 40 0f 00          	movb   $0x0,0xf(%eax)
    memcpy((void*)(start+1), buffer, len);
  10ac1f:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  10ac22:	83 c2 10             	add    $0x10,%edx
  10ac25:	8b 45 10             	mov    0x10(%ebp),%eax
  10ac28:	89 44 24 08          	mov    %eax,0x8(%esp)
  10ac2c:	8b 45 0c             	mov    0xc(%ebp),%eax
  10ac2f:	89 44 24 04          	mov    %eax,0x4(%esp)
  10ac33:	89 14 24             	mov    %edx,(%esp)
  10ac36:	e8 55 b2 ff ff       	call   105e90 <memcpy>
//    e100_print_state(dev);
//    if (e100_get_state(dev).status.cus == CUS_IDLE)
//    if (dev->cu_next_pkt == 0)
//    This test would fail in real i82559er
//    But it passed in qemu
/*    if ((!dev->cufirst) && (!dev->cuidle))
        if (start->base_cmd.link == dev->cu_next_pkt)
            e100_cu_command(dev, CUC_RESUME, start);*/
    if (dev->cufirst)
  10ac3b:	8b 45 08             	mov    0x8(%ebp),%eax
  10ac3e:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
  10ac44:	85 c0                	test   %eax,%eax
  10ac46:	74 35                	je     10ac7d <e100_send_dev+0x16d>
    {
        dev->cufirst = 0;
  10ac48:	8b 45 08             	mov    0x8(%ebp),%eax
  10ac4b:	c7 80 a8 00 00 00 00 	movl   $0x0,0xa8(%eax)
  10ac52:	00 00 00 
        dev->cu_next_pkt = &start->base_cmd;
  10ac55:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  10ac58:	8b 45 08             	mov    0x8(%ebp),%eax
  10ac5b:	89 90 b4 00 00 00    	mov    %edx,0xb4(%eax)
        e100_cu_command(dev, CUC_START, start);
  10ac61:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10ac64:	89 44 24 08          	mov    %eax,0x8(%esp)
  10ac68:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  10ac6f:	00 
  10ac70:	8b 45 08             	mov    0x8(%ebp),%eax
  10ac73:	89 04 24             	mov    %eax,(%esp)
  10ac76:	e8 a5 f8 ff ff       	call   10a520 <e100_cu_command>
  10ac7b:	eb 40                	jmp    10acbd <e100_send_dev+0x1ad>
    }
    else if (dev->cuidle)
  10ac7d:	8b 45 08             	mov    0x8(%ebp),%eax
  10ac80:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
  10ac86:	85 c0                	test   %eax,%eax
  10ac88:	74 33                	je     10acbd <e100_send_dev+0x1ad>
    {
        dev->cuidle = 0;
  10ac8a:	8b 45 08             	mov    0x8(%ebp),%eax
  10ac8d:	c7 80 ac 00 00 00 00 	movl   $0x0,0xac(%eax)
  10ac94:	00 00 00 
        dev->cu_next_pkt = &start->base_cmd;
  10ac97:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  10ac9a:	8b 45 08             	mov    0x8(%ebp),%eax
  10ac9d:	89 90 b4 00 00 00    	mov    %edx,0xb4(%eax)
        e100_cu_command(dev, CUC_RESUME, start); // the GENPTR is nonsense
  10aca3:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10aca6:	89 44 24 08          	mov    %eax,0x8(%esp)
  10acaa:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
  10acb1:	00 
  10acb2:	8b 45 08             	mov    0x8(%ebp),%eax
  10acb5:	89 04 24             	mov    %eax,(%esp)
  10acb8:	e8 63 f8 ff ff       	call   10a520 <e100_cu_command>
    }
    dev->cu_last_pkt = &start->base_cmd;
  10acbd:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10acc0:	8b 55 08             	mov    0x8(%ebp),%edx
  10acc3:	89 82 b0 00 00 00    	mov    %eax,0xb0(%edx)
    release(&dev->culock);
  10acc9:	8b 45 08             	mov    0x8(%ebp),%eax
  10accc:	83 c0 68             	add    $0x68,%eax
  10accf:	89 04 24             	mov    %eax,(%esp)
  10acd2:	e8 39 b0 ff ff       	call   105d10 <release>
    return len;
  10acd7:	8b 45 10             	mov    0x10(%ebp),%eax
  10acda:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  10acdd:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  10ace0:	c9                   	leave  
  10ace1:	c3                   	ret    
  10ace2:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi
  10ace9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

0010acf0 <e100_send>:

int
e100_send(void *buffer, uint32_t len)
{
  10acf0:	55                   	push   %ebp
  10acf1:	89 e5                	mov    %esp,%ebp
  10acf3:	83 ec 18             	sub    $0x18,%esp
    if (dev_count == 0)
  10acf6:	a1 c0 cd 11 00       	mov    0x11cdc0,%eax
  10acfb:	85 c0                	test   %eax,%eax
  10acfd:	75 09                	jne    10ad08 <e100_send+0x18>
        return -2; // Device not found
  10acff:	c7 45 fc fe ff ff ff 	movl   $0xfffffffe,0xfffffffc(%ebp)
  10ad06:	eb 1d                	jmp    10ad25 <e100_send+0x35>
    return e100_send_dev(&e100_devs[0], buffer,len);
  10ad08:	8b 45 0c             	mov    0xc(%ebp),%eax
  10ad0b:	89 44 24 08          	mov    %eax,0x8(%esp)
  10ad0f:	8b 45 08             	mov    0x8(%ebp),%eax
  10ad12:	89 44 24 04          	mov    %eax,0x4(%esp)
  10ad16:	c7 04 24 e0 cd 11 00 	movl   $0x11cde0,(%esp)
  10ad1d:	e8 ee fd ff ff       	call   10ab10 <e100_send_dev>
  10ad22:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  10ad25:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
}
  10ad28:	c9                   	leave  
  10ad29:	c3                   	ret    
  10ad2a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

0010ad30 <e100_ru_start>:

// Receive
void
e100_ru_start(e100_dev *dev)
{
  10ad30:	55                   	push   %ebp
  10ad31:	89 e5                	mov    %esp,%ebp
  10ad33:	83 ec 18             	sub    $0x18,%esp
    dev->ru_full = 0;
  10ad36:	8b 45 08             	mov    0x8(%ebp),%eax
  10ad39:	c7 80 04 01 00 00 00 	movl   $0x0,0x104(%eax)
  10ad40:	00 00 00 
    e100_ru_command(dev, RUC_START, (void*)dev->rubase);
  10ad43:	8b 45 08             	mov    0x8(%ebp),%eax
  10ad46:	8b 80 ec 00 00 00    	mov    0xec(%eax),%eax
  10ad4c:	89 44 24 08          	mov    %eax,0x8(%esp)
  10ad50:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  10ad57:	00 
  10ad58:	8b 45 08             	mov    0x8(%ebp),%eax
  10ad5b:	89 04 24             	mov    %eax,(%esp)
  10ad5e:	e8 2d f8 ff ff       	call   10a590 <e100_ru_command>
}
  10ad63:	c9                   	leave  
  10ad64:	c3                   	ret    
  10ad65:	8d 74 26 00          	lea    0x0(%esi),%esi
  10ad69:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

0010ad70 <e100_receive>:
 
int
e100_receive(void *buffer, uint32_t len)
{
  10ad70:	55                   	push   %ebp
  10ad71:	89 e5                	mov    %esp,%ebp
  10ad73:	83 ec 18             	sub    $0x18,%esp
    if (dev_count == 0)
  10ad76:	a1 c0 cd 11 00       	mov    0x11cdc0,%eax
  10ad7b:	85 c0                	test   %eax,%eax
  10ad7d:	75 09                	jne    10ad88 <e100_receive+0x18>
        return -2; // Device not found
  10ad7f:	c7 45 fc fe ff ff ff 	movl   $0xfffffffe,0xfffffffc(%ebp)
  10ad86:	eb 1d                	jmp    10ada5 <e100_receive+0x35>
    return e100_receive_dev(&e100_devs[0], buffer, len);
  10ad88:	8b 45 0c             	mov    0xc(%ebp),%eax
  10ad8b:	89 44 24 08          	mov    %eax,0x8(%esp)
  10ad8f:	8b 45 08             	mov    0x8(%ebp),%eax
  10ad92:	89 44 24 04          	mov    %eax,0x4(%esp)
  10ad96:	c7 04 24 e0 cd 11 00 	movl   $0x11cde0,(%esp)
  10ad9d:	e8 0e 00 00 00       	call   10adb0 <e100_receive_dev>
  10ada2:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  10ada5:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
}
  10ada8:	c9                   	leave  
  10ada9:	c3                   	ret    
  10adaa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

0010adb0 <e100_receive_dev>:

int
e100_receive_dev(e100_dev *dev, void *buffer, int len)
{
  10adb0:	55                   	push   %ebp
  10adb1:	89 e5                	mov    %esp,%ebp
  10adb3:	83 ec 28             	sub    $0x28,%esp
    int count;
//    cprintf("e100_receive_dev\n");
    acquire(&dev->rulock);
  10adb6:	8b 45 08             	mov    0x8(%ebp),%eax
  10adb9:	05 b8 00 00 00       	add    $0xb8,%eax
  10adbe:	89 04 24             	mov    %eax,(%esp)
  10adc1:	e8 4a ad ff ff       	call   105b10 <acquire>
    while (dev->ru_first == 0)
  10adc6:	eb 1d                	jmp    10ade5 <e100_receive_dev+0x35>
        sleep(&dev->rulock, &dev->rulock);
  10adc8:	8b 45 08             	mov    0x8(%ebp),%eax
  10adcb:	05 b8 00 00 00       	add    $0xb8,%eax
  10add0:	8b 55 08             	mov    0x8(%ebp),%edx
  10add3:	81 c2 b8 00 00 00    	add    $0xb8,%edx
  10add9:	89 44 24 04          	mov    %eax,0x4(%esp)
  10addd:	89 14 24             	mov    %edx,(%esp)
  10ade0:	e8 7b a6 ff ff       	call   105460 <sleep>
  10ade5:	8b 45 08             	mov    0x8(%ebp),%eax
  10ade8:	8b 80 f8 00 00 00    	mov    0xf8(%eax),%eax
  10adee:	85 c0                	test   %eax,%eax
  10adf0:	74 d6                	je     10adc8 <e100_receive_dev+0x18>
    if (len < dev->ru_first->count)
  10adf2:	8b 45 08             	mov    0x8(%ebp),%eax
  10adf5:	8b 80 f8 00 00 00    	mov    0xf8(%eax),%eax
  10adfb:	8b 40 0c             	mov    0xc(%eax),%eax
  10adfe:	66 25 ff 3f          	and    $0x3fff,%ax
  10ae02:	0f b7 c0             	movzwl %ax,%eax
  10ae05:	3b 45 10             	cmp    0x10(%ebp),%eax
  10ae08:	7e 1c                	jle    10ae26 <e100_receive_dev+0x76>
    {
        release(&dev->rulock);
  10ae0a:	8b 45 08             	mov    0x8(%ebp),%eax
  10ae0d:	05 b8 00 00 00       	add    $0xb8,%eax
  10ae12:	89 04 24             	mov    %eax,(%esp)
  10ae15:	e8 f6 ae ff ff       	call   105d10 <release>
        return -1; // ETOOBIG
  10ae1a:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  10ae21:	e9 2c 01 00 00       	jmp    10af52 <e100_receive_dev+0x1a2>
    }
    memcpy(buffer, dev->ru_first + 1, dev->ru_first->count);
  10ae26:	8b 45 08             	mov    0x8(%ebp),%eax
  10ae29:	8b 80 f8 00 00 00    	mov    0xf8(%eax),%eax
  10ae2f:	8b 40 0c             	mov    0xc(%eax),%eax
  10ae32:	66 25 ff 3f          	and    $0x3fff,%ax
  10ae36:	0f b7 d0             	movzwl %ax,%edx
  10ae39:	8b 45 08             	mov    0x8(%ebp),%eax
  10ae3c:	8b 80 f8 00 00 00    	mov    0xf8(%eax),%eax
  10ae42:	83 c0 10             	add    $0x10,%eax
  10ae45:	89 54 24 08          	mov    %edx,0x8(%esp)
  10ae49:	89 44 24 04          	mov    %eax,0x4(%esp)
  10ae4d:	8b 45 0c             	mov    0xc(%ebp),%eax
  10ae50:	89 04 24             	mov    %eax,(%esp)
  10ae53:	e8 38 b0 ff ff       	call   105e90 <memcpy>
//    cprintf("received %d bytes into 0x%08x\n", dev->ru_first->count, buffer);
    count = dev->ru_first->count;
  10ae58:	8b 45 08             	mov    0x8(%ebp),%eax
  10ae5b:	8b 80 f8 00 00 00    	mov    0xf8(%eax),%eax
  10ae61:	8b 40 0c             	mov    0xc(%eax),%eax
  10ae64:	66 25 ff 3f          	and    $0x3fff,%ax
  10ae68:	0f b7 c0             	movzwl %ax,%eax
  10ae6b:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
    dev->ru_first->eof = 0;
  10ae6e:	8b 45 08             	mov    0x8(%ebp),%eax
  10ae71:	8b 90 f8 00 00 00    	mov    0xf8(%eax),%edx
  10ae77:	8b 42 0c             	mov    0xc(%edx),%eax
  10ae7a:	80 e4 7f             	and    $0x7f,%ah
  10ae7d:	89 42 0c             	mov    %eax,0xc(%edx)
    dev->ru_first->f = 0;
  10ae80:	8b 45 08             	mov    0x8(%ebp),%eax
  10ae83:	8b 90 f8 00 00 00    	mov    0xf8(%eax),%edx
  10ae89:	8b 42 0c             	mov    0xc(%edx),%eax
  10ae8c:	80 e4 bf             	and    $0xbf,%ah
  10ae8f:	89 42 0c             	mov    %eax,0xc(%edx)
    dev->ru_prev->head.el = 0;
  10ae92:	8b 45 08             	mov    0x8(%ebp),%eax
  10ae95:	8b 90 00 01 00 00    	mov    0x100(%eax),%edx
  10ae9b:	8b 02                	mov    (%edx),%eax
  10ae9d:	25 ff ff ff 7f       	and    $0x7fffffff,%eax
  10aea2:	89 02                	mov    %eax,(%edx)
    dev->ru_first->head.el = 1;
  10aea4:	8b 45 08             	mov    0x8(%ebp),%eax
  10aea7:	8b 90 f8 00 00 00    	mov    0xf8(%eax),%edx
  10aead:	8b 02                	mov    (%edx),%eax
  10aeaf:	0d 00 00 00 80       	or     $0x80000000,%eax
  10aeb4:	89 02                	mov    %eax,(%edx)
    dev->ru_prev = dev->ru_first;
  10aeb6:	8b 45 08             	mov    0x8(%ebp),%eax
  10aeb9:	8b 90 f8 00 00 00    	mov    0xf8(%eax),%edx
  10aebf:	8b 45 08             	mov    0x8(%ebp),%eax
  10aec2:	89 90 00 01 00 00    	mov    %edx,0x100(%eax)
    dev->ru_first = (void*)dev->ru_first->head.link;
  10aec8:	8b 45 08             	mov    0x8(%ebp),%eax
  10aecb:	8b 80 f8 00 00 00    	mov    0xf8(%eax),%eax
  10aed1:	8b 40 04             	mov    0x4(%eax),%eax
  10aed4:	89 c2                	mov    %eax,%edx
  10aed6:	8b 45 08             	mov    0x8(%ebp),%eax
  10aed9:	89 90 f8 00 00 00    	mov    %edx,0xf8(%eax)
    if (dev->ru_full)
  10aedf:	8b 45 08             	mov    0x8(%ebp),%eax
  10aee2:	8b 80 04 01 00 00    	mov    0x104(%eax),%eax
  10aee8:	85 c0                	test   %eax,%eax
  10aeea:	74 2d                	je     10af19 <e100_receive_dev+0x169>
    {
        // RU full, in No Resource state
        dev->ru_full = 0;
  10aeec:	8b 45 08             	mov    0x8(%ebp),%eax
  10aeef:	c7 80 04 01 00 00 00 	movl   $0x0,0x104(%eax)
  10aef6:	00 00 00 
        e100_ru_command(dev, RUC_START, dev->ru_prev);
  10aef9:	8b 45 08             	mov    0x8(%ebp),%eax
  10aefc:	8b 80 00 01 00 00    	mov    0x100(%eax),%eax
  10af02:	89 44 24 08          	mov    %eax,0x8(%esp)
  10af06:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  10af0d:	00 
  10af0e:	8b 45 08             	mov    0x8(%ebp),%eax
  10af11:	89 04 24             	mov    %eax,(%esp)
  10af14:	e8 77 f6 ff ff       	call   10a590 <e100_ru_command>
    }
    if (dev->ru_first == dev->ru_last)
  10af19:	8b 45 08             	mov    0x8(%ebp),%eax
  10af1c:	8b 90 f8 00 00 00    	mov    0xf8(%eax),%edx
  10af22:	8b 45 08             	mov    0x8(%ebp),%eax
  10af25:	8b 80 fc 00 00 00    	mov    0xfc(%eax),%eax
  10af2b:	39 c2                	cmp    %eax,%edx
  10af2d:	75 0d                	jne    10af3c <e100_receive_dev+0x18c>
        dev->ru_first = 0;
  10af2f:	8b 45 08             	mov    0x8(%ebp),%eax
  10af32:	c7 80 f8 00 00 00 00 	movl   $0x0,0xf8(%eax)
  10af39:	00 00 00 
    release(&dev->rulock);
  10af3c:	8b 45 08             	mov    0x8(%ebp),%eax
  10af3f:	05 b8 00 00 00       	add    $0xb8,%eax
  10af44:	89 04 24             	mov    %eax,(%esp)
  10af47:	e8 c4 ad ff ff       	call   105d10 <release>
    return count;
  10af4c:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10af4f:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  10af52:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  10af55:	c9                   	leave  
  10af56:	c3                   	ret    
  10af57:	89 f6                	mov    %esi,%esi
  10af59:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

0010af60 <e100_rx_thread>:

void
e100_rx_thread(void *arg)
{
  10af60:	55                   	push   %ebp
  10af61:	89 e5                	mov    %esp,%ebp
  10af63:	83 ec 18             	sub    $0x18,%esp
    e100_dev *dev = arg;
  10af66:	8b 45 08             	mov    0x8(%ebp),%eax
  10af69:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
    acquire(&dev->rxlock);
  10af6c:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10af6f:	05 08 01 00 00       	add    $0x108,%eax
  10af74:	89 04 24             	mov    %eax,(%esp)
  10af77:	e8 94 ab ff ff       	call   105b10 <acquire>
    while(1)
    {
        sleep(&dev->rxlock, &dev->rxlock);
  10af7c:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10af7f:	05 08 01 00 00       	add    $0x108,%eax
  10af84:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  10af87:	81 c2 08 01 00 00    	add    $0x108,%edx
  10af8d:	89 44 24 04          	mov    %eax,0x4(%esp)
  10af91:	89 14 24             	mov    %edx,(%esp)
  10af94:	e8 c7 a4 ff ff       	call   105460 <sleep>
        while (dev->ru_last->eof)
  10af99:	eb 25                	jmp    10afc0 <e100_rx_thread+0x60>
        {
            ethernetif_input(&dev->netif);
  10af9b:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10af9e:	83 c0 38             	add    $0x38,%eax
  10afa1:	89 04 24             	mov    %eax,(%esp)
  10afa4:	e8 f7 13 00 00       	call   10c3a0 <ethernetif_input>
            dev->ru_last = (void*)dev->ru_last->head.link;
  10afa9:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10afac:	8b 80 fc 00 00 00    	mov    0xfc(%eax),%eax
  10afb2:	8b 40 04             	mov    0x4(%eax),%eax
  10afb5:	89 c2                	mov    %eax,%edx
  10afb7:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10afba:	89 90 fc 00 00 00    	mov    %edx,0xfc(%eax)
  10afc0:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10afc3:	8b 80 fc 00 00 00    	mov    0xfc(%eax),%eax
  10afc9:	8b 40 0c             	mov    0xc(%eax),%eax
  10afcc:	25 00 80 00 00       	and    $0x8000,%eax
  10afd1:	85 c0                	test   %eax,%eax
  10afd3:	75 c6                	jne    10af9b <e100_rx_thread+0x3b>
        }
    }
  10afd5:	eb a5                	jmp    10af7c <e100_rx_thread+0x1c>
  10afd7:	89 f6                	mov    %esi,%esi
  10afd9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

0010afe0 <e100_eeprom_out>:
    release(&dev->rxlock);
}

// EEPROM
void
e100_eeprom_out(e100_dev *dev, uint16_t val)
{
  10afe0:	55                   	push   %ebp
  10afe1:	89 e5                	mov    %esp,%ebp
  10afe3:	83 ec 0c             	sub    $0xc,%esp
  10afe6:	8b 45 0c             	mov    0xc(%ebp),%eax
  10afe9:	66 89 45 fc          	mov    %ax,0xfffffffc(%ebp)
    outw(dev->iobase + SCB_EEPROM_CTL, val);
  10afed:	0f b7 55 fc          	movzwl 0xfffffffc(%ebp),%edx
  10aff1:	8b 45 08             	mov    0x8(%ebp),%eax
  10aff4:	8b 40 34             	mov    0x34(%eax),%eax
  10aff7:	83 c0 0e             	add    $0xe,%eax
  10affa:	0f b7 c0             	movzwl %ax,%eax
  10affd:	89 54 24 04          	mov    %edx,0x4(%esp)
  10b001:	89 04 24             	mov    %eax,(%esp)
  10b004:	e8 f7 f2 ff ff       	call   10a300 <outw>
}
  10b009:	c9                   	leave  
  10b00a:	c3                   	ret    
  10b00b:	90                   	nop    
  10b00c:	8d 74 26 00          	lea    0x0(%esi),%esi

0010b010 <e100_eeprom_in>:

uint16_t
e100_eeprom_in(e100_dev *dev)
{
  10b010:	55                   	push   %ebp
  10b011:	89 e5                	mov    %esp,%ebp
  10b013:	83 ec 04             	sub    $0x4,%esp
    return inw(dev->iobase + SCB_EEPROM_CTL);
  10b016:	8b 45 08             	mov    0x8(%ebp),%eax
  10b019:	8b 40 34             	mov    0x34(%eax),%eax
  10b01c:	83 c0 0e             	add    $0xe,%eax
  10b01f:	0f b7 c0             	movzwl %ax,%eax
  10b022:	89 04 24             	mov    %eax,(%esp)
  10b025:	e8 26 f3 ff ff       	call   10a350 <inw>
  10b02a:	0f b7 c0             	movzwl %ax,%eax
}
  10b02d:	c9                   	leave  
  10b02e:	c3                   	ret    
  10b02f:	90                   	nop    

0010b030 <e100_eeprom_shiftin>:

void
e100_eeprom_shiftin(e100_dev *dev, int data, int len)
{
  10b030:	55                   	push   %ebp
  10b031:	89 e5                	mov    %esp,%ebp
  10b033:	83 ec 18             	sub    $0x18,%esp
    int val;
    int x;
    for (x = 1 << (len - 1); x > 0; x >>= 1)
  10b036:	8b 4d 10             	mov    0x10(%ebp),%ecx
  10b039:	83 e9 01             	sub    $0x1,%ecx
  10b03c:	b8 01 00 00 00       	mov    $0x1,%eax
  10b041:	d3 e0                	shl    %cl,%eax
  10b043:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  10b046:	e9 83 00 00 00       	jmp    10b0ce <e100_eeprom_shiftin+0x9e>
    {
        if (data & x)
  10b04b:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10b04e:	23 45 0c             	and    0xc(%ebp),%eax
  10b051:	85 c0                	test   %eax,%eax
  10b053:	74 09                	je     10b05e <e100_eeprom_shiftin+0x2e>
            val = EEPROM_EEDI | EEPROM_EECS;
  10b055:	c7 45 f8 06 00 00 00 	movl   $0x6,0xfffffff8(%ebp)
  10b05c:	eb 07                	jmp    10b065 <e100_eeprom_shiftin+0x35>
        else
            val = EEPROM_EECS;
  10b05e:	c7 45 f8 02 00 00 00 	movl   $0x2,0xfffffff8(%ebp)
        e100_eeprom_out(dev, val);
  10b065:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10b068:	0f b7 c0             	movzwl %ax,%eax
  10b06b:	89 44 24 04          	mov    %eax,0x4(%esp)
  10b06f:	8b 45 08             	mov    0x8(%ebp),%eax
  10b072:	89 04 24             	mov    %eax,(%esp)
  10b075:	e8 66 ff ff ff       	call   10afe0 <e100_eeprom_out>
        delay(1);
  10b07a:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  10b081:	e8 aa f1 ff ff       	call   10a230 <delay>
        e100_eeprom_out(dev, val | EEPROM_EESK);
  10b086:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10b089:	83 c8 01             	or     $0x1,%eax
  10b08c:	0f b7 c0             	movzwl %ax,%eax
  10b08f:	89 44 24 04          	mov    %eax,0x4(%esp)
  10b093:	8b 45 08             	mov    0x8(%ebp),%eax
  10b096:	89 04 24             	mov    %eax,(%esp)
  10b099:	e8 42 ff ff ff       	call   10afe0 <e100_eeprom_out>
        delay(1);
  10b09e:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  10b0a5:	e8 86 f1 ff ff       	call   10a230 <delay>
        e100_eeprom_out(dev, val);
  10b0aa:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10b0ad:	0f b7 c0             	movzwl %ax,%eax
  10b0b0:	89 44 24 04          	mov    %eax,0x4(%esp)
  10b0b4:	8b 45 08             	mov    0x8(%ebp),%eax
  10b0b7:	89 04 24             	mov    %eax,(%esp)
  10b0ba:	e8 21 ff ff ff       	call   10afe0 <e100_eeprom_out>
        delay(1);
  10b0bf:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  10b0c6:	e8 65 f1 ff ff       	call   10a230 <delay>
  10b0cb:	d1 7d fc             	sarl   0xfffffffc(%ebp)
  10b0ce:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  10b0d2:	0f 8f 73 ff ff ff    	jg     10b04b <e100_eeprom_shiftin+0x1b>
    }
}
  10b0d8:	c9                   	leave  
  10b0d9:	c3                   	ret    
  10b0da:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

0010b0e0 <e100_eeprom_shiftout>:

uint16_t
e100_eeprom_shiftout(e100_dev *dev)
{
  10b0e0:	55                   	push   %ebp
  10b0e1:	89 e5                	mov    %esp,%ebp
  10b0e3:	83 ec 18             	sub    $0x18,%esp
    int val;
    int data = 0;
  10b0e6:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)
    val = EEPROM_EECS;
  10b0ed:	c7 45 f4 02 00 00 00 	movl   $0x2,0xfffffff4(%ebp)
    int x;
    for (x = 1 << 15; x > 0; x >>= 1)
  10b0f4:	c7 45 fc 00 80 00 00 	movl   $0x8000,0xfffffffc(%ebp)
  10b0fb:	eb 63                	jmp    10b160 <e100_eeprom_shiftout+0x80>
    {
        e100_eeprom_out(dev, val | EEPROM_EESK);
  10b0fd:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10b100:	83 c8 01             	or     $0x1,%eax
  10b103:	0f b7 c0             	movzwl %ax,%eax
  10b106:	89 44 24 04          	mov    %eax,0x4(%esp)
  10b10a:	8b 45 08             	mov    0x8(%ebp),%eax
  10b10d:	89 04 24             	mov    %eax,(%esp)
  10b110:	e8 cb fe ff ff       	call   10afe0 <e100_eeprom_out>
        delay(1);
  10b115:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  10b11c:	e8 0f f1 ff ff       	call   10a230 <delay>
        if (e100_eeprom_in(dev) & EEPROM_EEDO)
  10b121:	8b 45 08             	mov    0x8(%ebp),%eax
  10b124:	89 04 24             	mov    %eax,(%esp)
  10b127:	e8 e4 fe ff ff       	call   10b010 <e100_eeprom_in>
  10b12c:	0f b7 c0             	movzwl %ax,%eax
  10b12f:	83 e0 08             	and    $0x8,%eax
  10b132:	85 c0                	test   %eax,%eax
  10b134:	74 06                	je     10b13c <e100_eeprom_shiftout+0x5c>
            data |= x;
  10b136:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10b139:	09 45 f8             	or     %eax,0xfffffff8(%ebp)
        e100_eeprom_out(dev, val);
  10b13c:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10b13f:	0f b7 c0             	movzwl %ax,%eax
  10b142:	89 44 24 04          	mov    %eax,0x4(%esp)
  10b146:	8b 45 08             	mov    0x8(%ebp),%eax
  10b149:	89 04 24             	mov    %eax,(%esp)
  10b14c:	e8 8f fe ff ff       	call   10afe0 <e100_eeprom_out>
        delay(1);
  10b151:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  10b158:	e8 d3 f0 ff ff       	call   10a230 <delay>
  10b15d:	d1 7d fc             	sarl   0xfffffffc(%ebp)
  10b160:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  10b164:	7f 97                	jg     10b0fd <e100_eeprom_shiftout+0x1d>
    }
    return data;
  10b166:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10b169:	0f b7 c0             	movzwl %ax,%eax
}
  10b16c:	c9                   	leave  
  10b16d:	c3                   	ret    
  10b16e:	89 f6                	mov    %esi,%esi

0010b170 <e100_eeprom_getword>:

uint16_t
e100_eeprom_getword(e100_dev *dev, int offset)
{
  10b170:	55                   	push   %ebp
  10b171:	89 e5                	mov    %esp,%ebp
  10b173:	83 ec 1c             	sub    $0x1c,%esp
    uint16_t data;
    e100_eeprom_out(dev, EEPROM_EECS);
  10b176:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
  10b17d:	00 
  10b17e:	8b 45 08             	mov    0x8(%ebp),%eax
  10b181:	89 04 24             	mov    %eax,(%esp)
  10b184:	e8 57 fe ff ff       	call   10afe0 <e100_eeprom_out>
    e100_eeprom_shiftin(dev, EEPROM_OP_READ, 3);
  10b189:	c7 44 24 08 03 00 00 	movl   $0x3,0x8(%esp)
  10b190:	00 
  10b191:	c7 44 24 04 06 00 00 	movl   $0x6,0x4(%esp)
  10b198:	00 
  10b199:	8b 45 08             	mov    0x8(%ebp),%eax
  10b19c:	89 04 24             	mov    %eax,(%esp)
  10b19f:	e8 8c fe ff ff       	call   10b030 <e100_eeprom_shiftin>
    e100_eeprom_shiftin(dev, offset, dev->eeprom_size);
  10b1a4:	8b 45 08             	mov    0x8(%ebp),%eax
  10b1a7:	8b 80 3c 01 00 00    	mov    0x13c(%eax),%eax
  10b1ad:	89 44 24 08          	mov    %eax,0x8(%esp)
  10b1b1:	8b 45 0c             	mov    0xc(%ebp),%eax
  10b1b4:	89 44 24 04          	mov    %eax,0x4(%esp)
  10b1b8:	8b 45 08             	mov    0x8(%ebp),%eax
  10b1bb:	89 04 24             	mov    %eax,(%esp)
  10b1be:	e8 6d fe ff ff       	call   10b030 <e100_eeprom_shiftin>
    data = e100_eeprom_shiftout(dev);
  10b1c3:	8b 45 08             	mov    0x8(%ebp),%eax
  10b1c6:	89 04 24             	mov    %eax,(%esp)
  10b1c9:	e8 12 ff ff ff       	call   10b0e0 <e100_eeprom_shiftout>
  10b1ce:	66 89 45 fe          	mov    %ax,0xfffffffe(%ebp)
    e100_eeprom_out(dev, 0);
  10b1d2:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  10b1d9:	00 
  10b1da:	8b 45 08             	mov    0x8(%ebp),%eax
  10b1dd:	89 04 24             	mov    %eax,(%esp)
  10b1e0:	e8 fb fd ff ff       	call   10afe0 <e100_eeprom_out>
    return data;
  10b1e5:	0f b7 45 fe          	movzwl 0xfffffffe(%ebp),%eax
}
  10b1e9:	c9                   	leave  
  10b1ea:	c3                   	ret    
  10b1eb:	90                   	nop    
  10b1ec:	8d 74 26 00          	lea    0x0(%esi),%esi

0010b1f0 <e100_read_eeprom>:

void
e100_read_eeprom(e100_dev *dev, uint16_t *data, int offset, int len)
{
  10b1f0:	55                   	push   %ebp
  10b1f1:	89 e5                	mov    %esp,%ebp
  10b1f3:	53                   	push   %ebx
  10b1f4:	83 ec 18             	sub    $0x18,%esp
    int i;

    for (i=0; i<len; i++)
  10b1f7:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)
  10b1fe:	eb 26                	jmp    10b226 <e100_read_eeprom+0x36>
        data[i] = e100_eeprom_getword(dev, offset+i);
  10b200:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10b203:	01 c0                	add    %eax,%eax
  10b205:	89 c3                	mov    %eax,%ebx
  10b207:	03 5d 0c             	add    0xc(%ebp),%ebx
  10b20a:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10b20d:	03 45 10             	add    0x10(%ebp),%eax
  10b210:	89 44 24 04          	mov    %eax,0x4(%esp)
  10b214:	8b 45 08             	mov    0x8(%ebp),%eax
  10b217:	89 04 24             	mov    %eax,(%esp)
  10b21a:	e8 51 ff ff ff       	call   10b170 <e100_eeprom_getword>
  10b21f:	66 89 03             	mov    %ax,(%ebx)
  10b222:	83 45 f8 01          	addl   $0x1,0xfffffff8(%ebp)
  10b226:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10b229:	3b 45 14             	cmp    0x14(%ebp),%eax
  10b22c:	7c d2                	jl     10b200 <e100_read_eeprom+0x10>
}
  10b22e:	83 c4 18             	add    $0x18,%esp
  10b231:	5b                   	pop    %ebx
  10b232:	5d                   	pop    %ebp
  10b233:	c3                   	ret    
  10b234:	90                   	nop    
  10b235:	90                   	nop    
  10b236:	90                   	nop    
  10b237:	90                   	nop    
  10b238:	90                   	nop    
  10b239:	90                   	nop    
  10b23a:	90                   	nop    
  10b23b:	90                   	nop    
  10b23c:	90                   	nop    
  10b23d:	90                   	nop    
  10b23e:	90                   	nop    
  10b23f:	90                   	nop    

0010b240 <etharp_init>:
 * Initializes ARP module.
 */
void
etharp_init(void)
{
  10b240:	55                   	push   %ebp
  10b241:	89 e5                	mov    %esp,%ebp
  10b243:	83 ec 10             	sub    $0x10,%esp
  s8_t i;
  /* clear ARP entries */
  for(i = 0; i < ARP_TABLE_SIZE; ++i) {
  10b246:	c6 45 ff 00          	movb   $0x0,0xffffffff(%ebp)
  10b24a:	eb 46                	jmp    10b292 <etharp_init+0x52>
    arp_table[i].state = ETHARP_STATE_EMPTY;
  10b24c:	0f be 55 ff          	movsbl 0xffffffff(%ebp),%edx
  10b250:	89 d0                	mov    %edx,%eax
  10b252:	01 c0                	add    %eax,%eax
  10b254:	01 d0                	add    %edx,%eax
  10b256:	c1 e0 03             	shl    $0x3,%eax
  10b259:	c7 80 cc da 11 00 00 	movl   $0x0,0x11dacc(%eax)
  10b260:	00 00 00 
#if ARP_QUEUEING
    arp_table[i].p = NULL;
  10b263:	0f be 55 ff          	movsbl 0xffffffff(%ebp),%edx
  10b267:	89 d0                	mov    %edx,%eax
  10b269:	01 c0                	add    %eax,%eax
  10b26b:	01 d0                	add    %edx,%eax
  10b26d:	c1 e0 03             	shl    $0x3,%eax
  10b270:	c7 80 d0 da 11 00 00 	movl   $0x0,0x11dad0(%eax)
  10b277:	00 00 00 
#endif
    arp_table[i].ctime = 0;
  10b27a:	0f be 55 ff          	movsbl 0xffffffff(%ebp),%edx
  10b27e:	89 d0                	mov    %edx,%eax
  10b280:	01 c0                	add    %eax,%eax
  10b282:	01 d0                	add    %edx,%eax
  10b284:	c1 e0 03             	shl    $0x3,%eax
  10b287:	c6 80 d4 da 11 00 00 	movb   $0x0,0x11dad4(%eax)
  10b28e:	80 45 ff 01          	addb   $0x1,0xffffffff(%ebp)
  10b292:	80 7d ff 09          	cmpb   $0x9,0xffffffff(%ebp)
  10b296:	7e b4                	jle    10b24c <etharp_init+0xc>
  }
}
  10b298:	c9                   	leave  
  10b299:	c3                   	ret    
  10b29a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

0010b2a0 <etharp_tmr>:

/**
 * Clears expired entries in the ARP table.
 *
 * This function should be called every ETHARP_TMR_INTERVAL microseconds (10 seconds),
 * in order to expire entries in the ARP table.
 */
void
etharp_tmr(void)
{
  10b2a0:	55                   	push   %ebp
  10b2a1:	89 e5                	mov    %esp,%ebp
  10b2a3:	83 ec 18             	sub    $0x18,%esp
  s8_t i;

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  10b2a6:	c6 45 ff 00          	movb   $0x0,0xffffffff(%ebp)
  10b2aa:	e9 ec 00 00 00       	jmp    10b39b <etharp_tmr+0xfb>
    arp_table[i].ctime++;
  10b2af:	0f be 55 ff          	movsbl 0xffffffff(%ebp),%edx
  10b2b3:	89 d0                	mov    %edx,%eax
  10b2b5:	01 c0                	add    %eax,%eax
  10b2b7:	01 d0                	add    %edx,%eax
  10b2b9:	c1 e0 03             	shl    $0x3,%eax
  10b2bc:	0f b6 80 d4 da 11 00 	movzbl 0x11dad4(%eax),%eax
  10b2c3:	8d 48 01             	lea    0x1(%eax),%ecx
  10b2c6:	89 d0                	mov    %edx,%eax
  10b2c8:	01 c0                	add    %eax,%eax
  10b2ca:	01 d0                	add    %edx,%eax
  10b2cc:	c1 e0 03             	shl    $0x3,%eax
  10b2cf:	88 88 d4 da 11 00    	mov    %cl,0x11dad4(%eax)
    /* a resolved/stable entry? */
    if ((arp_table[i].state == ETHARP_STATE_STABLE) &&
  10b2d5:	0f be 55 ff          	movsbl 0xffffffff(%ebp),%edx
  10b2d9:	89 d0                	mov    %edx,%eax
  10b2db:	01 c0                	add    %eax,%eax
  10b2dd:	01 d0                	add    %edx,%eax
  10b2df:	c1 e0 03             	shl    $0x3,%eax
  10b2e2:	8b 80 cc da 11 00    	mov    0x11dacc(%eax),%eax
  10b2e8:	83 f8 02             	cmp    $0x2,%eax
  10b2eb:	75 1a                	jne    10b307 <etharp_tmr+0x67>
  10b2ed:	0f be 55 ff          	movsbl 0xffffffff(%ebp),%edx
  10b2f1:	89 d0                	mov    %edx,%eax
  10b2f3:	01 c0                	add    %eax,%eax
  10b2f5:	01 d0                	add    %edx,%eax
  10b2f7:	c1 e0 03             	shl    $0x3,%eax
  10b2fa:	0f b6 80 d4 da 11 00 	movzbl 0x11dad4(%eax),%eax
  10b301:	3c 77                	cmp    $0x77,%al
  10b303:	76 02                	jbe    10b307 <etharp_tmr+0x67>
         /* entry has become old? */
        (arp_table[i].ctime >= ARP_MAXAGE)) {
      LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer: expired stable entry %u.\n", i));
      goto empty;
  10b305:	eb 30                	jmp    10b337 <etharp_tmr+0x97>
    /* an unresolved/pending entry? */
    } else if ((arp_table[i].state == ETHARP_STATE_PENDING) &&
  10b307:	0f be 55 ff          	movsbl 0xffffffff(%ebp),%edx
  10b30b:	89 d0                	mov    %edx,%eax
  10b30d:	01 c0                	add    %eax,%eax
  10b30f:	01 d0                	add    %edx,%eax
  10b311:	c1 e0 03             	shl    $0x3,%eax
  10b314:	8b 80 cc da 11 00    	mov    0x11dacc(%eax),%eax
  10b31a:	83 f8 01             	cmp    $0x1,%eax
  10b31d:	75 78                	jne    10b397 <etharp_tmr+0xf7>
  10b31f:	0f be 55 ff          	movsbl 0xffffffff(%ebp),%edx
  10b323:	89 d0                	mov    %edx,%eax
  10b325:	01 c0                	add    %eax,%eax
  10b327:	01 d0                	add    %edx,%eax
  10b329:	c1 e0 03             	shl    $0x3,%eax
  10b32c:	0f b6 80 d4 da 11 00 	movzbl 0x11dad4(%eax),%eax
  10b333:	3c 01                	cmp    $0x1,%al
  10b335:	76 60                	jbe    10b397 <etharp_tmr+0xf7>
         /* entry unresolved/pending for too long? */
        (arp_table[i].ctime >= ARP_MAXPENDING)) {
      LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer: expired pending entry %u.\n", i));
  empty:
      /* empty old entry */      
      arp_table[i].state = ETHARP_STATE_EMPTY;
  10b337:	0f be 55 ff          	movsbl 0xffffffff(%ebp),%edx
  10b33b:	89 d0                	mov    %edx,%eax
  10b33d:	01 c0                	add    %eax,%eax
  10b33f:	01 d0                	add    %edx,%eax
  10b341:	c1 e0 03             	shl    $0x3,%eax
  10b344:	c7 80 cc da 11 00 00 	movl   $0x0,0x11dacc(%eax)
  10b34b:	00 00 00 
#if ARP_QUEUEING
      /* and empty packet queue */
      if (arp_table[i].p != NULL) {
  10b34e:	0f be 55 ff          	movsbl 0xffffffff(%ebp),%edx
  10b352:	89 d0                	mov    %edx,%eax
  10b354:	01 c0                	add    %eax,%eax
  10b356:	01 d0                	add    %edx,%eax
  10b358:	c1 e0 03             	shl    $0x3,%eax
  10b35b:	8b 80 d0 da 11 00    	mov    0x11dad0(%eax),%eax
  10b361:	85 c0                	test   %eax,%eax
  10b363:	74 32                	je     10b397 <etharp_tmr+0xf7>
        /* remove any queued packet */
        LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer: freeing entry %u, packet queue %p.\n", i, (void *)(arp_table[i].p)));
        pbuf_free(arp_table[i].p);
  10b365:	0f be 55 ff          	movsbl 0xffffffff(%ebp),%edx
  10b369:	89 d0                	mov    %edx,%eax
  10b36b:	01 c0                	add    %eax,%eax
  10b36d:	01 d0                	add    %edx,%eax
  10b36f:	c1 e0 03             	shl    $0x3,%eax
  10b372:	8b 80 d0 da 11 00    	mov    0x11dad0(%eax),%eax
  10b378:	89 04 24             	mov    %eax,(%esp)
  10b37b:	e8 40 41 00 00       	call   10f4c0 <pbuf_free>
        arp_table[i].p = NULL;
  10b380:	0f be 55 ff          	movsbl 0xffffffff(%ebp),%edx
  10b384:	89 d0                	mov    %edx,%eax
  10b386:	01 c0                	add    %eax,%eax
  10b388:	01 d0                	add    %edx,%eax
  10b38a:	c1 e0 03             	shl    $0x3,%eax
  10b38d:	c7 80 d0 da 11 00 00 	movl   $0x0,0x11dad0(%eax)
  10b394:	00 00 00 
  10b397:	80 45 ff 01          	addb   $0x1,0xffffffff(%ebp)
  10b39b:	80 7d ff 09          	cmpb   $0x9,0xffffffff(%ebp)
  10b39f:	0f 8e 0a ff ff ff    	jle    10b2af <etharp_tmr+0xf>
      }
#endif
    }
  }
}
  10b3a5:	c9                   	leave  
  10b3a6:	c3                   	ret    
  10b3a7:	89 f6                	mov    %esi,%esi
  10b3a9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

0010b3b0 <find_arp_entry>:

/**
 * Return an empty ARP entry (possibly recycling the oldest stable entry).
 *
 * @return The ARP entry index that is available, ERR_MEM if no usable
 * entry is found.
 */
static s8_t
find_arp_entry(void)
{
  10b3b0:	55                   	push   %ebp
  10b3b1:	89 e5                	mov    %esp,%ebp
  10b3b3:	83 ec 18             	sub    $0x18,%esp
  s8_t i, j;
  u8_t maxtime = 0;
  10b3b6:	c6 45 ff 00          	movb   $0x0,0xffffffff(%ebp)

  j = ARP_TABLE_SIZE;
  10b3ba:	c6 45 fe 0a          	movb   $0xa,0xfffffffe(%ebp)
  /* search ARP table for an unused or old entry */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  10b3be:	c6 45 fd 00          	movb   $0x0,0xfffffffd(%ebp)
  10b3c2:	eb 76                	jmp    10b43a <find_arp_entry+0x8a>
  	/* empty entry? */
    if (arp_table[i].state == ETHARP_STATE_EMPTY) {
  10b3c4:	0f be 55 fd          	movsbl 0xfffffffd(%ebp),%edx
  10b3c8:	89 d0                	mov    %edx,%eax
  10b3ca:	01 c0                	add    %eax,%eax
  10b3cc:	01 d0                	add    %edx,%eax
  10b3ce:	c1 e0 03             	shl    $0x3,%eax
  10b3d1:	8b 80 cc da 11 00    	mov    0x11dacc(%eax),%eax
  10b3d7:	85 c0                	test   %eax,%eax
  10b3d9:	75 0c                	jne    10b3e7 <find_arp_entry+0x37>
      LWIP_DEBUGF(ETHARP_DEBUG, ("find_arp_entry: returning empty entry %u\n", i));
      return i;
  10b3db:	0f be 45 fd          	movsbl 0xfffffffd(%ebp),%eax
  10b3df:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  10b3e2:	e9 cb 00 00 00       	jmp    10b4b2 <find_arp_entry+0x102>
  	/* stable entry? */
    } else if (arp_table[i].state == ETHARP_STATE_STABLE) {
  10b3e7:	0f be 55 fd          	movsbl 0xfffffffd(%ebp),%edx
  10b3eb:	89 d0                	mov    %edx,%eax
  10b3ed:	01 c0                	add    %eax,%eax
  10b3ef:	01 d0                	add    %edx,%eax
  10b3f1:	c1 e0 03             	shl    $0x3,%eax
  10b3f4:	8b 80 cc da 11 00    	mov    0x11dacc(%eax),%eax
  10b3fa:	83 f8 02             	cmp    $0x2,%eax
  10b3fd:	75 37                	jne    10b436 <find_arp_entry+0x86>
      /* remember entry with oldest stable entry in j */
      if (arp_table[i].ctime >= maxtime) maxtime = arp_table[j = i].ctime;
  10b3ff:	0f be 55 fd          	movsbl 0xfffffffd(%ebp),%edx
  10b403:	89 d0                	mov    %edx,%eax
  10b405:	01 c0                	add    %eax,%eax
  10b407:	01 d0                	add    %edx,%eax
  10b409:	c1 e0 03             	shl    $0x3,%eax
  10b40c:	0f b6 80 d4 da 11 00 	movzbl 0x11dad4(%eax),%eax
  10b413:	3a 45 ff             	cmp    0xffffffff(%ebp),%al
  10b416:	72 1e                	jb     10b436 <find_arp_entry+0x86>
  10b418:	0f b6 45 fd          	movzbl 0xfffffffd(%ebp),%eax
  10b41c:	88 45 fe             	mov    %al,0xfffffffe(%ebp)
  10b41f:	0f be 55 fe          	movsbl 0xfffffffe(%ebp),%edx
  10b423:	89 d0                	mov    %edx,%eax
  10b425:	01 c0                	add    %eax,%eax
  10b427:	01 d0                	add    %edx,%eax
  10b429:	c1 e0 03             	shl    $0x3,%eax
  10b42c:	0f b6 80 d4 da 11 00 	movzbl 0x11dad4(%eax),%eax
  10b433:	88 45 ff             	mov    %al,0xffffffff(%ebp)
  10b436:	80 45 fd 01          	addb   $0x1,0xfffffffd(%ebp)
  10b43a:	80 7d fd 09          	cmpb   $0x9,0xfffffffd(%ebp)
  10b43e:	7e 84                	jle    10b3c4 <find_arp_entry+0x14>
    }
  }
  /* no empty entry found? */
  if (i == ARP_TABLE_SIZE) {
  10b440:	80 7d fd 0a          	cmpb   $0xa,0xfffffffd(%ebp)
  10b444:	75 07                	jne    10b44d <find_arp_entry+0x9d>
  	LWIP_DEBUGF(ETHARP_DEBUG, ("find_arp_entry: found oldest stable entry %u\n", j));
    /* fall-back to oldest stable */
  	i = j;
  10b446:	0f b6 45 fe          	movzbl 0xfffffffe(%ebp),%eax
  10b44a:	88 45 fd             	mov    %al,0xfffffffd(%ebp)
  }
  /* no available entry found? */
  if (i == ARP_TABLE_SIZE) {
  10b44d:	80 7d fd 0a          	cmpb   $0xa,0xfffffffd(%ebp)
  10b451:	75 09                	jne    10b45c <find_arp_entry+0xac>
    LWIP_DEBUGF(ETHARP_DEBUG, ("find_arp_entry: no replacable entry could be found\n"));
    /* return failure */
    return ERR_MEM;
  10b453:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  10b45a:	eb 56                	jmp    10b4b2 <find_arp_entry+0x102>
  }

  /* clean up the recycled stable entry */
  if (arp_table[i].state == ETHARP_STATE_STABLE) {
  10b45c:	0f be 55 fd          	movsbl 0xfffffffd(%ebp),%edx
  10b460:	89 d0                	mov    %edx,%eax
  10b462:	01 c0                	add    %eax,%eax
  10b464:	01 d0                	add    %edx,%eax
  10b466:	c1 e0 03             	shl    $0x3,%eax
  10b469:	8b 80 cc da 11 00    	mov    0x11dacc(%eax),%eax
  10b46f:	83 f8 02             	cmp    $0x2,%eax
  10b472:	75 37                	jne    10b4ab <find_arp_entry+0xfb>
#if ARP_QUEUEING
    /* free packets on queue */
    etharp_dequeue(i);
  10b474:	0f be 45 fd          	movsbl 0xfffffffd(%ebp),%eax
  10b478:	89 04 24             	mov    %eax,(%esp)
  10b47b:	e8 c0 00 00 00       	call   10b540 <etharp_dequeue>
#endif
    LWIP_DEBUGF(ETHARP_DEBUG | DBG_TRACE, ("find_arp_entry: recycling oldest stable entry %u\n", i));
    arp_table[i].state = ETHARP_STATE_EMPTY;
  10b480:	0f be 55 fd          	movsbl 0xfffffffd(%ebp),%edx
  10b484:	89 d0                	mov    %edx,%eax
  10b486:	01 c0                	add    %eax,%eax
  10b488:	01 d0                	add    %edx,%eax
  10b48a:	c1 e0 03             	shl    $0x3,%eax
  10b48d:	c7 80 cc da 11 00 00 	movl   $0x0,0x11dacc(%eax)
  10b494:	00 00 00 
    arp_table[i].ctime = 0;
  10b497:	0f be 55 fd          	movsbl 0xfffffffd(%ebp),%edx
  10b49b:	89 d0                	mov    %edx,%eax
  10b49d:	01 c0                	add    %eax,%eax
  10b49f:	01 d0                	add    %edx,%eax
  10b4a1:	c1 e0 03             	shl    $0x3,%eax
  10b4a4:	c6 80 d4 da 11 00 00 	movb   $0x0,0x11dad4(%eax)
  }
  LWIP_DEBUGF(ETHARP_DEBUG, ("find_arp_entry: returning %u\n", i));
  return i;
  10b4ab:	0f be 45 fd          	movsbl 0xfffffffd(%ebp),%eax
  10b4af:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  10b4b2:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  10b4b5:	c9                   	leave  
  10b4b6:	c3                   	ret    
  10b4b7:	89 f6                	mov    %esi,%esi
  10b4b9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

0010b4c0 <etharp_enqueue>:

#if ARP_QUEUEING
/*
 * Enqueues a pbuf (chain) on an ARP entry.
 * 
 * Places the pbuf (chain) on the queue (if space allows). The
 * caller may safely free the pbuf (chain) afterwards, as the
 * pbufs will be referenced by the queue and copies are made of
 * pbufs referencing external payloads.
 * 
 * @ i the ARP entry index
 * @arg q the pbuf (chain) to be queued on the ARP entry
 * 
 * @return Returns the new head of queue of the ARP entry.
 * 
 */
static struct pbuf *
etharp_enqueue(s8_t i, struct pbuf *q)
{
  10b4c0:	55                   	push   %ebp
  10b4c1:	89 e5                	mov    %esp,%ebp
  10b4c3:	83 ec 18             	sub    $0x18,%esp
  10b4c6:	8b 45 08             	mov    0x8(%ebp),%eax
  10b4c9:	88 45 ec             	mov    %al,0xffffffec(%ebp)
  /* any pbuf to queue? */
  if (q != NULL) {
  10b4cc:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  10b4d0:	74 59                	je     10b52b <etharp_enqueue+0x6b>
/* queue later packet over earliers? TODO: Implement multiple pbuf queue */
#if ARP_QUEUE_FIRST == 0
    /* remove any pbufs on queue */
    u8_t deq = etharp_dequeue(i);
  10b4d2:	0f be 45 ec          	movsbl 0xffffffec(%ebp),%eax
  10b4d6:	89 04 24             	mov    %eax,(%esp)
  10b4d9:	e8 62 00 00 00       	call   10b540 <etharp_dequeue>
  10b4de:	88 45 ff             	mov    %al,0xffffffff(%ebp)
    if (deq > 0) LWIP_DEBUGF(ETHARP_DEBUG | DBG_TRACE | 3, ("etharp_query: dequeued %u pbufs from ARP entry %u. Should not occur.\n", deq, i));
#endif
    /* packet can be queued? TODO: Implement multiple pbuf queue */
    if (arp_table[i].p == NULL) {
  10b4e1:	0f be 55 ec          	movsbl 0xffffffec(%ebp),%edx
  10b4e5:	89 d0                	mov    %edx,%eax
  10b4e7:	01 c0                	add    %eax,%eax
  10b4e9:	01 d0                	add    %edx,%eax
  10b4eb:	c1 e0 03             	shl    $0x3,%eax
  10b4ee:	8b 80 d0 da 11 00    	mov    0x11dad0(%eax),%eax
  10b4f4:	85 c0                	test   %eax,%eax
  10b4f6:	75 33                	jne    10b52b <etharp_enqueue+0x6b>
      /* copy any PBUF_REF referenced payloads into PBUF_RAM */
      q = pbuf_take(q);
  10b4f8:	8b 45 0c             	mov    0xc(%ebp),%eax
  10b4fb:	89 04 24             	mov    %eax,(%esp)
  10b4fe:	e8 7d 42 00 00       	call   10f780 <pbuf_take>
  10b503:	89 45 0c             	mov    %eax,0xc(%ebp)
      /* add pbuf to queue */
      arp_table[i].p = q;
  10b506:	0f be 55 ec          	movsbl 0xffffffec(%ebp),%edx
  10b50a:	89 d0                	mov    %edx,%eax
  10b50c:	01 c0                	add    %eax,%eax
  10b50e:	01 d0                	add    %edx,%eax
  10b510:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
  10b517:	8b 45 0c             	mov    0xc(%ebp),%eax
  10b51a:	89 82 d0 da 11 00    	mov    %eax,0x11dad0(%edx)
      /* pbuf (chain) now queued, increase the reference count */
      pbuf_ref(q);
  10b520:	8b 45 0c             	mov    0xc(%ebp),%eax
  10b523:	89 04 24             	mov    %eax,(%esp)
  10b526:	e8 05 41 00 00       	call   10f630 <pbuf_ref>
      LWIP_DEBUGF(ETHARP_DEBUG | DBG_TRACE | DBG_STATE, ("etharp_query: queued packet %p on ARP entry %u.\n", (void *)q, i));
    }
  }
  return arp_table[i].p;
  10b52b:	0f be 55 ec          	movsbl 0xffffffec(%ebp),%edx
  10b52f:	89 d0                	mov    %edx,%eax
  10b531:	01 c0                	add    %eax,%eax
  10b533:	01 d0                	add    %edx,%eax
  10b535:	c1 e0 03             	shl    $0x3,%eax
  10b538:	8b 80 d0 da 11 00    	mov    0x11dad0(%eax),%eax
}
  10b53e:	c9                   	leave  
  10b53f:	c3                   	ret    

0010b540 <etharp_dequeue>:

/**
 * Dequeues any pbufs queued on an ARP entry
 * 
 * @return number of pbufs removed from the queue
 * 
 * TODO: decide what is a sensible return value?
 */
static u8_t
etharp_dequeue(s8_t i)
{
  10b540:	55                   	push   %ebp
  10b541:	89 e5                	mov    %esp,%ebp
  10b543:	83 ec 18             	sub    $0x18,%esp
  10b546:	8b 45 08             	mov    0x8(%ebp),%eax
  10b549:	88 45 fc             	mov    %al,0xfffffffc(%ebp)
  /* queued packets on a stable entry (work in progress) */
  if (arp_table[i].p != NULL) {
  10b54c:	0f be 55 fc          	movsbl 0xfffffffc(%ebp),%edx
  10b550:	89 d0                	mov    %edx,%eax
  10b552:	01 c0                	add    %eax,%eax
  10b554:	01 d0                	add    %edx,%eax
  10b556:	c1 e0 03             	shl    $0x3,%eax
  10b559:	8b 80 d0 da 11 00    	mov    0x11dad0(%eax),%eax
  10b55f:	85 c0                	test   %eax,%eax
  10b561:	74 3b                	je     10b59e <etharp_dequeue+0x5e>
  	/* queue no longer references pbuf */
  	pbuf_free(arp_table[i].p);
  10b563:	0f be 55 fc          	movsbl 0xfffffffc(%ebp),%edx
  10b567:	89 d0                	mov    %edx,%eax
  10b569:	01 c0                	add    %eax,%eax
  10b56b:	01 d0                	add    %edx,%eax
  10b56d:	c1 e0 03             	shl    $0x3,%eax
  10b570:	8b 80 d0 da 11 00    	mov    0x11dad0(%eax),%eax
  10b576:	89 04 24             	mov    %eax,(%esp)
  10b579:	e8 42 3f 00 00       	call   10f4c0 <pbuf_free>
    arp_table[i].p = NULL;
  10b57e:	0f be 55 fc          	movsbl 0xfffffffc(%ebp),%edx
  10b582:	89 d0                	mov    %edx,%eax
  10b584:	01 c0                	add    %eax,%eax
  10b586:	01 d0                	add    %edx,%eax
  10b588:	c1 e0 03             	shl    $0x3,%eax
  10b58b:	c7 80 d0 da 11 00 00 	movl   $0x0,0x11dad0(%eax)
  10b592:	00 00 00 
    return 1;
  10b595:	c7 45 f8 01 00 00 00 	movl   $0x1,0xfffffff8(%ebp)
  10b59c:	eb 07                	jmp    10b5a5 <etharp_dequeue+0x65>
  } else {
    return 0;
  10b59e:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)
  10b5a5:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  }
}
  10b5a8:	c9                   	leave  
  10b5a9:	c3                   	ret    
  10b5aa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

0010b5b0 <update_arp_entry>:
#endif

/**
 * Update (or insert) a IP/MAC address pair in the ARP cache.
 *
 * If a pending entry is resolved, any queued packets will be sent
 * at this point.
 * 
 * @param ipaddr IP address of the inserted ARP entry.
 * @param ethaddr Ethernet address of the inserted ARP entry.
 * @param flags Defines behaviour:
 * - ARP_INSERT_FLAG Allows ARP to insert this as a new item. If not specified,
 * only existing ARP entries will be updated.
 *
 * @return pbuf If non-NULL, a packet that was queued on a pending entry.
 * You should sent it and must call pbuf_free() afterwards.
 *
 * @see pbuf_free()
 */
static struct pbuf *
update_arp_entry(struct netif *netif, struct ip_addr *ipaddr, struct eth_addr *ethaddr, u8_t flags)
{
  10b5b0:	55                   	push   %ebp
  10b5b1:	89 e5                	mov    %esp,%ebp
  10b5b3:	53                   	push   %ebx
  10b5b4:	83 ec 44             	sub    $0x44,%esp
  10b5b7:	8b 45 14             	mov    0x14(%ebp),%eax
  10b5ba:	88 45 d8             	mov    %al,0xffffffd8(%ebp)
  s8_t i, k;
  LWIP_DEBUGF(ETHARP_DEBUG | DBG_TRACE | 3, ("update_arp_entry()\n"));
  LWIP_ASSERT("netif->hwaddr_len != 0", netif->hwaddr_len != 0);
  LWIP_DEBUGF(ETHARP_DEBUG | DBG_TRACE, ("update_arp_entry: %u.%u.%u.%u - %02x:%02x:%02x:%02x:%02x:%02x\n", ip4_addr1(ipaddr), ip4_addr2(ipaddr), ip4_addr3(ipaddr), ip4_addr4(ipaddr),
  ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2], ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* do not update for 0.0.0.0 addresses */
  if (ipaddr->addr == 0) {
  10b5bd:	8b 45 0c             	mov    0xc(%ebp),%eax
  10b5c0:	8b 00                	mov    (%eax),%eax
  10b5c2:	85 c0                	test   %eax,%eax
  10b5c4:	75 0c                	jne    10b5d2 <update_arp_entry+0x22>
    LWIP_DEBUGF(ETHARP_DEBUG | DBG_TRACE, ("update_arp_entry: will not add 0.0.0.0 to ARP cache\n"));
    return NULL;
  10b5c6:	c7 45 cc 00 00 00 00 	movl   $0x0,0xffffffcc(%ebp)
  10b5cd:	e9 bf 02 00 00       	jmp    10b891 <update_arp_entry+0x2e1>
  }
  /* Walk through the ARP mapping table and try to find an entry to
  update. If none is found, the IP -> MAC address mapping is
  inserted in the ARP table. */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  10b5d2:	c6 45 ea 00          	movb   $0x0,0xffffffea(%ebp)
  10b5d6:	e9 d5 01 00 00       	jmp    10b7b0 <update_arp_entry+0x200>
    /* Check if the source IP address of the incoming packet matches
    the IP address in this ARP table entry. */
    if (ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
  10b5db:	8b 45 0c             	mov    0xc(%ebp),%eax
  10b5de:	8b 08                	mov    (%eax),%ecx
  10b5e0:	0f be 55 ea          	movsbl 0xffffffea(%ebp),%edx
  10b5e4:	89 d0                	mov    %edx,%eax
  10b5e6:	01 c0                	add    %eax,%eax
  10b5e8:	01 d0                	add    %edx,%eax
  10b5ea:	c1 e0 03             	shl    $0x3,%eax
  10b5ed:	8b 80 c0 da 11 00    	mov    0x11dac0(%eax),%eax
  10b5f3:	39 c1                	cmp    %eax,%ecx
  10b5f5:	0f 85 b1 01 00 00    	jne    10b7ac <update_arp_entry+0x1fc>
      /* pending entry? */
      if (arp_table[i].state == ETHARP_STATE_PENDING) {
  10b5fb:	0f be 55 ea          	movsbl 0xffffffea(%ebp),%edx
  10b5ff:	89 d0                	mov    %edx,%eax
  10b601:	01 c0                	add    %eax,%eax
  10b603:	01 d0                	add    %edx,%eax
  10b605:	c1 e0 03             	shl    $0x3,%eax
  10b608:	8b 80 cc da 11 00    	mov    0x11dacc(%eax),%eax
  10b60e:	83 f8 01             	cmp    $0x1,%eax
  10b611:	75 1b                	jne    10b62e <update_arp_entry+0x7e>
        LWIP_DEBUGF(ETHARP_DEBUG | DBG_TRACE, ("update_arp_entry: pending entry %u goes stable\n", i));
        /* A pending entry was found, mark it stable */
        arp_table[i].state = ETHARP_STATE_STABLE;
  10b613:	0f be 45 ea          	movsbl 0xffffffea(%ebp),%eax
  10b617:	89 c2                	mov    %eax,%edx
  10b619:	01 d2                	add    %edx,%edx
  10b61b:	01 c2                	add    %eax,%edx
  10b61d:	8d 04 d5 00 00 00 00 	lea    0x0(,%edx,8),%eax
  10b624:	c7 80 cc da 11 00 02 	movl   $0x2,0x11dacc(%eax)
  10b62b:	00 00 00 
        /* fall-through to next if */
      }
      /* stable entry? (possibly just marked to become stable) */
      if (arp_table[i].state == ETHARP_STATE_STABLE) {
  10b62e:	0f be 55 ea          	movsbl 0xffffffea(%ebp),%edx
  10b632:	89 d0                	mov    %edx,%eax
  10b634:	01 c0                	add    %eax,%eax
  10b636:	01 d0                	add    %edx,%eax
  10b638:	c1 e0 03             	shl    $0x3,%eax
  10b63b:	8b 80 cc da 11 00    	mov    0x11dacc(%eax),%eax
  10b641:	83 f8 02             	cmp    $0x2,%eax
  10b644:	0f 85 62 01 00 00    	jne    10b7ac <update_arp_entry+0x1fc>
#if ARP_QUEUEING
        struct pbuf *p;
        struct eth_hdr *ethhdr;
#endif
        LWIP_DEBUGF(ETHARP_DEBUG | DBG_TRACE, ("update_arp_entry: updating stable entry %u\n", i));
        /* An old entry found, update this and return. */
        for (k = 0; k < netif->hwaddr_len; ++k) {
  10b64a:	c6 45 eb 00          	movb   $0x0,0xffffffeb(%ebp)
  10b64e:	eb 2a                	jmp    10b67a <update_arp_entry+0xca>
          arp_table[i].ethaddr.addr[k] = ethaddr->addr[k];
  10b650:	0f be 4d ea          	movsbl 0xffffffea(%ebp),%ecx
  10b654:	0f be 5d eb          	movsbl 0xffffffeb(%ebp),%ebx
  10b658:	0f be 55 eb          	movsbl 0xffffffeb(%ebp),%edx
  10b65c:	8b 45 10             	mov    0x10(%ebp),%eax
  10b65f:	0f b6 14 10          	movzbl (%eax,%edx,1),%edx
  10b663:	89 c8                	mov    %ecx,%eax
  10b665:	01 c0                	add    %eax,%eax
  10b667:	01 c8                	add    %ecx,%eax
  10b669:	c1 e0 03             	shl    $0x3,%eax
  10b66c:	01 d8                	add    %ebx,%eax
  10b66e:	05 c0 da 11 00       	add    $0x11dac0,%eax
  10b673:	88 50 04             	mov    %dl,0x4(%eax)
  10b676:	80 45 eb 01          	addb   $0x1,0xffffffeb(%ebp)
  10b67a:	0f be 55 eb          	movsbl 0xffffffeb(%ebp),%edx
  10b67e:	8b 45 08             	mov    0x8(%ebp),%eax
  10b681:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  10b685:	0f b6 c0             	movzbl %al,%eax
  10b688:	39 c2                	cmp    %eax,%edx
  10b68a:	7c c4                	jl     10b650 <update_arp_entry+0xa0>
        }
        /* reset time stamp */
        arp_table[i].ctime = 0;
  10b68c:	0f be 55 ea          	movsbl 0xffffffea(%ebp),%edx
  10b690:	89 d0                	mov    %edx,%eax
  10b692:	01 c0                	add    %eax,%eax
  10b694:	01 d0                	add    %edx,%eax
  10b696:	c1 e0 03             	shl    $0x3,%eax
  10b699:	c6 80 d4 da 11 00 00 	movb   $0x0,0x11dad4(%eax)
/* this is where we will send out queued packets! */
#if ARP_QUEUEING
        /* get the first packet on the queue (if any) */
        p = arp_table[i].p;
  10b6a0:	0f be 55 ea          	movsbl 0xffffffea(%ebp),%edx
  10b6a4:	89 d0                	mov    %edx,%eax
  10b6a6:	01 c0                	add    %eax,%eax
  10b6a8:	01 d0                	add    %edx,%eax
  10b6aa:	c1 e0 03             	shl    $0x3,%eax
  10b6ad:	8b 80 d0 da 11 00    	mov    0x11dad0(%eax),%eax
  10b6b3:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
        /* (another) queued packet present? */
        while (p != NULL) {
  10b6b6:	e9 c0 00 00 00       	jmp    10b77b <update_arp_entry+0x1cb>
          struct pbuf *q, *n;
          /* search for second packet on queue (n) */
          q = p;
  10b6bb:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10b6be:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
          while (q->tot_len > q->len) {
  10b6c1:	eb 08                	jmp    10b6cb <update_arp_entry+0x11b>
            LWIP_ASSERT("q->next != NULL (while q->tot_len > q->len)", q->next != NULL);
            /* proceed to next pbuf of this packet */
            q = q->next;
  10b6c3:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10b6c6:	8b 00                	mov    (%eax),%eax
  10b6c8:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  10b6cb:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10b6ce:	0f b7 50 08          	movzwl 0x8(%eax),%edx
  10b6d2:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10b6d5:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  10b6d9:	66 39 c2             	cmp    %ax,%dx
  10b6dc:	77 e5                	ja     10b6c3 <update_arp_entry+0x113>
          }
          /* { q = last pbuf of this packet, q->tot_len == q->len } */
          LWIP_ASSERT("q->tot_len == q->len", q->tot_len == q->len);
          /* remember next packet on queue */
          n = q->next;
  10b6de:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10b6e1:	8b 00                	mov    (%eax),%eax
  10b6e3:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
          /* { n = first pbuf of next packet, or NULL if no next packet } */
          /* terminate this packet pbuf chain */
          q->next = NULL;
  10b6e6:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10b6e9:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
          /* fill-in Ethernet header */
          ethhdr = p->payload;
  10b6ef:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10b6f2:	8b 40 04             	mov    0x4(%eax),%eax
  10b6f5:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
          for (k = 0; k < netif->hwaddr_len; ++k) {
  10b6f8:	c6 45 eb 00          	movb   $0x0,0xffffffeb(%ebp)
  10b6fc:	eb 30                	jmp    10b72e <update_arp_entry+0x17e>
            ethhdr->dest.addr[k] = ethaddr->addr[k];
  10b6fe:	0f be 4d eb          	movsbl 0xffffffeb(%ebp),%ecx
  10b702:	0f be 55 eb          	movsbl 0xffffffeb(%ebp),%edx
  10b706:	8b 45 10             	mov    0x10(%ebp),%eax
  10b709:	0f b6 14 10          	movzbl (%eax,%edx,1),%edx
  10b70d:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10b710:	88 14 08             	mov    %dl,(%eax,%ecx,1)
            ethhdr->src.addr[k] = netif->hwaddr[k];
  10b713:	0f be 4d eb          	movsbl 0xffffffeb(%ebp),%ecx
  10b717:	0f be 55 eb          	movsbl 0xffffffeb(%ebp),%edx
  10b71b:	8b 45 08             	mov    0x8(%ebp),%eax
  10b71e:	0f b6 54 02 21       	movzbl 0x21(%edx,%eax,1),%edx
  10b723:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10b726:	88 54 01 06          	mov    %dl,0x6(%ecx,%eax,1)
  10b72a:	80 45 eb 01          	addb   $0x1,0xffffffeb(%ebp)
  10b72e:	0f be 55 eb          	movsbl 0xffffffeb(%ebp),%edx
  10b732:	8b 45 08             	mov    0x8(%ebp),%eax
  10b735:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  10b739:	0f b6 c0             	movzbl %al,%eax
  10b73c:	39 c2                	cmp    %eax,%edx
  10b73e:	7c be                	jl     10b6fe <update_arp_entry+0x14e>
          }
          ethhdr->type = htons(ETHTYPE_IP);
  10b740:	c7 04 24 00 08 00 00 	movl   $0x800,(%esp)
  10b747:	e8 34 2b 00 00       	call   10e280 <htons>
  10b74c:	89 c2                	mov    %eax,%edx
  10b74e:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10b751:	66 89 50 0c          	mov    %dx,0xc(%eax)
          LWIP_DEBUGF(ETHARP_DEBUG | DBG_TRACE, ("update_arp_entry: sending queued IP packet %p.\n", (void *)p));
          /* send the queued IP packet */
          netif->linkoutput(netif, p);
  10b755:	8b 45 08             	mov    0x8(%ebp),%eax
  10b758:	8b 50 18             	mov    0x18(%eax),%edx
  10b75b:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10b75e:	89 44 24 04          	mov    %eax,0x4(%esp)
  10b762:	8b 45 08             	mov    0x8(%ebp),%eax
  10b765:	89 04 24             	mov    %eax,(%esp)
  10b768:	ff d2                	call   *%edx
          /* free the queued IP packet */
          pbuf_free(p);
  10b76a:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10b76d:	89 04 24             	mov    %eax,(%esp)
  10b770:	e8 4b 3d 00 00       	call   10f4c0 <pbuf_free>
          /* proceed to next packet on queue */
          p = n;
  10b775:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10b778:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  10b77b:	83 7d ec 00          	cmpl   $0x0,0xffffffec(%ebp)
  10b77f:	0f 85 36 ff ff ff    	jne    10b6bb <update_arp_entry+0x10b>
        }
        /* NULL attached buffer*/
        arp_table[i].p = NULL;
  10b785:	0f be 45 ea          	movsbl 0xffffffea(%ebp),%eax
  10b789:	89 c2                	mov    %eax,%edx
  10b78b:	01 d2                	add    %edx,%edx
  10b78d:	01 c2                	add    %eax,%edx
  10b78f:	8d 04 d5 00 00 00 00 	lea    0x0(,%edx,8),%eax
  10b796:	c7 80 d0 da 11 00 00 	movl   $0x0,0x11dad0(%eax)
  10b79d:	00 00 00 
#endif
        /* IP addresses should only occur once in the ARP entry, we are done */
        return NULL;
  10b7a0:	c7 45 cc 00 00 00 00 	movl   $0x0,0xffffffcc(%ebp)
  10b7a7:	e9 e5 00 00 00       	jmp    10b891 <update_arp_entry+0x2e1>
  10b7ac:	80 45 ea 01          	addb   $0x1,0xffffffea(%ebp)
  10b7b0:	80 7d ea 09          	cmpb   $0x9,0xffffffea(%ebp)
  10b7b4:	0f 8e 21 fe ff ff    	jle    10b5db <update_arp_entry+0x2b>
      }
    } /* if STABLE */
  } /* for all ARP entries */

  /* no matching ARP entry was found */
  LWIP_ASSERT("update_arp_entry: i == ARP_TABLE_SIZE", i == ARP_TABLE_SIZE);

  LWIP_DEBUGF(ETHARP_DEBUG | DBG_TRACE, ("update_arp_entry: IP address not yet in table\n"));
  /* allowed to insert an entry? */
  if ((ETHARP_ALWAYS_INSERT) || (flags & ARP_INSERT_FLAG))
  {
    LWIP_DEBUGF(ETHARP_DEBUG | DBG_TRACE, ("update_arp_entry: adding entry to table\n"));
    /* find an empty or old entry. */
    i = find_arp_entry();
  10b7ba:	e8 f1 fb ff ff       	call   10b3b0 <find_arp_entry>
  10b7bf:	88 45 ea             	mov    %al,0xffffffea(%ebp)
    if (i == ERR_MEM) {
  10b7c2:	80 7d ea ff          	cmpb   $0xff,0xffffffea(%ebp)
  10b7c6:	75 0c                	jne    10b7d4 <update_arp_entry+0x224>
      LWIP_DEBUGF(ETHARP_DEBUG | DBG_TRACE, ("update_arp_entry: no available entry found\n"));
      return NULL;
  10b7c8:	c7 45 cc 00 00 00 00 	movl   $0x0,0xffffffcc(%ebp)
  10b7cf:	e9 bd 00 00 00       	jmp    10b891 <update_arp_entry+0x2e1>
    }
    /* set IP address */
    ip_addr_set(&arp_table[i].ipaddr, ipaddr);
  10b7d4:	0f be 45 ea          	movsbl 0xffffffea(%ebp),%eax
  10b7d8:	89 45 d0             	mov    %eax,0xffffffd0(%ebp)
  10b7db:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  10b7df:	74 0a                	je     10b7eb <update_arp_entry+0x23b>
  10b7e1:	8b 45 0c             	mov    0xc(%ebp),%eax
  10b7e4:	8b 00                	mov    (%eax),%eax
  10b7e6:	89 45 d4             	mov    %eax,0xffffffd4(%ebp)
  10b7e9:	eb 07                	jmp    10b7f2 <update_arp_entry+0x242>
  10b7eb:	c7 45 d4 00 00 00 00 	movl   $0x0,0xffffffd4(%ebp)
  10b7f2:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
  10b7f5:	01 c0                	add    %eax,%eax
  10b7f7:	03 45 d0             	add    0xffffffd0(%ebp),%eax
  10b7fa:	c1 e0 03             	shl    $0x3,%eax
  10b7fd:	8b 55 d4             	mov    0xffffffd4(%ebp),%edx
  10b800:	89 90 c0 da 11 00    	mov    %edx,0x11dac0(%eax)
    /* set Ethernet hardware address */
    for (k = 0; k < netif->hwaddr_len; ++k) {
  10b806:	c6 45 eb 00          	movb   $0x0,0xffffffeb(%ebp)
  10b80a:	eb 2a                	jmp    10b836 <update_arp_entry+0x286>
      arp_table[i].ethaddr.addr[k] = ethaddr->addr[k];
  10b80c:	0f be 4d ea          	movsbl 0xffffffea(%ebp),%ecx
  10b810:	0f be 5d eb          	movsbl 0xffffffeb(%ebp),%ebx
  10b814:	0f be 55 eb          	movsbl 0xffffffeb(%ebp),%edx
  10b818:	8b 45 10             	mov    0x10(%ebp),%eax
  10b81b:	0f b6 14 10          	movzbl (%eax,%edx,1),%edx
  10b81f:	89 c8                	mov    %ecx,%eax
  10b821:	01 c0                	add    %eax,%eax
  10b823:	01 c8                	add    %ecx,%eax
  10b825:	c1 e0 03             	shl    $0x3,%eax
  10b828:	01 d8                	add    %ebx,%eax
  10b82a:	05 c0 da 11 00       	add    $0x11dac0,%eax
  10b82f:	88 50 04             	mov    %dl,0x4(%eax)
  10b832:	80 45 eb 01          	addb   $0x1,0xffffffeb(%ebp)
  10b836:	0f be 55 eb          	movsbl 0xffffffeb(%ebp),%edx
  10b83a:	8b 45 08             	mov    0x8(%ebp),%eax
  10b83d:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  10b841:	0f b6 c0             	movzbl %al,%eax
  10b844:	39 c2                	cmp    %eax,%edx
  10b846:	7c c4                	jl     10b80c <update_arp_entry+0x25c>
    }
    /* reset time-stamp */
    arp_table[i].ctime = 0;
  10b848:	0f be 55 ea          	movsbl 0xffffffea(%ebp),%edx
  10b84c:	89 d0                	mov    %edx,%eax
  10b84e:	01 c0                	add    %eax,%eax
  10b850:	01 d0                	add    %edx,%eax
  10b852:	c1 e0 03             	shl    $0x3,%eax
  10b855:	c6 80 d4 da 11 00 00 	movb   $0x0,0x11dad4(%eax)
    /* mark as stable */
    arp_table[i].state = ETHARP_STATE_STABLE;
  10b85c:	0f be 55 ea          	movsbl 0xffffffea(%ebp),%edx
  10b860:	89 d0                	mov    %edx,%eax
  10b862:	01 c0                	add    %eax,%eax
  10b864:	01 d0                	add    %edx,%eax
  10b866:	c1 e0 03             	shl    $0x3,%eax
  10b869:	c7 80 cc da 11 00 02 	movl   $0x2,0x11dacc(%eax)
  10b870:	00 00 00 
    /* no queued packet */
#if ARP_QUEUEING
    arp_table[i].p = NULL;
  10b873:	0f be 55 ea          	movsbl 0xffffffea(%ebp),%edx
  10b877:	89 d0                	mov    %edx,%eax
  10b879:	01 c0                	add    %eax,%eax
  10b87b:	01 d0                	add    %edx,%eax
  10b87d:	c1 e0 03             	shl    $0x3,%eax
  10b880:	c7 80 d0 da 11 00 00 	movl   $0x0,0x11dad0(%eax)
  10b887:	00 00 00 
#endif
  }
  else
  {
    LWIP_DEBUGF(ETHARP_DEBUG | DBG_TRACE, ("update_arp_entry: no matching stable entry to update\n"));
  }
  return NULL;
  10b88a:	c7 45 cc 00 00 00 00 	movl   $0x0,0xffffffcc(%ebp)
  10b891:	8b 45 cc             	mov    0xffffffcc(%ebp),%eax
}
  10b894:	83 c4 44             	add    $0x44,%esp
  10b897:	5b                   	pop    %ebx
  10b898:	5d                   	pop    %ebp
  10b899:	c3                   	ret    
  10b89a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

0010b8a0 <etharp_ip_input>:

/**
 * Updates the ARP table using the given IP packet.
 *
 * Uses the incoming IP packet's source address to update the
 * ARP cache for the local network. The function does not alter
 * or free the packet. This function must be called before the
 * packet p is passed to the IP layer.
 *
 * @param netif The lwIP network interface on which the IP packet pbuf arrived.
 * @param pbuf The IP packet that arrived on netif.
 *
 * @return NULL
 *
 * @see pbuf_free()
 */
struct pbuf *
etharp_ip_input(struct netif *netif, struct pbuf *p)
{
  10b8a0:	55                   	push   %ebp
  10b8a1:	89 e5                	mov    %esp,%ebp
  10b8a3:	83 ec 28             	sub    $0x28,%esp
  struct ethip_hdr *hdr;

  /* Only insert an entry if the source IP address of the
     incoming IP packet comes from a host on the local network. */
  hdr = p->payload;
  10b8a6:	8b 45 0c             	mov    0xc(%ebp),%eax
  10b8a9:	8b 40 04             	mov    0x4(%eax),%eax
  10b8ac:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  /* source is on local network? */
  if (!ip_addr_maskcmp(&(hdr->ip.src), &(netif->ip_addr), &(netif->netmask))) {
  10b8af:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10b8b2:	8b 50 1a             	mov    0x1a(%eax),%edx
  10b8b5:	8b 45 08             	mov    0x8(%ebp),%eax
  10b8b8:	8b 40 08             	mov    0x8(%eax),%eax
  10b8bb:	89 d1                	mov    %edx,%ecx
  10b8bd:	21 c1                	and    %eax,%ecx
  10b8bf:	8b 45 08             	mov    0x8(%ebp),%eax
  10b8c2:	8b 50 04             	mov    0x4(%eax),%edx
  10b8c5:	8b 45 08             	mov    0x8(%ebp),%eax
  10b8c8:	8b 40 08             	mov    0x8(%eax),%eax
  10b8cb:	21 d0                	and    %edx,%eax
  10b8cd:	39 c1                	cmp    %eax,%ecx
  10b8cf:	74 09                	je     10b8da <etharp_ip_input+0x3a>
    /* do nothing */
    return NULL;
  10b8d1:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  10b8d8:	eb 2e                	jmp    10b908 <etharp_ip_input+0x68>
  }

  LWIP_DEBUGF(ETHARP_DEBUG | DBG_TRACE, ("etharp_ip_input: updating ETHARP table.\n"));
  /* update ARP table, ask to insert entry */
  update_arp_entry(netif, &(hdr->ip.src), &(hdr->eth.src), ARP_INSERT_FLAG);
  10b8da:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10b8dd:	83 c0 06             	add    $0x6,%eax
  10b8e0:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  10b8e3:	83 c2 1a             	add    $0x1a,%edx
  10b8e6:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
  10b8ed:	00 
  10b8ee:	89 44 24 08          	mov    %eax,0x8(%esp)
  10b8f2:	89 54 24 04          	mov    %edx,0x4(%esp)
  10b8f6:	8b 45 08             	mov    0x8(%ebp),%eax
  10b8f9:	89 04 24             	mov    %eax,(%esp)
  10b8fc:	e8 af fc ff ff       	call   10b5b0 <update_arp_entry>
  return NULL;
  10b901:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  10b908:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  10b90b:	c9                   	leave  
  10b90c:	c3                   	ret    
  10b90d:	8d 76 00             	lea    0x0(%esi),%esi

0010b910 <etharp_arp_input>:


/**
 * Responds to ARP requests to us. Upon ARP replies to us, add entry to cache  
 * send out queued IP packets. Updates cache with snooped address pairs.
 *
 * Should be called for incoming ARP packets. The pbuf in the argument
 * is freed by this function.
 *
 * @param netif The lwIP network interface on which the ARP packet pbuf arrived.
 * @param pbuf The ARP packet that arrived on netif. Is freed by this function.
 * @param ethaddr Ethernet address of netif.
 *
 * @return NULL
 *
 * @see pbuf_free()
 */
struct pbuf *
etharp_arp_input(struct netif *netif, struct eth_addr *ethaddr, struct pbuf *p)
{
  10b910:	55                   	push   %ebp
  10b911:	89 e5                	mov    %esp,%ebp
  10b913:	83 ec 38             	sub    $0x38,%esp
  struct etharp_hdr *hdr;
  u8_t i;
  u8_t for_us;

  /* drop short ARP packets */
  if (p->tot_len < sizeof(struct etharp_hdr)) {
  10b916:	8b 45 10             	mov    0x10(%ebp),%eax
  10b919:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  10b91d:	66 83 f8 29          	cmp    $0x29,%ax
  10b921:	77 17                	ja     10b93a <etharp_arp_input+0x2a>
    LWIP_DEBUGF(ETHARP_DEBUG | DBG_TRACE | 1, ("etharp_arp_input: packet dropped, too short (%d/%d)\n", p->tot_len, sizeof(struct etharp_hdr)));
    pbuf_free(p);
  10b923:	8b 45 10             	mov    0x10(%ebp),%eax
  10b926:	89 04 24             	mov    %eax,(%esp)
  10b929:	e8 92 3b 00 00       	call   10f4c0 <pbuf_free>
    return NULL;
  10b92e:	c7 45 e4 00 00 00 00 	movl   $0x0,0xffffffe4(%ebp)
  10b935:	e9 69 02 00 00       	jmp    10bba3 <etharp_arp_input+0x293>
  }

  hdr = p->payload;
  10b93a:	8b 45 10             	mov    0x10(%ebp),%eax
  10b93d:	8b 40 04             	mov    0x4(%eax),%eax
  10b940:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
 
  /* this interface is not configured? */
  if (netif->ip_addr.addr == 0) {
  10b943:	8b 45 08             	mov    0x8(%ebp),%eax
  10b946:	8b 40 04             	mov    0x4(%eax),%eax
  10b949:	85 c0                	test   %eax,%eax
  10b94b:	75 06                	jne    10b953 <etharp_arp_input+0x43>
    for_us = 0;
  10b94d:	c6 45 ff 00          	movb   $0x0,0xffffffff(%ebp)
  10b951:	eb 14                	jmp    10b967 <etharp_arp_input+0x57>
  } else {
    /* ARP packet directed to us? */
    for_us = ip_addr_cmp(&(hdr->dipaddr), &(netif->ip_addr));
  10b953:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10b956:	8b 50 26             	mov    0x26(%eax),%edx
  10b959:	8b 45 08             	mov    0x8(%ebp),%eax
  10b95c:	8b 40 04             	mov    0x4(%eax),%eax
  10b95f:	39 c2                	cmp    %eax,%edx
  10b961:	0f 94 c0             	sete   %al
  10b964:	88 45 ff             	mov    %al,0xffffffff(%ebp)
  }

  /* add or update entries in the ARP cache */
  if (for_us) {
  10b967:	80 7d ff 00          	cmpb   $0x0,0xffffffff(%ebp)
  10b96b:	74 29                	je     10b996 <etharp_arp_input+0x86>
    /* insert IP address in ARP cache (assume requester wants to talk to us)
     * we might even send out a queued packet to this host */
    update_arp_entry(netif, &(hdr->sipaddr), &(hdr->shwaddr), ARP_INSERT_FLAG);
  10b96d:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10b970:	83 c0 16             	add    $0x16,%eax
  10b973:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  10b976:	83 c2 1c             	add    $0x1c,%edx
  10b979:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
  10b980:	00 
  10b981:	89 44 24 08          	mov    %eax,0x8(%esp)
  10b985:	89 54 24 04          	mov    %edx,0x4(%esp)
  10b989:	8b 45 08             	mov    0x8(%ebp),%eax
  10b98c:	89 04 24             	mov    %eax,(%esp)
  10b98f:	e8 1c fc ff ff       	call   10b5b0 <update_arp_entry>
  10b994:	eb 27                	jmp    10b9bd <etharp_arp_input+0xad>
  /* request was not directed to us, but snoop anyway */
  } else {
    /* update the source IP address in the cache */
    update_arp_entry(netif, &(hdr->sipaddr), &(hdr->shwaddr), 0);
  10b996:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10b999:	83 c0 16             	add    $0x16,%eax
  10b99c:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  10b99f:	83 c2 1c             	add    $0x1c,%edx
  10b9a2:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  10b9a9:	00 
  10b9aa:	89 44 24 08          	mov    %eax,0x8(%esp)
  10b9ae:	89 54 24 04          	mov    %edx,0x4(%esp)
  10b9b2:	8b 45 08             	mov    0x8(%ebp),%eax
  10b9b5:	89 04 24             	mov    %eax,(%esp)
  10b9b8:	e8 f3 fb ff ff       	call   10b5b0 <update_arp_entry>
  }

  switch (htons(hdr->opcode)) {
  10b9bd:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10b9c0:	0f b7 40 14          	movzwl 0x14(%eax),%eax
  10b9c4:	0f b7 c0             	movzwl %ax,%eax
  10b9c7:	89 04 24             	mov    %eax,(%esp)
  10b9ca:	e8 b1 28 00 00       	call   10e280 <htons>
  10b9cf:	0f b7 c0             	movzwl %ax,%eax
  10b9d2:	83 f8 01             	cmp    $0x1,%eax
  10b9d5:	74 05                	je     10b9dc <etharp_arp_input+0xcc>
  10b9d7:	e9 ae 01 00 00       	jmp    10bb8a <etharp_arp_input+0x27a>
  /* ARP request? */
  case ARP_REQUEST:
    /* ARP request. If it asked for our address, we send out a
    reply. In any case, we time-stamp any existing ARP entry,
    and possiby send out an IP packet that was queued on it. */

    LWIP_DEBUGF (ETHARP_DEBUG | DBG_TRACE, ("etharp_arp_input: incoming ARP request\n"));
    /* we are not configured? */
    if (netif->ip_addr.addr == 0) {
  10b9dc:	8b 45 08             	mov    0x8(%ebp),%eax
  10b9df:	8b 40 04             	mov    0x4(%eax),%eax
  10b9e2:	85 c0                	test   %eax,%eax
  10b9e4:	75 17                	jne    10b9fd <etharp_arp_input+0xed>
      LWIP_DEBUGF(ETHARP_DEBUG | DBG_TRACE, ("etharp_arp_input: we are unconfigured, ARP request ignored.\n"));
      pbuf_free(p);
  10b9e6:	8b 45 10             	mov    0x10(%ebp),%eax
  10b9e9:	89 04 24             	mov    %eax,(%esp)
  10b9ec:	e8 cf 3a 00 00       	call   10f4c0 <pbuf_free>
      return NULL;
  10b9f1:	c7 45 e4 00 00 00 00 	movl   $0x0,0xffffffe4(%ebp)
  10b9f8:	e9 a6 01 00 00       	jmp    10bba3 <etharp_arp_input+0x293>
    }
    /* ARP request for our address? */
    if (for_us) {
  10b9fd:	80 7d ff 00          	cmpb   $0x0,0xffffffff(%ebp)
  10ba01:	0f 84 83 01 00 00    	je     10bb8a <etharp_arp_input+0x27a>

      LWIP_DEBUGF(ETHARP_DEBUG | DBG_TRACE, ("etharp_arp_input: replying to ARP request for our IP address\n"));
      /* re-use pbuf to send ARP reply */
      hdr->opcode = htons(ARP_REPLY);
  10ba07:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  10ba0e:	e8 6d 28 00 00       	call   10e280 <htons>
  10ba13:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  10ba16:	66 89 42 14          	mov    %ax,0x14(%edx)

      ip_addr_set(&(hdr->dipaddr), &(hdr->sipaddr));
  10ba1a:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10ba1d:	83 c0 1c             	add    $0x1c,%eax
  10ba20:	85 c0                	test   %eax,%eax
  10ba22:	74 0b                	je     10ba2f <etharp_arp_input+0x11f>
  10ba24:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10ba27:	8b 40 1c             	mov    0x1c(%eax),%eax
  10ba2a:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
  10ba2d:	eb 07                	jmp    10ba36 <etharp_arp_input+0x126>
  10ba2f:	c7 45 e8 00 00 00 00 	movl   $0x0,0xffffffe8(%ebp)
  10ba36:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10ba39:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
  10ba3c:	89 50 26             	mov    %edx,0x26(%eax)
      ip_addr_set(&(hdr->sipaddr), &(netif->ip_addr));
  10ba3f:	8b 45 08             	mov    0x8(%ebp),%eax
  10ba42:	83 c0 04             	add    $0x4,%eax
  10ba45:	85 c0                	test   %eax,%eax
  10ba47:	74 0b                	je     10ba54 <etharp_arp_input+0x144>
  10ba49:	8b 45 08             	mov    0x8(%ebp),%eax
  10ba4c:	8b 40 04             	mov    0x4(%eax),%eax
  10ba4f:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  10ba52:	eb 07                	jmp    10ba5b <etharp_arp_input+0x14b>
  10ba54:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  10ba5b:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10ba5e:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
  10ba61:	89 50 1c             	mov    %edx,0x1c(%eax)

      for(i = 0; i < netif->hwaddr_len; ++i) {
  10ba64:	c6 45 fe 00          	movb   $0x0,0xfffffffe(%ebp)
  10ba68:	eb 5d                	jmp    10bac7 <etharp_arp_input+0x1b7>
        hdr->dhwaddr.addr[i] = hdr->shwaddr.addr[i];
  10ba6a:	0f b6 4d fe          	movzbl 0xfffffffe(%ebp),%ecx
  10ba6e:	0f b6 55 fe          	movzbl 0xfffffffe(%ebp),%edx
  10ba72:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10ba75:	0f b6 54 02 16       	movzbl 0x16(%edx,%eax,1),%edx
  10ba7a:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10ba7d:	88 54 01 20          	mov    %dl,0x20(%ecx,%eax,1)
        hdr->shwaddr.addr[i] = ethaddr->addr[i];
  10ba81:	0f b6 4d fe          	movzbl 0xfffffffe(%ebp),%ecx
  10ba85:	0f b6 55 fe          	movzbl 0xfffffffe(%ebp),%edx
  10ba89:	8b 45 0c             	mov    0xc(%ebp),%eax
  10ba8c:	0f b6 14 10          	movzbl (%eax,%edx,1),%edx
  10ba90:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10ba93:	88 54 01 16          	mov    %dl,0x16(%ecx,%eax,1)
        hdr->ethhdr.dest.addr[i] = hdr->dhwaddr.addr[i];
  10ba97:	0f b6 4d fe          	movzbl 0xfffffffe(%ebp),%ecx
  10ba9b:	0f b6 55 fe          	movzbl 0xfffffffe(%ebp),%edx
  10ba9f:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10baa2:	0f b6 54 02 20       	movzbl 0x20(%edx,%eax,1),%edx
  10baa7:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10baaa:	88 14 08             	mov    %dl,(%eax,%ecx,1)
        hdr->ethhdr.src.addr[i] = ethaddr->addr[i];
  10baad:	0f b6 4d fe          	movzbl 0xfffffffe(%ebp),%ecx
  10bab1:	0f b6 55 fe          	movzbl 0xfffffffe(%ebp),%edx
  10bab5:	8b 45 0c             	mov    0xc(%ebp),%eax
  10bab8:	0f b6 14 10          	movzbl (%eax,%edx,1),%edx
  10babc:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10babf:	88 54 01 06          	mov    %dl,0x6(%ecx,%eax,1)
  10bac3:	80 45 fe 01          	addb   $0x1,0xfffffffe(%ebp)
  10bac7:	8b 45 08             	mov    0x8(%ebp),%eax
  10baca:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  10bace:	3a 45 fe             	cmp    0xfffffffe(%ebp),%al
  10bad1:	77 97                	ja     10ba6a <etharp_arp_input+0x15a>
      }

      hdr->hwtype = htons(HWTYPE_ETHERNET);
  10bad3:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  10bada:	e8 a1 27 00 00       	call   10e280 <htons>
  10badf:	89 c2                	mov    %eax,%edx
  10bae1:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10bae4:	66 89 50 0e          	mov    %dx,0xe(%eax)
      ARPH_HWLEN_SET(hdr, netif->hwaddr_len);
  10bae8:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10baeb:	0f b7 40 12          	movzwl 0x12(%eax),%eax
  10baef:	0f b7 c0             	movzwl %ax,%eax
  10baf2:	89 04 24             	mov    %eax,(%esp)
  10baf5:	e8 b6 27 00 00       	call   10e2b0 <ntohs>
  10bafa:	0f b6 d0             	movzbl %al,%edx
  10bafd:	8b 45 08             	mov    0x8(%ebp),%eax
  10bb00:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  10bb04:	0f b6 c0             	movzbl %al,%eax
  10bb07:	c1 e0 08             	shl    $0x8,%eax
  10bb0a:	09 d0                	or     %edx,%eax
  10bb0c:	0f b7 c0             	movzwl %ax,%eax
  10bb0f:	89 04 24             	mov    %eax,(%esp)
  10bb12:	e8 69 27 00 00       	call   10e280 <htons>
  10bb17:	89 c2                	mov    %eax,%edx
  10bb19:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10bb1c:	66 89 50 12          	mov    %dx,0x12(%eax)

      hdr->proto = htons(ETHTYPE_IP);
  10bb20:	c7 04 24 00 08 00 00 	movl   $0x800,(%esp)
  10bb27:	e8 54 27 00 00       	call   10e280 <htons>
  10bb2c:	89 c2                	mov    %eax,%edx
  10bb2e:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10bb31:	66 89 50 10          	mov    %dx,0x10(%eax)
      ARPH_PROTOLEN_SET(hdr, sizeof(struct ip_addr));
  10bb35:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10bb38:	0f b7 40 12          	movzwl 0x12(%eax),%eax
  10bb3c:	0f b7 c0             	movzwl %ax,%eax
  10bb3f:	89 04 24             	mov    %eax,(%esp)
  10bb42:	e8 69 27 00 00       	call   10e2b0 <ntohs>
  10bb47:	b0 00                	mov    $0x0,%al
  10bb49:	83 c8 04             	or     $0x4,%eax
  10bb4c:	0f b7 c0             	movzwl %ax,%eax
  10bb4f:	89 04 24             	mov    %eax,(%esp)
  10bb52:	e8 29 27 00 00       	call   10e280 <htons>
  10bb57:	89 c2                	mov    %eax,%edx
  10bb59:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10bb5c:	66 89 50 12          	mov    %dx,0x12(%eax)

      hdr->ethhdr.type = htons(ETHTYPE_ARP);
  10bb60:	c7 04 24 06 08 00 00 	movl   $0x806,(%esp)
  10bb67:	e8 14 27 00 00       	call   10e280 <htons>
  10bb6c:	89 c2                	mov    %eax,%edx
  10bb6e:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10bb71:	66 89 50 0c          	mov    %dx,0xc(%eax)
      /* return ARP reply */
      netif->linkoutput(netif, p);
  10bb75:	8b 45 08             	mov    0x8(%ebp),%eax
  10bb78:	8b 50 18             	mov    0x18(%eax),%edx
  10bb7b:	8b 45 10             	mov    0x10(%ebp),%eax
  10bb7e:	89 44 24 04          	mov    %eax,0x4(%esp)
  10bb82:	8b 45 08             	mov    0x8(%ebp),%eax
  10bb85:	89 04 24             	mov    %eax,(%esp)
  10bb88:	ff d2                	call   *%edx

    /* request was not directed to us */
    } else {
      LWIP_DEBUGF(ETHARP_DEBUG | DBG_TRACE, ("etharp_arp_input: incoming ARP request was not for us.\n"));
    }
    break;
  case ARP_REPLY:
    /* ARP reply. We insert or update the ARP table later. */
    LWIP_DEBUGF(ETHARP_DEBUG | DBG_TRACE, ("etharp_arp_input: incoming ARP reply\n"));
#if (LWIP_DHCP && DHCP_DOES_ARP_CHECK)
    /* DHCP wants to know about ARP replies to our wanna-have-address */
    if (for_us) dhcp_arp_reply(netif, &hdr->sipaddr);
#endif
    break;
  default:
    LWIP_DEBUGF(ETHARP_DEBUG | DBG_TRACE, ("etharp_arp_input: ARP unknown opcode type %d\n", htons(hdr->opcode)));
    break;
  }
  /* free ARP packet */
  pbuf_free(p);
  10bb8a:	8b 45 10             	mov    0x10(%ebp),%eax
  10bb8d:	89 04 24             	mov    %eax,(%esp)
  10bb90:	e8 2b 39 00 00       	call   10f4c0 <pbuf_free>
  p = NULL;
  10bb95:	c7 45 10 00 00 00 00 	movl   $0x0,0x10(%ebp)
  /* nothing to send, we did it! */
  return NULL;
  10bb9c:	c7 45 e4 00 00 00 00 	movl   $0x0,0xffffffe4(%ebp)
  10bba3:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
}
  10bba6:	c9                   	leave  
  10bba7:	c3                   	ret    
  10bba8:	90                   	nop    
  10bba9:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

0010bbb0 <etharp_output>:

/**
 * Resolve and fill-in Ethernet address header for outgoing packet.
 *
 * If ARP has the Ethernet address in cache, the given packet is
 * returned, ready to be sent.
 *
 * If ARP does not have the Ethernet address in cache the packet is
 * queued (if enabled and space available) and a ARP request is sent.
 * This ARP request is returned as a pbuf, which should be sent by
 * the caller.
 *
 * A returned non-NULL packet should be sent by the caller.
 *
 * If ARP failed to allocate resources, NULL is returned.
 *
 * @param netif The lwIP network interface which the IP packet will be sent on.
 * @param ipaddr The IP address of the packet destination.
 * @param pbuf The pbuf(s) containing the IP packet to be sent.
 *
 * @return If non-NULL, a packet ready to be sent by caller.
 *
 */
struct pbuf *
etharp_output(struct netif *netif, struct ip_addr *ipaddr, struct pbuf *q)
{
  10bbb0:	55                   	push   %ebp
  10bbb1:	89 e5                	mov    %esp,%ebp
  10bbb3:	53                   	push   %ebx
  10bbb4:	83 ec 34             	sub    $0x34,%esp
  struct eth_addr *dest, *srcaddr, mcastaddr;
  struct eth_hdr *ethhdr;
  s8_t i;

  /* make room for Ethernet header */
  if (pbuf_header(q, sizeof(struct eth_hdr)) != 0) {
  10bbb7:	c7 44 24 04 0e 00 00 	movl   $0xe,0x4(%esp)
  10bbbe:	00 
  10bbbf:	8b 45 10             	mov    0x10(%ebp),%eax
  10bbc2:	89 04 24             	mov    %eax,(%esp)
  10bbc5:	e8 f6 37 00 00       	call   10f3c0 <pbuf_header>
  10bbca:	84 c0                	test   %al,%al
  10bbcc:	74 1c                	je     10bbea <etharp_output+0x3a>
    /* The pbuf_header() call shouldn't fail, and we'll just bail
    out if it does.. */
    LWIP_DEBUGF(ETHARP_DEBUG | DBG_TRACE | 2, ("etharp_output: could not allocate room for header.\n"));
    LINK_STATS_INC(link.lenerr);
  10bbce:	0f b7 05 ec 14 14 00 	movzwl 0x1414ec,%eax
  10bbd5:	83 c0 01             	add    $0x1,%eax
  10bbd8:	66 a3 ec 14 14 00    	mov    %ax,0x1414ec
    return NULL;
  10bbde:	c7 45 d8 00 00 00 00 	movl   $0x0,0xffffffd8(%ebp)
  10bbe5:	e9 11 02 00 00       	jmp    10bdfb <etharp_output+0x24b>
  }

  /* assume unresolved Ethernet address */
  dest = NULL;
  10bbea:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  /* Construct Ethernet header. Start with looking up deciding which
     MAC address to use as a destination address. Broadcasts and
     multicasts are special, all other addresses are looked up in the
     ARP table. */

  /* destination IP address is an IP broadcast address? */
  if (ip_addr_isany(ipaddr) ||
  10bbf1:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  10bbf5:	74 37                	je     10bc2e <etharp_output+0x7e>
  10bbf7:	8b 45 0c             	mov    0xc(%ebp),%eax
  10bbfa:	8b 00                	mov    (%eax),%eax
  10bbfc:	85 c0                	test   %eax,%eax
  10bbfe:	74 2e                	je     10bc2e <etharp_output+0x7e>
  10bc00:	8b 45 0c             	mov    0xc(%ebp),%eax
  10bc03:	8b 10                	mov    (%eax),%edx
  10bc05:	8b 45 08             	mov    0x8(%ebp),%eax
  10bc08:	8b 40 08             	mov    0x8(%eax),%eax
  10bc0b:	f7 d0                	not    %eax
  10bc0d:	21 c2                	and    %eax,%edx
  10bc0f:	8b 45 08             	mov    0x8(%ebp),%eax
  10bc12:	8b 40 08             	mov    0x8(%eax),%eax
  10bc15:	f7 d0                	not    %eax
  10bc17:	39 c2                	cmp    %eax,%edx
  10bc19:	74 13                	je     10bc2e <etharp_output+0x7e>
  10bc1b:	8b 45 0c             	mov    0xc(%ebp),%eax
  10bc1e:	8b 00                	mov    (%eax),%eax
  10bc20:	83 f8 ff             	cmp    $0xffffffff,%eax
  10bc23:	74 09                	je     10bc2e <etharp_output+0x7e>
  10bc25:	8b 45 0c             	mov    0xc(%ebp),%eax
  10bc28:	8b 00                	mov    (%eax),%eax
  10bc2a:	85 c0                	test   %eax,%eax
  10bc2c:	75 0c                	jne    10bc3a <etharp_output+0x8a>
    ip_addr_isbroadcast(ipaddr, &(netif->netmask))) {
    /* broadcast on Ethernet also */
    dest = (struct eth_addr *)&ethbroadcast;
  10bc2e:	c7 45 ec 89 ad 11 00 	movl   $0x11ad89,0xffffffec(%ebp)
  10bc35:	e9 3e 01 00 00       	jmp    10bd78 <etharp_output+0x1c8>
  }
  /* destination IP address is an IP multicast address? */
  else if (ip_addr_ismulticast(ipaddr)) {
  10bc3a:	8b 45 0c             	mov    0xc(%ebp),%eax
  10bc3d:	8b 18                	mov    (%eax),%ebx
  10bc3f:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  10bc46:	e8 c5 26 00 00       	call   10e310 <ntohl>
  10bc4b:	21 c3                	and    %eax,%ebx
  10bc4d:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  10bc54:	e8 b7 26 00 00       	call   10e310 <ntohl>
  10bc59:	39 c3                	cmp    %eax,%ebx
  10bc5b:	75 50                	jne    10bcad <etharp_output+0xfd>
    /* Hash IP multicast address to MAC address. */
    mcastaddr.addr[0] = 0x01;
  10bc5d:	c6 45 e6 01          	movb   $0x1,0xffffffe6(%ebp)
    mcastaddr.addr[1] = 0x00;
  10bc61:	c6 45 e7 00          	movb   $0x0,0xffffffe7(%ebp)
    mcastaddr.addr[2] = 0x5e;
  10bc65:	c6 45 e8 5e          	movb   $0x5e,0xffffffe8(%ebp)
    mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
  10bc69:	8b 45 0c             	mov    0xc(%ebp),%eax
  10bc6c:	8b 00                	mov    (%eax),%eax
  10bc6e:	89 04 24             	mov    %eax,(%esp)
  10bc71:	e8 9a 26 00 00       	call   10e310 <ntohl>
  10bc76:	c1 e8 10             	shr    $0x10,%eax
  10bc79:	83 e0 7f             	and    $0x7f,%eax
  10bc7c:	88 45 e9             	mov    %al,0xffffffe9(%ebp)
    mcastaddr.addr[4] = ip4_addr3(ipaddr);
  10bc7f:	8b 45 0c             	mov    0xc(%ebp),%eax
  10bc82:	8b 00                	mov    (%eax),%eax
  10bc84:	89 04 24             	mov    %eax,(%esp)
  10bc87:	e8 84 26 00 00       	call   10e310 <ntohl>
  10bc8c:	c1 e8 08             	shr    $0x8,%eax
  10bc8f:	88 45 ea             	mov    %al,0xffffffea(%ebp)
    mcastaddr.addr[5] = ip4_addr4(ipaddr);
  10bc92:	8b 45 0c             	mov    0xc(%ebp),%eax
  10bc95:	8b 00                	mov    (%eax),%eax
  10bc97:	89 04 24             	mov    %eax,(%esp)
  10bc9a:	e8 71 26 00 00       	call   10e310 <ntohl>
  10bc9f:	88 45 eb             	mov    %al,0xffffffeb(%ebp)
    /* destination Ethernet address is multicast */
    dest = &mcastaddr;
  10bca2:	8d 45 e6             	lea    0xffffffe6(%ebp),%eax
  10bca5:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  10bca8:	e9 cb 00 00 00       	jmp    10bd78 <etharp_output+0x1c8>
  }
  /* destination IP address is an IP unicast address */
  else {
    /* destination IP network address not on local network?
     * IP layer wants us to forward to the default gateway */
    if (!ip_addr_maskcmp(ipaddr, &(netif->ip_addr), &(netif->netmask))) {
  10bcad:	8b 45 0c             	mov    0xc(%ebp),%eax
  10bcb0:	8b 10                	mov    (%eax),%edx
  10bcb2:	8b 45 08             	mov    0x8(%ebp),%eax
  10bcb5:	8b 40 08             	mov    0x8(%eax),%eax
  10bcb8:	89 d1                	mov    %edx,%ecx
  10bcba:	21 c1                	and    %eax,%ecx
  10bcbc:	8b 45 08             	mov    0x8(%ebp),%eax
  10bcbf:	8b 50 04             	mov    0x4(%eax),%edx
  10bcc2:	8b 45 08             	mov    0x8(%ebp),%eax
  10bcc5:	8b 40 08             	mov    0x8(%eax),%eax
  10bcc8:	21 d0                	and    %edx,%eax
  10bcca:	39 c1                	cmp    %eax,%ecx
  10bccc:	74 21                	je     10bcef <etharp_output+0x13f>
      /* interface has default gateway? */
      if (netif->gw.addr != 0)
  10bcce:	8b 45 08             	mov    0x8(%ebp),%eax
  10bcd1:	8b 40 0c             	mov    0xc(%eax),%eax
  10bcd4:	85 c0                	test   %eax,%eax
  10bcd6:	74 0b                	je     10bce3 <etharp_output+0x133>
      {
        /* route to default gateway IP address */
        ipaddr = &(netif->gw);
  10bcd8:	8b 45 08             	mov    0x8(%ebp),%eax
  10bcdb:	83 c0 0c             	add    $0xc,%eax
  10bcde:	89 45 0c             	mov    %eax,0xc(%ebp)
  10bce1:	eb 0c                	jmp    10bcef <etharp_output+0x13f>
      }
      /* no gateway available? */
      else
      {
        /* IP destination address outside local network, but no gateway available */
        /* { packet is discarded } */
        return NULL;
  10bce3:	c7 45 d8 00 00 00 00 	movl   $0x0,0xffffffd8(%ebp)
  10bcea:	e9 0c 01 00 00       	jmp    10bdfb <etharp_output+0x24b>
      }
    }

    /* Ethernet address for IP destination address is in ARP cache? */
    for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  10bcef:	c6 45 fb 00          	movb   $0x0,0xfffffffb(%ebp)
  10bcf3:	eb 52                	jmp    10bd47 <etharp_output+0x197>
      /* match found? */
      if (arp_table[i].state == ETHARP_STATE_STABLE &&
  10bcf5:	0f be 55 fb          	movsbl 0xfffffffb(%ebp),%edx
  10bcf9:	89 d0                	mov    %edx,%eax
  10bcfb:	01 c0                	add    %eax,%eax
  10bcfd:	01 d0                	add    %edx,%eax
  10bcff:	c1 e0 03             	shl    $0x3,%eax
  10bd02:	8b 80 cc da 11 00    	mov    0x11dacc(%eax),%eax
  10bd08:	83 f8 02             	cmp    $0x2,%eax
  10bd0b:	75 36                	jne    10bd43 <etharp_output+0x193>
  10bd0d:	8b 45 0c             	mov    0xc(%ebp),%eax
  10bd10:	8b 08                	mov    (%eax),%ecx
  10bd12:	0f be 55 fb          	movsbl 0xfffffffb(%ebp),%edx
  10bd16:	89 d0                	mov    %edx,%eax
  10bd18:	01 c0                	add    %eax,%eax
  10bd1a:	01 d0                	add    %edx,%eax
  10bd1c:	c1 e0 03             	shl    $0x3,%eax
  10bd1f:	8b 80 c0 da 11 00    	mov    0x11dac0(%eax),%eax
  10bd25:	39 c1                	cmp    %eax,%ecx
  10bd27:	75 1a                	jne    10bd43 <etharp_output+0x193>
        ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
        dest = &arp_table[i].ethaddr;
  10bd29:	0f be 55 fb          	movsbl 0xfffffffb(%ebp),%edx
  10bd2d:	89 d0                	mov    %edx,%eax
  10bd2f:	01 c0                	add    %eax,%eax
  10bd31:	01 d0                	add    %edx,%eax
  10bd33:	c1 e0 03             	shl    $0x3,%eax
  10bd36:	05 c0 da 11 00       	add    $0x11dac0,%eax
  10bd3b:	83 c0 04             	add    $0x4,%eax
  10bd3e:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
        break;
  10bd41:	eb 0a                	jmp    10bd4d <etharp_output+0x19d>
  10bd43:	80 45 fb 01          	addb   $0x1,0xfffffffb(%ebp)
  10bd47:	80 7d fb 09          	cmpb   $0x9,0xfffffffb(%ebp)
  10bd4b:	7e a8                	jle    10bcf5 <etharp_output+0x145>
      }
    }
    /* could not find the destination Ethernet address in ARP cache? */
    if (dest == NULL) {
  10bd4d:	83 7d ec 00          	cmpl   $0x0,0xffffffec(%ebp)
  10bd51:	75 25                	jne    10bd78 <etharp_output+0x1c8>
      /* ARP query for the IP address, submit this IP packet for queueing */
      /* TODO: How do we handle netif->ipaddr == ipaddr? */
      etharp_query(netif, ipaddr, q);
  10bd53:	8b 45 10             	mov    0x10(%ebp),%eax
  10bd56:	89 44 24 08          	mov    %eax,0x8(%esp)
  10bd5a:	8b 45 0c             	mov    0xc(%ebp),%eax
  10bd5d:	89 44 24 04          	mov    %eax,0x4(%esp)
  10bd61:	8b 45 08             	mov    0x8(%ebp),%eax
  10bd64:	89 04 24             	mov    %eax,(%esp)
  10bd67:	e8 a4 00 00 00       	call   10be10 <etharp_query>
      /* { packet was queued (ERR_OK), or discarded } */
      /* return nothing */
      return NULL;
  10bd6c:	c7 45 d8 00 00 00 00 	movl   $0x0,0xffffffd8(%ebp)
  10bd73:	e9 83 00 00 00       	jmp    10bdfb <etharp_output+0x24b>
    }
    /* destination Ethernet address resolved from ARP cache */
    else
    {
      /* fallthrough */
    }
  }

  /* destination Ethernet address known */
  if (dest != NULL) {
  10bd78:	83 7d ec 00          	cmpl   $0x0,0xffffffec(%ebp)
  10bd7c:	74 76                	je     10bdf4 <etharp_output+0x244>
    /* obtain source Ethernet address of the given interface */
    srcaddr = (struct eth_addr *)netif->hwaddr;
  10bd7e:	8b 45 08             	mov    0x8(%ebp),%eax
  10bd81:	83 c0 21             	add    $0x21,%eax
  10bd84:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)

    /* A valid IP->MAC address mapping was found, fill in the
     * Ethernet header for the outgoing packet */
    ethhdr = q->payload;
  10bd87:	8b 45 10             	mov    0x10(%ebp),%eax
  10bd8a:	8b 40 04             	mov    0x4(%eax),%eax
  10bd8d:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)

    for(i = 0; i < netif->hwaddr_len; i++) {
  10bd90:	c6 45 fb 00          	movb   $0x0,0xfffffffb(%ebp)
  10bd94:	eb 2f                	jmp    10bdc5 <etharp_output+0x215>
      ethhdr->dest.addr[i] = dest->addr[i];
  10bd96:	0f be 4d fb          	movsbl 0xfffffffb(%ebp),%ecx
  10bd9a:	0f be 55 fb          	movsbl 0xfffffffb(%ebp),%edx
  10bd9e:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10bda1:	0f b6 14 10          	movzbl (%eax,%edx,1),%edx
  10bda5:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10bda8:	88 14 08             	mov    %dl,(%eax,%ecx,1)
      ethhdr->src.addr[i] = srcaddr->addr[i];
  10bdab:	0f be 4d fb          	movsbl 0xfffffffb(%ebp),%ecx
  10bdaf:	0f be 55 fb          	movsbl 0xfffffffb(%ebp),%edx
  10bdb3:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10bdb6:	0f b6 14 10          	movzbl (%eax,%edx,1),%edx
  10bdba:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10bdbd:	88 54 01 06          	mov    %dl,0x6(%ecx,%eax,1)
  10bdc1:	80 45 fb 01          	addb   $0x1,0xfffffffb(%ebp)
  10bdc5:	0f be 55 fb          	movsbl 0xfffffffb(%ebp),%edx
  10bdc9:	8b 45 08             	mov    0x8(%ebp),%eax
  10bdcc:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  10bdd0:	0f b6 c0             	movzbl %al,%eax
  10bdd3:	39 c2                	cmp    %eax,%edx
  10bdd5:	7c bf                	jl     10bd96 <etharp_output+0x1e6>
    }

    ethhdr->type = htons(ETHTYPE_IP);
  10bdd7:	c7 04 24 00 08 00 00 	movl   $0x800,(%esp)
  10bdde:	e8 9d 24 00 00       	call   10e280 <htons>
  10bde3:	89 c2                	mov    %eax,%edx
  10bde5:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10bde8:	66 89 50 0c          	mov    %dx,0xc(%eax)
    /* return the outgoing packet */
    return q;
  10bdec:	8b 45 10             	mov    0x10(%ebp),%eax
  10bdef:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
  10bdf2:	eb 07                	jmp    10bdfb <etharp_output+0x24b>
  }
  /* never reached; here for safety */
  return NULL;
  10bdf4:	c7 45 d8 00 00 00 00 	movl   $0x0,0xffffffd8(%ebp)
  10bdfb:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
}
  10bdfe:	83 c4 34             	add    $0x34,%esp
  10be01:	5b                   	pop    %ebx
  10be02:	5d                   	pop    %ebp
  10be03:	c3                   	ret    
  10be04:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  10be0a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

0010be10 <etharp_query>:

/**
 * Send an ARP request for the given IP address.
 *
 * Sends an ARP request for the given IP address, unless
 * a request for this address is already pending. Optionally
 * queues an outgoing packet on the resulting ARP entry.
 *
 * @param netif The lwIP network interface where ipaddr
 * must be queried for.
 * @param ipaddr The IP address to be resolved.
 * @param q If non-NULL, a pbuf that must be queued on the
 * ARP entry for the ipaddr IP address.
 *
 * @return NULL.
 *
 * @note Might be used in the future by manual IP configuration
 * as well.
 *
 * TODO: use the ctime field to see how long ago an ARP request was sent,
 * possibly retry.
 */
err_t etharp_query(struct netif *netif, struct ip_addr *ipaddr, struct pbuf *q)
{
  10be10:	55                   	push   %ebp
  10be11:	89 e5                	mov    %esp,%ebp
  10be13:	83 ec 48             	sub    $0x48,%esp
  struct eth_addr *srcaddr;
  struct etharp_hdr *hdr;
  err_t result = ERR_OK;
  10be16:	c6 45 f5 00          	movb   $0x0,0xfffffff5(%ebp)
  s8_t i;
  u8_t perform_arp_request = 1;
  10be1a:	c6 45 f7 01          	movb   $0x1,0xfffffff7(%ebp)
  /* prevent 'unused argument' warning if ARP_QUEUEING == 0 */
  (void)q;
  srcaddr = (struct eth_addr *)netif->hwaddr;
  10be1e:	8b 45 08             	mov    0x8(%ebp),%eax
  10be21:	83 c0 21             	add    $0x21,%eax
  10be24:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  /* bail out if this IP address is pending */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  10be27:	c6 45 f6 00          	movb   $0x0,0xfffffff6(%ebp)
  10be2b:	eb 5e                	jmp    10be8b <etharp_query+0x7b>
    if (ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
  10be2d:	8b 45 0c             	mov    0xc(%ebp),%eax
  10be30:	8b 08                	mov    (%eax),%ecx
  10be32:	0f be 55 f6          	movsbl 0xfffffff6(%ebp),%edx
  10be36:	89 d0                	mov    %edx,%eax
  10be38:	01 c0                	add    %eax,%eax
  10be3a:	01 d0                	add    %edx,%eax
  10be3c:	c1 e0 03             	shl    $0x3,%eax
  10be3f:	8b 80 c0 da 11 00    	mov    0x11dac0(%eax),%eax
  10be45:	39 c1                	cmp    %eax,%ecx
  10be47:	75 3e                	jne    10be87 <etharp_query+0x77>
      if (arp_table[i].state == ETHARP_STATE_PENDING) {
  10be49:	0f be 55 f6          	movsbl 0xfffffff6(%ebp),%edx
  10be4d:	89 d0                	mov    %edx,%eax
  10be4f:	01 c0                	add    %eax,%eax
  10be51:	01 d0                	add    %edx,%eax
  10be53:	c1 e0 03             	shl    $0x3,%eax
  10be56:	8b 80 cc da 11 00    	mov    0x11dacc(%eax),%eax
  10be5c:	83 f8 01             	cmp    $0x1,%eax
  10be5f:	75 02                	jne    10be63 <etharp_query+0x53>
        LWIP_DEBUGF(ETHARP_DEBUG | DBG_TRACE | DBG_STATE, ("etharp_query: requested IP already pending as entry %u\n", i));
        /* break out of for-loop, user may wish to queue a packet on a pending entry */
        /* TODO: we will issue a new ARP request, which should not occur too often */
        /* we might want to run a faster timer on ARP to limit this */
        break;
  10be61:	eb 2e                	jmp    10be91 <etharp_query+0x81>
      }
      else if (arp_table[i].state == ETHARP_STATE_STABLE) {
  10be63:	0f be 55 f6          	movsbl 0xfffffff6(%ebp),%edx
  10be67:	89 d0                	mov    %edx,%eax
  10be69:	01 c0                	add    %eax,%eax
  10be6b:	01 d0                	add    %edx,%eax
  10be6d:	c1 e0 03             	shl    $0x3,%eax
  10be70:	8b 80 cc da 11 00    	mov    0x11dacc(%eax),%eax
  10be76:	83 f8 02             	cmp    $0x2,%eax
  10be79:	75 0c                	jne    10be87 <etharp_query+0x77>
        LWIP_DEBUGF(ETHARP_DEBUG | DBG_TRACE | DBG_STATE, ("etharp_query: requested IP already stable as entry %u\n", i));
        /* User wishes to queue a packet on a stable entry (or does she want to send
         * out the packet immediately, we will not know), so we force an ARP request.
         * Upon response we will send out the queued packet in etharp_update().
         * 
         * Alternatively, we could accept the stable entry, and just send out the packet
         * immediately. I chose to implement the former approach.
         */
        perform_arp_request = (q?1:0);
  10be7b:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  10be7f:	0f 95 c0             	setne  %al
  10be82:	88 45 f7             	mov    %al,0xfffffff7(%ebp)
        break;
  10be85:	eb 0a                	jmp    10be91 <etharp_query+0x81>
  10be87:	80 45 f6 01          	addb   $0x1,0xfffffff6(%ebp)
  10be8b:	80 7d f6 09          	cmpb   $0x9,0xfffffff6(%ebp)
  10be8f:	7e 9c                	jle    10be2d <etharp_query+0x1d>
      }
    }
  }
  /* queried address not yet in ARP table? */
  if (i == ARP_TABLE_SIZE) {
  10be91:	80 7d f6 0a          	cmpb   $0xa,0xfffffff6(%ebp)
  10be95:	75 67                	jne    10befe <etharp_query+0xee>
    LWIP_DEBUGF(ETHARP_DEBUG | DBG_TRACE, ("etharp_query: IP address not found in ARP table\n"));
    /* find an available (unused or old) entry */
    i = find_arp_entry();
  10be97:	e8 14 f5 ff ff       	call   10b3b0 <find_arp_entry>
  10be9c:	88 45 f6             	mov    %al,0xfffffff6(%ebp)
    /* bail out if no ARP entries are available */
    if (i == ERR_MEM) {
  10be9f:	80 7d f6 ff          	cmpb   $0xff,0xfffffff6(%ebp)
  10bea3:	75 0c                	jne    10beb1 <etharp_query+0xa1>
      LWIP_DEBUGF(ETHARP_DEBUG | 2, ("etharp_query: no more ARP entries available. Should seldom occur.\n"));
      return ERR_MEM;
  10bea5:	c7 45 cc ff ff ff ff 	movl   $0xffffffff,0xffffffcc(%ebp)
  10beac:	e9 3e 02 00 00       	jmp    10c0ef <etharp_query+0x2df>
    }
    /* i is available, create ARP entry */
    arp_table[i].state = ETHARP_STATE_PENDING;
  10beb1:	0f be 45 f6          	movsbl 0xfffffff6(%ebp),%eax
  10beb5:	89 c2                	mov    %eax,%edx
  10beb7:	01 d2                	add    %edx,%edx
  10beb9:	01 c2                	add    %eax,%edx
  10bebb:	8d 04 d5 00 00 00 00 	lea    0x0(,%edx,8),%eax
  10bec2:	c7 80 cc da 11 00 01 	movl   $0x1,0x11dacc(%eax)
  10bec9:	00 00 00 
    ip_addr_set(&arp_table[i].ipaddr, ipaddr);
  10becc:	0f be 45 f6          	movsbl 0xfffffff6(%ebp),%eax
  10bed0:	89 45 d0             	mov    %eax,0xffffffd0(%ebp)
  10bed3:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  10bed7:	74 0a                	je     10bee3 <etharp_query+0xd3>
  10bed9:	8b 45 0c             	mov    0xc(%ebp),%eax
  10bedc:	8b 00                	mov    (%eax),%eax
  10bede:	89 45 d4             	mov    %eax,0xffffffd4(%ebp)
  10bee1:	eb 07                	jmp    10beea <etharp_query+0xda>
  10bee3:	c7 45 d4 00 00 00 00 	movl   $0x0,0xffffffd4(%ebp)
  10beea:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
  10beed:	01 c0                	add    %eax,%eax
  10beef:	03 45 d0             	add    0xffffffd0(%ebp),%eax
  10bef2:	c1 e0 03             	shl    $0x3,%eax
  10bef5:	8b 55 d4             	mov    0xffffffd4(%ebp),%edx
  10bef8:	89 90 c0 da 11 00    	mov    %edx,0x11dac0(%eax)
  }
  /* { i is now valid } */
#if ARP_QUEUEING /* queue packet (even on a stable entry, see above) */
  etharp_enqueue(i, q);
  10befe:	0f be 55 f6          	movsbl 0xfffffff6(%ebp),%edx
  10bf02:	8b 45 10             	mov    0x10(%ebp),%eax
  10bf05:	89 44 24 04          	mov    %eax,0x4(%esp)
  10bf09:	89 14 24             	mov    %edx,(%esp)
  10bf0c:	e8 af f5 ff ff       	call   10b4c0 <etharp_enqueue>
#endif
  /* ARP request? */
  if (perform_arp_request)
  10bf11:	80 7d f7 00          	cmpb   $0x0,0xfffffff7(%ebp)
  10bf15:	0f 84 cd 01 00 00    	je     10c0e8 <etharp_query+0x2d8>
  {
    struct pbuf *p;
    /* allocate a pbuf for the outgoing ARP request packet */
    p = pbuf_alloc(PBUF_LINK, sizeof(struct etharp_hdr), PBUF_RAM);
  10bf1b:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  10bf22:	00 
  10bf23:	c7 44 24 04 2a 00 00 	movl   $0x2a,0x4(%esp)
  10bf2a:	00 
  10bf2b:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  10bf32:	e8 a9 30 00 00       	call   10efe0 <pbuf_alloc>
  10bf37:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
    /* could allocate pbuf? */
    if (p != NULL) {
  10bf3a:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  10bf3e:	0f 84 a0 01 00 00    	je     10c0e4 <etharp_query+0x2d4>
      u8_t j;
      LWIP_DEBUGF(ETHARP_DEBUG | DBG_TRACE, ("etharp_query: sending ARP request.\n"));
      hdr = p->payload;
  10bf44:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10bf47:	8b 40 04             	mov    0x4(%eax),%eax
  10bf4a:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
      hdr->opcode = htons(ARP_REQUEST);
  10bf4d:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  10bf54:	e8 27 23 00 00       	call   10e280 <htons>
  10bf59:	89 c2                	mov    %eax,%edx
  10bf5b:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10bf5e:	66 89 50 14          	mov    %dx,0x14(%eax)
      for (j = 0; j < netif->hwaddr_len; ++j)
  10bf62:	c6 45 ff 00          	movb   $0x0,0xffffffff(%ebp)
  10bf66:	eb 26                	jmp    10bf8e <etharp_query+0x17e>
      {
        hdr->shwaddr.addr[j] = srcaddr->addr[j];
  10bf68:	0f b6 4d ff          	movzbl 0xffffffff(%ebp),%ecx
  10bf6c:	0f b6 55 ff          	movzbl 0xffffffff(%ebp),%edx
  10bf70:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10bf73:	0f b6 14 10          	movzbl (%eax,%edx,1),%edx
  10bf77:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10bf7a:	88 54 01 16          	mov    %dl,0x16(%ecx,%eax,1)
        /* the hardware address is what we ask for, in
         * a request it is a don't-care, we use 0's */
        hdr->dhwaddr.addr[j] = 0x00;
  10bf7e:	0f b6 55 ff          	movzbl 0xffffffff(%ebp),%edx
  10bf82:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10bf85:	c6 44 02 20 00       	movb   $0x0,0x20(%edx,%eax,1)
  10bf8a:	80 45 ff 01          	addb   $0x1,0xffffffff(%ebp)
  10bf8e:	8b 45 08             	mov    0x8(%ebp),%eax
  10bf91:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  10bf95:	3a 45 ff             	cmp    0xffffffff(%ebp),%al
  10bf98:	77 ce                	ja     10bf68 <etharp_query+0x158>
      }
      ip_addr_set(&(hdr->dipaddr), ipaddr);
  10bf9a:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  10bf9e:	74 0a                	je     10bfaa <etharp_query+0x19a>
  10bfa0:	8b 45 0c             	mov    0xc(%ebp),%eax
  10bfa3:	8b 00                	mov    (%eax),%eax
  10bfa5:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
  10bfa8:	eb 07                	jmp    10bfb1 <etharp_query+0x1a1>
  10bfaa:	c7 45 d8 00 00 00 00 	movl   $0x0,0xffffffd8(%ebp)
  10bfb1:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10bfb4:	8b 55 d8             	mov    0xffffffd8(%ebp),%edx
  10bfb7:	89 50 26             	mov    %edx,0x26(%eax)
      ip_addr_set(&(hdr->sipaddr), &(netif->ip_addr));
  10bfba:	8b 45 08             	mov    0x8(%ebp),%eax
  10bfbd:	83 c0 04             	add    $0x4,%eax
  10bfc0:	85 c0                	test   %eax,%eax
  10bfc2:	74 0b                	je     10bfcf <etharp_query+0x1bf>
  10bfc4:	8b 45 08             	mov    0x8(%ebp),%eax
  10bfc7:	8b 40 04             	mov    0x4(%eax),%eax
  10bfca:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
  10bfcd:	eb 07                	jmp    10bfd6 <etharp_query+0x1c6>
  10bfcf:	c7 45 dc 00 00 00 00 	movl   $0x0,0xffffffdc(%ebp)
  10bfd6:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10bfd9:	8b 55 dc             	mov    0xffffffdc(%ebp),%edx
  10bfdc:	89 50 1c             	mov    %edx,0x1c(%eax)

      hdr->hwtype = htons(HWTYPE_ETHERNET);
  10bfdf:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  10bfe6:	e8 95 22 00 00       	call   10e280 <htons>
  10bfeb:	89 c2                	mov    %eax,%edx
  10bfed:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10bff0:	66 89 50 0e          	mov    %dx,0xe(%eax)
      ARPH_HWLEN_SET(hdr, netif->hwaddr_len);
  10bff4:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10bff7:	0f b7 40 12          	movzwl 0x12(%eax),%eax
  10bffb:	0f b7 c0             	movzwl %ax,%eax
  10bffe:	89 04 24             	mov    %eax,(%esp)
  10c001:	e8 aa 22 00 00       	call   10e2b0 <ntohs>
  10c006:	0f b6 d0             	movzbl %al,%edx
  10c009:	8b 45 08             	mov    0x8(%ebp),%eax
  10c00c:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  10c010:	0f b6 c0             	movzbl %al,%eax
  10c013:	c1 e0 08             	shl    $0x8,%eax
  10c016:	09 d0                	or     %edx,%eax
  10c018:	0f b7 c0             	movzwl %ax,%eax
  10c01b:	89 04 24             	mov    %eax,(%esp)
  10c01e:	e8 5d 22 00 00       	call   10e280 <htons>
  10c023:	89 c2                	mov    %eax,%edx
  10c025:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10c028:	66 89 50 12          	mov    %dx,0x12(%eax)

      hdr->proto = htons(ETHTYPE_IP);
  10c02c:	c7 04 24 00 08 00 00 	movl   $0x800,(%esp)
  10c033:	e8 48 22 00 00       	call   10e280 <htons>
  10c038:	89 c2                	mov    %eax,%edx
  10c03a:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10c03d:	66 89 50 10          	mov    %dx,0x10(%eax)
      ARPH_PROTOLEN_SET(hdr, sizeof(struct ip_addr));
  10c041:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10c044:	0f b7 40 12          	movzwl 0x12(%eax),%eax
  10c048:	0f b7 c0             	movzwl %ax,%eax
  10c04b:	89 04 24             	mov    %eax,(%esp)
  10c04e:	e8 5d 22 00 00       	call   10e2b0 <ntohs>
  10c053:	b0 00                	mov    $0x0,%al
  10c055:	83 c8 04             	or     $0x4,%eax
  10c058:	0f b7 c0             	movzwl %ax,%eax
  10c05b:	89 04 24             	mov    %eax,(%esp)
  10c05e:	e8 1d 22 00 00       	call   10e280 <htons>
  10c063:	89 c2                	mov    %eax,%edx
  10c065:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10c068:	66 89 50 12          	mov    %dx,0x12(%eax)
      for (j = 0; j < netif->hwaddr_len; ++j)
  10c06c:	c6 45 ff 00          	movb   $0x0,0xffffffff(%ebp)
  10c070:	eb 25                	jmp    10c097 <etharp_query+0x287>
      {
        hdr->ethhdr.dest.addr[j] = 0xff;
  10c072:	0f b6 55 ff          	movzbl 0xffffffff(%ebp),%edx
  10c076:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10c079:	c6 04 10 ff          	movb   $0xff,(%eax,%edx,1)
        hdr->ethhdr.src.addr[j] = srcaddr->addr[j];
  10c07d:	0f b6 4d ff          	movzbl 0xffffffff(%ebp),%ecx
  10c081:	0f b6 55 ff          	movzbl 0xffffffff(%ebp),%edx
  10c085:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10c088:	0f b6 14 10          	movzbl (%eax,%edx,1),%edx
  10c08c:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10c08f:	88 54 01 06          	mov    %dl,0x6(%ecx,%eax,1)
  10c093:	80 45 ff 01          	addb   $0x1,0xffffffff(%ebp)
  10c097:	8b 45 08             	mov    0x8(%ebp),%eax
  10c09a:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  10c09e:	3a 45 ff             	cmp    0xffffffff(%ebp),%al
  10c0a1:	77 cf                	ja     10c072 <etharp_query+0x262>
      }
      hdr->ethhdr.type = htons(ETHTYPE_ARP);
  10c0a3:	c7 04 24 06 08 00 00 	movl   $0x806,(%esp)
  10c0aa:	e8 d1 21 00 00       	call   10e280 <htons>
  10c0af:	89 c2                	mov    %eax,%edx
  10c0b1:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10c0b4:	66 89 50 0c          	mov    %dx,0xc(%eax)
      /* send ARP query */
      result = netif->linkoutput(netif, p);
  10c0b8:	8b 45 08             	mov    0x8(%ebp),%eax
  10c0bb:	8b 50 18             	mov    0x18(%eax),%edx
  10c0be:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10c0c1:	89 44 24 04          	mov    %eax,0x4(%esp)
  10c0c5:	8b 45 08             	mov    0x8(%ebp),%eax
  10c0c8:	89 04 24             	mov    %eax,(%esp)
  10c0cb:	ff d2                	call   *%edx
  10c0cd:	88 45 f5             	mov    %al,0xfffffff5(%ebp)
      /* free ARP query packet */
      pbuf_free(p);
  10c0d0:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10c0d3:	89 04 24             	mov    %eax,(%esp)
  10c0d6:	e8 e5 33 00 00       	call   10f4c0 <pbuf_free>
      p = NULL;
  10c0db:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)
  10c0e2:	eb 04                	jmp    10c0e8 <etharp_query+0x2d8>
    } else {
      result = ERR_MEM;
  10c0e4:	c6 45 f5 ff          	movb   $0xff,0xfffffff5(%ebp)
      LWIP_DEBUGF(ETHARP_DEBUG | DBG_TRACE | 2, ("etharp_query: could not allocate pbuf for ARP request.\n"));
    }
  }
  return result;
  10c0e8:	0f be 45 f5          	movsbl 0xfffffff5(%ebp),%eax
  10c0ec:	89 45 cc             	mov    %eax,0xffffffcc(%ebp)
  10c0ef:	8b 45 cc             	mov    0xffffffcc(%ebp),%eax
}
  10c0f2:	c9                   	leave  
  10c0f3:	c3                   	ret    
  10c0f4:	90                   	nop    
  10c0f5:	90                   	nop    
  10c0f6:	90                   	nop    
  10c0f7:	90                   	nop    
  10c0f8:	90                   	nop    
  10c0f9:	90                   	nop    
  10c0fa:	90                   	nop    
  10c0fb:	90                   	nop    
  10c0fc:	90                   	nop    
  10c0fd:	90                   	nop    
  10c0fe:	90                   	nop    
  10c0ff:	90                   	nop    

0010c100 <low_level_init>:


static void
low_level_init(struct netif *netif)
{
  10c100:	55                   	push   %ebp
  10c101:	89 e5                	mov    %esp,%ebp
  10c103:	83 ec 10             	sub    $0x10,%esp
  struct ethernetif *ethernetif;

  ethernetif = netif->state;
  10c106:	8b 45 08             	mov    0x8(%ebp),%eax
  10c109:	8b 40 1c             	mov    0x1c(%eax),%eax
  10c10c:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  
  /* set MAC hardware address length */
//  netif->hwaddr_len = 6;

  /* set MAC hardware address */
//  char ethaddr[6];

/*  netif->hwaddr[0] = 0x52;
  netif->hwaddr[1] = 0x54;
  netif->hwaddr[2] = 0x00;
  netif->hwaddr[3] = 0x12;
  netif->hwaddr[4] = 0x34;
  netif->hwaddr[5] = 0x56;*/

  /* maximum transfer unit */
  netif->mtu = 1500;
  10c10f:	8b 45 08             	mov    0x8(%ebp),%eax
  10c112:	66 c7 40 28 dc 05    	movw   $0x5dc,0x28(%eax)
  
  /* broadcast capability */
  netif->flags = NETIF_FLAG_BROADCAST;
  10c118:	8b 45 08             	mov    0x8(%ebp),%eax
  10c11b:	c6 40 2d 02          	movb   $0x2,0x2d(%eax)
 
  /* Do whatever else is needed to initialize interface. */  
}
  10c11f:	c9                   	leave  
  10c120:	c3                   	ret    
  10c121:	eb 0d                	jmp    10c130 <low_level_output>
  10c123:	90                   	nop    
  10c124:	90                   	nop    
  10c125:	90                   	nop    
  10c126:	90                   	nop    
  10c127:	90                   	nop    
  10c128:	90                   	nop    
  10c129:	90                   	nop    
  10c12a:	90                   	nop    
  10c12b:	90                   	nop    
  10c12c:	90                   	nop    
  10c12d:	90                   	nop    
  10c12e:	90                   	nop    
  10c12f:	90                   	nop    

0010c130 <low_level_output>:

/*
 * low_level_output():
 *
 * Should do the actual transmission of the packet. The packet is
 * contained in the pbuf that is passed to the function. This pbuf
 * might be chained.
 *
 */

static err_t
low_level_output(struct ethernetif *ethernetif, struct pbuf *p)
{
  10c130:	55                   	push   %ebp
  10c131:	89 e5                	mov    %esp,%ebp
  10c133:	53                   	push   %ebx
  10c134:	81 ec 64 06 00 00    	sub    $0x664,%esp
  struct pbuf *q;
  int totlen = 0;
  10c13a:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)
  unsigned char data[1600];
//  initiate transfer();
  
  if (!ethernetif->send)
  10c141:	8b 45 08             	mov    0x8(%ebp),%eax
  10c144:	8b 40 04             	mov    0x4(%eax),%eax
  10c147:	85 c0                	test   %eax,%eax
  10c149:	75 0f                	jne    10c15a <low_level_output+0x2a>
      return -2;
  10c14b:	c7 85 a8 f9 ff ff fe 	movl   $0xfffffffe,0xfffff9a8(%ebp)
  10c152:	ff ff ff 
  10c155:	e9 82 00 00 00       	jmp    10c1dc <low_level_output+0xac>
  for(q = p; q != NULL; q = q->next) {
  10c15a:	8b 45 0c             	mov    0xc(%ebp),%eax
  10c15d:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  10c160:	eb 42                	jmp    10c1a4 <low_level_output+0x74>
    /* Send the data from the pbuf to the interface, one pbuf at a
       time. The size of the data in each pbuf is kept in the ->len
       variable. */
//    send data from(q->payload, q->len);
    memcpy(data + totlen, q->payload, q->len);
  10c162:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10c165:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  10c169:	0f b7 c8             	movzwl %ax,%ecx
  10c16c:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10c16f:	8b 58 04             	mov    0x4(%eax),%ebx
  10c172:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10c175:	89 c2                	mov    %eax,%edx
  10c177:	8d 85 b4 f9 ff ff    	lea    0xfffff9b4(%ebp),%eax
  10c17d:	01 d0                	add    %edx,%eax
  10c17f:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  10c183:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  10c187:	89 04 24             	mov    %eax,(%esp)
  10c18a:	e8 01 9d ff ff       	call   105e90 <memcpy>
    totlen += q->len;
  10c18f:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10c192:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  10c196:	0f b7 c0             	movzwl %ax,%eax
  10c199:	01 45 f8             	add    %eax,0xfffffff8(%ebp)
  10c19c:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10c19f:	8b 00                	mov    (%eax),%eax
  10c1a1:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  10c1a4:	83 7d f4 00          	cmpl   $0x0,0xfffffff4(%ebp)
  10c1a8:	75 b8                	jne    10c162 <low_level_output+0x32>
  }

  ethernetif->send(data, totlen);
  10c1aa:	8b 45 08             	mov    0x8(%ebp),%eax
  10c1ad:	8b 50 04             	mov    0x4(%eax),%edx
  10c1b0:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10c1b3:	89 44 24 04          	mov    %eax,0x4(%esp)
  10c1b7:	8d 85 b4 f9 ff ff    	lea    0xfffff9b4(%ebp),%eax
  10c1bd:	89 04 24             	mov    %eax,(%esp)
  10c1c0:	ff d2                	call   *%edx
//  signal that packet should be sent();
  
#ifdef LINK_STATS
  lwip_stats.link.xmit++;
  10c1c2:	0f b7 05 e0 14 14 00 	movzwl 0x1414e0,%eax
  10c1c9:	83 c0 01             	add    $0x1,%eax
  10c1cc:	66 a3 e0 14 14 00    	mov    %ax,0x1414e0
#endif /* LINK_STATS */      

  return ERR_OK;
  10c1d2:	c7 85 a8 f9 ff ff 00 	movl   $0x0,0xfffff9a8(%ebp)
  10c1d9:	00 00 00 
  10c1dc:	8b 85 a8 f9 ff ff    	mov    0xfffff9a8(%ebp),%eax
}
  10c1e2:	81 c4 64 06 00 00    	add    $0x664,%esp
  10c1e8:	5b                   	pop    %ebx
  10c1e9:	5d                   	pop    %ebp
  10c1ea:	c3                   	ret    
  10c1eb:	90                   	nop    
  10c1ec:	8d 74 26 00          	lea    0x0(%esi),%esi

0010c1f0 <low_level_output_wrap>:

static err_t
low_level_output_wrap(struct netif *netif, struct pbuf *p)
{
  10c1f0:	55                   	push   %ebp
  10c1f1:	89 e5                	mov    %esp,%ebp
  10c1f3:	83 ec 08             	sub    $0x8,%esp
    return low_level_output(netif->state, p);
  10c1f6:	8b 45 08             	mov    0x8(%ebp),%eax
  10c1f9:	8b 40 1c             	mov    0x1c(%eax),%eax
  10c1fc:	89 c2                	mov    %eax,%edx
  10c1fe:	8b 45 0c             	mov    0xc(%ebp),%eax
  10c201:	89 44 24 04          	mov    %eax,0x4(%esp)
  10c205:	89 14 24             	mov    %edx,(%esp)
  10c208:	e8 23 ff ff ff       	call   10c130 <low_level_output>
  10c20d:	0f be c0             	movsbl %al,%eax
}
  10c210:	c9                   	leave  
  10c211:	c3                   	ret    
  10c212:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi
  10c219:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

0010c220 <low_level_input>:

/*
 * low_level_input():
 *
 * Should allocate a pbuf and transfer the bytes of the incoming
 * packet from the interface into the pbuf.
 *
 */

static struct pbuf *
low_level_input(struct ethernetif *ethernetif)
{
  10c220:	55                   	push   %ebp
  10c221:	89 e5                	mov    %esp,%ebp
  10c223:	53                   	push   %ebx
  10c224:	81 ec 64 06 00 00    	sub    $0x664,%esp
  struct pbuf *p, *q;
  u16_t len;
  unsigned char data[1600];
  u16_t curpos = 0;
  10c22a:	66 c7 45 f8 00 00    	movw   $0x0,0xfffffff8(%ebp)
  u16_t left;
//  int i;

//  cprintf("lwip :: low_level_input\n");
  /* Obtain the size of the packet and put it into the "len"
     variable. */
  len = ethernetif->receive(data, sizeof(data));
  10c230:	8b 45 08             	mov    0x8(%ebp),%eax
  10c233:	8b 50 08             	mov    0x8(%eax),%edx
  10c236:	c7 44 24 04 40 06 00 	movl   $0x640,0x4(%esp)
  10c23d:	00 
  10c23e:	8d 85 ac f9 ff ff    	lea    0xfffff9ac(%ebp),%eax
  10c244:	89 04 24             	mov    %eax,(%esp)
  10c247:	ff d2                	call   *%edx
  10c249:	66 89 45 f6          	mov    %ax,0xfffffff6(%ebp)
/*  cprintf(" read %d bytes\n", len);
  for (left = 0; left < len; left ++)
  {
      cprintf("%02x ", data[left]);
      if ((left + 1) % 16 == 0)
          cprintf("\n");
  }
  cprintf("\n");*/


  /* We allocate a pbuf chain of pbufs from the pool. */
  p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
  10c24d:	0f b7 45 f6          	movzwl 0xfffffff6(%ebp),%eax
  10c251:	c7 44 24 08 03 00 00 	movl   $0x3,0x8(%esp)
  10c258:	00 
  10c259:	89 44 24 04          	mov    %eax,0x4(%esp)
  10c25d:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  10c264:	e8 77 2d 00 00       	call   10efe0 <pbuf_alloc>
  10c269:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  
  if (p != NULL) {
  10c26c:	83 7d ec 00          	cmpl   $0x0,0xffffffec(%ebp)
  10c270:	0f 84 92 00 00 00    	je     10c308 <low_level_input+0xe8>
    /* We iterate over the pbuf chain until we have read the entire
       packet into the pbuf. */
    for(q = p; q != NULL; q = q->next) {
  10c276:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10c279:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
  10c27c:	eb 72                	jmp    10c2f0 <low_level_input+0xd0>
      /* Read enough bytes to fill this pbuf in the chain. The
         available data in the pbuf is given by the q->len
         variable. */
//      read data into(q->payload, q->len);
//        len = ether_receive(q->payload, q->len);
        if (q->len > len - curpos)
  10c27e:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10c281:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  10c285:	0f b7 c8             	movzwl %ax,%ecx
  10c288:	0f b7 55 f6          	movzwl 0xfffffff6(%ebp),%edx
  10c28c:	0f b7 45 f8          	movzwl 0xfffffff8(%ebp),%eax
  10c290:	89 d3                	mov    %edx,%ebx
  10c292:	29 c3                	sub    %eax,%ebx
  10c294:	89 d8                	mov    %ebx,%eax
  10c296:	39 c1                	cmp    %eax,%ecx
  10c298:	7e 15                	jle    10c2af <low_level_input+0x8f>
            left = len - curpos;
  10c29a:	0f b7 45 f8          	movzwl 0xfffffff8(%ebp),%eax
  10c29e:	0f b7 55 f6          	movzwl 0xfffffff6(%ebp),%edx
  10c2a2:	89 d1                	mov    %edx,%ecx
  10c2a4:	66 29 c1             	sub    %ax,%cx
  10c2a7:	89 c8                	mov    %ecx,%eax
  10c2a9:	66 89 45 fa          	mov    %ax,0xfffffffa(%ebp)
  10c2ad:	eb 0b                	jmp    10c2ba <low_level_input+0x9a>
        else
            left = q->len;
  10c2af:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10c2b2:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  10c2b6:	66 89 45 fa          	mov    %ax,0xfffffffa(%ebp)
        memcpy(q->payload, data + curpos, left);
  10c2ba:	0f b7 4d fa          	movzwl 0xfffffffa(%ebp),%ecx
  10c2be:	0f b7 45 f8          	movzwl 0xfffffff8(%ebp),%eax
  10c2c2:	8d 95 ac f9 ff ff    	lea    0xfffff9ac(%ebp),%edx
  10c2c8:	01 c2                	add    %eax,%edx
  10c2ca:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10c2cd:	8b 40 04             	mov    0x4(%eax),%eax
  10c2d0:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  10c2d4:	89 54 24 04          	mov    %edx,0x4(%esp)
  10c2d8:	89 04 24             	mov    %eax,(%esp)
  10c2db:	e8 b0 9b ff ff       	call   105e90 <memcpy>
        curpos += left;
  10c2e0:	0f b7 45 fa          	movzwl 0xfffffffa(%ebp),%eax
  10c2e4:	66 01 45 f8          	add    %ax,0xfffffff8(%ebp)
  10c2e8:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10c2eb:	8b 00                	mov    (%eax),%eax
  10c2ed:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
  10c2f0:	83 7d f0 00          	cmpl   $0x0,0xfffffff0(%ebp)
  10c2f4:	75 88                	jne    10c27e <low_level_input+0x5e>
    }
//    acknowledge that packet has been read();
#ifdef LINK_STATS
    lwip_stats.link.recv++;
  10c2f6:	0f b7 05 e4 14 14 00 	movzwl 0x1414e4,%eax
  10c2fd:	83 c0 01             	add    $0x1,%eax
  10c300:	66 a3 e4 14 14 00    	mov    %ax,0x1414e4
  10c306:	eb 2c                	jmp    10c334 <low_level_input+0x114>
#endif /* LINK_STATS */      
  } else {
//    drop packet();
#ifdef LINK_STATS
    lwip_stats.link.memerr++;
  10c308:	0f b7 05 ee 14 14 00 	movzwl 0x1414ee,%eax
  10c30f:	83 c0 01             	add    $0x1,%eax
  10c312:	66 a3 ee 14 14 00    	mov    %ax,0x1414ee
    lwip_stats.link.drop++;
  10c318:	0f b7 05 e8 14 14 00 	movzwl 0x1414e8,%eax
  10c31f:	83 c0 01             	add    $0x1,%eax
  10c322:	66 a3 e8 14 14 00    	mov    %ax,0x1414e8
    cprintf("low_level_input: no mem\n");
  10c328:	c7 04 24 a6 ad 11 00 	movl   $0x11ada6,(%esp)
  10c32f:	e8 dc 43 ff ff       	call   100710 <cprintf>
#endif /* LINK_STATS */      
  }

  return p;  
  10c334:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  10c337:	81 c4 64 06 00 00    	add    $0x664,%esp
  10c33d:	5b                   	pop    %ebx
  10c33e:	5d                   	pop    %ebp
  10c33f:	c3                   	ret    

0010c340 <ethernetif_output>:

/*
 * ethernetif_output():
 *
 * This function is called by the TCP/IP stack when an IP packet
 * should be sent. It calls the function called low_level_output() to
 * do the actual transmission of the packet.
 *
 */

static err_t
ethernetif_output(struct netif *netif, struct pbuf *p,
      struct ip_addr *ipaddr)
{
  10c340:	55                   	push   %ebp
  10c341:	89 e5                	mov    %esp,%ebp
  10c343:	83 ec 28             	sub    $0x28,%esp
  struct ethernetif *ethernetif;
//  struct pbuf *q;
//  struct eth_hdr *ethhdr;
//  struct eth_addr *dest, mcastaddr;
//  struct ip_addr *queryaddr;
//  err_t err;
//  u8_t i;
  
  ethernetif = netif->state;
  10c346:	8b 45 08             	mov    0x8(%ebp),%eax
  10c349:	8b 40 1c             	mov    0x1c(%eax),%eax
  10c34c:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)

  /* resolve the link destination hardware address */
  p = etharp_output(netif, ipaddr, p);
  10c34f:	8b 45 0c             	mov    0xc(%ebp),%eax
  10c352:	89 44 24 08          	mov    %eax,0x8(%esp)
  10c356:	8b 45 10             	mov    0x10(%ebp),%eax
  10c359:	89 44 24 04          	mov    %eax,0x4(%esp)
  10c35d:	8b 45 08             	mov    0x8(%ebp),%eax
  10c360:	89 04 24             	mov    %eax,(%esp)
  10c363:	e8 48 f8 ff ff       	call   10bbb0 <etharp_output>
  10c368:	89 45 0c             	mov    %eax,0xc(%ebp)
  
  /* network hardware address obtained? */
  if (p == NULL)
  10c36b:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  10c36f:	75 09                	jne    10c37a <ethernetif_output+0x3a>
  {
    /* we cannot tell if the packet was sent: the packet could */
    /* have been queued on an ARP entry that was already pending. */
  	return ERR_OK;
  10c371:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  10c378:	eb 18                	jmp    10c392 <ethernetif_output+0x52>
  }
  	
  /* send out the packet */
  return low_level_output(ethernetif, p);
  10c37a:	8b 45 0c             	mov    0xc(%ebp),%eax
  10c37d:	89 44 24 04          	mov    %eax,0x4(%esp)
  10c381:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10c384:	89 04 24             	mov    %eax,(%esp)
  10c387:	e8 a4 fd ff ff       	call   10c130 <low_level_output>
  10c38c:	0f be c0             	movsbl %al,%eax
  10c38f:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  10c392:	8b 45 ec             	mov    0xffffffec(%ebp),%eax

}
  10c395:	c9                   	leave  
  10c396:	c3                   	ret    
  10c397:	89 f6                	mov    %esi,%esi
  10c399:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

0010c3a0 <ethernetif_input>:

/*
 * ethernetif_input():
 *
 * This function should be called when a packet is ready to be read
 * from the interface. It uses the function low_level_input() that
 * should handle the actual reception of bytes from the network
 * interface.
 *
 */

void
ethernetif_input(struct netif *netif)
{
  10c3a0:	55                   	push   %ebp
  10c3a1:	89 e5                	mov    %esp,%ebp
  10c3a3:	83 ec 28             	sub    $0x28,%esp
  struct ethernetif *ethernetif;
  struct eth_hdr *ethhdr;
  struct pbuf *p, *q;

  ethernetif = netif->state;
  10c3a6:	8b 45 08             	mov    0x8(%ebp),%eax
  10c3a9:	8b 40 1c             	mov    0x1c(%eax),%eax
  10c3ac:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
  
  p = low_level_input(ethernetif);
  10c3af:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10c3b2:	89 04 24             	mov    %eax,(%esp)
  10c3b5:	e8 66 fe ff ff       	call   10c220 <low_level_input>
  10c3ba:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)

  if (p == NULL)
  10c3bd:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  10c3c1:	0f 84 e7 00 00 00    	je     10c4ae <ethernetif_input+0x10e>
    return;

#ifdef LINK_STATS
  lwip_stats.link.recv++;
  10c3c7:	0f b7 05 e4 14 14 00 	movzwl 0x1414e4,%eax
  10c3ce:	83 c0 01             	add    $0x1,%eax
  10c3d1:	66 a3 e4 14 14 00    	mov    %ax,0x1414e4
#endif /* LINK_STATS */

  ethhdr = p->payload;
  10c3d7:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10c3da:	8b 40 04             	mov    0x4(%eax),%eax
  10c3dd:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  q = NULL;
  10c3e0:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)

  switch (htons(ethhdr->type)) {
  10c3e7:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10c3ea:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  10c3ee:	0f b7 c0             	movzwl %ax,%eax
  10c3f1:	89 04 24             	mov    %eax,(%esp)
  10c3f4:	e8 87 1e 00 00       	call   10e280 <htons>
  10c3f9:	0f b7 c0             	movzwl %ax,%eax
  10c3fc:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  10c3ff:	81 7d ec 00 08 00 00 	cmpl   $0x800,0xffffffec(%ebp)
  10c406:	74 0b                	je     10c413 <ethernetif_input+0x73>
  10c408:	81 7d ec 06 08 00 00 	cmpl   $0x806,0xffffffec(%ebp)
  10c40f:	74 41                	je     10c452 <ethernetif_input+0xb2>
  10c411:	eb 5f                	jmp    10c472 <ethernetif_input+0xd2>
    case ETHTYPE_IP:
      q = etharp_ip_input(netif, p);
  10c413:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10c416:	89 44 24 04          	mov    %eax,0x4(%esp)
  10c41a:	8b 45 08             	mov    0x8(%ebp),%eax
  10c41d:	89 04 24             	mov    %eax,(%esp)
  10c420:	e8 7b f4 ff ff       	call   10b8a0 <etharp_ip_input>
  10c425:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
      pbuf_header(p, -14);
  10c428:	c7 44 24 04 f2 ff ff 	movl   $0xfffffff2,0x4(%esp)
  10c42f:	ff 
  10c430:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10c433:	89 04 24             	mov    %eax,(%esp)
  10c436:	e8 85 2f 00 00       	call   10f3c0 <pbuf_header>
      netif->input(p, netif);
  10c43b:	8b 45 08             	mov    0x8(%ebp),%eax
  10c43e:	8b 50 10             	mov    0x10(%eax),%edx
  10c441:	8b 45 08             	mov    0x8(%ebp),%eax
  10c444:	89 44 24 04          	mov    %eax,0x4(%esp)
  10c448:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10c44b:	89 04 24             	mov    %eax,(%esp)
  10c44e:	ff d2                	call   *%edx
      break;
  10c450:	eb 32                	jmp    10c484 <ethernetif_input+0xe4>
      
    case ETHTYPE_ARP:
      q = etharp_arp_input(netif, ethernetif->ethaddr, p);
  10c452:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10c455:	8b 10                	mov    (%eax),%edx
  10c457:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10c45a:	89 44 24 08          	mov    %eax,0x8(%esp)
  10c45e:	89 54 24 04          	mov    %edx,0x4(%esp)
  10c462:	8b 45 08             	mov    0x8(%ebp),%eax
  10c465:	89 04 24             	mov    %eax,(%esp)
  10c468:	e8 a3 f4 ff ff       	call   10b910 <etharp_arp_input>
  10c46d:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
      break;
  10c470:	eb 12                	jmp    10c484 <ethernetif_input+0xe4>
    default:
      pbuf_free(p);
  10c472:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10c475:	89 04 24             	mov    %eax,(%esp)
  10c478:	e8 43 30 00 00       	call   10f4c0 <pbuf_free>
      p = NULL;
  10c47d:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)
      break;
  }
  if (q != NULL) {
  10c484:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  10c488:	74 24                	je     10c4ae <ethernetif_input+0x10e>
    low_level_output(ethernetif, q);
  10c48a:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10c48d:	89 44 24 04          	mov    %eax,0x4(%esp)
  10c491:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10c494:	89 04 24             	mov    %eax,(%esp)
  10c497:	e8 94 fc ff ff       	call   10c130 <low_level_output>
    pbuf_free(q);
  10c49c:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10c49f:	89 04 24             	mov    %eax,(%esp)
  10c4a2:	e8 19 30 00 00       	call   10f4c0 <pbuf_free>
    q = NULL;
  10c4a7:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
  }
}
  10c4ae:	c9                   	leave  
  10c4af:	c3                   	ret    

0010c4b0 <arp_timer>:

static void
arp_timer(void *arg)
{
  10c4b0:	55                   	push   %ebp
  10c4b1:	89 e5                	mov    %esp,%ebp
  10c4b3:	83 ec 18             	sub    $0x18,%esp
  etharp_tmr();
  10c4b6:	e8 e5 ed ff ff       	call   10b2a0 <etharp_tmr>
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
  10c4bb:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  10c4c2:	00 
  10c4c3:	c7 44 24 04 b0 c4 10 	movl   $0x10c4b0,0x4(%esp)
  10c4ca:	00 
  10c4cb:	c7 04 24 10 27 00 00 	movl   $0x2710,(%esp)
  10c4d2:	e8 29 3a 00 00       	call   10ff00 <sys_timeout>
}
  10c4d7:	c9                   	leave  
  10c4d8:	c3                   	ret    
  10c4d9:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

0010c4e0 <ethernetif_init>:

/*
 * ethernetif_init():
 *
 * Should be called at the beginning of the program to set up the
 * network interface. It calls the function low_level_init() to do the
 * actual setup of the hardware.
 *
 */

err_t
ethernetif_init(struct netif *netif)
{
  10c4e0:	55                   	push   %ebp
  10c4e1:	89 e5                	mov    %esp,%ebp
  10c4e3:	83 ec 28             	sub    $0x28,%esp
  struct ethernetif *ethernetif;
    
  ethernetif = mem_malloc(sizeof(struct ethernetif));
  10c4e6:	c7 04 24 0c 00 00 00 	movl   $0xc,(%esp)
  10c4ed:	e8 de 21 00 00       	call   10e6d0 <mem_malloc>
  10c4f2:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  
  if (ethernetif == NULL)
  10c4f5:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  10c4f9:	75 09                	jne    10c504 <ethernetif_init+0x24>
  {
  	LWIP_DEBUGF(NETIF_DEBUG, ("ethernetif_init: out of memory\n"));
  	return ERR_MEM;
  10c4fb:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  10c502:	eb 6b                	jmp    10c56f <ethernetif_init+0x8f>
  }
  
  netif->state = ethernetif;
  10c504:	8b 55 08             	mov    0x8(%ebp),%edx
  10c507:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10c50a:	89 42 1c             	mov    %eax,0x1c(%edx)
  netif->name[0] = IFNAME0;
  10c50d:	8b 45 08             	mov    0x8(%ebp),%eax
  10c510:	c6 40 2a 65          	movb   $0x65,0x2a(%eax)
  netif->name[1] = IFNAME1;
  10c514:	8b 45 08             	mov    0x8(%ebp),%eax
  10c517:	c6 40 2b 6e          	movb   $0x6e,0x2b(%eax)
  netif->output = ethernetif_output;
  10c51b:	8b 45 08             	mov    0x8(%ebp),%eax
  10c51e:	c7 40 14 40 c3 10 00 	movl   $0x10c340,0x14(%eax)
  netif->linkoutput = low_level_output_wrap;
  10c525:	8b 45 08             	mov    0x8(%ebp),%eax
  10c528:	c7 40 18 f0 c1 10 00 	movl   $0x10c1f0,0x18(%eax)
  
  ethernetif->ethaddr = (struct eth_addr *)&(netif->hwaddr[0]);
  10c52f:	8b 45 08             	mov    0x8(%ebp),%eax
  10c532:	83 c0 21             	add    $0x21,%eax
  10c535:	89 c2                	mov    %eax,%edx
  10c537:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10c53a:	89 10                	mov    %edx,(%eax)
  
  low_level_init(netif);
  10c53c:	8b 45 08             	mov    0x8(%ebp),%eax
  10c53f:	89 04 24             	mov    %eax,(%esp)
  10c542:	e8 b9 fb ff ff       	call   10c100 <low_level_init>

  etharp_init();
  10c547:	e8 f4 ec ff ff       	call   10b240 <etharp_init>

  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
  10c54c:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  10c553:	00 
  10c554:	c7 44 24 04 b0 c4 10 	movl   $0x10c4b0,0x4(%esp)
  10c55b:	00 
  10c55c:	c7 04 24 10 27 00 00 	movl   $0x2710,(%esp)
  10c563:	e8 98 39 00 00       	call   10ff00 <sys_timeout>
  return 0;
  10c568:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  10c56f:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  10c572:	c9                   	leave  
  10c573:	c3                   	ret    
  10c574:	90                   	nop    
  10c575:	90                   	nop    
  10c576:	90                   	nop    
  10c577:	90                   	nop    
  10c578:	90                   	nop    
  10c579:	90                   	nop    
  10c57a:	90                   	nop    
  10c57b:	90                   	nop    
  10c57c:	90                   	nop    
  10c57d:	90                   	nop    
  10c57e:	90                   	nop    
  10c57f:	90                   	nop    

0010c580 <loopif_input>:
#include "lwip/ip.h"

static void
loopif_input( void * arg )
{
  10c580:	55                   	push   %ebp
  10c581:	89 e5                	mov    %esp,%ebp
  10c583:	83 ec 18             	sub    $0x18,%esp
	struct netif *netif = (struct netif *)( ((void **)arg)[ 0 ] );
  10c586:	8b 45 08             	mov    0x8(%ebp),%eax
  10c589:	8b 00                	mov    (%eax),%eax
  10c58b:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
	struct pbuf *r = (struct pbuf *)( ((void **)arg)[ 1 ] );
  10c58e:	8b 45 08             	mov    0x8(%ebp),%eax
  10c591:	83 c0 04             	add    $0x4,%eax
  10c594:	8b 00                	mov    (%eax),%eax
  10c596:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)

	mem_free( arg );
  10c599:	8b 45 08             	mov    0x8(%ebp),%eax
  10c59c:	89 04 24             	mov    %eax,(%esp)
  10c59f:	e8 fc 1e 00 00       	call   10e4a0 <mem_free>
	netif -> input( r, netif );
  10c5a4:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10c5a7:	8b 50 10             	mov    0x10(%eax),%edx
  10c5aa:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10c5ad:	89 44 24 04          	mov    %eax,0x4(%esp)
  10c5b1:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10c5b4:	89 04 24             	mov    %eax,(%esp)
  10c5b7:	ff d2                	call   *%edx
}
  10c5b9:	c9                   	leave  
  10c5ba:	c3                   	ret    
  10c5bb:	90                   	nop    
  10c5bc:	8d 74 26 00          	lea    0x0(%esi),%esi

0010c5c0 <loopif_output>:

static err_t
loopif_output(struct netif *netif, struct pbuf *p,
       struct ip_addr *ipaddr)
{
  10c5c0:	55                   	push   %ebp
  10c5c1:	89 e5                	mov    %esp,%ebp
  10c5c3:	83 ec 28             	sub    $0x28,%esp
  struct pbuf *q, *r;
  char *ptr;
  void **arg;

#if defined(LWIP_DEBUG) && defined(LWIP_TCPDUMP)
  tcpdump(p);
#endif /* LWIP_DEBUG && LWIP_TCPDUMP */
  
  r = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
  10c5c6:	8b 45 0c             	mov    0xc(%ebp),%eax
  10c5c9:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  10c5cd:	0f b7 c0             	movzwl %ax,%eax
  10c5d0:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  10c5d7:	00 
  10c5d8:	89 44 24 04          	mov    %eax,0x4(%esp)
  10c5dc:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  10c5e3:	e8 f8 29 00 00       	call   10efe0 <pbuf_alloc>
  10c5e8:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  if (r != NULL) {
  10c5eb:	83 7d f4 00          	cmpl   $0x0,0xfffffff4(%ebp)
  10c5ef:	0f 84 a4 00 00 00    	je     10c699 <loopif_output+0xd9>
    ptr = r->payload;
  10c5f5:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10c5f8:	8b 40 04             	mov    0x4(%eax),%eax
  10c5fb:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
    
    for(q = p; q != NULL; q = q->next) {
  10c5fe:	8b 45 0c             	mov    0xc(%ebp),%eax
  10c601:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
  10c604:	eb 38                	jmp    10c63e <loopif_output+0x7e>
      memcpy(ptr, q->payload, q->len);
  10c606:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10c609:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  10c60d:	0f b7 d0             	movzwl %ax,%edx
  10c610:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10c613:	8b 40 04             	mov    0x4(%eax),%eax
  10c616:	89 54 24 08          	mov    %edx,0x8(%esp)
  10c61a:	89 44 24 04          	mov    %eax,0x4(%esp)
  10c61e:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10c621:	89 04 24             	mov    %eax,(%esp)
  10c624:	e8 67 98 ff ff       	call   105e90 <memcpy>
      ptr += q->len;
  10c629:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10c62c:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  10c630:	0f b7 c0             	movzwl %ax,%eax
  10c633:	01 45 f8             	add    %eax,0xfffffff8(%ebp)
  10c636:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10c639:	8b 00                	mov    (%eax),%eax
  10c63b:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
  10c63e:	83 7d f0 00          	cmpl   $0x0,0xfffffff0(%ebp)
  10c642:	75 c2                	jne    10c606 <loopif_output+0x46>
    }

    arg = mem_malloc( sizeof( void *[2]));
  10c644:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  10c64b:	e8 80 20 00 00       	call   10e6d0 <mem_malloc>
  10c650:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
	if( NULL == arg ) {
  10c653:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  10c657:	75 09                	jne    10c662 <loopif_output+0xa2>
		return ERR_MEM;
  10c659:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  10c660:	eb 3e                	jmp    10c6a0 <loopif_output+0xe0>
	}
	
	arg[0] = netif;
  10c662:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  10c665:	8b 45 08             	mov    0x8(%ebp),%eax
  10c668:	89 02                	mov    %eax,(%edx)
	arg[1] = r;
  10c66a:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  10c66d:	83 c2 04             	add    $0x4,%edx
  10c670:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10c673:	89 02                	mov    %eax,(%edx)
	/**
	 * workaround (patch #1779) to try to prevent bug #2595:
	 * When connecting to "localhost" with the loopif interface,
	 * tcp_output doesn't get the opportunity to finnish sending the
	 * segment before tcp_process gets it, resulting in tcp_process
	 * referencing pcb->unacked-> which still is NULL.
	 * 
	 * TODO: Is there still a race condition here? Leon
	 */
	sys_timeout( 1, loopif_input, arg );
  10c675:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10c678:	89 44 24 08          	mov    %eax,0x8(%esp)
  10c67c:	c7 44 24 04 80 c5 10 	movl   $0x10c580,0x4(%esp)
  10c683:	00 
  10c684:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  10c68b:	e8 70 38 00 00       	call   10ff00 <sys_timeout>
	
    return ERR_OK;    
  10c690:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  10c697:	eb 07                	jmp    10c6a0 <loopif_output+0xe0>
  }
  return ERR_MEM;
  10c699:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  10c6a0:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  10c6a3:	c9                   	leave  
  10c6a4:	c3                   	ret    
  10c6a5:	8d 74 26 00          	lea    0x0(%esi),%esi
  10c6a9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

0010c6b0 <loopif_init>:

err_t
loopif_init(struct netif *netif)
{
  10c6b0:	55                   	push   %ebp
  10c6b1:	89 e5                	mov    %esp,%ebp
  netif->name[0] = 'l';
  10c6b3:	8b 45 08             	mov    0x8(%ebp),%eax
  10c6b6:	c6 40 2a 6c          	movb   $0x6c,0x2a(%eax)
  netif->name[1] = 'o';
  10c6ba:	8b 45 08             	mov    0x8(%ebp),%eax
  10c6bd:	c6 40 2b 6f          	movb   $0x6f,0x2b(%eax)
#if 0 /** TODO: I think this should be enabled, or not? Leon */
  netif->input = loopif_input;
#endif
  netif->output = loopif_output;
  10c6c1:	8b 45 08             	mov    0x8(%ebp),%eax
  10c6c4:	c7 40 14 c0 c5 10 00 	movl   $0x10c5c0,0x14(%eax)
  return ERR_OK;
  10c6cb:	b8 00 00 00 00       	mov    $0x0,%eax
}
  10c6d0:	5d                   	pop    %ebp
  10c6d1:	c3                   	ret    
  10c6d2:	90                   	nop    
  10c6d3:	90                   	nop    
  10c6d4:	90                   	nop    
  10c6d5:	90                   	nop    
  10c6d6:	90                   	nop    
  10c6d7:	90                   	nop    
  10c6d8:	90                   	nop    
  10c6d9:	90                   	nop    
  10c6da:	90                   	nop    
  10c6db:	90                   	nop    
  10c6dc:	90                   	nop    
  10c6dd:	90                   	nop    
  10c6de:	90                   	nop    
  10c6df:	90                   	nop    

0010c6e0 <icmp_input>:
#include "lwip/snmp.h"

void
icmp_input(struct pbuf *p, struct netif *inp)
{
  10c6e0:	55                   	push   %ebp
  10c6e1:	89 e5                	mov    %esp,%ebp
  10c6e3:	53                   	push   %ebx
  10c6e4:	83 ec 44             	sub    $0x44,%esp
  unsigned char type;
  unsigned char code;
  struct icmp_echo_hdr *iecho;
  struct ip_hdr *iphdr;
  struct ip_addr tmpaddr;
  u16_t hlen;

  ICMP_STATS_INC(icmp.recv);
  10c6e7:	0f b7 05 32 15 14 00 	movzwl 0x141532,%eax
  10c6ee:	83 c0 01             	add    $0x1,%eax
  10c6f1:	66 a3 32 15 14 00    	mov    %ax,0x141532
  snmp_inc_icmpinmsgs();


  iphdr = p->payload;
  10c6f7:	8b 45 08             	mov    0x8(%ebp),%eax
  10c6fa:	8b 40 04             	mov    0x4(%eax),%eax
  10c6fd:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  hlen = IPH_HL(iphdr) * 4;
  10c700:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10c703:	0f b7 00             	movzwl (%eax),%eax
  10c706:	0f b7 c0             	movzwl %ax,%eax
  10c709:	89 04 24             	mov    %eax,(%esp)
  10c70c:	e8 9f 1b 00 00       	call   10e2b0 <ntohs>
  10c711:	66 c1 e8 08          	shr    $0x8,%ax
  10c715:	0f b7 c0             	movzwl %ax,%eax
  10c718:	83 e0 0f             	and    $0xf,%eax
  10c71b:	c1 e0 02             	shl    $0x2,%eax
  10c71e:	66 89 45 fa          	mov    %ax,0xfffffffa(%ebp)
  if (pbuf_header(p, -((s16_t)hlen)) || (p->tot_len < sizeof(u16_t)*2)) {
  10c722:	0f b7 45 fa          	movzwl 0xfffffffa(%ebp),%eax
  10c726:	f7 d8                	neg    %eax
  10c728:	98                   	cwtl   
  10c729:	89 44 24 04          	mov    %eax,0x4(%esp)
  10c72d:	8b 45 08             	mov    0x8(%ebp),%eax
  10c730:	89 04 24             	mov    %eax,(%esp)
  10c733:	e8 88 2c 00 00       	call   10f3c0 <pbuf_header>
  10c738:	84 c0                	test   %al,%al
  10c73a:	75 0d                	jne    10c749 <icmp_input+0x69>
  10c73c:	8b 45 08             	mov    0x8(%ebp),%eax
  10c73f:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  10c743:	66 83 f8 03          	cmp    $0x3,%ax
  10c747:	77 20                	ja     10c769 <icmp_input+0x89>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: short ICMP (%u bytes) received\n", p->tot_len));
    pbuf_free(p);
  10c749:	8b 45 08             	mov    0x8(%ebp),%eax
  10c74c:	89 04 24             	mov    %eax,(%esp)
  10c74f:	e8 6c 2d 00 00       	call   10f4c0 <pbuf_free>
    ICMP_STATS_INC(icmp.lenerr);
  10c754:	0f b7 05 3a 15 14 00 	movzwl 0x14153a,%eax
  10c75b:	83 c0 01             	add    $0x1,%eax
  10c75e:	66 a3 3a 15 14 00    	mov    %ax,0x14153a
    snmp_inc_icmpinerrors();
    return;
  10c764:	e9 44 02 00 00       	jmp    10c9ad <icmp_input+0x2cd>
  }

  type = *((u8_t *)p->payload);
  10c769:	8b 45 08             	mov    0x8(%ebp),%eax
  10c76c:	8b 40 04             	mov    0x4(%eax),%eax
  10c76f:	0f b6 00             	movzbl (%eax),%eax
  10c772:	88 45 ee             	mov    %al,0xffffffee(%ebp)
  code = *(((u8_t *)p->payload)+1);
  10c775:	8b 45 08             	mov    0x8(%ebp),%eax
  10c778:	8b 40 04             	mov    0x4(%eax),%eax
  10c77b:	83 c0 01             	add    $0x1,%eax
  10c77e:	0f b6 00             	movzbl (%eax),%eax
  10c781:	88 45 ef             	mov    %al,0xffffffef(%ebp)
  switch (type) {
  10c784:	0f b6 45 ee          	movzbl 0xffffffee(%ebp),%eax
  10c788:	83 f8 08             	cmp    $0x8,%eax
  10c78b:	74 05                	je     10c792 <icmp_input+0xb2>
  10c78d:	e9 f0 01 00 00       	jmp    10c982 <icmp_input+0x2a2>
  case ICMP_ECHO:
    if (ip_addr_isbroadcast(&iphdr->dest, &inp->netmask) ||
  10c792:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10c795:	8b 50 10             	mov    0x10(%eax),%edx
  10c798:	8b 45 0c             	mov    0xc(%ebp),%eax
  10c79b:	8b 40 08             	mov    0x8(%eax),%eax
  10c79e:	f7 d0                	not    %eax
  10c7a0:	21 c2                	and    %eax,%edx
  10c7a2:	8b 45 0c             	mov    0xc(%ebp),%eax
  10c7a5:	8b 40 08             	mov    0x8(%eax),%eax
  10c7a8:	f7 d0                	not    %eax
  10c7aa:	39 c2                	cmp    %eax,%edx
  10c7ac:	74 39                	je     10c7e7 <icmp_input+0x107>
  10c7ae:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10c7b1:	8b 40 10             	mov    0x10(%eax),%eax
  10c7b4:	83 f8 ff             	cmp    $0xffffffff,%eax
  10c7b7:	74 2e                	je     10c7e7 <icmp_input+0x107>
  10c7b9:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10c7bc:	8b 40 10             	mov    0x10(%eax),%eax
  10c7bf:	85 c0                	test   %eax,%eax
  10c7c1:	74 24                	je     10c7e7 <icmp_input+0x107>
  10c7c3:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10c7c6:	8b 58 10             	mov    0x10(%eax),%ebx
  10c7c9:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  10c7d0:	e8 3b 1b 00 00       	call   10e310 <ntohl>
  10c7d5:	21 c3                	and    %eax,%ebx
  10c7d7:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  10c7de:	e8 2d 1b 00 00       	call   10e310 <ntohl>
  10c7e3:	39 c3                	cmp    %eax,%ebx
  10c7e5:	75 20                	jne    10c807 <icmp_input+0x127>
       ip_addr_ismulticast(&iphdr->dest)) {
      LWIP_DEBUGF(ICMP_DEBUG, ("Smurf.\n"));
      ICMP_STATS_INC(icmp.err);
  10c7e7:	0f b7 05 44 15 14 00 	movzwl 0x141544,%eax
  10c7ee:	83 c0 01             	add    $0x1,%eax
  10c7f1:	66 a3 44 15 14 00    	mov    %ax,0x141544
      pbuf_free(p);
  10c7f7:	8b 45 08             	mov    0x8(%ebp),%eax
  10c7fa:	89 04 24             	mov    %eax,(%esp)
  10c7fd:	e8 be 2c 00 00       	call   10f4c0 <pbuf_free>
      return;
  10c802:	e9 a6 01 00 00       	jmp    10c9ad <icmp_input+0x2cd>
    }
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ping\n"));
    if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
  10c807:	8b 45 08             	mov    0x8(%ebp),%eax
  10c80a:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  10c80e:	66 83 f8 07          	cmp    $0x7,%ax
  10c812:	77 20                	ja     10c834 <icmp_input+0x154>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: bad ICMP echo received\n"));
      pbuf_free(p);
  10c814:	8b 45 08             	mov    0x8(%ebp),%eax
  10c817:	89 04 24             	mov    %eax,(%esp)
  10c81a:	e8 a1 2c 00 00       	call   10f4c0 <pbuf_free>
      ICMP_STATS_INC(icmp.lenerr);
  10c81f:	0f b7 05 3a 15 14 00 	movzwl 0x14153a,%eax
  10c826:	83 c0 01             	add    $0x1,%eax
  10c829:	66 a3 3a 15 14 00    	mov    %ax,0x14153a
      snmp_inc_icmpinerrors();

      return;
  10c82f:	e9 79 01 00 00       	jmp    10c9ad <icmp_input+0x2cd>
    }
    iecho = p->payload;
  10c834:	8b 45 08             	mov    0x8(%ebp),%eax
  10c837:	8b 40 04             	mov    0x4(%eax),%eax
  10c83a:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
    if (inet_chksum_pbuf(p) != 0) {
  10c83d:	8b 45 08             	mov    0x8(%ebp),%eax
  10c840:	89 04 24             	mov    %eax,(%esp)
  10c843:	e8 98 15 00 00       	call   10dde0 <inet_chksum_pbuf>
  10c848:	66 85 c0             	test   %ax,%ax
  10c84b:	74 20                	je     10c86d <icmp_input+0x18d>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: checksum failed for received ICMP echo\n"));
      pbuf_free(p);
  10c84d:	8b 45 08             	mov    0x8(%ebp),%eax
  10c850:	89 04 24             	mov    %eax,(%esp)
  10c853:	e8 68 2c 00 00       	call   10f4c0 <pbuf_free>
      ICMP_STATS_INC(icmp.chkerr);
  10c858:	0f b7 05 38 15 14 00 	movzwl 0x141538,%eax
  10c85f:	83 c0 01             	add    $0x1,%eax
  10c862:	66 a3 38 15 14 00    	mov    %ax,0x141538
      snmp_inc_icmpinerrors();
      return;
  10c868:	e9 40 01 00 00       	jmp    10c9ad <icmp_input+0x2cd>
    }
    tmpaddr.addr = iphdr->src.addr;
  10c86d:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10c870:	8b 40 0c             	mov    0xc(%eax),%eax
  10c873:	89 45 ea             	mov    %eax,0xffffffea(%ebp)
    iphdr->src.addr = iphdr->dest.addr;
  10c876:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10c879:	8b 50 10             	mov    0x10(%eax),%edx
  10c87c:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10c87f:	89 50 0c             	mov    %edx,0xc(%eax)
    iphdr->dest.addr = tmpaddr.addr;
  10c882:	8b 55 ea             	mov    0xffffffea(%ebp),%edx
  10c885:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10c888:	89 50 10             	mov    %edx,0x10(%eax)
    ICMPH_TYPE_SET(iecho, ICMP_ER);
  10c88b:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10c88e:	0f b7 00             	movzwl (%eax),%eax
  10c891:	0f b7 c0             	movzwl %ax,%eax
  10c894:	89 04 24             	mov    %eax,(%esp)
  10c897:	e8 14 1a 00 00       	call   10e2b0 <ntohs>
  10c89c:	0f b7 c0             	movzwl %ax,%eax
  10c89f:	25 ff 00 00 00       	and    $0xff,%eax
  10c8a4:	89 04 24             	mov    %eax,(%esp)
  10c8a7:	e8 d4 19 00 00       	call   10e280 <htons>
  10c8ac:	89 c2                	mov    %eax,%edx
  10c8ae:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10c8b1:	66 89 10             	mov    %dx,(%eax)
    /* adjust the checksum */
    if (iecho->chksum >= htons(0xffff - (ICMP_ECHO << 8))) {
  10c8b4:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10c8b7:	0f b7 58 02          	movzwl 0x2(%eax),%ebx
  10c8bb:	c7 04 24 ff f7 00 00 	movl   $0xf7ff,(%esp)
  10c8c2:	e8 b9 19 00 00       	call   10e280 <htons>
  10c8c7:	66 39 c3             	cmp    %ax,%bx
  10c8ca:	72 22                	jb     10c8ee <icmp_input+0x20e>
      iecho->chksum += htons(ICMP_ECHO << 8) + 1;
  10c8cc:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10c8cf:	0f b7 58 02          	movzwl 0x2(%eax),%ebx
  10c8d3:	c7 04 24 00 08 00 00 	movl   $0x800,(%esp)
  10c8da:	e8 a1 19 00 00       	call   10e280 <htons>
  10c8df:	8d 04 03             	lea    (%ebx,%eax,1),%eax
  10c8e2:	8d 50 01             	lea    0x1(%eax),%edx
  10c8e5:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10c8e8:	66 89 50 02          	mov    %dx,0x2(%eax)
  10c8ec:	eb 1d                	jmp    10c90b <icmp_input+0x22b>
    } else {
      iecho->chksum += htons(ICMP_ECHO << 8);
  10c8ee:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10c8f1:	0f b7 58 02          	movzwl 0x2(%eax),%ebx
  10c8f5:	c7 04 24 00 08 00 00 	movl   $0x800,(%esp)
  10c8fc:	e8 7f 19 00 00       	call   10e280 <htons>
  10c901:	8d 14 03             	lea    (%ebx,%eax,1),%edx
  10c904:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10c907:	66 89 50 02          	mov    %dx,0x2(%eax)
    }
    ICMP_STATS_INC(icmp.xmit);
  10c90b:	0f b7 05 2e 15 14 00 	movzwl 0x14152e,%eax
  10c912:	83 c0 01             	add    $0x1,%eax
  10c915:	66 a3 2e 15 14 00    	mov    %ax,0x14152e
    /* increase number of messages attempted to send */
    snmp_inc_icmpoutmsgs();
    /* increase number of echo replies attempted to send */
    snmp_inc_icmpoutechoreps();

    pbuf_header(p, hlen);
  10c91b:	0f b7 45 fa          	movzwl 0xfffffffa(%ebp),%eax
  10c91f:	98                   	cwtl   
  10c920:	89 44 24 04          	mov    %eax,0x4(%esp)
  10c924:	8b 45 08             	mov    0x8(%ebp),%eax
  10c927:	89 04 24             	mov    %eax,(%esp)
  10c92a:	e8 91 2a 00 00       	call   10f3c0 <pbuf_header>
    ip_output_if(p, &(iphdr->src), IP_HDRINCL,
  10c92f:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10c932:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  10c936:	0f b7 c0             	movzwl %ax,%eax
  10c939:	89 04 24             	mov    %eax,(%esp)
  10c93c:	e8 6f 19 00 00       	call   10e2b0 <ntohs>
  10c941:	66 c1 e8 08          	shr    $0x8,%ax
  10c945:	0f b6 d0             	movzbl %al,%edx
  10c948:	8b 4d f4             	mov    0xfffffff4(%ebp),%ecx
  10c94b:	83 c1 0c             	add    $0xc,%ecx
  10c94e:	8b 45 0c             	mov    0xc(%ebp),%eax
  10c951:	89 44 24 18          	mov    %eax,0x18(%esp)
  10c955:	c7 44 24 14 01 00 00 	movl   $0x1,0x14(%esp)
  10c95c:	00 
  10c95d:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  10c964:	00 
  10c965:	89 54 24 0c          	mov    %edx,0xc(%esp)
  10c969:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  10c970:	00 
  10c971:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10c975:	8b 45 08             	mov    0x8(%ebp),%eax
  10c978:	89 04 24             	mov    %eax,(%esp)
  10c97b:	e8 f0 05 00 00       	call   10cf70 <ip_output_if>
		 IPH_TTL(iphdr), 0, IP_PROTO_ICMP, inp);
    break;
  10c980:	eb 20                	jmp    10c9a2 <icmp_input+0x2c2>
  default:
  LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ICMP type %d code %d not supported.\n", (int)type, (int)code));
    ICMP_STATS_INC(icmp.proterr);
  10c982:	0f b7 05 40 15 14 00 	movzwl 0x141540,%eax
  10c989:	83 c0 01             	add    $0x1,%eax
  10c98c:	66 a3 40 15 14 00    	mov    %ax,0x141540
    ICMP_STATS_INC(icmp.drop);
  10c992:	0f b7 05 36 15 14 00 	movzwl 0x141536,%eax
  10c999:	83 c0 01             	add    $0x1,%eax
  10c99c:	66 a3 36 15 14 00    	mov    %ax,0x141536
  }
  pbuf_free(p);
  10c9a2:	8b 45 08             	mov    0x8(%ebp),%eax
  10c9a5:	89 04 24             	mov    %eax,(%esp)
  10c9a8:	e8 13 2b 00 00       	call   10f4c0 <pbuf_free>
}
  10c9ad:	83 c4 44             	add    $0x44,%esp
  10c9b0:	5b                   	pop    %ebx
  10c9b1:	5d                   	pop    %ebp
  10c9b2:	c3                   	ret    
  10c9b3:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  10c9b9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

0010c9c0 <icmp_dest_unreach>:

void
icmp_dest_unreach(struct pbuf *p, enum icmp_dur_type t)
{
  10c9c0:	55                   	push   %ebp
  10c9c1:	89 e5                	mov    %esp,%ebp
  10c9c3:	83 ec 28             	sub    $0x28,%esp
  struct pbuf *q;
  struct ip_hdr *iphdr;
  struct icmp_dur_hdr *idur;

  q = pbuf_alloc(PBUF_IP, 8 + IP_HLEN + 8, PBUF_RAM);
  10c9c6:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  10c9cd:	00 
  10c9ce:	c7 44 24 04 24 00 00 	movl   $0x24,0x4(%esp)
  10c9d5:	00 
  10c9d6:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  10c9dd:	e8 fe 25 00 00       	call   10efe0 <pbuf_alloc>
  10c9e2:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  /* ICMP header + IP header + 8 bytes of data */

  iphdr = p->payload;
  10c9e5:	8b 45 08             	mov    0x8(%ebp),%eax
  10c9e8:	8b 40 04             	mov    0x4(%eax),%eax
  10c9eb:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)

  idur = q->payload;
  10c9ee:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10c9f1:	8b 40 04             	mov    0x4(%eax),%eax
  10c9f4:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  ICMPH_TYPE_SET(idur, ICMP_DUR);
  10c9f7:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10c9fa:	0f b7 00             	movzwl (%eax),%eax
  10c9fd:	0f b7 c0             	movzwl %ax,%eax
  10ca00:	89 04 24             	mov    %eax,(%esp)
  10ca03:	e8 a8 18 00 00       	call   10e2b0 <ntohs>
  10ca08:	66 25 ff 00          	and    $0xff,%ax
  10ca0c:	80 cc 03             	or     $0x3,%ah
  10ca0f:	0f b7 c0             	movzwl %ax,%eax
  10ca12:	89 04 24             	mov    %eax,(%esp)
  10ca15:	e8 66 18 00 00       	call   10e280 <htons>
  10ca1a:	89 c2                	mov    %eax,%edx
  10ca1c:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10ca1f:	66 89 10             	mov    %dx,(%eax)
  ICMPH_CODE_SET(idur, t);
  10ca22:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10ca25:	0f b7 00             	movzwl (%eax),%eax
  10ca28:	0f b7 c0             	movzwl %ax,%eax
  10ca2b:	89 04 24             	mov    %eax,(%esp)
  10ca2e:	e8 7d 18 00 00       	call   10e2b0 <ntohs>
  10ca33:	89 c2                	mov    %eax,%edx
  10ca35:	b2 00                	mov    $0x0,%dl
  10ca37:	8b 45 0c             	mov    0xc(%ebp),%eax
  10ca3a:	09 d0                	or     %edx,%eax
  10ca3c:	0f b7 c0             	movzwl %ax,%eax
  10ca3f:	89 04 24             	mov    %eax,(%esp)
  10ca42:	e8 39 18 00 00       	call   10e280 <htons>
  10ca47:	89 c2                	mov    %eax,%edx
  10ca49:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10ca4c:	66 89 10             	mov    %dx,(%eax)

  memcpy((char *)q->payload + 8, p->payload, IP_HLEN + 8);
  10ca4f:	8b 45 08             	mov    0x8(%ebp),%eax
  10ca52:	8b 50 04             	mov    0x4(%eax),%edx
  10ca55:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10ca58:	8b 40 04             	mov    0x4(%eax),%eax
  10ca5b:	83 c0 08             	add    $0x8,%eax
  10ca5e:	c7 44 24 08 1c 00 00 	movl   $0x1c,0x8(%esp)
  10ca65:	00 
  10ca66:	89 54 24 04          	mov    %edx,0x4(%esp)
  10ca6a:	89 04 24             	mov    %eax,(%esp)
  10ca6d:	e8 1e 94 ff ff       	call   105e90 <memcpy>

  /* calculate checksum */
  idur->chksum = 0;
  10ca72:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10ca75:	66 c7 40 02 00 00    	movw   $0x0,0x2(%eax)
  idur->chksum = inet_chksum(idur, q->len);
  10ca7b:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10ca7e:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  10ca82:	0f b7 c0             	movzwl %ax,%eax
  10ca85:	89 44 24 04          	mov    %eax,0x4(%esp)
  10ca89:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10ca8c:	89 04 24             	mov    %eax,(%esp)
  10ca8f:	e8 fc 12 00 00       	call   10dd90 <inet_chksum>
  10ca94:	89 c2                	mov    %eax,%edx
  10ca96:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10ca99:	66 89 50 02          	mov    %dx,0x2(%eax)
  ICMP_STATS_INC(icmp.xmit);
  10ca9d:	0f b7 05 2e 15 14 00 	movzwl 0x14152e,%eax
  10caa4:	83 c0 01             	add    $0x1,%eax
  10caa7:	66 a3 2e 15 14 00    	mov    %ax,0x14152e
  /* increase number of messages attempted to send */
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpoutdestunreachs();

  ip_output(q, NULL, &(iphdr->src),
  10caad:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10cab0:	83 c0 0c             	add    $0xc,%eax
  10cab3:	c7 44 24 14 01 00 00 	movl   $0x1,0x14(%esp)
  10caba:	00 
  10cabb:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  10cac2:	00 
  10cac3:	c7 44 24 0c ff 00 00 	movl   $0xff,0xc(%esp)
  10caca:	00 
  10cacb:	89 44 24 08          	mov    %eax,0x8(%esp)
  10cacf:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  10cad6:	00 
  10cad7:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10cada:	89 04 24             	mov    %eax,(%esp)
  10cadd:	e8 2e 07 00 00       	call   10d210 <ip_output>
	    ICMP_TTL, 0, IP_PROTO_ICMP);
  pbuf_free(q);
  10cae2:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10cae5:	89 04 24             	mov    %eax,(%esp)
  10cae8:	e8 d3 29 00 00       	call   10f4c0 <pbuf_free>
}
  10caed:	c9                   	leave  
  10caee:	c3                   	ret    
  10caef:	90                   	nop    

0010caf0 <ip_init>:
 */

void
ip_init(void)
{
  10caf0:	55                   	push   %ebp
  10caf1:	89 e5                	mov    %esp,%ebp
}
  10caf3:	5d                   	pop    %ebp
  10caf4:	c3                   	ret    
  10caf5:	8d 74 26 00          	lea    0x0(%esi),%esi
  10caf9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

0010cb00 <ip_route>:

/* ip_route:
 *
 * Finds the appropriate network interface for a given IP address. It
 * searches the list of network interfaces linearly. A match is found
 * if the masked IP address of the network interface equals the masked
 * IP address given to the function.
 */

struct netif *
ip_route(struct ip_addr *dest)
{
  10cb00:	55                   	push   %ebp
  10cb01:	89 e5                	mov    %esp,%ebp
  10cb03:	83 ec 14             	sub    $0x14,%esp
  struct netif *netif;

  /* iterate through netifs */
  for(netif = netif_list; netif != NULL; netif = netif->next) {
  10cb06:	a1 98 08 13 00       	mov    0x130898,%eax
  10cb0b:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  10cb0e:	eb 31                	jmp    10cb41 <ip_route+0x41>
    /* network mask matches? */
    if (ip_addr_maskcmp(dest, &(netif->ip_addr), &(netif->netmask))) {
  10cb10:	8b 45 08             	mov    0x8(%ebp),%eax
  10cb13:	8b 10                	mov    (%eax),%edx
  10cb15:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10cb18:	8b 40 08             	mov    0x8(%eax),%eax
  10cb1b:	89 d1                	mov    %edx,%ecx
  10cb1d:	21 c1                	and    %eax,%ecx
  10cb1f:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10cb22:	8b 50 04             	mov    0x4(%eax),%edx
  10cb25:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10cb28:	8b 40 08             	mov    0x8(%eax),%eax
  10cb2b:	21 d0                	and    %edx,%eax
  10cb2d:	39 c1                	cmp    %eax,%ecx
  10cb2f:	75 08                	jne    10cb39 <ip_route+0x39>
      /* return netif on which to forward IP packet */
      return netif;
  10cb31:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10cb34:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  10cb37:	eb 16                	jmp    10cb4f <ip_route+0x4f>
  10cb39:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10cb3c:	8b 00                	mov    (%eax),%eax
  10cb3e:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  10cb41:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  10cb45:	75 c9                	jne    10cb10 <ip_route+0x10>
    }
  }
  /* no matching netif found, use default netif */
  return netif_default;
  10cb47:	a1 9c 08 13 00       	mov    0x13089c,%eax
  10cb4c:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  10cb4f:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  10cb52:	c9                   	leave  
  10cb53:	c3                   	ret    
  10cb54:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  10cb5a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

0010cb60 <ip_input>:
#if IP_FORWARD

/* ip_forward:
 *
 * Forwards an IP packet. It finds an appropriate route for the
 * packet, decrements the TTL value of the packet, adjusts the
 * checksum and outputs the packet on the appropriate interface.
 */

static void
ip_forward(struct pbuf *p, struct ip_hdr *iphdr, struct netif *inp)
{
  struct netif *netif;

  PERF_START;
  /* Find network interface where to forward this IP packet to. */
  netif = ip_route((struct ip_addr *)&(iphdr->dest));
  if (netif == NULL) {
    LWIP_DEBUGF(IP_DEBUG, ("ip_forward: no forwarding route for 0x%lx found\n",
                      iphdr->dest.addr));
    snmp_inc_ipnoroutes();
    return;
  }
  /* Do not forward packets onto the same network interface on which
     they arrived. */
  if (netif == inp) {
    LWIP_DEBUGF(IP_DEBUG, ("ip_forward: not bouncing packets back on incoming interface.\n"));
    snmp_inc_ipnoroutes();
    return;
  }

  /* decrement TTL */
  IPH_TTL_SET(iphdr, IPH_TTL(iphdr) - 1);
  /* send ICMP if TTL == 0 */
  if (IPH_TTL(iphdr) == 0) {
    /* Don't send ICMP messages in response to ICMP messages */
    if (IPH_PROTO(iphdr) != IP_PROTO_ICMP) {
      icmp_time_exceeded(p, ICMP_TE_TTL);
      snmp_inc_icmpouttimeexcds();
    }
    return;
  }

  /* Incrementally update the IP checksum. */
  if (IPH_CHKSUM(iphdr) >= htons(0xffff - 0x100)) {
    IPH_CHKSUM_SET(iphdr, IPH_CHKSUM(iphdr) + htons(0x100) + 1);
  } else {
    IPH_CHKSUM_SET(iphdr, IPH_CHKSUM(iphdr) + htons(0x100));
  }

  LWIP_DEBUGF(IP_DEBUG, ("ip_forward: forwarding packet to 0x%lx\n",
                    iphdr->dest.addr));

  IP_STATS_INC(ip.fw);
  IP_STATS_INC(ip.xmit);
    snmp_inc_ipforwdatagrams();

  PERF_STOP("ip_forward");
  /* transmit pbuf on chosen interface */
  netif->output(netif, p, (struct ip_addr *)&(iphdr->dest));
}
#endif /* IP_FORWARD */

/* ip_input:
 *
 * This function is called by the network interface device driver when
 * an IP packet is received. The function does the basic checks of the
 * IP header such as packet size being at least larger than the header
 * size etc. If the packet was not destined for us, the packet is
 * forwarded (using ip_forward). The IP checksum is always checked.
 *
 * Finally, the packet is sent to the upper layer protocol input function.
 */

err_t
ip_input(struct pbuf *p, struct netif *inp) {
  10cb60:	55                   	push   %ebp
  10cb61:	89 e5                	mov    %esp,%ebp
  10cb63:	53                   	push   %ebx
  10cb64:	83 ec 14             	sub    $0x14,%esp
  static struct ip_hdr *iphdr;
  static struct netif *netif;
  static u16_t iphdrlen;

  IP_STATS_INC(ip.recv);
  10cb67:	0f b7 05 18 15 14 00 	movzwl 0x141518,%eax
  10cb6e:	83 c0 01             	add    $0x1,%eax
  10cb71:	66 a3 18 15 14 00    	mov    %ax,0x141518
  snmp_inc_ipinreceives();

  /* identify the IP header */
  iphdr = p->payload;
  10cb77:	8b 45 08             	mov    0x8(%ebp),%eax
  10cb7a:	8b 40 04             	mov    0x4(%eax),%eax
  10cb7d:	a3 b8 db 11 00       	mov    %eax,0x11dbb8
  if (IPH_V(iphdr) != 4) {
  10cb82:	a1 b8 db 11 00       	mov    0x11dbb8,%eax
  10cb87:	0f b7 00             	movzwl (%eax),%eax
  10cb8a:	0f b7 c0             	movzwl %ax,%eax
  10cb8d:	89 04 24             	mov    %eax,(%esp)
  10cb90:	e8 1b 17 00 00       	call   10e2b0 <ntohs>
  10cb95:	66 c1 e8 0c          	shr    $0xc,%ax
  10cb99:	66 83 f8 04          	cmp    $0x4,%ax
  10cb9d:	74 37                	je     10cbd6 <ip_input+0x76>
    LWIP_DEBUGF(IP_DEBUG | 1, ("IP packet dropped due to bad version number %u\n", IPH_V(iphdr)));
    ip_debug_print(p);
    pbuf_free(p);
  10cb9f:	8b 45 08             	mov    0x8(%ebp),%eax
  10cba2:	89 04 24             	mov    %eax,(%esp)
  10cba5:	e8 16 29 00 00       	call   10f4c0 <pbuf_free>
    IP_STATS_INC(ip.err);
  10cbaa:	0f b7 05 2a 15 14 00 	movzwl 0x14152a,%eax
  10cbb1:	83 c0 01             	add    $0x1,%eax
  10cbb4:	66 a3 2a 15 14 00    	mov    %ax,0x14152a
    IP_STATS_INC(ip.drop);
  10cbba:	0f b7 05 1c 15 14 00 	movzwl 0x14151c,%eax
  10cbc1:	83 c0 01             	add    $0x1,%eax
  10cbc4:	66 a3 1c 15 14 00    	mov    %ax,0x14151c
    snmp_inc_ipunknownprotos();
    return ERR_OK;
  10cbca:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
  10cbd1:	e9 8c 03 00 00       	jmp    10cf62 <ip_input+0x402>
  }
  /* obtain IP header length in number of 32-bit words */
  iphdrlen = IPH_HL(iphdr);
  10cbd6:	a1 b8 db 11 00       	mov    0x11dbb8,%eax
  10cbdb:	0f b7 00             	movzwl (%eax),%eax
  10cbde:	0f b7 c0             	movzwl %ax,%eax
  10cbe1:	89 04 24             	mov    %eax,(%esp)
  10cbe4:	e8 c7 16 00 00       	call   10e2b0 <ntohs>
  10cbe9:	66 c1 e8 08          	shr    $0x8,%ax
  10cbed:	83 e0 0f             	and    $0xf,%eax
  10cbf0:	66 a3 b0 db 11 00    	mov    %ax,0x11dbb0
  /* calculate IP header length in bytes */
  iphdrlen *= 4;
  10cbf6:	0f b7 05 b0 db 11 00 	movzwl 0x11dbb0,%eax
  10cbfd:	0f b7 c0             	movzwl %ax,%eax
  10cc00:	c1 e0 02             	shl    $0x2,%eax
  10cc03:	66 a3 b0 db 11 00    	mov    %ax,0x11dbb0

  /* header length exceeds first pbuf length? */
  if (iphdrlen > p->len) {
  10cc09:	8b 45 08             	mov    0x8(%ebp),%eax
  10cc0c:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
  10cc10:	0f b7 05 b0 db 11 00 	movzwl 0x11dbb0,%eax
  10cc17:	66 39 c2             	cmp    %ax,%dx
  10cc1a:	73 37                	jae    10cc53 <ip_input+0xf3>
    LWIP_DEBUGF(IP_DEBUG | 2, ("IP header (len %u) does not fit in first pbuf (len %u), IP packet droppped.\n",
      iphdrlen, p->len));
    /* free (drop) packet pbufs */
    pbuf_free(p);
  10cc1c:	8b 45 08             	mov    0x8(%ebp),%eax
  10cc1f:	89 04 24             	mov    %eax,(%esp)
  10cc22:	e8 99 28 00 00       	call   10f4c0 <pbuf_free>
    IP_STATS_INC(ip.lenerr);
  10cc27:	0f b7 05 20 15 14 00 	movzwl 0x141520,%eax
  10cc2e:	83 c0 01             	add    $0x1,%eax
  10cc31:	66 a3 20 15 14 00    	mov    %ax,0x141520
    IP_STATS_INC(ip.drop);
  10cc37:	0f b7 05 1c 15 14 00 	movzwl 0x14151c,%eax
  10cc3e:	83 c0 01             	add    $0x1,%eax
  10cc41:	66 a3 1c 15 14 00    	mov    %ax,0x14151c
    snmp_inc_ipindiscards();
    return ERR_OK;
  10cc47:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
  10cc4e:	e9 0f 03 00 00       	jmp    10cf62 <ip_input+0x402>
  }

  /* verify checksum */
  if (inet_chksum(iphdr, iphdrlen) != 0) {
  10cc53:	0f b7 05 b0 db 11 00 	movzwl 0x11dbb0,%eax
  10cc5a:	0f b7 c0             	movzwl %ax,%eax
  10cc5d:	8b 15 b8 db 11 00    	mov    0x11dbb8,%edx
  10cc63:	89 44 24 04          	mov    %eax,0x4(%esp)
  10cc67:	89 14 24             	mov    %edx,(%esp)
  10cc6a:	e8 21 11 00 00       	call   10dd90 <inet_chksum>
  10cc6f:	66 85 c0             	test   %ax,%ax
  10cc72:	74 37                	je     10ccab <ip_input+0x14b>

    LWIP_DEBUGF(IP_DEBUG | 2, ("Checksum (0x%x) failed, IP packet dropped.\n", inet_chksum(iphdr, iphdrlen)));
    ip_debug_print(p);
    pbuf_free(p);
  10cc74:	8b 45 08             	mov    0x8(%ebp),%eax
  10cc77:	89 04 24             	mov    %eax,(%esp)
  10cc7a:	e8 41 28 00 00       	call   10f4c0 <pbuf_free>
    IP_STATS_INC(ip.chkerr);
  10cc7f:	0f b7 05 1e 15 14 00 	movzwl 0x14151e,%eax
  10cc86:	83 c0 01             	add    $0x1,%eax
  10cc89:	66 a3 1e 15 14 00    	mov    %ax,0x14151e
    IP_STATS_INC(ip.drop);
  10cc8f:	0f b7 05 1c 15 14 00 	movzwl 0x14151c,%eax
  10cc96:	83 c0 01             	add    $0x1,%eax
  10cc99:	66 a3 1c 15 14 00    	mov    %ax,0x14151c
    snmp_inc_ipindiscards();
    return ERR_OK;
  10cc9f:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
  10cca6:	e9 b7 02 00 00       	jmp    10cf62 <ip_input+0x402>
  }

  /* Trim pbuf. This should have been done at the netif layer,
     but we'll do it anyway just to be sure that its done. */
  pbuf_realloc(p, ntohs(IPH_LEN(iphdr)));
  10ccab:	a1 b8 db 11 00       	mov    0x11dbb8,%eax
  10ccb0:	0f b7 40 02          	movzwl 0x2(%eax),%eax
  10ccb4:	0f b7 c0             	movzwl %ax,%eax
  10ccb7:	89 04 24             	mov    %eax,(%esp)
  10ccba:	e8 f1 15 00 00       	call   10e2b0 <ntohs>
  10ccbf:	0f b7 c0             	movzwl %ax,%eax
  10ccc2:	89 44 24 04          	mov    %eax,0x4(%esp)
  10ccc6:	8b 45 08             	mov    0x8(%ebp),%eax
  10ccc9:	89 04 24             	mov    %eax,(%esp)
  10cccc:	e8 df 25 00 00       	call   10f2b0 <pbuf_realloc>

  /* is this packet for us? */
  for(netif = netif_list; netif != NULL; netif = netif->next) {
  10ccd1:	a1 98 08 13 00       	mov    0x130898,%eax
  10ccd6:	a3 b4 db 11 00       	mov    %eax,0x11dbb4
  10ccdb:	e9 be 00 00 00       	jmp    10cd9e <ip_input+0x23e>

    LWIP_DEBUGF(IP_DEBUG, ("ip_input: iphdr->dest 0x%lx netif->ip_addr 0x%lx (0x%lx, 0x%lx, 0x%lx)\n",
                      iphdr->dest.addr, netif->ip_addr.addr,
                      iphdr->dest.addr & netif->netmask.addr,
                      netif->ip_addr.addr & netif->netmask.addr,
                      iphdr->dest.addr & ~(netif->netmask.addr)));

    /* interface configured? */
    if (!ip_addr_isany(&(netif->ip_addr)))
  10cce0:	a1 b4 db 11 00       	mov    0x11dbb4,%eax
  10cce5:	83 c0 04             	add    $0x4,%eax
  10cce8:	85 c0                	test   %eax,%eax
  10ccea:	0f 84 a2 00 00 00    	je     10cd92 <ip_input+0x232>
  10ccf0:	a1 b4 db 11 00       	mov    0x11dbb4,%eax
  10ccf5:	8b 40 04             	mov    0x4(%eax),%eax
  10ccf8:	85 c0                	test   %eax,%eax
  10ccfa:	0f 84 92 00 00 00    	je     10cd92 <ip_input+0x232>
    {
      /* unicast to this interface address? */
      if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
  10cd00:	a1 b8 db 11 00       	mov    0x11dbb8,%eax
  10cd05:	8b 50 10             	mov    0x10(%eax),%edx
  10cd08:	a1 b4 db 11 00       	mov    0x11dbb4,%eax
  10cd0d:	8b 40 04             	mov    0x4(%eax),%eax
  10cd10:	39 c2                	cmp    %eax,%edx
  10cd12:	0f 84 93 00 00 00    	je     10cdab <ip_input+0x24b>
  10cd18:	a1 b8 db 11 00       	mov    0x11dbb8,%eax
  10cd1d:	8b 50 10             	mov    0x10(%eax),%edx
  10cd20:	a1 b4 db 11 00       	mov    0x11dbb4,%eax
  10cd25:	8b 40 08             	mov    0x8(%eax),%eax
  10cd28:	f7 d0                	not    %eax
  10cd2a:	21 c2                	and    %eax,%edx
  10cd2c:	a1 b4 db 11 00       	mov    0x11dbb4,%eax
  10cd31:	8b 40 08             	mov    0x8(%eax),%eax
  10cd34:	f7 d0                	not    %eax
  10cd36:	39 c2                	cmp    %eax,%edx
  10cd38:	74 19                	je     10cd53 <ip_input+0x1f3>
  10cd3a:	a1 b8 db 11 00       	mov    0x11dbb8,%eax
  10cd3f:	8b 40 10             	mov    0x10(%eax),%eax
  10cd42:	83 f8 ff             	cmp    $0xffffffff,%eax
  10cd45:	74 0c                	je     10cd53 <ip_input+0x1f3>
  10cd47:	a1 b8 db 11 00       	mov    0x11dbb8,%eax
  10cd4c:	8b 40 10             	mov    0x10(%eax),%eax
  10cd4f:	85 c0                	test   %eax,%eax
  10cd51:	75 2a                	jne    10cd7d <ip_input+0x21d>
  10cd53:	a1 b8 db 11 00       	mov    0x11dbb8,%eax
  10cd58:	8b 50 10             	mov    0x10(%eax),%edx
  10cd5b:	a1 b4 db 11 00       	mov    0x11dbb4,%eax
  10cd60:	8b 40 08             	mov    0x8(%eax),%eax
  10cd63:	89 d1                	mov    %edx,%ecx
  10cd65:	21 c1                	and    %eax,%ecx
  10cd67:	a1 b4 db 11 00       	mov    0x11dbb4,%eax
  10cd6c:	8b 50 04             	mov    0x4(%eax),%edx
  10cd6f:	a1 b4 db 11 00       	mov    0x11dbb4,%eax
  10cd74:	8b 40 08             	mov    0x8(%eax),%eax
  10cd77:	21 d0                	and    %edx,%eax
  10cd79:	39 c1                	cmp    %eax,%ecx
  10cd7b:	74 2e                	je     10cdab <ip_input+0x24b>
  10cd7d:	a1 b8 db 11 00       	mov    0x11dbb8,%eax
  10cd82:	8b 50 10             	mov    0x10(%eax),%edx
  10cd85:	b8 c3 ad 11 00       	mov    $0x11adc3,%eax
  10cd8a:	8b 00                	mov    (%eax),%eax
  10cd8c:	39 c2                	cmp    %eax,%edx
  10cd8e:	75 02                	jne    10cd92 <ip_input+0x232>
        /* or broadcast matching this interface network address? */
        (ip_addr_isbroadcast(&(iphdr->dest), &(netif->netmask)) &&
         ip_addr_maskcmp(&(iphdr->dest), &(netif->ip_addr), &(netif->netmask))) ||
         /* or restricted broadcast? */
         ip_addr_cmp(&(iphdr->dest), IP_ADDR_BROADCAST)) {
         LWIP_DEBUGF(IP_DEBUG, ("ip_input: packet accepted on interface %c%c\n",
                       netif->name[0], netif->name[1]));
         /* break out of for loop */
         break;
  10cd90:	eb 19                	jmp    10cdab <ip_input+0x24b>
  10cd92:	a1 b4 db 11 00       	mov    0x11dbb4,%eax
  10cd97:	8b 00                	mov    (%eax),%eax
  10cd99:	a3 b4 db 11 00       	mov    %eax,0x11dbb4
  10cd9e:	a1 b4 db 11 00       	mov    0x11dbb4,%eax
  10cda3:	85 c0                	test   %eax,%eax
  10cda5:	0f 85 35 ff ff ff    	jne    10cce0 <ip_input+0x180>
      }
    }
  }
#if LWIP_DHCP
  /* Pass DHCP messages regardless of destination address. DHCP traffic is addressed
     using link layer addressing (such as Ethernet MAC) so we must not filter on IP.
     According to RFC 1542 section 3.1.1, referred by RFC 2131). */
  if (netif == NULL) {
    /* remote port is DHCP server? */
    if (IPH_PROTO(iphdr) == IP_PROTO_UDP) {
      LWIP_DEBUGF(IP_DEBUG | DBG_TRACE | 1, ("ip_input: UDP packet to DHCP client port %u\n",
        ntohs(((struct udp_hdr *)((u8_t *)iphdr + iphdrlen))->dest)));
      if (ntohs(((struct udp_hdr *)((u8_t *)iphdr + iphdrlen))->dest) == DHCP_CLIENT_PORT) {
        LWIP_DEBUGF(IP_DEBUG | DBG_TRACE | 1, ("ip_input: DHCP packet accepted.\n"));
        netif = inp;
      }
    }
  }
#endif /* LWIP_DHCP */
        /* packet not for us? */
  if (netif == NULL) {
  10cdab:	a1 b4 db 11 00       	mov    0x11dbb4,%eax
  10cdb0:	85 c0                	test   %eax,%eax
  10cdb2:	75 17                	jne    10cdcb <ip_input+0x26b>
    /* packet not for us, route or discard */
    LWIP_DEBUGF(IP_DEBUG | DBG_TRACE | 1, ("ip_input: packet not for us.\n"));
#if IP_FORWARD
    /* non-broadcast packet? */
    if (!ip_addr_isbroadcast(&(iphdr->dest), &(inp->netmask))) {
      /* try to forward IP packet on (other) interfaces */
      ip_forward(p, iphdr, inp);
    }
    else
#endif /* IP_FORWARD */
    {
      snmp_inc_ipindiscards();
    }
    pbuf_free(p);
  10cdb4:	8b 45 08             	mov    0x8(%ebp),%eax
  10cdb7:	89 04 24             	mov    %eax,(%esp)
  10cdba:	e8 01 27 00 00       	call   10f4c0 <pbuf_free>
    return ERR_OK;
  10cdbf:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
  10cdc6:	e9 97 01 00 00       	jmp    10cf62 <ip_input+0x402>
  }

#if IP_REASSEMBLY
  if ((IPH_OFFSET(iphdr) & htons(IP_OFFMASK | IP_MF)) != 0) {
  10cdcb:	a1 b8 db 11 00       	mov    0x11dbb8,%eax
  10cdd0:	0f b7 58 06          	movzwl 0x6(%eax),%ebx
  10cdd4:	c7 04 24 ff 3f 00 00 	movl   $0x3fff,(%esp)
  10cddb:	e8 a0 14 00 00       	call   10e280 <htons>
  10cde0:	21 d8                	and    %ebx,%eax
  10cde2:	66 85 c0             	test   %ax,%ax
  10cde5:	74 2b                	je     10ce12 <ip_input+0x2b2>
    LWIP_DEBUGF(IP_DEBUG, ("IP packet is a fragment (id=0x%04x tot_len=%u len=%u MF=%u offset=%u), calling ip_reass()\n",
      ntohs(IPH_ID(iphdr)), p->tot_len, ntohs(IPH_LEN(iphdr)), !!(IPH_OFFSET(iphdr) & htons(IP_MF)), (ntohs(IPH_OFFSET(iphdr)) & IP_OFFMASK)*8));
    p = ip_reass(p);
  10cde7:	8b 45 08             	mov    0x8(%ebp),%eax
  10cdea:	89 04 24             	mov    %eax,(%esp)
  10cded:	e8 ce 05 00 00       	call   10d3c0 <ip_reass>
  10cdf2:	89 45 08             	mov    %eax,0x8(%ebp)
    if (p == NULL) {
  10cdf5:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  10cdf9:	75 0c                	jne    10ce07 <ip_input+0x2a7>
      return ERR_OK;
  10cdfb:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
  10ce02:	e9 5b 01 00 00       	jmp    10cf62 <ip_input+0x402>
    }
    iphdr = p->payload;
  10ce07:	8b 45 08             	mov    0x8(%ebp),%eax
  10ce0a:	8b 40 04             	mov    0x4(%eax),%eax
  10ce0d:	a3 b8 db 11 00       	mov    %eax,0x11dbb8
  }
#else /* IP_REASSEMBLY */
  if ((IPH_OFFSET(iphdr) & htons(IP_OFFMASK | IP_MF)) != 0) {
    pbuf_free(p);
    LWIP_DEBUGF(IP_DEBUG | 2, ("IP packet dropped since it was fragmented (0x%x) (while IP_REASSEMBLY == 0).\n",
                  ntohs(IPH_OFFSET(iphdr))));
    IP_STATS_INC(ip.opterr);
    IP_STATS_INC(ip.drop);
    snmp_inc_ipunknownprotos();
    return ERR_OK;
  }
#endif /* IP_REASSEMBLY */

#if IP_OPTIONS == 0
  if (iphdrlen > IP_HLEN) {
    LWIP_DEBUGF(IP_DEBUG | 2, ("IP packet dropped since there were IP options (while IP_OPTIONS == 0).\n"));
    pbuf_free(p);
    IP_STATS_INC(ip.opterr);
    IP_STATS_INC(ip.drop);
    snmp_inc_ipunknownprotos();
    return ERR_OK;
  }
#endif /* IP_OPTIONS == 0 */

  /* send to upper layers */
  LWIP_DEBUGF(IP_DEBUG, ("ip_input: \n"));
  ip_debug_print(p);
  LWIP_DEBUGF(IP_DEBUG, ("ip_input: p->len %d p->tot_len %d\n", p->len, p->tot_len));

#if LWIP_RAW
  if (!raw_input(p, inp)) {
  10ce12:	8b 45 0c             	mov    0xc(%ebp),%eax
  10ce15:	89 44 24 04          	mov    %eax,0x4(%esp)
  10ce19:	8b 45 08             	mov    0x8(%ebp),%eax
  10ce1c:	89 04 24             	mov    %eax,(%esp)
  10ce1f:	e8 2c 2b 00 00       	call   10f950 <raw_input>
  10ce24:	85 c0                	test   %eax,%eax
  10ce26:	0f 85 2f 01 00 00    	jne    10cf5b <ip_input+0x3fb>
#endif /* LWIP_RAW */

  switch (IPH_PROTO(iphdr)) {
  10ce2c:	a1 b8 db 11 00       	mov    0x11dbb8,%eax
  10ce31:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  10ce35:	0f b7 c0             	movzwl %ax,%eax
  10ce38:	89 04 24             	mov    %eax,(%esp)
  10ce3b:	e8 70 14 00 00       	call   10e2b0 <ntohs>
  10ce40:	0f b7 c0             	movzwl %ax,%eax
  10ce43:	25 ff 00 00 00       	and    $0xff,%eax
  10ce48:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  10ce4b:	83 7d f8 06          	cmpl   $0x6,0xfffffff8(%ebp)
  10ce4f:	74 36                	je     10ce87 <ip_input+0x327>
  10ce51:	83 7d f8 06          	cmpl   $0x6,0xfffffff8(%ebp)
  10ce55:	7f 08                	jg     10ce5f <ip_input+0x2ff>
  10ce57:	83 7d f8 01          	cmpl   $0x1,0xfffffff8(%ebp)
  10ce5b:	74 41                	je     10ce9e <ip_input+0x33e>
  10ce5d:	eb 56                	jmp    10ceb5 <ip_input+0x355>
  10ce5f:	83 7d f8 11          	cmpl   $0x11,0xfffffff8(%ebp)
  10ce63:	74 0b                	je     10ce70 <ip_input+0x310>
  10ce65:	81 7d f8 aa 00 00 00 	cmpl   $0xaa,0xfffffff8(%ebp)
  10ce6c:	74 02                	je     10ce70 <ip_input+0x310>
  10ce6e:	eb 45                	jmp    10ceb5 <ip_input+0x355>
#if LWIP_UDP
  case IP_PROTO_UDP:
  case IP_PROTO_UDPLITE:
    snmp_inc_ipindelivers();
    udp_input(p, inp);
  10ce70:	8b 45 0c             	mov    0xc(%ebp),%eax
  10ce73:	89 44 24 04          	mov    %eax,0x4(%esp)
  10ce77:	8b 45 08             	mov    0x8(%ebp),%eax
  10ce7a:	89 04 24             	mov    %eax,(%esp)
  10ce7d:	e8 7e 7d 00 00       	call   114c00 <udp_input>
    break;
  10ce82:	e9 d4 00 00 00       	jmp    10cf5b <ip_input+0x3fb>
#endif /* LWIP_UDP */
#if LWIP_TCP
  case IP_PROTO_TCP:
    snmp_inc_ipindelivers();
    tcp_input(p, inp);
  10ce87:	8b 45 0c             	mov    0xc(%ebp),%eax
  10ce8a:	89 44 24 04          	mov    %eax,0x4(%esp)
  10ce8e:	8b 45 08             	mov    0x8(%ebp),%eax
  10ce91:	89 04 24             	mov    %eax,(%esp)
  10ce94:	e8 f7 59 00 00       	call   112890 <tcp_input>
    break;
  10ce99:	e9 bd 00 00 00       	jmp    10cf5b <ip_input+0x3fb>
#endif /* LWIP_TCP */
  case IP_PROTO_ICMP:
    snmp_inc_ipindelivers();
    icmp_input(p, inp);
  10ce9e:	8b 45 0c             	mov    0xc(%ebp),%eax
  10cea1:	89 44 24 04          	mov    %eax,0x4(%esp)
  10cea5:	8b 45 08             	mov    0x8(%ebp),%eax
  10cea8:	89 04 24             	mov    %eax,(%esp)
  10ceab:	e8 30 f8 ff ff       	call   10c6e0 <icmp_input>
    break;
  10ceb0:	e9 a6 00 00 00       	jmp    10cf5b <ip_input+0x3fb>
  default:
    /* send ICMP destination protocol unreachable unless is was a broadcast */
    if (!ip_addr_isbroadcast(&(iphdr->dest), &(inp->netmask)) &&
  10ceb5:	a1 b8 db 11 00       	mov    0x11dbb8,%eax
  10ceba:	8b 50 10             	mov    0x10(%eax),%edx
  10cebd:	8b 45 0c             	mov    0xc(%ebp),%eax
  10cec0:	8b 40 08             	mov    0x8(%eax),%eax
  10cec3:	f7 d0                	not    %eax
  10cec5:	21 c2                	and    %eax,%edx
  10cec7:	8b 45 0c             	mov    0xc(%ebp),%eax
  10ceca:	8b 40 08             	mov    0x8(%eax),%eax
  10cecd:	f7 d0                	not    %eax
  10cecf:	39 c2                	cmp    %eax,%edx
  10ced1:	74 5d                	je     10cf30 <ip_input+0x3d0>
  10ced3:	a1 b8 db 11 00       	mov    0x11dbb8,%eax
  10ced8:	8b 40 10             	mov    0x10(%eax),%eax
  10cedb:	83 f8 ff             	cmp    $0xffffffff,%eax
  10cede:	74 50                	je     10cf30 <ip_input+0x3d0>
  10cee0:	a1 b8 db 11 00       	mov    0x11dbb8,%eax
  10cee5:	8b 40 10             	mov    0x10(%eax),%eax
  10cee8:	85 c0                	test   %eax,%eax
  10ceea:	74 44                	je     10cf30 <ip_input+0x3d0>
  10ceec:	a1 b8 db 11 00       	mov    0x11dbb8,%eax
  10cef1:	8b 58 10             	mov    0x10(%eax),%ebx
  10cef4:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  10cefb:	e8 10 14 00 00       	call   10e310 <ntohl>
  10cf00:	21 c3                	and    %eax,%ebx
  10cf02:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  10cf09:	e8 02 14 00 00       	call   10e310 <ntohl>
  10cf0e:	39 c3                	cmp    %eax,%ebx
  10cf10:	74 1e                	je     10cf30 <ip_input+0x3d0>
       !ip_addr_ismulticast(&(iphdr->dest))) {
      p->payload = iphdr;
  10cf12:	a1 b8 db 11 00       	mov    0x11dbb8,%eax
  10cf17:	8b 55 08             	mov    0x8(%ebp),%edx
  10cf1a:	89 42 04             	mov    %eax,0x4(%edx)
      icmp_dest_unreach(p, ICMP_DUR_PROTO);
  10cf1d:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
  10cf24:	00 
  10cf25:	8b 45 08             	mov    0x8(%ebp),%eax
  10cf28:	89 04 24             	mov    %eax,(%esp)
  10cf2b:	e8 90 fa ff ff       	call   10c9c0 <icmp_dest_unreach>
    }
    pbuf_free(p);
  10cf30:	8b 45 08             	mov    0x8(%ebp),%eax
  10cf33:	89 04 24             	mov    %eax,(%esp)
  10cf36:	e8 85 25 00 00       	call   10f4c0 <pbuf_free>

    LWIP_DEBUGF(IP_DEBUG | 2, ("Unsupported transport protocol %d\n", IPH_PROTO(iphdr)));

    IP_STATS_INC(ip.proterr);
  10cf3b:	0f b7 05 26 15 14 00 	movzwl 0x141526,%eax
  10cf42:	83 c0 01             	add    $0x1,%eax
  10cf45:	66 a3 26 15 14 00    	mov    %ax,0x141526
    IP_STATS_INC(ip.drop);
  10cf4b:	0f b7 05 1c 15 14 00 	movzwl 0x14151c,%eax
  10cf52:	83 c0 01             	add    $0x1,%eax
  10cf55:	66 a3 1c 15 14 00    	mov    %ax,0x14151c
    snmp_inc_ipunknownprotos();

  }
#if LWIP_RAW
  } /* LWIP_RAW */
#endif
  return ERR_OK;
  10cf5b:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
  10cf62:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
}
  10cf65:	83 c4 14             	add    $0x14,%esp
  10cf68:	5b                   	pop    %ebx
  10cf69:	5d                   	pop    %ebp
  10cf6a:	c3                   	ret    
  10cf6b:	90                   	nop    
  10cf6c:	8d 74 26 00          	lea    0x0(%esi),%esi

0010cf70 <ip_output_if>:


/* ip_output_if:
 *
 * Sends an IP packet on a network interface. This function constructs
 * the IP header and calculates the IP header checksum. If the source
 * IP address is NULL, the IP address of the outgoing network
 * interface is filled in as source address.
 */

err_t
ip_output_if(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,
             u8_t ttl, u8_t tos,
             u8_t proto, struct netif *netif)
{
  10cf70:	55                   	push   %ebp
  10cf71:	89 e5                	mov    %esp,%ebp
  10cf73:	56                   	push   %esi
  10cf74:	53                   	push   %ebx
  10cf75:	83 ec 40             	sub    $0x40,%esp
  10cf78:	8b 45 14             	mov    0x14(%ebp),%eax
  10cf7b:	8b 55 18             	mov    0x18(%ebp),%edx
  10cf7e:	8b 4d 1c             	mov    0x1c(%ebp),%ecx
  10cf81:	88 45 f4             	mov    %al,0xfffffff4(%ebp)
  10cf84:	88 55 f0             	mov    %dl,0xfffffff0(%ebp)
  10cf87:	88 4d ec             	mov    %cl,0xffffffec(%ebp)
  static struct ip_hdr *iphdr;
  static u16_t ip_id = 0;

  snmp_inc_ipoutrequests();

  if (dest != IP_HDRINCL) {
  10cf8a:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  10cf8e:	0f 84 e0 01 00 00    	je     10d174 <ip_output_if+0x204>
    if (pbuf_header(p, IP_HLEN)) {
  10cf94:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  10cf9b:	00 
  10cf9c:	8b 45 08             	mov    0x8(%ebp),%eax
  10cf9f:	89 04 24             	mov    %eax,(%esp)
  10cfa2:	e8 19 24 00 00       	call   10f3c0 <pbuf_header>
  10cfa7:	84 c0                	test   %al,%al
  10cfa9:	74 1c                	je     10cfc7 <ip_output_if+0x57>
      LWIP_DEBUGF(IP_DEBUG | 2, ("ip_output: not enough room for IP header in pbuf\n"));

      IP_STATS_INC(ip.err);
  10cfab:	0f b7 05 2a 15 14 00 	movzwl 0x14152a,%eax
  10cfb2:	83 c0 01             	add    $0x1,%eax
  10cfb5:	66 a3 2a 15 14 00    	mov    %ax,0x14152a
      snmp_inc_ipoutdiscards();
      return ERR_BUF;
  10cfbb:	c7 45 d0 fe ff ff ff 	movl   $0xfffffffe,0xffffffd0(%ebp)
  10cfc2:	e9 35 02 00 00       	jmp    10d1fc <ip_output_if+0x28c>
    }

    iphdr = p->payload;
  10cfc7:	8b 45 08             	mov    0x8(%ebp),%eax
  10cfca:	8b 40 04             	mov    0x4(%eax),%eax
  10cfcd:	a3 c0 db 11 00       	mov    %eax,0x11dbc0

    IPH_TTL_SET(iphdr, ttl);
  10cfd2:	8b 1d c0 db 11 00    	mov    0x11dbc0,%ebx
  10cfd8:	a1 c0 db 11 00       	mov    0x11dbc0,%eax
  10cfdd:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  10cfe1:	0f b7 c0             	movzwl %ax,%eax
  10cfe4:	89 04 24             	mov    %eax,(%esp)
  10cfe7:	e8 c4 12 00 00       	call   10e2b0 <ntohs>
  10cfec:	0f b6 d0             	movzbl %al,%edx
  10cfef:	0f b6 45 f4          	movzbl 0xfffffff4(%ebp),%eax
  10cff3:	c1 e0 08             	shl    $0x8,%eax
  10cff6:	09 d0                	or     %edx,%eax
  10cff8:	0f b7 c0             	movzwl %ax,%eax
  10cffb:	89 04 24             	mov    %eax,(%esp)
  10cffe:	e8 7d 12 00 00       	call   10e280 <htons>
  10d003:	66 89 43 08          	mov    %ax,0x8(%ebx)
    IPH_PROTO_SET(iphdr, proto);
  10d007:	8b 1d c0 db 11 00    	mov    0x11dbc0,%ebx
  10d00d:	0f b6 75 ec          	movzbl 0xffffffec(%ebp),%esi
  10d011:	a1 c0 db 11 00       	mov    0x11dbc0,%eax
  10d016:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  10d01a:	0f b7 c0             	movzwl %ax,%eax
  10d01d:	89 04 24             	mov    %eax,(%esp)
  10d020:	e8 8b 12 00 00       	call   10e2b0 <ntohs>
  10d025:	66 c1 e8 08          	shr    $0x8,%ax
  10d029:	0f b7 c0             	movzwl %ax,%eax
  10d02c:	c1 e0 08             	shl    $0x8,%eax
  10d02f:	09 f0                	or     %esi,%eax
  10d031:	0f b7 c0             	movzwl %ax,%eax
  10d034:	89 04 24             	mov    %eax,(%esp)
  10d037:	e8 44 12 00 00       	call   10e280 <htons>
  10d03c:	66 89 43 08          	mov    %ax,0x8(%ebx)

    ip_addr_set(&(iphdr->dest), dest);
  10d040:	a1 c0 db 11 00       	mov    0x11dbc0,%eax
  10d045:	89 45 d4             	mov    %eax,0xffffffd4(%ebp)
  10d048:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  10d04c:	74 0a                	je     10d058 <ip_output_if+0xe8>
  10d04e:	8b 45 10             	mov    0x10(%ebp),%eax
  10d051:	8b 00                	mov    (%eax),%eax
  10d053:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
  10d056:	eb 07                	jmp    10d05f <ip_output_if+0xef>
  10d058:	c7 45 d8 00 00 00 00 	movl   $0x0,0xffffffd8(%ebp)
  10d05f:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  10d062:	8b 55 d4             	mov    0xffffffd4(%ebp),%edx
  10d065:	89 42 10             	mov    %eax,0x10(%edx)

    IPH_VHLTOS_SET(iphdr, 4, IP_HLEN / 4, tos);
  10d068:	8b 1d c0 db 11 00    	mov    0x11dbc0,%ebx
  10d06e:	0f b6 45 f0          	movzbl 0xfffffff0(%ebp),%eax
  10d072:	80 cc 45             	or     $0x45,%ah
  10d075:	0f b7 c0             	movzwl %ax,%eax
  10d078:	89 04 24             	mov    %eax,(%esp)
  10d07b:	e8 00 12 00 00       	call   10e280 <htons>
  10d080:	66 89 03             	mov    %ax,(%ebx)
    IPH_LEN_SET(iphdr, htons(p->tot_len));
  10d083:	8b 1d c0 db 11 00    	mov    0x11dbc0,%ebx
  10d089:	8b 45 08             	mov    0x8(%ebp),%eax
  10d08c:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  10d090:	0f b7 c0             	movzwl %ax,%eax
  10d093:	89 04 24             	mov    %eax,(%esp)
  10d096:	e8 e5 11 00 00       	call   10e280 <htons>
  10d09b:	66 89 43 02          	mov    %ax,0x2(%ebx)
    IPH_OFFSET_SET(iphdr, htons(IP_DF));
  10d09f:	8b 1d c0 db 11 00    	mov    0x11dbc0,%ebx
  10d0a5:	c7 04 24 00 40 00 00 	movl   $0x4000,(%esp)
  10d0ac:	e8 cf 11 00 00       	call   10e280 <htons>
  10d0b1:	66 89 43 06          	mov    %ax,0x6(%ebx)
    IPH_ID_SET(iphdr, htons(ip_id));
  10d0b5:	8b 1d c0 db 11 00    	mov    0x11dbc0,%ebx
  10d0bb:	0f b7 05 bc db 11 00 	movzwl 0x11dbbc,%eax
  10d0c2:	0f b7 c0             	movzwl %ax,%eax
  10d0c5:	89 04 24             	mov    %eax,(%esp)
  10d0c8:	e8 b3 11 00 00       	call   10e280 <htons>
  10d0cd:	66 89 43 04          	mov    %ax,0x4(%ebx)
    ++ip_id;
  10d0d1:	0f b7 05 bc db 11 00 	movzwl 0x11dbbc,%eax
  10d0d8:	83 c0 01             	add    $0x1,%eax
  10d0db:	66 a3 bc db 11 00    	mov    %ax,0x11dbbc

    if (ip_addr_isany(src)) {
  10d0e1:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  10d0e5:	74 09                	je     10d0f0 <ip_output_if+0x180>
  10d0e7:	8b 45 0c             	mov    0xc(%ebp),%eax
  10d0ea:	8b 00                	mov    (%eax),%eax
  10d0ec:	85 c0                	test   %eax,%eax
  10d0ee:	75 30                	jne    10d120 <ip_output_if+0x1b0>
      ip_addr_set(&(iphdr->src), &(netif->ip_addr));
  10d0f0:	8b 15 c0 db 11 00    	mov    0x11dbc0,%edx
  10d0f6:	89 55 dc             	mov    %edx,0xffffffdc(%ebp)
  10d0f9:	8b 45 20             	mov    0x20(%ebp),%eax
  10d0fc:	83 c0 04             	add    $0x4,%eax
  10d0ff:	85 c0                	test   %eax,%eax
  10d101:	74 0b                	je     10d10e <ip_output_if+0x19e>
  10d103:	8b 45 20             	mov    0x20(%ebp),%eax
  10d106:	8b 40 04             	mov    0x4(%eax),%eax
  10d109:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
  10d10c:	eb 07                	jmp    10d115 <ip_output_if+0x1a5>
  10d10e:	c7 45 e0 00 00 00 00 	movl   $0x0,0xffffffe0(%ebp)
  10d115:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
  10d118:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  10d11b:	89 50 0c             	mov    %edx,0xc(%eax)
  10d11e:	eb 28                	jmp    10d148 <ip_output_if+0x1d8>
    } else {
      ip_addr_set(&(iphdr->src), src);
  10d120:	a1 c0 db 11 00       	mov    0x11dbc0,%eax
  10d125:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
  10d128:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  10d12c:	74 0a                	je     10d138 <ip_output_if+0x1c8>
  10d12e:	8b 45 0c             	mov    0xc(%ebp),%eax
  10d131:	8b 00                	mov    (%eax),%eax
  10d133:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
  10d136:	eb 07                	jmp    10d13f <ip_output_if+0x1cf>
  10d138:	c7 45 e8 00 00 00 00 	movl   $0x0,0xffffffe8(%ebp)
  10d13f:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  10d142:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
  10d145:	89 42 0c             	mov    %eax,0xc(%edx)
    }

    IPH_CHKSUM_SET(iphdr, 0);
  10d148:	a1 c0 db 11 00       	mov    0x11dbc0,%eax
  10d14d:	66 c7 40 0a 00 00    	movw   $0x0,0xa(%eax)
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  10d153:	8b 1d c0 db 11 00    	mov    0x11dbc0,%ebx
  10d159:	a1 c0 db 11 00       	mov    0x11dbc0,%eax
  10d15e:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  10d165:	00 
  10d166:	89 04 24             	mov    %eax,(%esp)
  10d169:	e8 22 0c 00 00       	call   10dd90 <inet_chksum>
  10d16e:	66 89 43 0a          	mov    %ax,0xa(%ebx)
  10d172:	eb 16                	jmp    10d18a <ip_output_if+0x21a>
  } else {
    iphdr = p->payload;
  10d174:	8b 45 08             	mov    0x8(%ebp),%eax
  10d177:	8b 40 04             	mov    0x4(%eax),%eax
  10d17a:	a3 c0 db 11 00       	mov    %eax,0x11dbc0
    dest = &(iphdr->dest);
  10d17f:	a1 c0 db 11 00       	mov    0x11dbc0,%eax
  10d184:	83 c0 10             	add    $0x10,%eax
  10d187:	89 45 10             	mov    %eax,0x10(%ebp)
  }

#if IP_FRAG
  /* don't fragment if interface has mtu set to 0 [loopif] */
  if (netif->mtu && (p->tot_len > netif->mtu))
  10d18a:	8b 45 20             	mov    0x20(%ebp),%eax
  10d18d:	0f b7 40 28          	movzwl 0x28(%eax),%eax
  10d191:	66 85 c0             	test   %ax,%ax
  10d194:	74 34                	je     10d1ca <ip_output_if+0x25a>
  10d196:	8b 45 08             	mov    0x8(%ebp),%eax
  10d199:	0f b7 50 08          	movzwl 0x8(%eax),%edx
  10d19d:	8b 45 20             	mov    0x20(%ebp),%eax
  10d1a0:	0f b7 40 28          	movzwl 0x28(%eax),%eax
  10d1a4:	66 39 c2             	cmp    %ax,%dx
  10d1a7:	76 21                	jbe    10d1ca <ip_output_if+0x25a>
    return ip_frag(p,netif,dest);
  10d1a9:	8b 45 10             	mov    0x10(%ebp),%eax
  10d1ac:	89 44 24 08          	mov    %eax,0x8(%esp)
  10d1b0:	8b 45 20             	mov    0x20(%ebp),%eax
  10d1b3:	89 44 24 04          	mov    %eax,0x4(%esp)
  10d1b7:	8b 45 08             	mov    0x8(%ebp),%eax
  10d1ba:	89 04 24             	mov    %eax,(%esp)
  10d1bd:	e8 7e 07 00 00       	call   10d940 <ip_frag>
  10d1c2:	0f be c0             	movsbl %al,%eax
  10d1c5:	89 45 d0             	mov    %eax,0xffffffd0(%ebp)
  10d1c8:	eb 32                	jmp    10d1fc <ip_output_if+0x28c>
#endif

  IP_STATS_INC(ip.xmit);
  10d1ca:	0f b7 05 14 15 14 00 	movzwl 0x141514,%eax
  10d1d1:	83 c0 01             	add    $0x1,%eax
  10d1d4:	66 a3 14 15 14 00    	mov    %ax,0x141514

  LWIP_DEBUGF(IP_DEBUG, ("ip_output_if: %c%c%u\n", netif->name[0], netif->name[1], netif->num));
  ip_debug_print(p);

  LWIP_DEBUGF(IP_DEBUG, ("netif->output()"));

  return netif->output(netif, p, dest);
  10d1da:	8b 45 20             	mov    0x20(%ebp),%eax
  10d1dd:	8b 50 14             	mov    0x14(%eax),%edx
  10d1e0:	8b 45 10             	mov    0x10(%ebp),%eax
  10d1e3:	89 44 24 08          	mov    %eax,0x8(%esp)
  10d1e7:	8b 45 08             	mov    0x8(%ebp),%eax
  10d1ea:	89 44 24 04          	mov    %eax,0x4(%esp)
  10d1ee:	8b 45 20             	mov    0x20(%ebp),%eax
  10d1f1:	89 04 24             	mov    %eax,(%esp)
  10d1f4:	ff d2                	call   *%edx
  10d1f6:	0f be c0             	movsbl %al,%eax
  10d1f9:	89 45 d0             	mov    %eax,0xffffffd0(%ebp)
  10d1fc:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
}
  10d1ff:	83 c4 40             	add    $0x40,%esp
  10d202:	5b                   	pop    %ebx
  10d203:	5e                   	pop    %esi
  10d204:	5d                   	pop    %ebp
  10d205:	c3                   	ret    
  10d206:	8d 76 00             	lea    0x0(%esi),%esi
  10d209:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

0010d210 <ip_output>:

/* ip_output:
 *
 * Simple interface to ip_output_if. It finds the outgoing network
 * interface and calls upon ip_output_if to do the actual work.
 */

err_t
ip_output(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,
          u8_t ttl, u8_t tos, u8_t proto)
{
  10d210:	55                   	push   %ebp
  10d211:	89 e5                	mov    %esp,%ebp
  10d213:	53                   	push   %ebx
  10d214:	83 ec 44             	sub    $0x44,%esp
  10d217:	8b 45 14             	mov    0x14(%ebp),%eax
  10d21a:	8b 55 18             	mov    0x18(%ebp),%edx
  10d21d:	8b 4d 1c             	mov    0x1c(%ebp),%ecx
  10d220:	88 45 e8             	mov    %al,0xffffffe8(%ebp)
  10d223:	88 55 e4             	mov    %dl,0xffffffe4(%ebp)
  10d226:	88 4d e0             	mov    %cl,0xffffffe0(%ebp)
  struct netif *netif;

  if ((netif = ip_route(dest)) == NULL) {
  10d229:	8b 45 10             	mov    0x10(%ebp),%eax
  10d22c:	89 04 24             	mov    %eax,(%esp)
  10d22f:	e8 cc f8 ff ff       	call   10cb00 <ip_route>
  10d234:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  10d237:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  10d23b:	75 19                	jne    10d256 <ip_output+0x46>
    LWIP_DEBUGF(IP_DEBUG | 2, ("ip_output: No route to 0x%lx\n", dest->addr));

    IP_STATS_INC(ip.rterr);
  10d23d:	0f b7 05 24 15 14 00 	movzwl 0x141524,%eax
  10d244:	83 c0 01             	add    $0x1,%eax
  10d247:	66 a3 24 15 14 00    	mov    %ax,0x141524
    snmp_inc_ipoutdiscards();
    return ERR_RTE;
  10d24d:	c7 45 dc f7 ff ff ff 	movl   $0xfffffff7,0xffffffdc(%ebp)
  10d254:	eb 3e                	jmp    10d294 <ip_output+0x84>
  }

  return ip_output_if(p, src, dest, ttl, tos, proto, netif);
  10d256:	0f b6 55 e0          	movzbl 0xffffffe0(%ebp),%edx
  10d25a:	0f b6 4d e4          	movzbl 0xffffffe4(%ebp),%ecx
  10d25e:	0f b6 5d e8          	movzbl 0xffffffe8(%ebp),%ebx
  10d262:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10d265:	89 44 24 18          	mov    %eax,0x18(%esp)
  10d269:	89 54 24 14          	mov    %edx,0x14(%esp)
  10d26d:	89 4c 24 10          	mov    %ecx,0x10(%esp)
  10d271:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
  10d275:	8b 45 10             	mov    0x10(%ebp),%eax
  10d278:	89 44 24 08          	mov    %eax,0x8(%esp)
  10d27c:	8b 45 0c             	mov    0xc(%ebp),%eax
  10d27f:	89 44 24 04          	mov    %eax,0x4(%esp)
  10d283:	8b 45 08             	mov    0x8(%ebp),%eax
  10d286:	89 04 24             	mov    %eax,(%esp)
  10d289:	e8 e2 fc ff ff       	call   10cf70 <ip_output_if>
  10d28e:	0f be c0             	movsbl %al,%eax
  10d291:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
  10d294:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
}
  10d297:	83 c4 44             	add    $0x44,%esp
  10d29a:	5b                   	pop    %ebx
  10d29b:	5d                   	pop    %ebp
  10d29c:	c3                   	ret    
  10d29d:	90                   	nop    
  10d29e:	90                   	nop    
  10d29f:	90                   	nop    

0010d2a0 <copy_from_pbuf>:
 */
static struct pbuf *
copy_from_pbuf(struct pbuf *p, u16_t * offset,
           u8_t * buffer, u16_t len)
{
  10d2a0:	55                   	push   %ebp
  10d2a1:	89 e5                	mov    %esp,%ebp
  10d2a3:	83 ec 28             	sub    $0x28,%esp
  10d2a6:	8b 45 14             	mov    0x14(%ebp),%eax
  10d2a9:	66 89 45 ec          	mov    %ax,0xffffffec(%ebp)
  u16_t l;

  p->payload = (u8_t *)p->payload + *offset;
  10d2ad:	8b 45 08             	mov    0x8(%ebp),%eax
  10d2b0:	8b 40 04             	mov    0x4(%eax),%eax
  10d2b3:	89 c2                	mov    %eax,%edx
  10d2b5:	8b 45 0c             	mov    0xc(%ebp),%eax
  10d2b8:	0f b7 00             	movzwl (%eax),%eax
  10d2bb:	0f b7 c0             	movzwl %ax,%eax
  10d2be:	01 c2                	add    %eax,%edx
  10d2c0:	8b 45 08             	mov    0x8(%ebp),%eax
  10d2c3:	89 50 04             	mov    %edx,0x4(%eax)
  p->len -= *offset;
  10d2c6:	8b 45 08             	mov    0x8(%ebp),%eax
  10d2c9:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
  10d2cd:	8b 45 0c             	mov    0xc(%ebp),%eax
  10d2d0:	0f b7 00             	movzwl (%eax),%eax
  10d2d3:	66 29 c2             	sub    %ax,%dx
  10d2d6:	8b 45 08             	mov    0x8(%ebp),%eax
  10d2d9:	66 89 50 0a          	mov    %dx,0xa(%eax)
  while (len) {
  10d2dd:	eb 74                	jmp    10d353 <copy_from_pbuf+0xb3>
    l = len < p->len ? len : p->len;
  10d2df:	8b 45 08             	mov    0x8(%ebp),%eax
  10d2e2:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  10d2e6:	0f b7 55 ec          	movzwl 0xffffffec(%ebp),%edx
  10d2ea:	66 89 55 e8          	mov    %dx,0xffffffe8(%ebp)
  10d2ee:	66 89 45 ea          	mov    %ax,0xffffffea(%ebp)
  10d2f2:	0f b7 45 e8          	movzwl 0xffffffe8(%ebp),%eax
  10d2f6:	66 39 45 ea          	cmp    %ax,0xffffffea(%ebp)
  10d2fa:	76 08                	jbe    10d304 <copy_from_pbuf+0x64>
  10d2fc:	0f b7 55 e8          	movzwl 0xffffffe8(%ebp),%edx
  10d300:	66 89 55 ea          	mov    %dx,0xffffffea(%ebp)
  10d304:	0f b7 45 ea          	movzwl 0xffffffea(%ebp),%eax
  10d308:	66 89 45 fe          	mov    %ax,0xfffffffe(%ebp)
    memcpy(buffer, p->payload, l);
  10d30c:	0f b7 55 fe          	movzwl 0xfffffffe(%ebp),%edx
  10d310:	8b 45 08             	mov    0x8(%ebp),%eax
  10d313:	8b 40 04             	mov    0x4(%eax),%eax
  10d316:	89 54 24 08          	mov    %edx,0x8(%esp)
  10d31a:	89 44 24 04          	mov    %eax,0x4(%esp)
  10d31e:	8b 45 10             	mov    0x10(%ebp),%eax
  10d321:	89 04 24             	mov    %eax,(%esp)
  10d324:	e8 67 8b ff ff       	call   105e90 <memcpy>
    buffer += l;
  10d329:	0f b7 45 fe          	movzwl 0xfffffffe(%ebp),%eax
  10d32d:	01 45 10             	add    %eax,0x10(%ebp)
    len -= l;
  10d330:	0f b7 45 fe          	movzwl 0xfffffffe(%ebp),%eax
  10d334:	66 29 45 ec          	sub    %ax,0xffffffec(%ebp)
    if (len)
  10d338:	66 83 7d ec 00       	cmpw   $0x0,0xffffffec(%ebp)
  10d33d:	74 0a                	je     10d349 <copy_from_pbuf+0xa9>
      p = p->next;
  10d33f:	8b 45 08             	mov    0x8(%ebp),%eax
  10d342:	8b 00                	mov    (%eax),%eax
  10d344:	89 45 08             	mov    %eax,0x8(%ebp)
  10d347:	eb 0a                	jmp    10d353 <copy_from_pbuf+0xb3>
    else
      *offset = l;
  10d349:	8b 55 0c             	mov    0xc(%ebp),%edx
  10d34c:	0f b7 45 fe          	movzwl 0xfffffffe(%ebp),%eax
  10d350:	66 89 02             	mov    %ax,(%edx)
  10d353:	66 83 7d ec 00       	cmpw   $0x0,0xffffffec(%ebp)
  10d358:	75 85                	jne    10d2df <copy_from_pbuf+0x3f>
  }
  return p;
  10d35a:	8b 45 08             	mov    0x8(%ebp),%eax
}
  10d35d:	c9                   	leave  
  10d35e:	c3                   	ret    
  10d35f:	90                   	nop    

0010d360 <ip_reass_timer>:

#define IP_REASS_BUFSIZE 5760
#define IP_REASS_MAXAGE 30
#define IP_REASS_TMO 1000

static u8_t ip_reassbuf[IP_HLEN + IP_REASS_BUFSIZE];
static u8_t ip_reassbitmap[IP_REASS_BUFSIZE / (8 * 8)];
static const u8_t bitmap_bits[8] = { 0xff, 0x7f, 0x3f, 0x1f,
  0x0f, 0x07, 0x03, 0x01
};
static u16_t ip_reasslen;
static u8_t ip_reassflags;
#define IP_REASS_FLAG_LASTFRAG 0x01

static u8_t ip_reasstmr;

/* Reassembly timer */ 
static void 
ip_reass_timer(void *arg)
{
  10d360:	55                   	push   %ebp
  10d361:	89 e5                	mov    %esp,%ebp
  10d363:	83 ec 18             	sub    $0x18,%esp
  (void)arg;
  if (ip_reasstmr > 1) {
  10d366:	0f b6 05 dd f2 11 00 	movzbl 0x11f2dd,%eax
  10d36d:	3c 01                	cmp    $0x1,%al
  10d36f:	76 2d                	jbe    10d39e <ip_reass_timer+0x3e>
    ip_reasstmr--;
  10d371:	0f b6 05 dd f2 11 00 	movzbl 0x11f2dd,%eax
  10d378:	83 e8 01             	sub    $0x1,%eax
  10d37b:	a2 dd f2 11 00       	mov    %al,0x11f2dd
    sys_timeout(IP_REASS_TMO, ip_reass_timer, NULL);
  10d380:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  10d387:	00 
  10d388:	c7 44 24 04 60 d3 10 	movl   $0x10d360,0x4(%esp)
  10d38f:	00 
  10d390:	c7 04 24 e8 03 00 00 	movl   $0x3e8,(%esp)
  10d397:	e8 64 2b 00 00       	call   10ff00 <sys_timeout>
  10d39c:	eb 12                	jmp    10d3b0 <ip_reass_timer+0x50>
  } else if (ip_reasstmr == 1)
  10d39e:	0f b6 05 dd f2 11 00 	movzbl 0x11f2dd,%eax
  10d3a5:	3c 01                	cmp    $0x1,%al
  10d3a7:	75 07                	jne    10d3b0 <ip_reass_timer+0x50>
  ip_reasstmr = 0;
  10d3a9:	c6 05 dd f2 11 00 00 	movb   $0x0,0x11f2dd
}
  10d3b0:	c9                   	leave  
  10d3b1:	c3                   	ret    
  10d3b2:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi
  10d3b9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

0010d3c0 <ip_reass>:

struct pbuf *
ip_reass(struct pbuf *p)
{
  10d3c0:	55                   	push   %ebp
  10d3c1:	89 e5                	mov    %esp,%ebp
  10d3c3:	56                   	push   %esi
  10d3c4:	53                   	push   %ebx
  10d3c5:	83 ec 40             	sub    $0x40,%esp
  struct pbuf *q;
  struct ip_hdr *fraghdr, *iphdr;
  u16_t offset, len;
  u16_t i;

  IPFRAG_STATS_INC(ip_frag.recv);
  10d3c8:	0f b7 05 fe 14 14 00 	movzwl 0x1414fe,%eax
  10d3cf:	83 c0 01             	add    $0x1,%eax
  10d3d2:	66 a3 fe 14 14 00    	mov    %ax,0x1414fe

  iphdr = (struct ip_hdr *) ip_reassbuf;
  10d3d8:	c7 45 f0 e0 db 11 00 	movl   $0x11dbe0,0xfffffff0(%ebp)
  fraghdr = (struct ip_hdr *) p->payload;
  10d3df:	8b 45 08             	mov    0x8(%ebp),%eax
  10d3e2:	8b 40 04             	mov    0x4(%eax),%eax
  10d3e5:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  /* If ip_reasstmr is zero, no packet is present in the buffer, so we
     write the IP header of the fragment into the reassembly
     buffer. The timer is updated with the maximum age. */
  if (ip_reasstmr == 0) {
  10d3e8:	0f b6 05 dd f2 11 00 	movzbl 0x11f2dd,%eax
  10d3ef:	84 c0                	test   %al,%al
  10d3f1:	75 60                	jne    10d453 <ip_reass+0x93>
    LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass: new packet\n"));
    memcpy(iphdr, fraghdr, IP_HLEN);
  10d3f3:	c7 44 24 08 14 00 00 	movl   $0x14,0x8(%esp)
  10d3fa:	00 
  10d3fb:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10d3fe:	89 44 24 04          	mov    %eax,0x4(%esp)
  10d402:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10d405:	89 04 24             	mov    %eax,(%esp)
  10d408:	e8 83 8a ff ff       	call   105e90 <memcpy>
    ip_reasstmr = IP_REASS_MAXAGE;
  10d40d:	c6 05 dd f2 11 00 1e 	movb   $0x1e,0x11f2dd
    sys_timeout(IP_REASS_TMO, ip_reass_timer, NULL);
  10d414:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  10d41b:	00 
  10d41c:	c7 44 24 04 60 d3 10 	movl   $0x10d360,0x4(%esp)
  10d423:	00 
  10d424:	c7 04 24 e8 03 00 00 	movl   $0x3e8,(%esp)
  10d42b:	e8 d0 2a 00 00       	call   10ff00 <sys_timeout>
    ip_reassflags = 0;
  10d430:	c6 05 dc f2 11 00 00 	movb   $0x0,0x11f2dc
    /* Clear the bitmap. */
    memset(ip_reassbitmap, 0, sizeof(ip_reassbitmap));
  10d437:	c7 44 24 08 5a 00 00 	movl   $0x5a,0x8(%esp)
  10d43e:	00 
  10d43f:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  10d446:	00 
  10d447:	c7 04 24 80 f2 11 00 	movl   $0x11f280,(%esp)
  10d44e:	e8 7d 8a ff ff       	call   105ed0 <memset>
  }

  /* Check if the incoming fragment matches the one currently present
     in the reasembly buffer. If so, we proceed with copying the
     fragment into the buffer. */
  if (ip_addr_cmp(&iphdr->src, &fraghdr->src) &&
  10d453:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10d456:	8b 50 0c             	mov    0xc(%eax),%edx
  10d459:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10d45c:	8b 40 0c             	mov    0xc(%eax),%eax
  10d45f:	39 c2                	cmp    %eax,%edx
  10d461:	0f 85 9e 04 00 00    	jne    10d905 <ip_reass+0x545>
  10d467:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10d46a:	8b 50 10             	mov    0x10(%eax),%edx
  10d46d:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10d470:	8b 40 10             	mov    0x10(%eax),%eax
  10d473:	39 c2                	cmp    %eax,%edx
  10d475:	0f 85 8a 04 00 00    	jne    10d905 <ip_reass+0x545>
  10d47b:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10d47e:	0f b7 50 04          	movzwl 0x4(%eax),%edx
  10d482:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10d485:	0f b7 40 04          	movzwl 0x4(%eax),%eax
  10d489:	66 39 c2             	cmp    %ax,%dx
  10d48c:	0f 85 73 04 00 00    	jne    10d905 <ip_reass+0x545>
      ip_addr_cmp(&iphdr->dest, &fraghdr->dest) &&
      IPH_ID(iphdr) == IPH_ID(fraghdr)) {
    LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass: matching old packet\n"));
    IPFRAG_STATS_INC(ip_frag.cachehit);
  10d492:	0f b7 05 12 15 14 00 	movzwl 0x141512,%eax
  10d499:	83 c0 01             	add    $0x1,%eax
  10d49c:	66 a3 12 15 14 00    	mov    %ax,0x141512
    /* Find out the offset in the reassembly buffer where we should
       copy the fragment. */
    len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  10d4a2:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10d4a5:	0f b7 40 02          	movzwl 0x2(%eax),%eax
  10d4a9:	0f b7 c0             	movzwl %ax,%eax
  10d4ac:	89 04 24             	mov    %eax,(%esp)
  10d4af:	e8 fc 0d 00 00       	call   10e2b0 <ntohs>
  10d4b4:	89 c3                	mov    %eax,%ebx
  10d4b6:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10d4b9:	0f b7 00             	movzwl (%eax),%eax
  10d4bc:	0f b7 c0             	movzwl %ax,%eax
  10d4bf:	89 04 24             	mov    %eax,(%esp)
  10d4c2:	e8 e9 0d 00 00       	call   10e2b0 <ntohs>
  10d4c7:	66 c1 e8 08          	shr    $0x8,%ax
  10d4cb:	0f b7 c0             	movzwl %ax,%eax
  10d4ce:	83 e0 0f             	and    $0xf,%eax
  10d4d1:	c1 e0 02             	shl    $0x2,%eax
  10d4d4:	89 da                	mov    %ebx,%edx
  10d4d6:	66 29 c2             	sub    %ax,%dx
  10d4d9:	89 d0                	mov    %edx,%eax
  10d4db:	66 89 45 f6          	mov    %ax,0xfffffff6(%ebp)
    offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
  10d4df:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10d4e2:	0f b7 40 06          	movzwl 0x6(%eax),%eax
  10d4e6:	0f b7 c0             	movzwl %ax,%eax
  10d4e9:	89 04 24             	mov    %eax,(%esp)
  10d4ec:	e8 bf 0d 00 00       	call   10e2b0 <ntohs>
  10d4f1:	0f b7 c0             	movzwl %ax,%eax
  10d4f4:	25 ff 1f 00 00       	and    $0x1fff,%eax
  10d4f9:	c1 e0 03             	shl    $0x3,%eax
  10d4fc:	66 89 45 f4          	mov    %ax,0xfffffff4(%ebp)

    /* If the offset or the offset + fragment length overflows the
       reassembly buffer, we discard the entire packet. */
    if (offset > IP_REASS_BUFSIZE || offset + len > IP_REASS_BUFSIZE) {
  10d500:	66 81 7d f4 80 16    	cmpw   $0x1680,0xfffffff4(%ebp)
  10d506:	77 11                	ja     10d519 <ip_reass+0x159>
  10d508:	0f b7 45 f4          	movzwl 0xfffffff4(%ebp),%eax
  10d50c:	0f b7 55 f6          	movzwl 0xfffffff6(%ebp),%edx
  10d510:	01 d0                	add    %edx,%eax
  10d512:	3d 80 16 00 00       	cmp    $0x1680,%eax
  10d517:	7e 20                	jle    10d539 <ip_reass+0x179>
      LWIP_DEBUGF(IP_REASS_DEBUG,
       ("ip_reass: fragment outside of buffer (%d:%d/%d).\n", offset,
        offset + len, IP_REASS_BUFSIZE));
      sys_untimeout(ip_reass_timer, NULL);
  10d519:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  10d520:	00 
  10d521:	c7 04 24 60 d3 10 00 	movl   $0x10d360,(%esp)
  10d528:	e8 03 2b 00 00       	call   110030 <sys_untimeout>
      ip_reasstmr = 0;
  10d52d:	c6 05 dd f2 11 00 00 	movb   $0x0,0x11f2dd
      goto nullreturn;
  10d534:	e9 cc 03 00 00       	jmp    10d905 <ip_reass+0x545>
    }

    /* Copy the fragment into the reassembly buffer, at the right
       offset. */
    LWIP_DEBUGF(IP_REASS_DEBUG,
     ("ip_reass: copying with offset %d into %d:%d\n", offset,
      IP_HLEN + offset, IP_HLEN + offset + len));
    i = IPH_HL(fraghdr) * 4;
  10d539:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10d53c:	0f b7 00             	movzwl (%eax),%eax
  10d53f:	0f b7 c0             	movzwl %ax,%eax
  10d542:	89 04 24             	mov    %eax,(%esp)
  10d545:	e8 66 0d 00 00       	call   10e2b0 <ntohs>
  10d54a:	66 c1 e8 08          	shr    $0x8,%ax
  10d54e:	0f b7 c0             	movzwl %ax,%eax
  10d551:	83 e0 0f             	and    $0xf,%eax
  10d554:	c1 e0 02             	shl    $0x2,%eax
  10d557:	66 89 45 e6          	mov    %ax,0xffffffe6(%ebp)
    copy_from_pbuf(p, &i, &ip_reassbuf[IP_HLEN + offset], len);
  10d55b:	0f b7 4d f6          	movzwl 0xfffffff6(%ebp),%ecx
  10d55f:	0f b7 45 f4          	movzwl 0xfffffff4(%ebp),%eax
  10d563:	89 c2                	mov    %eax,%edx
  10d565:	b8 f4 db 11 00       	mov    $0x11dbf4,%eax
  10d56a:	8d 04 02             	lea    (%edx,%eax,1),%eax
  10d56d:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
  10d571:	89 44 24 08          	mov    %eax,0x8(%esp)
  10d575:	8d 45 e6             	lea    0xffffffe6(%ebp),%eax
  10d578:	89 44 24 04          	mov    %eax,0x4(%esp)
  10d57c:	8b 45 08             	mov    0x8(%ebp),%eax
  10d57f:	89 04 24             	mov    %eax,(%esp)
  10d582:	e8 19 fd ff ff       	call   10d2a0 <copy_from_pbuf>

    /* Update the bitmap. */
    if (offset / (8 * 8) == (offset + len) / (8 * 8)) {
  10d587:	0f b7 45 f4          	movzwl 0xfffffff4(%ebp),%eax
  10d58b:	66 c1 e8 06          	shr    $0x6,%ax
  10d58f:	0f b7 c8             	movzwl %ax,%ecx
  10d592:	0f b7 55 f4          	movzwl 0xfffffff4(%ebp),%edx
  10d596:	0f b7 45 f6          	movzwl 0xfffffff6(%ebp),%eax
  10d59a:	01 c2                	add    %eax,%edx
  10d59c:	89 d0                	mov    %edx,%eax
  10d59e:	c1 f8 1f             	sar    $0x1f,%eax
  10d5a1:	c1 e8 1a             	shr    $0x1a,%eax
  10d5a4:	01 d0                	add    %edx,%eax
  10d5a6:	c1 f8 06             	sar    $0x6,%eax
  10d5a9:	39 c1                	cmp    %eax,%ecx
  10d5ab:	75 60                	jne    10d60d <ip_reass+0x24d>
      LWIP_DEBUGF(IP_REASS_DEBUG,
       ("ip_reass: updating single byte in bitmap.\n"));
      /* If the two endpoints are in the same byte, we only update
         that byte. */
      ip_reassbitmap[offset / (8 * 8)] |=
  10d5ad:	0f b7 45 f4          	movzwl 0xfffffff4(%ebp),%eax
  10d5b1:	66 c1 e8 06          	shr    $0x6,%ax
  10d5b5:	0f b7 c8             	movzwl %ax,%ecx
  10d5b8:	0f b7 c0             	movzwl %ax,%eax
  10d5bb:	0f b6 80 80 f2 11 00 	movzbl 0x11f280(%eax),%eax
  10d5c2:	89 c3                	mov    %eax,%ebx
  10d5c4:	0f b7 45 f4          	movzwl 0xfffffff4(%ebp),%eax
  10d5c8:	66 c1 e8 03          	shr    $0x3,%ax
  10d5cc:	0f b7 c0             	movzwl %ax,%eax
  10d5cf:	83 e0 07             	and    $0x7,%eax
  10d5d2:	0f b6 80 c7 ad 11 00 	movzbl 0x11adc7(%eax),%eax
  10d5d9:	89 c6                	mov    %eax,%esi
  10d5db:	0f b7 55 f4          	movzwl 0xfffffff4(%ebp),%edx
  10d5df:	0f b7 45 f6          	movzwl 0xfffffff6(%ebp),%eax
  10d5e3:	01 c2                	add    %eax,%edx
  10d5e5:	89 d0                	mov    %edx,%eax
  10d5e7:	c1 f8 1f             	sar    $0x1f,%eax
  10d5ea:	c1 e8 1d             	shr    $0x1d,%eax
  10d5ed:	01 d0                	add    %edx,%eax
  10d5ef:	c1 f8 03             	sar    $0x3,%eax
  10d5f2:	83 e0 07             	and    $0x7,%eax
  10d5f5:	0f b6 80 c7 ad 11 00 	movzbl 0x11adc7(%eax),%eax
  10d5fc:	f7 d0                	not    %eax
  10d5fe:	21 f0                	and    %esi,%eax
  10d600:	09 d8                	or     %ebx,%eax
  10d602:	88 81 80 f2 11 00    	mov    %al,0x11f280(%ecx)
  10d608:	e9 cb 00 00 00       	jmp    10d6d8 <ip_reass+0x318>
    bitmap_bits[(offset / 8) & 7] &
    ~bitmap_bits[((offset + len) / 8) & 7];
    } else {
      /* If the two endpoints are in different bytes, we update the
         bytes in the endpoints and fill the stuff inbetween with
         0xff. */
      ip_reassbitmap[offset / (8 * 8)] |= bitmap_bits[(offset / 8) & 7];
  10d60d:	0f b7 45 f4          	movzwl 0xfffffff4(%ebp),%eax
  10d611:	66 c1 e8 06          	shr    $0x6,%ax
  10d615:	0f b7 d0             	movzwl %ax,%edx
  10d618:	0f b7 c0             	movzwl %ax,%eax
  10d61b:	0f b6 88 80 f2 11 00 	movzbl 0x11f280(%eax),%ecx
  10d622:	0f b7 45 f4          	movzwl 0xfffffff4(%ebp),%eax
  10d626:	66 c1 e8 03          	shr    $0x3,%ax
  10d62a:	0f b7 c0             	movzwl %ax,%eax
  10d62d:	83 e0 07             	and    $0x7,%eax
  10d630:	0f b6 80 c7 ad 11 00 	movzbl 0x11adc7(%eax),%eax
  10d637:	09 c8                	or     %ecx,%eax
  10d639:	88 82 80 f2 11 00    	mov    %al,0x11f280(%edx)
      LWIP_DEBUGF(IP_REASS_DEBUG,
       ("ip_reass: updating many bytes in bitmap (%d:%d).\n",
        1 + offset / (8 * 8), (offset + len) / (8 * 8)));
      for (i = 1 + offset / (8 * 8); i < (offset + len) / (8 * 8); ++i) {
  10d63f:	0f b7 45 f4          	movzwl 0xfffffff4(%ebp),%eax
  10d643:	66 c1 e8 06          	shr    $0x6,%ax
  10d647:	83 c0 01             	add    $0x1,%eax
  10d64a:	66 89 45 e6          	mov    %ax,0xffffffe6(%ebp)
  10d64e:	eb 19                	jmp    10d669 <ip_reass+0x2a9>
  ip_reassbitmap[i] = 0xff;
  10d650:	0f b7 45 e6          	movzwl 0xffffffe6(%ebp),%eax
  10d654:	0f b7 c0             	movzwl %ax,%eax
  10d657:	c6 80 80 f2 11 00 ff 	movb   $0xff,0x11f280(%eax)
  10d65e:	0f b7 45 e6          	movzwl 0xffffffe6(%ebp),%eax
  10d662:	83 c0 01             	add    $0x1,%eax
  10d665:	66 89 45 e6          	mov    %ax,0xffffffe6(%ebp)
  10d669:	0f b7 45 e6          	movzwl 0xffffffe6(%ebp),%eax
  10d66d:	0f b7 c8             	movzwl %ax,%ecx
  10d670:	0f b7 55 f4          	movzwl 0xfffffff4(%ebp),%edx
  10d674:	0f b7 45 f6          	movzwl 0xfffffff6(%ebp),%eax
  10d678:	01 c2                	add    %eax,%edx
  10d67a:	89 d0                	mov    %edx,%eax
  10d67c:	c1 f8 1f             	sar    $0x1f,%eax
  10d67f:	c1 e8 1a             	shr    $0x1a,%eax
  10d682:	01 d0                	add    %edx,%eax
  10d684:	c1 f8 06             	sar    $0x6,%eax
  10d687:	39 c1                	cmp    %eax,%ecx
  10d689:	7c c5                	jl     10d650 <ip_reass+0x290>
      }
      ip_reassbitmap[(offset + len) / (8 * 8)] |=
  10d68b:	0f b7 55 f4          	movzwl 0xfffffff4(%ebp),%edx
  10d68f:	0f b7 45 f6          	movzwl 0xfffffff6(%ebp),%eax
  10d693:	01 c2                	add    %eax,%edx
  10d695:	89 d0                	mov    %edx,%eax
  10d697:	c1 f8 1f             	sar    $0x1f,%eax
  10d69a:	c1 e8 1a             	shr    $0x1a,%eax
  10d69d:	01 d0                	add    %edx,%eax
  10d69f:	c1 f8 06             	sar    $0x6,%eax
  10d6a2:	89 c1                	mov    %eax,%ecx
  10d6a4:	0f b6 80 80 f2 11 00 	movzbl 0x11f280(%eax),%eax
  10d6ab:	89 c3                	mov    %eax,%ebx
  10d6ad:	0f b7 55 f4          	movzwl 0xfffffff4(%ebp),%edx
  10d6b1:	0f b7 45 f6          	movzwl 0xfffffff6(%ebp),%eax
  10d6b5:	01 c2                	add    %eax,%edx
  10d6b7:	89 d0                	mov    %edx,%eax
  10d6b9:	c1 f8 1f             	sar    $0x1f,%eax
  10d6bc:	c1 e8 1d             	shr    $0x1d,%eax
  10d6bf:	01 d0                	add    %edx,%eax
  10d6c1:	c1 f8 03             	sar    $0x3,%eax
  10d6c4:	83 e0 07             	and    $0x7,%eax
  10d6c7:	0f b6 80 c7 ad 11 00 	movzbl 0x11adc7(%eax),%eax
  10d6ce:	f7 d0                	not    %eax
  10d6d0:	09 d8                	or     %ebx,%eax
  10d6d2:	88 81 80 f2 11 00    	mov    %al,0x11f280(%ecx)
    ~bitmap_bits[((offset + len) / 8) & 7];
    }

    /* If this fragment has the More Fragments flag set to zero, we
       know that this is the last fragment, so we can calculate the
       size of the entire packet. We also set the
       IP_REASS_FLAG_LASTFRAG flag to indicate that we have received
       the final fragment. */

    if ((ntohs(IPH_OFFSET(fraghdr)) & IP_MF) == 0) {
  10d6d8:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10d6db:	0f b7 40 06          	movzwl 0x6(%eax),%eax
  10d6df:	0f b7 c0             	movzwl %ax,%eax
  10d6e2:	89 04 24             	mov    %eax,(%esp)
  10d6e5:	e8 c6 0b 00 00       	call   10e2b0 <ntohs>
  10d6ea:	0f b7 c0             	movzwl %ax,%eax
  10d6ed:	25 00 20 00 00       	and    $0x2000,%eax
  10d6f2:	85 c0                	test   %eax,%eax
  10d6f4:	75 1d                	jne    10d713 <ip_reass+0x353>
      ip_reassflags |= IP_REASS_FLAG_LASTFRAG;
  10d6f6:	0f b6 05 dc f2 11 00 	movzbl 0x11f2dc,%eax
  10d6fd:	83 c8 01             	or     $0x1,%eax
  10d700:	a2 dc f2 11 00       	mov    %al,0x11f2dc
      ip_reasslen = offset + len;
  10d705:	0f b7 45 f6          	movzwl 0xfffffff6(%ebp),%eax
  10d709:	66 03 45 f4          	add    0xfffffff4(%ebp),%ax
  10d70d:	66 a3 da f2 11 00    	mov    %ax,0x11f2da
      LWIP_DEBUGF(IP_REASS_DEBUG,
       ("ip_reass: last fragment seen, total len %d\n",
        ip_reasslen));
    }

    /* Finally, we check if we have a full packet in the buffer. We do
       this by checking if we have the last fragment and if all bits
       in the bitmap are set. */
    if (ip_reassflags & IP_REASS_FLAG_LASTFRAG) {
  10d713:	0f b6 05 dc f2 11 00 	movzbl 0x11f2dc,%eax
  10d71a:	0f b6 c0             	movzbl %al,%eax
  10d71d:	83 e0 01             	and    $0x1,%eax
  10d720:	84 c0                	test   %al,%al
  10d722:	0f 84 dd 01 00 00    	je     10d905 <ip_reass+0x545>
      /* Check all bytes up to and including all but the last byte in
         the bitmap. */
      for (i = 0; i < ip_reasslen / (8 * 8) - 1; ++i) {
  10d728:	66 c7 45 e6 00 00    	movw   $0x0,0xffffffe6(%ebp)
  10d72e:	eb 22                	jmp    10d752 <ip_reass+0x392>
  if (ip_reassbitmap[i] != 0xff) {
  10d730:	0f b7 45 e6          	movzwl 0xffffffe6(%ebp),%eax
  10d734:	0f b7 c0             	movzwl %ax,%eax
  10d737:	0f b6 80 80 f2 11 00 	movzbl 0x11f280(%eax),%eax
  10d73e:	3c ff                	cmp    $0xff,%al
  10d740:	74 05                	je     10d747 <ip_reass+0x387>
    LWIP_DEBUGF(IP_REASS_DEBUG,
     ("ip_reass: last fragment seen, bitmap %d/%d failed (%x)\n",
      i, ip_reasslen / (8 * 8) - 1, ip_reassbitmap[i]));
    goto nullreturn;
  10d742:	e9 be 01 00 00       	jmp    10d905 <ip_reass+0x545>
  10d747:	0f b7 45 e6          	movzwl 0xffffffe6(%ebp),%eax
  10d74b:	83 c0 01             	add    $0x1,%eax
  10d74e:	66 89 45 e6          	mov    %ax,0xffffffe6(%ebp)
  10d752:	0f b7 45 e6          	movzwl 0xffffffe6(%ebp),%eax
  10d756:	0f b7 d0             	movzwl %ax,%edx
  10d759:	0f b7 05 da f2 11 00 	movzwl 0x11f2da,%eax
  10d760:	66 c1 e8 06          	shr    $0x6,%ax
  10d764:	0f b7 c0             	movzwl %ax,%eax
  10d767:	83 e8 01             	sub    $0x1,%eax
  10d76a:	39 c2                	cmp    %eax,%edx
  10d76c:	7c c2                	jl     10d730 <ip_reass+0x370>
  }
      }
      /* Check the last byte in the bitmap. It should contain just the
         right amount of bits. */
      if (ip_reassbitmap[ip_reasslen / (8 * 8)] !=
  10d76e:	0f b7 05 da f2 11 00 	movzwl 0x11f2da,%eax
  10d775:	66 c1 e8 06          	shr    $0x6,%ax
  10d779:	0f b7 c0             	movzwl %ax,%eax
  10d77c:	0f b6 90 80 f2 11 00 	movzbl 0x11f280(%eax),%edx
  10d783:	0f b7 05 da f2 11 00 	movzwl 0x11f2da,%eax
  10d78a:	66 c1 e8 03          	shr    $0x3,%ax
  10d78e:	0f b7 c0             	movzwl %ax,%eax
  10d791:	83 e0 07             	and    $0x7,%eax
  10d794:	0f b6 80 c7 ad 11 00 	movzbl 0x11adc7(%eax),%eax
  10d79b:	f7 d0                	not    %eax
  10d79d:	38 c2                	cmp    %al,%dl
  10d79f:	74 05                	je     10d7a6 <ip_reass+0x3e6>
    (u8_t) ~ bitmap_bits[ip_reasslen / 8 & 7]) {
  LWIP_DEBUGF(IP_REASS_DEBUG,
         ("ip_reass: last fragment seen, bitmap %d didn't contain %x (%x)\n",
    ip_reasslen / (8 * 8), ~bitmap_bits[ip_reasslen / 8 & 7],
    ip_reassbitmap[ip_reasslen / (8 * 8)]));
  goto nullreturn;
  10d7a1:	e9 5f 01 00 00       	jmp    10d905 <ip_reass+0x545>
      }

      /* Pretend to be a "normal" (i.e., not fragmented) IP packet
         from now on. */
      ip_reasslen += IP_HLEN;
  10d7a6:	0f b7 05 da f2 11 00 	movzwl 0x11f2da,%eax
  10d7ad:	83 c0 14             	add    $0x14,%eax
  10d7b0:	66 a3 da f2 11 00    	mov    %ax,0x11f2da

      IPH_LEN_SET(iphdr, htons(ip_reasslen));
  10d7b6:	0f b7 05 da f2 11 00 	movzwl 0x11f2da,%eax
  10d7bd:	0f b7 c0             	movzwl %ax,%eax
  10d7c0:	89 04 24             	mov    %eax,(%esp)
  10d7c3:	e8 b8 0a 00 00       	call   10e280 <htons>
  10d7c8:	89 c2                	mov    %eax,%edx
  10d7ca:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10d7cd:	66 89 50 02          	mov    %dx,0x2(%eax)
      IPH_OFFSET_SET(iphdr, 0);
  10d7d1:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10d7d4:	66 c7 40 06 00 00    	movw   $0x0,0x6(%eax)
      IPH_CHKSUM_SET(iphdr, 0);
  10d7da:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10d7dd:	66 c7 40 0a 00 00    	movw   $0x0,0xa(%eax)
      IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  10d7e3:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  10d7ea:	00 
  10d7eb:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10d7ee:	89 04 24             	mov    %eax,(%esp)
  10d7f1:	e8 9a 05 00 00       	call   10dd90 <inet_chksum>
  10d7f6:	89 c2                	mov    %eax,%edx
  10d7f8:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10d7fb:	66 89 50 0a          	mov    %dx,0xa(%eax)

      /* If we have come this far, we have a full packet in the
         buffer, so we allocate a pbuf and copy the packet into it. We
         also reset the timer. */
      sys_untimeout(ip_reass_timer, NULL);
  10d7ff:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  10d806:	00 
  10d807:	c7 04 24 60 d3 10 00 	movl   $0x10d360,(%esp)
  10d80e:	e8 1d 28 00 00       	call   110030 <sys_untimeout>
      ip_reasstmr = 0;
  10d813:	c6 05 dd f2 11 00 00 	movb   $0x0,0x11f2dd
      pbuf_free(p);
  10d81a:	8b 45 08             	mov    0x8(%ebp),%eax
  10d81d:	89 04 24             	mov    %eax,(%esp)
  10d820:	e8 9b 1c 00 00       	call   10f4c0 <pbuf_free>
      p = pbuf_alloc(PBUF_LINK, ip_reasslen, PBUF_POOL);
  10d825:	0f b7 05 da f2 11 00 	movzwl 0x11f2da,%eax
  10d82c:	0f b7 c0             	movzwl %ax,%eax
  10d82f:	c7 44 24 08 03 00 00 	movl   $0x3,0x8(%esp)
  10d836:	00 
  10d837:	89 44 24 04          	mov    %eax,0x4(%esp)
  10d83b:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  10d842:	e8 99 17 00 00       	call   10efe0 <pbuf_alloc>
  10d847:	89 45 08             	mov    %eax,0x8(%ebp)
      if (p != NULL) {
  10d84a:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  10d84e:	0f 84 99 00 00 00    	je     10d8ed <ip_reass+0x52d>
  i = 0;
  10d854:	66 c7 45 e6 00 00    	movw   $0x0,0xffffffe6(%ebp)
  for (q = p; q != NULL; q = q->next) {
  10d85a:	8b 45 08             	mov    0x8(%ebp),%eax
  10d85d:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
  10d860:	eb 73                	jmp    10d8d5 <ip_reass+0x515>
    /* Copy enough bytes to fill this pbuf in the chain. The
       available data in the pbuf is given by the q->len
       variable. */
    LWIP_DEBUGF(IP_REASS_DEBUG,
     ("ip_reass: memcpy from %p (%d) to %p, %d bytes\n",
      &ip_reassbuf[i], i, q->payload,
      q->len > ip_reasslen - i ? ip_reasslen - i : q->len));
    memcpy(q->payload, &ip_reassbuf[i],
  10d862:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  10d865:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  10d869:	0f b7 c8             	movzwl %ax,%ecx
  10d86c:	0f b7 05 da f2 11 00 	movzwl 0x11f2da,%eax
  10d873:	0f b7 d0             	movzwl %ax,%edx
  10d876:	0f b7 45 e6          	movzwl 0xffffffe6(%ebp),%eax
  10d87a:	0f b7 c0             	movzwl %ax,%eax
  10d87d:	89 d3                	mov    %edx,%ebx
  10d87f:	29 c3                	sub    %eax,%ebx
  10d881:	89 5d cc             	mov    %ebx,0xffffffcc(%ebp)
  10d884:	89 4d d0             	mov    %ecx,0xffffffd0(%ebp)
  10d887:	8b 45 cc             	mov    0xffffffcc(%ebp),%eax
  10d88a:	39 45 d0             	cmp    %eax,0xffffffd0(%ebp)
  10d88d:	7e 06                	jle    10d895 <ip_reass+0x4d5>
  10d88f:	8b 55 cc             	mov    0xffffffcc(%ebp),%edx
  10d892:	89 55 d0             	mov    %edx,0xffffffd0(%ebp)
  10d895:	0f b7 45 e6          	movzwl 0xffffffe6(%ebp),%eax
  10d899:	0f b7 c0             	movzwl %ax,%eax
  10d89c:	8d 90 e0 db 11 00    	lea    0x11dbe0(%eax),%edx
  10d8a2:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  10d8a5:	8b 40 04             	mov    0x4(%eax),%eax
  10d8a8:	8b 4d d0             	mov    0xffffffd0(%ebp),%ecx
  10d8ab:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  10d8af:	89 54 24 04          	mov    %edx,0x4(%esp)
  10d8b3:	89 04 24             	mov    %eax,(%esp)
  10d8b6:	e8 d5 85 ff ff       	call   105e90 <memcpy>
    q->len > ip_reasslen - i ? ip_reasslen - i : q->len);
    i += q->len;
  10d8bb:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  10d8be:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
  10d8c2:	0f b7 45 e6          	movzwl 0xffffffe6(%ebp),%eax
  10d8c6:	8d 04 02             	lea    (%edx,%eax,1),%eax
  10d8c9:	66 89 45 e6          	mov    %ax,0xffffffe6(%ebp)
  10d8cd:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  10d8d0:	8b 00                	mov    (%eax),%eax
  10d8d2:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
  10d8d5:	83 7d e8 00          	cmpl   $0x0,0xffffffe8(%ebp)
  10d8d9:	75 87                	jne    10d862 <ip_reass+0x4a2>
  }
  IPFRAG_STATS_INC(ip_frag.fw);
  10d8db:	0f b7 05 00 15 14 00 	movzwl 0x141500,%eax
  10d8e2:	83 c0 01             	add    $0x1,%eax
  10d8e5:	66 a3 00 15 14 00    	mov    %ax,0x141500
  10d8eb:	eb 10                	jmp    10d8fd <ip_reass+0x53d>
      } else {
  IPFRAG_STATS_INC(ip_frag.memerr);
  10d8ed:	0f b7 05 08 15 14 00 	movzwl 0x141508,%eax
  10d8f4:	83 c0 01             	add    $0x1,%eax
  10d8f7:	66 a3 08 15 14 00    	mov    %ax,0x141508
      }
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass: p %p\n", (void*)p));
      return p;
  10d8fd:	8b 5d 08             	mov    0x8(%ebp),%ebx
  10d900:	89 5d d4             	mov    %ebx,0xffffffd4(%ebp)
  10d903:	eb 22                	jmp    10d927 <ip_reass+0x567>
    }
  }

nullreturn:
  IPFRAG_STATS_INC(ip_frag.drop);
  10d905:	0f b7 05 02 15 14 00 	movzwl 0x141502,%eax
  10d90c:	83 c0 01             	add    $0x1,%eax
  10d90f:	66 a3 02 15 14 00    	mov    %ax,0x141502
  pbuf_free(p);
  10d915:	8b 45 08             	mov    0x8(%ebp),%eax
  10d918:	89 04 24             	mov    %eax,(%esp)
  10d91b:	e8 a0 1b 00 00       	call   10f4c0 <pbuf_free>
  return NULL;
  10d920:	c7 45 d4 00 00 00 00 	movl   $0x0,0xffffffd4(%ebp)
  10d927:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
}
  10d92a:	83 c4 40             	add    $0x40,%esp
  10d92d:	5b                   	pop    %ebx
  10d92e:	5e                   	pop    %esi
  10d92f:	5d                   	pop    %ebp
  10d930:	c3                   	ret    
  10d931:	eb 0d                	jmp    10d940 <ip_frag>
  10d933:	90                   	nop    
  10d934:	90                   	nop    
  10d935:	90                   	nop    
  10d936:	90                   	nop    
  10d937:	90                   	nop    
  10d938:	90                   	nop    
  10d939:	90                   	nop    
  10d93a:	90                   	nop    
  10d93b:	90                   	nop    
  10d93c:	90                   	nop    
  10d93d:	90                   	nop    
  10d93e:	90                   	nop    
  10d93f:	90                   	nop    

0010d940 <ip_frag>:

#define MAX_MTU 1500
static u8_t buf[MEM_ALIGN_SIZE(MAX_MTU)];

/**
 * Fragment an IP packet if too large
 *
 * Chop the packet in mtu sized chunks and send them in order
 * by using a fixed size static memory buffer (PBUF_ROM)
 */
err_t 
ip_frag(struct pbuf *p, struct netif *netif, struct ip_addr *dest)
{
  10d940:	55                   	push   %ebp
  10d941:	89 e5                	mov    %esp,%ebp
  10d943:	83 ec 38             	sub    $0x38,%esp
  struct pbuf *rambuf;
  struct pbuf *header;
  struct ip_hdr *iphdr;
  u16_t nfb = 0;
  10d946:	66 c7 45 f0 00 00    	movw   $0x0,0xfffffff0(%ebp)
  u16_t left, cop;
  u16_t mtu = netif->mtu;
  10d94c:	8b 45 0c             	mov    0xc(%ebp),%eax
  10d94f:	0f b7 40 28          	movzwl 0x28(%eax),%eax
  10d953:	66 89 45 f6          	mov    %ax,0xfffffff6(%ebp)
  u16_t ofo, omf;
  u16_t last;
  u16_t poff = IP_HLEN;
  10d957:	66 c7 45 e2 14 00    	movw   $0x14,0xffffffe2(%ebp)
  u16_t tmp;

  /* Get a RAM based MTU sized pbuf */
  rambuf = pbuf_alloc(PBUF_LINK, 0, PBUF_REF);
  10d95d:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
  10d964:	00 
  10d965:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  10d96c:	00 
  10d96d:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  10d974:	e8 67 16 00 00       	call   10efe0 <pbuf_alloc>
  10d979:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
  rambuf->tot_len = rambuf->len = mtu;
  10d97c:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
  10d97f:	0f b7 45 f6          	movzwl 0xfffffff6(%ebp),%eax
  10d983:	66 89 42 0a          	mov    %ax,0xa(%edx)
  10d987:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
  10d98a:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
  10d98e:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
  10d991:	66 89 50 08          	mov    %dx,0x8(%eax)
  rambuf->payload = MEM_ALIGN((void *)buf);
  10d995:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
  10d998:	c7 40 04 e0 f2 11 00 	movl   $0x11f2e0,0x4(%eax)


  /* Copy the IP header in it */
  iphdr = rambuf->payload;
  10d99f:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
  10d9a2:	8b 40 04             	mov    0x4(%eax),%eax
  10d9a5:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  memcpy(iphdr, p->payload, IP_HLEN);
  10d9a8:	8b 45 08             	mov    0x8(%ebp),%eax
  10d9ab:	8b 40 04             	mov    0x4(%eax),%eax
  10d9ae:	c7 44 24 08 14 00 00 	movl   $0x14,0x8(%esp)
  10d9b5:	00 
  10d9b6:	89 44 24 04          	mov    %eax,0x4(%esp)
  10d9ba:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10d9bd:	89 04 24             	mov    %eax,(%esp)
  10d9c0:	e8 cb 84 ff ff       	call   105e90 <memcpy>

  /* Save original offset */
  tmp = ntohs(IPH_OFFSET(iphdr));
  10d9c5:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10d9c8:	0f b7 40 06          	movzwl 0x6(%eax),%eax
  10d9cc:	0f b7 c0             	movzwl %ax,%eax
  10d9cf:	89 04 24             	mov    %eax,(%esp)
  10d9d2:	e8 d9 08 00 00       	call   10e2b0 <ntohs>
  10d9d7:	66 89 45 fe          	mov    %ax,0xfffffffe(%ebp)
  ofo = tmp & IP_OFFMASK;
  10d9db:	0f b7 45 fe          	movzwl 0xfffffffe(%ebp),%eax
  10d9df:	66 25 ff 1f          	and    $0x1fff,%ax
  10d9e3:	66 89 45 f8          	mov    %ax,0xfffffff8(%ebp)
  omf = tmp & IP_MF;
  10d9e7:	0f b7 45 fe          	movzwl 0xfffffffe(%ebp),%eax
  10d9eb:	66 25 00 20          	and    $0x2000,%ax
  10d9ef:	66 89 45 fa          	mov    %ax,0xfffffffa(%ebp)

  left = p->tot_len - IP_HLEN;
  10d9f3:	8b 45 08             	mov    0x8(%ebp),%eax
  10d9f6:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  10d9fa:	83 e8 14             	sub    $0x14,%eax
  10d9fd:	66 89 45 f2          	mov    %ax,0xfffffff2(%ebp)

  while (left) {
  10da01:	e9 89 01 00 00       	jmp    10db8f <ip_frag+0x24f>
    last = (left <= mtu - IP_HLEN);
  10da06:	0f b7 55 f2          	movzwl 0xfffffff2(%ebp),%edx
  10da0a:	0f b7 45 f6          	movzwl 0xfffffff6(%ebp),%eax
  10da0e:	83 e8 14             	sub    $0x14,%eax
  10da11:	39 c2                	cmp    %eax,%edx
  10da13:	0f 9e c0             	setle  %al
  10da16:	0f b6 c0             	movzbl %al,%eax
  10da19:	66 89 45 fc          	mov    %ax,0xfffffffc(%ebp)

    /* Set new offset and MF flag */
    ofo += nfb;
  10da1d:	0f b7 45 f0          	movzwl 0xfffffff0(%ebp),%eax
  10da21:	66 01 45 f8          	add    %ax,0xfffffff8(%ebp)
    tmp = omf | (IP_OFFMASK & (ofo));
  10da25:	0f b7 45 f8          	movzwl 0xfffffff8(%ebp),%eax
  10da29:	89 c2                	mov    %eax,%edx
  10da2b:	66 81 e2 ff 1f       	and    $0x1fff,%dx
  10da30:	0f b7 45 fa          	movzwl 0xfffffffa(%ebp),%eax
  10da34:	09 d0                	or     %edx,%eax
  10da36:	66 89 45 fe          	mov    %ax,0xfffffffe(%ebp)
    if (!last)
  10da3a:	66 83 7d fc 00       	cmpw   $0x0,0xfffffffc(%ebp)
  10da3f:	75 06                	jne    10da47 <ip_frag+0x107>
      tmp = tmp | IP_MF;
  10da41:	66 81 4d fe 00 20    	orw    $0x2000,0xfffffffe(%ebp)
    IPH_OFFSET_SET(iphdr, htons(tmp));
  10da47:	0f b7 45 fe          	movzwl 0xfffffffe(%ebp),%eax
  10da4b:	89 04 24             	mov    %eax,(%esp)
  10da4e:	e8 2d 08 00 00       	call   10e280 <htons>
  10da53:	89 c2                	mov    %eax,%edx
  10da55:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10da58:	66 89 50 06          	mov    %dx,0x6(%eax)

    /* Fill this fragment */
    nfb = (mtu - IP_HLEN) / 8;
  10da5c:	0f b7 45 f6          	movzwl 0xfffffff6(%ebp),%eax
  10da60:	8d 50 ec             	lea    0xffffffec(%eax),%edx
  10da63:	89 d0                	mov    %edx,%eax
  10da65:	c1 f8 1f             	sar    $0x1f,%eax
  10da68:	c1 e8 1d             	shr    $0x1d,%eax
  10da6b:	01 d0                	add    %edx,%eax
  10da6d:	c1 f8 03             	sar    $0x3,%eax
  10da70:	66 89 45 f0          	mov    %ax,0xfffffff0(%ebp)
    cop = last ? left : nfb * 8;
  10da74:	66 83 7d fc 00       	cmpw   $0x0,0xfffffffc(%ebp)
  10da79:	75 0d                	jne    10da88 <ip_frag+0x148>
  10da7b:	0f b7 45 f0          	movzwl 0xfffffff0(%ebp),%eax
  10da7f:	c1 e0 03             	shl    $0x3,%eax
  10da82:	66 89 45 de          	mov    %ax,0xffffffde(%ebp)
  10da86:	eb 08                	jmp    10da90 <ip_frag+0x150>
  10da88:	0f b7 45 f2          	movzwl 0xfffffff2(%ebp),%eax
  10da8c:	66 89 45 de          	mov    %ax,0xffffffde(%ebp)
  10da90:	0f b7 45 de          	movzwl 0xffffffde(%ebp),%eax
  10da94:	66 89 45 f4          	mov    %ax,0xfffffff4(%ebp)

    p = copy_from_pbuf(p, &poff, (u8_t *) iphdr + IP_HLEN, cop);
  10da98:	0f b7 55 f4          	movzwl 0xfffffff4(%ebp),%edx
  10da9c:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10da9f:	83 c0 14             	add    $0x14,%eax
  10daa2:	89 54 24 0c          	mov    %edx,0xc(%esp)
  10daa6:	89 44 24 08          	mov    %eax,0x8(%esp)
  10daaa:	8d 45 e2             	lea    0xffffffe2(%ebp),%eax
  10daad:	89 44 24 04          	mov    %eax,0x4(%esp)
  10dab1:	8b 45 08             	mov    0x8(%ebp),%eax
  10dab4:	89 04 24             	mov    %eax,(%esp)
  10dab7:	e8 e4 f7 ff ff       	call   10d2a0 <copy_from_pbuf>
  10dabc:	89 45 08             	mov    %eax,0x8(%ebp)

    /* Correct header */
    IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
  10dabf:	0f b7 45 f4          	movzwl 0xfffffff4(%ebp),%eax
  10dac3:	83 c0 14             	add    $0x14,%eax
  10dac6:	0f b7 c0             	movzwl %ax,%eax
  10dac9:	89 04 24             	mov    %eax,(%esp)
  10dacc:	e8 af 07 00 00       	call   10e280 <htons>
  10dad1:	89 c2                	mov    %eax,%edx
  10dad3:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10dad6:	66 89 50 02          	mov    %dx,0x2(%eax)
    IPH_CHKSUM_SET(iphdr, 0);
  10dada:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10dadd:	66 c7 40 0a 00 00    	movw   $0x0,0xa(%eax)
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  10dae3:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  10daea:	00 
  10daeb:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10daee:	89 04 24             	mov    %eax,(%esp)
  10daf1:	e8 9a 02 00 00       	call   10dd90 <inet_chksum>
  10daf6:	89 c2                	mov    %eax,%edx
  10daf8:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10dafb:	66 89 50 0a          	mov    %dx,0xa(%eax)

    if (last)
  10daff:	66 83 7d fc 00       	cmpw   $0x0,0xfffffffc(%ebp)
  10db04:	74 19                	je     10db1f <ip_frag+0x1df>
      pbuf_realloc(rambuf, left + IP_HLEN);
  10db06:	0f b7 45 f2          	movzwl 0xfffffff2(%ebp),%eax
  10db0a:	83 c0 14             	add    $0x14,%eax
  10db0d:	0f b7 c0             	movzwl %ax,%eax
  10db10:	89 44 24 04          	mov    %eax,0x4(%esp)
  10db14:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
  10db17:	89 04 24             	mov    %eax,(%esp)
  10db1a:	e8 91 17 00 00       	call   10f2b0 <pbuf_realloc>
    /* This part is ugly: we alloc a RAM based pbuf for 
     * the link level header for each chunk and then 
     * free it.A PBUF_ROM style pbuf for which pbuf_header
     * worked would make things simpler.
     */
    header = pbuf_alloc(PBUF_LINK, 0, PBUF_RAM);
  10db1f:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  10db26:	00 
  10db27:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  10db2e:	00 
  10db2f:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  10db36:	e8 a5 14 00 00       	call   10efe0 <pbuf_alloc>
  10db3b:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
    pbuf_chain(header, rambuf);
  10db3e:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
  10db41:	89 44 24 04          	mov    %eax,0x4(%esp)
  10db45:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  10db48:	89 04 24             	mov    %eax,(%esp)
  10db4b:	e8 70 1b 00 00       	call   10f6c0 <pbuf_chain>
    netif->output(netif, header, dest);
  10db50:	8b 45 0c             	mov    0xc(%ebp),%eax
  10db53:	8b 50 14             	mov    0x14(%eax),%edx
  10db56:	8b 45 10             	mov    0x10(%ebp),%eax
  10db59:	89 44 24 08          	mov    %eax,0x8(%esp)
  10db5d:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  10db60:	89 44 24 04          	mov    %eax,0x4(%esp)
  10db64:	8b 45 0c             	mov    0xc(%ebp),%eax
  10db67:	89 04 24             	mov    %eax,(%esp)
  10db6a:	ff d2                	call   *%edx
    IPFRAG_STATS_INC(ip_frag.xmit);
  10db6c:	0f b7 05 fa 14 14 00 	movzwl 0x1414fa,%eax
  10db73:	83 c0 01             	add    $0x1,%eax
  10db76:	66 a3 fa 14 14 00    	mov    %ax,0x1414fa
    pbuf_free(header);
  10db7c:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  10db7f:	89 04 24             	mov    %eax,(%esp)
  10db82:	e8 39 19 00 00       	call   10f4c0 <pbuf_free>

    left -= cop;
  10db87:	0f b7 45 f4          	movzwl 0xfffffff4(%ebp),%eax
  10db8b:	66 29 45 f2          	sub    %ax,0xfffffff2(%ebp)
  10db8f:	66 83 7d f2 00       	cmpw   $0x0,0xfffffff2(%ebp)
  10db94:	0f 85 6c fe ff ff    	jne    10da06 <ip_frag+0xc6>
  }
  pbuf_free(rambuf);
  10db9a:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
  10db9d:	89 04 24             	mov    %eax,(%esp)
  10dba0:	e8 1b 19 00 00       	call   10f4c0 <pbuf_free>
  return ERR_OK;
  10dba5:	b8 00 00 00 00       	mov    $0x0,%eax
}
  10dbaa:	c9                   	leave  
  10dbab:	c3                   	ret    
  10dbac:	90                   	nop    
  10dbad:	90                   	nop    
  10dbae:	90                   	nop    
  10dbaf:	90                   	nop    

0010dbb0 <lwip_chksum>:


static u16_t
lwip_chksum(void *dataptr, int len)
{
  10dbb0:	55                   	push   %ebp
  10dbb1:	89 e5                	mov    %esp,%ebp
  10dbb3:	83 ec 18             	sub    $0x18,%esp
  u32_t acc;

  LWIP_DEBUGF(INET_DEBUG, ("lwip_chksum(%p, %d)\n", (void *)dataptr, len));
  for(acc = 0; len > 1; len -= 2) {
  10dbb6:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
  10dbbd:	eb 19                	jmp    10dbd8 <lwip_chksum+0x28>
      /*    acc = acc + *((u16_t *)dataptr)++;*/
    acc += *(u16_t *)dataptr;
  10dbbf:	8b 45 08             	mov    0x8(%ebp),%eax
  10dbc2:	0f b7 00             	movzwl (%eax),%eax
  10dbc5:	0f b7 c0             	movzwl %ax,%eax
  10dbc8:	01 45 fc             	add    %eax,0xfffffffc(%ebp)
    dataptr = (void *)((u16_t *)dataptr + 1);
  10dbcb:	8b 45 08             	mov    0x8(%ebp),%eax
  10dbce:	83 c0 02             	add    $0x2,%eax
  10dbd1:	89 45 08             	mov    %eax,0x8(%ebp)
  10dbd4:	83 6d 0c 02          	subl   $0x2,0xc(%ebp)
  10dbd8:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
  10dbdc:	7f e1                	jg     10dbbf <lwip_chksum+0xf>
  }

  /* add up any odd byte */
  if (len == 1) {
  10dbde:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
  10dbe2:	75 1d                	jne    10dc01 <lwip_chksum+0x51>
    acc += htons((u16_t)((*(u8_t *)dataptr) & 0xff) << 8);
  10dbe4:	8b 45 08             	mov    0x8(%ebp),%eax
  10dbe7:	0f b6 00             	movzbl (%eax),%eax
  10dbea:	0f b6 c0             	movzbl %al,%eax
  10dbed:	c1 e0 08             	shl    $0x8,%eax
  10dbf0:	0f b7 c0             	movzwl %ax,%eax
  10dbf3:	89 04 24             	mov    %eax,(%esp)
  10dbf6:	e8 85 06 00 00       	call   10e280 <htons>
  10dbfb:	0f b7 c0             	movzwl %ax,%eax
  10dbfe:	01 45 fc             	add    %eax,0xfffffffc(%ebp)
    LWIP_DEBUGF(INET_DEBUG, ("inet: chksum: odd byte %d\n", (unsigned int)(*(u8_t *)dataptr)));
  } else {
    LWIP_DEBUGF(INET_DEBUG, ("inet: chksum: no odd byte\n"));
  }
  acc = (acc >> 16) + (acc & 0xffffUL);
  10dc01:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10dc04:	89 c2                	mov    %eax,%edx
  10dc06:	c1 ea 10             	shr    $0x10,%edx
  10dc09:	0f b7 45 fc          	movzwl 0xfffffffc(%ebp),%eax
  10dc0d:	8d 04 02             	lea    (%edx,%eax,1),%eax
  10dc10:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)

  if ((acc & 0xffff0000) != 0) {
  10dc13:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10dc16:	66 b8 00 00          	mov    $0x0,%ax
  10dc1a:	85 c0                	test   %eax,%eax
  10dc1c:	74 12                	je     10dc30 <lwip_chksum+0x80>
    acc = (acc >> 16) + (acc & 0xffffUL);
  10dc1e:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10dc21:	89 c2                	mov    %eax,%edx
  10dc23:	c1 ea 10             	shr    $0x10,%edx
  10dc26:	0f b7 45 fc          	movzwl 0xfffffffc(%ebp),%eax
  10dc2a:	8d 04 02             	lea    (%edx,%eax,1),%eax
  10dc2d:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  }

  return (u16_t)acc;
  10dc30:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10dc33:	0f b7 c0             	movzwl %ax,%eax
}
  10dc36:	c9                   	leave  
  10dc37:	c3                   	ret    
  10dc38:	90                   	nop    
  10dc39:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

0010dc40 <inet_chksum_pseudo>:

/* inet_chksum_pseudo:
 *
 * Calculates the pseudo Internet checksum used by TCP and UDP for a pbuf chain.
 */

u16_t
inet_chksum_pseudo(struct pbuf *p,
       struct ip_addr *src, struct ip_addr *dest,
       u8_t proto, u16_t proto_len)
{
  10dc40:	55                   	push   %ebp
  10dc41:	89 e5                	mov    %esp,%ebp
  10dc43:	83 ec 28             	sub    $0x28,%esp
  10dc46:	8b 45 14             	mov    0x14(%ebp),%eax
  10dc49:	8b 55 18             	mov    0x18(%ebp),%edx
  10dc4c:	88 45 ec             	mov    %al,0xffffffec(%ebp)
  10dc4f:	66 89 55 e8          	mov    %dx,0xffffffe8(%ebp)
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  10dc53:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
  swapped = 0;
  10dc5a:	c6 45 ff 00          	movb   $0x0,0xffffffff(%ebp)
  /* iterate through all pbuf in chain */
  for(q = p; q != NULL; q = q->next) {
  10dc5e:	8b 45 08             	mov    0x8(%ebp),%eax
  10dc61:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  10dc64:	eb 7b                	jmp    10dce1 <inet_chksum_pseudo+0xa1>
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
      (void *)q, (void *)q->next));
    acc += lwip_chksum(q->payload, q->len);
  10dc66:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10dc69:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  10dc6d:	0f b7 d0             	movzwl %ax,%edx
  10dc70:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10dc73:	8b 40 04             	mov    0x4(%eax),%eax
  10dc76:	89 54 24 04          	mov    %edx,0x4(%esp)
  10dc7a:	89 04 24             	mov    %eax,(%esp)
  10dc7d:	e8 2e ff ff ff       	call   10dbb0 <lwip_chksum>
  10dc82:	0f b7 c0             	movzwl %ax,%eax
  10dc85:	01 45 f4             	add    %eax,0xfffffff4(%ebp)
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%lx \n", acc));*/
    while (acc >> 16) {
  10dc88:	eb 10                	jmp    10dc9a <inet_chksum_pseudo+0x5a>
      acc = (acc & 0xffffUL) + (acc >> 16);
  10dc8a:	0f b7 55 f4          	movzwl 0xfffffff4(%ebp),%edx
  10dc8e:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10dc91:	c1 e8 10             	shr    $0x10,%eax
  10dc94:	8d 04 02             	lea    (%edx,%eax,1),%eax
  10dc97:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  10dc9a:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10dc9d:	c1 e8 10             	shr    $0x10,%eax
  10dca0:	85 c0                	test   %eax,%eax
  10dca2:	75 e6                	jne    10dc8a <inet_chksum_pseudo+0x4a>
    }
    if (q->len % 2 != 0) {
  10dca4:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10dca7:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  10dcab:	0f b7 c0             	movzwl %ax,%eax
  10dcae:	83 e0 01             	and    $0x1,%eax
  10dcb1:	84 c0                	test   %al,%al
  10dcb3:	74 24                	je     10dcd9 <inet_chksum_pseudo+0x99>
      swapped = 1 - swapped;
  10dcb5:	b8 01 00 00 00       	mov    $0x1,%eax
  10dcba:	2a 45 ff             	sub    0xffffffff(%ebp),%al
  10dcbd:	88 45 ff             	mov    %al,0xffffffff(%ebp)
      acc = ((acc & 0xff) << 8) | ((acc & 0xff00UL) >> 8);
  10dcc0:	0f b6 45 f4          	movzbl 0xfffffff4(%ebp),%eax
  10dcc4:	89 c2                	mov    %eax,%edx
  10dcc6:	c1 e2 08             	shl    $0x8,%edx
  10dcc9:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10dccc:	25 00 ff 00 00       	and    $0xff00,%eax
  10dcd1:	c1 e8 08             	shr    $0x8,%eax
  10dcd4:	09 d0                	or     %edx,%eax
  10dcd6:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  10dcd9:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10dcdc:	8b 00                	mov    (%eax),%eax
  10dcde:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  10dce1:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  10dce5:	0f 85 7b ff ff ff    	jne    10dc66 <inet_chksum_pseudo+0x26>
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%lx \n", acc));*/
  }

  if (swapped) {
  10dceb:	80 7d ff 00          	cmpb   $0x0,0xffffffff(%ebp)
  10dcef:	74 19                	je     10dd0a <inet_chksum_pseudo+0xca>
    acc = ((acc & 0xff) << 8) | ((acc & 0xff00UL) >> 8);
  10dcf1:	0f b6 45 f4          	movzbl 0xfffffff4(%ebp),%eax
  10dcf5:	89 c2                	mov    %eax,%edx
  10dcf7:	c1 e2 08             	shl    $0x8,%edx
  10dcfa:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10dcfd:	25 00 ff 00 00       	and    $0xff00,%eax
  10dd02:	c1 e8 08             	shr    $0x8,%eax
  10dd05:	09 d0                	or     %edx,%eax
  10dd07:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  }
  acc += (src->addr & 0xffffUL);
  10dd0a:	8b 45 0c             	mov    0xc(%ebp),%eax
  10dd0d:	8b 00                	mov    (%eax),%eax
  10dd0f:	25 ff ff 00 00       	and    $0xffff,%eax
  10dd14:	01 45 f4             	add    %eax,0xfffffff4(%ebp)
  acc += ((src->addr >> 16) & 0xffffUL);
  10dd17:	8b 45 0c             	mov    0xc(%ebp),%eax
  10dd1a:	8b 00                	mov    (%eax),%eax
  10dd1c:	c1 e8 10             	shr    $0x10,%eax
  10dd1f:	25 ff ff 00 00       	and    $0xffff,%eax
  10dd24:	01 45 f4             	add    %eax,0xfffffff4(%ebp)
  acc += (dest->addr & 0xffffUL);
  10dd27:	8b 45 10             	mov    0x10(%ebp),%eax
  10dd2a:	8b 00                	mov    (%eax),%eax
  10dd2c:	25 ff ff 00 00       	and    $0xffff,%eax
  10dd31:	01 45 f4             	add    %eax,0xfffffff4(%ebp)
  acc += ((dest->addr >> 16) & 0xffffUL);
  10dd34:	8b 45 10             	mov    0x10(%ebp),%eax
  10dd37:	8b 00                	mov    (%eax),%eax
  10dd39:	c1 e8 10             	shr    $0x10,%eax
  10dd3c:	25 ff ff 00 00       	and    $0xffff,%eax
  10dd41:	01 45 f4             	add    %eax,0xfffffff4(%ebp)
  acc += (u32_t)htons((u16_t)proto);
  10dd44:	0f b6 45 ec          	movzbl 0xffffffec(%ebp),%eax
  10dd48:	89 04 24             	mov    %eax,(%esp)
  10dd4b:	e8 30 05 00 00       	call   10e280 <htons>
  10dd50:	0f b7 c0             	movzwl %ax,%eax
  10dd53:	01 45 f4             	add    %eax,0xfffffff4(%ebp)
  acc += (u32_t)htons(proto_len);
  10dd56:	0f b7 45 e8          	movzwl 0xffffffe8(%ebp),%eax
  10dd5a:	89 04 24             	mov    %eax,(%esp)
  10dd5d:	e8 1e 05 00 00       	call   10e280 <htons>
  10dd62:	0f b7 c0             	movzwl %ax,%eax
  10dd65:	01 45 f4             	add    %eax,0xfffffff4(%ebp)

  while (acc >> 16) {
  10dd68:	eb 10                	jmp    10dd7a <inet_chksum_pseudo+0x13a>
    acc = (acc & 0xffffUL) + (acc >> 16);
  10dd6a:	0f b7 55 f4          	movzwl 0xfffffff4(%ebp),%edx
  10dd6e:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10dd71:	c1 e8 10             	shr    $0x10,%eax
  10dd74:	8d 04 02             	lea    (%edx,%eax,1),%eax
  10dd77:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  10dd7a:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10dd7d:	c1 e8 10             	shr    $0x10,%eax
  10dd80:	85 c0                	test   %eax,%eax
  10dd82:	75 e6                	jne    10dd6a <inet_chksum_pseudo+0x12a>
  }
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%lx\n", acc));
  return ~(acc & 0xffffUL);
  10dd84:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10dd87:	f7 d0                	not    %eax
  10dd89:	0f b7 c0             	movzwl %ax,%eax
}
  10dd8c:	c9                   	leave  
  10dd8d:	c3                   	ret    
  10dd8e:	89 f6                	mov    %esi,%esi

0010dd90 <inet_chksum>:

/* inet_chksum:
 *
 * Calculates the Internet checksum over a portion of memory. Used primarely for IP
 * and ICMP.
 */

u16_t
inet_chksum(void *dataptr, u16_t len)
{
  10dd90:	55                   	push   %ebp
  10dd91:	89 e5                	mov    %esp,%ebp
  10dd93:	83 ec 28             	sub    $0x28,%esp
  10dd96:	8b 45 0c             	mov    0xc(%ebp),%eax
  10dd99:	66 89 45 ec          	mov    %ax,0xffffffec(%ebp)
  u32_t acc;

  acc = lwip_chksum(dataptr, len);
  10dd9d:	0f b7 45 ec          	movzwl 0xffffffec(%ebp),%eax
  10dda1:	89 44 24 04          	mov    %eax,0x4(%esp)
  10dda5:	8b 45 08             	mov    0x8(%ebp),%eax
  10dda8:	89 04 24             	mov    %eax,(%esp)
  10ddab:	e8 00 fe ff ff       	call   10dbb0 <lwip_chksum>
  10ddb0:	0f b7 c0             	movzwl %ax,%eax
  10ddb3:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  while (acc >> 16) {
  10ddb6:	eb 10                	jmp    10ddc8 <inet_chksum+0x38>
    acc = (acc & 0xffff) + (acc >> 16);
  10ddb8:	0f b7 55 fc          	movzwl 0xfffffffc(%ebp),%edx
  10ddbc:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10ddbf:	c1 e8 10             	shr    $0x10,%eax
  10ddc2:	8d 04 02             	lea    (%edx,%eax,1),%eax
  10ddc5:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  10ddc8:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10ddcb:	c1 e8 10             	shr    $0x10,%eax
  10ddce:	85 c0                	test   %eax,%eax
  10ddd0:	75 e6                	jne    10ddb8 <inet_chksum+0x28>
  }
  return ~(acc & 0xffff);
  10ddd2:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10ddd5:	f7 d0                	not    %eax
  10ddd7:	0f b7 c0             	movzwl %ax,%eax
}
  10ddda:	c9                   	leave  
  10dddb:	c3                   	ret    
  10dddc:	8d 74 26 00          	lea    0x0(%esi),%esi

0010dde0 <inet_chksum_pbuf>:

u16_t
inet_chksum_pbuf(struct pbuf *p)
{
  10dde0:	55                   	push   %ebp
  10dde1:	89 e5                	mov    %esp,%ebp
  10dde3:	83 ec 18             	sub    $0x18,%esp
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  10dde6:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
  swapped = 0;
  10dded:	c6 45 ff 00          	movb   $0x0,0xffffffff(%ebp)
  for(q = p; q != NULL; q = q->next) {
  10ddf1:	8b 45 08             	mov    0x8(%ebp),%eax
  10ddf4:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  10ddf7:	eb 69                	jmp    10de62 <inet_chksum_pbuf+0x82>
    acc += lwip_chksum(q->payload, q->len);
  10ddf9:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10ddfc:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  10de00:	0f b7 d0             	movzwl %ax,%edx
  10de03:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10de06:	8b 40 04             	mov    0x4(%eax),%eax
  10de09:	89 54 24 04          	mov    %edx,0x4(%esp)
  10de0d:	89 04 24             	mov    %eax,(%esp)
  10de10:	e8 9b fd ff ff       	call   10dbb0 <lwip_chksum>
  10de15:	0f b7 c0             	movzwl %ax,%eax
  10de18:	01 45 f4             	add    %eax,0xfffffff4(%ebp)
    while (acc >> 16) {
  10de1b:	eb 10                	jmp    10de2d <inet_chksum_pbuf+0x4d>
      acc = (acc & 0xffffUL) + (acc >> 16);
  10de1d:	0f b7 55 f4          	movzwl 0xfffffff4(%ebp),%edx
  10de21:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10de24:	c1 e8 10             	shr    $0x10,%eax
  10de27:	8d 04 02             	lea    (%edx,%eax,1),%eax
  10de2a:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  10de2d:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10de30:	c1 e8 10             	shr    $0x10,%eax
  10de33:	85 c0                	test   %eax,%eax
  10de35:	75 e6                	jne    10de1d <inet_chksum_pbuf+0x3d>
    }
    if (q->len % 2 != 0) {
  10de37:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10de3a:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  10de3e:	0f b7 c0             	movzwl %ax,%eax
  10de41:	83 e0 01             	and    $0x1,%eax
  10de44:	84 c0                	test   %al,%al
  10de46:	74 12                	je     10de5a <inet_chksum_pbuf+0x7a>
      swapped = 1 - swapped;
  10de48:	b8 01 00 00 00       	mov    $0x1,%eax
  10de4d:	2a 45 ff             	sub    0xffffffff(%ebp),%al
  10de50:	88 45 ff             	mov    %al,0xffffffff(%ebp)
      acc = (acc & 0x00ffUL << 8) | (acc & 0xff00UL >> 8);
  10de53:	81 65 f4 ff ff 00 00 	andl   $0xffff,0xfffffff4(%ebp)
  10de5a:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10de5d:	8b 00                	mov    (%eax),%eax
  10de5f:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  10de62:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  10de66:	75 91                	jne    10ddf9 <inet_chksum_pbuf+0x19>
    }
  }

  if (swapped) {
  10de68:	80 7d ff 00          	cmpb   $0x0,0xffffffff(%ebp)
  10de6c:	74 19                	je     10de87 <inet_chksum_pbuf+0xa7>
    acc = ((acc & 0x00ffUL) << 8) | ((acc & 0xff00UL) >> 8);
  10de6e:	0f b6 45 f4          	movzbl 0xfffffff4(%ebp),%eax
  10de72:	89 c2                	mov    %eax,%edx
  10de74:	c1 e2 08             	shl    $0x8,%edx
  10de77:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10de7a:	25 00 ff 00 00       	and    $0xff00,%eax
  10de7f:	c1 e8 08             	shr    $0x8,%eax
  10de82:	09 d0                	or     %edx,%eax
  10de84:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  }
  return ~(acc & 0xffffUL);
  10de87:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10de8a:	f7 d0                	not    %eax
  10de8c:	0f b7 c0             	movzwl %ax,%eax
}
  10de8f:	c9                   	leave  
  10de90:	c3                   	ret    
  10de91:	eb 0d                	jmp    10dea0 <inet_addr>
  10de93:	90                   	nop    
  10de94:	90                   	nop    
  10de95:	90                   	nop    
  10de96:	90                   	nop    
  10de97:	90                   	nop    
  10de98:	90                   	nop    
  10de99:	90                   	nop    
  10de9a:	90                   	nop    
  10de9b:	90                   	nop    
  10de9c:	90                   	nop    
  10de9d:	90                   	nop    
  10de9e:	90                   	nop    
  10de9f:	90                   	nop    

0010dea0 <inet_addr>:

/* Here for now until needed in other places in lwIP */
#ifndef isascii
#define in_range(c, lo, up)  ((u8_t)c >= lo && (u8_t)c <= up)
#define isascii(c)           in_range(c, 0x20, 0x7f)
#define isdigit(c)           in_range(c, '0', '9')
#define isxdigit(c)          (isdigit(c) || in_range(c, 'a', 'f') || in_range(c, 'A', 'F'))
#define islower(c)           in_range(c, 'a', 'z')
#define isspace(c)           (c == ' ' || c == '\f' || c == '\n' || c == '\r' || c == '\t' || c == '\v')
#endif		
		

 /*
  * Ascii internet address interpretation routine.
  * The value returned is in network order.
  */

 /*  */
 /* inet_addr */
 u32_t inet_addr(const char *cp)
 {
  10dea0:	55                   	push   %ebp
  10dea1:	89 e5                	mov    %esp,%ebp
  10dea3:	83 ec 28             	sub    $0x28,%esp
     struct in_addr val;

     if (inet_aton(cp, &val)) {
  10dea6:	8d 45 fc             	lea    0xfffffffc(%ebp),%eax
  10dea9:	89 44 24 04          	mov    %eax,0x4(%esp)
  10dead:	8b 45 08             	mov    0x8(%ebp),%eax
  10deb0:	89 04 24             	mov    %eax,(%esp)
  10deb3:	e8 18 00 00 00       	call   10ded0 <inet_aton>
  10deb8:	85 c0                	test   %eax,%eax
  10deba:	74 08                	je     10dec4 <inet_addr+0x24>
         return (val.s_addr);
  10debc:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10debf:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  10dec2:	eb 07                	jmp    10decb <inet_addr+0x2b>
     }
     return (INADDR_NONE);
  10dec4:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  10decb:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
 }
  10dece:	c9                   	leave  
  10decf:	c3                   	ret    

0010ded0 <inet_aton>:

 /*
  * Check whether "cp" is a valid ascii representation
  * of an Internet address and convert to a binary address.
  * Returns 1 if the address is valid, 0 if not.
  * This replaces inet_addr, the return value from which
  * cannot distinguish between failure and a local broadcast address.
  */
 /*  */
 /* inet_aton */
 int inet_aton(const char *cp, struct in_addr *addr)
 {
  10ded0:	55                   	push   %ebp
  10ded1:	89 e5                	mov    %esp,%ebp
  10ded3:	83 ec 48             	sub    $0x48,%esp
     u32_t val;
     int base, n;
     char c;
     u32_t parts[4];
     u32_t* pp = parts;
  10ded6:	8d 45 dc             	lea    0xffffffdc(%ebp),%eax
  10ded9:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)

     c = *cp;
  10dedc:	8b 45 08             	mov    0x8(%ebp),%eax
  10dedf:	0f b6 00             	movzbl (%eax),%eax
  10dee2:	88 45 fb             	mov    %al,0xfffffffb(%ebp)
     for (;;) {
         /*
          * Collect number up to ``.''.
          * Values are specified as for C:
          * 0x=hex, 0=octal, isdigit=decimal.
          */
         if (!isdigit(c))
  10dee5:	0f b6 45 fb          	movzbl 0xfffffffb(%ebp),%eax
  10dee9:	3c 2f                	cmp    $0x2f,%al
  10deeb:	76 08                	jbe    10def5 <inet_aton+0x25>
  10deed:	0f b6 45 fb          	movzbl 0xfffffffb(%ebp),%eax
  10def1:	3c 39                	cmp    $0x39,%al
  10def3:	76 0c                	jbe    10df01 <inet_aton+0x31>
             return (0);
  10def5:	c7 45 c0 00 00 00 00 	movl   $0x0,0xffffffc0(%ebp)
  10defc:	e9 78 02 00 00       	jmp    10e179 <inet_aton+0x2a9>
         val = 0; base = 10;
  10df01:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  10df08:	c7 45 f0 0a 00 00 00 	movl   $0xa,0xfffffff0(%ebp)
         if (c == '0') {
  10df0f:	80 7d fb 30          	cmpb   $0x30,0xfffffffb(%ebp)
  10df13:	75 36                	jne    10df4b <inet_aton+0x7b>
             c = *++cp;
  10df15:	83 45 08 01          	addl   $0x1,0x8(%ebp)
  10df19:	8b 45 08             	mov    0x8(%ebp),%eax
  10df1c:	0f b6 00             	movzbl (%eax),%eax
  10df1f:	88 45 fb             	mov    %al,0xfffffffb(%ebp)
             if (c == 'x' || c == 'X')
  10df22:	80 7d fb 78          	cmpb   $0x78,0xfffffffb(%ebp)
  10df26:	74 06                	je     10df2e <inet_aton+0x5e>
  10df28:	80 7d fb 58          	cmpb   $0x58,0xfffffffb(%ebp)
  10df2c:	75 16                	jne    10df44 <inet_aton+0x74>
                 base = 16, c = *++cp;
  10df2e:	c7 45 f0 10 00 00 00 	movl   $0x10,0xfffffff0(%ebp)
  10df35:	83 45 08 01          	addl   $0x1,0x8(%ebp)
  10df39:	8b 45 08             	mov    0x8(%ebp),%eax
  10df3c:	0f b6 00             	movzbl (%eax),%eax
  10df3f:	88 45 fb             	mov    %al,0xfffffffb(%ebp)
  10df42:	eb 07                	jmp    10df4b <inet_aton+0x7b>
             else
                 base = 8;
  10df44:	c7 45 f0 08 00 00 00 	movl   $0x8,0xfffffff0(%ebp)
         }
         for (;;) {
             if (isascii(c) && isdigit(c)) {
  10df4b:	0f b6 45 fb          	movzbl 0xfffffffb(%ebp),%eax
  10df4f:	3c 1f                	cmp    $0x1f,%al
  10df51:	76 3b                	jbe    10df8e <inet_aton+0xbe>
  10df53:	80 7d fb 00          	cmpb   $0x0,0xfffffffb(%ebp)
  10df57:	78 35                	js     10df8e <inet_aton+0xbe>
  10df59:	0f b6 45 fb          	movzbl 0xfffffffb(%ebp),%eax
  10df5d:	3c 2f                	cmp    $0x2f,%al
  10df5f:	76 2d                	jbe    10df8e <inet_aton+0xbe>
  10df61:	0f b6 45 fb          	movzbl 0xfffffffb(%ebp),%eax
  10df65:	3c 39                	cmp    $0x39,%al
  10df67:	77 25                	ja     10df8e <inet_aton+0xbe>
                 val = (val * base) + (c - '0');
  10df69:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10df6c:	89 c2                	mov    %eax,%edx
  10df6e:	0f af 55 ec          	imul   0xffffffec(%ebp),%edx
  10df72:	0f be 45 fb          	movsbl 0xfffffffb(%ebp),%eax
  10df76:	8d 04 02             	lea    (%edx,%eax,1),%eax
  10df79:	83 e8 30             	sub    $0x30,%eax
  10df7c:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
                 c = *++cp;
  10df7f:	83 45 08 01          	addl   $0x1,0x8(%ebp)
  10df83:	8b 45 08             	mov    0x8(%ebp),%eax
  10df86:	0f b6 00             	movzbl (%eax),%eax
  10df89:	88 45 fb             	mov    %al,0xfffffffb(%ebp)
  10df8c:	eb bd                	jmp    10df4b <inet_aton+0x7b>
             } else if (base == 16 && isascii(c) && isxdigit(c)) {
  10df8e:	83 7d f0 10          	cmpl   $0x10,0xfffffff0(%ebp)
  10df92:	0f 85 99 00 00 00    	jne    10e031 <inet_aton+0x161>
  10df98:	0f b6 45 fb          	movzbl 0xfffffffb(%ebp),%eax
  10df9c:	3c 1f                	cmp    $0x1f,%al
  10df9e:	0f 86 8d 00 00 00    	jbe    10e031 <inet_aton+0x161>
  10dfa4:	80 7d fb 00          	cmpb   $0x0,0xfffffffb(%ebp)
  10dfa8:	0f 88 83 00 00 00    	js     10e031 <inet_aton+0x161>
  10dfae:	0f b6 45 fb          	movzbl 0xfffffffb(%ebp),%eax
  10dfb2:	3c 2f                	cmp    $0x2f,%al
  10dfb4:	76 08                	jbe    10dfbe <inet_aton+0xee>
  10dfb6:	0f b6 45 fb          	movzbl 0xfffffffb(%ebp),%eax
  10dfba:	3c 39                	cmp    $0x39,%al
  10dfbc:	76 20                	jbe    10dfde <inet_aton+0x10e>
  10dfbe:	0f b6 45 fb          	movzbl 0xfffffffb(%ebp),%eax
  10dfc2:	3c 60                	cmp    $0x60,%al
  10dfc4:	76 08                	jbe    10dfce <inet_aton+0xfe>
  10dfc6:	0f b6 45 fb          	movzbl 0xfffffffb(%ebp),%eax
  10dfca:	3c 66                	cmp    $0x66,%al
  10dfcc:	76 10                	jbe    10dfde <inet_aton+0x10e>
  10dfce:	0f b6 45 fb          	movzbl 0xfffffffb(%ebp),%eax
  10dfd2:	3c 40                	cmp    $0x40,%al
  10dfd4:	76 5b                	jbe    10e031 <inet_aton+0x161>
  10dfd6:	0f b6 45 fb          	movzbl 0xfffffffb(%ebp),%eax
  10dfda:	3c 46                	cmp    $0x46,%al
  10dfdc:	77 53                	ja     10e031 <inet_aton+0x161>
                 val = (val << 4) |
  10dfde:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10dfe1:	89 c2                	mov    %eax,%edx
  10dfe3:	c1 e2 04             	shl    $0x4,%edx
  10dfe6:	89 55 c4             	mov    %edx,0xffffffc4(%ebp)
  10dfe9:	0f be 45 fb          	movsbl 0xfffffffb(%ebp),%eax
  10dfed:	83 c0 0a             	add    $0xa,%eax
  10dff0:	89 45 c8             	mov    %eax,0xffffffc8(%ebp)
  10dff3:	0f b6 45 fb          	movzbl 0xfffffffb(%ebp),%eax
  10dff7:	3c 60                	cmp    $0x60,%al
  10dff9:	76 11                	jbe    10e00c <inet_aton+0x13c>
  10dffb:	0f b6 45 fb          	movzbl 0xfffffffb(%ebp),%eax
  10dfff:	3c 7a                	cmp    $0x7a,%al
  10e001:	77 09                	ja     10e00c <inet_aton+0x13c>
  10e003:	c7 45 cc 61 00 00 00 	movl   $0x61,0xffffffcc(%ebp)
  10e00a:	eb 07                	jmp    10e013 <inet_aton+0x143>
  10e00c:	c7 45 cc 41 00 00 00 	movl   $0x41,0xffffffcc(%ebp)
  10e013:	8b 45 c8             	mov    0xffffffc8(%ebp),%eax
  10e016:	2b 45 cc             	sub    0xffffffcc(%ebp),%eax
  10e019:	0b 45 c4             	or     0xffffffc4(%ebp),%eax
  10e01c:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
                     (c + 10 - (islower(c) ? 'a' : 'A'));
                 c = *++cp;
  10e01f:	83 45 08 01          	addl   $0x1,0x8(%ebp)
  10e023:	8b 45 08             	mov    0x8(%ebp),%eax
  10e026:	0f b6 00             	movzbl (%eax),%eax
  10e029:	88 45 fb             	mov    %al,0xfffffffb(%ebp)
             } else
             break;
         }
  10e02c:	e9 1a ff ff ff       	jmp    10df4b <inet_aton+0x7b>
         if (c == '.') {
  10e031:	80 7d fb 2e          	cmpb   $0x2e,0xfffffffb(%ebp)
  10e035:	75 35                	jne    10e06c <inet_aton+0x19c>
             /*
              * Internet format:
              *  a.b.c.d
              *  a.b.c   (with c treated as 16 bits)
              *  a.b (with b treated as 24 bits)
              */
             if (pp >= parts + 3)
  10e037:	8d 45 dc             	lea    0xffffffdc(%ebp),%eax
  10e03a:	83 c0 0c             	add    $0xc,%eax
  10e03d:	3b 45 fc             	cmp    0xfffffffc(%ebp),%eax
  10e040:	77 0c                	ja     10e04e <inet_aton+0x17e>
                 return (0);
  10e042:	c7 45 c0 00 00 00 00 	movl   $0x0,0xffffffc0(%ebp)
  10e049:	e9 2b 01 00 00       	jmp    10e179 <inet_aton+0x2a9>
             *pp++ = val;
  10e04e:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  10e051:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10e054:	89 02                	mov    %eax,(%edx)
  10e056:	83 45 fc 04          	addl   $0x4,0xfffffffc(%ebp)
             c = *++cp;
  10e05a:	83 45 08 01          	addl   $0x1,0x8(%ebp)
  10e05e:	8b 45 08             	mov    0x8(%ebp),%eax
  10e061:	0f b6 00             	movzbl (%eax),%eax
  10e064:	88 45 fb             	mov    %al,0xfffffffb(%ebp)
         } else
             break;
     }
  10e067:	e9 79 fe ff ff       	jmp    10dee5 <inet_aton+0x15>
     /*
      * Check for trailing characters.
      */
     if (c != '\0' && (!isascii(c) || !isspace(c)))
  10e06c:	80 7d fb 00          	cmpb   $0x0,0xfffffffb(%ebp)
  10e070:	74 3e                	je     10e0b0 <inet_aton+0x1e0>
  10e072:	0f b6 45 fb          	movzbl 0xfffffffb(%ebp),%eax
  10e076:	3c 1f                	cmp    $0x1f,%al
  10e078:	76 2a                	jbe    10e0a4 <inet_aton+0x1d4>
  10e07a:	80 7d fb 00          	cmpb   $0x0,0xfffffffb(%ebp)
  10e07e:	78 24                	js     10e0a4 <inet_aton+0x1d4>
  10e080:	80 7d fb 20          	cmpb   $0x20,0xfffffffb(%ebp)
  10e084:	74 2a                	je     10e0b0 <inet_aton+0x1e0>
  10e086:	80 7d fb 0c          	cmpb   $0xc,0xfffffffb(%ebp)
  10e08a:	74 24                	je     10e0b0 <inet_aton+0x1e0>
  10e08c:	80 7d fb 0a          	cmpb   $0xa,0xfffffffb(%ebp)
  10e090:	74 1e                	je     10e0b0 <inet_aton+0x1e0>
  10e092:	80 7d fb 0d          	cmpb   $0xd,0xfffffffb(%ebp)
  10e096:	74 18                	je     10e0b0 <inet_aton+0x1e0>
  10e098:	80 7d fb 09          	cmpb   $0x9,0xfffffffb(%ebp)
  10e09c:	74 12                	je     10e0b0 <inet_aton+0x1e0>
  10e09e:	80 7d fb 0b          	cmpb   $0xb,0xfffffffb(%ebp)
  10e0a2:	74 0c                	je     10e0b0 <inet_aton+0x1e0>
         return (0);
  10e0a4:	c7 45 c0 00 00 00 00 	movl   $0x0,0xffffffc0(%ebp)
  10e0ab:	e9 c9 00 00 00       	jmp    10e179 <inet_aton+0x2a9>
     /*
      * Concoct the address according to
      * the number of parts specified.
      */
     n = pp - parts + 1;
  10e0b0:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  10e0b3:	8d 45 dc             	lea    0xffffffdc(%ebp),%eax
  10e0b6:	89 d1                	mov    %edx,%ecx
  10e0b8:	29 c1                	sub    %eax,%ecx
  10e0ba:	89 c8                	mov    %ecx,%eax
  10e0bc:	c1 f8 02             	sar    $0x2,%eax
  10e0bf:	83 c0 01             	add    $0x1,%eax
  10e0c2:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
     switch (n) {
  10e0c5:	83 7d f4 04          	cmpl   $0x4,0xfffffff4(%ebp)
  10e0c9:	0f 87 8b 00 00 00    	ja     10e15a <inet_aton+0x28a>
  10e0cf:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10e0d2:	c1 e0 02             	shl    $0x2,%eax
  10e0d5:	8b 80 d0 ad 11 00    	mov    0x11add0(%eax),%eax
  10e0db:	ff e0                	jmp    *%eax

     case 0:
         return (0);     /* initial nondigit */
  10e0dd:	c7 45 c0 00 00 00 00 	movl   $0x0,0xffffffc0(%ebp)
  10e0e4:	e9 90 00 00 00       	jmp    10e179 <inet_aton+0x2a9>

     case 1:             /* a -- 32 bits */
         break;

     case 2:             /* a.b -- 8.24 bits */
         if (val > 0xffffff)
  10e0e9:	81 7d ec ff ff ff 00 	cmpl   $0xffffff,0xffffffec(%ebp)
  10e0f0:	76 09                	jbe    10e0fb <inet_aton+0x22b>
             return (0);
  10e0f2:	c7 45 c0 00 00 00 00 	movl   $0x0,0xffffffc0(%ebp)
  10e0f9:	eb 7e                	jmp    10e179 <inet_aton+0x2a9>
         val |= parts[0] << 24;
  10e0fb:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  10e0fe:	c1 e0 18             	shl    $0x18,%eax
  10e101:	09 45 ec             	or     %eax,0xffffffec(%ebp)
         break;
  10e104:	eb 54                	jmp    10e15a <inet_aton+0x28a>

     case 3:             /* a.b.c -- 8.8.16 bits */
         if (val > 0xffff)
  10e106:	81 7d ec ff ff 00 00 	cmpl   $0xffff,0xffffffec(%ebp)
  10e10d:	76 09                	jbe    10e118 <inet_aton+0x248>
             return (0);
  10e10f:	c7 45 c0 00 00 00 00 	movl   $0x0,0xffffffc0(%ebp)
  10e116:	eb 61                	jmp    10e179 <inet_aton+0x2a9>
         val |= (parts[0] << 24) | (parts[1] << 16);
  10e118:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  10e11b:	89 c2                	mov    %eax,%edx
  10e11d:	c1 e2 18             	shl    $0x18,%edx
  10e120:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  10e123:	c1 e0 10             	shl    $0x10,%eax
  10e126:	09 d0                	or     %edx,%eax
  10e128:	09 45 ec             	or     %eax,0xffffffec(%ebp)
         break;
  10e12b:	eb 2d                	jmp    10e15a <inet_aton+0x28a>

     case 4:             /* a.b.c.d -- 8.8.8.8 bits */
         if (val > 0xff)
  10e12d:	81 7d ec ff 00 00 00 	cmpl   $0xff,0xffffffec(%ebp)
  10e134:	76 09                	jbe    10e13f <inet_aton+0x26f>
             return (0);
  10e136:	c7 45 c0 00 00 00 00 	movl   $0x0,0xffffffc0(%ebp)
  10e13d:	eb 3a                	jmp    10e179 <inet_aton+0x2a9>
         val |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);
  10e13f:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  10e142:	89 c2                	mov    %eax,%edx
  10e144:	c1 e2 18             	shl    $0x18,%edx
  10e147:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  10e14a:	c1 e0 10             	shl    $0x10,%eax
  10e14d:	09 c2                	or     %eax,%edx
  10e14f:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
  10e152:	c1 e0 08             	shl    $0x8,%eax
  10e155:	09 d0                	or     %edx,%eax
  10e157:	09 45 ec             	or     %eax,0xffffffec(%ebp)
         break;
     }
     if (addr)
  10e15a:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  10e15e:	74 12                	je     10e172 <inet_aton+0x2a2>
         addr->s_addr = htonl(val);
  10e160:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10e163:	89 04 24             	mov    %eax,(%esp)
  10e166:	e8 65 01 00 00       	call   10e2d0 <htonl>
  10e16b:	89 c2                	mov    %eax,%edx
  10e16d:	8b 45 0c             	mov    0xc(%ebp),%eax
  10e170:	89 10                	mov    %edx,(%eax)
     return (1);
  10e172:	c7 45 c0 01 00 00 00 	movl   $0x1,0xffffffc0(%ebp)
  10e179:	8b 45 c0             	mov    0xffffffc0(%ebp),%eax
 }
  10e17c:	c9                   	leave  
  10e17d:	c3                   	ret    
  10e17e:	89 f6                	mov    %esi,%esi

0010e180 <inet_ntoa>:

/* Convert numeric IP address into decimal dotted ASCII representation.
 * returns ptr to static buffer; not reentrant!
 */
char *inet_ntoa(struct in_addr addr)
{
  10e180:	55                   	push   %ebp
  10e181:	89 e5                	mov    %esp,%ebp
  10e183:	53                   	push   %ebx
  10e184:	83 ec 24             	sub    $0x24,%esp
  static char str[16];
  u32_t s_addr = addr.s_addr;
  10e187:	8b 45 08             	mov    0x8(%ebp),%eax
  10e18a:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  char inv[3];
  char *rp;
  char *ap;
  u8_t rem;
  u8_t n;
  u8_t i;

  rp = str;
  10e18d:	c7 45 f0 bc f8 11 00 	movl   $0x11f8bc,0xfffffff0(%ebp)
  ap = (u8_t *)&s_addr;
  10e194:	8d 45 ec             	lea    0xffffffec(%ebp),%eax
  10e197:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  for(n = 0; n < 4; n++) {
  10e19a:	c6 45 fa 00          	movb   $0x0,0xfffffffa(%ebp)
  10e19e:	e9 af 00 00 00       	jmp    10e252 <inet_ntoa+0xd2>
    i = 0;
  10e1a3:	c6 45 fb 00          	movb   $0x0,0xfffffffb(%ebp)
    do {
      rem = *ap % (u8_t)10;
  10e1a7:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10e1aa:	0f b6 08             	movzbl (%eax),%ecx
  10e1ad:	b8 67 00 00 00       	mov    $0x67,%eax
  10e1b2:	f6 e9                	imul   %cl
  10e1b4:	66 c1 e8 08          	shr    $0x8,%ax
  10e1b8:	89 c2                	mov    %eax,%edx
  10e1ba:	c0 fa 02             	sar    $0x2,%dl
  10e1bd:	89 c8                	mov    %ecx,%eax
  10e1bf:	c0 f8 07             	sar    $0x7,%al
  10e1c2:	89 d3                	mov    %edx,%ebx
  10e1c4:	28 c3                	sub    %al,%bl
  10e1c6:	88 5d db             	mov    %bl,0xffffffdb(%ebp)
  10e1c9:	0f b6 45 db          	movzbl 0xffffffdb(%ebp),%eax
  10e1cd:	c1 e0 02             	shl    $0x2,%eax
  10e1d0:	02 45 db             	add    0xffffffdb(%ebp),%al
  10e1d3:	01 c0                	add    %eax,%eax
  10e1d5:	89 ca                	mov    %ecx,%edx
  10e1d7:	28 c2                	sub    %al,%dl
  10e1d9:	88 55 db             	mov    %dl,0xffffffdb(%ebp)
  10e1dc:	0f b6 5d db          	movzbl 0xffffffdb(%ebp),%ebx
  10e1e0:	88 5d f9             	mov    %bl,0xfffffff9(%ebp)
      *ap /= (u8_t)10;
  10e1e3:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10e1e6:	0f b6 08             	movzbl (%eax),%ecx
  10e1e9:	b8 67 00 00 00       	mov    $0x67,%eax
  10e1ee:	f6 e9                	imul   %cl
  10e1f0:	66 c1 e8 08          	shr    $0x8,%ax
  10e1f4:	89 c2                	mov    %eax,%edx
  10e1f6:	c0 fa 02             	sar    $0x2,%dl
  10e1f9:	89 c8                	mov    %ecx,%eax
  10e1fb:	c0 f8 07             	sar    $0x7,%al
  10e1fe:	28 c2                	sub    %al,%dl
  10e200:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10e203:	88 10                	mov    %dl,(%eax)
      inv[i++] = '0' + rem;
  10e205:	0f b6 55 fb          	movzbl 0xfffffffb(%ebp),%edx
  10e209:	0f b6 45 f9          	movzbl 0xfffffff9(%ebp),%eax
  10e20d:	83 c0 30             	add    $0x30,%eax
  10e210:	88 44 15 e9          	mov    %al,0xffffffe9(%ebp,%edx,1)
  10e214:	80 45 fb 01          	addb   $0x1,0xfffffffb(%ebp)
    } while(*ap);
  10e218:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10e21b:	0f b6 00             	movzbl (%eax),%eax
  10e21e:	84 c0                	test   %al,%al
  10e220:	75 85                	jne    10e1a7 <inet_ntoa+0x27>
    while(i--)
  10e222:	eb 12                	jmp    10e236 <inet_ntoa+0xb6>
      *rp++ = inv[i];
  10e224:	0f b6 45 fb          	movzbl 0xfffffffb(%ebp),%eax
  10e228:	0f b6 54 05 e9       	movzbl 0xffffffe9(%ebp,%eax,1),%edx
  10e22d:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10e230:	88 10                	mov    %dl,(%eax)
  10e232:	83 45 f0 01          	addl   $0x1,0xfffffff0(%ebp)
  10e236:	80 6d fb 01          	subb   $0x1,0xfffffffb(%ebp)
  10e23a:	80 7d fb ff          	cmpb   $0xff,0xfffffffb(%ebp)
  10e23e:	75 e4                	jne    10e224 <inet_ntoa+0xa4>
    *rp++ = '.';
  10e240:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10e243:	c6 00 2e             	movb   $0x2e,(%eax)
  10e246:	83 45 f0 01          	addl   $0x1,0xfffffff0(%ebp)
    ap++;
  10e24a:	83 45 f4 01          	addl   $0x1,0xfffffff4(%ebp)
  10e24e:	80 45 fa 01          	addb   $0x1,0xfffffffa(%ebp)
  10e252:	80 7d fa 03          	cmpb   $0x3,0xfffffffa(%ebp)
  10e256:	0f 86 47 ff ff ff    	jbe    10e1a3 <inet_ntoa+0x23>
  }
  *--rp = 0;
  10e25c:	83 6d f0 01          	subl   $0x1,0xfffffff0(%ebp)
  10e260:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10e263:	c6 00 00             	movb   $0x0,(%eax)
  return str;
  10e266:	b8 bc f8 11 00       	mov    $0x11f8bc,%eax
}
  10e26b:	83 c4 24             	add    $0x24,%esp
  10e26e:	5b                   	pop    %ebx
  10e26f:	5d                   	pop    %ebp
  10e270:	c3                   	ret    
  10e271:	eb 0d                	jmp    10e280 <htons>
  10e273:	90                   	nop    
  10e274:	90                   	nop    
  10e275:	90                   	nop    
  10e276:	90                   	nop    
  10e277:	90                   	nop    
  10e278:	90                   	nop    
  10e279:	90                   	nop    
  10e27a:	90                   	nop    
  10e27b:	90                   	nop    
  10e27c:	90                   	nop    
  10e27d:	90                   	nop    
  10e27e:	90                   	nop    
  10e27f:	90                   	nop    

0010e280 <htons>:


#ifndef BYTE_ORDER
#error BYTE_ORDER is not defined
#endif
#if BYTE_ORDER == LITTLE_ENDIAN

u16_t
htons(u16_t n)
{
  10e280:	55                   	push   %ebp
  10e281:	89 e5                	mov    %esp,%ebp
  10e283:	83 ec 04             	sub    $0x4,%esp
  10e286:	8b 45 08             	mov    0x8(%ebp),%eax
  10e289:	66 89 45 fc          	mov    %ax,0xfffffffc(%ebp)
  return ((n & 0xff) << 8) | ((n & 0xff00) >> 8);
  10e28d:	0f b7 45 fc          	movzwl 0xfffffffc(%ebp),%eax
  10e291:	25 ff 00 00 00       	and    $0xff,%eax
  10e296:	c1 e0 08             	shl    $0x8,%eax
  10e299:	89 c2                	mov    %eax,%edx
  10e29b:	0f b7 45 fc          	movzwl 0xfffffffc(%ebp),%eax
  10e29f:	25 00 ff 00 00       	and    $0xff00,%eax
  10e2a4:	c1 f8 08             	sar    $0x8,%eax
  10e2a7:	09 d0                	or     %edx,%eax
  10e2a9:	0f b7 c0             	movzwl %ax,%eax
}
  10e2ac:	c9                   	leave  
  10e2ad:	c3                   	ret    
  10e2ae:	89 f6                	mov    %esi,%esi

0010e2b0 <ntohs>:

u16_t
ntohs(u16_t n)
{
  10e2b0:	55                   	push   %ebp
  10e2b1:	89 e5                	mov    %esp,%ebp
  10e2b3:	83 ec 08             	sub    $0x8,%esp
  10e2b6:	8b 45 08             	mov    0x8(%ebp),%eax
  10e2b9:	66 89 45 fc          	mov    %ax,0xfffffffc(%ebp)
  return htons(n);
  10e2bd:	0f b7 45 fc          	movzwl 0xfffffffc(%ebp),%eax
  10e2c1:	89 04 24             	mov    %eax,(%esp)
  10e2c4:	e8 b7 ff ff ff       	call   10e280 <htons>
  10e2c9:	0f b7 c0             	movzwl %ax,%eax
}
  10e2cc:	c9                   	leave  
  10e2cd:	c3                   	ret    
  10e2ce:	89 f6                	mov    %esi,%esi

0010e2d0 <htonl>:

u32_t
htonl(u32_t n)
{
  10e2d0:	55                   	push   %ebp
  10e2d1:	89 e5                	mov    %esp,%ebp
  return ((n & 0xff) << 24) |
  10e2d3:	0f b6 45 08          	movzbl 0x8(%ebp),%eax
  10e2d7:	89 c2                	mov    %eax,%edx
  10e2d9:	c1 e2 18             	shl    $0x18,%edx
  10e2dc:	8b 45 08             	mov    0x8(%ebp),%eax
  10e2df:	25 00 ff 00 00       	and    $0xff00,%eax
  10e2e4:	c1 e0 08             	shl    $0x8,%eax
  10e2e7:	09 c2                	or     %eax,%edx
  10e2e9:	8b 45 08             	mov    0x8(%ebp),%eax
  10e2ec:	25 00 00 ff 00       	and    $0xff0000,%eax
  10e2f1:	c1 e8 08             	shr    $0x8,%eax
  10e2f4:	09 c2                	or     %eax,%edx
  10e2f6:	8b 45 08             	mov    0x8(%ebp),%eax
  10e2f9:	25 00 00 00 ff       	and    $0xff000000,%eax
  10e2fe:	c1 e8 18             	shr    $0x18,%eax
  10e301:	09 d0                	or     %edx,%eax
    ((n & 0xff00) << 8) |
    ((n & 0xff0000) >> 8) |
    ((n & 0xff000000) >> 24);
}
  10e303:	5d                   	pop    %ebp
  10e304:	c3                   	ret    
  10e305:	8d 74 26 00          	lea    0x0(%esi),%esi
  10e309:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

0010e310 <ntohl>:

u32_t
ntohl(u32_t n)
{
  10e310:	55                   	push   %ebp
  10e311:	89 e5                	mov    %esp,%ebp
  10e313:	83 ec 04             	sub    $0x4,%esp
  return htonl(n);
  10e316:	8b 45 08             	mov    0x8(%ebp),%eax
  10e319:	89 04 24             	mov    %eax,(%esp)
  10e31c:	e8 af ff ff ff       	call   10e2d0 <htonl>
}
  10e321:	c9                   	leave  
  10e322:	c3                   	ret    
  10e323:	90                   	nop    
  10e324:	90                   	nop    
  10e325:	90                   	nop    
  10e326:	90                   	nop    
  10e327:	90                   	nop    
  10e328:	90                   	nop    
  10e329:	90                   	nop    
  10e32a:	90                   	nop    
  10e32b:	90                   	nop    
  10e32c:	90                   	nop    
  10e32d:	90                   	nop    
  10e32e:	90                   	nop    
  10e32f:	90                   	nop    

0010e330 <plug_holes>:
static sys_sem_t mem_sem;

static void
plug_holes(struct mem *mem)
{
  10e330:	55                   	push   %ebp
  10e331:	89 e5                	mov    %esp,%ebp
  10e333:	53                   	push   %ebx
  10e334:	83 ec 10             	sub    $0x10,%esp
  struct mem *nmem;
  struct mem *pmem;

  LWIP_ASSERT("plug_holes: mem >= ram", (u8_t *)mem >= ram);
  LWIP_ASSERT("plug_holes: mem < ram_end", (u8_t *)mem < (u8_t *)ram_end);
  LWIP_ASSERT("plug_holes: mem->used == 0", mem->used == 0);
  
  /* plug hole forward */
  LWIP_ASSERT("plug_holes: mem->next <= MEM_SIZE", mem->next <= MEM_SIZE);
  
  nmem = (struct mem *)&ram[mem->next];
  10e337:	8b 45 08             	mov    0x8(%ebp),%eax
  10e33a:	8b 00                	mov    (%eax),%eax
  10e33c:	05 00 f9 11 00       	add    $0x11f900,%eax
  10e341:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  if (mem != nmem && nmem->used == 0 && (u8_t *)nmem != (u8_t *)ram_end) {
  10e344:	8b 45 08             	mov    0x8(%ebp),%eax
  10e347:	3b 45 f4             	cmp    0xfffffff4(%ebp),%eax
  10e34a:	74 51                	je     10e39d <plug_holes+0x6d>
  10e34c:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10e34f:	0f b6 40 08          	movzbl 0x8(%eax),%eax
  10e353:	84 c0                	test   %al,%al
  10e355:	75 46                	jne    10e39d <plug_holes+0x6d>
  10e357:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10e35a:	8b 15 e0 f8 11 00    	mov    0x11f8e0,%edx
  10e360:	39 d0                	cmp    %edx,%eax
  10e362:	74 39                	je     10e39d <plug_holes+0x6d>
    if (lfree == nmem) {
  10e364:	a1 10 f9 12 00       	mov    0x12f910,%eax
  10e369:	3b 45 f4             	cmp    0xfffffff4(%ebp),%eax
  10e36c:	75 08                	jne    10e376 <plug_holes+0x46>
      lfree = mem;
  10e36e:	8b 45 08             	mov    0x8(%ebp),%eax
  10e371:	a3 10 f9 12 00       	mov    %eax,0x12f910
    }
    mem->next = nmem->next;
  10e376:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10e379:	8b 10                	mov    (%eax),%edx
  10e37b:	8b 45 08             	mov    0x8(%ebp),%eax
  10e37e:	89 10                	mov    %edx,(%eax)
    ((struct mem *)&ram[nmem->next])->prev = (u8_t *)mem - ram;
  10e380:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10e383:	8b 00                	mov    (%eax),%eax
  10e385:	05 00 f9 11 00       	add    $0x11f900,%eax
  10e38a:	89 c1                	mov    %eax,%ecx
  10e38c:	8b 55 08             	mov    0x8(%ebp),%edx
  10e38f:	b8 00 f9 11 00       	mov    $0x11f900,%eax
  10e394:	89 d3                	mov    %edx,%ebx
  10e396:	29 c3                	sub    %eax,%ebx
  10e398:	89 d8                	mov    %ebx,%eax
  10e39a:	89 41 04             	mov    %eax,0x4(%ecx)
  }

  /* plug hole backward */
  pmem = (struct mem *)&ram[mem->prev];
  10e39d:	8b 45 08             	mov    0x8(%ebp),%eax
  10e3a0:	8b 40 04             	mov    0x4(%eax),%eax
  10e3a3:	05 00 f9 11 00       	add    $0x11f900,%eax
  10e3a8:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  if (pmem != mem && pmem->used == 0) {
  10e3ab:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10e3ae:	3b 45 08             	cmp    0x8(%ebp),%eax
  10e3b1:	74 44                	je     10e3f7 <plug_holes+0xc7>
  10e3b3:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10e3b6:	0f b6 40 08          	movzbl 0x8(%eax),%eax
  10e3ba:	84 c0                	test   %al,%al
  10e3bc:	75 39                	jne    10e3f7 <plug_holes+0xc7>
    if (lfree == mem) {
  10e3be:	a1 10 f9 12 00       	mov    0x12f910,%eax
  10e3c3:	3b 45 08             	cmp    0x8(%ebp),%eax
  10e3c6:	75 08                	jne    10e3d0 <plug_holes+0xa0>
      lfree = pmem;
  10e3c8:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10e3cb:	a3 10 f9 12 00       	mov    %eax,0x12f910
    }
    pmem->next = mem->next;
  10e3d0:	8b 45 08             	mov    0x8(%ebp),%eax
  10e3d3:	8b 10                	mov    (%eax),%edx
  10e3d5:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10e3d8:	89 10                	mov    %edx,(%eax)
    ((struct mem *)&ram[mem->next])->prev = (u8_t *)pmem - ram;
  10e3da:	8b 45 08             	mov    0x8(%ebp),%eax
  10e3dd:	8b 00                	mov    (%eax),%eax
  10e3df:	05 00 f9 11 00       	add    $0x11f900,%eax
  10e3e4:	89 c1                	mov    %eax,%ecx
  10e3e6:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  10e3e9:	b8 00 f9 11 00       	mov    $0x11f900,%eax
  10e3ee:	89 d3                	mov    %edx,%ebx
  10e3f0:	29 c3                	sub    %eax,%ebx
  10e3f2:	89 d8                	mov    %ebx,%eax
  10e3f4:	89 41 04             	mov    %eax,0x4(%ecx)
  }

}
  10e3f7:	83 c4 10             	add    $0x10,%esp
  10e3fa:	5b                   	pop    %ebx
  10e3fb:	5d                   	pop    %ebp
  10e3fc:	c3                   	ret    
  10e3fd:	8d 76 00             	lea    0x0(%esi),%esi

0010e400 <mem_init>:
void
mem_init(void)
{
  10e400:	55                   	push   %ebp
  10e401:	89 e5                	mov    %esp,%ebp
  10e403:	83 ec 28             	sub    $0x28,%esp
  struct mem *mem;

  memset(ram, 0, MEM_SIZE);
  10e406:	c7 44 24 08 00 00 01 	movl   $0x10000,0x8(%esp)
  10e40d:	00 
  10e40e:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  10e415:	00 
  10e416:	c7 04 24 00 f9 11 00 	movl   $0x11f900,(%esp)
  10e41d:	e8 ae 7a ff ff       	call   105ed0 <memset>
  mem = (struct mem *)ram;
  10e422:	c7 45 fc 00 f9 11 00 	movl   $0x11f900,0xfffffffc(%ebp)
  mem->next = MEM_SIZE;
  10e429:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10e42c:	c7 00 00 00 01 00    	movl   $0x10000,(%eax)
  mem->prev = 0;
  10e432:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10e435:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  mem->used = 0;
  10e43c:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10e43f:	c6 40 08 00          	movb   $0x0,0x8(%eax)
  ram_end = (struct mem *)&ram[MEM_SIZE];
  10e443:	b8 00 f9 12 00       	mov    $0x12f900,%eax
  10e448:	a3 e0 f8 11 00       	mov    %eax,0x11f8e0
  ram_end->used = 1;
  10e44d:	a1 e0 f8 11 00       	mov    0x11f8e0,%eax
  10e452:	c6 40 08 01          	movb   $0x1,0x8(%eax)
  ram_end->next = MEM_SIZE;
  10e456:	a1 e0 f8 11 00       	mov    0x11f8e0,%eax
  10e45b:	c7 00 00 00 01 00    	movl   $0x10000,(%eax)
  ram_end->prev = MEM_SIZE;
  10e461:	a1 e0 f8 11 00       	mov    0x11f8e0,%eax
  10e466:	c7 40 04 00 00 01 00 	movl   $0x10000,0x4(%eax)

  mem_sem = sys_sem_new(1);
  10e46d:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  10e474:	e8 d7 b8 00 00       	call   119d50 <sys_sem_new>
  10e479:	a3 14 f9 12 00       	mov    %eax,0x12f914

  lfree = (struct mem *)ram;
  10e47e:	b8 00 f9 11 00       	mov    $0x11f900,%eax
  10e483:	a3 10 f9 12 00       	mov    %eax,0x12f910

#if MEM_STATS
  lwip_stats.mem.avail = MEM_SIZE;
  10e488:	c7 05 88 15 14 00 00 	movl   $0x10000,0x141588
  10e48f:	00 01 00 
#endif /* MEM_STATS */
}
  10e492:	c9                   	leave  
  10e493:	c3                   	ret    
  10e494:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  10e49a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

0010e4a0 <mem_free>:
void
mem_free(void *rmem)
{
  10e4a0:	55                   	push   %ebp
  10e4a1:	89 e5                	mov    %esp,%ebp
  10e4a3:	53                   	push   %ebx
  10e4a4:	83 ec 14             	sub    $0x14,%esp
  struct mem *mem;

  if (rmem == NULL) {
  10e4a7:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  10e4ab:	75 05                	jne    10e4b2 <mem_free+0x12>
    LWIP_DEBUGF(MEM_DEBUG | DBG_TRACE | 2, ("mem_free(p == NULL) was called.\n"));
    return;
  10e4ad:	e9 a3 00 00 00       	jmp    10e555 <mem_free+0xb5>
  }
  
  sys_sem_wait(mem_sem);
  10e4b2:	a1 14 f9 12 00       	mov    0x12f914,%eax
  10e4b7:	89 04 24             	mov    %eax,(%esp)
  10e4ba:	e8 51 19 00 00       	call   10fe10 <sys_sem_wait>

  LWIP_ASSERT("mem_free: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
    (u8_t *)rmem < (u8_t *)ram_end);
  
  if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
  10e4bf:	8b 45 08             	mov    0x8(%ebp),%eax
  10e4c2:	3d 00 f9 11 00       	cmp    $0x11f900,%eax
  10e4c7:	72 0d                	jb     10e4d6 <mem_free+0x36>
  10e4c9:	8b 45 08             	mov    0x8(%ebp),%eax
  10e4cc:	8b 15 e0 f8 11 00    	mov    0x11f8e0,%edx
  10e4d2:	39 d0                	cmp    %edx,%eax
  10e4d4:	72 1c                	jb     10e4f2 <mem_free+0x52>
    LWIP_DEBUGF(MEM_DEBUG | 3, ("mem_free: illegal memory\n"));
#if MEM_STATS
    ++lwip_stats.mem.err;
  10e4d6:	a1 94 15 14 00       	mov    0x141594,%eax
  10e4db:	83 c0 01             	add    $0x1,%eax
  10e4de:	a3 94 15 14 00       	mov    %eax,0x141594
#endif /* MEM_STATS */
    sys_sem_signal(mem_sem);
  10e4e3:	a1 14 f9 12 00       	mov    0x12f914,%eax
  10e4e8:	89 04 24             	mov    %eax,(%esp)
  10e4eb:	e8 e0 b8 00 00       	call   119dd0 <sys_sem_signal>
    return;
  10e4f0:	eb 63                	jmp    10e555 <mem_free+0xb5>
  }
  mem = (struct mem *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  10e4f2:	8b 45 08             	mov    0x8(%ebp),%eax
  10e4f5:	83 e8 0c             	sub    $0xc,%eax
  10e4f8:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)

  LWIP_ASSERT("mem_free: mem->used", mem->used);
  
  mem->used = 0;
  10e4fb:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10e4fe:	c6 40 08 00          	movb   $0x0,0x8(%eax)

  if (mem < lfree) {
  10e502:	a1 10 f9 12 00       	mov    0x12f910,%eax
  10e507:	39 45 f8             	cmp    %eax,0xfffffff8(%ebp)
  10e50a:	73 08                	jae    10e514 <mem_free+0x74>
    lfree = mem;
  10e50c:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10e50f:	a3 10 f9 12 00       	mov    %eax,0x12f910
  }
  
#if MEM_STATS
  lwip_stats.mem.used -= mem->next - ((u8_t *)mem - ram);
  10e514:	8b 0d 8c 15 14 00    	mov    0x14158c,%ecx
  10e51a:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10e51d:	89 c2                	mov    %eax,%edx
  10e51f:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10e522:	8b 00                	mov    (%eax),%eax
  10e524:	89 d3                	mov    %edx,%ebx
  10e526:	29 c3                	sub    %eax,%ebx
  10e528:	89 d8                	mov    %ebx,%eax
  10e52a:	8d 14 01             	lea    (%ecx,%eax,1),%edx
  10e52d:	b8 00 f9 11 00       	mov    $0x11f900,%eax
  10e532:	89 d1                	mov    %edx,%ecx
  10e534:	29 c1                	sub    %eax,%ecx
  10e536:	89 c8                	mov    %ecx,%eax
  10e538:	a3 8c 15 14 00       	mov    %eax,0x14158c
  
#endif /* MEM_STATS */
  plug_holes(mem);
  10e53d:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10e540:	89 04 24             	mov    %eax,(%esp)
  10e543:	e8 e8 fd ff ff       	call   10e330 <plug_holes>
  sys_sem_signal(mem_sem);
  10e548:	a1 14 f9 12 00       	mov    0x12f914,%eax
  10e54d:	89 04 24             	mov    %eax,(%esp)
  10e550:	e8 7b b8 00 00       	call   119dd0 <sys_sem_signal>
}
  10e555:	83 c4 14             	add    $0x14,%esp
  10e558:	5b                   	pop    %ebx
  10e559:	5d                   	pop    %ebp
  10e55a:	c3                   	ret    
  10e55b:	90                   	nop    
  10e55c:	8d 74 26 00          	lea    0x0(%esi),%esi

0010e560 <mem_reallocm>:
void *
mem_reallocm(void *rmem, mem_size_t newsize)
{
  10e560:	55                   	push   %ebp
  10e561:	89 e5                	mov    %esp,%ebp
  10e563:	83 ec 28             	sub    $0x28,%esp
  void *nmem;
  nmem = mem_malloc(newsize);
  10e566:	8b 45 0c             	mov    0xc(%ebp),%eax
  10e569:	89 04 24             	mov    %eax,(%esp)
  10e56c:	e8 5f 01 00 00       	call   10e6d0 <mem_malloc>
  10e571:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  if (nmem == NULL) {
  10e574:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  10e578:	75 17                	jne    10e591 <mem_reallocm+0x31>
    return mem_realloc(rmem, newsize);
  10e57a:	8b 45 0c             	mov    0xc(%ebp),%eax
  10e57d:	89 44 24 04          	mov    %eax,0x4(%esp)
  10e581:	8b 45 08             	mov    0x8(%ebp),%eax
  10e584:	89 04 24             	mov    %eax,(%esp)
  10e587:	e8 34 00 00 00       	call   10e5c0 <mem_realloc>
  10e58c:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  10e58f:	eb 2a                	jmp    10e5bb <mem_reallocm+0x5b>
  }
  memcpy(nmem, rmem, newsize);
  10e591:	8b 45 0c             	mov    0xc(%ebp),%eax
  10e594:	89 44 24 08          	mov    %eax,0x8(%esp)
  10e598:	8b 45 08             	mov    0x8(%ebp),%eax
  10e59b:	89 44 24 04          	mov    %eax,0x4(%esp)
  10e59f:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10e5a2:	89 04 24             	mov    %eax,(%esp)
  10e5a5:	e8 e6 78 ff ff       	call   105e90 <memcpy>
  mem_free(rmem);
  10e5aa:	8b 45 08             	mov    0x8(%ebp),%eax
  10e5ad:	89 04 24             	mov    %eax,(%esp)
  10e5b0:	e8 eb fe ff ff       	call   10e4a0 <mem_free>
  return nmem;
  10e5b5:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10e5b8:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  10e5bb:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  10e5be:	c9                   	leave  
  10e5bf:	c3                   	ret    

0010e5c0 <mem_realloc>:

void *
mem_realloc(void *rmem, mem_size_t newsize)
{
  10e5c0:	55                   	push   %ebp
  10e5c1:	89 e5                	mov    %esp,%ebp
  10e5c3:	83 ec 28             	sub    $0x28,%esp
  mem_size_t size;
  mem_size_t ptr, ptr2;
  struct mem *mem, *mem2;

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  if ((newsize % MEM_ALIGNMENT) != 0) {
   newsize += MEM_ALIGNMENT - ((newsize + SIZEOF_STRUCT_MEM) % MEM_ALIGNMENT);
  }
  
  if (newsize > MEM_SIZE) {
  10e5c6:	81 7d 0c 00 00 01 00 	cmpl   $0x10000,0xc(%ebp)
  10e5cd:	76 0c                	jbe    10e5db <mem_realloc+0x1b>
    return NULL;
  10e5cf:	c7 45 dc 00 00 00 00 	movl   $0x0,0xffffffdc(%ebp)
  10e5d6:	e9 f0 00 00 00       	jmp    10e6cb <mem_realloc+0x10b>
  }
  
  sys_sem_wait(mem_sem);
  10e5db:	a1 14 f9 12 00       	mov    0x12f914,%eax
  10e5e0:	89 04 24             	mov    %eax,(%esp)
  10e5e3:	e8 28 18 00 00       	call   10fe10 <sys_sem_wait>
  
  LWIP_ASSERT("mem_realloc: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
   (u8_t *)rmem < (u8_t *)ram_end);
  
  if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
  10e5e8:	8b 45 08             	mov    0x8(%ebp),%eax
  10e5eb:	3d 00 f9 11 00       	cmp    $0x11f900,%eax
  10e5f0:	72 0d                	jb     10e5ff <mem_realloc+0x3f>
  10e5f2:	8b 45 08             	mov    0x8(%ebp),%eax
  10e5f5:	8b 15 e0 f8 11 00    	mov    0x11f8e0,%edx
  10e5fb:	39 d0                	cmp    %edx,%eax
  10e5fd:	72 0b                	jb     10e60a <mem_realloc+0x4a>
    LWIP_DEBUGF(MEM_DEBUG | 3, ("mem_realloc: illegal memory\n"));
    return rmem;
  10e5ff:	8b 45 08             	mov    0x8(%ebp),%eax
  10e602:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
  10e605:	e9 c1 00 00 00       	jmp    10e6cb <mem_realloc+0x10b>
  }
  mem = (struct mem *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  10e60a:	8b 45 08             	mov    0x8(%ebp),%eax
  10e60d:	83 e8 0c             	sub    $0xc,%eax
  10e610:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)

  ptr = (u8_t *)mem - ram;
  10e613:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  10e616:	b8 00 f9 11 00       	mov    $0x11f900,%eax
  10e61b:	89 d1                	mov    %edx,%ecx
  10e61d:	29 c1                	sub    %eax,%ecx
  10e61f:	89 c8                	mov    %ecx,%eax
  10e621:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)

  size = mem->next - ptr - SIZEOF_STRUCT_MEM;
  10e624:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10e627:	8b 00                	mov    (%eax),%eax
  10e629:	2b 45 f0             	sub    0xfffffff0(%ebp),%eax
  10e62c:	83 e8 0c             	sub    $0xc,%eax
  10e62f:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
#if MEM_STATS
  lwip_stats.mem.used -= (size - newsize);
  10e632:	8b 0d 8c 15 14 00    	mov    0x14158c,%ecx
  10e638:	8b 55 0c             	mov    0xc(%ebp),%edx
  10e63b:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10e63e:	29 d0                	sub    %edx,%eax
  10e640:	89 ca                	mov    %ecx,%edx
  10e642:	29 c2                	sub    %eax,%edx
  10e644:	89 d0                	mov    %edx,%eax
  10e646:	a3 8c 15 14 00       	mov    %eax,0x14158c
#endif /* MEM_STATS */
  
  if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE < size) {
  10e64b:	8b 45 0c             	mov    0xc(%ebp),%eax
  10e64e:	83 c0 18             	add    $0x18,%eax
  10e651:	3b 45 ec             	cmp    0xffffffec(%ebp),%eax
  10e654:	73 62                	jae    10e6b8 <mem_realloc+0xf8>
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
  10e656:	8b 45 0c             	mov    0xc(%ebp),%eax
  10e659:	03 45 f0             	add    0xfffffff0(%ebp),%eax
  10e65c:	83 c0 0c             	add    $0xc,%eax
  10e65f:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
    mem2 = (struct mem *)&ram[ptr2];
  10e662:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10e665:	05 00 f9 11 00       	add    $0x11f900,%eax
  10e66a:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
    mem2->used = 0;
  10e66d:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10e670:	c6 40 08 00          	movb   $0x0,0x8(%eax)
    mem2->next = mem->next;
  10e674:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10e677:	8b 10                	mov    (%eax),%edx
  10e679:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10e67c:	89 10                	mov    %edx,(%eax)
    mem2->prev = ptr;
  10e67e:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  10e681:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10e684:	89 42 04             	mov    %eax,0x4(%edx)
    mem->next = ptr2;
  10e687:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  10e68a:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10e68d:	89 02                	mov    %eax,(%edx)
    if (mem2->next != MEM_SIZE) {
  10e68f:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10e692:	8b 00                	mov    (%eax),%eax
  10e694:	3d 00 00 01 00       	cmp    $0x10000,%eax
  10e699:	74 12                	je     10e6ad <mem_realloc+0xed>
      ((struct mem *)&ram[mem2->next])->prev = ptr2;
  10e69b:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10e69e:	8b 00                	mov    (%eax),%eax
  10e6a0:	05 00 f9 11 00       	add    $0x11f900,%eax
  10e6a5:	89 c2                	mov    %eax,%edx
  10e6a7:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10e6aa:	89 42 04             	mov    %eax,0x4(%edx)
    }

    plug_holes(mem2);
  10e6ad:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10e6b0:	89 04 24             	mov    %eax,(%esp)
  10e6b3:	e8 78 fc ff ff       	call   10e330 <plug_holes>
  }
  sys_sem_signal(mem_sem);  
  10e6b8:	a1 14 f9 12 00       	mov    0x12f914,%eax
  10e6bd:	89 04 24             	mov    %eax,(%esp)
  10e6c0:	e8 0b b7 00 00       	call   119dd0 <sys_sem_signal>
  return rmem;
  10e6c5:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10e6c8:	89 4d dc             	mov    %ecx,0xffffffdc(%ebp)
  10e6cb:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
}
  10e6ce:	c9                   	leave  
  10e6cf:	c3                   	ret    

0010e6d0 <mem_malloc>:
void *
mem_malloc(mem_size_t size)
{
  10e6d0:	55                   	push   %ebp
  10e6d1:	89 e5                	mov    %esp,%ebp
  10e6d3:	83 ec 18             	sub    $0x18,%esp
  mem_size_t ptr, ptr2;
  struct mem *mem, *mem2;

  if (size == 0) {
  10e6d6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  10e6da:	75 0c                	jne    10e6e8 <mem_malloc+0x18>
    return NULL;
  10e6dc:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  10e6e3:	e9 7b 01 00 00       	jmp    10e863 <mem_malloc+0x193>
  }

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  if ((size % MEM_ALIGNMENT) != 0) {
    size += MEM_ALIGNMENT - ((size + SIZEOF_STRUCT_MEM) % MEM_ALIGNMENT);
  }
  
  if (size > MEM_SIZE) {
  10e6e8:	81 7d 08 00 00 01 00 	cmpl   $0x10000,0x8(%ebp)
  10e6ef:	76 0c                	jbe    10e6fd <mem_malloc+0x2d>
    return NULL;
  10e6f1:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  10e6f8:	e9 66 01 00 00       	jmp    10e863 <mem_malloc+0x193>
  }
  
  sys_sem_wait(mem_sem);
  10e6fd:	a1 14 f9 12 00       	mov    0x12f914,%eax
  10e702:	89 04 24             	mov    %eax,(%esp)
  10e705:	e8 06 17 00 00       	call   10fe10 <sys_sem_wait>

  for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE; ptr = ((struct mem *)&ram[ptr])->next) {
  10e70a:	a1 10 f9 12 00       	mov    0x12f910,%eax
  10e70f:	89 c2                	mov    %eax,%edx
  10e711:	b8 00 f9 11 00       	mov    $0x11f900,%eax
  10e716:	89 d1                	mov    %edx,%ecx
  10e718:	29 c1                	sub    %eax,%ecx
  10e71a:	89 c8                	mov    %ecx,%eax
  10e71c:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
  10e71f:	e9 11 01 00 00       	jmp    10e835 <mem_malloc+0x165>
    mem = (struct mem *)&ram[ptr];
  10e724:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10e727:	05 00 f9 11 00       	add    $0x11f900,%eax
  10e72c:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
    if (!mem->used &&
  10e72f:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10e732:	0f b6 40 08          	movzbl 0x8(%eax),%eax
  10e736:	84 c0                	test   %al,%al
  10e738:	0f 85 ea 00 00 00    	jne    10e828 <mem_malloc+0x158>
  10e73e:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10e741:	8b 00                	mov    (%eax),%eax
  10e743:	2b 45 f0             	sub    0xfffffff0(%ebp),%eax
  10e746:	8d 50 f4             	lea    0xfffffff4(%eax),%edx
  10e749:	8b 45 08             	mov    0x8(%ebp),%eax
  10e74c:	83 c0 0c             	add    $0xc,%eax
  10e74f:	39 c2                	cmp    %eax,%edx
  10e751:	0f 82 d1 00 00 00    	jb     10e828 <mem_malloc+0x158>
       mem->next - (ptr + SIZEOF_STRUCT_MEM) >= size + SIZEOF_STRUCT_MEM) {
      ptr2 = ptr + SIZEOF_STRUCT_MEM + size;
  10e757:	8b 45 08             	mov    0x8(%ebp),%eax
  10e75a:	03 45 f0             	add    0xfffffff0(%ebp),%eax
  10e75d:	83 c0 0c             	add    $0xc,%eax
  10e760:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
      mem2 = (struct mem *)&ram[ptr2];
  10e763:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10e766:	05 00 f9 11 00       	add    $0x11f900,%eax
  10e76b:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)

      mem2->prev = ptr;      
  10e76e:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  10e771:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10e774:	89 42 04             	mov    %eax,0x4(%edx)
      mem2->next = mem->next;
  10e777:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10e77a:	8b 10                	mov    (%eax),%edx
  10e77c:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10e77f:	89 10                	mov    %edx,(%eax)
      mem->next = ptr2;      
  10e781:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  10e784:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10e787:	89 02                	mov    %eax,(%edx)
      if (mem2->next != MEM_SIZE) {
  10e789:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10e78c:	8b 00                	mov    (%eax),%eax
  10e78e:	3d 00 00 01 00       	cmp    $0x10000,%eax
  10e793:	74 12                	je     10e7a7 <mem_malloc+0xd7>
        ((struct mem *)&ram[mem2->next])->prev = ptr2;
  10e795:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10e798:	8b 00                	mov    (%eax),%eax
  10e79a:	05 00 f9 11 00       	add    $0x11f900,%eax
  10e79f:	89 c2                	mov    %eax,%edx
  10e7a1:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10e7a4:	89 42 04             	mov    %eax,0x4(%edx)
      }
      
      mem2->used = 0;      
  10e7a7:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10e7aa:	c6 40 08 00          	movb   $0x0,0x8(%eax)
      mem->used = 1;
  10e7ae:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10e7b1:	c6 40 08 01          	movb   $0x1,0x8(%eax)
#if MEM_STATS
      lwip_stats.mem.used += (size + SIZEOF_STRUCT_MEM);
  10e7b5:	a1 8c 15 14 00       	mov    0x14158c,%eax
  10e7ba:	03 45 08             	add    0x8(%ebp),%eax
  10e7bd:	83 c0 0c             	add    $0xc,%eax
  10e7c0:	a3 8c 15 14 00       	mov    %eax,0x14158c
      /*      if (lwip_stats.mem.max < lwip_stats.mem.used) {
        lwip_stats.mem.max = lwip_stats.mem.used;
  } */
      if (lwip_stats.mem.max < ptr2) {
  10e7c5:	a1 90 15 14 00       	mov    0x141590,%eax
  10e7ca:	3b 45 f4             	cmp    0xfffffff4(%ebp),%eax
  10e7cd:	73 08                	jae    10e7d7 <mem_malloc+0x107>
        lwip_stats.mem.max = ptr2;
  10e7cf:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10e7d2:	a3 90 15 14 00       	mov    %eax,0x141590
      }      
#endif /* MEM_STATS */

      if (mem == lfree) {
  10e7d7:	a1 10 f9 12 00       	mov    0x12f910,%eax
  10e7dc:	39 45 f8             	cmp    %eax,0xfffffff8(%ebp)
  10e7df:	75 2f                	jne    10e810 <mem_malloc+0x140>
  /* Find next free block after mem */
        while (lfree->used && lfree != ram_end) {
  10e7e1:	eb 11                	jmp    10e7f4 <mem_malloc+0x124>
    lfree = (struct mem *)&ram[lfree->next];
  10e7e3:	a1 10 f9 12 00       	mov    0x12f910,%eax
  10e7e8:	8b 00                	mov    (%eax),%eax
  10e7ea:	05 00 f9 11 00       	add    $0x11f900,%eax
  10e7ef:	a3 10 f9 12 00       	mov    %eax,0x12f910
  10e7f4:	a1 10 f9 12 00       	mov    0x12f910,%eax
  10e7f9:	0f b6 40 08          	movzbl 0x8(%eax),%eax
  10e7fd:	84 c0                	test   %al,%al
  10e7ff:	74 0f                	je     10e810 <mem_malloc+0x140>
  10e801:	8b 15 10 f9 12 00    	mov    0x12f910,%edx
  10e807:	a1 e0 f8 11 00       	mov    0x11f8e0,%eax
  10e80c:	39 c2                	cmp    %eax,%edx
  10e80e:	75 d3                	jne    10e7e3 <mem_malloc+0x113>
        }
        LWIP_ASSERT("mem_malloc: !lfree->used", !lfree->used);
      }
      sys_sem_signal(mem_sem);
  10e810:	a1 14 f9 12 00       	mov    0x12f914,%eax
  10e815:	89 04 24             	mov    %eax,(%esp)
  10e818:	e8 b3 b5 00 00       	call   119dd0 <sys_sem_signal>
      LWIP_ASSERT("mem_malloc: allocated memory not above ram_end.",
       (mem_ptr_t)mem + SIZEOF_STRUCT_MEM + size <= (mem_ptr_t)ram_end);
      LWIP_ASSERT("mem_malloc: allocated memory properly aligned.",
       (unsigned long)((u8_t *)mem + SIZEOF_STRUCT_MEM) % MEM_ALIGNMENT == 0);
      return (u8_t *)mem + SIZEOF_STRUCT_MEM;
  10e81d:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10e820:	83 c0 0c             	add    $0xc,%eax
  10e823:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  10e826:	eb 3b                	jmp    10e863 <mem_malloc+0x193>
  10e828:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10e82b:	05 00 f9 11 00       	add    $0x11f900,%eax
  10e830:	8b 00                	mov    (%eax),%eax
  10e832:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
  10e835:	81 7d f0 ff ff 00 00 	cmpl   $0xffff,0xfffffff0(%ebp)
  10e83c:	0f 86 e2 fe ff ff    	jbe    10e724 <mem_malloc+0x54>
    }    
  }
  LWIP_DEBUGF(MEM_DEBUG | 2, ("mem_malloc: could not allocate %d bytes\n", (int)size));
#if MEM_STATS
  ++lwip_stats.mem.err;
  10e842:	a1 94 15 14 00       	mov    0x141594,%eax
  10e847:	83 c0 01             	add    $0x1,%eax
  10e84a:	a3 94 15 14 00       	mov    %eax,0x141594
#endif /* MEM_STATS */  
  sys_sem_signal(mem_sem);
  10e84f:	a1 14 f9 12 00       	mov    0x12f914,%eax
  10e854:	89 04 24             	mov    %eax,(%esp)
  10e857:	e8 74 b5 00 00       	call   119dd0 <sys_sem_signal>
  return NULL;
  10e85c:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  10e863:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  10e866:	c9                   	leave  
  10e867:	c3                   	ret    
  10e868:	90                   	nop    
  10e869:	90                   	nop    
  10e86a:	90                   	nop    
  10e86b:	90                   	nop    
  10e86c:	90                   	nop    
  10e86d:	90                   	nop    
  10e86e:	90                   	nop    
  10e86f:	90                   	nop    

0010e870 <memp_init>:
#endif /* MEMP_SANITY_CHECK*/

void
memp_init(void)
{
  10e870:	55                   	push   %ebp
  10e871:	89 e5                	mov    %esp,%ebp
  10e873:	53                   	push   %ebx
  10e874:	83 ec 14             	sub    $0x14,%esp
  struct memp *m, *memp;
  u16_t i, j;
  u16_t size;
      
#if MEMP_STATS
  for(i = 0; i < MEMP_MAX; ++i) {
  10e877:	66 c7 45 f6 00 00    	movw   $0x0,0xfffffff6(%ebp)
  10e87d:	eb 6a                	jmp    10e8e9 <memp_init+0x79>
    lwip_stats.memp[i].used = lwip_stats.memp[i].max =
  10e87f:	0f b7 5d f6          	movzwl 0xfffffff6(%ebp),%ebx
  10e883:	0f b7 4d f6          	movzwl 0xfffffff6(%ebp),%ecx
  10e887:	0f b7 55 f6          	movzwl 0xfffffff6(%ebp),%edx
  10e88b:	89 d0                	mov    %edx,%eax
  10e88d:	c1 e0 04             	shl    $0x4,%eax
  10e890:	c7 80 a4 15 14 00 00 	movl   $0x0,0x1415a4(%eax)
  10e897:	00 00 00 
  10e89a:	89 d0                	mov    %edx,%eax
  10e89c:	c1 e0 04             	shl    $0x4,%eax
  10e89f:	8b 90 a4 15 14 00    	mov    0x1415a4(%eax),%edx
  10e8a5:	89 c8                	mov    %ecx,%eax
  10e8a7:	c1 e0 04             	shl    $0x4,%eax
  10e8aa:	89 90 a0 15 14 00    	mov    %edx,0x1415a0(%eax)
  10e8b0:	89 c8                	mov    %ecx,%eax
  10e8b2:	c1 e0 04             	shl    $0x4,%eax
  10e8b5:	8b 90 a0 15 14 00    	mov    0x1415a0(%eax),%edx
  10e8bb:	89 d8                	mov    %ebx,%eax
  10e8bd:	c1 e0 04             	shl    $0x4,%eax
  10e8c0:	89 90 9c 15 14 00    	mov    %edx,0x14159c(%eax)
      lwip_stats.memp[i].err = 0;
    lwip_stats.memp[i].avail = memp_num[i];
  10e8c6:	0f b7 4d f6          	movzwl 0xfffffff6(%ebp),%ecx
  10e8ca:	0f b7 45 f6          	movzwl 0xfffffff6(%ebp),%eax
  10e8ce:	0f b7 84 00 26 ae 11 	movzwl 0x11ae26(%eax,%eax,1),%eax
  10e8d5:	00 
  10e8d6:	0f b7 d0             	movzwl %ax,%edx
  10e8d9:	89 c8                	mov    %ecx,%eax
  10e8db:	c1 e0 04             	shl    $0x4,%eax
  10e8de:	89 90 98 15 14 00    	mov    %edx,0x141598(%eax)
  10e8e4:	66 83 45 f6 01       	addw   $0x1,0xfffffff6(%ebp)
  10e8e9:	66 83 7d f6 0a       	cmpw   $0xa,0xfffffff6(%ebp)
  10e8ee:	76 8f                	jbe    10e87f <memp_init+0xf>
  }
#endif /* MEMP_STATS */

  memp = (struct memp *)&memp_memory[0];
  10e8f0:	c7 45 f0 60 f9 12 00 	movl   $0x12f960,0xfffffff0(%ebp)
  for(i = 0; i < MEMP_MAX; ++i) {
  10e8f7:	66 c7 45 f6 00 00    	movw   $0x0,0xfffffff6(%ebp)
  10e8fd:	e9 9d 00 00 00       	jmp    10e99f <memp_init+0x12f>
    size = MEM_ALIGN_SIZE(memp_sizes[i] + sizeof(struct memp));
  10e902:	0f b7 45 f6          	movzwl 0xfffffff6(%ebp),%eax
  10e906:	0f b7 84 00 10 ae 11 	movzwl 0x11ae10(%eax,%eax,1),%eax
  10e90d:	00 
  10e90e:	83 c0 04             	add    $0x4,%eax
  10e911:	66 89 45 fa          	mov    %ax,0xfffffffa(%ebp)
    if (memp_num[i] > 0) {
  10e915:	0f b7 45 f6          	movzwl 0xfffffff6(%ebp),%eax
  10e919:	0f b7 84 00 26 ae 11 	movzwl 0x11ae26(%eax,%eax,1),%eax
  10e920:	00 
  10e921:	66 85 c0             	test   %ax,%ax
  10e924:	74 65                	je     10e98b <memp_init+0x11b>
      memp_tab[i] = memp;
  10e926:	0f b7 45 f6          	movzwl 0xfffffff6(%ebp),%eax
  10e92a:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
  10e92d:	89 14 85 20 f9 12 00 	mov    %edx,0x12f920(,%eax,4)
      m = memp;
  10e934:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10e937:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
      
      for(j = 0; j < memp_num[i]; ++j) {
  10e93a:	66 c7 45 f8 00 00    	movw   $0x0,0xfffffff8(%ebp)
  10e940:	eb 26                	jmp    10e968 <memp_init+0xf8>
  m->next = (struct memp *)MEM_ALIGN((u8_t *)m + size);
  10e942:	0f b7 45 fa          	movzwl 0xfffffffa(%ebp),%eax
  10e946:	89 c2                	mov    %eax,%edx
  10e948:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10e94b:	8d 04 02             	lea    (%edx,%eax,1),%eax
  10e94e:	89 c2                	mov    %eax,%edx
  10e950:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10e953:	89 10                	mov    %edx,(%eax)
  memp = m;
  10e955:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10e958:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
  m = m->next;
  10e95b:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10e95e:	8b 00                	mov    (%eax),%eax
  10e960:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  10e963:	66 83 45 f8 01       	addw   $0x1,0xfffffff8(%ebp)
  10e968:	0f b7 45 f6          	movzwl 0xfffffff6(%ebp),%eax
  10e96c:	0f b7 84 00 26 ae 11 	movzwl 0x11ae26(%eax,%eax,1),%eax
  10e973:	00 
  10e974:	66 3b 45 f8          	cmp    0xfffffff8(%ebp),%ax
  10e978:	77 c8                	ja     10e942 <memp_init+0xd2>
      }
      memp->next = NULL;
  10e97a:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10e97d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
      memp = m;
  10e983:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10e986:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
  10e989:	eb 0f                	jmp    10e99a <memp_init+0x12a>
    } else {
      memp_tab[i] = NULL;
  10e98b:	0f b7 45 f6          	movzwl 0xfffffff6(%ebp),%eax
  10e98f:	c7 04 85 20 f9 12 00 	movl   $0x0,0x12f920(,%eax,4)
  10e996:	00 00 00 00 
  10e99a:	66 83 45 f6 01       	addw   $0x1,0xfffffff6(%ebp)
  10e99f:	66 83 7d f6 0a       	cmpw   $0xa,0xfffffff6(%ebp)
  10e9a4:	0f 86 58 ff ff ff    	jbe    10e902 <memp_init+0x92>
    }
  }

#if !SYS_LIGHTWEIGHT_PROT
  mutex = sys_sem_new(1);
  10e9aa:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  10e9b1:	e8 9a b3 00 00       	call   119d50 <sys_sem_new>
  10e9b6:	a3 94 08 13 00       	mov    %eax,0x130894
#endif

  
}
  10e9bb:	83 c4 14             	add    $0x14,%esp
  10e9be:	5b                   	pop    %ebx
  10e9bf:	5d                   	pop    %ebp
  10e9c0:	c3                   	ret    
  10e9c1:	eb 0d                	jmp    10e9d0 <memp_malloc>
  10e9c3:	90                   	nop    
  10e9c4:	90                   	nop    
  10e9c5:	90                   	nop    
  10e9c6:	90                   	nop    
  10e9c7:	90                   	nop    
  10e9c8:	90                   	nop    
  10e9c9:	90                   	nop    
  10e9ca:	90                   	nop    
  10e9cb:	90                   	nop    
  10e9cc:	90                   	nop    
  10e9cd:	90                   	nop    
  10e9ce:	90                   	nop    
  10e9cf:	90                   	nop    

0010e9d0 <memp_malloc>:

void *
memp_malloc(memp_t type)
{
  10e9d0:	55                   	push   %ebp
  10e9d1:	89 e5                	mov    %esp,%ebp
  10e9d3:	83 ec 18             	sub    $0x18,%esp
  struct memp *memp;
  void *mem;
#if SYS_LIGHTWEIGHT_PROT
  SYS_ARCH_DECL_PROTECT(old_level);
#endif
 
  LWIP_ASSERT("memp_malloc: type < MEMP_MAX", type < MEMP_MAX);

#if SYS_LIGHTWEIGHT_PROT
  SYS_ARCH_PROTECT(old_level);
#else /* SYS_LIGHTWEIGHT_PROT */  
  sys_sem_wait(mutex);
  10e9d6:	a1 94 08 13 00       	mov    0x130894,%eax
  10e9db:	89 04 24             	mov    %eax,(%esp)
  10e9de:	e8 2d 14 00 00       	call   10fe10 <sys_sem_wait>
#endif /* SYS_LIGHTWEIGHT_PROT */  

  memp = memp_tab[type];
  10e9e3:	8b 45 08             	mov    0x8(%ebp),%eax
  10e9e6:	8b 04 85 20 f9 12 00 	mov    0x12f920(,%eax,4),%eax
  10e9ed:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  
  if (memp != NULL) {    
  10e9f0:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  10e9f4:	0f 84 88 00 00 00    	je     10ea82 <memp_malloc+0xb2>
    memp_tab[type] = memp->next;    
  10e9fa:	8b 55 08             	mov    0x8(%ebp),%edx
  10e9fd:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10ea00:	8b 00                	mov    (%eax),%eax
  10ea02:	89 04 95 20 f9 12 00 	mov    %eax,0x12f920(,%edx,4)
    memp->next = NULL;
  10ea09:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10ea0c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
#if MEMP_STATS
    ++lwip_stats.memp[type].used;
  10ea12:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10ea15:	89 c8                	mov    %ecx,%eax
  10ea17:	c1 e0 04             	shl    $0x4,%eax
  10ea1a:	8b 80 9c 15 14 00    	mov    0x14159c(%eax),%eax
  10ea20:	8d 50 01             	lea    0x1(%eax),%edx
  10ea23:	89 c8                	mov    %ecx,%eax
  10ea25:	c1 e0 04             	shl    $0x4,%eax
  10ea28:	89 90 9c 15 14 00    	mov    %edx,0x14159c(%eax)
    if (lwip_stats.memp[type].used > lwip_stats.memp[type].max) {
  10ea2e:	8b 45 08             	mov    0x8(%ebp),%eax
  10ea31:	c1 e0 04             	shl    $0x4,%eax
  10ea34:	8b 90 9c 15 14 00    	mov    0x14159c(%eax),%edx
  10ea3a:	8b 45 08             	mov    0x8(%ebp),%eax
  10ea3d:	c1 e0 04             	shl    $0x4,%eax
  10ea40:	8b 80 a0 15 14 00    	mov    0x1415a0(%eax),%eax
  10ea46:	39 c2                	cmp    %eax,%edx
  10ea48:	76 1a                	jbe    10ea64 <memp_malloc+0x94>
      lwip_stats.memp[type].max = lwip_stats.memp[type].used;
  10ea4a:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10ea4d:	8b 45 08             	mov    0x8(%ebp),%eax
  10ea50:	c1 e0 04             	shl    $0x4,%eax
  10ea53:	8b 90 9c 15 14 00    	mov    0x14159c(%eax),%edx
  10ea59:	89 c8                	mov    %ecx,%eax
  10ea5b:	c1 e0 04             	shl    $0x4,%eax
  10ea5e:	89 90 a0 15 14 00    	mov    %edx,0x1415a0(%eax)
    }
#endif /* MEMP_STATS */
#if SYS_LIGHTWEIGHT_PROT
    SYS_ARCH_UNPROTECT(old_level);
#else /* SYS_LIGHTWEIGHT_PROT */
    sys_sem_signal(mutex);
  10ea64:	a1 94 08 13 00       	mov    0x130894,%eax
  10ea69:	89 04 24             	mov    %eax,(%esp)
  10ea6c:	e8 5f b3 00 00       	call   119dd0 <sys_sem_signal>
#endif /* SYS_LIGHTWEIGHT_PROT */  
    LWIP_ASSERT("memp_malloc: memp properly aligned",
     ((mem_ptr_t)MEM_ALIGN((u8_t *)memp + sizeof(struct memp)) % MEM_ALIGNMENT) == 0);

    mem = MEM_ALIGN((u8_t *)memp + sizeof(struct memp));
  10ea71:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10ea74:	83 c0 04             	add    $0x4,%eax
  10ea77:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
    return mem;
  10ea7a:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10ea7d:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  10ea80:	eb 30                	jmp    10eab2 <memp_malloc+0xe2>
  } else {
    LWIP_DEBUGF(MEMP_DEBUG | 2, ("memp_malloc: out of memory in pool %d\n", type));
#if MEMP_STATS
    ++lwip_stats.memp[type].err;
  10ea82:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10ea85:	89 c8                	mov    %ecx,%eax
  10ea87:	c1 e0 04             	shl    $0x4,%eax
  10ea8a:	8b 80 a4 15 14 00    	mov    0x1415a4(%eax),%eax
  10ea90:	8d 50 01             	lea    0x1(%eax),%edx
  10ea93:	89 c8                	mov    %ecx,%eax
  10ea95:	c1 e0 04             	shl    $0x4,%eax
  10ea98:	89 90 a4 15 14 00    	mov    %edx,0x1415a4(%eax)
#endif /* MEMP_STATS */
#if SYS_LIGHTWEIGHT_PROT
  SYS_ARCH_UNPROTECT(old_level);
#else /* SYS_LIGHTWEIGHT_PROT */
  sys_sem_signal(mutex);
  10ea9e:	a1 94 08 13 00       	mov    0x130894,%eax
  10eaa3:	89 04 24             	mov    %eax,(%esp)
  10eaa6:	e8 25 b3 00 00       	call   119dd0 <sys_sem_signal>
#endif /* SYS_LIGHTWEIGHT_PROT */  
    return NULL;
  10eaab:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  10eab2:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  }
}
  10eab5:	c9                   	leave  
  10eab6:	c3                   	ret    
  10eab7:	89 f6                	mov    %esi,%esi
  10eab9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

0010eac0 <memp_free>:

void
memp_free(memp_t type, void *mem)
{
  10eac0:	55                   	push   %ebp
  10eac1:	89 e5                	mov    %esp,%ebp
  10eac3:	83 ec 18             	sub    $0x18,%esp
  struct memp *memp;
#if SYS_LIGHTWEIGHT_PROT
  SYS_ARCH_DECL_PROTECT(old_level);
#endif /* SYS_LIGHTWEIGHT_PROT */  

  if (mem == NULL) {
  10eac6:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  10eaca:	74 5b                	je     10eb27 <memp_free+0x67>
    return;
  }
  memp = (struct memp *)((u8_t *)mem - sizeof(struct memp));
  10eacc:	8b 45 0c             	mov    0xc(%ebp),%eax
  10eacf:	83 e8 04             	sub    $0x4,%eax
  10ead2:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)

#if SYS_LIGHTWEIGHT_PROT
    SYS_ARCH_PROTECT(old_level);
#else /* SYS_LIGHTWEIGHT_PROT */  
  sys_sem_wait(mutex);
  10ead5:	a1 94 08 13 00       	mov    0x130894,%eax
  10eada:	89 04 24             	mov    %eax,(%esp)
  10eadd:	e8 2e 13 00 00       	call   10fe10 <sys_sem_wait>
#endif /* SYS_LIGHTWEIGHT_PROT */  

#if MEMP_STATS
  lwip_stats.memp[type].used--; 
  10eae2:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10eae5:	89 c8                	mov    %ecx,%eax
  10eae7:	c1 e0 04             	shl    $0x4,%eax
  10eaea:	8b 80 9c 15 14 00    	mov    0x14159c(%eax),%eax
  10eaf0:	8d 50 ff             	lea    0xffffffff(%eax),%edx
  10eaf3:	89 c8                	mov    %ecx,%eax
  10eaf5:	c1 e0 04             	shl    $0x4,%eax
  10eaf8:	89 90 9c 15 14 00    	mov    %edx,0x14159c(%eax)
#endif /* MEMP_STATS */
  
  memp->next = memp_tab[type]; 
  10eafe:	8b 45 08             	mov    0x8(%ebp),%eax
  10eb01:	8b 14 85 20 f9 12 00 	mov    0x12f920(,%eax,4),%edx
  10eb08:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10eb0b:	89 10                	mov    %edx,(%eax)
  memp_tab[type] = memp;
  10eb0d:	8b 55 08             	mov    0x8(%ebp),%edx
  10eb10:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10eb13:	89 04 95 20 f9 12 00 	mov    %eax,0x12f920(,%edx,4)

#if MEMP_SANITY_CHECK
  LWIP_ASSERT("memp sanity", memp_sanity());
#endif  

#if SYS_LIGHTWEIGHT_PROT
  SYS_ARCH_UNPROTECT(old_level);
#else /* SYS_LIGHTWEIGHT_PROT */
  sys_sem_signal(mutex);
  10eb1a:	a1 94 08 13 00       	mov    0x130894,%eax
  10eb1f:	89 04 24             	mov    %eax,(%esp)
  10eb22:	e8 a9 b2 00 00       	call   119dd0 <sys_sem_signal>
#endif /* SYS_LIGHTWEIGHT_PROT */  
}
  10eb27:	c9                   	leave  
  10eb28:	c3                   	ret    
  10eb29:	90                   	nop    
  10eb2a:	90                   	nop    
  10eb2b:	90                   	nop    
  10eb2c:	90                   	nop    
  10eb2d:	90                   	nop    
  10eb2e:	90                   	nop    
  10eb2f:	90                   	nop    

0010eb30 <netif_add>:
  struct ip_addr *gw,
  void *state,
  err_t (* init)(struct netif *netif),
  err_t (* input)(struct pbuf *p, struct netif *netif))
{
  10eb30:	55                   	push   %ebp
  10eb31:	89 e5                	mov    %esp,%ebp
  10eb33:	83 ec 18             	sub    $0x18,%esp
  static int netifnum = 0;

  
#if LWIP_DHCP
  /* netif not under DHCP control by default */
  netif->dhcp = NULL;
#endif
  /* remember netif specific state information data */
  netif->state = state;
  10eb36:	8b 55 08             	mov    0x8(%ebp),%edx
  10eb39:	8b 45 18             	mov    0x18(%ebp),%eax
  10eb3c:	89 42 1c             	mov    %eax,0x1c(%edx)
  netif->num = netifnum++;
  10eb3f:	8b 0d a0 08 13 00    	mov    0x1308a0,%ecx
  10eb45:	89 ca                	mov    %ecx,%edx
  10eb47:	8b 45 08             	mov    0x8(%ebp),%eax
  10eb4a:	88 50 2c             	mov    %dl,0x2c(%eax)
  10eb4d:	8d 41 01             	lea    0x1(%ecx),%eax
  10eb50:	a3 a0 08 13 00       	mov    %eax,0x1308a0
  netif->input = input;
  10eb55:	8b 55 08             	mov    0x8(%ebp),%edx
  10eb58:	8b 45 20             	mov    0x20(%ebp),%eax
  10eb5b:	89 42 10             	mov    %eax,0x10(%edx)

  netif_set_addr(netif, ipaddr, netmask, gw);
  10eb5e:	8b 45 14             	mov    0x14(%ebp),%eax
  10eb61:	89 44 24 0c          	mov    %eax,0xc(%esp)
  10eb65:	8b 45 10             	mov    0x10(%ebp),%eax
  10eb68:	89 44 24 08          	mov    %eax,0x8(%esp)
  10eb6c:	8b 45 0c             	mov    0xc(%ebp),%eax
  10eb6f:	89 44 24 04          	mov    %eax,0x4(%esp)
  10eb73:	8b 45 08             	mov    0x8(%ebp),%eax
  10eb76:	89 04 24             	mov    %eax,(%esp)
  10eb79:	e8 42 00 00 00       	call   10ebc0 <netif_set_addr>

  /* call user specified initialization function for netif */
  if (init(netif) != ERR_OK) {
  10eb7e:	8b 45 08             	mov    0x8(%ebp),%eax
  10eb81:	89 04 24             	mov    %eax,(%esp)
  10eb84:	8b 45 1c             	mov    0x1c(%ebp),%eax
  10eb87:	ff d0                	call   *%eax
  10eb89:	84 c0                	test   %al,%al
  10eb8b:	74 09                	je     10eb96 <netif_add+0x66>
    return NULL;
  10eb8d:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
  10eb94:	eb 18                	jmp    10ebae <netif_add+0x7e>
  }

  /* add this netif to the list */
  netif->next = netif_list;
  10eb96:	a1 98 08 13 00       	mov    0x130898,%eax
  10eb9b:	8b 55 08             	mov    0x8(%ebp),%edx
  10eb9e:	89 02                	mov    %eax,(%edx)
  netif_list = netif;
  10eba0:	8b 45 08             	mov    0x8(%ebp),%eax
  10eba3:	a3 98 08 13 00       	mov    %eax,0x130898
  LWIP_DEBUGF(NETIF_DEBUG, ("netif: added interface %c%c IP addr ",
    netif->name[0], netif->name[1]));
  ip_addr_debug_print(NETIF_DEBUG, ipaddr);
  LWIP_DEBUGF(NETIF_DEBUG, (" netmask "));
  ip_addr_debug_print(NETIF_DEBUG, netmask);
  LWIP_DEBUGF(NETIF_DEBUG, (" gw "));
  ip_addr_debug_print(NETIF_DEBUG, gw);
  LWIP_DEBUGF(NETIF_DEBUG, ("\n"));
  return netif;
  10eba8:	8b 45 08             	mov    0x8(%ebp),%eax
  10ebab:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  10ebae:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
}
  10ebb1:	c9                   	leave  
  10ebb2:	c3                   	ret    
  10ebb3:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  10ebb9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

0010ebc0 <netif_set_addr>:

void
netif_set_addr(struct netif *netif,struct ip_addr *ipaddr, struct ip_addr *netmask,
    struct ip_addr *gw)
{
  10ebc0:	55                   	push   %ebp
  10ebc1:	89 e5                	mov    %esp,%ebp
  10ebc3:	83 ec 08             	sub    $0x8,%esp
  netif_set_ipaddr(netif, ipaddr);
  10ebc6:	8b 45 0c             	mov    0xc(%ebp),%eax
  10ebc9:	89 44 24 04          	mov    %eax,0x4(%esp)
  10ebcd:	8b 45 08             	mov    0x8(%ebp),%eax
  10ebd0:	89 04 24             	mov    %eax,(%esp)
  10ebd3:	e8 28 01 00 00       	call   10ed00 <netif_set_ipaddr>
  netif_set_netmask(netif, netmask);
  10ebd8:	8b 45 10             	mov    0x10(%ebp),%eax
  10ebdb:	89 44 24 04          	mov    %eax,0x4(%esp)
  10ebdf:	8b 45 08             	mov    0x8(%ebp),%eax
  10ebe2:	89 04 24             	mov    %eax,(%esp)
  10ebe5:	e8 16 02 00 00       	call   10ee00 <netif_set_netmask>
  netif_set_gw(netif, gw);
  10ebea:	8b 45 14             	mov    0x14(%ebp),%eax
  10ebed:	89 44 24 04          	mov    %eax,0x4(%esp)
  10ebf1:	8b 45 08             	mov    0x8(%ebp),%eax
  10ebf4:	89 04 24             	mov    %eax,(%esp)
  10ebf7:	e8 d4 01 00 00       	call   10edd0 <netif_set_gw>
}
  10ebfc:	c9                   	leave  
  10ebfd:	c3                   	ret    
  10ebfe:	89 f6                	mov    %esi,%esi

0010ec00 <netif_remove>:

void netif_remove(struct netif * netif)
{
  10ec00:	55                   	push   %ebp
  10ec01:	89 e5                	mov    %esp,%ebp
  10ec03:	83 ec 10             	sub    $0x10,%esp
  if ( netif == NULL ) return;
  10ec06:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  10ec0a:	74 5e                	je     10ec6a <netif_remove+0x6a>

  /*  is it the first netif? */
  if (netif_list == netif) {
  10ec0c:	a1 98 08 13 00       	mov    0x130898,%eax
  10ec11:	3b 45 08             	cmp    0x8(%ebp),%eax
  10ec14:	75 0c                	jne    10ec22 <netif_remove+0x22>
    netif_list = netif->next;
  10ec16:	8b 45 08             	mov    0x8(%ebp),%eax
  10ec19:	8b 00                	mov    (%eax),%eax
  10ec1b:	a3 98 08 13 00       	mov    %eax,0x130898
  10ec20:	eb 34                	jmp    10ec56 <netif_remove+0x56>
  }
  else {
    /*  look for netif further down the list */
    struct netif * tmpNetif;
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
  10ec22:	a1 98 08 13 00       	mov    0x130898,%eax
  10ec27:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  10ec2a:	eb 1e                	jmp    10ec4a <netif_remove+0x4a>
      if (tmpNetif->next == netif) {
  10ec2c:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10ec2f:	8b 00                	mov    (%eax),%eax
  10ec31:	3b 45 08             	cmp    0x8(%ebp),%eax
  10ec34:	75 0c                	jne    10ec42 <netif_remove+0x42>
        tmpNetif->next = netif->next;
  10ec36:	8b 45 08             	mov    0x8(%ebp),%eax
  10ec39:	8b 10                	mov    (%eax),%edx
  10ec3b:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10ec3e:	89 10                	mov    %edx,(%eax)
        break;
  10ec40:	eb 0e                	jmp    10ec50 <netif_remove+0x50>
  10ec42:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10ec45:	8b 00                	mov    (%eax),%eax
  10ec47:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  10ec4a:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  10ec4e:	75 dc                	jne    10ec2c <netif_remove+0x2c>
        }
    }
    if (tmpNetif == NULL)
  10ec50:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  10ec54:	74 14                	je     10ec6a <netif_remove+0x6a>
      return; /*  we didn't find any netif today */
  }
  /* this netif is default? */
  if (netif_default == netif)
  10ec56:	a1 9c 08 13 00       	mov    0x13089c,%eax
  10ec5b:	3b 45 08             	cmp    0x8(%ebp),%eax
  10ec5e:	75 0a                	jne    10ec6a <netif_remove+0x6a>
    /* reset default netif */
    netif_default = NULL;
  10ec60:	c7 05 9c 08 13 00 00 	movl   $0x0,0x13089c
  10ec67:	00 00 00 
  LWIP_DEBUGF( NETIF_DEBUG, ("netif_remove: removed netif\n") );
}
  10ec6a:	c9                   	leave  
  10ec6b:	c3                   	ret    
  10ec6c:	8d 74 26 00          	lea    0x0(%esi),%esi

0010ec70 <netif_find>:

struct netif *
netif_find(char *name)
{
  10ec70:	55                   	push   %ebp
  10ec71:	89 e5                	mov    %esp,%ebp
  10ec73:	83 ec 14             	sub    $0x14,%esp
  struct netif *netif;
  u8_t num;

  if (name == NULL) {
  10ec76:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  10ec7a:	75 09                	jne    10ec85 <netif_find+0x15>
    return NULL;
  10ec7c:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  10ec83:	eb 67                	jmp    10ecec <netif_find+0x7c>
  }

  num = name[2] - '0';
  10ec85:	8b 45 08             	mov    0x8(%ebp),%eax
  10ec88:	83 c0 02             	add    $0x2,%eax
  10ec8b:	0f b6 00             	movzbl (%eax),%eax
  10ec8e:	83 e8 30             	sub    $0x30,%eax
  10ec91:	88 45 ff             	mov    %al,0xffffffff(%ebp)

  for(netif = netif_list; netif != NULL; netif = netif->next) {
  10ec94:	a1 98 08 13 00       	mov    0x130898,%eax
  10ec99:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  10ec9c:	eb 41                	jmp    10ecdf <netif_find+0x6f>
    if (num == netif->num &&
  10ec9e:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10eca1:	0f b6 40 2c          	movzbl 0x2c(%eax),%eax
  10eca5:	3a 45 ff             	cmp    0xffffffff(%ebp),%al
  10eca8:	75 2d                	jne    10ecd7 <netif_find+0x67>
  10ecaa:	8b 45 08             	mov    0x8(%ebp),%eax
  10ecad:	0f b6 10             	movzbl (%eax),%edx
  10ecb0:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10ecb3:	0f b6 40 2a          	movzbl 0x2a(%eax),%eax
  10ecb7:	38 c2                	cmp    %al,%dl
  10ecb9:	75 1c                	jne    10ecd7 <netif_find+0x67>
  10ecbb:	8b 45 08             	mov    0x8(%ebp),%eax
  10ecbe:	83 c0 01             	add    $0x1,%eax
  10ecc1:	0f b6 10             	movzbl (%eax),%edx
  10ecc4:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10ecc7:	0f b6 40 2b          	movzbl 0x2b(%eax),%eax
  10eccb:	38 c2                	cmp    %al,%dl
  10eccd:	75 08                	jne    10ecd7 <netif_find+0x67>
       name[0] == netif->name[0] &&
       name[1] == netif->name[1]) {
      LWIP_DEBUGF(NETIF_DEBUG, ("netif_find: found %c%c\n", name[0], name[1]));
      return netif;
  10eccf:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10ecd2:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  10ecd5:	eb 15                	jmp    10ecec <netif_find+0x7c>
  10ecd7:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10ecda:	8b 00                	mov    (%eax),%eax
  10ecdc:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  10ecdf:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  10ece3:	75 b9                	jne    10ec9e <netif_find+0x2e>
    }
  }
  LWIP_DEBUGF(NETIF_DEBUG, ("netif_find: didn't find %c%c\n", name[0], name[1]));
  return NULL;
  10ece5:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  10ecec:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  10ecef:	c9                   	leave  
  10ecf0:	c3                   	ret    
  10ecf1:	eb 0d                	jmp    10ed00 <netif_set_ipaddr>
  10ecf3:	90                   	nop    
  10ecf4:	90                   	nop    
  10ecf5:	90                   	nop    
  10ecf6:	90                   	nop    
  10ecf7:	90                   	nop    
  10ecf8:	90                   	nop    
  10ecf9:	90                   	nop    
  10ecfa:	90                   	nop    
  10ecfb:	90                   	nop    
  10ecfc:	90                   	nop    
  10ecfd:	90                   	nop    
  10ecfe:	90                   	nop    
  10ecff:	90                   	nop    

0010ed00 <netif_set_ipaddr>:

void
netif_set_ipaddr(struct netif *netif, struct ip_addr *ipaddr)
{
  10ed00:	55                   	push   %ebp
  10ed01:	89 e5                	mov    %esp,%ebp
  10ed03:	83 ec 28             	sub    $0x28,%esp
  /* TODO: Handling of obsolete pcbs */
  /* See:  http://mail.gnu.org/archive/html/lwip-users/2003-03/msg00118.html */
#if LWIP_TCP
  struct tcp_pcb *pcb;
  struct tcp_pcb_listen *lpcb;

  /* address is actually being changed? */
  if ((ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0)
  10ed06:	8b 45 0c             	mov    0xc(%ebp),%eax
  10ed09:	8b 10                	mov    (%eax),%edx
  10ed0b:	8b 45 08             	mov    0x8(%ebp),%eax
  10ed0e:	8b 40 04             	mov    0x4(%eax),%eax
  10ed11:	39 c2                	cmp    %eax,%edx
  10ed13:	0f 84 8b 00 00 00    	je     10eda4 <netif_set_ipaddr+0xa4>
  {
    /* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
    LWIP_DEBUGF(NETIF_DEBUG | 1, ("netif_set_ipaddr: netif address being changed\n"));
    pcb = tcp_active_pcbs;
  10ed19:	a1 54 16 14 00       	mov    0x141654,%eax
  10ed1e:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
    while (pcb != NULL) {
  10ed21:	eb 34                	jmp    10ed57 <netif_set_ipaddr+0x57>
      /* PCB bound to current local interface address? */
      if (ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
  10ed23:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10ed26:	8b 10                	mov    (%eax),%edx
  10ed28:	8b 45 08             	mov    0x8(%ebp),%eax
  10ed2b:	8b 40 04             	mov    0x4(%eax),%eax
  10ed2e:	39 c2                	cmp    %eax,%edx
  10ed30:	75 1c                	jne    10ed4e <netif_set_ipaddr+0x4e>
        /* this connection must be aborted */
        struct tcp_pcb *next = pcb->next;
  10ed32:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10ed35:	8b 40 0c             	mov    0xc(%eax),%eax
  10ed38:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
        LWIP_DEBUGF(NETIF_DEBUG | 1, ("netif_set_ipaddr: aborting TCP pcb %p\n", (void *)pcb));
        tcp_abort(pcb);
  10ed3b:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10ed3e:	89 04 24             	mov    %eax,(%esp)
  10ed41:	e8 0a 16 00 00       	call   110350 <tcp_abort>
        pcb = next;
  10ed46:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10ed49:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  10ed4c:	eb 09                	jmp    10ed57 <netif_set_ipaddr+0x57>
      } else {
        pcb = pcb->next;
  10ed4e:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10ed51:	8b 40 0c             	mov    0xc(%eax),%eax
  10ed54:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  10ed57:	83 7d f4 00          	cmpl   $0x0,0xfffffff4(%ebp)
  10ed5b:	75 c6                	jne    10ed23 <netif_set_ipaddr+0x23>
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  10ed5d:	a1 5c 16 14 00       	mov    0x14165c,%eax
  10ed62:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  10ed65:	eb 37                	jmp    10ed9e <netif_set_ipaddr+0x9e>
      /* PCB bound to current local interface address? */
      if (ip_addr_cmp(&(lpcb->local_ip), &(netif->ip_addr))) {
  10ed67:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10ed6a:	8b 10                	mov    (%eax),%edx
  10ed6c:	8b 45 08             	mov    0x8(%ebp),%eax
  10ed6f:	8b 40 04             	mov    0x4(%eax),%eax
  10ed72:	39 c2                	cmp    %eax,%edx
  10ed74:	75 1f                	jne    10ed95 <netif_set_ipaddr+0x95>
        /* The PCB is listening to the old ipaddr and
         * is set to listen to the new one instead */
        ip_addr_set(&(lpcb->local_ip), ipaddr);
  10ed76:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  10ed7a:	74 0a                	je     10ed86 <netif_set_ipaddr+0x86>
  10ed7c:	8b 45 0c             	mov    0xc(%ebp),%eax
  10ed7f:	8b 00                	mov    (%eax),%eax
  10ed81:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
  10ed84:	eb 07                	jmp    10ed8d <netif_set_ipaddr+0x8d>
  10ed86:	c7 45 e8 00 00 00 00 	movl   $0x0,0xffffffe8(%ebp)
  10ed8d:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10ed90:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
  10ed93:	89 10                	mov    %edx,(%eax)
  10ed95:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10ed98:	8b 40 0c             	mov    0xc(%eax),%eax
  10ed9b:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  10ed9e:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  10eda2:	75 c3                	jne    10ed67 <netif_set_ipaddr+0x67>
      }
    }
  }
#endif
  ip_addr_set(&(netif->ip_addr), ipaddr);
  10eda4:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  10eda8:	74 0a                	je     10edb4 <netif_set_ipaddr+0xb4>
  10edaa:	8b 45 0c             	mov    0xc(%ebp),%eax
  10edad:	8b 00                	mov    (%eax),%eax
  10edaf:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  10edb2:	eb 07                	jmp    10edbb <netif_set_ipaddr+0xbb>
  10edb4:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  10edbb:	8b 45 08             	mov    0x8(%ebp),%eax
  10edbe:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
  10edc1:	89 50 04             	mov    %edx,0x4(%eax)
  LWIP_DEBUGF(NETIF_DEBUG | DBG_TRACE | DBG_STATE | 3, ("netif: IP address of interface %c%c set to %u.%u.%u.%u\n",
    netif->name[0], netif->name[1],
    (unsigned int)(ntohl(netif->ip_addr.addr) >> 24 & 0xff),
    (unsigned int)(ntohl(netif->ip_addr.addr) >> 16 & 0xff),
    (unsigned int)(ntohl(netif->ip_addr.addr) >> 8 & 0xff),
    (unsigned int)(ntohl(netif->ip_addr.addr) & 0xff)));
}
  10edc4:	c9                   	leave  
  10edc5:	c3                   	ret    
  10edc6:	8d 76 00             	lea    0x0(%esi),%esi
  10edc9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

0010edd0 <netif_set_gw>:

void
netif_set_gw(struct netif *netif, struct ip_addr *gw)
{
  10edd0:	55                   	push   %ebp
  10edd1:	89 e5                	mov    %esp,%ebp
  10edd3:	83 ec 04             	sub    $0x4,%esp
  ip_addr_set(&(netif->gw), gw);
  10edd6:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  10edda:	74 0a                	je     10ede6 <netif_set_gw+0x16>
  10eddc:	8b 45 0c             	mov    0xc(%ebp),%eax
  10eddf:	8b 00                	mov    (%eax),%eax
  10ede1:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  10ede4:	eb 07                	jmp    10eded <netif_set_gw+0x1d>
  10ede6:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
  10eded:	8b 45 08             	mov    0x8(%ebp),%eax
  10edf0:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  10edf3:	89 50 0c             	mov    %edx,0xc(%eax)
  LWIP_DEBUGF(NETIF_DEBUG | DBG_TRACE | DBG_STATE | 3, ("netif: GW address of interface %c%c set to %u.%u.%u.%u\n",
           netif->name[0], netif->name[1],
           (unsigned int)(ntohl(netif->gw.addr) >> 24 & 0xff),
           (unsigned int)(ntohl(netif->gw.addr) >> 16 & 0xff),
           (unsigned int)(ntohl(netif->gw.addr) >> 8 & 0xff),
           (unsigned int)(ntohl(netif->gw.addr) & 0xff)));
}
  10edf6:	c9                   	leave  
  10edf7:	c3                   	ret    
  10edf8:	90                   	nop    
  10edf9:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

0010ee00 <netif_set_netmask>:

void
netif_set_netmask(struct netif *netif, struct ip_addr *netmask)
{
  10ee00:	55                   	push   %ebp
  10ee01:	89 e5                	mov    %esp,%ebp
  10ee03:	83 ec 04             	sub    $0x4,%esp
  ip_addr_set(&(netif->netmask), netmask);
  10ee06:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  10ee0a:	74 0a                	je     10ee16 <netif_set_netmask+0x16>
  10ee0c:	8b 45 0c             	mov    0xc(%ebp),%eax
  10ee0f:	8b 00                	mov    (%eax),%eax
  10ee11:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  10ee14:	eb 07                	jmp    10ee1d <netif_set_netmask+0x1d>
  10ee16:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
  10ee1d:	8b 45 08             	mov    0x8(%ebp),%eax
  10ee20:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  10ee23:	89 50 08             	mov    %edx,0x8(%eax)
  LWIP_DEBUGF(NETIF_DEBUG | DBG_TRACE | DBG_STATE | 3, ("netif: netmask of interface %c%c set to %u.%u.%u.%u\n",
           netif->name[0], netif->name[1],
           (unsigned int)(ntohl(netif->netmask.addr) >> 24 & 0xff),
           (unsigned int)(ntohl(netif->netmask.addr) >> 16 & 0xff),
           (unsigned int)(ntohl(netif->netmask.addr) >> 8 & 0xff),
           (unsigned int)(ntohl(netif->netmask.addr) & 0xff)));
}
  10ee26:	c9                   	leave  
  10ee27:	c3                   	ret    
  10ee28:	90                   	nop    
  10ee29:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

0010ee30 <netif_set_default>:

void
netif_set_default(struct netif *netif)
{
  10ee30:	55                   	push   %ebp
  10ee31:	89 e5                	mov    %esp,%ebp
  netif_default = netif;
  10ee33:	8b 45 08             	mov    0x8(%ebp),%eax
  10ee36:	a3 9c 08 13 00       	mov    %eax,0x13089c
  LWIP_DEBUGF(NETIF_DEBUG, ("netif: setting default interface %c%c\n",
           netif ? netif->name[0] : '\'', netif ? netif->name[1] : '\''));
}
  10ee3b:	5d                   	pop    %ebp
  10ee3c:	c3                   	ret    
  10ee3d:	8d 76 00             	lea    0x0(%esi),%esi

0010ee40 <netif_init>:

void
netif_init(void)
{
  10ee40:	55                   	push   %ebp
  10ee41:	89 e5                	mov    %esp,%ebp
  netif_list = netif_default = NULL;
  10ee43:	c7 05 9c 08 13 00 00 	movl   $0x0,0x13089c
  10ee4a:	00 00 00 
  10ee4d:	a1 9c 08 13 00       	mov    0x13089c,%eax
  10ee52:	a3 98 08 13 00       	mov    %eax,0x130898
}
  10ee57:	5d                   	pop    %ebp
  10ee58:	c3                   	ret    
  10ee59:	90                   	nop    
  10ee5a:	90                   	nop    
  10ee5b:	90                   	nop    
  10ee5c:	90                   	nop    
  10ee5d:	90                   	nop    
  10ee5e:	90                   	nop    
  10ee5f:	90                   	nop    

0010ee60 <pbuf_init>:
 *
 */
void
pbuf_init(void)
{
  10ee60:	55                   	push   %ebp
  10ee61:	89 e5                	mov    %esp,%ebp
  10ee63:	83 ec 18             	sub    $0x18,%esp
  struct pbuf *p, *q = NULL;
  10ee66:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)
  u16_t i;

  pbuf_pool = (struct pbuf *)&pbuf_pool_memory[0];
  10ee6d:	b8 e0 08 13 00       	mov    $0x1308e0,%eax
  10ee72:	a3 c0 08 13 00       	mov    %eax,0x1308c0
  LWIP_ASSERT("pbuf_init: pool aligned", (mem_ptr_t)pbuf_pool % MEM_ALIGNMENT == 0);

#if PBUF_STATS
  lwip_stats.pbuf.avail = PBUF_POOL_SIZE;
  10ee77:	66 c7 05 7c 15 14 00 	movw   $0x100,0x14157c
  10ee7e:	00 01 
#endif /* PBUF_STATS */

  /* Set up ->next pointers to link the pbufs of the pool together */
  p = pbuf_pool;
  10ee80:	a1 c0 08 13 00       	mov    0x1308c0,%eax
  10ee85:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)

  for(i = 0; i < PBUF_POOL_SIZE; ++i) {
  10ee88:	66 c7 45 fe 00 00    	movw   $0x0,0xfffffffe(%ebp)
  10ee8e:	eb 50                	jmp    10eee0 <pbuf_init+0x80>
    p->next = (struct pbuf *)((u8_t *)p + PBUF_POOL_BUFSIZE + sizeof(struct pbuf));
  10ee90:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10ee93:	05 90 00 00 00       	add    $0x90,%eax
  10ee98:	89 c2                	mov    %eax,%edx
  10ee9a:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10ee9d:	89 10                	mov    %edx,(%eax)
    p->len = p->tot_len = PBUF_POOL_BUFSIZE;
  10ee9f:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10eea2:	66 c7 40 08 80 00    	movw   $0x80,0x8(%eax)
  10eea8:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10eeab:	0f b7 50 08          	movzwl 0x8(%eax),%edx
  10eeaf:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10eeb2:	66 89 50 0a          	mov    %dx,0xa(%eax)
    p->payload = MEM_ALIGN((void *)((u8_t *)p + sizeof(struct pbuf)));
  10eeb6:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10eeb9:	83 c0 10             	add    $0x10,%eax
  10eebc:	89 c2                	mov    %eax,%edx
  10eebe:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10eec1:	89 50 04             	mov    %edx,0x4(%eax)
    p->flags = PBUF_FLAG_POOL;
  10eec4:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10eec7:	66 c7 40 0c 02 00    	movw   $0x2,0xc(%eax)
    q = p;
  10eecd:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10eed0:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
    p = p->next;
  10eed3:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10eed6:	8b 00                	mov    (%eax),%eax
  10eed8:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  10eedb:	66 83 45 fe 01       	addw   $0x1,0xfffffffe(%ebp)
  10eee0:	66 81 7d fe ff 00    	cmpw   $0xff,0xfffffffe(%ebp)
  10eee6:	76 a8                	jbe    10ee90 <pbuf_init+0x30>
  }

  /* The ->next pointer of last pbuf is NULL to indicate that there
     are no more pbufs in the pool */
  q->next = NULL;
  10eee8:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10eeeb:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

#if !SYS_LIGHTWEIGHT_PROT
  pbuf_pool_alloc_lock = 0;
  10eef1:	c6 05 e1 98 13 00 00 	movb   $0x0,0x1398e1
  pbuf_pool_free_lock = 0;
  10eef8:	c6 05 e0 98 13 00 00 	movb   $0x0,0x1398e0
  pbuf_pool_free_sem = sys_sem_new(1);
  10eeff:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  10ef06:	e8 45 ae 00 00       	call   119d50 <sys_sem_new>
  10ef0b:	a3 e4 98 13 00       	mov    %eax,0x1398e4
#endif
}
  10ef10:	c9                   	leave  
  10ef11:	c3                   	ret    
  10ef12:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi
  10ef19:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

0010ef20 <pbuf_pool_alloc>:

/**
 * @internal only called from pbuf_alloc()
 */
static struct pbuf *
pbuf_pool_alloc(void)
{
  10ef20:	55                   	push   %ebp
  10ef21:	89 e5                	mov    %esp,%ebp
  10ef23:	83 ec 14             	sub    $0x14,%esp
  struct pbuf *p = NULL;
  10ef26:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)

  SYS_ARCH_DECL_PROTECT(old_level);
  SYS_ARCH_PROTECT(old_level);

#if !SYS_LIGHTWEIGHT_PROT
  /* Next, check the actual pbuf pool, but if the pool is locked, we
     pretend to be out of buffers and return NULL. */
  if (pbuf_pool_free_lock) {
  10ef2d:	0f b6 05 e0 98 13 00 	movzbl 0x1398e0,%eax
  10ef34:	84 c0                	test   %al,%al
  10ef36:	74 19                	je     10ef51 <pbuf_pool_alloc+0x31>
#if PBUF_STATS
    ++lwip_stats.pbuf.alloc_locked;
  10ef38:	0f b7 05 84 15 14 00 	movzwl 0x141584,%eax
  10ef3f:	83 c0 01             	add    $0x1,%eax
  10ef42:	66 a3 84 15 14 00    	mov    %ax,0x141584
#endif /* PBUF_STATS */
    return NULL;
  10ef48:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  10ef4f:	eb 7f                	jmp    10efd0 <pbuf_pool_alloc+0xb0>
  }
  pbuf_pool_alloc_lock = 1;
  10ef51:	c6 05 e1 98 13 00 01 	movb   $0x1,0x1398e1
  if (!pbuf_pool_free_lock) {
  10ef58:	0f b6 05 e0 98 13 00 	movzbl 0x1398e0,%eax
  10ef5f:	84 c0                	test   %al,%al
  10ef61:	75 1a                	jne    10ef7d <pbuf_pool_alloc+0x5d>
#endif /* SYS_LIGHTWEIGHT_PROT */
    p = pbuf_pool;
  10ef63:	a1 c0 08 13 00       	mov    0x1308c0,%eax
  10ef68:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
    if (p) {
  10ef6b:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  10ef6f:	74 1c                	je     10ef8d <pbuf_pool_alloc+0x6d>
      pbuf_pool = p->next;
  10ef71:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10ef74:	8b 00                	mov    (%eax),%eax
  10ef76:	a3 c0 08 13 00       	mov    %eax,0x1308c0
  10ef7b:	eb 10                	jmp    10ef8d <pbuf_pool_alloc+0x6d>
    }
#if !SYS_LIGHTWEIGHT_PROT
#if PBUF_STATS
  } else {
    ++lwip_stats.pbuf.alloc_locked;
  10ef7d:	0f b7 05 84 15 14 00 	movzwl 0x141584,%eax
  10ef84:	83 c0 01             	add    $0x1,%eax
  10ef87:	66 a3 84 15 14 00    	mov    %ax,0x141584
#endif /* PBUF_STATS */
  }
  pbuf_pool_alloc_lock = 0;
  10ef8d:	c6 05 e1 98 13 00 00 	movb   $0x0,0x1398e1
#endif /* SYS_LIGHTWEIGHT_PROT */

#if PBUF_STATS
  if (p != NULL) {
  10ef94:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  10ef98:	74 30                	je     10efca <pbuf_pool_alloc+0xaa>
    ++lwip_stats.pbuf.used;
  10ef9a:	0f b7 05 7e 15 14 00 	movzwl 0x14157e,%eax
  10efa1:	83 c0 01             	add    $0x1,%eax
  10efa4:	66 a3 7e 15 14 00    	mov    %ax,0x14157e
    if (lwip_stats.pbuf.used > lwip_stats.pbuf.max) {
  10efaa:	0f b7 15 7e 15 14 00 	movzwl 0x14157e,%edx
  10efb1:	0f b7 05 80 15 14 00 	movzwl 0x141580,%eax
  10efb8:	66 39 c2             	cmp    %ax,%dx
  10efbb:	76 0d                	jbe    10efca <pbuf_pool_alloc+0xaa>
      lwip_stats.pbuf.max = lwip_stats.pbuf.used;
  10efbd:	0f b7 05 7e 15 14 00 	movzwl 0x14157e,%eax
  10efc4:	66 a3 80 15 14 00    	mov    %ax,0x141580
    }
  }
#endif /* PBUF_STATS */

  SYS_ARCH_UNPROTECT(old_level);
  return p;
  10efca:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10efcd:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  10efd0:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  10efd3:	c9                   	leave  
  10efd4:	c3                   	ret    
  10efd5:	8d 74 26 00          	lea    0x0(%esi),%esi
  10efd9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

0010efe0 <pbuf_alloc>:


/**
 * Allocates a pbuf.
 *
 * The actual memory allocated for the pbuf is determined by the
 * layer at which the pbuf is allocated and the requested size
 * (from the size parameter).
 *
 * @param flag this parameter decides how and where the pbuf
 * should be allocated as follows:
 *
 * - PBUF_RAM: buffer memory for pbuf is allocated as one large
 *             chunk. This includes protocol headers as well.
 * - PBUF_ROM: no buffer memory is allocated for the pbuf, even for
 *             protocol headers. Additional headers must be prepended
 *             by allocating another pbuf and chain in to the front of
 *             the ROM pbuf. It is assumed that the memory used is really
 *             similar to ROM in that it is immutable and will not be
 *             changed. Memory which is dynamic should generally not
 *             be attached to PBUF_ROM pbufs. Use PBUF_REF instead.
 * - PBUF_REF: no buffer memory is allocated for the pbuf, even for
 *             protocol headers. It is assumed that the pbuf is only
 *             being used in a single thread. If the pbuf gets queued,
 *             then pbuf_take should be called to copy the buffer.
 * - PBUF_POOL: the pbuf is allocated as a pbuf chain, with pbufs from
 *              the pbuf pool that is allocated during pbuf_init().
 *
 * @return the allocated pbuf. If multiple pbufs where allocated, this
 * is the first pbuf of a pbuf chain.
 */
struct pbuf *
pbuf_alloc(pbuf_layer l, u16_t length, pbuf_flag flag)
{
  10efe0:	55                   	push   %ebp
  10efe1:	89 e5                	mov    %esp,%ebp
  10efe3:	53                   	push   %ebx
  10efe4:	83 ec 34             	sub    $0x34,%esp
  10efe7:	8b 45 0c             	mov    0xc(%ebp),%eax
  10efea:	66 89 45 e8          	mov    %ax,0xffffffe8(%ebp)
  struct pbuf *p, *q, *r;
  u16_t offset;
  s32_t rem_len; /* remaining length */
  LWIP_DEBUGF(PBUF_DEBUG | DBG_TRACE | 3, ("pbuf_alloc(length=%u)\n", length));

  /* determine header offset */
  offset = 0;
  10efee:	66 c7 45 f8 00 00    	movw   $0x0,0xfffffff8(%ebp)
  switch (l) {
  10eff4:	8b 45 08             	mov    0x8(%ebp),%eax
  10eff7:	89 45 d4             	mov    %eax,0xffffffd4(%ebp)
  10effa:	83 7d d4 01          	cmpl   $0x1,0xffffffd4(%ebp)
  10effe:	74 19                	je     10f019 <pbuf_alloc+0x39>
  10f000:	83 7d d4 01          	cmpl   $0x1,0xffffffd4(%ebp)
  10f004:	72 0e                	jb     10f014 <pbuf_alloc+0x34>
  10f006:	83 7d d4 02          	cmpl   $0x2,0xffffffd4(%ebp)
  10f00a:	74 12                	je     10f01e <pbuf_alloc+0x3e>
  10f00c:	83 7d d4 03          	cmpl   $0x3,0xffffffd4(%ebp)
  10f010:	74 1f                	je     10f031 <pbuf_alloc+0x51>
  10f012:	eb 11                	jmp    10f025 <pbuf_alloc+0x45>
  case PBUF_TRANSPORT:
    /* add room for transport (often TCP) layer header */
    offset += PBUF_TRANSPORT_HLEN;
  10f014:	66 83 45 f8 14       	addw   $0x14,0xfffffff8(%ebp)
    /* FALLTHROUGH */
  case PBUF_IP:
    /* add room for IP layer header */
    offset += PBUF_IP_HLEN;
  10f019:	66 83 45 f8 14       	addw   $0x14,0xfffffff8(%ebp)
    /* FALLTHROUGH */
  case PBUF_LINK:
    /* add room for link layer header */
    offset += PBUF_LINK_HLEN;
  10f01e:	66 83 45 f8 0e       	addw   $0xe,0xfffffff8(%ebp)
    break;
  10f023:	eb 0c                	jmp    10f031 <pbuf_alloc+0x51>
  case PBUF_RAW:
    break;
  default:
    LWIP_ASSERT("pbuf_alloc: bad pbuf layer", 0);
    return NULL;
  10f025:	c7 45 d8 00 00 00 00 	movl   $0x0,0xffffffd8(%ebp)
  10f02c:	e9 6e 02 00 00       	jmp    10f29f <pbuf_alloc+0x2bf>
  }

  switch (flag) {
  10f031:	8b 55 10             	mov    0x10(%ebp),%edx
  10f034:	89 55 d0             	mov    %edx,0xffffffd0(%ebp)
  10f037:	83 7d d0 02          	cmpl   $0x2,0xffffffd0(%ebp)
  10f03b:	77 0f                	ja     10f04c <pbuf_alloc+0x6c>
  10f03d:	83 7d d0 01          	cmpl   $0x1,0xffffffd0(%ebp)
  10f041:	0f 83 d5 01 00 00    	jae    10f21c <pbuf_alloc+0x23c>
  10f047:	e9 66 01 00 00       	jmp    10f1b2 <pbuf_alloc+0x1d2>
  10f04c:	83 7d d0 03          	cmpl   $0x3,0xffffffd0(%ebp)
  10f050:	74 05                	je     10f057 <pbuf_alloc+0x77>
  10f052:	e9 30 02 00 00       	jmp    10f287 <pbuf_alloc+0x2a7>
  case PBUF_POOL:
    /* allocate head of pbuf chain into p */
    p = pbuf_pool_alloc();
  10f057:	e8 c4 fe ff ff       	call   10ef20 <pbuf_pool_alloc>
  10f05c:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
    LWIP_DEBUGF(PBUF_DEBUG | DBG_TRACE | 3, ("pbuf_alloc: allocated pbuf %p offset %p\n", (void *)p, offset));
    if (p == NULL) {
  10f05f:	83 7d ec 00          	cmpl   $0x0,0xffffffec(%ebp)
  10f063:	75 1c                	jne    10f081 <pbuf_alloc+0xa1>
#if PBUF_STATS
      ++lwip_stats.pbuf.err;
  10f065:	0f b7 05 82 15 14 00 	movzwl 0x141582,%eax
  10f06c:	83 c0 01             	add    $0x1,%eax
  10f06f:	66 a3 82 15 14 00    	mov    %ax,0x141582
#endif /* PBUF_STATS */
      return NULL;
  10f075:	c7 45 d8 00 00 00 00 	movl   $0x0,0xffffffd8(%ebp)
  10f07c:	e9 1e 02 00 00       	jmp    10f29f <pbuf_alloc+0x2bf>
    }
    p->next = NULL;
  10f081:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10f084:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

    /* make the payload pointer point 'offset' bytes into pbuf data memory */
    p->payload = MEM_ALIGN((void *)((u8_t *)p + (sizeof(struct pbuf) + offset)));
  10f08a:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10f08d:	8d 50 10             	lea    0x10(%eax),%edx
  10f090:	0f b7 45 f8          	movzwl 0xfffffff8(%ebp),%eax
  10f094:	01 c2                	add    %eax,%edx
  10f096:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10f099:	89 50 04             	mov    %edx,0x4(%eax)
    LWIP_ASSERT("pbuf_alloc: pbuf p->payload properly aligned",
            ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
    /* the total length of the pbuf chain is the requested size */
    p->tot_len = length;
  10f09c:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
  10f09f:	0f b7 45 e8          	movzwl 0xffffffe8(%ebp),%eax
  10f0a3:	66 89 42 08          	mov    %ax,0x8(%edx)
    /* set the length of the first pbuf in the chain */
    p->len = length > PBUF_POOL_BUFSIZE - offset? PBUF_POOL_BUFSIZE - offset: length;
  10f0a7:	0f b7 4d e8          	movzwl 0xffffffe8(%ebp),%ecx
  10f0ab:	0f b7 55 f8          	movzwl 0xfffffff8(%ebp),%edx
  10f0af:	b8 80 00 00 00       	mov    $0x80,%eax
  10f0b4:	89 c3                	mov    %eax,%ebx
  10f0b6:	29 d3                	sub    %edx,%ebx
  10f0b8:	89 5d dc             	mov    %ebx,0xffffffdc(%ebp)
  10f0bb:	89 4d e0             	mov    %ecx,0xffffffe0(%ebp)
  10f0be:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  10f0c1:	39 45 e0             	cmp    %eax,0xffffffe0(%ebp)
  10f0c4:	7e 06                	jle    10f0cc <pbuf_alloc+0xec>
  10f0c6:	8b 55 dc             	mov    0xffffffdc(%ebp),%edx
  10f0c9:	89 55 e0             	mov    %edx,0xffffffe0(%ebp)
  10f0cc:	0f b7 55 e0          	movzwl 0xffffffe0(%ebp),%edx
  10f0d0:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10f0d3:	66 89 50 0a          	mov    %dx,0xa(%eax)
    /* set reference count (needed here in case we fail) */
    p->ref = 1;
  10f0d7:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10f0da:	66 c7 40 0e 01 00    	movw   $0x1,0xe(%eax)

    /* now allocate the tail of the pbuf chain */

    /* remember first pbuf for linkage in next iteration */
    r = p;
  10f0e0:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10f0e3:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
    /* remaining length to be allocated */
    rem_len = length - p->len;
  10f0e6:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10f0e9:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
  10f0ed:	0f b7 45 e8          	movzwl 0xffffffe8(%ebp),%eax
  10f0f1:	66 29 d0             	sub    %dx,%ax
  10f0f4:	66 89 45 fa          	mov    %ax,0xfffffffa(%ebp)
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
  10f0f8:	e9 a5 00 00 00       	jmp    10f1a2 <pbuf_alloc+0x1c2>
      q = pbuf_pool_alloc();
  10f0fd:	e8 1e fe ff ff       	call   10ef20 <pbuf_pool_alloc>
  10f102:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
      if (q == NULL) {
  10f105:	83 7d f0 00          	cmpl   $0x0,0xfffffff0(%ebp)
  10f109:	75 27                	jne    10f132 <pbuf_alloc+0x152>
       LWIP_DEBUGF(PBUF_DEBUG | 2, ("pbuf_alloc: Out of pbufs in pool.\n"));
#if PBUF_STATS
        ++lwip_stats.pbuf.err;
  10f10b:	0f b7 05 82 15 14 00 	movzwl 0x141582,%eax
  10f112:	83 c0 01             	add    $0x1,%eax
  10f115:	66 a3 82 15 14 00    	mov    %ax,0x141582
#endif /* PBUF_STATS */
        /* free chain so far allocated */
        pbuf_free(p);
  10f11b:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10f11e:	89 04 24             	mov    %eax,(%esp)
  10f121:	e8 9a 03 00 00       	call   10f4c0 <pbuf_free>
        /* bail out unsuccesfully */
        return NULL;
  10f126:	c7 45 d8 00 00 00 00 	movl   $0x0,0xffffffd8(%ebp)
  10f12d:	e9 6d 01 00 00       	jmp    10f29f <pbuf_alloc+0x2bf>
      }
      q->next = NULL;
  10f132:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10f135:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
      /* make previous pbuf point to this pbuf */
      r->next = q;
  10f13b:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
  10f13e:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10f141:	89 02                	mov    %eax,(%edx)
      /* set total length of this pbuf and next in chain */
      q->tot_len = rem_len;
  10f143:	0f b7 55 fa          	movzwl 0xfffffffa(%ebp),%edx
  10f147:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10f14a:	66 89 50 08          	mov    %dx,0x8(%eax)
      /* this pbuf length is pool size, unless smaller sized tail */
      q->len = rem_len > PBUF_POOL_BUFSIZE? PBUF_POOL_BUFSIZE: rem_len;
  10f14e:	66 81 7d fa 80 00    	cmpw   $0x80,0xfffffffa(%ebp)
  10f154:	7f 0a                	jg     10f160 <pbuf_alloc+0x180>
  10f156:	0f b7 4d fa          	movzwl 0xfffffffa(%ebp),%ecx
  10f15a:	66 89 4d e4          	mov    %cx,0xffffffe4(%ebp)
  10f15e:	eb 06                	jmp    10f166 <pbuf_alloc+0x186>
  10f160:	66 c7 45 e4 80 00    	movw   $0x80,0xffffffe4(%ebp)
  10f166:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10f169:	0f b7 5d e4          	movzwl 0xffffffe4(%ebp),%ebx
  10f16d:	66 89 58 0a          	mov    %bx,0xa(%eax)
      q->payload = (void *)((u8_t *)q + sizeof(struct pbuf));
  10f171:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10f174:	8d 50 10             	lea    0x10(%eax),%edx
  10f177:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10f17a:	89 50 04             	mov    %edx,0x4(%eax)
      LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
              ((mem_ptr_t)q->payload % MEM_ALIGNMENT) == 0);
      q->ref = 1;
  10f17d:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10f180:	66 c7 40 0e 01 00    	movw   $0x1,0xe(%eax)
      /* calculate remaining length to be allocated */
      rem_len -= q->len;
  10f186:	0f b7 55 fa          	movzwl 0xfffffffa(%ebp),%edx
  10f18a:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10f18d:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  10f191:	89 d1                	mov    %edx,%ecx
  10f193:	66 29 c1             	sub    %ax,%cx
  10f196:	89 c8                	mov    %ecx,%eax
  10f198:	66 89 45 fa          	mov    %ax,0xfffffffa(%ebp)
      /* remember this pbuf for linkage in next iteration */
      r = q;
  10f19c:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10f19f:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  10f1a2:	66 83 7d fa 00       	cmpw   $0x0,0xfffffffa(%ebp)
  10f1a7:	0f 8f 50 ff ff ff    	jg     10f0fd <pbuf_alloc+0x11d>
    }
    /* end of chain */
    /*r->next = NULL;*/

    break;
  10f1ad:	e9 de 00 00 00       	jmp    10f290 <pbuf_alloc+0x2b0>
  case PBUF_RAM:
    /* If pbuf is to be allocated in RAM, allocate memory for it. */
    p = mem_malloc(MEM_ALIGN_SIZE(sizeof(struct pbuf) + length + offset));
  10f1b2:	0f b7 55 e8          	movzwl 0xffffffe8(%ebp),%edx
  10f1b6:	0f b7 45 f8          	movzwl 0xfffffff8(%ebp),%eax
  10f1ba:	8d 04 02             	lea    (%edx,%eax,1),%eax
  10f1bd:	83 c0 10             	add    $0x10,%eax
  10f1c0:	89 04 24             	mov    %eax,(%esp)
  10f1c3:	e8 08 f5 ff ff       	call   10e6d0 <mem_malloc>
  10f1c8:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
    if (p == NULL) {
  10f1cb:	83 7d ec 00          	cmpl   $0x0,0xffffffec(%ebp)
  10f1cf:	75 0c                	jne    10f1dd <pbuf_alloc+0x1fd>
      return NULL;
  10f1d1:	c7 45 d8 00 00 00 00 	movl   $0x0,0xffffffd8(%ebp)
  10f1d8:	e9 c2 00 00 00       	jmp    10f29f <pbuf_alloc+0x2bf>
    }
    /* Set up internal structure of the pbuf. */
    p->payload = MEM_ALIGN((void *)((u8_t *)p + sizeof(struct pbuf) + offset));
  10f1dd:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10f1e0:	8d 50 10             	lea    0x10(%eax),%edx
  10f1e3:	0f b7 45 f8          	movzwl 0xfffffff8(%ebp),%eax
  10f1e7:	01 c2                	add    %eax,%edx
  10f1e9:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10f1ec:	89 50 04             	mov    %edx,0x4(%eax)
    p->len = p->tot_len = length;
  10f1ef:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
  10f1f2:	0f b7 45 e8          	movzwl 0xffffffe8(%ebp),%eax
  10f1f6:	66 89 42 08          	mov    %ax,0x8(%edx)
  10f1fa:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10f1fd:	0f b7 50 08          	movzwl 0x8(%eax),%edx
  10f201:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10f204:	66 89 50 0a          	mov    %dx,0xa(%eax)
    p->next = NULL;
  10f208:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10f20b:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    p->flags = PBUF_FLAG_RAM;
  10f211:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10f214:	66 c7 40 0c 00 00    	movw   $0x0,0xc(%eax)

    LWIP_ASSERT("pbuf_alloc: pbuf->payload properly aligned",
           ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
    break;
  10f21a:	eb 74                	jmp    10f290 <pbuf_alloc+0x2b0>
  /* pbuf references existing (static constant) ROM payload? */
  case PBUF_ROM:
  /* pbuf references existing (externally allocated) RAM payload? */
  case PBUF_REF:
    /* only allocate memory for the pbuf structure */
    p = memp_malloc(MEMP_PBUF);
  10f21c:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  10f223:	e8 a8 f7 ff ff       	call   10e9d0 <memp_malloc>
  10f228:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
    if (p == NULL) {
  10f22b:	83 7d ec 00          	cmpl   $0x0,0xffffffec(%ebp)
  10f22f:	75 09                	jne    10f23a <pbuf_alloc+0x25a>
      LWIP_DEBUGF(PBUF_DEBUG | DBG_TRACE | 2, ("pbuf_alloc: Could not allocate MEMP_PBUF for PBUF_%s.\n", flag == PBUF_ROM?"ROM":"REF"));
      return NULL;
  10f231:	c7 45 d8 00 00 00 00 	movl   $0x0,0xffffffd8(%ebp)
  10f238:	eb 65                	jmp    10f29f <pbuf_alloc+0x2bf>
    }
    /* caller must set this field properly, afterwards */
    p->payload = NULL;
  10f23a:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10f23d:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    p->len = p->tot_len = length;
  10f244:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
  10f247:	0f b7 45 e8          	movzwl 0xffffffe8(%ebp),%eax
  10f24b:	66 89 42 08          	mov    %ax,0x8(%edx)
  10f24f:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10f252:	0f b7 50 08          	movzwl 0x8(%eax),%edx
  10f256:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10f259:	66 89 50 0a          	mov    %dx,0xa(%eax)
    p->next = NULL;
  10f25d:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10f260:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    p->flags = (flag == PBUF_ROM? PBUF_FLAG_ROM: PBUF_FLAG_REF);
  10f266:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
  10f26a:	75 08                	jne    10f274 <pbuf_alloc+0x294>
  10f26c:	66 c7 45 e6 01 00    	movw   $0x1,0xffffffe6(%ebp)
  10f272:	eb 06                	jmp    10f27a <pbuf_alloc+0x29a>
  10f274:	66 c7 45 e6 04 00    	movw   $0x4,0xffffffe6(%ebp)
  10f27a:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10f27d:	0f b7 5d e6          	movzwl 0xffffffe6(%ebp),%ebx
  10f281:	66 89 58 0c          	mov    %bx,0xc(%eax)
    break;
  10f285:	eb 09                	jmp    10f290 <pbuf_alloc+0x2b0>
  default:
    LWIP_ASSERT("pbuf_alloc: erroneous flag", 0);
    return NULL;
  10f287:	c7 45 d8 00 00 00 00 	movl   $0x0,0xffffffd8(%ebp)
  10f28e:	eb 0f                	jmp    10f29f <pbuf_alloc+0x2bf>
  }
  /* set reference count */
  p->ref = 1;
  10f290:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10f293:	66 c7 40 0e 01 00    	movw   $0x1,0xe(%eax)
  LWIP_DEBUGF(PBUF_DEBUG | DBG_TRACE | 3, ("pbuf_alloc(length=%u) == %p (%d)\n", length, (void *)p, offset));
  return p;
  10f299:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10f29c:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
  10f29f:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
}
  10f2a2:	83 c4 34             	add    $0x34,%esp
  10f2a5:	5b                   	pop    %ebx
  10f2a6:	5d                   	pop    %ebp
  10f2a7:	c3                   	ret    
  10f2a8:	90                   	nop    
  10f2a9:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

0010f2b0 <pbuf_realloc>:


#if PBUF_STATS
#define DEC_PBUF_STATS do { --lwip_stats.pbuf.used; } while (0)
#else /* PBUF_STATS */
#define DEC_PBUF_STATS
#endif /* PBUF_STATS */

#define PBUF_POOL_FAST_FREE(p)  do {                                    \
                                  p->next = pbuf_pool;                  \
                                  pbuf_pool = p;                        \
                                  DEC_PBUF_STATS;                       \
                                } while (0)

#if SYS_LIGHTWEIGHT_PROT
#define PBUF_POOL_FREE(p)  do {                                         \
                                SYS_ARCH_DECL_PROTECT(old_level);       \
                                SYS_ARCH_PROTECT(old_level);            \
                                PBUF_POOL_FAST_FREE(p);                 \
                                SYS_ARCH_UNPROTECT(old_level);          \
                               } while (0)
#else /* SYS_LIGHTWEIGHT_PROT */
#define PBUF_POOL_FREE(p)  do {                                         \
                             sys_sem_wait(pbuf_pool_free_sem);          \
                             PBUF_POOL_FAST_FREE(p);                    \
                             sys_sem_signal(pbuf_pool_free_sem);        \
                           } while (0)
#endif /* SYS_LIGHTWEIGHT_PROT */

/**
 * Shrink a pbuf chain to a desired length.
 *
 * @param p pbuf to shrink.
 * @param new_len desired new length of pbuf chain
 *
 * Depending on the desired length, the first few pbufs in a chain might
 * be skipped and left unchanged. The new last pbuf in the chain will be
 * resized, and any remaining pbufs will be freed.
 *
 * @note If the pbuf is ROM/REF, only the ->tot_len and ->len fields are adjusted.
 * @note May not be called on a packet queue.
 *
 * @bug Cannot grow the size of a pbuf (chain) (yet).
 */
void
pbuf_realloc(struct pbuf *p, u16_t new_len)
{
  10f2b0:	55                   	push   %ebp
  10f2b1:	89 e5                	mov    %esp,%ebp
  10f2b3:	83 ec 28             	sub    $0x28,%esp
  10f2b6:	8b 45 0c             	mov    0xc(%ebp),%eax
  10f2b9:	66 89 45 ec          	mov    %ax,0xffffffec(%ebp)
  struct pbuf *q;
  u16_t rem_len; /* remaining length */
  s16_t grow;

  LWIP_ASSERT("pbuf_realloc: sane p->flags", p->flags == PBUF_FLAG_POOL ||
  10f2bd:	8b 45 08             	mov    0x8(%ebp),%eax
  10f2c0:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  10f2c4:	66 83 f8 02          	cmp    $0x2,%ax
  10f2c8:	74 0d                	je     10f2d7 <pbuf_realloc+0x27>
  10f2ca:	8b 45 08             	mov    0x8(%ebp),%eax
  10f2cd:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  10f2d1:	66 83 f8 01          	cmp    $0x1,%ax
  10f2d5:	74 00                	je     10f2d7 <pbuf_realloc+0x27>
              p->flags == PBUF_FLAG_ROM ||
              p->flags == PBUF_FLAG_RAM ||
              p->flags == PBUF_FLAG_REF);

  /* desired length larger than current length? */
  if (new_len >= p->tot_len) {
  10f2d7:	8b 45 08             	mov    0x8(%ebp),%eax
  10f2da:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  10f2de:	66 3b 45 ec          	cmp    0xffffffec(%ebp),%ax
  10f2e2:	0f 86 ca 00 00 00    	jbe    10f3b2 <pbuf_realloc+0x102>
    /* enlarging not yet supported */
    return;
  }

  /* the pbuf chain grows by (new_len - p->tot_len) bytes
   * (which may be negative in case of shrinking) */
  grow = new_len - p->tot_len;
  10f2e8:	8b 45 08             	mov    0x8(%ebp),%eax
  10f2eb:	0f b7 50 08          	movzwl 0x8(%eax),%edx
  10f2ef:	0f b7 45 ec          	movzwl 0xffffffec(%ebp),%eax
  10f2f3:	66 29 d0             	sub    %dx,%ax
  10f2f6:	66 89 45 fe          	mov    %ax,0xfffffffe(%ebp)

  /* first, step over any pbufs that should remain in the chain */
  rem_len = new_len;
  10f2fa:	0f b7 45 ec          	movzwl 0xffffffec(%ebp),%eax
  10f2fe:	66 89 45 fc          	mov    %ax,0xfffffffc(%ebp)
  q = p;
  10f302:	8b 45 08             	mov    0x8(%ebp),%eax
  10f305:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
  10f308:	eb 27                	jmp    10f331 <pbuf_realloc+0x81>
    /* decrease remaining length by pbuf length */
    rem_len -= q->len;
  10f30a:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10f30d:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  10f311:	66 29 45 fc          	sub    %ax,0xfffffffc(%ebp)
    /* decrease total length indicator */
    q->tot_len += grow;
  10f315:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10f318:	0f b7 50 08          	movzwl 0x8(%eax),%edx
  10f31c:	0f b7 45 fe          	movzwl 0xfffffffe(%ebp),%eax
  10f320:	01 c2                	add    %eax,%edx
  10f322:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10f325:	66 89 50 08          	mov    %dx,0x8(%eax)
    /* proceed to next pbuf in chain */
    q = q->next;
  10f329:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10f32c:	8b 00                	mov    (%eax),%eax
  10f32e:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  10f331:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10f334:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  10f338:	66 3b 45 fc          	cmp    0xfffffffc(%ebp),%ax
  10f33c:	72 cc                	jb     10f30a <pbuf_realloc+0x5a>
  }
  /* we have now reached the new last pbuf (in q) */
  /* rem_len == desired length for pbuf q */

  /* shrink allocated memory for PBUF_RAM */
  /* (other types merely adjust their length fields */
  if ((q->flags == PBUF_FLAG_RAM) && (rem_len != q->len)) {
  10f33e:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10f341:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  10f345:	66 85 c0             	test   %ax,%ax
  10f348:	75 30                	jne    10f37a <pbuf_realloc+0xca>
  10f34a:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10f34d:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  10f351:	66 3b 45 fc          	cmp    0xfffffffc(%ebp),%ax
  10f355:	74 23                	je     10f37a <pbuf_realloc+0xca>
    /* reallocate and adjust the length of the pbuf that will be split */
    mem_realloc(q, (u8_t *)q->payload - (u8_t *)q + rem_len);
  10f357:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10f35a:	8b 40 04             	mov    0x4(%eax),%eax
  10f35d:	89 c2                	mov    %eax,%edx
  10f35f:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10f362:	29 c2                	sub    %eax,%edx
  10f364:	0f b7 45 fc          	movzwl 0xfffffffc(%ebp),%eax
  10f368:	8d 04 02             	lea    (%edx,%eax,1),%eax
  10f36b:	89 44 24 04          	mov    %eax,0x4(%esp)
  10f36f:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10f372:	89 04 24             	mov    %eax,(%esp)
  10f375:	e8 46 f2 ff ff       	call   10e5c0 <mem_realloc>
  }
  /* adjust length fields for new last pbuf */
  q->len = rem_len;
  10f37a:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  10f37d:	0f b7 45 fc          	movzwl 0xfffffffc(%ebp),%eax
  10f381:	66 89 42 0a          	mov    %ax,0xa(%edx)
  q->tot_len = q->len;
  10f385:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10f388:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
  10f38c:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10f38f:	66 89 50 08          	mov    %dx,0x8(%eax)

  /* any remaining pbufs in chain? */
  if (q->next != NULL) {
  10f393:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10f396:	8b 00                	mov    (%eax),%eax
  10f398:	85 c0                	test   %eax,%eax
  10f39a:	74 0d                	je     10f3a9 <pbuf_realloc+0xf9>
    /* free remaining pbufs in chain */
    pbuf_free(q->next);
  10f39c:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10f39f:	8b 00                	mov    (%eax),%eax
  10f3a1:	89 04 24             	mov    %eax,(%esp)
  10f3a4:	e8 17 01 00 00       	call   10f4c0 <pbuf_free>
  }
  /* q is last packet in chain */
  q->next = NULL;
  10f3a9:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10f3ac:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

}
  10f3b2:	c9                   	leave  
  10f3b3:	c3                   	ret    
  10f3b4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  10f3ba:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

0010f3c0 <pbuf_header>:

/**
 * Adjusts the payload pointer to hide or reveal headers in the payload.
 *
 * Adjusts the ->payload pointer so that space for a header
 * (dis)appears in the pbuf payload.
 *
 * The ->payload, ->tot_len and ->len fields are adjusted.
 *
 * @param hdr_size Number of bytes to increment header size which
 * increases the size of the pbuf. New space is on the front.
 * (Using a negative value decreases the header size.)
 *
 * PBUF_ROM and PBUF_REF type buffers cannot have their sizes increased, so
 * the call will fail. A check is made that the increase in header size does
 * not move the payload pointer in front of the start of the buffer.
 * @return 1 on failure, 0 on success.
 *
 * @note May not be called on a packet queue.
 */
u8_t
pbuf_header(struct pbuf *p, s16_t header_size)
{
  10f3c0:	55                   	push   %ebp
  10f3c1:	89 e5                	mov    %esp,%ebp
  10f3c3:	83 ec 18             	sub    $0x18,%esp
  10f3c6:	8b 45 0c             	mov    0xc(%ebp),%eax
  10f3c9:	66 89 45 ec          	mov    %ax,0xffffffec(%ebp)
  void *payload;

  /* remember current payload pointer */
  payload = p->payload;
  10f3cd:	8b 45 08             	mov    0x8(%ebp),%eax
  10f3d0:	8b 40 04             	mov    0x4(%eax),%eax
  10f3d3:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)

  /* pbuf types containing payloads? */
  if (p->flags == PBUF_FLAG_RAM || p->flags == PBUF_FLAG_POOL) {
  10f3d6:	8b 45 08             	mov    0x8(%ebp),%eax
  10f3d9:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  10f3dd:	66 85 c0             	test   %ax,%ax
  10f3e0:	74 0d                	je     10f3ef <pbuf_header+0x2f>
  10f3e2:	8b 45 08             	mov    0x8(%ebp),%eax
  10f3e5:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  10f3e9:	66 83 f8 02          	cmp    $0x2,%ax
  10f3ed:	75 3b                	jne    10f42a <pbuf_header+0x6a>
    /* set new payload pointer */
    p->payload = (u8_t *)p->payload - header_size;
  10f3ef:	8b 45 08             	mov    0x8(%ebp),%eax
  10f3f2:	8b 40 04             	mov    0x4(%eax),%eax
  10f3f5:	89 c2                	mov    %eax,%edx
  10f3f7:	0f bf 45 ec          	movswl 0xffffffec(%ebp),%eax
  10f3fb:	29 c2                	sub    %eax,%edx
  10f3fd:	8b 45 08             	mov    0x8(%ebp),%eax
  10f400:	89 50 04             	mov    %edx,0x4(%eax)
    /* boundary check fails? */
    if ((u8_t *)p->payload < (u8_t *)p + sizeof(struct pbuf)) {
  10f403:	8b 45 08             	mov    0x8(%ebp),%eax
  10f406:	8b 40 04             	mov    0x4(%eax),%eax
  10f409:	89 c2                	mov    %eax,%edx
  10f40b:	8b 45 08             	mov    0x8(%ebp),%eax
  10f40e:	83 c0 10             	add    $0x10,%eax
  10f411:	39 c2                	cmp    %eax,%edx
  10f413:	73 6d                	jae    10f482 <pbuf_header+0xc2>
      LWIP_DEBUGF( PBUF_DEBUG | 2, ("pbuf_header: failed as %p < %p\n",
        (u8_t *)p->payload,
        (u8_t *)((u32_t)p + sizeof(struct pbuf))) );\
      /* restore old payload pointer */
      p->payload = payload;
  10f415:	8b 55 08             	mov    0x8(%ebp),%edx
  10f418:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10f41b:	89 42 04             	mov    %eax,0x4(%edx)
      /* bail out unsuccesfully */
      return 1;
  10f41e:	c7 45 e8 01 00 00 00 	movl   $0x1,0xffffffe8(%ebp)
  10f425:	e9 87 00 00 00       	jmp    10f4b1 <pbuf_header+0xf1>
    }
  /* pbuf types refering to payloads? */
  } else if (p->flags == PBUF_FLAG_REF || p->flags == PBUF_FLAG_ROM) {
  10f42a:	8b 45 08             	mov    0x8(%ebp),%eax
  10f42d:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  10f431:	66 83 f8 04          	cmp    $0x4,%ax
  10f435:	74 0d                	je     10f444 <pbuf_header+0x84>
  10f437:	8b 45 08             	mov    0x8(%ebp),%eax
  10f43a:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  10f43e:	66 83 f8 01          	cmp    $0x1,%ax
  10f442:	75 3e                	jne    10f482 <pbuf_header+0xc2>
    /* hide a header in the payload? */
    if ((header_size < 0) && (header_size - p->len <= 0)) {
  10f444:	66 83 7d ec 00       	cmpw   $0x0,0xffffffec(%ebp)
  10f449:	79 2e                	jns    10f479 <pbuf_header+0xb9>
  10f44b:	0f bf 55 ec          	movswl 0xffffffec(%ebp),%edx
  10f44f:	8b 45 08             	mov    0x8(%ebp),%eax
  10f452:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  10f456:	0f b7 c0             	movzwl %ax,%eax
  10f459:	89 d1                	mov    %edx,%ecx
  10f45b:	29 c1                	sub    %eax,%ecx
  10f45d:	89 c8                	mov    %ecx,%eax
  10f45f:	85 c0                	test   %eax,%eax
  10f461:	7f 16                	jg     10f479 <pbuf_header+0xb9>
      /* increase payload pointer */
      p->payload = (u8_t *)p->payload - header_size;
  10f463:	8b 45 08             	mov    0x8(%ebp),%eax
  10f466:	8b 40 04             	mov    0x4(%eax),%eax
  10f469:	89 c2                	mov    %eax,%edx
  10f46b:	0f bf 45 ec          	movswl 0xffffffec(%ebp),%eax
  10f46f:	29 c2                	sub    %eax,%edx
  10f471:	8b 45 08             	mov    0x8(%ebp),%eax
  10f474:	89 50 04             	mov    %edx,0x4(%eax)
  10f477:	eb 09                	jmp    10f482 <pbuf_header+0xc2>
    } else {
      /* cannot expand payload to front (yet!)
       * bail out unsuccesfully */
      return 1;
  10f479:	c7 45 e8 01 00 00 00 	movl   $0x1,0xffffffe8(%ebp)
  10f480:	eb 2f                	jmp    10f4b1 <pbuf_header+0xf1>
    }
  }
  LWIP_DEBUGF( PBUF_DEBUG, ("pbuf_header: old %p new %p (%d)\n", (void *)payload, (void *)p->payload, header_size) );
  /* modify pbuf length fields */
  p->len += header_size;
  10f482:	8b 45 08             	mov    0x8(%ebp),%eax
  10f485:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
  10f489:	0f b7 45 ec          	movzwl 0xffffffec(%ebp),%eax
  10f48d:	01 c2                	add    %eax,%edx
  10f48f:	8b 45 08             	mov    0x8(%ebp),%eax
  10f492:	66 89 50 0a          	mov    %dx,0xa(%eax)
  p->tot_len += header_size;
  10f496:	8b 45 08             	mov    0x8(%ebp),%eax
  10f499:	0f b7 50 08          	movzwl 0x8(%eax),%edx
  10f49d:	0f b7 45 ec          	movzwl 0xffffffec(%ebp),%eax
  10f4a1:	01 c2                	add    %eax,%edx
  10f4a3:	8b 45 08             	mov    0x8(%ebp),%eax
  10f4a6:	66 89 50 08          	mov    %dx,0x8(%eax)

  return 0;
  10f4aa:	c7 45 e8 00 00 00 00 	movl   $0x0,0xffffffe8(%ebp)
  10f4b1:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
}
  10f4b4:	c9                   	leave  
  10f4b5:	c3                   	ret    
  10f4b6:	8d 76 00             	lea    0x0(%esi),%esi
  10f4b9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

0010f4c0 <pbuf_free>:

/**
 * Dereference a pbuf (chain) and deallocate any no-longer-used
 * pbufs at the head of this chain.
 *
 * Decrements the pbuf reference count. If it reaches
 * zero, the pbuf is deallocated.
 *
 * For a pbuf chain, this is repeated for each pbuf in the chain,
 * up to a pbuf which has a non-zero reference count after
 * decrementing. (This might de-allocate the whole chain.)
 *
 * @param pbuf The pbuf (chain) to be dereferenced.
 *
 * @return the number of pbufs that were de-allocated
 * from the head of the chain.
 *
 * @note MUST NOT be called on a packet queue.
 * @note the reference counter of a pbuf equals the number of pointers
 * that refer to the pbuf (or into the pbuf).
 *
 * @internal examples:
 *
 * Assuming existing chains a->b->c with the following reference
 * counts, calling pbuf_free(a) results in:
 * 
 * 1->2->3 becomes ...1->3
 * 3->3->3 becomes 2->3->3
 * 1->1->2 becomes ......1
 * 2->1->1 becomes 1->1->1
 * 1->1->1 becomes .......
 *
 */
u8_t
pbuf_free(struct pbuf *p)
{
  10f4c0:	55                   	push   %ebp
  10f4c1:	89 e5                	mov    %esp,%ebp
  10f4c3:	83 ec 28             	sub    $0x28,%esp
  struct pbuf *q;
  u8_t count;
  SYS_ARCH_DECL_PROTECT(old_level);

  if (p == NULL) {
  10f4c6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  10f4ca:	75 0c                	jne    10f4d8 <pbuf_free+0x18>
    LWIP_DEBUGF(PBUF_DEBUG | DBG_TRACE | 2, ("pbuf_free(p == NULL) was called.\n"));
    return 0;
  10f4cc:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  10f4d3:	e9 18 01 00 00       	jmp    10f5f0 <pbuf_free+0x130>
  }
  LWIP_DEBUGF(PBUF_DEBUG | DBG_TRACE | 3, ("pbuf_free(%p)\n", (void *)p));

  PERF_START;

  LWIP_ASSERT("pbuf_free: sane flags",
  10f4d8:	8b 45 08             	mov    0x8(%ebp),%eax
  10f4db:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  10f4df:	66 85 c0             	test   %ax,%ax
  10f4e2:	74 0d                	je     10f4f1 <pbuf_free+0x31>
  10f4e4:	8b 45 08             	mov    0x8(%ebp),%eax
  10f4e7:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  10f4eb:	66 83 f8 01          	cmp    $0x1,%ax
  10f4ef:	74 00                	je     10f4f1 <pbuf_free+0x31>
    p->flags == PBUF_FLAG_RAM || p->flags == PBUF_FLAG_ROM ||
    p->flags == PBUF_FLAG_REF || p->flags == PBUF_FLAG_POOL);

  count = 0;
  10f4f1:	c6 45 ff 00          	movb   $0x0,0xffffffff(%ebp)
  /* Since decrementing ref cannot be guaranteed to be a single machine operation
   * we must protect it. Also, the later test of ref must be protected.
   */
  SYS_ARCH_PROTECT(old_level);
  /* de-allocate all consecutive pbufs from the head of the chain that
   * obtain a zero reference count after decrementing*/
  while (p != NULL) {
  10f4f5:	e9 e5 00 00 00       	jmp    10f5df <pbuf_free+0x11f>
    /* all pbufs in a chain are referenced at least once */
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
    /* decrease reference count (number of pointers to pbuf) */
    p->ref--;
  10f4fa:	8b 45 08             	mov    0x8(%ebp),%eax
  10f4fd:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
  10f501:	8d 50 ff             	lea    0xffffffff(%eax),%edx
  10f504:	8b 45 08             	mov    0x8(%ebp),%eax
  10f507:	66 89 50 0e          	mov    %dx,0xe(%eax)
    /* this pbuf is no longer referenced to? */
    if (p->ref == 0) {
  10f50b:	8b 45 08             	mov    0x8(%ebp),%eax
  10f50e:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
  10f512:	66 85 c0             	test   %ax,%ax
  10f515:	0f 85 bd 00 00 00    	jne    10f5d8 <pbuf_free+0x118>
      /* remember next pbuf in chain for next iteration */
      q = p->next;
  10f51b:	8b 45 08             	mov    0x8(%ebp),%eax
  10f51e:	8b 00                	mov    (%eax),%eax
  10f520:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
      LWIP_DEBUGF( PBUF_DEBUG | 2, ("pbuf_free: deallocating %p\n", (void *)p));
      /* is this a pbuf from the pool? */
      if (p->flags == PBUF_FLAG_POOL) {
  10f523:	8b 45 08             	mov    0x8(%ebp),%eax
  10f526:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  10f52a:	66 83 f8 02          	cmp    $0x2,%ax
  10f52e:	75 62                	jne    10f592 <pbuf_free+0xd2>
        p->len = p->tot_len = PBUF_POOL_BUFSIZE;
  10f530:	8b 45 08             	mov    0x8(%ebp),%eax
  10f533:	66 c7 40 08 80 00    	movw   $0x80,0x8(%eax)
  10f539:	8b 45 08             	mov    0x8(%ebp),%eax
  10f53c:	0f b7 50 08          	movzwl 0x8(%eax),%edx
  10f540:	8b 45 08             	mov    0x8(%ebp),%eax
  10f543:	66 89 50 0a          	mov    %dx,0xa(%eax)
        p->payload = (void *)((u8_t *)p + sizeof(struct pbuf));
  10f547:	8b 45 08             	mov    0x8(%ebp),%eax
  10f54a:	8d 50 10             	lea    0x10(%eax),%edx
  10f54d:	8b 45 08             	mov    0x8(%ebp),%eax
  10f550:	89 50 04             	mov    %edx,0x4(%eax)
        PBUF_POOL_FREE(p);
  10f553:	a1 e4 98 13 00       	mov    0x1398e4,%eax
  10f558:	89 04 24             	mov    %eax,(%esp)
  10f55b:	e8 b0 08 00 00       	call   10fe10 <sys_sem_wait>
  10f560:	8b 15 c0 08 13 00    	mov    0x1308c0,%edx
  10f566:	8b 45 08             	mov    0x8(%ebp),%eax
  10f569:	89 10                	mov    %edx,(%eax)
  10f56b:	8b 45 08             	mov    0x8(%ebp),%eax
  10f56e:	a3 c0 08 13 00       	mov    %eax,0x1308c0
  10f573:	0f b7 05 7e 15 14 00 	movzwl 0x14157e,%eax
  10f57a:	83 e8 01             	sub    $0x1,%eax
  10f57d:	66 a3 7e 15 14 00    	mov    %ax,0x14157e
  10f583:	a1 e4 98 13 00       	mov    0x1398e4,%eax
  10f588:	89 04 24             	mov    %eax,(%esp)
  10f58b:	e8 40 a8 00 00       	call   119dd0 <sys_sem_signal>
  10f590:	eb 3a                	jmp    10f5cc <pbuf_free+0x10c>
      /* a ROM or RAM referencing pbuf */
      } else if (p->flags == PBUF_FLAG_ROM || p->flags == PBUF_FLAG_REF) {
  10f592:	8b 45 08             	mov    0x8(%ebp),%eax
  10f595:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  10f599:	66 83 f8 01          	cmp    $0x1,%ax
  10f59d:	74 0d                	je     10f5ac <pbuf_free+0xec>
  10f59f:	8b 45 08             	mov    0x8(%ebp),%eax
  10f5a2:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  10f5a6:	66 83 f8 04          	cmp    $0x4,%ax
  10f5aa:	75 15                	jne    10f5c1 <pbuf_free+0x101>
        memp_free(MEMP_PBUF, p);
  10f5ac:	8b 45 08             	mov    0x8(%ebp),%eax
  10f5af:	89 44 24 04          	mov    %eax,0x4(%esp)
  10f5b3:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  10f5ba:	e8 01 f5 ff ff       	call   10eac0 <memp_free>
  10f5bf:	eb 0b                	jmp    10f5cc <pbuf_free+0x10c>
      /* p->flags == PBUF_FLAG_RAM */
      } else {
        mem_free(p);
  10f5c1:	8b 45 08             	mov    0x8(%ebp),%eax
  10f5c4:	89 04 24             	mov    %eax,(%esp)
  10f5c7:	e8 d4 ee ff ff       	call   10e4a0 <mem_free>
      }
      count++;
  10f5cc:	80 45 ff 01          	addb   $0x1,0xffffffff(%ebp)
      /* proceed to next pbuf */
      p = q;
  10f5d0:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10f5d3:	89 45 08             	mov    %eax,0x8(%ebp)
  10f5d6:	eb 07                	jmp    10f5df <pbuf_free+0x11f>
    /* p->ref > 0, this pbuf is still referenced to */
    /* (and so the remaining pbufs in chain as well) */
    } else {
      LWIP_DEBUGF( PBUF_DEBUG | 2, ("pbuf_free: %p has ref %u, ending here.\n", (void *)p, (unsigned int)p->ref));
      /* stop walking through chain */
      p = NULL;
  10f5d8:	c7 45 08 00 00 00 00 	movl   $0x0,0x8(%ebp)
  10f5df:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  10f5e3:	0f 85 11 ff ff ff    	jne    10f4fa <pbuf_free+0x3a>
    }
  }
  SYS_ARCH_UNPROTECT(old_level);
  PERF_STOP("pbuf_free");
  /* return number of de-allocated pbufs */
  return count;
  10f5e9:	0f b6 45 ff          	movzbl 0xffffffff(%ebp),%eax
  10f5ed:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  10f5f0:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  10f5f3:	c9                   	leave  
  10f5f4:	c3                   	ret    
  10f5f5:	8d 74 26 00          	lea    0x0(%esi),%esi
  10f5f9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

0010f600 <pbuf_clen>:

/**
 * Count number of pbufs in a chain
 *
 * @param p first pbuf of chain
 * @return the number of pbufs in a chain
 */

u8_t
pbuf_clen(struct pbuf *p)
{
  10f600:	55                   	push   %ebp
  10f601:	89 e5                	mov    %esp,%ebp
  10f603:	83 ec 10             	sub    $0x10,%esp
  u8_t len;

  len = 0;
  10f606:	c6 45 ff 00          	movb   $0x0,0xffffffff(%ebp)
  while (p != NULL) {
  10f60a:	eb 0c                	jmp    10f618 <pbuf_clen+0x18>
    ++len;
  10f60c:	80 45 ff 01          	addb   $0x1,0xffffffff(%ebp)
    p = p->next;
  10f610:	8b 45 08             	mov    0x8(%ebp),%eax
  10f613:	8b 00                	mov    (%eax),%eax
  10f615:	89 45 08             	mov    %eax,0x8(%ebp)
  10f618:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  10f61c:	75 ee                	jne    10f60c <pbuf_clen+0xc>
  }
  return len;
  10f61e:	0f b6 45 ff          	movzbl 0xffffffff(%ebp),%eax
}
  10f622:	c9                   	leave  
  10f623:	c3                   	ret    
  10f624:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  10f62a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

0010f630 <pbuf_ref>:

/**
 * Increment the reference count of the pbuf.
 *
 * @param p pbuf to increase reference counter of
 *
 */
void
pbuf_ref(struct pbuf *p)
{
  10f630:	55                   	push   %ebp
  10f631:	89 e5                	mov    %esp,%ebp
  SYS_ARCH_DECL_PROTECT(old_level);
  /* pbuf given? */
  if (p != NULL) {
  10f633:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  10f637:	74 11                	je     10f64a <pbuf_ref+0x1a>
    SYS_ARCH_PROTECT(old_level);
    ++(p->ref);
  10f639:	8b 45 08             	mov    0x8(%ebp),%eax
  10f63c:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
  10f640:	8d 50 01             	lea    0x1(%eax),%edx
  10f643:	8b 45 08             	mov    0x8(%ebp),%eax
  10f646:	66 89 50 0e          	mov    %dx,0xe(%eax)
    SYS_ARCH_UNPROTECT(old_level);
  }
}
  10f64a:	5d                   	pop    %ebp
  10f64b:	c3                   	ret    
  10f64c:	8d 74 26 00          	lea    0x0(%esi),%esi

0010f650 <pbuf_cat>:

/**
 * Concatenate two pbufs (each may be a pbuf chain) and take over
 * the caller's reference of the tail pbuf.
 * 
 * @note The caller MAY NOT reference the tail pbuf afterwards.
 * Use pbuf_chain() for that purpose.
 * 
 * @see pbuf_chain()
 */

void
pbuf_cat(struct pbuf *h, struct pbuf *t)
{
  10f650:	55                   	push   %ebp
  10f651:	89 e5                	mov    %esp,%ebp
  10f653:	83 ec 10             	sub    $0x10,%esp
  struct pbuf *p;

  LWIP_ASSERT("h != NULL", h != NULL);
  LWIP_ASSERT("t != NULL", t != NULL);
  if ((h == NULL) || (t == NULL)) return;
  10f656:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  10f65a:	74 57                	je     10f6b3 <pbuf_cat+0x63>
  10f65c:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  10f660:	75 02                	jne    10f664 <pbuf_cat+0x14>
  10f662:	eb 4f                	jmp    10f6b3 <pbuf_cat+0x63>

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
  10f664:	8b 45 08             	mov    0x8(%ebp),%eax
  10f667:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  10f66a:	eb 1f                	jmp    10f68b <pbuf_cat+0x3b>
    /* add total length of second chain to all totals of first chain */
    p->tot_len += t->tot_len;
  10f66c:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10f66f:	0f b7 50 08          	movzwl 0x8(%eax),%edx
  10f673:	8b 45 0c             	mov    0xc(%ebp),%eax
  10f676:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  10f67a:	01 c2                	add    %eax,%edx
  10f67c:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10f67f:	66 89 50 08          	mov    %dx,0x8(%eax)
  10f683:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10f686:	8b 00                	mov    (%eax),%eax
  10f688:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  10f68b:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10f68e:	8b 00                	mov    (%eax),%eax
  10f690:	85 c0                	test   %eax,%eax
  10f692:	75 d8                	jne    10f66c <pbuf_cat+0x1c>
  }
  /* { p is last pbuf of first h chain, p->next == NULL } */
  LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
  /* add total length of second chain to last pbuf total of first chain */
  p->tot_len += t->tot_len;
  10f694:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10f697:	0f b7 50 08          	movzwl 0x8(%eax),%edx
  10f69b:	8b 45 0c             	mov    0xc(%ebp),%eax
  10f69e:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  10f6a2:	01 c2                	add    %eax,%edx
  10f6a4:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10f6a7:	66 89 50 08          	mov    %dx,0x8(%eax)
  /* chain last pbuf of head (p) with first of tail (t) */
  p->next = t;
  10f6ab:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  10f6ae:	8b 45 0c             	mov    0xc(%ebp),%eax
  10f6b1:	89 02                	mov    %eax,(%edx)
}
  10f6b3:	c9                   	leave  
  10f6b4:	c3                   	ret    
  10f6b5:	8d 74 26 00          	lea    0x0(%esi),%esi
  10f6b9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

0010f6c0 <pbuf_chain>:

/**
 * Chain two pbufs (or pbuf chains) together.
 * 
 * The caller MUST call pbuf_free(t) once it has stopped
 * using it. Use pbuf_cat() instead if you no longer use t.
 * 
 * @param h head pbuf (chain)
 * @param t tail pbuf (chain)
 * @note The pbufs MUST belong to the same packet.
 * @note MAY NOT be called on a packet queue.
 *
 * The ->tot_len fields of all pbufs of the head chain are adjusted.
 * The ->next field of the last pbuf of the head chain is adjusted.
 * The ->ref field of the first pbuf of the tail chain is adjusted.
 *
 */
void
pbuf_chain(struct pbuf *h, struct pbuf *t)
{
  10f6c0:	55                   	push   %ebp
  10f6c1:	89 e5                	mov    %esp,%ebp
  10f6c3:	83 ec 08             	sub    $0x8,%esp
  pbuf_cat(h, t);
  10f6c6:	8b 45 0c             	mov    0xc(%ebp),%eax
  10f6c9:	89 44 24 04          	mov    %eax,0x4(%esp)
  10f6cd:	8b 45 08             	mov    0x8(%ebp),%eax
  10f6d0:	89 04 24             	mov    %eax,(%esp)
  10f6d3:	e8 78 ff ff ff       	call   10f650 <pbuf_cat>
  /* t is now referenced by h */
  pbuf_ref(t);
  10f6d8:	8b 45 0c             	mov    0xc(%ebp),%eax
  10f6db:	89 04 24             	mov    %eax,(%esp)
  10f6de:	e8 4d ff ff ff       	call   10f630 <pbuf_ref>
  LWIP_DEBUGF(PBUF_DEBUG | DBG_FRESH | 2, ("pbuf_chain: %p references %p\n", (void *)h, (void *)t));
}
  10f6e3:	c9                   	leave  
  10f6e4:	c3                   	ret    
  10f6e5:	8d 74 26 00          	lea    0x0(%esi),%esi
  10f6e9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

0010f6f0 <pbuf_queue>:

/* For packet queueing. Note that queued packets must be dequeued first
 * before calling any pbuf functions. */
#if ARP_QUEUEING
/**
 * Add a packet to the end of a queue.
 *
 * @param q pointer to first packet on the queue
 * @param n packet to be queued
 *
 */
void
pbuf_queue(struct pbuf *p, struct pbuf *n)
{
  10f6f0:	55                   	push   %ebp
  10f6f1:	89 e5                	mov    %esp,%ebp
  10f6f3:	83 ec 04             	sub    $0x4,%esp
  LWIP_ASSERT("p != NULL", p != NULL);
  LWIP_ASSERT("n != NULL", n != NULL);

  if ((p == NULL) || (n == NULL))
  10f6f6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  10f6fa:	74 2c                	je     10f728 <pbuf_queue+0x38>
  10f6fc:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  10f700:	75 0a                	jne    10f70c <pbuf_queue+0x1c>
    return;
  10f702:	eb 24                	jmp    10f728 <pbuf_queue+0x38>

  /* iterate through all packets on queue */
  while (p->next != NULL) {
/* be very picky about pbuf chain correctness */
#if PBUF_DEBUG
    /* iterate through all pbufs in packet */
    while (p->tot_len != p->len) {
      /* make sure each packet is complete */
      LWIP_ASSERT("p->next != NULL", p->next != NULL);
      p = p->next;
    }
#endif
    /* now p->tot_len == p->len */
    /* proceed to next packet on queue */
    p = p->next;
  10f704:	8b 45 08             	mov    0x8(%ebp),%eax
  10f707:	8b 00                	mov    (%eax),%eax
  10f709:	89 45 08             	mov    %eax,0x8(%ebp)
  10f70c:	8b 45 08             	mov    0x8(%ebp),%eax
  10f70f:	8b 00                	mov    (%eax),%eax
  10f711:	85 c0                	test   %eax,%eax
  10f713:	75 ef                	jne    10f704 <pbuf_queue+0x14>
  }
  /* chain last pbuf of queue with n */
  p->next = n;
  10f715:	8b 45 08             	mov    0x8(%ebp),%eax
  10f718:	8b 55 0c             	mov    0xc(%ebp),%edx
  10f71b:	89 10                	mov    %edx,(%eax)
  /* n is now referenced to one more time */
  pbuf_ref(n);
  10f71d:	8b 45 0c             	mov    0xc(%ebp),%eax
  10f720:	89 04 24             	mov    %eax,(%esp)
  10f723:	e8 08 ff ff ff       	call   10f630 <pbuf_ref>
  LWIP_DEBUGF(PBUF_DEBUG | DBG_FRESH | 2, ("pbuf_queue: referencing queued packet %p\n", (void *)n));
}
  10f728:	c9                   	leave  
  10f729:	c3                   	ret    
  10f72a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

0010f730 <pbuf_dequeue>:

/**
 * Remove a packet from the head of a queue.
 *
 * @param p pointer to first packet on the queue which will be dequeued.
 * @return first packet on the remaining queue (NULL if no further packets).
 *
 */
struct pbuf *
pbuf_dequeue(struct pbuf *p)
{
  10f730:	55                   	push   %ebp
  10f731:	89 e5                	mov    %esp,%ebp
  10f733:	83 ec 18             	sub    $0x18,%esp
  struct pbuf *q;
  LWIP_ASSERT("p != NULL", p != NULL);

  /* iterate through all pbufs in packet */
  while (p->tot_len != p->len) {
  10f736:	eb 08                	jmp    10f740 <pbuf_dequeue+0x10>
    /* make sure each packet is complete */
    LWIP_ASSERT("p->next != NULL", p->next != NULL);
    p = p->next;
  10f738:	8b 45 08             	mov    0x8(%ebp),%eax
  10f73b:	8b 00                	mov    (%eax),%eax
  10f73d:	89 45 08             	mov    %eax,0x8(%ebp)
  10f740:	8b 45 08             	mov    0x8(%ebp),%eax
  10f743:	0f b7 50 08          	movzwl 0x8(%eax),%edx
  10f747:	8b 45 08             	mov    0x8(%ebp),%eax
  10f74a:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  10f74e:	66 39 c2             	cmp    %ax,%dx
  10f751:	75 e5                	jne    10f738 <pbuf_dequeue+0x8>
  }
  /* remember next packet on queue */
  q = p->next;
  10f753:	8b 45 08             	mov    0x8(%ebp),%eax
  10f756:	8b 00                	mov    (%eax),%eax
  10f758:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  /* dequeue p from queue */
  p->next = NULL;
  10f75b:	8b 45 08             	mov    0x8(%ebp),%eax
  10f75e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  /* q is now referenced to one less time */
  pbuf_free(q);
  10f764:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10f767:	89 04 24             	mov    %eax,(%esp)
  10f76a:	e8 51 fd ff ff       	call   10f4c0 <pbuf_free>
  LWIP_DEBUGF(PBUF_DEBUG | DBG_FRESH | 2, ("pbuf_dequeue: dereferencing remaining queue %p\n", (void *)q));
  return q;
  10f76f:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
}
  10f772:	c9                   	leave  
  10f773:	c3                   	ret    
  10f774:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  10f77a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

0010f780 <pbuf_take>:
#endif

/**
 *
 * Create PBUF_POOL (or PBUF_RAM) copies of PBUF_REF pbufs.
 *
 * Used to queue packets on behalf of the lwIP stack, such as
 * ARP based queueing.
 *
 * Go through a pbuf chain and replace any PBUF_REF buffers
 * with PBUF_POOL (or PBUF_RAM) pbufs, each taking a copy of
 * the referenced data.
 *
 * @note You MUST explicitly use p = pbuf_take(p);
 * The pbuf you give as argument, may have been replaced
 * by pbuf_take()!
 *
 * @note Any replaced pbufs will be freed through pbuf_free().
 * This may deallocate them if they become no longer referenced.
 *
 * @param p Head of pbuf chain to process
 *
 * @return Pointer to head of pbuf chain
 */
struct pbuf *
pbuf_take(struct pbuf *p)
{
  10f780:	55                   	push   %ebp
  10f781:	89 e5                	mov    %esp,%ebp
  10f783:	83 ec 28             	sub    $0x28,%esp
  struct pbuf *q , *prev, *head;
  LWIP_ASSERT("pbuf_take: p != NULL\n", p != NULL);
  LWIP_DEBUGF(PBUF_DEBUG | DBG_TRACE | 3, ("pbuf_take(%p)\n", (void*)p));

  prev = NULL;
  10f786:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)
  head = p;
  10f78d:	8b 45 08             	mov    0x8(%ebp),%eax
  10f790:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  /* iterate through pbuf chain */
  do
  {
    /* pbuf is of type PBUF_REF? */
    if (p->flags == PBUF_FLAG_REF) {
  10f793:	8b 45 08             	mov    0x8(%ebp),%eax
  10f796:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  10f79a:	66 83 f8 04          	cmp    $0x4,%ax
  10f79e:	0f 85 fe 00 00 00    	jne    10f8a2 <pbuf_take+0x122>
      LWIP_DEBUGF(PBUF_DEBUG | DBG_TRACE, ("pbuf_take: encountered PBUF_REF %p\n", (void *)p));
      /* allocate a pbuf (w/ payload) fully in RAM */
      /* PBUF_POOL buffers are faster if we can use them */
      if (p->len <= PBUF_POOL_BUFSIZE) {
  10f7a4:	8b 45 08             	mov    0x8(%ebp),%eax
  10f7a7:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  10f7ab:	66 3d 80 00          	cmp    $0x80,%ax
  10f7af:	77 27                	ja     10f7d8 <pbuf_take+0x58>
        q = pbuf_alloc(PBUF_RAW, p->len, PBUF_POOL);
  10f7b1:	8b 45 08             	mov    0x8(%ebp),%eax
  10f7b4:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  10f7b8:	0f b7 c0             	movzwl %ax,%eax
  10f7bb:	c7 44 24 08 03 00 00 	movl   $0x3,0x8(%esp)
  10f7c2:	00 
  10f7c3:	89 44 24 04          	mov    %eax,0x4(%esp)
  10f7c7:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  10f7ce:	e8 0d f8 ff ff       	call   10efe0 <pbuf_alloc>
  10f7d3:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  10f7d6:	eb 07                	jmp    10f7df <pbuf_take+0x5f>
        if (q == NULL) LWIP_DEBUGF(PBUF_DEBUG | DBG_TRACE | 2, ("pbuf_take: Could not allocate PBUF_POOL\n"));
      } else {
        /* no replacement pbuf yet */
        q = NULL;
  10f7d8:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
        LWIP_DEBUGF(PBUF_DEBUG | DBG_TRACE | 2, ("pbuf_take: PBUF_POOL too small to replace PBUF_REF\n"));
      }
      /* no (large enough) PBUF_POOL was available? retry with PBUF_RAM */
      if (q == NULL) {
  10f7df:	83 7d f4 00          	cmpl   $0x0,0xfffffff4(%ebp)
  10f7e3:	75 25                	jne    10f80a <pbuf_take+0x8a>
        q = pbuf_alloc(PBUF_RAW, p->len, PBUF_RAM);
  10f7e5:	8b 45 08             	mov    0x8(%ebp),%eax
  10f7e8:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  10f7ec:	0f b7 c0             	movzwl %ax,%eax
  10f7ef:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  10f7f6:	00 
  10f7f7:	89 44 24 04          	mov    %eax,0x4(%esp)
  10f7fb:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  10f802:	e8 d9 f7 ff ff       	call   10efe0 <pbuf_alloc>
  10f807:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
        if (q == NULL) LWIP_DEBUGF(PBUF_DEBUG | DBG_TRACE | 2, ("pbuf_take: Could not allocate PBUF_RAM\n"));
      }
      /* replacement pbuf could be allocated? */
      if (q != NULL)
  10f80a:	83 7d f4 00          	cmpl   $0x0,0xfffffff4(%ebp)
  10f80e:	74 7e                	je     10f88e <pbuf_take+0x10e>
      {
        /* copy p to q */
        /* copy successor */
        q->next = p->next;
  10f810:	8b 45 08             	mov    0x8(%ebp),%eax
  10f813:	8b 10                	mov    (%eax),%edx
  10f815:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10f818:	89 10                	mov    %edx,(%eax)
        /* remove linkage from original pbuf */
        p->next = NULL;
  10f81a:	8b 45 08             	mov    0x8(%ebp),%eax
  10f81d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
        /* remove linkage to original pbuf */
        if (prev != NULL) {
  10f823:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  10f827:	74 0a                	je     10f833 <pbuf_take+0xb3>
          /* prev->next == p at this point */
          LWIP_ASSERT("prev->next == p", prev->next == p);
          /* break chain and insert new pbuf instead */
          prev->next = q;
  10f829:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  10f82c:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10f82f:	89 02                	mov    %eax,(%edx)
  10f831:	eb 06                	jmp    10f839 <pbuf_take+0xb9>
        /* prev == NULL, so we replaced the head pbuf of the chain */
        } else {
          head = q;
  10f833:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10f836:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
        }
        /* copy pbuf payload */
        memcpy(q->payload, p->payload, p->len);
  10f839:	8b 45 08             	mov    0x8(%ebp),%eax
  10f83c:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  10f840:	0f b7 d0             	movzwl %ax,%edx
  10f843:	8b 45 08             	mov    0x8(%ebp),%eax
  10f846:	8b 48 04             	mov    0x4(%eax),%ecx
  10f849:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10f84c:	8b 40 04             	mov    0x4(%eax),%eax
  10f84f:	89 54 24 08          	mov    %edx,0x8(%esp)
  10f853:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10f857:	89 04 24             	mov    %eax,(%esp)
  10f85a:	e8 31 66 ff ff       	call   105e90 <memcpy>
        q->tot_len = p->tot_len;
  10f85f:	8b 45 08             	mov    0x8(%ebp),%eax
  10f862:	0f b7 50 08          	movzwl 0x8(%eax),%edx
  10f866:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10f869:	66 89 50 08          	mov    %dx,0x8(%eax)
        q->len = p->len;
  10f86d:	8b 45 08             	mov    0x8(%ebp),%eax
  10f870:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
  10f874:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10f877:	66 89 50 0a          	mov    %dx,0xa(%eax)
        /* in case p was the first pbuf, it is no longer refered to by
         * our caller, as the caller MUST do p = pbuf_take(p);
         * in case p was not the first pbuf, it is no longer refered to
         * by prev. we can safely free the pbuf here.
         * (note that we have set p->next to NULL already so that
         * we will not free the rest of the chain by accident.)
         */
        pbuf_free(p);
  10f87b:	8b 45 08             	mov    0x8(%ebp),%eax
  10f87e:	89 04 24             	mov    %eax,(%esp)
  10f881:	e8 3a fc ff ff       	call   10f4c0 <pbuf_free>
        /* do not copy ref, since someone else might be using the old buffer */
        LWIP_DEBUGF(PBUF_DEBUG, ("pbuf_take: replaced PBUF_REF %p with %p\n", (void *)p, (void *)q));
        p = q;
  10f886:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10f889:	89 45 08             	mov    %eax,0x8(%ebp)
  10f88c:	eb 14                	jmp    10f8a2 <pbuf_take+0x122>
      } else {
        /* deallocate chain */
        pbuf_free(head);
  10f88e:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10f891:	89 04 24             	mov    %eax,(%esp)
  10f894:	e8 27 fc ff ff       	call   10f4c0 <pbuf_free>
        LWIP_DEBUGF(PBUF_DEBUG | 2, ("pbuf_take: failed to allocate replacement pbuf for %p\n", (void *)p));
        return NULL;
  10f899:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  10f8a0:	eb 1e                	jmp    10f8c0 <pbuf_take+0x140>
      }
    /* p->flags != PBUF_FLAG_REF */
    } else {
      LWIP_DEBUGF(PBUF_DEBUG | DBG_TRACE | 1, ("pbuf_take: skipping pbuf not of type PBUF_REF\n"));
    }
    /* remember this pbuf */
    prev = p;
  10f8a2:	8b 45 08             	mov    0x8(%ebp),%eax
  10f8a5:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
    /* proceed to next pbuf in original chain */
    p = p->next;
  10f8a8:	8b 45 08             	mov    0x8(%ebp),%eax
  10f8ab:	8b 00                	mov    (%eax),%eax
  10f8ad:	89 45 08             	mov    %eax,0x8(%ebp)
  } while (p);
  10f8b0:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  10f8b4:	0f 85 d9 fe ff ff    	jne    10f793 <pbuf_take+0x13>
  LWIP_DEBUGF(PBUF_DEBUG | DBG_TRACE | 1, ("pbuf_take: end of chain reached.\n"));

  return head;
  10f8ba:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10f8bd:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  10f8c0:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  10f8c3:	c9                   	leave  
  10f8c4:	c3                   	ret    
  10f8c5:	8d 74 26 00          	lea    0x0(%esi),%esi
  10f8c9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

0010f8d0 <pbuf_dechain>:

/**
 * Dechains the first pbuf from its succeeding pbufs in the chain.
 *
 * Makes p->tot_len field equal to p->len.
 * @param p pbuf to dechain
 * @return remainder of the pbuf chain, or NULL if it was de-allocated.
 * @note May not be called on a packet queue.
 */
struct pbuf *
pbuf_dechain(struct pbuf *p)
{
  10f8d0:	55                   	push   %ebp
  10f8d1:	89 e5                	mov    %esp,%ebp
  10f8d3:	83 ec 18             	sub    $0x18,%esp
  struct pbuf *q;
  u8_t tail_gone = 1;
  10f8d6:	c6 45 ff 01          	movb   $0x1,0xffffffff(%ebp)
  /* tail */
  q = p->next;
  10f8da:	8b 45 08             	mov    0x8(%ebp),%eax
  10f8dd:	8b 00                	mov    (%eax),%eax
  10f8df:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  /* pbuf has successor in chain? */
  if (q != NULL) {
  10f8e2:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  10f8e6:	74 3d                	je     10f925 <pbuf_dechain+0x55>
    /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
    LWIP_ASSERT("p->tot_len == p->len + q->tot_len", q->tot_len == p->tot_len - p->len);
    /* enforce invariant if assertion is disabled */
    q->tot_len = p->tot_len - p->len;
  10f8e8:	8b 45 08             	mov    0x8(%ebp),%eax
  10f8eb:	0f b7 50 08          	movzwl 0x8(%eax),%edx
  10f8ef:	8b 45 08             	mov    0x8(%ebp),%eax
  10f8f2:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  10f8f6:	66 29 c2             	sub    %ax,%dx
  10f8f9:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10f8fc:	66 89 50 08          	mov    %dx,0x8(%eax)
    /* decouple pbuf from remainder */
    p->next = NULL;
  10f900:	8b 45 08             	mov    0x8(%ebp),%eax
  10f903:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    /* total length of pbuf p is its own length only */
    p->tot_len = p->len;
  10f909:	8b 45 08             	mov    0x8(%ebp),%eax
  10f90c:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
  10f910:	8b 45 08             	mov    0x8(%ebp),%eax
  10f913:	66 89 50 08          	mov    %dx,0x8(%eax)
    /* q is no longer referenced by p, free it */
    LWIP_DEBUGF(PBUF_DEBUG | DBG_STATE, ("pbuf_dechain: unreferencing %p\n", (void *)q));
    tail_gone = pbuf_free(q);
  10f917:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10f91a:	89 04 24             	mov    %eax,(%esp)
  10f91d:	e8 9e fb ff ff       	call   10f4c0 <pbuf_free>
  10f922:	88 45 ff             	mov    %al,0xffffffff(%ebp)
    if (tail_gone > 0) LWIP_DEBUGF(PBUF_DEBUG | DBG_STATE,
      ("pbuf_dechain: deallocated %p (as it is no longer referenced)\n", (void *)q));
    /* return remaining tail or NULL if deallocated */
  }
  /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
  LWIP_ASSERT("p->tot_len == p->len", p->tot_len == p->len);
  return (tail_gone > 0? NULL: q);
  10f925:	80 7d ff 00          	cmpb   $0x0,0xffffffff(%ebp)
  10f929:	75 08                	jne    10f933 <pbuf_dechain+0x63>
  10f92b:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10f92e:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  10f931:	eb 07                	jmp    10f93a <pbuf_dechain+0x6a>
  10f933:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  10f93a:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  10f93d:	c9                   	leave  
  10f93e:	c3                   	ret    
  10f93f:	90                   	nop    

0010f940 <raw_init>:


void
raw_init(void)
{
  10f940:	55                   	push   %ebp
  10f941:	89 e5                	mov    %esp,%ebp
  raw_pcbs = NULL;
  10f943:	c7 05 e8 98 13 00 00 	movl   $0x0,0x1398e8
  10f94a:	00 00 00 
}
  10f94d:	5d                   	pop    %ebp
  10f94e:	c3                   	ret    
  10f94f:	90                   	nop    

0010f950 <raw_input>:

/**
 * Determine if in incoming IP packet is covered by a RAW pcb and
 * and process it if possible
 *
 * Given an incoming IP datagram (as a chain of pbufs) this function
 * finds a corresponding RAW PCB and
 *
 * @param pbuf pbuf to be demultiplexed to a RAW PCB.
 * @param netif network interface on which the datagram was received.
 * @return 0 if packet is not eated (pbuf needs to be freed then)
 *         or 1 if the packet has been eaten (pbuf needs not to be freed
 *         then)
 *
 */
int
raw_input(struct pbuf *p, struct netif *inp)
{
  10f950:	55                   	push   %ebp
  10f951:	89 e5                	mov    %esp,%ebp
  10f953:	53                   	push   %ebx
  10f954:	83 ec 24             	sub    $0x24,%esp
  struct raw_pcb *pcb;
  struct ip_hdr *iphdr;
  int proto;
  int rc = 0;
  10f957:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)

  iphdr = p->payload;
  10f95e:	8b 45 08             	mov    0x8(%ebp),%eax
  10f961:	8b 40 04             	mov    0x4(%eax),%eax
  10f964:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
  proto = IPH_PROTO(iphdr);
  10f967:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10f96a:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  10f96e:	0f b7 c0             	movzwl %ax,%eax
  10f971:	89 04 24             	mov    %eax,(%esp)
  10f974:	e8 37 e9 ff ff       	call   10e2b0 <ntohs>
  10f979:	0f b7 c0             	movzwl %ax,%eax
  10f97c:	25 ff 00 00 00       	and    $0xff,%eax
  10f981:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)

  for(pcb = raw_pcbs; pcb != NULL; pcb = pcb->next) {
  10f984:	a1 e8 98 13 00       	mov    0x1398e8,%eax
  10f989:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  10f98c:	eb 6c                	jmp    10f9fa <raw_input+0xaa>
    if (pcb->protocol == proto) {
  10f98e:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10f991:	0f b7 40 10          	movzwl 0x10(%eax),%eax
  10f995:	0f b7 c0             	movzwl %ax,%eax
  10f998:	3b 45 f4             	cmp    0xfffffff4(%ebp),%eax
  10f99b:	75 54                	jne    10f9f1 <raw_input+0xa1>
      if (pcb->recv) {
  10f99d:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10f9a0:	8b 40 14             	mov    0x14(%eax),%eax
  10f9a3:	85 c0                	test   %eax,%eax
  10f9a5:	74 36                	je     10f9dd <raw_input+0x8d>
        if (!pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src)))
  10f9a7:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10f9aa:	8b 48 14             	mov    0x14(%eax),%ecx
  10f9ad:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
  10f9b0:	83 c2 0c             	add    $0xc,%edx
  10f9b3:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10f9b6:	8b 58 18             	mov    0x18(%eax),%ebx
  10f9b9:	89 54 24 0c          	mov    %edx,0xc(%esp)
  10f9bd:	8b 45 08             	mov    0x8(%ebp),%eax
  10f9c0:	89 44 24 08          	mov    %eax,0x8(%esp)
  10f9c4:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10f9c7:	89 44 24 04          	mov    %eax,0x4(%esp)
  10f9cb:	89 1c 24             	mov    %ebx,(%esp)
  10f9ce:	ff d1                	call   *%ecx
  10f9d0:	85 c0                	test   %eax,%eax
  10f9d2:	75 09                	jne    10f9dd <raw_input+0x8d>
          return 0;
  10f9d4:	c7 45 e8 00 00 00 00 	movl   $0x0,0xffffffe8(%ebp)
  10f9db:	eb 29                	jmp    10fa06 <raw_input+0xb6>
      }
      pbuf_free(p);
  10f9dd:	8b 45 08             	mov    0x8(%ebp),%eax
  10f9e0:	89 04 24             	mov    %eax,(%esp)
  10f9e3:	e8 d8 fa ff ff       	call   10f4c0 <pbuf_free>
      rc = 1;
  10f9e8:	c7 45 f8 01 00 00 00 	movl   $0x1,0xfffffff8(%ebp)
      break;
  10f9ef:	eb 0f                	jmp    10fa00 <raw_input+0xb0>
  10f9f1:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10f9f4:	8b 40 0c             	mov    0xc(%eax),%eax
  10f9f7:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  10f9fa:	83 7d ec 00          	cmpl   $0x0,0xffffffec(%ebp)
  10f9fe:	75 8e                	jne    10f98e <raw_input+0x3e>
    }
  }
  return rc;
  10fa00:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10fa03:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
  10fa06:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
}
  10fa09:	83 c4 24             	add    $0x24,%esp
  10fa0c:	5b                   	pop    %ebx
  10fa0d:	5d                   	pop    %ebp
  10fa0e:	c3                   	ret    
  10fa0f:	90                   	nop    

0010fa10 <raw_bind>:

/**
 * Bind a RAW PCB.
 *
 * @param pcb RAW PCB to be bound with a local address ipaddr.
 * @param ipaddr local IP address to bind with. Use IP_ADDR_ANY to
 * bind to all local interfaces.
 *
 * @return lwIP error code.
 * - ERR_OK. Successful. No error occured.
 * - ERR_USE. The specified ipaddr is already bound to by
 * another RAW PCB.
 *
 * @see raw_disconnect()
 */
err_t
raw_bind(struct raw_pcb *pcb, struct ip_addr *ipaddr)
{
  10fa10:	55                   	push   %ebp
  10fa11:	89 e5                	mov    %esp,%ebp
  10fa13:	83 ec 04             	sub    $0x4,%esp
  ip_addr_set(&pcb->local_ip, ipaddr);
  10fa16:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  10fa1a:	74 0a                	je     10fa26 <raw_bind+0x16>
  10fa1c:	8b 45 0c             	mov    0xc(%ebp),%eax
  10fa1f:	8b 00                	mov    (%eax),%eax
  10fa21:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  10fa24:	eb 07                	jmp    10fa2d <raw_bind+0x1d>
  10fa26:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
  10fa2d:	8b 45 08             	mov    0x8(%ebp),%eax
  10fa30:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  10fa33:	89 10                	mov    %edx,(%eax)
  return ERR_OK;
  10fa35:	b8 00 00 00 00       	mov    $0x0,%eax
}
  10fa3a:	c9                   	leave  
  10fa3b:	c3                   	ret    
  10fa3c:	8d 74 26 00          	lea    0x0(%esi),%esi

0010fa40 <raw_connect>:

/**
 * Connect an RAW PCB. This function is required by upper layers
 * of lwip. Using the raw api you could use raw_send_to() instead
 *
 * This will associate the RAW PCB with the remote address.
 *
 * @param pcb RAW PCB to be connected with remote address ipaddr and port.
 * @param ipaddr remote IP address to connect with.
 *
 * @return lwIP error code
 *
 * @see raw_disconnect() and raw_send_to()
 */
err_t
raw_connect(struct raw_pcb *pcb, struct ip_addr *ipaddr)
{
  10fa40:	55                   	push   %ebp
  10fa41:	89 e5                	mov    %esp,%ebp
  10fa43:	83 ec 04             	sub    $0x4,%esp
  ip_addr_set(&pcb->remote_ip, ipaddr);
  10fa46:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  10fa4a:	74 0a                	je     10fa56 <raw_connect+0x16>
  10fa4c:	8b 45 0c             	mov    0xc(%ebp),%eax
  10fa4f:	8b 00                	mov    (%eax),%eax
  10fa51:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  10fa54:	eb 07                	jmp    10fa5d <raw_connect+0x1d>
  10fa56:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
  10fa5d:	8b 45 08             	mov    0x8(%ebp),%eax
  10fa60:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  10fa63:	89 50 04             	mov    %edx,0x4(%eax)
  return ERR_OK;
  10fa66:	b8 00 00 00 00       	mov    $0x0,%eax
}
  10fa6b:	c9                   	leave  
  10fa6c:	c3                   	ret    
  10fa6d:	8d 76 00             	lea    0x0(%esi),%esi

0010fa70 <raw_recv>:


/**
 * Set the callback function if a RAW packet with the pcb's protocol
 * is received. If the callback function returns a value unequal 0
 * the raw packet is "eaten" and not forwarded to any other raw pcb
 * including lwip itself
 */
void
raw_recv(struct raw_pcb *pcb,
         int (* recv)(void *arg, struct raw_pcb *upcb, struct pbuf *p,
                      struct ip_addr *addr),
         void *recv_arg)
{
  10fa70:	55                   	push   %ebp
  10fa71:	89 e5                	mov    %esp,%ebp
  /* remember recv() callback and user data */
  pcb->recv = recv;
  10fa73:	8b 55 08             	mov    0x8(%ebp),%edx
  10fa76:	8b 45 0c             	mov    0xc(%ebp),%eax
  10fa79:	89 42 14             	mov    %eax,0x14(%edx)
  pcb->recv_arg = recv_arg;
  10fa7c:	8b 55 08             	mov    0x8(%ebp),%edx
  10fa7f:	8b 45 10             	mov    0x10(%ebp),%eax
  10fa82:	89 42 18             	mov    %eax,0x18(%edx)
}
  10fa85:	5d                   	pop    %ebp
  10fa86:	c3                   	ret    
  10fa87:	89 f6                	mov    %esi,%esi
  10fa89:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

0010fa90 <raw_send_to>:

/**
 * Send the raw IP packet to the given address. Note that actually you cannot
 * modify the IP headers (this is inconsitent with the receive callback where
 * you actually get the IP headers), you can only specifiy the ip payload here.
 * It requires some more changes in LWIP. (there will be a raw_send() function
 * then)
 *
 * @param pcb the raw pcb which to send
 * @param p the ip payload to send
 * @param ipaddr the destination address of the whole IP packet
 *
 */
err_t
raw_send_to(struct raw_pcb *pcb, struct pbuf *p, struct ip_addr *ipaddr)
{
  10fa90:	55                   	push   %ebp
  10fa91:	89 e5                	mov    %esp,%ebp
  10fa93:	53                   	push   %ebx
  10fa94:	83 ec 34             	sub    $0x34,%esp
  err_t err;
  struct netif *netif;
  struct ip_addr *src_ip;
  struct pbuf *q; /* q will be sent down the stack */
  
  LWIP_DEBUGF(RAW_DEBUG | DBG_TRACE | 3, ("raw_send_to\n"));
  
  /* not enough space to add an IP header to first pbuf in given p chain? */
  if (pbuf_header(p, IP_HLEN)) {
  10fa97:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  10fa9e:	00 
  10fa9f:	8b 45 0c             	mov    0xc(%ebp),%eax
  10faa2:	89 04 24             	mov    %eax,(%esp)
  10faa5:	e8 16 f9 ff ff       	call   10f3c0 <pbuf_header>
  10faaa:	84 c0                	test   %al,%al
  10faac:	74 45                	je     10faf3 <raw_send_to+0x63>
    /* allocate header in new pbuf */
    q = pbuf_alloc(PBUF_IP, 0, PBUF_RAM);
  10faae:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  10fab5:	00 
  10fab6:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  10fabd:	00 
  10fabe:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  10fac5:	e8 16 f5 ff ff       	call   10efe0 <pbuf_alloc>
  10faca:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
  10facd:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  10fad1:	75 0c                	jne    10fadf <raw_send_to+0x4f>
      LWIP_DEBUGF(RAW_DEBUG | DBG_TRACE | 2, ("raw_send_to: could not allocate header\n"));
      return ERR_MEM;
  10fad3:	c7 45 e8 ff ff ff ff 	movl   $0xffffffff,0xffffffe8(%ebp)
  10fada:	e9 e8 00 00 00       	jmp    10fbc7 <raw_send_to+0x137>
    }
    /* chain header q in front of given pbuf p */
    pbuf_chain(q, p);
  10fadf:	8b 45 0c             	mov    0xc(%ebp),%eax
  10fae2:	89 44 24 04          	mov    %eax,0x4(%esp)
  10fae6:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10fae9:	89 04 24             	mov    %eax,(%esp)
  10faec:	e8 cf fb ff ff       	call   10f6c0 <pbuf_chain>
  10faf1:	eb 19                	jmp    10fb0c <raw_send_to+0x7c>
    /* { first pbuf q points to header pbuf } */
    LWIP_DEBUGF(RAW_DEBUG, ("raw_send_to: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
  }  else {
    /* first pbuf q equals given pbuf */
    q = p;
  10faf3:	8b 45 0c             	mov    0xc(%ebp),%eax
  10faf6:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
    pbuf_header(q, -IP_HLEN);
  10faf9:	c7 44 24 04 ec ff ff 	movl   $0xffffffec,0x4(%esp)
  10fb00:	ff 
  10fb01:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10fb04:	89 04 24             	mov    %eax,(%esp)
  10fb07:	e8 b4 f8 ff ff       	call   10f3c0 <pbuf_header>
  }
  
  if ((netif = ip_route(ipaddr)) == NULL) {
  10fb0c:	8b 45 10             	mov    0x10(%ebp),%eax
  10fb0f:	89 04 24             	mov    %eax,(%esp)
  10fb12:	e8 e9 cf ff ff       	call   10cb00 <ip_route>
  10fb17:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
  10fb1a:	83 7d f0 00          	cmpl   $0x0,0xfffffff0(%ebp)
  10fb1e:	75 1f                	jne    10fb3f <raw_send_to+0xaf>
    LWIP_DEBUGF(RAW_DEBUG | 1, ("raw_send_to: No route to 0x%lx\n", ipaddr->addr));
#if RAW_STATS
    /*    ++lwip_stats.raw.rterr;*/
#endif /* RAW_STATS */
    if (q != p) {
  10fb20:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10fb23:	3b 45 0c             	cmp    0xc(%ebp),%eax
  10fb26:	74 0b                	je     10fb33 <raw_send_to+0xa3>
      pbuf_free(q);
  10fb28:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10fb2b:	89 04 24             	mov    %eax,(%esp)
  10fb2e:	e8 8d f9 ff ff       	call   10f4c0 <pbuf_free>
    }
    return ERR_RTE;
  10fb33:	c7 45 e8 f7 ff ff ff 	movl   $0xfffffff7,0xffffffe8(%ebp)
  10fb3a:	e9 88 00 00 00       	jmp    10fbc7 <raw_send_to+0x137>
  }

  if (ip_addr_isany(&pcb->local_ip)) {
  10fb3f:	8b 45 08             	mov    0x8(%ebp),%eax
  10fb42:	85 c0                	test   %eax,%eax
  10fb44:	74 09                	je     10fb4f <raw_send_to+0xbf>
  10fb46:	8b 45 08             	mov    0x8(%ebp),%eax
  10fb49:	8b 00                	mov    (%eax),%eax
  10fb4b:	85 c0                	test   %eax,%eax
  10fb4d:	75 0b                	jne    10fb5a <raw_send_to+0xca>
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
  10fb4f:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10fb52:	83 c0 04             	add    $0x4,%eax
  10fb55:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  10fb58:	eb 06                	jmp    10fb60 <raw_send_to+0xd0>
  } else {
    /* use RAW PCB local IP address as source address */
    src_ip = &(pcb->local_ip);
  10fb5a:	8b 45 08             	mov    0x8(%ebp),%eax
  10fb5d:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  }

  err = ip_output_if (q, src_ip, ipaddr, pcb->ttl, pcb->tos, pcb->protocol, netif);
  10fb60:	8b 45 08             	mov    0x8(%ebp),%eax
  10fb63:	0f b7 40 10          	movzwl 0x10(%eax),%eax
  10fb67:	0f b6 c8             	movzbl %al,%ecx
  10fb6a:	8b 45 08             	mov    0x8(%ebp),%eax
  10fb6d:	0f b6 40 0a          	movzbl 0xa(%eax),%eax
  10fb71:	0f b6 d8             	movzbl %al,%ebx
  10fb74:	8b 45 08             	mov    0x8(%ebp),%eax
  10fb77:	0f b6 40 0b          	movzbl 0xb(%eax),%eax
  10fb7b:	0f b6 d0             	movzbl %al,%edx
  10fb7e:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10fb81:	89 44 24 18          	mov    %eax,0x18(%esp)
  10fb85:	89 4c 24 14          	mov    %ecx,0x14(%esp)
  10fb89:	89 5c 24 10          	mov    %ebx,0x10(%esp)
  10fb8d:	89 54 24 0c          	mov    %edx,0xc(%esp)
  10fb91:	8b 45 10             	mov    0x10(%ebp),%eax
  10fb94:	89 44 24 08          	mov    %eax,0x8(%esp)
  10fb98:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10fb9b:	89 44 24 04          	mov    %eax,0x4(%esp)
  10fb9f:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10fba2:	89 04 24             	mov    %eax,(%esp)
  10fba5:	e8 c6 d3 ff ff       	call   10cf70 <ip_output_if>
  10fbaa:	88 45 ef             	mov    %al,0xffffffef(%ebp)

  /* did we chain a header earlier? */
  if (q != p) {
  10fbad:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10fbb0:	3b 45 0c             	cmp    0xc(%ebp),%eax
  10fbb3:	74 0b                	je     10fbc0 <raw_send_to+0x130>
    /* free the header */
    pbuf_free(q);
  10fbb5:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10fbb8:	89 04 24             	mov    %eax,(%esp)
  10fbbb:	e8 00 f9 ff ff       	call   10f4c0 <pbuf_free>
  }
  return err;
  10fbc0:	0f be 45 ef          	movsbl 0xffffffef(%ebp),%eax
  10fbc4:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
  10fbc7:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
}
  10fbca:	83 c4 34             	add    $0x34,%esp
  10fbcd:	5b                   	pop    %ebx
  10fbce:	5d                   	pop    %ebp
  10fbcf:	c3                   	ret    

0010fbd0 <raw_send>:

/**
 * Send the raw IP packet to the address given by raw_connect()
 *
 * @param pcb the raw pcb which to send
 * @param p the ip payload to send
 * @param ipaddr the destination address of the whole IP packet
 *
 */
err_t
raw_send(struct raw_pcb *pcb, struct pbuf *p)
{
  10fbd0:	55                   	push   %ebp
  10fbd1:	89 e5                	mov    %esp,%ebp
  10fbd3:	83 ec 18             	sub    $0x18,%esp
  return raw_send_to(pcb,p,&pcb->remote_ip);
  10fbd6:	8b 45 08             	mov    0x8(%ebp),%eax
  10fbd9:	83 c0 04             	add    $0x4,%eax
  10fbdc:	89 44 24 08          	mov    %eax,0x8(%esp)
  10fbe0:	8b 45 0c             	mov    0xc(%ebp),%eax
  10fbe3:	89 44 24 04          	mov    %eax,0x4(%esp)
  10fbe7:	8b 45 08             	mov    0x8(%ebp),%eax
  10fbea:	89 04 24             	mov    %eax,(%esp)
  10fbed:	e8 9e fe ff ff       	call   10fa90 <raw_send_to>
  10fbf2:	0f be c0             	movsbl %al,%eax
}
  10fbf5:	c9                   	leave  
  10fbf6:	c3                   	ret    
  10fbf7:	89 f6                	mov    %esi,%esi
  10fbf9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

0010fc00 <raw_remove>:

/**
 * Remove an RAW PCB.
 *
 * @param pcb RAW PCB to be removed. The PCB is removed from the list of
 * RAW PCB's and the data structure is freed from memory.
 *
 * @see raw_new()
 */
void
raw_remove(struct raw_pcb *pcb)
{
  10fc00:	55                   	push   %ebp
  10fc01:	89 e5                	mov    %esp,%ebp
  10fc03:	83 ec 18             	sub    $0x18,%esp
  struct raw_pcb *pcb2;
  /* pcb to be removed is first in list? */
  if (raw_pcbs == pcb) {
  10fc06:	a1 e8 98 13 00       	mov    0x1398e8,%eax
  10fc0b:	3b 45 08             	cmp    0x8(%ebp),%eax
  10fc0e:	75 0f                	jne    10fc1f <raw_remove+0x1f>
    /* make list start at 2nd pcb */
    raw_pcbs = raw_pcbs->next;
  10fc10:	a1 e8 98 13 00       	mov    0x1398e8,%eax
  10fc15:	8b 40 0c             	mov    0xc(%eax),%eax
  10fc18:	a3 e8 98 13 00       	mov    %eax,0x1398e8
  10fc1d:	eb 3a                	jmp    10fc59 <raw_remove+0x59>
  /* pcb not 1st in list */
  } else for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  10fc1f:	a1 e8 98 13 00       	mov    0x1398e8,%eax
  10fc24:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  10fc27:	eb 2a                	jmp    10fc53 <raw_remove+0x53>
    /* find pcb in raw_pcbs list */
    if (pcb2->next != NULL && pcb2->next == pcb) {
  10fc29:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10fc2c:	8b 40 0c             	mov    0xc(%eax),%eax
  10fc2f:	85 c0                	test   %eax,%eax
  10fc31:	74 17                	je     10fc4a <raw_remove+0x4a>
  10fc33:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10fc36:	8b 40 0c             	mov    0xc(%eax),%eax
  10fc39:	3b 45 08             	cmp    0x8(%ebp),%eax
  10fc3c:	75 0c                	jne    10fc4a <raw_remove+0x4a>
      /* remove pcb from list */
      pcb2->next = pcb->next;
  10fc3e:	8b 45 08             	mov    0x8(%ebp),%eax
  10fc41:	8b 50 0c             	mov    0xc(%eax),%edx
  10fc44:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10fc47:	89 50 0c             	mov    %edx,0xc(%eax)
  10fc4a:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10fc4d:	8b 40 0c             	mov    0xc(%eax),%eax
  10fc50:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  10fc53:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  10fc57:	75 d0                	jne    10fc29 <raw_remove+0x29>
    }
  }
  memp_free(MEMP_RAW_PCB, pcb);
  10fc59:	8b 45 08             	mov    0x8(%ebp),%eax
  10fc5c:	89 44 24 04          	mov    %eax,0x4(%esp)
  10fc60:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  10fc67:	e8 54 ee ff ff       	call   10eac0 <memp_free>
}
  10fc6c:	c9                   	leave  
  10fc6d:	c3                   	ret    
  10fc6e:	89 f6                	mov    %esi,%esi

0010fc70 <raw_new>:

/**
 * Create a RAW PCB.
 *
 * @return The RAW PCB which was created. NULL if the PCB data structure
 * could not be allocated.
 *
 * @param proto the protocol number of the IPs payload (e.g. IP_PROTO_ICMP)
 *
 * @see raw_remove()
 */
struct raw_pcb *
raw_new(u16_t proto) {
  10fc70:	55                   	push   %ebp
  10fc71:	89 e5                	mov    %esp,%ebp
  10fc73:	83 ec 28             	sub    $0x28,%esp
  10fc76:	8b 45 08             	mov    0x8(%ebp),%eax
  10fc79:	66 89 45 ec          	mov    %ax,0xffffffec(%ebp)
  struct raw_pcb *pcb;

  LWIP_DEBUGF(RAW_DEBUG | DBG_TRACE | 3, ("raw_new\n"));

  pcb = memp_malloc(MEMP_RAW_PCB);
  10fc7d:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  10fc84:	e8 47 ed ff ff       	call   10e9d0 <memp_malloc>
  10fc89:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  /* could allocate RAW PCB? */
  if (pcb != NULL) {
  10fc8c:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  10fc90:	74 41                	je     10fcd3 <raw_new+0x63>
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct raw_pcb));
  10fc92:	c7 44 24 08 1c 00 00 	movl   $0x1c,0x8(%esp)
  10fc99:	00 
  10fc9a:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  10fca1:	00 
  10fca2:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10fca5:	89 04 24             	mov    %eax,(%esp)
  10fca8:	e8 23 62 ff ff       	call   105ed0 <memset>
    pcb->protocol = proto;
  10fcad:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  10fcb0:	0f b7 45 ec          	movzwl 0xffffffec(%ebp),%eax
  10fcb4:	66 89 42 10          	mov    %ax,0x10(%edx)
    pcb->ttl = RAW_TTL;
  10fcb8:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10fcbb:	c6 40 0b ff          	movb   $0xff,0xb(%eax)
    pcb->next = raw_pcbs;
  10fcbf:	8b 15 e8 98 13 00    	mov    0x1398e8,%edx
  10fcc5:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10fcc8:	89 50 0c             	mov    %edx,0xc(%eax)
    raw_pcbs = pcb;
  10fccb:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10fcce:	a3 e8 98 13 00       	mov    %eax,0x1398e8
  }

  return pcb;
  10fcd3:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
}
  10fcd6:	c9                   	leave  
  10fcd7:	c3                   	ret    
  10fcd8:	90                   	nop    
  10fcd9:	90                   	nop    
  10fcda:	90                   	nop    
  10fcdb:	90                   	nop    
  10fcdc:	90                   	nop    
  10fcdd:	90                   	nop    
  10fcde:	90                   	nop    
  10fcdf:	90                   	nop    

0010fce0 <stats_init>:
struct stats_ lwip_stats;

void
stats_init(void)
{
  10fce0:	55                   	push   %ebp
  10fce1:	89 e5                	mov    %esp,%ebp
  10fce3:	83 ec 18             	sub    $0x18,%esp
  memset(&lwip_stats, 0, sizeof(struct stats_));
  10fce6:	c7 44 24 08 74 01 00 	movl   $0x174,0x8(%esp)
  10fced:	00 
  10fcee:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  10fcf5:	00 
  10fcf6:	c7 04 24 e0 14 14 00 	movl   $0x1414e0,(%esp)
  10fcfd:	e8 ce 61 ff ff       	call   105ed0 <memset>
}
  10fd02:	c9                   	leave  
  10fd03:	c3                   	ret    
  10fd04:	90                   	nop    
  10fd05:	90                   	nop    
  10fd06:	90                   	nop    
  10fd07:	90                   	nop    
  10fd08:	90                   	nop    
  10fd09:	90                   	nop    
  10fd0a:	90                   	nop    
  10fd0b:	90                   	nop    
  10fd0c:	90                   	nop    
  10fd0d:	90                   	nop    
  10fd0e:	90                   	nop    
  10fd0f:	90                   	nop    

0010fd10 <sys_mbox_fetch>:


void
sys_mbox_fetch(sys_mbox_t mbox, void **msg)
{
  10fd10:	55                   	push   %ebp
  10fd11:	89 e5                	mov    %esp,%ebp
  10fd13:	83 ec 38             	sub    $0x38,%esp
  u32_t time;
  struct sys_timeouts *timeouts;
  struct sys_timeout *tmptimeout;
  sys_timeout_handler h;
  void *arg;


 again:
  timeouts = sys_arch_timeouts();
  10fd16:	e8 65 a4 00 00       	call   11a180 <sys_arch_timeouts>
  10fd1b:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)

  if (!timeouts || !timeouts->next) {
  10fd1e:	83 7d f0 00          	cmpl   $0x0,0xfffffff0(%ebp)
  10fd22:	74 09                	je     10fd2d <sys_mbox_fetch+0x1d>
  10fd24:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10fd27:	8b 00                	mov    (%eax),%eax
  10fd29:	85 c0                	test   %eax,%eax
  10fd2b:	75 1f                	jne    10fd4c <sys_mbox_fetch+0x3c>
    sys_arch_mbox_fetch(mbox, msg, 0);
  10fd2d:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  10fd34:	00 
  10fd35:	8b 45 0c             	mov    0xc(%ebp),%eax
  10fd38:	89 44 24 04          	mov    %eax,0x4(%esp)
  10fd3c:	8b 45 08             	mov    0x8(%ebp),%eax
  10fd3f:	89 04 24             	mov    %eax,(%esp)
  10fd42:	e8 f9 a2 00 00       	call   11a040 <sys_arch_mbox_fetch>
  10fd47:	e9 bb 00 00 00       	jmp    10fe07 <sys_mbox_fetch+0xf7>
  } else {
    if (timeouts->next->time > 0) {
  10fd4c:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10fd4f:	8b 00                	mov    (%eax),%eax
  10fd51:	8b 40 04             	mov    0x4(%eax),%eax
  10fd54:	85 c0                	test   %eax,%eax
  10fd56:	74 23                	je     10fd7b <sys_mbox_fetch+0x6b>
      time = sys_arch_mbox_fetch(mbox, msg, timeouts->next->time);
  10fd58:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10fd5b:	8b 00                	mov    (%eax),%eax
  10fd5d:	8b 40 04             	mov    0x4(%eax),%eax
  10fd60:	89 44 24 08          	mov    %eax,0x8(%esp)
  10fd64:	8b 45 0c             	mov    0xc(%ebp),%eax
  10fd67:	89 44 24 04          	mov    %eax,0x4(%esp)
  10fd6b:	8b 45 08             	mov    0x8(%ebp),%eax
  10fd6e:	89 04 24             	mov    %eax,(%esp)
  10fd71:	e8 ca a2 00 00       	call   11a040 <sys_arch_mbox_fetch>
  10fd76:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  10fd79:	eb 07                	jmp    10fd82 <sys_mbox_fetch+0x72>
    } else {
      time = SYS_ARCH_TIMEOUT;
  10fd7b:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
    }

    if (time == SYS_ARCH_TIMEOUT) {
  10fd82:	83 7d ec ff          	cmpl   $0xffffffff,0xffffffec(%ebp)
  10fd86:	75 51                	jne    10fdd9 <sys_mbox_fetch+0xc9>
      /* If time == SYS_ARCH_TIMEOUT, a timeout occured before a message
   could be fetched. We should now call the timeout handler and
   deallocate the memory allocated for the timeout. */
      tmptimeout = timeouts->next;
  10fd88:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10fd8b:	8b 00                	mov    (%eax),%eax
  10fd8d:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
      timeouts->next = tmptimeout->next;
  10fd90:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10fd93:	8b 10                	mov    (%eax),%edx
  10fd95:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10fd98:	89 10                	mov    %edx,(%eax)
      h = tmptimeout->h;
  10fd9a:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10fd9d:	8b 40 08             	mov    0x8(%eax),%eax
  10fda0:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
      arg = tmptimeout->arg;
  10fda3:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10fda6:	8b 40 0c             	mov    0xc(%eax),%eax
  10fda9:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
      memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
  10fdac:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10fdaf:	89 44 24 04          	mov    %eax,0x4(%esp)
  10fdb3:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
  10fdba:	e8 01 ed ff ff       	call   10eac0 <memp_free>
      if (h != NULL) {
  10fdbf:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  10fdc3:	0f 84 4d ff ff ff    	je     10fd16 <sys_mbox_fetch+0x6>
        LWIP_DEBUGF(SYS_DEBUG, ("smf calling h=%p(%p)\n", (void *)h, (void *)arg));
      	h(arg);
  10fdc9:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10fdcc:	89 04 24             	mov    %eax,(%esp)
  10fdcf:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10fdd2:	ff d0                	call   *%eax
      }

      /* We try again to fetch a message from the mbox. */
      goto again;
  10fdd4:	e9 3d ff ff ff       	jmp    10fd16 <sys_mbox_fetch+0x6>
    } else {
      /* If time != SYS_ARCH_TIMEOUT, a message was received before the timeout
   occured. The time variable is set to the number of
   milliseconds we waited for the message. */
      if (time <= timeouts->next->time) {
  10fdd9:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10fddc:	8b 00                	mov    (%eax),%eax
  10fdde:	8b 40 04             	mov    0x4(%eax),%eax
  10fde1:	3b 45 ec             	cmp    0xffffffec(%ebp),%eax
  10fde4:	72 15                	jb     10fdfb <sys_mbox_fetch+0xeb>
  timeouts->next->time -= time;
  10fde6:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10fde9:	8b 10                	mov    (%eax),%edx
  10fdeb:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10fdee:	8b 00                	mov    (%eax),%eax
  10fdf0:	8b 40 04             	mov    0x4(%eax),%eax
  10fdf3:	2b 45 ec             	sub    0xffffffec(%ebp),%eax
  10fdf6:	89 42 04             	mov    %eax,0x4(%edx)
  10fdf9:	eb 0c                	jmp    10fe07 <sys_mbox_fetch+0xf7>
      } else {
  timeouts->next->time = 0;
  10fdfb:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10fdfe:	8b 00                	mov    (%eax),%eax
  10fe00:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
      }
    }

  }
}
  10fe07:	c9                   	leave  
  10fe08:	c3                   	ret    
  10fe09:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

0010fe10 <sys_sem_wait>:

void
sys_sem_wait(sys_sem_t sem)
{
  10fe10:	55                   	push   %ebp
  10fe11:	89 e5                	mov    %esp,%ebp
  10fe13:	83 ec 28             	sub    $0x28,%esp
  u32_t time;
  struct sys_timeouts *timeouts;
  struct sys_timeout *tmptimeout;
  sys_timeout_handler h;
  void *arg;

  /*  while (sys_arch_sem_wait(sem, 1000) == 0);
      return;*/

 again:

  timeouts = sys_arch_timeouts();
  10fe16:	e8 65 a3 00 00       	call   11a180 <sys_arch_timeouts>
  10fe1b:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)

  if (!timeouts || !timeouts->next) {
  10fe1e:	83 7d f0 00          	cmpl   $0x0,0xfffffff0(%ebp)
  10fe22:	74 09                	je     10fe2d <sys_sem_wait+0x1d>
  10fe24:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10fe27:	8b 00                	mov    (%eax),%eax
  10fe29:	85 c0                	test   %eax,%eax
  10fe2b:	75 18                	jne    10fe45 <sys_sem_wait+0x35>
    sys_arch_sem_wait(sem, 0);
  10fe2d:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  10fe34:	00 
  10fe35:	8b 45 08             	mov    0x8(%ebp),%eax
  10fe38:	89 04 24             	mov    %eax,(%esp)
  10fe3b:	e8 b0 9f 00 00       	call   119df0 <sys_arch_sem_wait>
  10fe40:	e9 b4 00 00 00       	jmp    10fef9 <sys_sem_wait+0xe9>
  } else {
    if (timeouts->next->time > 0) {
  10fe45:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10fe48:	8b 00                	mov    (%eax),%eax
  10fe4a:	8b 40 04             	mov    0x4(%eax),%eax
  10fe4d:	85 c0                	test   %eax,%eax
  10fe4f:	74 1c                	je     10fe6d <sys_sem_wait+0x5d>
      time = sys_arch_sem_wait(sem, timeouts->next->time);
  10fe51:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10fe54:	8b 00                	mov    (%eax),%eax
  10fe56:	8b 40 04             	mov    0x4(%eax),%eax
  10fe59:	89 44 24 04          	mov    %eax,0x4(%esp)
  10fe5d:	8b 45 08             	mov    0x8(%ebp),%eax
  10fe60:	89 04 24             	mov    %eax,(%esp)
  10fe63:	e8 88 9f 00 00       	call   119df0 <sys_arch_sem_wait>
  10fe68:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  10fe6b:	eb 07                	jmp    10fe74 <sys_sem_wait+0x64>
    } else {
      time = SYS_ARCH_TIMEOUT;
  10fe6d:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
    }

    if (time == SYS_ARCH_TIMEOUT) {
  10fe74:	83 7d ec ff          	cmpl   $0xffffffff,0xffffffec(%ebp)
  10fe78:	75 51                	jne    10fecb <sys_sem_wait+0xbb>
      /* If time == SYS_ARCH_TIMEOUT, a timeout occured before a message
   could be fetched. We should now call the timeout handler and
   deallocate the memory allocated for the timeout. */
      tmptimeout = timeouts->next;
  10fe7a:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10fe7d:	8b 00                	mov    (%eax),%eax
  10fe7f:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
      timeouts->next = tmptimeout->next;
  10fe82:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10fe85:	8b 10                	mov    (%eax),%edx
  10fe87:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10fe8a:	89 10                	mov    %edx,(%eax)
      h = tmptimeout->h;
  10fe8c:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10fe8f:	8b 40 08             	mov    0x8(%eax),%eax
  10fe92:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
      arg = tmptimeout->arg;
  10fe95:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10fe98:	8b 40 0c             	mov    0xc(%eax),%eax
  10fe9b:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
      memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
  10fe9e:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10fea1:	89 44 24 04          	mov    %eax,0x4(%esp)
  10fea5:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
  10feac:	e8 0f ec ff ff       	call   10eac0 <memp_free>
      if (h != NULL) {
  10feb1:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  10feb5:	0f 84 5b ff ff ff    	je     10fe16 <sys_sem_wait+0x6>
        LWIP_DEBUGF(SYS_DEBUG, ("ssw h=%p(%p)\n", (void *)h, (void *)arg));
        h(arg);
  10febb:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  10febe:	89 04 24             	mov    %eax,(%esp)
  10fec1:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  10fec4:	ff d0                	call   *%eax
      }


      /* We try again to fetch a message from the mbox. */
      goto again;
  10fec6:	e9 4b ff ff ff       	jmp    10fe16 <sys_sem_wait+0x6>
    } else {
      /* If time != SYS_ARCH_TIMEOUT, a message was received before the timeout
   occured. The time variable is set to the number of
   milliseconds we waited for the message. */
      if (time <= timeouts->next->time) {
  10fecb:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10fece:	8b 00                	mov    (%eax),%eax
  10fed0:	8b 40 04             	mov    0x4(%eax),%eax
  10fed3:	3b 45 ec             	cmp    0xffffffec(%ebp),%eax
  10fed6:	72 15                	jb     10feed <sys_sem_wait+0xdd>
  timeouts->next->time -= time;
  10fed8:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10fedb:	8b 10                	mov    (%eax),%edx
  10fedd:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10fee0:	8b 00                	mov    (%eax),%eax
  10fee2:	8b 40 04             	mov    0x4(%eax),%eax
  10fee5:	2b 45 ec             	sub    0xffffffec(%ebp),%eax
  10fee8:	89 42 04             	mov    %eax,0x4(%edx)
  10feeb:	eb 0c                	jmp    10fef9 <sys_sem_wait+0xe9>
      } else {
  timeouts->next->time = 0;
  10feed:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10fef0:	8b 00                	mov    (%eax),%eax
  10fef2:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
      }
    }

  }
}
  10fef9:	c9                   	leave  
  10fefa:	c3                   	ret    
  10fefb:	90                   	nop    
  10fefc:	8d 74 26 00          	lea    0x0(%esi),%esi

0010ff00 <sys_timeout>:

void
sys_timeout(u32_t msecs, sys_timeout_handler h, void *arg)
{
  10ff00:	55                   	push   %ebp
  10ff01:	89 e5                	mov    %esp,%ebp
  10ff03:	53                   	push   %ebx
  10ff04:	83 ec 14             	sub    $0x14,%esp
  struct sys_timeouts *timeouts;
  struct sys_timeout *timeout, *t;
  sys_timeout_handler y = h;
  10ff07:	8b 45 0c             	mov    0xc(%ebp),%eax
  10ff0a:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)

  timeout = memp_malloc(MEMP_SYS_TIMEOUT);
  10ff0d:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
  10ff14:	e8 b7 ea ff ff       	call   10e9d0 <memp_malloc>
  10ff19:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
  if (timeout == NULL) {
  10ff1c:	83 7d f0 00          	cmpl   $0x0,0xfffffff0(%ebp)
  10ff20:	0f 84 f9 00 00 00    	je     11001f <sys_timeout+0x11f>
    return;
  }
  timeout->next = NULL;
  10ff26:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10ff29:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  timeout->h = h;
  10ff2f:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
  10ff32:	8b 45 0c             	mov    0xc(%ebp),%eax
  10ff35:	89 42 08             	mov    %eax,0x8(%edx)
  timeout->arg = arg;
  10ff38:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
  10ff3b:	8b 45 10             	mov    0x10(%ebp),%eax
  10ff3e:	89 42 0c             	mov    %eax,0xc(%edx)
  timeout->time = msecs;
  10ff41:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
  10ff44:	8b 45 08             	mov    0x8(%ebp),%eax
  10ff47:	89 42 04             	mov    %eax,0x4(%edx)

  timeouts = sys_arch_timeouts();
  10ff4a:	e8 31 a2 00 00       	call   11a180 <sys_arch_timeouts>
  10ff4f:	89 45 ec             	mov    %eax,0xffffffec(%ebp)

  LWIP_DEBUGF(SYS_DEBUG, ("sys_timeout: %p msecs=%lu h=%p arg=%p\n",
    (void *)timeout, msecs, (void *)h, (void *)arg));

  LWIP_ASSERT("sys_timeout: timeouts != NULL", timeouts != NULL);

  if (timeouts->next == NULL) {
  10ff52:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10ff55:	8b 00                	mov    (%eax),%eax
  10ff57:	85 c0                	test   %eax,%eax
  10ff59:	75 0d                	jne    10ff68 <sys_timeout+0x68>
    timeouts->next = timeout;
  10ff5b:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
  10ff5e:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10ff61:	89 02                	mov    %eax,(%edx)
    return;
  10ff63:	e9 b7 00 00 00       	jmp    11001f <sys_timeout+0x11f>
  }

  if (timeouts->next->time > msecs) {
  10ff68:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10ff6b:	8b 00                	mov    (%eax),%eax
  10ff6d:	8b 40 04             	mov    0x4(%eax),%eax
  10ff70:	3b 45 08             	cmp    0x8(%ebp),%eax
  10ff73:	76 2a                	jbe    10ff9f <sys_timeout+0x9f>
    timeouts->next->time -= msecs;
  10ff75:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10ff78:	8b 10                	mov    (%eax),%edx
  10ff7a:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10ff7d:	8b 00                	mov    (%eax),%eax
  10ff7f:	8b 40 04             	mov    0x4(%eax),%eax
  10ff82:	2b 45 08             	sub    0x8(%ebp),%eax
  10ff85:	89 42 04             	mov    %eax,0x4(%edx)
    timeout->next = timeouts->next;
  10ff88:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10ff8b:	8b 10                	mov    (%eax),%edx
  10ff8d:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10ff90:	89 10                	mov    %edx,(%eax)
    timeouts->next = timeout;
  10ff92:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
  10ff95:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10ff98:	89 02                	mov    %eax,(%edx)
  10ff9a:	e9 80 00 00 00       	jmp    11001f <sys_timeout+0x11f>
  } else {
    for(t = timeouts->next; t != NULL; t = t->next) {
  10ff9f:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  10ffa2:	8b 00                	mov    (%eax),%eax
  10ffa4:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  10ffa7:	eb 70                	jmp    110019 <sys_timeout+0x119>
      timeout->time -= t->time;
  10ffa9:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10ffac:	8b 50 04             	mov    0x4(%eax),%edx
  10ffaf:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10ffb2:	8b 40 04             	mov    0x4(%eax),%eax
  10ffb5:	29 c2                	sub    %eax,%edx
  10ffb7:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10ffba:	89 50 04             	mov    %edx,0x4(%eax)
      if (t->next == NULL || t->next->time > timeout->time) {
  10ffbd:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10ffc0:	8b 00                	mov    (%eax),%eax
  10ffc2:	85 c0                	test   %eax,%eax
  10ffc4:	74 12                	je     10ffd8 <sys_timeout+0xd8>
  10ffc6:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10ffc9:	8b 00                	mov    (%eax),%eax
  10ffcb:	8b 50 04             	mov    0x4(%eax),%edx
  10ffce:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10ffd1:	8b 40 04             	mov    0x4(%eax),%eax
  10ffd4:	39 c2                	cmp    %eax,%edx
  10ffd6:	76 39                	jbe    110011 <sys_timeout+0x111>
        if (t->next != NULL) {
  10ffd8:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10ffdb:	8b 00                	mov    (%eax),%eax
  10ffdd:	85 c0                	test   %eax,%eax
  10ffdf:	74 1c                	je     10fffd <sys_timeout+0xfd>
          t->next->time -= timeout->time;
  10ffe1:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10ffe4:	8b 08                	mov    (%eax),%ecx
  10ffe6:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  10ffe9:	8b 00                	mov    (%eax),%eax
  10ffeb:	8b 50 04             	mov    0x4(%eax),%edx
  10ffee:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  10fff1:	8b 40 04             	mov    0x4(%eax),%eax
  10fff4:	89 d3                	mov    %edx,%ebx
  10fff6:	29 c3                	sub    %eax,%ebx
  10fff8:	89 d8                	mov    %ebx,%eax
  10fffa:	89 41 04             	mov    %eax,0x4(%ecx)
        }
        timeout->next = t->next;
  10fffd:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  110000:	8b 10                	mov    (%eax),%edx
  110002:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  110005:	89 10                	mov    %edx,(%eax)
        t->next = timeout;
  110007:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
  11000a:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  11000d:	89 02                	mov    %eax,(%edx)
        break;
  11000f:	eb 0e                	jmp    11001f <sys_timeout+0x11f>
  110011:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  110014:	8b 00                	mov    (%eax),%eax
  110016:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  110019:	83 7d f4 00          	cmpl   $0x0,0xfffffff4(%ebp)
  11001d:	75 8a                	jne    10ffa9 <sys_timeout+0xa9>
      }
    }
  }

}
  11001f:	83 c4 14             	add    $0x14,%esp
  110022:	5b                   	pop    %ebx
  110023:	5d                   	pop    %ebp
  110024:	c3                   	ret    
  110025:	8d 74 26 00          	lea    0x0(%esi),%esi
  110029:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00110030 <sys_untimeout>:

/* Go through timeout list (for this task only) and remove the first matching entry,
   even though the timeout has not triggered yet.
*/

void
sys_untimeout(sys_timeout_handler h, void *arg)
{
  110030:	55                   	push   %ebp
  110031:	89 e5                	mov    %esp,%ebp
  110033:	83 ec 18             	sub    $0x18,%esp
    struct sys_timeouts *timeouts;
    struct sys_timeout *prev_t, *t;

    timeouts = sys_arch_timeouts();
  110036:	e8 45 a1 00 00       	call   11a180 <sys_arch_timeouts>
  11003b:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)

    if (timeouts->next == NULL)
  11003e:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  110041:	8b 00                	mov    (%eax),%eax
  110043:	85 c0                	test   %eax,%eax
  110045:	0f 84 8e 00 00 00    	je     1100d9 <sys_untimeout+0xa9>
        return;

    for (t = timeouts->next, prev_t = NULL; t != NULL; prev_t = t, t = t->next)
  11004b:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  11004e:	8b 00                	mov    (%eax),%eax
  110050:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  110053:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)
  11005a:	eb 77                	jmp    1100d3 <sys_untimeout+0xa3>
    {
        if ((t->h == h) && (t->arg == arg))
  11005c:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  11005f:	8b 40 08             	mov    0x8(%eax),%eax
  110062:	3b 45 08             	cmp    0x8(%ebp),%eax
  110065:	75 5e                	jne    1100c5 <sys_untimeout+0x95>
  110067:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  11006a:	8b 40 0c             	mov    0xc(%eax),%eax
  11006d:	3b 45 0c             	cmp    0xc(%ebp),%eax
  110070:	75 53                	jne    1100c5 <sys_untimeout+0x95>
        {
            /* We have a match */
            /* Unlink from previous in list */
            if (prev_t == NULL)
  110072:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  110076:	75 0c                	jne    110084 <sys_untimeout+0x54>
                timeouts->next = t->next;
  110078:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  11007b:	8b 10                	mov    (%eax),%edx
  11007d:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  110080:	89 10                	mov    %edx,(%eax)
  110082:	eb 0a                	jmp    11008e <sys_untimeout+0x5e>
            else
                prev_t->next = t->next;
  110084:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  110087:	8b 10                	mov    (%eax),%edx
  110089:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  11008c:	89 10                	mov    %edx,(%eax)
            /* If not the last one, add time of this one back to next */
            if (t->next != NULL)
  11008e:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  110091:	8b 00                	mov    (%eax),%eax
  110093:	85 c0                	test   %eax,%eax
  110095:	74 19                	je     1100b0 <sys_untimeout+0x80>
                t->next->time += t->time;
  110097:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  11009a:	8b 08                	mov    (%eax),%ecx
  11009c:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  11009f:	8b 00                	mov    (%eax),%eax
  1100a1:	8b 50 04             	mov    0x4(%eax),%edx
  1100a4:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1100a7:	8b 40 04             	mov    0x4(%eax),%eax
  1100aa:	8d 04 02             	lea    (%edx,%eax,1),%eax
  1100ad:	89 41 04             	mov    %eax,0x4(%ecx)
            memp_free(MEMP_SYS_TIMEOUT, t);
  1100b0:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1100b3:	89 44 24 04          	mov    %eax,0x4(%esp)
  1100b7:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
  1100be:	e8 fd e9 ff ff       	call   10eac0 <memp_free>
            return;
  1100c3:	eb 14                	jmp    1100d9 <sys_untimeout+0xa9>
  1100c5:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1100c8:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  1100cb:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1100ce:	8b 00                	mov    (%eax),%eax
  1100d0:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  1100d3:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  1100d7:	75 83                	jne    11005c <sys_untimeout+0x2c>
        }
    }
    return;
}
  1100d9:	c9                   	leave  
  1100da:	c3                   	ret    
  1100db:	90                   	nop    
  1100dc:	8d 74 26 00          	lea    0x0(%esi),%esi

001100e0 <sswt_handler>:





static void
sswt_handler(void *arg)
{
  1100e0:	55                   	push   %ebp
  1100e1:	89 e5                	mov    %esp,%ebp
  1100e3:	83 ec 18             	sub    $0x18,%esp
    struct sswt_cb *sswt_cb = (struct sswt_cb *) arg;
  1100e6:	8b 45 08             	mov    0x8(%ebp),%eax
  1100e9:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)

    /* Timeout. Set flag to TRUE and signal semaphore */
    sswt_cb->timeflag = 1;
  1100ec:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1100ef:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    sys_sem_signal(*(sswt_cb->psem));
  1100f5:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1100f8:	8b 40 04             	mov    0x4(%eax),%eax
  1100fb:	8b 00                	mov    (%eax),%eax
  1100fd:	89 04 24             	mov    %eax,(%esp)
  110100:	e8 cb 9c 00 00       	call   119dd0 <sys_sem_signal>
}
  110105:	c9                   	leave  
  110106:	c3                   	ret    
  110107:	89 f6                	mov    %esi,%esi
  110109:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00110110 <sys_sem_wait_timeout>:

/* Wait for a semaphore with timeout (specified in ms) */
/* timeout = 0: wait forever */
/* Returns 0 on timeout. 1 otherwise */

int
sys_sem_wait_timeout(sys_sem_t sem, u32_t timeout)
{
  110110:	55                   	push   %ebp
  110111:	89 e5                	mov    %esp,%ebp
  110113:	83 ec 28             	sub    $0x28,%esp
    struct sswt_cb sswt_cb;

    sswt_cb.psem = &sem;
  110116:	8d 45 08             	lea    0x8(%ebp),%eax
  110119:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
    sswt_cb.timeflag = 0;
  11011c:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)

    /* If timeout is zero, then just wait forever */
    if (timeout > 0)
  110123:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  110127:	74 1a                	je     110143 <sys_sem_wait_timeout+0x33>
        /* Create a timer and pass it the address of our flag */
        sys_timeout(timeout, sswt_handler, &sswt_cb);
  110129:	8d 45 f8             	lea    0xfffffff8(%ebp),%eax
  11012c:	89 44 24 08          	mov    %eax,0x8(%esp)
  110130:	c7 44 24 04 e0 00 11 	movl   $0x1100e0,0x4(%esp)
  110137:	00 
  110138:	8b 45 0c             	mov    0xc(%ebp),%eax
  11013b:	89 04 24             	mov    %eax,(%esp)
  11013e:	e8 bd fd ff ff       	call   10ff00 <sys_timeout>
    sys_sem_wait(sem);
  110143:	8b 45 08             	mov    0x8(%ebp),%eax
  110146:	89 04 24             	mov    %eax,(%esp)
  110149:	e8 c2 fc ff ff       	call   10fe10 <sys_sem_wait>
    /* Was it a timeout? */
    if (sswt_cb.timeflag)
  11014e:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  110151:	85 c0                	test   %eax,%eax
  110153:	74 09                	je     11015e <sys_sem_wait_timeout+0x4e>
    {
        /* timeout */
        return 0;
  110155:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  11015c:	eb 1a                	jmp    110178 <sys_sem_wait_timeout+0x68>
    } else {
        /* Not a timeout. Remove timeout entry */
        sys_untimeout(sswt_handler, &sswt_cb);
  11015e:	8d 45 f8             	lea    0xfffffff8(%ebp),%eax
  110161:	89 44 24 04          	mov    %eax,0x4(%esp)
  110165:	c7 04 24 e0 00 11 00 	movl   $0x1100e0,(%esp)
  11016c:	e8 bf fe ff ff       	call   110030 <sys_untimeout>
        return 1;
  110171:	c7 45 ec 01 00 00 00 	movl   $0x1,0xffffffec(%ebp)
  110178:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    }

}
  11017b:	c9                   	leave  
  11017c:	c3                   	ret    
  11017d:	8d 76 00             	lea    0x0(%esi),%esi

00110180 <sys_msleep>:


void
sys_msleep(u32_t ms)
{
  110180:	55                   	push   %ebp
  110181:	89 e5                	mov    %esp,%ebp
  110183:	83 ec 18             	sub    $0x18,%esp
  sys_sem_t delaysem = sys_sem_new(0);
  110186:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  11018d:	e8 be 9b 00 00       	call   119d50 <sys_sem_new>
  110192:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)

  sys_sem_wait_timeout(delaysem, ms);
  110195:	8b 45 08             	mov    0x8(%ebp),%eax
  110198:	89 44 24 04          	mov    %eax,0x4(%esp)
  11019c:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  11019f:	89 04 24             	mov    %eax,(%esp)
  1101a2:	e8 69 ff ff ff       	call   110110 <sys_sem_wait_timeout>

  sys_sem_free(delaysem);
  1101a7:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1101aa:	89 04 24             	mov    %eax,(%esp)
  1101ad:	e8 ee 9b 00 00       	call   119da0 <sys_sem_free>
}
  1101b2:	c9                   	leave  
  1101b3:	c3                   	ret    
  1101b4:	90                   	nop    
  1101b5:	90                   	nop    
  1101b6:	90                   	nop    
  1101b7:	90                   	nop    
  1101b8:	90                   	nop    
  1101b9:	90                   	nop    
  1101ba:	90                   	nop    
  1101bb:	90                   	nop    
  1101bc:	90                   	nop    
  1101bd:	90                   	nop    
  1101be:	90                   	nop    
  1101bf:	90                   	nop    

001101c0 <tcp_init>:
 */

void
tcp_init(void)
{
  1101c0:	55                   	push   %ebp
  1101c1:	89 e5                	mov    %esp,%ebp
  /* Clear globals. */
  tcp_listen_pcbs.listen_pcbs = NULL;
  1101c3:	c7 05 5c 16 14 00 00 	movl   $0x0,0x14165c
  1101ca:	00 00 00 
  tcp_active_pcbs = NULL;
  1101cd:	c7 05 54 16 14 00 00 	movl   $0x0,0x141654
  1101d4:	00 00 00 
  tcp_tw_pcbs = NULL;
  1101d7:	c7 05 64 16 14 00 00 	movl   $0x0,0x141664
  1101de:	00 00 00 
  tcp_tmp_pcb = NULL;
  1101e1:	c7 05 60 16 14 00 00 	movl   $0x0,0x141660
  1101e8:	00 00 00 
  
  /* initialize timer */
  tcp_ticks = 0;
  1101eb:	c7 05 58 16 14 00 00 	movl   $0x0,0x141658
  1101f2:	00 00 00 
  tcp_timer = 0;
  1101f5:	c6 05 ec 98 13 00 00 	movb   $0x0,0x1398ec
  
}
  1101fc:	5d                   	pop    %ebp
  1101fd:	c3                   	ret    
  1101fe:	89 f6                	mov    %esi,%esi

00110200 <tcp_tmr>:

/*
 * tcp_tmr():
 *
 * Called periodically to dispatch TCP timers.
 *
 */

void
tcp_tmr(void)
{
  110200:	55                   	push   %ebp
  110201:	89 e5                	mov    %esp,%ebp
  110203:	83 ec 08             	sub    $0x8,%esp
  /* Call tcp_fasttmr() every 250 ms */
  tcp_fasttmr();
  110206:	e8 65 0e 00 00       	call   111070 <tcp_fasttmr>

  if (++tcp_timer & 1) {
  11020b:	0f b6 05 ec 98 13 00 	movzbl 0x1398ec,%eax
  110212:	83 c0 01             	add    $0x1,%eax
  110215:	a2 ec 98 13 00       	mov    %al,0x1398ec
  11021a:	0f b6 05 ec 98 13 00 	movzbl 0x1398ec,%eax
  110221:	0f b6 c0             	movzbl %al,%eax
  110224:	83 e0 01             	and    $0x1,%eax
  110227:	84 c0                	test   %al,%al
  110229:	74 05                	je     110230 <tcp_tmr+0x30>
    /* Call tcp_tmr() every 500 ms, i.e., every other timer
       tcp_tmr() is called. */
    tcp_slowtmr();
  11022b:	e8 e0 09 00 00       	call   110c10 <tcp_slowtmr>
  }
}
  110230:	c9                   	leave  
  110231:	c3                   	ret    
  110232:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi
  110239:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00110240 <tcp_close>:

/*
 * tcp_close():
 *
 * Closes the connection held by the PCB.
 *
 */

err_t
tcp_close(struct tcp_pcb *pcb)
{
  110240:	55                   	push   %ebp
  110241:	89 e5                	mov    %esp,%ebp
  110243:	83 ec 28             	sub    $0x28,%esp
  err_t err;

#if TCP_DEBUG
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_close: closing in state "));
  tcp_debug_print_state(pcb->state);
  LWIP_DEBUGF(TCP_DEBUG, ("\n"));
#endif /* TCP_DEBUG */
  switch (pcb->state) {
  110246:	8b 45 08             	mov    0x8(%ebp),%eax
  110249:	8b 40 10             	mov    0x10(%eax),%eax
  11024c:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  11024f:	83 7d ec 07          	cmpl   $0x7,0xffffffec(%ebp)
  110253:	0f 87 c5 00 00 00    	ja     11031e <tcp_close+0xde>
  110259:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
  11025c:	8b 04 95 c8 ae 11 00 	mov    0x11aec8(,%edx,4),%eax
  110263:	ff e0                	jmp    *%eax
  case LISTEN:
    err = ERR_OK;
  110265:	c6 45 ff 00          	movb   $0x0,0xffffffff(%ebp)
    tcp_pcb_remove((struct tcp_pcb **)&tcp_listen_pcbs.pcbs, pcb);
  110269:	8b 45 08             	mov    0x8(%ebp),%eax
  11026c:	89 44 24 04          	mov    %eax,0x4(%esp)
  110270:	c7 04 24 5c 16 14 00 	movl   $0x14165c,(%esp)
  110277:	e8 74 13 00 00       	call   1115f0 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB_LISTEN, pcb);
  11027c:	8b 45 08             	mov    0x8(%ebp),%eax
  11027f:	89 44 24 04          	mov    %eax,0x4(%esp)
  110283:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  11028a:	e8 31 e8 ff ff       	call   10eac0 <memp_free>
    pcb = NULL;
  11028f:	c7 45 08 00 00 00 00 	movl   $0x0,0x8(%ebp)
    break;
  110296:	e9 8e 00 00 00       	jmp    110329 <tcp_close+0xe9>
  case SYN_SENT:
    err = ERR_OK;
  11029b:	c6 45 ff 00          	movb   $0x0,0xffffffff(%ebp)
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
  11029f:	8b 45 08             	mov    0x8(%ebp),%eax
  1102a2:	89 44 24 04          	mov    %eax,0x4(%esp)
  1102a6:	c7 04 24 54 16 14 00 	movl   $0x141654,(%esp)
  1102ad:	e8 3e 13 00 00       	call   1115f0 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB, pcb);
  1102b2:	8b 45 08             	mov    0x8(%ebp),%eax
  1102b5:	89 44 24 04          	mov    %eax,0x4(%esp)
  1102b9:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  1102c0:	e8 fb e7 ff ff       	call   10eac0 <memp_free>
    pcb = NULL;
  1102c5:	c7 45 08 00 00 00 00 	movl   $0x0,0x8(%ebp)
    break;
  1102cc:	eb 5b                	jmp    110329 <tcp_close+0xe9>
  case SYN_RCVD:
  case ESTABLISHED:
    err = tcp_send_ctrl(pcb, TCP_FIN);
  1102ce:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  1102d5:	00 
  1102d6:	8b 45 08             	mov    0x8(%ebp),%eax
  1102d9:	89 04 24             	mov    %eax,(%esp)
  1102dc:	e8 ff 13 00 00       	call   1116e0 <tcp_send_ctrl>
  1102e1:	88 45 ff             	mov    %al,0xffffffff(%ebp)
    if (err == ERR_OK) {
  1102e4:	80 7d ff 00          	cmpb   $0x0,0xffffffff(%ebp)
  1102e8:	75 3f                	jne    110329 <tcp_close+0xe9>
      pcb->state = FIN_WAIT_1;
  1102ea:	8b 45 08             	mov    0x8(%ebp),%eax
  1102ed:	c7 40 10 05 00 00 00 	movl   $0x5,0x10(%eax)
    }
    break;
  1102f4:	eb 33                	jmp    110329 <tcp_close+0xe9>
  case CLOSE_WAIT:
    err = tcp_send_ctrl(pcb, TCP_FIN);
  1102f6:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  1102fd:	00 
  1102fe:	8b 45 08             	mov    0x8(%ebp),%eax
  110301:	89 04 24             	mov    %eax,(%esp)
  110304:	e8 d7 13 00 00       	call   1116e0 <tcp_send_ctrl>
  110309:	88 45 ff             	mov    %al,0xffffffff(%ebp)
    if (err == ERR_OK) {
  11030c:	80 7d ff 00          	cmpb   $0x0,0xffffffff(%ebp)
  110310:	75 17                	jne    110329 <tcp_close+0xe9>
      pcb->state = LAST_ACK;
  110312:	8b 45 08             	mov    0x8(%ebp),%eax
  110315:	c7 40 10 09 00 00 00 	movl   $0x9,0x10(%eax)
    }
    break;
  11031c:	eb 0b                	jmp    110329 <tcp_close+0xe9>
  default:
    /* Has already been closed, do nothing. */
    err = ERR_OK;
  11031e:	c6 45 ff 00          	movb   $0x0,0xffffffff(%ebp)
    pcb = NULL;
  110322:	c7 45 08 00 00 00 00 	movl   $0x0,0x8(%ebp)
    break;
  }

  if (pcb != NULL && err == ERR_OK) {
  110329:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  11032d:	74 14                	je     110343 <tcp_close+0x103>
  11032f:	80 7d ff 00          	cmpb   $0x0,0xffffffff(%ebp)
  110333:	75 0e                	jne    110343 <tcp_close+0x103>
    err = tcp_output(pcb);
  110335:	8b 45 08             	mov    0x8(%ebp),%eax
  110338:	89 04 24             	mov    %eax,(%esp)
  11033b:	e8 10 1b 00 00       	call   111e50 <tcp_output>
  110340:	88 45 ff             	mov    %al,0xffffffff(%ebp)
  }
  return err;
  110343:	0f be 45 ff          	movsbl 0xffffffff(%ebp),%eax
}
  110347:	c9                   	leave  
  110348:	c3                   	ret    
  110349:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

00110350 <tcp_abort>:

/*
 * tcp_abort()
 *
 * Aborts a connection by sending a RST to the remote host and deletes
 * the local protocol control block. This is done when a connection is
 * killed because of shortage of memory.
 *
 */

void
tcp_abort(struct tcp_pcb *pcb)
{
  110350:	55                   	push   %ebp
  110351:	89 e5                	mov    %esp,%ebp
  110353:	83 ec 48             	sub    $0x48,%esp
  u32_t seqno, ackno;
  u16_t remote_port, local_port;
  struct ip_addr remote_ip, local_ip;
#if LWIP_CALLBACK_API  
  void (* errf)(void *arg, err_t err);
#endif /* LWIP_CALLBACK_API */
  void *errf_arg;

  
  /* Figure out on which TCP PCB list we are, and remove us. If we
     are in an active state, call the receive function associated with
     the PCB with a NULL argument, and send an RST to the remote end. */
  if (pcb->state == TIME_WAIT) {
  110356:	8b 45 08             	mov    0x8(%ebp),%eax
  110359:	8b 40 10             	mov    0x10(%eax),%eax
  11035c:	83 f8 0a             	cmp    $0xa,%eax
  11035f:	75 2b                	jne    11038c <tcp_abort+0x3c>
    tcp_pcb_remove(&tcp_tw_pcbs, pcb);
  110361:	8b 45 08             	mov    0x8(%ebp),%eax
  110364:	89 44 24 04          	mov    %eax,0x4(%esp)
  110368:	c7 04 24 64 16 14 00 	movl   $0x141664,(%esp)
  11036f:	e8 7c 12 00 00       	call   1115f0 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB, pcb);
  110374:	8b 45 08             	mov    0x8(%ebp),%eax
  110377:	89 44 24 04          	mov    %eax,0x4(%esp)
  11037b:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  110382:	e8 39 e7 ff ff       	call   10eac0 <memp_free>
  110387:	e9 34 01 00 00       	jmp    1104c0 <tcp_abort+0x170>
  } else {
    seqno = pcb->snd_nxt;
  11038c:	8b 45 08             	mov    0x8(%ebp),%eax
  11038f:	8b 40 50             	mov    0x50(%eax),%eax
  110392:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
    ackno = pcb->rcv_nxt;
  110395:	8b 45 08             	mov    0x8(%ebp),%eax
  110398:	8b 40 24             	mov    0x24(%eax),%eax
  11039b:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
    ip_addr_set(&local_ip, &(pcb->local_ip));
  11039e:	8b 45 08             	mov    0x8(%ebp),%eax
  1103a1:	85 c0                	test   %eax,%eax
  1103a3:	74 0a                	je     1103af <tcp_abort+0x5f>
  1103a5:	8b 45 08             	mov    0x8(%ebp),%eax
  1103a8:	8b 00                	mov    (%eax),%eax
  1103aa:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
  1103ad:	eb 07                	jmp    1103b6 <tcp_abort+0x66>
  1103af:	c7 45 d8 00 00 00 00 	movl   $0x0,0xffffffd8(%ebp)
  1103b6:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  1103b9:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
    ip_addr_set(&remote_ip, &(pcb->remote_ip));
  1103bc:	8b 45 08             	mov    0x8(%ebp),%eax
  1103bf:	83 c0 04             	add    $0x4,%eax
  1103c2:	85 c0                	test   %eax,%eax
  1103c4:	74 0b                	je     1103d1 <tcp_abort+0x81>
  1103c6:	8b 45 08             	mov    0x8(%ebp),%eax
  1103c9:	8b 40 04             	mov    0x4(%eax),%eax
  1103cc:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
  1103cf:	eb 07                	jmp    1103d8 <tcp_abort+0x88>
  1103d1:	c7 45 dc 00 00 00 00 	movl   $0x0,0xffffffdc(%ebp)
  1103d8:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  1103db:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
    local_port = pcb->local_port;
  1103de:	8b 45 08             	mov    0x8(%ebp),%eax
  1103e1:	0f b7 40 1c          	movzwl 0x1c(%eax),%eax
  1103e5:	66 89 45 f6          	mov    %ax,0xfffffff6(%ebp)
    remote_port = pcb->remote_port;
  1103e9:	8b 45 08             	mov    0x8(%ebp),%eax
  1103ec:	0f b7 40 1e          	movzwl 0x1e(%eax),%eax
  1103f0:	66 89 45 f4          	mov    %ax,0xfffffff4(%ebp)
#if LWIP_CALLBACK_API
    errf = pcb->errf;
  1103f4:	8b 45 08             	mov    0x8(%ebp),%eax
  1103f7:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
  1103fd:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
#endif /* LWIP_CALLBACK_API */
    errf_arg = pcb->callback_arg;
  110400:	8b 45 08             	mov    0x8(%ebp),%eax
  110403:	8b 40 18             	mov    0x18(%eax),%eax
  110406:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
  110409:	8b 45 08             	mov    0x8(%ebp),%eax
  11040c:	89 44 24 04          	mov    %eax,0x4(%esp)
  110410:	c7 04 24 54 16 14 00 	movl   $0x141654,(%esp)
  110417:	e8 d4 11 00 00       	call   1115f0 <tcp_pcb_remove>
    if (pcb->unacked != NULL) {
  11041c:	8b 45 08             	mov    0x8(%ebp),%eax
  11041f:	8b 40 74             	mov    0x74(%eax),%eax
  110422:	85 c0                	test   %eax,%eax
  110424:	74 0e                	je     110434 <tcp_abort+0xe4>
      tcp_segs_free(pcb->unacked);
  110426:	8b 45 08             	mov    0x8(%ebp),%eax
  110429:	8b 40 74             	mov    0x74(%eax),%eax
  11042c:	89 04 24             	mov    %eax,(%esp)
  11042f:	e8 ac 0c 00 00       	call   1110e0 <tcp_segs_free>
    }
    if (pcb->unsent != NULL) {
  110434:	8b 45 08             	mov    0x8(%ebp),%eax
  110437:	8b 40 70             	mov    0x70(%eax),%eax
  11043a:	85 c0                	test   %eax,%eax
  11043c:	74 0e                	je     11044c <tcp_abort+0xfc>
      tcp_segs_free(pcb->unsent);
  11043e:	8b 45 08             	mov    0x8(%ebp),%eax
  110441:	8b 40 70             	mov    0x70(%eax),%eax
  110444:	89 04 24             	mov    %eax,(%esp)
  110447:	e8 94 0c 00 00       	call   1110e0 <tcp_segs_free>
    }
#if TCP_QUEUE_OOSEQ    
    if (pcb->ooseq != NULL) {
  11044c:	8b 45 08             	mov    0x8(%ebp),%eax
  11044f:	8b 40 78             	mov    0x78(%eax),%eax
  110452:	85 c0                	test   %eax,%eax
  110454:	74 0e                	je     110464 <tcp_abort+0x114>
      tcp_segs_free(pcb->ooseq);
  110456:	8b 45 08             	mov    0x8(%ebp),%eax
  110459:	8b 40 78             	mov    0x78(%eax),%eax
  11045c:	89 04 24             	mov    %eax,(%esp)
  11045f:	e8 7c 0c 00 00       	call   1110e0 <tcp_segs_free>
    }
#endif /* TCP_QUEUE_OOSEQ */
    memp_free(MEMP_TCP_PCB, pcb);
  110464:	8b 45 08             	mov    0x8(%ebp),%eax
  110467:	89 44 24 04          	mov    %eax,0x4(%esp)
  11046b:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  110472:	e8 49 e6 ff ff       	call   10eac0 <memp_free>
    TCP_EVENT_ERR(errf, errf_arg, ERR_ABRT);
  110477:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  11047b:	74 13                	je     110490 <tcp_abort+0x140>
  11047d:	c7 44 24 04 fd ff ff 	movl   $0xfffffffd,0x4(%esp)
  110484:	ff 
  110485:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  110488:	89 04 24             	mov    %eax,(%esp)
  11048b:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  11048e:	ff d0                	call   *%eax
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_abort: sending RST\n"));
    tcp_rst(seqno, ackno, &local_ip, &remote_ip, local_port, remote_port);
  110490:	0f b7 45 f4          	movzwl 0xfffffff4(%ebp),%eax
  110494:	0f b7 55 f6          	movzwl 0xfffffff6(%ebp),%edx
  110498:	89 44 24 14          	mov    %eax,0x14(%esp)
  11049c:	89 54 24 10          	mov    %edx,0x10(%esp)
  1104a0:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
  1104a3:	89 44 24 0c          	mov    %eax,0xc(%esp)
  1104a7:	8d 45 e4             	lea    0xffffffe4(%ebp),%eax
  1104aa:	89 44 24 08          	mov    %eax,0x8(%esp)
  1104ae:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  1104b1:	89 44 24 04          	mov    %eax,0x4(%esp)
  1104b5:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  1104b8:	89 04 24             	mov    %eax,(%esp)
  1104bb:	e8 10 20 00 00       	call   1124d0 <tcp_rst>
  }
}
  1104c0:	c9                   	leave  
  1104c1:	c3                   	ret    
  1104c2:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi
  1104c9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

001104d0 <tcp_bind>:

/*
 * tcp_bind():
 *
 * Binds the connection to a local portnumber and IP address. If the
 * IP address is not given (i.e., ipaddr == NULL), the IP address of
 * the outgoing network interface is used instead.
 *
 */

err_t
tcp_bind(struct tcp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  1104d0:	55                   	push   %ebp
  1104d1:	89 e5                	mov    %esp,%ebp
  1104d3:	83 ec 28             	sub    $0x28,%esp
  1104d6:	8b 45 10             	mov    0x10(%ebp),%eax
  1104d9:	66 89 45 ec          	mov    %ax,0xffffffec(%ebp)
  struct tcp_pcb *cpcb;
#if SO_REUSE
  int reuse_port_all_set = 1;
  1104dd:	c7 45 fc 01 00 00 00 	movl   $0x1,0xfffffffc(%ebp)
#endif /* SO_REUSE */

  if (port == 0) {
  1104e4:	66 83 7d ec 00       	cmpw   $0x0,0xffffffec(%ebp)
  1104e9:	75 09                	jne    1104f4 <tcp_bind+0x24>
    port = tcp_new_port();
  1104eb:	e8 d0 04 00 00       	call   1109c0 <tcp_new_port>
  1104f0:	66 89 45 ec          	mov    %ax,0xffffffec(%ebp)
  }
#if SO_REUSE == 0
  /* Check if the address already is in use. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_isany(&(cpcb->local_ip)) ||
        ip_addr_isany(ipaddr) ||
        ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
          return ERR_USE;
      }
    }
  }
  for(cpcb = tcp_active_pcbs;
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_isany(&(cpcb->local_ip)) ||
   ip_addr_isany(ipaddr) ||
   ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
  return ERR_USE;
      }
    }
  }
#else /* SO_REUSE */
  /* Search through list of PCB's in LISTEN state. 
     
  If there is a PCB bound to specified port and IP_ADDR_ANY another PCB can be bound to the interface IP
  or to the loopback address on the same port if SOF_REUSEADDR is set. Any combination of PCB's bound to 
  the same local port, but to one address out of {IP_ADDR_ANY, 127.0.0.1, interface IP} at a time is valid.
  But no two PCB's bound to same local port and same local address is valid.
  
  If SOF_REUSEPORT is set several PCB's can be bound to same local port and same local address also. But then 
  all PCB's must have the SOF_REUSEPORT option set.
  
  When the two options aren't set and specified port is already bound, ERR_USE is returned saying that 
  address is already in use. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; cpcb != NULL; cpcb = cpcb->next) {
  1104f4:	a1 5c 16 14 00       	mov    0x14165c,%eax
  1104f9:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  1104fc:	e9 e6 00 00 00       	jmp    1105e7 <tcp_bind+0x117>
    if(cpcb->local_port == port) {
  110501:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  110504:	0f b7 40 1c          	movzwl 0x1c(%eax),%eax
  110508:	66 3b 45 ec          	cmp    0xffffffec(%ebp),%ax
  11050c:	0f 85 cc 00 00 00    	jne    1105de <tcp_bind+0x10e>
      if(ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
  110512:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  110515:	8b 10                	mov    (%eax),%edx
  110517:	8b 45 0c             	mov    0xc(%ebp),%eax
  11051a:	8b 00                	mov    (%eax),%eax
  11051c:	39 c2                	cmp    %eax,%edx
  11051e:	75 50                	jne    110570 <tcp_bind+0xa0>
        if(pcb->so_options & SOF_REUSEPORT) {
  110520:	8b 45 08             	mov    0x8(%ebp),%eax
  110523:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  110527:	0f b7 c0             	movzwl %ax,%eax
  11052a:	25 00 02 00 00       	and    $0x200,%eax
  11052f:	85 c0                	test   %eax,%eax
  110531:	74 31                	je     110564 <tcp_bind+0x94>
          LWIP_DEBUGF(TCP_DEBUG, ("tcp_bind: in listening PCB's: SO_REUSEPORT set and same address.\n"));
          reuse_port_all_set = (reuse_port_all_set && (cpcb->so_options & SOF_REUSEPORT));
  110533:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  110537:	74 1c                	je     110555 <tcp_bind+0x85>
  110539:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  11053c:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  110540:	0f b7 c0             	movzwl %ax,%eax
  110543:	25 00 02 00 00       	and    $0x200,%eax
  110548:	85 c0                	test   %eax,%eax
  11054a:	74 09                	je     110555 <tcp_bind+0x85>
  11054c:	c7 45 dc 01 00 00 00 	movl   $0x1,0xffffffdc(%ebp)
  110553:	eb 07                	jmp    11055c <tcp_bind+0x8c>
  110555:	c7 45 dc 00 00 00 00 	movl   $0x0,0xffffffdc(%ebp)
  11055c:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  11055f:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  110562:	eb 7a                	jmp    1105de <tcp_bind+0x10e>
        }
        else {
          LWIP_DEBUGF(TCP_DEBUG, ("tcp_bind: in listening PCB's: SO_REUSEPORT not set and same address.\n"));
          return ERR_USE;
  110564:	c7 45 e0 f6 ff ff ff 	movl   $0xfffffff6,0xffffffe0(%ebp)
  11056b:	e9 69 02 00 00       	jmp    1107d9 <tcp_bind+0x309>
        }
      }
      else if((ip_addr_isany(ipaddr) && !ip_addr_isany(&(cpcb->local_ip))) ||
  110570:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  110574:	74 09                	je     11057f <tcp_bind+0xaf>
  110576:	8b 45 0c             	mov    0xc(%ebp),%eax
  110579:	8b 00                	mov    (%eax),%eax
  11057b:	85 c0                	test   %eax,%eax
  11057d:	75 10                	jne    11058f <tcp_bind+0xbf>
  11057f:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  110582:	85 c0                	test   %eax,%eax
  110584:	74 09                	je     11058f <tcp_bind+0xbf>
  110586:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  110589:	8b 00                	mov    (%eax),%eax
  11058b:	85 c0                	test   %eax,%eax
  11058d:	75 1f                	jne    1105ae <tcp_bind+0xde>
  11058f:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  110593:	74 49                	je     1105de <tcp_bind+0x10e>
  110595:	8b 45 0c             	mov    0xc(%ebp),%eax
  110598:	8b 00                	mov    (%eax),%eax
  11059a:	85 c0                	test   %eax,%eax
  11059c:	74 40                	je     1105de <tcp_bind+0x10e>
  11059e:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1105a1:	85 c0                	test   %eax,%eax
  1105a3:	74 09                	je     1105ae <tcp_bind+0xde>
  1105a5:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1105a8:	8b 00                	mov    (%eax),%eax
  1105aa:	85 c0                	test   %eax,%eax
  1105ac:	75 30                	jne    1105de <tcp_bind+0x10e>
              (!ip_addr_isany(ipaddr) && ip_addr_isany(&(cpcb->local_ip)))) {
        if(!(pcb->so_options & SOF_REUSEADDR) && !(pcb->so_options & SOF_REUSEPORT)) {
  1105ae:	8b 45 08             	mov    0x8(%ebp),%eax
  1105b1:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  1105b5:	0f b7 c0             	movzwl %ax,%eax
  1105b8:	83 e0 04             	and    $0x4,%eax
  1105bb:	85 c0                	test   %eax,%eax
  1105bd:	75 1f                	jne    1105de <tcp_bind+0x10e>
  1105bf:	8b 45 08             	mov    0x8(%ebp),%eax
  1105c2:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  1105c6:	0f b7 c0             	movzwl %ax,%eax
  1105c9:	25 00 02 00 00       	and    $0x200,%eax
  1105ce:	85 c0                	test   %eax,%eax
  1105d0:	75 0c                	jne    1105de <tcp_bind+0x10e>
          LWIP_DEBUGF(TCP_DEBUG, ("tcp_bind: in listening PCB's SO_REUSEPORT or SO_REUSEADDR not set and not the same address.\n"));
          return ERR_USE;
  1105d2:	c7 45 e0 f6 ff ff ff 	movl   $0xfffffff6,0xffffffe0(%ebp)
  1105d9:	e9 fb 01 00 00       	jmp    1107d9 <tcp_bind+0x309>
  1105de:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1105e1:	8b 40 0c             	mov    0xc(%eax),%eax
  1105e4:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  1105e7:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  1105eb:	0f 85 10 ff ff ff    	jne    110501 <tcp_bind+0x31>
        }      
        else {
          LWIP_DEBUGF(TCP_DEBUG, ("tcp_bind: in listening PCB's SO_REUSEPORT or SO_REUSEADDR set and not the same address.\n"));
        }     
      }
    }
  }

  /* Search through list of PCB's in a state in which they can accept or send data. Same decription as for 
     PCB's in state LISTEN applies to this PCB's regarding the options SOF_REUSEADDR and SOF_REUSEPORT. */
  for(cpcb = tcp_active_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  1105f1:	a1 54 16 14 00       	mov    0x141654,%eax
  1105f6:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  1105f9:	e9 e6 00 00 00       	jmp    1106e4 <tcp_bind+0x214>
    if(cpcb->local_port == port) {
  1105fe:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  110601:	0f b7 40 1c          	movzwl 0x1c(%eax),%eax
  110605:	66 3b 45 ec          	cmp    0xffffffec(%ebp),%ax
  110609:	0f 85 cc 00 00 00    	jne    1106db <tcp_bind+0x20b>
      if(ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
  11060f:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  110612:	8b 10                	mov    (%eax),%edx
  110614:	8b 45 0c             	mov    0xc(%ebp),%eax
  110617:	8b 00                	mov    (%eax),%eax
  110619:	39 c2                	cmp    %eax,%edx
  11061b:	75 50                	jne    11066d <tcp_bind+0x19d>
        if(pcb->so_options & SOF_REUSEPORT) {
  11061d:	8b 45 08             	mov    0x8(%ebp),%eax
  110620:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  110624:	0f b7 c0             	movzwl %ax,%eax
  110627:	25 00 02 00 00       	and    $0x200,%eax
  11062c:	85 c0                	test   %eax,%eax
  11062e:	74 31                	je     110661 <tcp_bind+0x191>
          LWIP_DEBUGF(TCP_DEBUG, ("tcp_bind: in active PCB's SO_REUSEPORT set and same address.\n"));
          reuse_port_all_set = (reuse_port_all_set && (cpcb->so_options & SOF_REUSEPORT));
  110630:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  110634:	74 1c                	je     110652 <tcp_bind+0x182>
  110636:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  110639:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  11063d:	0f b7 c0             	movzwl %ax,%eax
  110640:	25 00 02 00 00       	and    $0x200,%eax
  110645:	85 c0                	test   %eax,%eax
  110647:	74 09                	je     110652 <tcp_bind+0x182>
  110649:	c7 45 e4 01 00 00 00 	movl   $0x1,0xffffffe4(%ebp)
  110650:	eb 07                	jmp    110659 <tcp_bind+0x189>
  110652:	c7 45 e4 00 00 00 00 	movl   $0x0,0xffffffe4(%ebp)
  110659:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
  11065c:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  11065f:	eb 7a                	jmp    1106db <tcp_bind+0x20b>
        }
        else {
          LWIP_DEBUGF(TCP_DEBUG, ("tcp_bind: in active PCB's SO_REUSEPORT not set and same address.\n"));
          return ERR_USE;
  110661:	c7 45 e0 f6 ff ff ff 	movl   $0xfffffff6,0xffffffe0(%ebp)
  110668:	e9 6c 01 00 00       	jmp    1107d9 <tcp_bind+0x309>
        }
      }
      else if((ip_addr_isany(ipaddr) && !ip_addr_isany(&(cpcb->local_ip))) ||
  11066d:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  110671:	74 09                	je     11067c <tcp_bind+0x1ac>
  110673:	8b 45 0c             	mov    0xc(%ebp),%eax
  110676:	8b 00                	mov    (%eax),%eax
  110678:	85 c0                	test   %eax,%eax
  11067a:	75 10                	jne    11068c <tcp_bind+0x1bc>
  11067c:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  11067f:	85 c0                	test   %eax,%eax
  110681:	74 09                	je     11068c <tcp_bind+0x1bc>
  110683:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  110686:	8b 00                	mov    (%eax),%eax
  110688:	85 c0                	test   %eax,%eax
  11068a:	75 1f                	jne    1106ab <tcp_bind+0x1db>
  11068c:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  110690:	74 49                	je     1106db <tcp_bind+0x20b>
  110692:	8b 45 0c             	mov    0xc(%ebp),%eax
  110695:	8b 00                	mov    (%eax),%eax
  110697:	85 c0                	test   %eax,%eax
  110699:	74 40                	je     1106db <tcp_bind+0x20b>
  11069b:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  11069e:	85 c0                	test   %eax,%eax
  1106a0:	74 09                	je     1106ab <tcp_bind+0x1db>
  1106a2:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1106a5:	8b 00                	mov    (%eax),%eax
  1106a7:	85 c0                	test   %eax,%eax
  1106a9:	75 30                	jne    1106db <tcp_bind+0x20b>
              (!ip_addr_isany(ipaddr) && ip_addr_isany(&(cpcb->local_ip)))) {
        if(!(pcb->so_options & SOF_REUSEADDR) && !(pcb->so_options & SOF_REUSEPORT)) {
  1106ab:	8b 45 08             	mov    0x8(%ebp),%eax
  1106ae:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  1106b2:	0f b7 c0             	movzwl %ax,%eax
  1106b5:	83 e0 04             	and    $0x4,%eax
  1106b8:	85 c0                	test   %eax,%eax
  1106ba:	75 1f                	jne    1106db <tcp_bind+0x20b>
  1106bc:	8b 45 08             	mov    0x8(%ebp),%eax
  1106bf:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  1106c3:	0f b7 c0             	movzwl %ax,%eax
  1106c6:	25 00 02 00 00       	and    $0x200,%eax
  1106cb:	85 c0                	test   %eax,%eax
  1106cd:	75 0c                	jne    1106db <tcp_bind+0x20b>
          LWIP_DEBUGF(TCP_DEBUG, ("tcp_bind: in active PCB's SO_REUSEPORT or SO_REUSEADDR not set and not the same address.\n"));
          return ERR_USE;
  1106cf:	c7 45 e0 f6 ff ff ff 	movl   $0xfffffff6,0xffffffe0(%ebp)
  1106d6:	e9 fe 00 00 00       	jmp    1107d9 <tcp_bind+0x309>
  1106db:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1106de:	8b 40 0c             	mov    0xc(%eax),%eax
  1106e1:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  1106e4:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  1106e8:	0f 85 10 ff ff ff    	jne    1105fe <tcp_bind+0x12e>
        }   
        else {
          LWIP_DEBUGF(TCP_DEBUG, ("tcp_bind: in active PCB's SO_REUSEPORT or SO_REUSEADDR set and not the same address.\n"));
        }        
      }
    }
  }

  /* Search through list of PCB's in TIME_WAIT state. If SO_REUSEADDR is set a bound combination [IP, port} 
     can be rebound. The same applies when SOF_REUSEPORT is set. 
     
     If SOF_REUSEPORT is set several PCB's can be bound to same local port and same local address also. But then 
     all PCB's must have the SOF_REUSEPORT option set.
     
     When the two options aren't set and specified port is already bound, ERR_USE is returned saying that 
     address is already in use. */
  for(cpcb = tcp_tw_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  1106ee:	a1 64 16 14 00       	mov    0x141664,%eax
  1106f3:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  1106f6:	e9 9a 00 00 00       	jmp    110795 <tcp_bind+0x2c5>
    if(cpcb->local_port == port) {
  1106fb:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1106fe:	0f b7 40 1c          	movzwl 0x1c(%eax),%eax
  110702:	66 3b 45 ec          	cmp    0xffffffec(%ebp),%ax
  110706:	0f 85 80 00 00 00    	jne    11078c <tcp_bind+0x2bc>
      if(ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
  11070c:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  11070f:	8b 10                	mov    (%eax),%edx
  110711:	8b 45 0c             	mov    0xc(%ebp),%eax
  110714:	8b 00                	mov    (%eax),%eax
  110716:	39 c2                	cmp    %eax,%edx
  110718:	75 72                	jne    11078c <tcp_bind+0x2bc>
        if(!(pcb->so_options & SOF_REUSEADDR) && !(pcb->so_options & SOF_REUSEPORT)) {
  11071a:	8b 45 08             	mov    0x8(%ebp),%eax
  11071d:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  110721:	0f b7 c0             	movzwl %ax,%eax
  110724:	83 e0 04             	and    $0x4,%eax
  110727:	85 c0                	test   %eax,%eax
  110729:	75 1f                	jne    11074a <tcp_bind+0x27a>
  11072b:	8b 45 08             	mov    0x8(%ebp),%eax
  11072e:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  110732:	0f b7 c0             	movzwl %ax,%eax
  110735:	25 00 02 00 00       	and    $0x200,%eax
  11073a:	85 c0                	test   %eax,%eax
  11073c:	75 0c                	jne    11074a <tcp_bind+0x27a>
          LWIP_DEBUGF(TCP_DEBUG, ("tcp_bind: in TIME_WAIT PCB's SO_REUSEPORT or SO_REUSEADDR not set and same address.\n"));
          return ERR_USE;
  11073e:	c7 45 e0 f6 ff ff ff 	movl   $0xfffffff6,0xffffffe0(%ebp)
  110745:	e9 8f 00 00 00       	jmp    1107d9 <tcp_bind+0x309>
        }
        else if(pcb->so_options & SOF_REUSEPORT) {
  11074a:	8b 45 08             	mov    0x8(%ebp),%eax
  11074d:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  110751:	0f b7 c0             	movzwl %ax,%eax
  110754:	25 00 02 00 00       	and    $0x200,%eax
  110759:	85 c0                	test   %eax,%eax
  11075b:	74 2f                	je     11078c <tcp_bind+0x2bc>
          LWIP_DEBUGF(TCP_DEBUG, ("tcp_bind: in TIME_WAIT PCB's SO_REUSEPORT set and same address.\n"));
          reuse_port_all_set = (reuse_port_all_set && (cpcb->so_options & SOF_REUSEPORT));
  11075d:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  110761:	74 1c                	je     11077f <tcp_bind+0x2af>
  110763:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  110766:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  11076a:	0f b7 c0             	movzwl %ax,%eax
  11076d:	25 00 02 00 00       	and    $0x200,%eax
  110772:	85 c0                	test   %eax,%eax
  110774:	74 09                	je     11077f <tcp_bind+0x2af>
  110776:	c7 45 e8 01 00 00 00 	movl   $0x1,0xffffffe8(%ebp)
  11077d:	eb 07                	jmp    110786 <tcp_bind+0x2b6>
  11077f:	c7 45 e8 00 00 00 00 	movl   $0x0,0xffffffe8(%ebp)
  110786:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  110789:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  11078c:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  11078f:	8b 40 0c             	mov    0xc(%eax),%eax
  110792:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  110795:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  110799:	0f 85 5c ff ff ff    	jne    1106fb <tcp_bind+0x22b>
        }
      }
    }
  }

  /* If SOF_REUSEPORT isn't set in all PCB's bound to specified port and local address specified then 
     {IP, port} can't be reused. */
  if(!reuse_port_all_set) {
  11079f:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  1107a3:	75 09                	jne    1107ae <tcp_bind+0x2de>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_bind: not all sockets have SO_REUSEPORT set.\n"));
    return ERR_USE;
  1107a5:	c7 45 e0 f6 ff ff ff 	movl   $0xfffffff6,0xffffffe0(%ebp)
  1107ac:	eb 2b                	jmp    1107d9 <tcp_bind+0x309>
  }
#endif /* SO_REUSE */

  if (!ip_addr_isany(ipaddr)) {
  1107ae:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  1107b2:	74 13                	je     1107c7 <tcp_bind+0x2f7>
  1107b4:	8b 45 0c             	mov    0xc(%ebp),%eax
  1107b7:	8b 00                	mov    (%eax),%eax
  1107b9:	85 c0                	test   %eax,%eax
  1107bb:	74 0a                	je     1107c7 <tcp_bind+0x2f7>
    pcb->local_ip = *ipaddr;
  1107bd:	8b 45 0c             	mov    0xc(%ebp),%eax
  1107c0:	8b 10                	mov    (%eax),%edx
  1107c2:	8b 45 08             	mov    0x8(%ebp),%eax
  1107c5:	89 10                	mov    %edx,(%eax)
  }
  pcb->local_port = port;
  1107c7:	8b 55 08             	mov    0x8(%ebp),%edx
  1107ca:	0f b7 45 ec          	movzwl 0xffffffec(%ebp),%eax
  1107ce:	66 89 42 1c          	mov    %ax,0x1c(%edx)
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_bind: bind to port %u\n", port));
  return ERR_OK;
  1107d2:	c7 45 e0 00 00 00 00 	movl   $0x0,0xffffffe0(%ebp)
  1107d9:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
}
  1107dc:	c9                   	leave  
  1107dd:	c3                   	ret    
  1107de:	89 f6                	mov    %esi,%esi

001107e0 <tcp_accept_null>:
#if LWIP_CALLBACK_API
static err_t
tcp_accept_null(void *arg, struct tcp_pcb *pcb, err_t err)
{
  1107e0:	55                   	push   %ebp
  1107e1:	89 e5                	mov    %esp,%ebp
  1107e3:	83 ec 04             	sub    $0x4,%esp
  1107e6:	8b 45 10             	mov    0x10(%ebp),%eax
  1107e9:	88 45 fc             	mov    %al,0xfffffffc(%ebp)
  (void)arg;
  (void)pcb;
  (void)err;

  return ERR_ABRT;
  1107ec:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
}
  1107f1:	c9                   	leave  
  1107f2:	c3                   	ret    
  1107f3:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  1107f9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00110800 <tcp_listen>:
#endif /* LWIP_CALLBACK_API */

/*
 * tcp_listen():
 *
 * Set the state of the connection to be LISTEN, which means that it
 * is able to accept incoming connections. The protocol control block
 * is reallocated in order to consume less memory. Setting the
 * connection to LISTEN is an irreversible process.
 *
 */

struct tcp_pcb *
tcp_listen(struct tcp_pcb *pcb)
{
  110800:	55                   	push   %ebp
  110801:	89 e5                	mov    %esp,%ebp
  110803:	83 ec 28             	sub    $0x28,%esp
  struct tcp_pcb_listen *lpcb;

  /* already listening? */
  if (pcb->state == LISTEN) {
  110806:	8b 45 08             	mov    0x8(%ebp),%eax
  110809:	8b 40 10             	mov    0x10(%eax),%eax
  11080c:	83 f8 01             	cmp    $0x1,%eax
  11080f:	75 0b                	jne    11081c <tcp_listen+0x1c>
    return pcb;
  110811:	8b 45 08             	mov    0x8(%ebp),%eax
  110814:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
  110817:	e9 dc 00 00 00       	jmp    1108f8 <tcp_listen+0xf8>
  }
  lpcb = memp_malloc(MEMP_TCP_PCB_LISTEN);
  11081c:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  110823:	e8 a8 e1 ff ff       	call   10e9d0 <memp_malloc>
  110828:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  if (lpcb == NULL) {
  11082b:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  11082f:	75 0c                	jne    11083d <tcp_listen+0x3d>
    return NULL;
  110831:	c7 45 e8 00 00 00 00 	movl   $0x0,0xffffffe8(%ebp)
  110838:	e9 bb 00 00 00       	jmp    1108f8 <tcp_listen+0xf8>
  }
  lpcb->callback_arg = pcb->callback_arg;
  11083d:	8b 45 08             	mov    0x8(%ebp),%eax
  110840:	8b 50 18             	mov    0x18(%eax),%edx
  110843:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  110846:	89 50 18             	mov    %edx,0x18(%eax)
  lpcb->local_port = pcb->local_port;
  110849:	8b 45 08             	mov    0x8(%ebp),%eax
  11084c:	0f b7 50 1c          	movzwl 0x1c(%eax),%edx
  110850:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  110853:	66 89 50 1c          	mov    %dx,0x1c(%eax)
  lpcb->state = LISTEN;
  110857:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  11085a:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
  lpcb->so_options = pcb->so_options;
  110861:	8b 45 08             	mov    0x8(%ebp),%eax
  110864:	0f b7 50 08          	movzwl 0x8(%eax),%edx
  110868:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  11086b:	66 89 50 08          	mov    %dx,0x8(%eax)
  lpcb->so_options |= SOF_ACCEPTCONN;
  11086f:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  110872:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  110876:	89 c2                	mov    %eax,%edx
  110878:	83 ca 02             	or     $0x2,%edx
  11087b:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  11087e:	66 89 50 08          	mov    %dx,0x8(%eax)
  lpcb->ttl = pcb->ttl;
  110882:	8b 45 08             	mov    0x8(%ebp),%eax
  110885:	0f b6 50 0b          	movzbl 0xb(%eax),%edx
  110889:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  11088c:	88 50 0b             	mov    %dl,0xb(%eax)
  lpcb->tos = pcb->tos;
  11088f:	8b 45 08             	mov    0x8(%ebp),%eax
  110892:	0f b6 50 0a          	movzbl 0xa(%eax),%edx
  110896:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  110899:	88 50 0a             	mov    %dl,0xa(%eax)
  ip_addr_set(&lpcb->local_ip, &pcb->local_ip);
  11089c:	8b 45 08             	mov    0x8(%ebp),%eax
  11089f:	85 c0                	test   %eax,%eax
  1108a1:	74 0a                	je     1108ad <tcp_listen+0xad>
  1108a3:	8b 45 08             	mov    0x8(%ebp),%eax
  1108a6:	8b 00                	mov    (%eax),%eax
  1108a8:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  1108ab:	eb 07                	jmp    1108b4 <tcp_listen+0xb4>
  1108ad:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  1108b4:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1108b7:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
  1108ba:	89 10                	mov    %edx,(%eax)
  memp_free(MEMP_TCP_PCB, pcb);
  1108bc:	8b 45 08             	mov    0x8(%ebp),%eax
  1108bf:	89 44 24 04          	mov    %eax,0x4(%esp)
  1108c3:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  1108ca:	e8 f1 e1 ff ff       	call   10eac0 <memp_free>
#if LWIP_CALLBACK_API
  lpcb->accept = tcp_accept_null;
  1108cf:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1108d2:	c7 40 20 e0 07 11 00 	movl   $0x1107e0,0x20(%eax)
#endif /* LWIP_CALLBACK_API */
  TCP_REG(&tcp_listen_pcbs.listen_pcbs, lpcb);
  1108d9:	8b 15 5c 16 14 00    	mov    0x14165c,%edx
  1108df:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1108e2:	89 50 0c             	mov    %edx,0xc(%eax)
  1108e5:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1108e8:	a3 5c 16 14 00       	mov    %eax,0x14165c
  1108ed:	e8 de 91 00 00       	call   119ad0 <tcp_timer_needed>
  return (struct tcp_pcb *)lpcb;
  1108f2:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1108f5:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
  1108f8:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
}
  1108fb:	c9                   	leave  
  1108fc:	c3                   	ret    
  1108fd:	8d 76 00             	lea    0x0(%esi),%esi

00110900 <tcp_recved>:

/*
 * tcp_recved():
 *
 * This function should be called by the application when it has
 * processed the data. The purpose is to advertise a larger window
 * when the data has been processed.
 *
 */

void
tcp_recved(struct tcp_pcb *pcb, u16_t len)
{
  110900:	55                   	push   %ebp
  110901:	89 e5                	mov    %esp,%ebp
  110903:	83 ec 08             	sub    $0x8,%esp
  110906:	8b 45 0c             	mov    0xc(%ebp),%eax
  110909:	66 89 45 fc          	mov    %ax,0xfffffffc(%ebp)
  if ((u32_t)pcb->rcv_wnd + len > TCP_WND) {
  11090d:	8b 45 08             	mov    0x8(%ebp),%eax
  110910:	0f b7 40 28          	movzwl 0x28(%eax),%eax
  110914:	0f b7 d0             	movzwl %ax,%edx
  110917:	0f b7 45 fc          	movzwl 0xfffffffc(%ebp),%eax
  11091b:	8d 04 02             	lea    (%edx,%eax,1),%eax
  11091e:	3d 00 20 00 00       	cmp    $0x2000,%eax
  110923:	76 0b                	jbe    110930 <tcp_recved+0x30>
    pcb->rcv_wnd = TCP_WND;
  110925:	8b 45 08             	mov    0x8(%ebp),%eax
  110928:	66 c7 40 28 00 20    	movw   $0x2000,0x28(%eax)
  11092e:	eb 14                	jmp    110944 <tcp_recved+0x44>
  } else {
    pcb->rcv_wnd += len;
  110930:	8b 45 08             	mov    0x8(%ebp),%eax
  110933:	0f b7 40 28          	movzwl 0x28(%eax),%eax
  110937:	89 c2                	mov    %eax,%edx
  110939:	66 03 55 fc          	add    0xfffffffc(%ebp),%dx
  11093d:	8b 45 08             	mov    0x8(%ebp),%eax
  110940:	66 89 50 28          	mov    %dx,0x28(%eax)
  }
  if (!(pcb->flags & TF_ACK_DELAY) &&
  110944:	8b 45 08             	mov    0x8(%ebp),%eax
  110947:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  11094b:	0f b6 c0             	movzbl %al,%eax
  11094e:	83 e0 01             	and    $0x1,%eax
  110951:	85 c0                	test   %eax,%eax
  110953:	75 65                	jne    1109ba <tcp_recved+0xba>
  110955:	8b 45 08             	mov    0x8(%ebp),%eax
  110958:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  11095c:	0f b6 c0             	movzbl %al,%eax
  11095f:	83 e0 02             	and    $0x2,%eax
  110962:	85 c0                	test   %eax,%eax
  110964:	75 54                	jne    1109ba <tcp_recved+0xba>
     !(pcb->flags & TF_ACK_NOW)) {
    /*
     * We send an ACK here (if one is not already pending, hence
     * the above tests) as tcp_recved() implies that the application
     * has processed some data, and so we can open the receiver's
     * window to allow more to be transmitted.  This could result in
     * two ACKs being sent for each received packet in some limited cases
     * (where the application is only receiving data, and is slow to
     * process it) but it is necessary to guarantee that the sender can
     * continue to transmit.
     */
    tcp_ack(pcb);
  110966:	8b 45 08             	mov    0x8(%ebp),%eax
  110969:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  11096d:	0f b6 c0             	movzbl %al,%eax
  110970:	83 e0 01             	and    $0x1,%eax
  110973:	84 c0                	test   %al,%al
  110975:	74 31                	je     1109a8 <tcp_recved+0xa8>
  110977:	8b 45 08             	mov    0x8(%ebp),%eax
  11097a:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  11097e:	89 c2                	mov    %eax,%edx
  110980:	83 e2 fe             	and    $0xfffffffe,%edx
  110983:	8b 45 08             	mov    0x8(%ebp),%eax
  110986:	88 50 20             	mov    %dl,0x20(%eax)
  110989:	8b 45 08             	mov    0x8(%ebp),%eax
  11098c:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  110990:	89 c2                	mov    %eax,%edx
  110992:	83 ca 02             	or     $0x2,%edx
  110995:	8b 45 08             	mov    0x8(%ebp),%eax
  110998:	88 50 20             	mov    %dl,0x20(%eax)
  11099b:	8b 45 08             	mov    0x8(%ebp),%eax
  11099e:	89 04 24             	mov    %eax,(%esp)
  1109a1:	e8 aa 14 00 00       	call   111e50 <tcp_output>
  1109a6:	eb 12                	jmp    1109ba <tcp_recved+0xba>
  1109a8:	8b 45 08             	mov    0x8(%ebp),%eax
  1109ab:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  1109af:	89 c2                	mov    %eax,%edx
  1109b1:	83 ca 01             	or     $0x1,%edx
  1109b4:	8b 45 08             	mov    0x8(%ebp),%eax
  1109b7:	88 50 20             	mov    %dl,0x20(%eax)
  }

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_recved: recveived %u bytes, wnd %u (%u).\n",
         len, pcb->rcv_wnd, TCP_WND - pcb->rcv_wnd));
}
  1109ba:	c9                   	leave  
  1109bb:	c3                   	ret    
  1109bc:	8d 74 26 00          	lea    0x0(%esi),%esi

001109c0 <tcp_new_port>:

/*
 * tcp_new_port():
 *
 * A nastly hack featuring 'goto' statements that allocates a
 * new TCP local port.
 */

static u16_t
tcp_new_port(void)
{
  1109c0:	55                   	push   %ebp
  1109c1:	89 e5                	mov    %esp,%ebp
  1109c3:	83 ec 10             	sub    $0x10,%esp
  struct tcp_pcb *pcb;
#ifndef TCP_LOCAL_PORT_RANGE_START
#define TCP_LOCAL_PORT_RANGE_START 4096
#define TCP_LOCAL_PORT_RANGE_END   0x7fff
#endif
  static u16_t port = TCP_LOCAL_PORT_RANGE_START;
  
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
  1109c6:	0f b7 05 a0 cb 11 00 	movzwl 0x11cba0,%eax
  1109cd:	83 c0 01             	add    $0x1,%eax
  1109d0:	66 a3 a0 cb 11 00    	mov    %ax,0x11cba0
  1109d6:	0f b7 05 a0 cb 11 00 	movzwl 0x11cba0,%eax
  1109dd:	66 85 c0             	test   %ax,%ax
  1109e0:	79 09                	jns    1109eb <tcp_new_port+0x2b>
    port = TCP_LOCAL_PORT_RANGE_START;
  1109e2:	66 c7 05 a0 cb 11 00 	movw   $0x1000,0x11cba0
  1109e9:	00 10 
  }
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  1109eb:	a1 54 16 14 00       	mov    0x141654,%eax
  1109f0:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  1109f3:	eb 1c                	jmp    110a11 <tcp_new_port+0x51>
    if (pcb->local_port == port) {
  1109f5:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1109f8:	0f b7 50 1c          	movzwl 0x1c(%eax),%edx
  1109fc:	0f b7 05 a0 cb 11 00 	movzwl 0x11cba0,%eax
  110a03:	66 39 c2             	cmp    %ax,%dx
  110a06:	74 be                	je     1109c6 <tcp_new_port+0x6>
  110a08:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  110a0b:	8b 40 0c             	mov    0xc(%eax),%eax
  110a0e:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  110a11:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  110a15:	75 de                	jne    1109f5 <tcp_new_port+0x35>
      goto again;
    }
  }
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  110a17:	a1 64 16 14 00       	mov    0x141664,%eax
  110a1c:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  110a1f:	eb 1c                	jmp    110a3d <tcp_new_port+0x7d>
    if (pcb->local_port == port) {
  110a21:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  110a24:	0f b7 50 1c          	movzwl 0x1c(%eax),%edx
  110a28:	0f b7 05 a0 cb 11 00 	movzwl 0x11cba0,%eax
  110a2f:	66 39 c2             	cmp    %ax,%dx
  110a32:	74 92                	je     1109c6 <tcp_new_port+0x6>
  110a34:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  110a37:	8b 40 0c             	mov    0xc(%eax),%eax
  110a3a:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  110a3d:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  110a41:	75 de                	jne    110a21 <tcp_new_port+0x61>
      goto again;
    }
  }
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
  110a43:	a1 5c 16 14 00       	mov    0x14165c,%eax
  110a48:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  110a4b:	eb 20                	jmp    110a6d <tcp_new_port+0xad>
    if (pcb->local_port == port) {
  110a4d:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  110a50:	0f b7 50 1c          	movzwl 0x1c(%eax),%edx
  110a54:	0f b7 05 a0 cb 11 00 	movzwl 0x11cba0,%eax
  110a5b:	66 39 c2             	cmp    %ax,%dx
  110a5e:	0f 84 62 ff ff ff    	je     1109c6 <tcp_new_port+0x6>
  110a64:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  110a67:	8b 40 0c             	mov    0xc(%eax),%eax
  110a6a:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  110a6d:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  110a71:	75 da                	jne    110a4d <tcp_new_port+0x8d>
      goto again;
    }
  }
  return port;
  110a73:	0f b7 05 a0 cb 11 00 	movzwl 0x11cba0,%eax
  110a7a:	0f b7 c0             	movzwl %ax,%eax
}
  110a7d:	c9                   	leave  
  110a7e:	c3                   	ret    
  110a7f:	90                   	nop    

00110a80 <tcp_connect>:

/*
 * tcp_connect():
 *
 * Connects to another host. The function given as the "connected"
 * argument will be called when the connection has been established.
 *
 */

err_t
tcp_connect(struct tcp_pcb *pcb, struct ip_addr *ipaddr, u16_t port,
      err_t (* connected)(void *arg, struct tcp_pcb *tpcb, err_t err))
{
  110a80:	55                   	push   %ebp
  110a81:	89 e5                	mov    %esp,%ebp
  110a83:	83 ec 38             	sub    $0x38,%esp
  110a86:	8b 45 10             	mov    0x10(%ebp),%eax
  110a89:	66 89 45 ec          	mov    %ax,0xffffffec(%ebp)
  u32_t optdata;
  err_t ret;
  u32_t iss;

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_connect to port %u\n", port));
  if (ipaddr != NULL) {
  110a8d:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  110a91:	74 24                	je     110ab7 <tcp_connect+0x37>
    pcb->remote_ip = *ipaddr;
  110a93:	8b 45 0c             	mov    0xc(%ebp),%eax
  110a96:	8b 10                	mov    (%eax),%edx
  110a98:	8b 45 08             	mov    0x8(%ebp),%eax
  110a9b:	89 50 04             	mov    %edx,0x4(%eax)
  } else {
    return ERR_VAL;
  }
  pcb->remote_port = port;
  110a9e:	8b 55 08             	mov    0x8(%ebp),%edx
  110aa1:	0f b7 45 ec          	movzwl 0xffffffec(%ebp),%eax
  110aa5:	66 89 42 1e          	mov    %ax,0x1e(%edx)
  if (pcb->local_port == 0) {
  110aa9:	8b 45 08             	mov    0x8(%ebp),%eax
  110aac:	0f b7 40 1c          	movzwl 0x1c(%eax),%eax
  110ab0:	66 85 c0             	test   %ax,%ax
  110ab3:	74 0e                	je     110ac3 <tcp_connect+0x43>
  110ab5:	eb 1a                	jmp    110ad1 <tcp_connect+0x51>
  110ab7:	c7 45 e8 f9 ff ff ff 	movl   $0xfffffff9,0xffffffe8(%ebp)
  110abe:	e9 3a 01 00 00       	jmp    110bfd <tcp_connect+0x17d>
    pcb->local_port = tcp_new_port();
  110ac3:	e8 f8 fe ff ff       	call   1109c0 <tcp_new_port>
  110ac8:	89 c2                	mov    %eax,%edx
  110aca:	8b 45 08             	mov    0x8(%ebp),%eax
  110acd:	66 89 50 1c          	mov    %dx,0x1c(%eax)
  }
  iss = tcp_next_iss();
  110ad1:	e8 ea 0b 00 00       	call   1116c0 <tcp_next_iss>
  110ad6:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  pcb->rcv_nxt = 0;
  110ad9:	8b 45 08             	mov    0x8(%ebp),%eax
  110adc:	c7 40 24 00 00 00 00 	movl   $0x0,0x24(%eax)
  pcb->snd_nxt = iss;
  110ae3:	8b 55 08             	mov    0x8(%ebp),%edx
  110ae6:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  110ae9:	89 42 50             	mov    %eax,0x50(%edx)
  pcb->lastack = iss - 1;
  110aec:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  110aef:	83 ea 01             	sub    $0x1,%edx
  110af2:	8b 45 08             	mov    0x8(%ebp),%eax
  110af5:	89 50 44             	mov    %edx,0x44(%eax)
  pcb->snd_lbb = iss - 1;
  110af8:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  110afb:	83 ea 01             	sub    $0x1,%edx
  110afe:	8b 45 08             	mov    0x8(%ebp),%eax
  110b01:	89 50 64             	mov    %edx,0x64(%eax)
  pcb->rcv_wnd = TCP_WND;
  110b04:	8b 45 08             	mov    0x8(%ebp),%eax
  110b07:	66 c7 40 28 00 20    	movw   $0x2000,0x28(%eax)
  pcb->snd_wnd = TCP_WND;
  110b0d:	8b 45 08             	mov    0x8(%ebp),%eax
  110b10:	c7 40 58 00 20 00 00 	movl   $0x2000,0x58(%eax)
  pcb->mss = TCP_MSS;
  110b17:	8b 45 08             	mov    0x8(%ebp),%eax
  110b1a:	66 c7 40 34 00 02    	movw   $0x200,0x34(%eax)
  pcb->cwnd = 1;
  110b20:	8b 45 08             	mov    0x8(%ebp),%eax
  110b23:	66 c7 40 4a 01 00    	movw   $0x1,0x4a(%eax)
  pcb->ssthresh = pcb->mss * 10;
  110b29:	8b 45 08             	mov    0x8(%ebp),%eax
  110b2c:	0f b7 40 34          	movzwl 0x34(%eax),%eax
  110b30:	0f b7 d0             	movzwl %ax,%edx
  110b33:	89 d0                	mov    %edx,%eax
  110b35:	c1 e0 02             	shl    $0x2,%eax
  110b38:	01 d0                	add    %edx,%eax
  110b3a:	01 c0                	add    %eax,%eax
  110b3c:	89 c2                	mov    %eax,%edx
  110b3e:	8b 45 08             	mov    0x8(%ebp),%eax
  110b41:	66 89 50 4c          	mov    %dx,0x4c(%eax)
  pcb->state = SYN_SENT;
  110b45:	8b 45 08             	mov    0x8(%ebp),%eax
  110b48:	c7 40 10 02 00 00 00 	movl   $0x2,0x10(%eax)
#if LWIP_CALLBACK_API  
  pcb->connected = connected;
  110b4f:	8b 55 08             	mov    0x8(%ebp),%edx
  110b52:	8b 45 14             	mov    0x14(%ebp),%eax
  110b55:	89 82 84 00 00 00    	mov    %eax,0x84(%edx)
#endif /* LWIP_CALLBACK_API */  
  TCP_REG(&tcp_active_pcbs, pcb);
  110b5b:	8b 15 54 16 14 00    	mov    0x141654,%edx
  110b61:	8b 45 08             	mov    0x8(%ebp),%eax
  110b64:	89 50 0c             	mov    %edx,0xc(%eax)
  110b67:	8b 45 08             	mov    0x8(%ebp),%eax
  110b6a:	a3 54 16 14 00       	mov    %eax,0x141654
  110b6f:	e8 5c 8f 00 00       	call   119ad0 <tcp_timer_needed>
  
  /* Build an MSS option */
  optdata = htonl(((u32_t)2 << 24) | 
  110b74:	8b 45 08             	mov    0x8(%ebp),%eax
  110b77:	0f b7 40 34          	movzwl 0x34(%eax),%eax
  110b7b:	66 c1 e8 08          	shr    $0x8,%ax
  110b7f:	0f b7 c0             	movzwl %ax,%eax
  110b82:	89 c2                	mov    %eax,%edx
  110b84:	c1 e2 08             	shl    $0x8,%edx
  110b87:	8b 45 08             	mov    0x8(%ebp),%eax
  110b8a:	0f b7 40 34          	movzwl 0x34(%eax),%eax
  110b8e:	0f b7 c0             	movzwl %ax,%eax
  110b91:	25 ff 00 00 00       	and    $0xff,%eax
  110b96:	09 d0                	or     %edx,%eax
  110b98:	0d 00 00 04 02       	or     $0x2040000,%eax
  110b9d:	89 04 24             	mov    %eax,(%esp)
  110ba0:	e8 2b d7 ff ff       	call   10e2d0 <htonl>
  110ba5:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
      ((u32_t)4 << 16) | 
      (((u32_t)pcb->mss / 256) << 8) |
      (pcb->mss & 255));

  ret = tcp_enqueue(pcb, NULL, 0, TCP_SYN, 0, (u8_t *)&optdata, 4);
  110ba8:	8d 45 f4             	lea    0xfffffff4(%ebp),%eax
  110bab:	c7 44 24 18 04 00 00 	movl   $0x4,0x18(%esp)
  110bb2:	00 
  110bb3:	89 44 24 14          	mov    %eax,0x14(%esp)
  110bb7:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  110bbe:	00 
  110bbf:	c7 44 24 0c 02 00 00 	movl   $0x2,0xc(%esp)
  110bc6:	00 
  110bc7:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  110bce:	00 
  110bcf:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  110bd6:	00 
  110bd7:	8b 45 08             	mov    0x8(%ebp),%eax
  110bda:	89 04 24             	mov    %eax,(%esp)
  110bdd:	e8 ee 0b 00 00       	call   1117d0 <tcp_enqueue>
  110be2:	88 45 fb             	mov    %al,0xfffffffb(%ebp)
  if (ret == ERR_OK) { 
  110be5:	80 7d fb 00          	cmpb   $0x0,0xfffffffb(%ebp)
  110be9:	75 0b                	jne    110bf6 <tcp_connect+0x176>
    tcp_output(pcb);
  110beb:	8b 45 08             	mov    0x8(%ebp),%eax
  110bee:	89 04 24             	mov    %eax,(%esp)
  110bf1:	e8 5a 12 00 00       	call   111e50 <tcp_output>
  }
  return ret;
  110bf6:	0f be 45 fb          	movsbl 0xfffffffb(%ebp),%eax
  110bfa:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
  110bfd:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
} 
  110c00:	c9                   	leave  
  110c01:	c3                   	ret    
  110c02:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi
  110c09:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00110c10 <tcp_slowtmr>:

/*
 * tcp_slowtmr():
 *
 * Called every 500 ms and implements the retransmission timer and the timer that
 * removes PCBs that have been in TIME-WAIT for enough time. It also increments
 * various timers such as the inactivity timer in each PCB.
 */

void
tcp_slowtmr(void)
{
  110c10:	55                   	push   %ebp
  110c11:	89 e5                	mov    %esp,%ebp
  110c13:	83 ec 38             	sub    $0x38,%esp
  struct tcp_pcb *pcb, *pcb2, *prev;
  u32_t eff_wnd;
  u8_t pcb_remove;      /* flag if a PCB should be removed */
  err_t err;

  err = ERR_OK;
  110c16:	c6 45 ff 00          	movb   $0x0,0xffffffff(%ebp)

  ++tcp_ticks;
  110c1a:	a1 58 16 14 00       	mov    0x141658,%eax
  110c1f:	83 c0 01             	add    $0x1,%eax
  110c22:	a3 58 16 14 00       	mov    %eax,0x141658

  /* Steps through all of the active PCBs. */
  prev = NULL;
  110c27:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
  pcb = tcp_active_pcbs;
  110c2e:	a1 54 16 14 00       	mov    0x141654,%eax
  110c33:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  110c36:	e9 83 03 00 00       	jmp    110fbe <tcp_slowtmr+0x3ae>
  if (pcb == NULL) LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  while (pcb != NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);

    pcb_remove = 0;
  110c3b:	c6 45 fe 00          	movb   $0x0,0xfffffffe(%ebp)

    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
  110c3f:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110c42:	8b 40 10             	mov    0x10(%eax),%eax
  110c45:	83 f8 02             	cmp    $0x2,%eax
  110c48:	75 14                	jne    110c5e <tcp_slowtmr+0x4e>
  110c4a:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110c4d:	0f b6 40 42          	movzbl 0x42(%eax),%eax
  110c51:	3c 06                	cmp    $0x6,%al
  110c53:	75 09                	jne    110c5e <tcp_slowtmr+0x4e>
      ++pcb_remove;
  110c55:	80 45 fe 01          	addb   $0x1,0xfffffffe(%ebp)
  110c59:	e9 07 01 00 00       	jmp    110d65 <tcp_slowtmr+0x155>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max SYN retries reached\n"));
    }
    else if (pcb->nrtx == TCP_MAXRTX) {
  110c5e:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110c61:	0f b6 40 42          	movzbl 0x42(%eax),%eax
  110c65:	3c 0c                	cmp    $0xc,%al
  110c67:	75 09                	jne    110c72 <tcp_slowtmr+0x62>
      ++pcb_remove;
  110c69:	80 45 fe 01          	addb   $0x1,0xfffffffe(%ebp)
  110c6d:	e9 f3 00 00 00       	jmp    110d65 <tcp_slowtmr+0x155>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max DATA retries reached\n"));
    } else {
      ++pcb->rtime;
  110c72:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110c75:	0f b7 40 32          	movzwl 0x32(%eax),%eax
  110c79:	8d 50 01             	lea    0x1(%eax),%edx
  110c7c:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110c7f:	66 89 50 32          	mov    %dx,0x32(%eax)
      if (pcb->unacked != NULL && pcb->rtime >= pcb->rto) {
  110c83:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110c86:	8b 40 74             	mov    0x74(%eax),%eax
  110c89:	85 c0                	test   %eax,%eax
  110c8b:	0f 84 d4 00 00 00    	je     110d65 <tcp_slowtmr+0x155>
  110c91:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110c94:	0f b7 50 32          	movzwl 0x32(%eax),%edx
  110c98:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110c9b:	0f b7 40 40          	movzwl 0x40(%eax),%eax
  110c9f:	66 39 c2             	cmp    %ax,%dx
  110ca2:	0f 82 bd 00 00 00    	jb     110d65 <tcp_slowtmr+0x155>

        /* Time for a retransmission. */
        LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_slowtmr: rtime %u pcb->rto %u\n",
          pcb->rtime, pcb->rto));

        /* Double retransmission time-out unless we are trying to
         * connect to somebody (i.e., we are in SYN_SENT). */
        if (pcb->state != SYN_SENT) {
  110ca8:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110cab:	8b 40 10             	mov    0x10(%eax),%eax
  110cae:	83 f8 02             	cmp    $0x2,%eax
  110cb1:	74 39                	je     110cec <tcp_slowtmr+0xdc>
          pcb->rto = ((pcb->sa >> 3) + pcb->sv) << tcp_backoff[pcb->nrtx];
  110cb3:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110cb6:	0f b7 40 3c          	movzwl 0x3c(%eax),%eax
  110cba:	66 c1 f8 03          	sar    $0x3,%ax
  110cbe:	0f bf d0             	movswl %ax,%edx
  110cc1:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110cc4:	0f b7 40 3e          	movzwl 0x3e(%eax),%eax
  110cc8:	98                   	cwtl   
  110cc9:	01 c2                	add    %eax,%edx
  110ccb:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110cce:	0f b6 40 42          	movzbl 0x42(%eax),%eax
  110cd2:	0f b6 c0             	movzbl %al,%eax
  110cd5:	0f b6 80 b8 ae 11 00 	movzbl 0x11aeb8(%eax),%eax
  110cdc:	0f b6 c8             	movzbl %al,%ecx
  110cdf:	89 d0                	mov    %edx,%eax
  110ce1:	d3 e0                	shl    %cl,%eax
  110ce3:	89 c2                	mov    %eax,%edx
  110ce5:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110ce8:	66 89 50 40          	mov    %dx,0x40(%eax)
        }
        tcp_rexmit(pcb);
  110cec:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110cef:	89 04 24             	mov    %eax,(%esp)
  110cf2:	e8 79 19 00 00       	call   112670 <tcp_rexmit>
        /* Reduce congestion window and ssthresh. */
        eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
  110cf7:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110cfa:	8b 50 58             	mov    0x58(%eax),%edx
  110cfd:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110d00:	0f b7 40 4a          	movzwl 0x4a(%eax),%eax
  110d04:	0f b7 c0             	movzwl %ax,%eax
  110d07:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
  110d0a:	89 55 d8             	mov    %edx,0xffffffd8(%ebp)
  110d0d:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  110d10:	39 45 d8             	cmp    %eax,0xffffffd8(%ebp)
  110d13:	76 06                	jbe    110d1b <tcp_slowtmr+0x10b>
  110d15:	8b 4d dc             	mov    0xffffffdc(%ebp),%ecx
  110d18:	89 4d d8             	mov    %ecx,0xffffffd8(%ebp)
  110d1b:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  110d1e:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
        pcb->ssthresh = eff_wnd >> 1;
  110d21:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  110d24:	d1 e8                	shr    %eax
  110d26:	89 c2                	mov    %eax,%edx
  110d28:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110d2b:	66 89 50 4c          	mov    %dx,0x4c(%eax)
        if (pcb->ssthresh < pcb->mss) {
  110d2f:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110d32:	0f b7 50 4c          	movzwl 0x4c(%eax),%edx
  110d36:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110d39:	0f b7 40 34          	movzwl 0x34(%eax),%eax
  110d3d:	66 39 c2             	cmp    %ax,%dx
  110d40:	73 15                	jae    110d57 <tcp_slowtmr+0x147>
          pcb->ssthresh = pcb->mss * 2;
  110d42:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110d45:	0f b7 40 34          	movzwl 0x34(%eax),%eax
  110d49:	0f b7 c0             	movzwl %ax,%eax
  110d4c:	01 c0                	add    %eax,%eax
  110d4e:	89 c2                	mov    %eax,%edx
  110d50:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110d53:	66 89 50 4c          	mov    %dx,0x4c(%eax)
        }
        pcb->cwnd = pcb->mss;
  110d57:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110d5a:	0f b7 50 34          	movzwl 0x34(%eax),%edx
  110d5e:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110d61:	66 89 50 4a          	mov    %dx,0x4a(%eax)
        LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_slowtmr: cwnd %u ssthresh %u\n",
                                pcb->cwnd, pcb->ssthresh));
      }
    }
    /* Check if this PCB has stayed too long in FIN-WAIT-2 */
    if (pcb->state == FIN_WAIT_2) {
  110d65:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110d68:	8b 40 10             	mov    0x10(%eax),%eax
  110d6b:	83 f8 06             	cmp    $0x6,%eax
  110d6e:	75 1b                	jne    110d8b <tcp_slowtmr+0x17b>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
  110d70:	8b 15 58 16 14 00    	mov    0x141658,%edx
  110d76:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110d79:	8b 40 2c             	mov    0x2c(%eax),%eax
  110d7c:	89 d1                	mov    %edx,%ecx
  110d7e:	29 c1                	sub    %eax,%ecx
  110d80:	89 c8                	mov    %ecx,%eax
  110d82:	83 f8 28             	cmp    $0x28,%eax
  110d85:	76 04                	jbe    110d8b <tcp_slowtmr+0x17b>
        TCP_FIN_WAIT_TIMEOUT / TCP_SLOW_INTERVAL) {
        ++pcb_remove;
  110d87:	80 45 fe 01          	addb   $0x1,0xfffffffe(%ebp)
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in FIN-WAIT-2\n"));
      }
    }

   /* Check if KEEPALIVE should be sent */
   if((pcb->so_options & SOF_KEEPALIVE) && ((pcb->state == ESTABLISHED) || (pcb->state == CLOSE_WAIT))) {
  110d8b:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110d8e:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  110d92:	0f b7 c0             	movzwl %ax,%eax
  110d95:	83 e0 08             	and    $0x8,%eax
  110d98:	85 c0                	test   %eax,%eax
  110d9a:	0f 84 bf 00 00 00    	je     110e5f <tcp_slowtmr+0x24f>
  110da0:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110da3:	8b 40 10             	mov    0x10(%eax),%eax
  110da6:	83 f8 04             	cmp    $0x4,%eax
  110da9:	74 0f                	je     110dba <tcp_slowtmr+0x1aa>
  110dab:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110dae:	8b 40 10             	mov    0x10(%eax),%eax
  110db1:	83 f8 07             	cmp    $0x7,%eax
  110db4:	0f 85 a5 00 00 00    	jne    110e5f <tcp_slowtmr+0x24f>
      if((u32_t)(tcp_ticks - pcb->tmr) > (pcb->keepalive + TCP_MAXIDLE) / TCP_SLOW_INTERVAL)  {
  110dba:	8b 15 58 16 14 00    	mov    0x141658,%edx
  110dc0:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110dc3:	8b 40 2c             	mov    0x2c(%eax),%eax
  110dc6:	89 d1                	mov    %edx,%ecx
  110dc8:	29 c1                	sub    %eax,%ecx
  110dca:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110dcd:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
  110dd3:	8d 90 b8 4c 0a 00    	lea    0xa4cb8(%eax),%edx
  110dd9:	c7 45 d4 d3 4d 62 10 	movl   $0x10624dd3,0xffffffd4(%ebp)
  110de0:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
  110de3:	f7 e2                	mul    %edx
  110de5:	89 d0                	mov    %edx,%eax
  110de7:	c1 e8 05             	shr    $0x5,%eax
  110dea:	39 c1                	cmp    %eax,%ecx
  110dec:	76 0d                	jbe    110dfb <tcp_slowtmr+0x1eb>
         LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: KEEPALIVE timeout. Aborting connection to %u.%u.%u.%u.\n",
                                 ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                                 ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip)));

         tcp_abort(pcb);
  110dee:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110df1:	89 04 24             	mov    %eax,(%esp)
  110df4:	e8 57 f5 ff ff       	call   110350 <tcp_abort>
  110df9:	eb 64                	jmp    110e5f <tcp_slowtmr+0x24f>
      }
      else if((u32_t)(tcp_ticks - pcb->tmr) > (pcb->keepalive + pcb->keep_cnt * TCP_KEEPINTVL) / TCP_SLOW_INTERVAL) {
  110dfb:	8b 15 58 16 14 00    	mov    0x141658,%edx
  110e01:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110e04:	8b 40 2c             	mov    0x2c(%eax),%eax
  110e07:	89 d1                	mov    %edx,%ecx
  110e09:	29 c1                	sub    %eax,%ecx
  110e0b:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110e0e:	8b 90 94 00 00 00    	mov    0x94(%eax),%edx
  110e14:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110e17:	0f b6 80 98 00 00 00 	movzbl 0x98(%eax),%eax
  110e1e:	0f b6 c0             	movzbl %al,%eax
  110e21:	69 c0 f8 24 01 00    	imul   $0x124f8,%eax,%eax
  110e27:	01 c2                	add    %eax,%edx
  110e29:	c7 45 d4 d3 4d 62 10 	movl   $0x10624dd3,0xffffffd4(%ebp)
  110e30:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
  110e33:	f7 e2                	mul    %edx
  110e35:	89 d0                	mov    %edx,%eax
  110e37:	c1 e8 05             	shr    $0x5,%eax
  110e3a:	39 c1                	cmp    %eax,%ecx
  110e3c:	76 21                	jbe    110e5f <tcp_slowtmr+0x24f>
         tcp_keepalive(pcb);
  110e3e:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110e41:	89 04 24             	mov    %eax,(%esp)
  110e44:	e8 b7 18 00 00       	call   112700 <tcp_keepalive>
         pcb->keep_cnt++;
  110e49:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110e4c:	0f b6 80 98 00 00 00 	movzbl 0x98(%eax),%eax
  110e53:	8d 50 01             	lea    0x1(%eax),%edx
  110e56:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110e59:	88 90 98 00 00 00    	mov    %dl,0x98(%eax)
      }
   }

    /* If this PCB has queued out of sequence data, but has been
       inactive for too long, will drop the data (it will eventually
       be retransmitted). */
#if TCP_QUEUE_OOSEQ    
    if (pcb->ooseq != NULL &&
  110e5f:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110e62:	8b 40 78             	mov    0x78(%eax),%eax
  110e65:	85 c0                	test   %eax,%eax
  110e67:	74 3e                	je     110ea7 <tcp_slowtmr+0x297>
  110e69:	8b 15 58 16 14 00    	mov    0x141658,%edx
  110e6f:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110e72:	8b 40 2c             	mov    0x2c(%eax),%eax
  110e75:	89 d1                	mov    %edx,%ecx
  110e77:	29 c1                	sub    %eax,%ecx
  110e79:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110e7c:	0f b7 40 40          	movzwl 0x40(%eax),%eax
  110e80:	0f b7 d0             	movzwl %ax,%edx
  110e83:	89 d0                	mov    %edx,%eax
  110e85:	01 c0                	add    %eax,%eax
  110e87:	01 d0                	add    %edx,%eax
  110e89:	01 c0                	add    %eax,%eax
  110e8b:	39 c1                	cmp    %eax,%ecx
  110e8d:	72 18                	jb     110ea7 <tcp_slowtmr+0x297>
       (u32_t)tcp_ticks - pcb->tmr >=
       pcb->rto * TCP_OOSEQ_TIMEOUT) {
      tcp_segs_free(pcb->ooseq);
  110e8f:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110e92:	8b 40 78             	mov    0x78(%eax),%eax
  110e95:	89 04 24             	mov    %eax,(%esp)
  110e98:	e8 43 02 00 00       	call   1110e0 <tcp_segs_free>
      pcb->ooseq = NULL;
  110e9d:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110ea0:	c7 40 78 00 00 00 00 	movl   $0x0,0x78(%eax)
      LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_slowtmr: dropping OOSEQ queued data\n"));
    }
#endif /* TCP_QUEUE_OOSEQ */

    /* Check if this PCB has stayed too long in SYN-RCVD */
    if (pcb->state == SYN_RCVD) {
  110ea7:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110eaa:	8b 40 10             	mov    0x10(%eax),%eax
  110ead:	83 f8 03             	cmp    $0x3,%eax
  110eb0:	75 1b                	jne    110ecd <tcp_slowtmr+0x2bd>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
  110eb2:	8b 15 58 16 14 00    	mov    0x141658,%edx
  110eb8:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110ebb:	8b 40 2c             	mov    0x2c(%eax),%eax
  110ebe:	89 d1                	mov    %edx,%ecx
  110ec0:	29 c1                	sub    %eax,%ecx
  110ec2:	89 c8                	mov    %ecx,%eax
  110ec4:	83 f8 28             	cmp    $0x28,%eax
  110ec7:	76 04                	jbe    110ecd <tcp_slowtmr+0x2bd>
   TCP_SYN_RCVD_TIMEOUT / TCP_SLOW_INTERVAL) {
        ++pcb_remove;
  110ec9:	80 45 fe 01          	addb   $0x1,0xfffffffe(%ebp)
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in SYN-RCVD\n"));
      }
    }


    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
  110ecd:	80 7d fe 00          	cmpb   $0x0,0xfffffffe(%ebp)
  110ed1:	74 77                	je     110f4a <tcp_slowtmr+0x33a>
      tcp_pcb_purge(pcb);      
  110ed3:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110ed6:	89 04 24             	mov    %eax,(%esp)
  110ed9:	e8 92 06 00 00       	call   111570 <tcp_pcb_purge>
      /* Remove PCB from tcp_active_pcbs list. */
      if (prev != NULL) {
  110ede:	83 7d f4 00          	cmpl   $0x0,0xfffffff4(%ebp)
  110ee2:	74 0e                	je     110ef2 <tcp_slowtmr+0x2e2>
  LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
        prev->next = pcb->next;
  110ee4:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110ee7:	8b 50 0c             	mov    0xc(%eax),%edx
  110eea:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  110eed:	89 50 0c             	mov    %edx,0xc(%eax)
  110ef0:	eb 0b                	jmp    110efd <tcp_slowtmr+0x2ed>
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
        tcp_active_pcbs = pcb->next;
  110ef2:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110ef5:	8b 40 0c             	mov    0xc(%eax),%eax
  110ef8:	a3 54 16 14 00       	mov    %eax,0x141654
      }

      TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_ABRT);
  110efd:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110f00:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
  110f06:	85 c0                	test   %eax,%eax
  110f08:	74 1c                	je     110f26 <tcp_slowtmr+0x316>
  110f0a:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110f0d:	8b 90 90 00 00 00    	mov    0x90(%eax),%edx
  110f13:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110f16:	8b 40 18             	mov    0x18(%eax),%eax
  110f19:	c7 44 24 04 fd ff ff 	movl   $0xfffffffd,0x4(%esp)
  110f20:	ff 
  110f21:	89 04 24             	mov    %eax,(%esp)
  110f24:	ff d2                	call   *%edx

      pcb2 = pcb->next;
  110f26:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110f29:	8b 40 0c             	mov    0xc(%eax),%eax
  110f2c:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
      memp_free(MEMP_TCP_PCB, pcb);
  110f2f:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110f32:	89 44 24 04          	mov    %eax,0x4(%esp)
  110f36:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  110f3d:	e8 7e db ff ff       	call   10eac0 <memp_free>
      pcb = pcb2;
  110f42:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  110f45:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  110f48:	eb 74                	jmp    110fbe <tcp_slowtmr+0x3ae>
    } else {

      /* We check if we should poll the connection. */
      ++pcb->polltmr;
  110f4a:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110f4d:	0f b6 40 30          	movzbl 0x30(%eax),%eax
  110f51:	8d 50 01             	lea    0x1(%eax),%edx
  110f54:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110f57:	88 50 30             	mov    %dl,0x30(%eax)
      if (pcb->polltmr >= pcb->pollinterval) {
  110f5a:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110f5d:	0f b6 50 30          	movzbl 0x30(%eax),%edx
  110f61:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110f64:	0f b6 40 31          	movzbl 0x31(%eax),%eax
  110f68:	38 c2                	cmp    %al,%dl
  110f6a:	72 43                	jb     110faf <tcp_slowtmr+0x39f>
        pcb->polltmr = 0;
  110f6c:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110f6f:	c6 40 30 00          	movb   $0x0,0x30(%eax)
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: polling application\n"));
        TCP_EVENT_POLL(pcb, err);
  110f73:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110f76:	8b 80 8c 00 00 00    	mov    0x8c(%eax),%eax
  110f7c:	85 c0                	test   %eax,%eax
  110f7e:	74 1e                	je     110f9e <tcp_slowtmr+0x38e>
  110f80:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110f83:	8b 88 8c 00 00 00    	mov    0x8c(%eax),%ecx
  110f89:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110f8c:	8b 50 18             	mov    0x18(%eax),%edx
  110f8f:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110f92:	89 44 24 04          	mov    %eax,0x4(%esp)
  110f96:	89 14 24             	mov    %edx,(%esp)
  110f99:	ff d1                	call   *%ecx
  110f9b:	88 45 ff             	mov    %al,0xffffffff(%ebp)
        if (err == ERR_OK) {
  110f9e:	80 7d ff 00          	cmpb   $0x0,0xffffffff(%ebp)
  110fa2:	75 0b                	jne    110faf <tcp_slowtmr+0x39f>
          tcp_output(pcb);
  110fa4:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110fa7:	89 04 24             	mov    %eax,(%esp)
  110faa:	e8 a1 0e 00 00       	call   111e50 <tcp_output>
        }
      }
      
      prev = pcb;
  110faf:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110fb2:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
      pcb = pcb->next;
  110fb5:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110fb8:	8b 40 0c             	mov    0xc(%eax),%eax
  110fbb:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  110fbe:	83 7d ec 00          	cmpl   $0x0,0xffffffec(%ebp)
  110fc2:	0f 85 73 fc ff ff    	jne    110c3b <tcp_slowtmr+0x2b>
    }
  }

  
  /* Steps through all of the TIME-WAIT PCBs. */
  prev = NULL;    
  110fc8:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
  pcb = tcp_tw_pcbs;
  110fcf:	a1 64 16 14 00       	mov    0x141664,%eax
  110fd4:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  while (pcb != NULL) {
  110fd7:	e9 84 00 00 00       	jmp    111060 <tcp_slowtmr+0x450>
    LWIP_ASSERT("tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
    pcb_remove = 0;
  110fdc:	c6 45 fe 00          	movb   $0x0,0xfffffffe(%ebp)

    /* Check if this PCB has stayed long enough in TIME-WAIT */
    if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
  110fe0:	8b 15 58 16 14 00    	mov    0x141658,%edx
  110fe6:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  110fe9:	8b 40 2c             	mov    0x2c(%eax),%eax
  110fec:	89 d1                	mov    %edx,%ecx
  110fee:	29 c1                	sub    %eax,%ecx
  110ff0:	89 c8                	mov    %ecx,%eax
  110ff2:	3d f0 00 00 00       	cmp    $0xf0,%eax
  110ff7:	76 04                	jbe    110ffd <tcp_slowtmr+0x3ed>
      ++pcb_remove;
  110ff9:	80 45 fe 01          	addb   $0x1,0xfffffffe(%ebp)
    }
    


    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
  110ffd:	80 7d fe 00          	cmpb   $0x0,0xfffffffe(%ebp)
  111001:	74 4e                	je     111051 <tcp_slowtmr+0x441>
      tcp_pcb_purge(pcb);      
  111003:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  111006:	89 04 24             	mov    %eax,(%esp)
  111009:	e8 62 05 00 00       	call   111570 <tcp_pcb_purge>
      /* Remove PCB from tcp_tw_pcbs list. */
      if (prev != NULL) {
  11100e:	83 7d f4 00          	cmpl   $0x0,0xfffffff4(%ebp)
  111012:	74 0e                	je     111022 <tcp_slowtmr+0x412>
  LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_tw_pcbs", pcb != tcp_tw_pcbs);
        prev->next = pcb->next;
  111014:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  111017:	8b 50 0c             	mov    0xc(%eax),%edx
  11101a:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  11101d:	89 50 0c             	mov    %edx,0xc(%eax)
  111020:	eb 0b                	jmp    11102d <tcp_slowtmr+0x41d>
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_tw_pcbs", tcp_tw_pcbs == pcb);
        tcp_tw_pcbs = pcb->next;
  111022:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  111025:	8b 40 0c             	mov    0xc(%eax),%eax
  111028:	a3 64 16 14 00       	mov    %eax,0x141664
      }
      pcb2 = pcb->next;
  11102d:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  111030:	8b 40 0c             	mov    0xc(%eax),%eax
  111033:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
      memp_free(MEMP_TCP_PCB, pcb);
  111036:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  111039:	89 44 24 04          	mov    %eax,0x4(%esp)
  11103d:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  111044:	e8 77 da ff ff       	call   10eac0 <memp_free>
      pcb = pcb2;
  111049:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  11104c:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  11104f:	eb 0f                	jmp    111060 <tcp_slowtmr+0x450>
    } else {
      prev = pcb;
  111051:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  111054:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
      pcb = pcb->next;
  111057:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  11105a:	8b 40 0c             	mov    0xc(%eax),%eax
  11105d:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  111060:	83 7d ec 00          	cmpl   $0x0,0xffffffec(%ebp)
  111064:	0f 85 72 ff ff ff    	jne    110fdc <tcp_slowtmr+0x3cc>
    }
  }
}
  11106a:	c9                   	leave  
  11106b:	c3                   	ret    
  11106c:	8d 74 26 00          	lea    0x0(%esi),%esi

00111070 <tcp_fasttmr>:

/*
 * tcp_fasttmr():
 *
 * Is called every TCP_FAST_INTERVAL (250 ms) and sends delayed ACKs.
 */

void
tcp_fasttmr(void)
{
  111070:	55                   	push   %ebp
  111071:	89 e5                	mov    %esp,%ebp
  111073:	83 ec 18             	sub    $0x18,%esp
  struct tcp_pcb *pcb;

  /* send delayed ACKs */  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  111076:	a1 54 16 14 00       	mov    0x141654,%eax
  11107b:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  11107e:	eb 49                	jmp    1110c9 <tcp_fasttmr+0x59>
    if (pcb->flags & TF_ACK_DELAY) {
  111080:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  111083:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  111087:	0f b6 c0             	movzbl %al,%eax
  11108a:	83 e0 01             	and    $0x1,%eax
  11108d:	84 c0                	test   %al,%al
  11108f:	74 2f                	je     1110c0 <tcp_fasttmr+0x50>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
      tcp_ack_now(pcb);
  111091:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  111094:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  111098:	89 c2                	mov    %eax,%edx
  11109a:	83 ca 02             	or     $0x2,%edx
  11109d:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1110a0:	88 50 20             	mov    %dl,0x20(%eax)
  1110a3:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1110a6:	89 04 24             	mov    %eax,(%esp)
  1110a9:	e8 a2 0d 00 00       	call   111e50 <tcp_output>
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  1110ae:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1110b1:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  1110b5:	89 c2                	mov    %eax,%edx
  1110b7:	83 e2 fc             	and    $0xfffffffc,%edx
  1110ba:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1110bd:	88 50 20             	mov    %dl,0x20(%eax)
  1110c0:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1110c3:	8b 40 0c             	mov    0xc(%eax),%eax
  1110c6:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  1110c9:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  1110cd:	75 b1                	jne    111080 <tcp_fasttmr+0x10>
    }
  }
}
  1110cf:	c9                   	leave  
  1110d0:	c3                   	ret    
  1110d1:	eb 0d                	jmp    1110e0 <tcp_segs_free>
  1110d3:	90                   	nop    
  1110d4:	90                   	nop    
  1110d5:	90                   	nop    
  1110d6:	90                   	nop    
  1110d7:	90                   	nop    
  1110d8:	90                   	nop    
  1110d9:	90                   	nop    
  1110da:	90                   	nop    
  1110db:	90                   	nop    
  1110dc:	90                   	nop    
  1110dd:	90                   	nop    
  1110de:	90                   	nop    
  1110df:	90                   	nop    

001110e0 <tcp_segs_free>:

/*
 * tcp_segs_free():
 *
 * Deallocates a list of TCP segments (tcp_seg structures).
 *
 */

u8_t
tcp_segs_free(struct tcp_seg *seg)
{
  1110e0:	55                   	push   %ebp
  1110e1:	89 e5                	mov    %esp,%ebp
  1110e3:	83 ec 18             	sub    $0x18,%esp
  u8_t count = 0;
  1110e6:	c6 45 fb 00          	movb   $0x0,0xfffffffb(%ebp)
  struct tcp_seg *next;
  while (seg != NULL) {
  1110ea:	eb 1c                	jmp    111108 <tcp_segs_free+0x28>
    next = seg->next;
  1110ec:	8b 45 08             	mov    0x8(%ebp),%eax
  1110ef:	8b 00                	mov    (%eax),%eax
  1110f1:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
    count += tcp_seg_free(seg);
  1110f4:	8b 45 08             	mov    0x8(%ebp),%eax
  1110f7:	89 04 24             	mov    %eax,(%esp)
  1110fa:	e8 21 00 00 00       	call   111120 <tcp_seg_free>
  1110ff:	00 45 fb             	add    %al,0xfffffffb(%ebp)
    seg = next;
  111102:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  111105:	89 45 08             	mov    %eax,0x8(%ebp)
  111108:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  11110c:	75 de                	jne    1110ec <tcp_segs_free+0xc>
  }
  return count;
  11110e:	0f b6 45 fb          	movzbl 0xfffffffb(%ebp),%eax
}
  111112:	c9                   	leave  
  111113:	c3                   	ret    
  111114:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  11111a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

00111120 <tcp_seg_free>:

/*
 * tcp_seg_free():
 *
 * Frees a TCP segment.
 *
 */

u8_t
tcp_seg_free(struct tcp_seg *seg)
{
  111120:	55                   	push   %ebp
  111121:	89 e5                	mov    %esp,%ebp
  111123:	83 ec 18             	sub    $0x18,%esp
  u8_t count = 0;
  111126:	c6 45 ff 00          	movb   $0x0,0xffffffff(%ebp)
  
  if (seg != NULL) {
  11112a:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  11112e:	74 2e                	je     11115e <tcp_seg_free+0x3e>
    if (seg->p != NULL) {
  111130:	8b 45 08             	mov    0x8(%ebp),%eax
  111133:	8b 40 04             	mov    0x4(%eax),%eax
  111136:	85 c0                	test   %eax,%eax
  111138:	74 11                	je     11114b <tcp_seg_free+0x2b>
      count = pbuf_free(seg->p);
  11113a:	8b 45 08             	mov    0x8(%ebp),%eax
  11113d:	8b 40 04             	mov    0x4(%eax),%eax
  111140:	89 04 24             	mov    %eax,(%esp)
  111143:	e8 78 e3 ff ff       	call   10f4c0 <pbuf_free>
  111148:	88 45 ff             	mov    %al,0xffffffff(%ebp)
#if TCP_DEBUG
      seg->p = NULL;
#endif /* TCP_DEBUG */
    }
    memp_free(MEMP_TCP_SEG, seg);
  11114b:	8b 45 08             	mov    0x8(%ebp),%eax
  11114e:	89 44 24 04          	mov    %eax,0x4(%esp)
  111152:	c7 04 24 05 00 00 00 	movl   $0x5,(%esp)
  111159:	e8 62 d9 ff ff       	call   10eac0 <memp_free>
  }
  return count;
  11115e:	0f b6 45 ff          	movzbl 0xffffffff(%ebp),%eax
}
  111162:	c9                   	leave  
  111163:	c3                   	ret    
  111164:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  11116a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

00111170 <tcp_setprio>:

/*
 * tcp_setprio():
 *
 * Sets the priority of a connection.
 *
 */

void
tcp_setprio(struct tcp_pcb *pcb, u8_t prio)
{
  111170:	55                   	push   %ebp
  111171:	89 e5                	mov    %esp,%ebp
  111173:	83 ec 04             	sub    $0x4,%esp
  111176:	8b 45 0c             	mov    0xc(%ebp),%eax
  111179:	88 45 fc             	mov    %al,0xfffffffc(%ebp)
  pcb->prio = prio;
  11117c:	8b 55 08             	mov    0x8(%ebp),%edx
  11117f:	0f b6 45 fc          	movzbl 0xfffffffc(%ebp),%eax
  111183:	88 42 14             	mov    %al,0x14(%edx)
}
  111186:	c9                   	leave  
  111187:	c3                   	ret    
  111188:	90                   	nop    
  111189:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

00111190 <tcp_seg_copy>:
#if TCP_QUEUE_OOSEQ

/*
 * tcp_seg_copy():
 *
 * Returns a copy of the given TCP segment.
 *
 */ 

struct tcp_seg *
tcp_seg_copy(struct tcp_seg *seg)
{
  111190:	55                   	push   %ebp
  111191:	89 e5                	mov    %esp,%ebp
  111193:	83 ec 28             	sub    $0x28,%esp
  struct tcp_seg *cseg;

  cseg = memp_malloc(MEMP_TCP_SEG);
  111196:	c7 04 24 05 00 00 00 	movl   $0x5,(%esp)
  11119d:	e8 2e d8 ff ff       	call   10e9d0 <memp_malloc>
  1111a2:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  if (cseg == NULL) {
  1111a5:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  1111a9:	75 09                	jne    1111b4 <tcp_seg_copy+0x24>
    return NULL;
  1111ab:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  1111b2:	eb 2e                	jmp    1111e2 <tcp_seg_copy+0x52>
  }
  memcpy((char *)cseg, (const char *)seg, sizeof(struct tcp_seg)); 
  1111b4:	8b 45 08             	mov    0x8(%ebp),%eax
  1111b7:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  1111ba:	c7 44 24 08 14 00 00 	movl   $0x14,0x8(%esp)
  1111c1:	00 
  1111c2:	89 44 24 04          	mov    %eax,0x4(%esp)
  1111c6:	89 14 24             	mov    %edx,(%esp)
  1111c9:	e8 c2 4c ff ff       	call   105e90 <memcpy>
  pbuf_ref(cseg->p);
  1111ce:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1111d1:	8b 40 04             	mov    0x4(%eax),%eax
  1111d4:	89 04 24             	mov    %eax,(%esp)
  1111d7:	e8 54 e4 ff ff       	call   10f630 <pbuf_ref>
  return cseg;
  1111dc:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1111df:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  1111e2:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  1111e5:	c9                   	leave  
  1111e6:	c3                   	ret    
  1111e7:	89 f6                	mov    %esi,%esi
  1111e9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

001111f0 <tcp_recv_null>:
#endif

#if LWIP_CALLBACK_API
static err_t
tcp_recv_null(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
  1111f0:	55                   	push   %ebp
  1111f1:	89 e5                	mov    %esp,%ebp
  1111f3:	83 ec 18             	sub    $0x18,%esp
  1111f6:	8b 45 14             	mov    0x14(%ebp),%eax
  1111f9:	88 45 fc             	mov    %al,0xfffffffc(%ebp)
  arg = arg;
  if (p != NULL) {
  1111fc:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  111200:	74 0d                	je     11120f <tcp_recv_null+0x1f>
    pbuf_free(p);
  111202:	8b 45 10             	mov    0x10(%ebp),%eax
  111205:	89 04 24             	mov    %eax,(%esp)
  111208:	e8 b3 e2 ff ff       	call   10f4c0 <pbuf_free>
  11120d:	eb 19                	jmp    111228 <tcp_recv_null+0x38>
  } else if (err == ERR_OK) {
  11120f:	80 7d fc 00          	cmpb   $0x0,0xfffffffc(%ebp)
  111213:	75 13                	jne    111228 <tcp_recv_null+0x38>
    return tcp_close(pcb);
  111215:	8b 45 0c             	mov    0xc(%ebp),%eax
  111218:	89 04 24             	mov    %eax,(%esp)
  11121b:	e8 20 f0 ff ff       	call   110240 <tcp_close>
  111220:	0f be c0             	movsbl %al,%eax
  111223:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  111226:	eb 07                	jmp    11122f <tcp_recv_null+0x3f>
  }
  return ERR_OK;
  111228:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)
  11122f:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
}
  111232:	c9                   	leave  
  111233:	c3                   	ret    
  111234:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  11123a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

00111240 <tcp_kill_prio>:
#endif /* LWIP_CALLBACK_API */

static void
tcp_kill_prio(u8_t prio)
{
  111240:	55                   	push   %ebp
  111241:	89 e5                	mov    %esp,%ebp
  111243:	83 ec 18             	sub    $0x18,%esp
  111246:	8b 45 08             	mov    0x8(%ebp),%eax
  111249:	88 45 ec             	mov    %al,0xffffffec(%ebp)
  struct tcp_pcb *pcb, *inactive;
  u32_t inactivity;
  u8_t mprio;


  mprio = TCP_PRIO_MAX;
  11124c:	c6 45 ff 7f          	movb   $0x7f,0xffffffff(%ebp)
  
  /* We kill the oldest active connection that has lower priority than
     prio. */
  inactivity = 0;
  111250:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)
  inactive = NULL;
  111257:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  11125e:	a1 54 16 14 00       	mov    0x141654,%eax
  111263:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
  111266:	eb 5d                	jmp    1112c5 <tcp_kill_prio+0x85>
    if (pcb->prio <= prio &&
  111268:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  11126b:	0f b6 40 14          	movzbl 0x14(%eax),%eax
  11126f:	3a 45 ec             	cmp    0xffffffec(%ebp),%al
  111272:	77 48                	ja     1112bc <tcp_kill_prio+0x7c>
  111274:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  111277:	0f b6 40 14          	movzbl 0x14(%eax),%eax
  11127b:	3a 45 ff             	cmp    0xffffffff(%ebp),%al
  11127e:	77 3c                	ja     1112bc <tcp_kill_prio+0x7c>
  111280:	8b 15 58 16 14 00    	mov    0x141658,%edx
  111286:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  111289:	8b 40 2c             	mov    0x2c(%eax),%eax
  11128c:	89 d1                	mov    %edx,%ecx
  11128e:	29 c1                	sub    %eax,%ecx
  111290:	89 c8                	mov    %ecx,%eax
  111292:	3b 45 f8             	cmp    0xfffffff8(%ebp),%eax
  111295:	72 25                	jb     1112bc <tcp_kill_prio+0x7c>
       pcb->prio <= mprio &&
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
      inactivity = tcp_ticks - pcb->tmr;
  111297:	8b 15 58 16 14 00    	mov    0x141658,%edx
  11129d:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  1112a0:	8b 40 2c             	mov    0x2c(%eax),%eax
  1112a3:	89 d1                	mov    %edx,%ecx
  1112a5:	29 c1                	sub    %eax,%ecx
  1112a7:	89 c8                	mov    %ecx,%eax
  1112a9:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
      inactive = pcb;
  1112ac:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  1112af:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
      mprio = pcb->prio;
  1112b2:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  1112b5:	0f b6 40 14          	movzbl 0x14(%eax),%eax
  1112b9:	88 45 ff             	mov    %al,0xffffffff(%ebp)
  1112bc:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  1112bf:	8b 40 0c             	mov    0xc(%eax),%eax
  1112c2:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
  1112c5:	83 7d f0 00          	cmpl   $0x0,0xfffffff0(%ebp)
  1112c9:	75 9d                	jne    111268 <tcp_kill_prio+0x28>
    }
  }
  if (inactive != NULL) {
  1112cb:	83 7d f4 00          	cmpl   $0x0,0xfffffff4(%ebp)
  1112cf:	74 0b                	je     1112dc <tcp_kill_prio+0x9c>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_prio: killing oldest PCB 0x%p (%ld)\n",
           (void *)inactive, inactivity));
    tcp_abort(inactive);
  1112d1:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  1112d4:	89 04 24             	mov    %eax,(%esp)
  1112d7:	e8 74 f0 ff ff       	call   110350 <tcp_abort>
  }      
}
  1112dc:	c9                   	leave  
  1112dd:	c3                   	ret    
  1112de:	89 f6                	mov    %esi,%esi

001112e0 <tcp_kill_timewait>:


static void
tcp_kill_timewait(void)
{
  1112e0:	55                   	push   %ebp
  1112e1:	89 e5                	mov    %esp,%ebp
  1112e3:	83 ec 18             	sub    $0x18,%esp
  struct tcp_pcb *pcb, *inactive;
  u32_t inactivity;

  inactivity = 0;
  1112e6:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
  inactive = NULL;
  1112ed:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  1112f4:	a1 64 16 14 00       	mov    0x141664,%eax
  1112f9:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  1112fc:	eb 3b                	jmp    111339 <tcp_kill_timewait+0x59>
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  1112fe:	8b 15 58 16 14 00    	mov    0x141658,%edx
  111304:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  111307:	8b 40 2c             	mov    0x2c(%eax),%eax
  11130a:	89 d1                	mov    %edx,%ecx
  11130c:	29 c1                	sub    %eax,%ecx
  11130e:	89 c8                	mov    %ecx,%eax
  111310:	3b 45 fc             	cmp    0xfffffffc(%ebp),%eax
  111313:	72 1b                	jb     111330 <tcp_kill_timewait+0x50>
      inactivity = tcp_ticks - pcb->tmr;
  111315:	8b 15 58 16 14 00    	mov    0x141658,%edx
  11131b:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  11131e:	8b 40 2c             	mov    0x2c(%eax),%eax
  111321:	89 d1                	mov    %edx,%ecx
  111323:	29 c1                	sub    %eax,%ecx
  111325:	89 c8                	mov    %ecx,%eax
  111327:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
      inactive = pcb;
  11132a:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  11132d:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  111330:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  111333:	8b 40 0c             	mov    0xc(%eax),%eax
  111336:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  111339:	83 7d f4 00          	cmpl   $0x0,0xfffffff4(%ebp)
  11133d:	75 bf                	jne    1112fe <tcp_kill_timewait+0x1e>
    }
  }
  if (inactive != NULL) {
  11133f:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  111343:	74 0b                	je     111350 <tcp_kill_timewait+0x70>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_timewait: killing oldest TIME-WAIT PCB 0x%p (%ld)\n",
           (void *)inactive, inactivity));
    tcp_abort(inactive);
  111345:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  111348:	89 04 24             	mov    %eax,(%esp)
  11134b:	e8 00 f0 ff ff       	call   110350 <tcp_abort>
  }      
}
  111350:	c9                   	leave  
  111351:	c3                   	ret    
  111352:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi
  111359:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00111360 <tcp_alloc>:



struct tcp_pcb *
tcp_alloc(u8_t prio)
{
  111360:	55                   	push   %ebp
  111361:	89 e5                	mov    %esp,%ebp
  111363:	83 ec 28             	sub    $0x28,%esp
  111366:	8b 45 08             	mov    0x8(%ebp),%eax
  111369:	88 45 ec             	mov    %al,0xffffffec(%ebp)
  struct tcp_pcb *pcb;
  u32_t iss;
  
  pcb = memp_malloc(MEMP_TCP_PCB);
  11136c:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  111373:	e8 58 d6 ff ff       	call   10e9d0 <memp_malloc>
  111378:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  if (pcb == NULL) {
  11137b:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  11137f:	75 35                	jne    1113b6 <tcp_alloc+0x56>
    /* Try killing oldest connection in TIME-WAIT. */
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing off oldest TIME-WAIT connection\n"));
    tcp_kill_timewait();
  111381:	e8 5a ff ff ff       	call   1112e0 <tcp_kill_timewait>
    pcb = memp_malloc(MEMP_TCP_PCB);
  111386:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  11138d:	e8 3e d6 ff ff       	call   10e9d0 <memp_malloc>
  111392:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
    if (pcb == NULL) {
  111395:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  111399:	75 1b                	jne    1113b6 <tcp_alloc+0x56>
      tcp_kill_prio(prio);    
  11139b:	0f b6 45 ec          	movzbl 0xffffffec(%ebp),%eax
  11139f:	89 04 24             	mov    %eax,(%esp)
  1113a2:	e8 99 fe ff ff       	call   111240 <tcp_kill_prio>
      pcb = memp_malloc(MEMP_TCP_PCB);
  1113a7:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  1113ae:	e8 1d d6 ff ff       	call   10e9d0 <memp_malloc>
  1113b3:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
    }
  }
  if (pcb != NULL) {
  1113b6:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  1113ba:	0f 84 eb 00 00 00    	je     1114ab <tcp_alloc+0x14b>
    memset(pcb, 0, sizeof(struct tcp_pcb));
  1113c0:	c7 44 24 08 9c 00 00 	movl   $0x9c,0x8(%esp)
  1113c7:	00 
  1113c8:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  1113cf:	00 
  1113d0:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1113d3:	89 04 24             	mov    %eax,(%esp)
  1113d6:	e8 f5 4a ff ff       	call   105ed0 <memset>
    pcb->prio = TCP_PRIO_NORMAL;
  1113db:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1113de:	c6 40 14 40          	movb   $0x40,0x14(%eax)
    pcb->snd_buf = TCP_SND_BUF;
  1113e2:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1113e5:	66 c7 40 6a 00 08    	movw   $0x800,0x6a(%eax)
    pcb->snd_queuelen = 0;
  1113eb:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1113ee:	c6 40 6c 00          	movb   $0x0,0x6c(%eax)
    pcb->rcv_wnd = TCP_WND;
  1113f2:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1113f5:	66 c7 40 28 00 20    	movw   $0x2000,0x28(%eax)
    pcb->tos = 0;
  1113fb:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1113fe:	c6 40 0a 00          	movb   $0x0,0xa(%eax)
    pcb->ttl = TCP_TTL;
  111402:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  111405:	c6 40 0b ff          	movb   $0xff,0xb(%eax)
    pcb->mss = TCP_MSS;
  111409:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  11140c:	66 c7 40 34 00 02    	movw   $0x200,0x34(%eax)
    pcb->rto = 3000 / TCP_SLOW_INTERVAL;
  111412:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  111415:	66 c7 40 40 06 00    	movw   $0x6,0x40(%eax)
    pcb->sa = 0;
  11141b:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  11141e:	66 c7 40 3c 00 00    	movw   $0x0,0x3c(%eax)
    pcb->sv = 3000 / TCP_SLOW_INTERVAL;
  111424:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  111427:	66 c7 40 3e 06 00    	movw   $0x6,0x3e(%eax)
    pcb->rtime = 0;
  11142d:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  111430:	66 c7 40 32 00 00    	movw   $0x0,0x32(%eax)
    pcb->cwnd = 1;
  111436:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  111439:	66 c7 40 4a 01 00    	movw   $0x1,0x4a(%eax)
    iss = tcp_next_iss();
  11143f:	e8 7c 02 00 00       	call   1116c0 <tcp_next_iss>
  111444:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
    pcb->snd_wl2 = iss;
  111447:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  11144a:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  11144d:	89 42 60             	mov    %eax,0x60(%edx)
    pcb->snd_nxt = iss;
  111450:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  111453:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  111456:	89 42 50             	mov    %eax,0x50(%edx)
    pcb->snd_max = iss;
  111459:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  11145c:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  11145f:	89 42 54             	mov    %eax,0x54(%edx)
    pcb->lastack = iss;
  111462:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  111465:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  111468:	89 42 44             	mov    %eax,0x44(%edx)
    pcb->snd_lbb = iss;   
  11146b:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  11146e:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  111471:	89 42 64             	mov    %eax,0x64(%edx)
    pcb->tmr = tcp_ticks;
  111474:	8b 15 58 16 14 00    	mov    0x141658,%edx
  11147a:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  11147d:	89 50 2c             	mov    %edx,0x2c(%eax)

    pcb->polltmr = 0;
  111480:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  111483:	c6 40 30 00          	movb   $0x0,0x30(%eax)

#if LWIP_CALLBACK_API
    pcb->recv = tcp_recv_null;
  111487:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  11148a:	c7 80 80 00 00 00 f0 	movl   $0x1111f0,0x80(%eax)
  111491:	11 11 00 
#endif /* LWIP_CALLBACK_API */  
    
    /* Init KEEPALIVE timer */
    pcb->keepalive = TCP_KEEPDEFAULT;
  111494:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  111497:	c7 80 94 00 00 00 00 	movl   $0x6ddd00,0x94(%eax)
  11149e:	dd 6d 00 
    pcb->keep_cnt = 0;
  1114a1:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1114a4:	c6 80 98 00 00 00 00 	movb   $0x0,0x98(%eax)
  }
  return pcb;
  1114ab:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
}
  1114ae:	c9                   	leave  
  1114af:	c3                   	ret    

001114b0 <tcp_new>:

/*
 * tcp_new():
 *
 * Creates a new TCP protocol control block but doesn't place it on
 * any of the TCP PCB lists.
 *
 */

struct tcp_pcb *
tcp_new(void)
{
  1114b0:	55                   	push   %ebp
  1114b1:	89 e5                	mov    %esp,%ebp
  1114b3:	83 ec 08             	sub    $0x8,%esp
  return tcp_alloc(TCP_PRIO_NORMAL);
  1114b6:	c7 04 24 40 00 00 00 	movl   $0x40,(%esp)
  1114bd:	e8 9e fe ff ff       	call   111360 <tcp_alloc>
}
  1114c2:	c9                   	leave  
  1114c3:	c3                   	ret    
  1114c4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  1114ca:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

001114d0 <tcp_arg>:

/*
 * tcp_arg():
 *
 * Used to specify the argument that should be passed callback
 * functions.
 *
 */ 

void
tcp_arg(struct tcp_pcb *pcb, void *arg)
{  
  1114d0:	55                   	push   %ebp
  1114d1:	89 e5                	mov    %esp,%ebp
  pcb->callback_arg = arg;
  1114d3:	8b 55 08             	mov    0x8(%ebp),%edx
  1114d6:	8b 45 0c             	mov    0xc(%ebp),%eax
  1114d9:	89 42 18             	mov    %eax,0x18(%edx)
}
  1114dc:	5d                   	pop    %ebp
  1114dd:	c3                   	ret    
  1114de:	89 f6                	mov    %esi,%esi

001114e0 <tcp_recv>:
#if LWIP_CALLBACK_API

/*
 * tcp_recv():
 *
 * Used to specify the function that should be called when a TCP
 * connection receives data.
 *
 */ 

void
tcp_recv(struct tcp_pcb *pcb,
   err_t (* recv)(void *arg, struct tcp_pcb *tpcb, struct pbuf *p, err_t err))
{
  1114e0:	55                   	push   %ebp
  1114e1:	89 e5                	mov    %esp,%ebp
  pcb->recv = recv;
  1114e3:	8b 55 08             	mov    0x8(%ebp),%edx
  1114e6:	8b 45 0c             	mov    0xc(%ebp),%eax
  1114e9:	89 82 80 00 00 00    	mov    %eax,0x80(%edx)
}
  1114ef:	5d                   	pop    %ebp
  1114f0:	c3                   	ret    
  1114f1:	eb 0d                	jmp    111500 <tcp_sent>
  1114f3:	90                   	nop    
  1114f4:	90                   	nop    
  1114f5:	90                   	nop    
  1114f6:	90                   	nop    
  1114f7:	90                   	nop    
  1114f8:	90                   	nop    
  1114f9:	90                   	nop    
  1114fa:	90                   	nop    
  1114fb:	90                   	nop    
  1114fc:	90                   	nop    
  1114fd:	90                   	nop    
  1114fe:	90                   	nop    
  1114ff:	90                   	nop    

00111500 <tcp_sent>:

/*
 * tcp_sent():
 *
 * Used to specify the function that should be called when TCP data
 * has been successfully delivered to the remote host.
 *
 */ 

void
tcp_sent(struct tcp_pcb *pcb,
   err_t (* sent)(void *arg, struct tcp_pcb *tpcb, u16_t len))
{
  111500:	55                   	push   %ebp
  111501:	89 e5                	mov    %esp,%ebp
  pcb->sent = sent;
  111503:	8b 55 08             	mov    0x8(%ebp),%edx
  111506:	8b 45 0c             	mov    0xc(%ebp),%eax
  111509:	89 42 7c             	mov    %eax,0x7c(%edx)
}
  11150c:	5d                   	pop    %ebp
  11150d:	c3                   	ret    
  11150e:	89 f6                	mov    %esi,%esi

00111510 <tcp_err>:

/*
 * tcp_err():
 *
 * Used to specify the function that should be called when a fatal error
 * has occured on the connection.
 *
 */ 

void
tcp_err(struct tcp_pcb *pcb,
   void (* errf)(void *arg, err_t err))
{
  111510:	55                   	push   %ebp
  111511:	89 e5                	mov    %esp,%ebp
  pcb->errf = errf;
  111513:	8b 55 08             	mov    0x8(%ebp),%edx
  111516:	8b 45 0c             	mov    0xc(%ebp),%eax
  111519:	89 82 90 00 00 00    	mov    %eax,0x90(%edx)
}
  11151f:	5d                   	pop    %ebp
  111520:	c3                   	ret    
  111521:	eb 0d                	jmp    111530 <tcp_accept>
  111523:	90                   	nop    
  111524:	90                   	nop    
  111525:	90                   	nop    
  111526:	90                   	nop    
  111527:	90                   	nop    
  111528:	90                   	nop    
  111529:	90                   	nop    
  11152a:	90                   	nop    
  11152b:	90                   	nop    
  11152c:	90                   	nop    
  11152d:	90                   	nop    
  11152e:	90                   	nop    
  11152f:	90                   	nop    

00111530 <tcp_accept>:

/*
 * tcp_accept():
 *
 * Used for specifying the function that should be called when a
 * LISTENing connection has been connected to another host.
 *
 */ 

void
tcp_accept(struct tcp_pcb *pcb,
     err_t (* accept)(void *arg, struct tcp_pcb *newpcb, err_t err))
{
  111530:	55                   	push   %ebp
  111531:	89 e5                	mov    %esp,%ebp
  ((struct tcp_pcb_listen *)pcb)->accept = accept;
  111533:	8b 55 08             	mov    0x8(%ebp),%edx
  111536:	8b 45 0c             	mov    0xc(%ebp),%eax
  111539:	89 42 20             	mov    %eax,0x20(%edx)
}
  11153c:	5d                   	pop    %ebp
  11153d:	c3                   	ret    
  11153e:	89 f6                	mov    %esi,%esi

00111540 <tcp_poll>:
#endif /* LWIP_CALLBACK_API */


/*
 * tcp_poll():
 *
 * Used to specify the function that should be called periodically
 * from TCP. The interval is specified in terms of the TCP coarse
 * timer interval, which is called twice a second.
 *
 */ 

void
tcp_poll(struct tcp_pcb *pcb,
   err_t (* poll)(void *arg, struct tcp_pcb *tpcb), u8_t interval)
{
  111540:	55                   	push   %ebp
  111541:	89 e5                	mov    %esp,%ebp
  111543:	83 ec 04             	sub    $0x4,%esp
  111546:	8b 45 10             	mov    0x10(%ebp),%eax
  111549:	88 45 fc             	mov    %al,0xfffffffc(%ebp)
#if LWIP_CALLBACK_API
  pcb->poll = poll;
  11154c:	8b 55 08             	mov    0x8(%ebp),%edx
  11154f:	8b 45 0c             	mov    0xc(%ebp),%eax
  111552:	89 82 8c 00 00 00    	mov    %eax,0x8c(%edx)
#endif /* LWIP_CALLBACK_API */  
  pcb->pollinterval = interval;
  111558:	8b 55 08             	mov    0x8(%ebp),%edx
  11155b:	0f b6 45 fc          	movzbl 0xfffffffc(%ebp),%eax
  11155f:	88 42 31             	mov    %al,0x31(%edx)
}
  111562:	c9                   	leave  
  111563:	c3                   	ret    
  111564:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  11156a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

00111570 <tcp_pcb_purge>:

/*
 * tcp_pcb_purge():
 *
 * Purges a TCP PCB. Removes any buffered data and frees the buffer memory.
 *
 */

void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
  111570:	55                   	push   %ebp
  111571:	89 e5                	mov    %esp,%ebp
  111573:	83 ec 08             	sub    $0x8,%esp
  if (pcb->state != CLOSED &&
  111576:	8b 45 08             	mov    0x8(%ebp),%eax
  111579:	8b 40 10             	mov    0x10(%eax),%eax
  11157c:	85 c0                	test   %eax,%eax
  11157e:	74 60                	je     1115e0 <tcp_pcb_purge+0x70>
  111580:	8b 45 08             	mov    0x8(%ebp),%eax
  111583:	8b 40 10             	mov    0x10(%eax),%eax
  111586:	83 f8 0a             	cmp    $0xa,%eax
  111589:	74 55                	je     1115e0 <tcp_pcb_purge+0x70>
  11158b:	8b 45 08             	mov    0x8(%ebp),%eax
  11158e:	8b 40 10             	mov    0x10(%eax),%eax
  111591:	83 f8 01             	cmp    $0x1,%eax
  111594:	74 4a                	je     1115e0 <tcp_pcb_purge+0x70>
     pcb->state != TIME_WAIT &&
     pcb->state != LISTEN) {

    LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge\n"));
    
    if (pcb->unsent != NULL) {    
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: not all data sent\n"));
    }
    if (pcb->unacked != NULL) {    
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->unacked\n"));
    }
#if TCP_QUEUE_OOSEQ /* LW */
    if (pcb->ooseq != NULL) {    
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->ooseq\n"));
    }
    
    tcp_segs_free(pcb->ooseq);
  111596:	8b 45 08             	mov    0x8(%ebp),%eax
  111599:	8b 40 78             	mov    0x78(%eax),%eax
  11159c:	89 04 24             	mov    %eax,(%esp)
  11159f:	e8 3c fb ff ff       	call   1110e0 <tcp_segs_free>
    pcb->ooseq = NULL;
  1115a4:	8b 45 08             	mov    0x8(%ebp),%eax
  1115a7:	c7 40 78 00 00 00 00 	movl   $0x0,0x78(%eax)
#endif /* TCP_QUEUE_OOSEQ */
    tcp_segs_free(pcb->unsent);
  1115ae:	8b 45 08             	mov    0x8(%ebp),%eax
  1115b1:	8b 40 70             	mov    0x70(%eax),%eax
  1115b4:	89 04 24             	mov    %eax,(%esp)
  1115b7:	e8 24 fb ff ff       	call   1110e0 <tcp_segs_free>
    tcp_segs_free(pcb->unacked);
  1115bc:	8b 45 08             	mov    0x8(%ebp),%eax
  1115bf:	8b 40 74             	mov    0x74(%eax),%eax
  1115c2:	89 04 24             	mov    %eax,(%esp)
  1115c5:	e8 16 fb ff ff       	call   1110e0 <tcp_segs_free>
    pcb->unacked = pcb->unsent = NULL;
  1115ca:	8b 45 08             	mov    0x8(%ebp),%eax
  1115cd:	c7 40 70 00 00 00 00 	movl   $0x0,0x70(%eax)
  1115d4:	8b 45 08             	mov    0x8(%ebp),%eax
  1115d7:	8b 50 70             	mov    0x70(%eax),%edx
  1115da:	8b 45 08             	mov    0x8(%ebp),%eax
  1115dd:	89 50 74             	mov    %edx,0x74(%eax)
  }
}
  1115e0:	c9                   	leave  
  1115e1:	c3                   	ret    
  1115e2:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi
  1115e9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

001115f0 <tcp_pcb_remove>:

/*
 * tcp_pcb_remove():
 *
 * Purges the PCB and removes it from a PCB list. Any delayed ACKs are sent first.
 *
 */

void
tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
{
  1115f0:	55                   	push   %ebp
  1115f1:	89 e5                	mov    %esp,%ebp
  1115f3:	83 ec 08             	sub    $0x8,%esp
  TCP_RMV(pcblist, pcb);
  1115f6:	8b 45 08             	mov    0x8(%ebp),%eax
  1115f9:	8b 00                	mov    (%eax),%eax
  1115fb:	3b 45 0c             	cmp    0xc(%ebp),%eax
  1115fe:	75 0f                	jne    11160f <tcp_pcb_remove+0x1f>
  111600:	8b 45 08             	mov    0x8(%ebp),%eax
  111603:	8b 00                	mov    (%eax),%eax
  111605:	8b 50 0c             	mov    0xc(%eax),%edx
  111608:	8b 45 08             	mov    0x8(%ebp),%eax
  11160b:	89 10                	mov    %edx,(%eax)
  11160d:	eb 4b                	jmp    11165a <tcp_pcb_remove+0x6a>
  11160f:	8b 45 08             	mov    0x8(%ebp),%eax
  111612:	8b 00                	mov    (%eax),%eax
  111614:	a3 60 16 14 00       	mov    %eax,0x141660
  111619:	eb 36                	jmp    111651 <tcp_pcb_remove+0x61>
  11161b:	a1 60 16 14 00       	mov    0x141660,%eax
  111620:	8b 40 0c             	mov    0xc(%eax),%eax
  111623:	85 c0                	test   %eax,%eax
  111625:	74 1d                	je     111644 <tcp_pcb_remove+0x54>
  111627:	a1 60 16 14 00       	mov    0x141660,%eax
  11162c:	8b 40 0c             	mov    0xc(%eax),%eax
  11162f:	3b 45 0c             	cmp    0xc(%ebp),%eax
  111632:	75 10                	jne    111644 <tcp_pcb_remove+0x54>
  111634:	a1 60 16 14 00       	mov    0x141660,%eax
  111639:	8b 55 0c             	mov    0xc(%ebp),%edx
  11163c:	8b 52 0c             	mov    0xc(%edx),%edx
  11163f:	89 50 0c             	mov    %edx,0xc(%eax)
  111642:	eb 16                	jmp    11165a <tcp_pcb_remove+0x6a>
  111644:	a1 60 16 14 00       	mov    0x141660,%eax
  111649:	8b 40 0c             	mov    0xc(%eax),%eax
  11164c:	a3 60 16 14 00       	mov    %eax,0x141660
  111651:	a1 60 16 14 00       	mov    0x141660,%eax
  111656:	85 c0                	test   %eax,%eax
  111658:	75 c1                	jne    11161b <tcp_pcb_remove+0x2b>
  11165a:	8b 45 0c             	mov    0xc(%ebp),%eax
  11165d:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)

  tcp_pcb_purge(pcb);
  111664:	8b 45 0c             	mov    0xc(%ebp),%eax
  111667:	89 04 24             	mov    %eax,(%esp)
  11166a:	e8 01 ff ff ff       	call   111570 <tcp_pcb_purge>
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
  11166f:	8b 45 0c             	mov    0xc(%ebp),%eax
  111672:	8b 40 10             	mov    0x10(%eax),%eax
  111675:	83 f8 0a             	cmp    $0xa,%eax
  111678:	74 39                	je     1116b3 <tcp_pcb_remove+0xc3>
  11167a:	8b 45 0c             	mov    0xc(%ebp),%eax
  11167d:	8b 40 10             	mov    0x10(%eax),%eax
  111680:	83 f8 01             	cmp    $0x1,%eax
  111683:	74 2e                	je     1116b3 <tcp_pcb_remove+0xc3>
  111685:	8b 45 0c             	mov    0xc(%ebp),%eax
  111688:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  11168c:	0f b6 c0             	movzbl %al,%eax
  11168f:	83 e0 01             	and    $0x1,%eax
  111692:	84 c0                	test   %al,%al
  111694:	74 1d                	je     1116b3 <tcp_pcb_remove+0xc3>
     pcb->state != LISTEN &&
     pcb->flags & TF_ACK_DELAY) {
    pcb->flags |= TF_ACK_NOW;
  111696:	8b 45 0c             	mov    0xc(%ebp),%eax
  111699:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  11169d:	89 c2                	mov    %eax,%edx
  11169f:	83 ca 02             	or     $0x2,%edx
  1116a2:	8b 45 0c             	mov    0xc(%ebp),%eax
  1116a5:	88 50 20             	mov    %dl,0x20(%eax)
    tcp_output(pcb);
  1116a8:	8b 45 0c             	mov    0xc(%ebp),%eax
  1116ab:	89 04 24             	mov    %eax,(%esp)
  1116ae:	e8 9d 07 00 00       	call   111e50 <tcp_output>
  }  
  pcb->state = CLOSED;
  1116b3:	8b 45 0c             	mov    0xc(%ebp),%eax
  1116b6:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)

  LWIP_ASSERT("tcp_pcb_remove: tcp_pcbs_sane()", tcp_pcbs_sane());
}
  1116bd:	c9                   	leave  
  1116be:	c3                   	ret    
  1116bf:	90                   	nop    

001116c0 <tcp_next_iss>:

/*
 * tcp_next_iss():
 *
 * Calculates a new initial sequence number for new connections.
 *
 */

u32_t
tcp_next_iss(void)
{
  1116c0:	55                   	push   %ebp
  1116c1:	89 e5                	mov    %esp,%ebp
  static u32_t iss = 6510;
  
  iss += tcp_ticks;       /* XXX */
  1116c3:	8b 15 a4 cb 11 00    	mov    0x11cba4,%edx
  1116c9:	a1 58 16 14 00       	mov    0x141658,%eax
  1116ce:	8d 04 02             	lea    (%edx,%eax,1),%eax
  1116d1:	a3 a4 cb 11 00       	mov    %eax,0x11cba4
  return iss;
  1116d6:	a1 a4 cb 11 00       	mov    0x11cba4,%eax
}
  1116db:	5d                   	pop    %ebp
  1116dc:	c3                   	ret    
  1116dd:	90                   	nop    
  1116de:	90                   	nop    
  1116df:	90                   	nop    

001116e0 <tcp_send_ctrl>:
static void tcp_output_segment(struct tcp_seg *seg, struct tcp_pcb *pcb);

err_t
tcp_send_ctrl(struct tcp_pcb *pcb, u8_t flags)
{
  1116e0:	55                   	push   %ebp
  1116e1:	89 e5                	mov    %esp,%ebp
  1116e3:	83 ec 28             	sub    $0x28,%esp
  1116e6:	8b 45 0c             	mov    0xc(%ebp),%eax
  1116e9:	88 45 fc             	mov    %al,0xfffffffc(%ebp)
  return tcp_enqueue(pcb, NULL, 0, flags, 1, NULL, 0);
  1116ec:	0f b6 45 fc          	movzbl 0xfffffffc(%ebp),%eax
  1116f0:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
  1116f7:	00 
  1116f8:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
  1116ff:	00 
  111700:	c7 44 24 10 01 00 00 	movl   $0x1,0x10(%esp)
  111707:	00 
  111708:	89 44 24 0c          	mov    %eax,0xc(%esp)
  11170c:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  111713:	00 
  111714:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  11171b:	00 
  11171c:	8b 45 08             	mov    0x8(%ebp),%eax
  11171f:	89 04 24             	mov    %eax,(%esp)
  111722:	e8 a9 00 00 00       	call   1117d0 <tcp_enqueue>
  111727:	0f be c0             	movsbl %al,%eax

}
  11172a:	c9                   	leave  
  11172b:	c3                   	ret    
  11172c:	8d 74 26 00          	lea    0x0(%esi),%esi

00111730 <tcp_write>:

/*
 * NB. tcp_write() enqueues data for sending, but does not send it
 * straight away.  It waits in the expectation of more data being sent
 * soon (as it can send them more efficiently by combining them
 * together).  To prompt the system to send data now, call
 * tcp_output() after calling tcp_write().
 */

err_t
tcp_write(struct tcp_pcb *pcb, const void *arg, u16_t len, u8_t copy)
{
  111730:	55                   	push   %ebp
  111731:	89 e5                	mov    %esp,%ebp
  111733:	83 ec 28             	sub    $0x28,%esp
  111736:	8b 45 10             	mov    0x10(%ebp),%eax
  111739:	8b 55 14             	mov    0x14(%ebp),%edx
  11173c:	66 89 45 fc          	mov    %ax,0xfffffffc(%ebp)
  111740:	88 55 f8             	mov    %dl,0xfffffff8(%ebp)
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, arg=%p, len=%u, copy=%d)\n", (void *)pcb,
    arg, len, (unsigned int)copy));
  if (pcb->state == SYN_SENT ||
  111743:	8b 45 08             	mov    0x8(%ebp),%eax
  111746:	8b 40 10             	mov    0x10(%eax),%eax
  111749:	83 f8 02             	cmp    $0x2,%eax
  11174c:	74 21                	je     11176f <tcp_write+0x3f>
  11174e:	8b 45 08             	mov    0x8(%ebp),%eax
  111751:	8b 40 10             	mov    0x10(%eax),%eax
  111754:	83 f8 03             	cmp    $0x3,%eax
  111757:	74 16                	je     11176f <tcp_write+0x3f>
  111759:	8b 45 08             	mov    0x8(%ebp),%eax
  11175c:	8b 40 10             	mov    0x10(%eax),%eax
  11175f:	83 f8 04             	cmp    $0x4,%eax
  111762:	74 0b                	je     11176f <tcp_write+0x3f>
  111764:	8b 45 08             	mov    0x8(%ebp),%eax
  111767:	8b 40 10             	mov    0x10(%eax),%eax
  11176a:	83 f8 07             	cmp    $0x7,%eax
  11176d:	75 52                	jne    1117c1 <tcp_write+0x91>
     pcb->state == SYN_RCVD ||
     pcb->state == ESTABLISHED ||
     pcb->state == CLOSE_WAIT) {
    if (len > 0) {
  11176f:	66 83 7d fc 00       	cmpw   $0x0,0xfffffffc(%ebp)
  111774:	74 42                	je     1117b8 <tcp_write+0x88>
      return tcp_enqueue(pcb, (void *)arg, len, 0, copy, NULL, 0);
  111776:	0f b6 45 f8          	movzbl 0xfffffff8(%ebp),%eax
  11177a:	0f b7 55 fc          	movzwl 0xfffffffc(%ebp),%edx
  11177e:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
  111785:	00 
  111786:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
  11178d:	00 
  11178e:	89 44 24 10          	mov    %eax,0x10(%esp)
  111792:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  111799:	00 
  11179a:	89 54 24 08          	mov    %edx,0x8(%esp)
  11179e:	8b 45 0c             	mov    0xc(%ebp),%eax
  1117a1:	89 44 24 04          	mov    %eax,0x4(%esp)
  1117a5:	8b 45 08             	mov    0x8(%ebp),%eax
  1117a8:	89 04 24             	mov    %eax,(%esp)
  1117ab:	e8 20 00 00 00       	call   1117d0 <tcp_enqueue>
  1117b0:	0f be c0             	movsbl %al,%eax
  1117b3:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  1117b6:	eb 10                	jmp    1117c8 <tcp_write+0x98>
    }
    return ERR_OK;
  1117b8:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
  1117bf:	eb 07                	jmp    1117c8 <tcp_write+0x98>
  } else {
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | DBG_STATE | 3, ("tcp_write() called in invalid state\n"));
    return ERR_CONN;
  1117c1:	c7 45 f4 fa ff ff ff 	movl   $0xfffffffa,0xfffffff4(%ebp)
  1117c8:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  }
}
  1117cb:	c9                   	leave  
  1117cc:	c3                   	ret    
  1117cd:	8d 76 00             	lea    0x0(%esi),%esi

001117d0 <tcp_enqueue>:

err_t
tcp_enqueue(struct tcp_pcb *pcb, void *arg, u16_t len,
      u8_t flags, u8_t copy,
            u8_t *optdata, u8_t optlen)
{
  1117d0:	55                   	push   %ebp
  1117d1:	89 e5                	mov    %esp,%ebp
  1117d3:	56                   	push   %esi
  1117d4:	53                   	push   %ebx
  1117d5:	83 ec 60             	sub    $0x60,%esp
  1117d8:	8b 45 10             	mov    0x10(%ebp),%eax
  1117db:	8b 55 14             	mov    0x14(%ebp),%edx
  1117de:	8b 4d 18             	mov    0x18(%ebp),%ecx
  1117e1:	8b 5d 20             	mov    0x20(%ebp),%ebx
  1117e4:	66 89 45 c4          	mov    %ax,0xffffffc4(%ebp)
  1117e8:	88 55 c0             	mov    %dl,0xffffffc0(%ebp)
  1117eb:	88 4d bc             	mov    %cl,0xffffffbc(%ebp)
  1117ee:	88 5d b8             	mov    %bl,0xffffffb8(%ebp)
  struct pbuf *p;
  struct tcp_seg *seg, *useg, *queue;
  u32_t left, seqno;
  u16_t seglen;
  void *ptr;
  u8_t queuelen;

  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_enqueue(pcb=%p, arg=%p, len=%u, flags=%x, copy=%u)\n",
    (void *)pcb, arg, len, (unsigned int)flags, (unsigned int)copy));
  left = len;
  1117f1:	0f b7 45 c4          	movzwl 0xffffffc4(%ebp),%eax
  1117f5:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
  ptr = arg;
  1117f8:	8b 45 0c             	mov    0xc(%ebp),%eax
  1117fb:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
  /* fail on too much data */
  if (len > pcb->snd_buf) {
  1117fe:	8b 45 08             	mov    0x8(%ebp),%eax
  111801:	0f b7 40 6a          	movzwl 0x6a(%eax),%eax
  111805:	66 3b 45 c4          	cmp    0xffffffc4(%ebp),%ax
  111809:	73 0c                	jae    111817 <tcp_enqueue+0x47>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue: too much data (len=%u > snd_buf=%u)\n", len, pcb->snd_buf));
    return ERR_MEM;
  11180b:	c7 45 a8 ff ff ff ff 	movl   $0xffffffff,0xffffffa8(%ebp)
  111812:	e9 28 06 00 00       	jmp    111e3f <tcp_enqueue+0x66f>
  }

  /* seqno will be the sequence number of the first segment enqueued
   * by the call to this function. */
  seqno = pcb->snd_lbb;
  111817:	8b 45 08             	mov    0x8(%ebp),%eax
  11181a:	8b 40 64             	mov    0x64(%eax),%eax
  11181d:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)

  queue = NULL;
  111820:	c7 45 e0 00 00 00 00 	movl   $0x0,0xffffffe0(%ebp)
  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue: queuelen: %u\n", (unsigned int)pcb->snd_queuelen));

  /* Check if the queue length exceeds the configured maximum queue
   * length. If so, we return an error. */
  queuelen = pcb->snd_queuelen;
  111827:	8b 45 08             	mov    0x8(%ebp),%eax
  11182a:	0f b6 40 6c          	movzbl 0x6c(%eax),%eax
  11182e:	88 45 f7             	mov    %al,0xfffffff7(%ebp)
  if (queuelen >= TCP_SND_QUEUELEN) {
  111831:	80 7d f7 3f          	cmpb   $0x3f,0xfffffff7(%ebp)
  111835:	76 05                	jbe    11183c <tcp_enqueue+0x6c>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue: too long queue %u (max %u)\n", queuelen, TCP_SND_QUEUELEN));
    goto memerr;
  111837:	e9 d0 05 00 00       	jmp    111e0c <tcp_enqueue+0x63c>
  }

  if (pcb->snd_queuelen != 0) {
  11183c:	8b 45 08             	mov    0x8(%ebp),%eax
  11183f:	0f b6 40 6c          	movzbl 0x6c(%eax),%eax
  111843:	84 c0                	test   %al,%al
  111845:	74 00                	je     111847 <tcp_enqueue+0x77>
    LWIP_ASSERT("tcp_enqueue: valid queue length", pcb->unacked != NULL ||
    pcb->unsent != NULL);
  }

  seg = useg = NULL;
  111847:	c7 45 dc 00 00 00 00 	movl   $0x0,0xffffffdc(%ebp)
  11184e:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  111851:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
  seglen = 0;
  111854:	66 c7 45 ee 00 00    	movw   $0x0,0xffffffee(%ebp)

  /* First, break up the data into segments and tuck them together in
   * the local "queue" variable. */
  while (queue == NULL || left > 0) {
  11185a:	e9 72 03 00 00       	jmp    111bd1 <tcp_enqueue+0x401>

    /* The segment length should be the MSS if the data to be enqueued
     * is larger than the MSS. */
    seglen = left > pcb->mss? pcb->mss: left;
  11185f:	8b 45 08             	mov    0x8(%ebp),%eax
  111862:	0f b7 40 34          	movzwl 0x34(%eax),%eax
  111866:	0f b7 c0             	movzwl %ax,%eax
  111869:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
  11186c:	89 55 a4             	mov    %edx,0xffffffa4(%ebp)
  11186f:	89 45 ac             	mov    %eax,0xffffffac(%ebp)
  111872:	8b 45 a4             	mov    0xffffffa4(%ebp),%eax
  111875:	39 45 ac             	cmp    %eax,0xffffffac(%ebp)
  111878:	76 06                	jbe    111880 <tcp_enqueue+0xb0>
  11187a:	8b 55 a4             	mov    0xffffffa4(%ebp),%edx
  11187d:	89 55 ac             	mov    %edx,0xffffffac(%ebp)
  111880:	0f b7 45 ac          	movzwl 0xffffffac(%ebp),%eax
  111884:	66 89 45 ee          	mov    %ax,0xffffffee(%ebp)

    /* Allocate memory for tcp_seg, and fill in fields. */
    seg = memp_malloc(MEMP_TCP_SEG);
  111888:	c7 04 24 05 00 00 00 	movl   $0x5,(%esp)
  11188f:	e8 3c d1 ff ff       	call   10e9d0 <memp_malloc>
  111894:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
    if (seg == NULL) {
  111897:	83 7d d8 00          	cmpl   $0x0,0xffffffd8(%ebp)
  11189b:	75 05                	jne    1118a2 <tcp_enqueue+0xd2>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: could not allocate memory for tcp_seg\n"));
      goto memerr;
  11189d:	e9 6a 05 00 00       	jmp    111e0c <tcp_enqueue+0x63c>
    }
    seg->next = NULL;
  1118a2:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  1118a5:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    seg->p = NULL;
  1118ab:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  1118ae:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)

    if (queue == NULL) {
  1118b5:	83 7d e0 00          	cmpl   $0x0,0xffffffe0(%ebp)
  1118b9:	75 0e                	jne    1118c9 <tcp_enqueue+0xf9>
      useg = queue = seg;
  1118bb:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  1118be:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
  1118c1:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  1118c4:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
  1118c7:	eb 0e                	jmp    1118d7 <tcp_enqueue+0x107>
    }
    else {
      /* Attach the segment to the end of the queued segments. */
      LWIP_ASSERT("useg != NULL", useg != NULL);
      useg->next = seg;
  1118c9:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  1118cc:	8b 55 d8             	mov    0xffffffd8(%ebp),%edx
  1118cf:	89 10                	mov    %edx,(%eax)
      useg = seg;
  1118d1:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  1118d4:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
    }

    /* If copy is set, memory should be allocated
     * and data copied into pbuf, otherwise data comes from
     * ROM or other static memory, and need not be copied. If
     * optdata is != NULL, we have options instead of data. */
    if (optdata != NULL) {
  1118d7:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  1118db:	74 4a                	je     111927 <tcp_enqueue+0x157>
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
  1118dd:	0f b6 45 b8          	movzbl 0xffffffb8(%ebp),%eax
  1118e1:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  1118e8:	00 
  1118e9:	89 44 24 04          	mov    %eax,0x4(%esp)
  1118ed:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  1118f4:	e8 e7 d6 ff ff       	call   10efe0 <pbuf_alloc>
  1118f9:	89 c2                	mov    %eax,%edx
  1118fb:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  1118fe:	89 50 04             	mov    %edx,0x4(%eax)
  111901:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  111904:	8b 40 04             	mov    0x4(%eax),%eax
  111907:	85 c0                	test   %eax,%eax
  111909:	0f 84 fd 04 00 00    	je     111e0c <tcp_enqueue+0x63c>
        goto memerr;
      }
      ++queuelen;
  11190f:	80 45 f7 01          	addb   $0x1,0xfffffff7(%ebp)
      seg->dataptr = seg->p->payload;
  111913:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  111916:	8b 40 04             	mov    0x4(%eax),%eax
  111919:	8b 50 04             	mov    0x4(%eax),%edx
  11191c:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  11191f:	89 50 08             	mov    %edx,0x8(%eax)
  111922:	e9 15 01 00 00       	jmp    111a3c <tcp_enqueue+0x26c>
    }
    else if (copy) {
  111927:	80 7d bc 00          	cmpb   $0x0,0xffffffbc(%ebp)
  11192b:	74 71                	je     11199e <tcp_enqueue+0x1ce>
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_RAM)) == NULL) {
  11192d:	0f b7 45 ee          	movzwl 0xffffffee(%ebp),%eax
  111931:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  111938:	00 
  111939:	89 44 24 04          	mov    %eax,0x4(%esp)
  11193d:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  111944:	e8 97 d6 ff ff       	call   10efe0 <pbuf_alloc>
  111949:	89 c2                	mov    %eax,%edx
  11194b:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  11194e:	89 50 04             	mov    %edx,0x4(%eax)
  111951:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  111954:	8b 40 04             	mov    0x4(%eax),%eax
  111957:	85 c0                	test   %eax,%eax
  111959:	75 05                	jne    111960 <tcp_enqueue+0x190>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue : could not allocate memory for pbuf copy size %u\n", seglen));
        goto memerr;
  11195b:	e9 ac 04 00 00       	jmp    111e0c <tcp_enqueue+0x63c>
      }
      ++queuelen;
  111960:	80 45 f7 01          	addb   $0x1,0xfffffff7(%ebp)
      if (arg != NULL) {
  111964:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  111968:	74 20                	je     11198a <tcp_enqueue+0x1ba>
        memcpy(seg->p->payload, ptr, seglen);
  11196a:	0f b7 55 ee          	movzwl 0xffffffee(%ebp),%edx
  11196e:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  111971:	8b 40 04             	mov    0x4(%eax),%eax
  111974:	8b 48 04             	mov    0x4(%eax),%ecx
  111977:	89 54 24 08          	mov    %edx,0x8(%esp)
  11197b:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  11197e:	89 44 24 04          	mov    %eax,0x4(%esp)
  111982:	89 0c 24             	mov    %ecx,(%esp)
  111985:	e8 06 45 ff ff       	call   105e90 <memcpy>
      }
      seg->dataptr = seg->p->payload;
  11198a:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  11198d:	8b 40 04             	mov    0x4(%eax),%eax
  111990:	8b 50 04             	mov    0x4(%eax),%edx
  111993:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  111996:	89 50 08             	mov    %edx,0x8(%eax)
  111999:	e9 9e 00 00 00       	jmp    111a3c <tcp_enqueue+0x26c>
    }
    /* do not copy data */
    else {

      /* first, allocate a pbuf for holding the data.
       * since the referenced data is available at least until it is sent out on the
       * link (as it has to be ACKed by the remote party) we can safely use PBUF_ROM
       * instead of PBUF_REF here.
       */
      if ((p = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_ROM)) == NULL) {
  11199e:	0f b7 45 ee          	movzwl 0xffffffee(%ebp),%eax
  1119a2:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  1119a9:	00 
  1119aa:	89 44 24 04          	mov    %eax,0x4(%esp)
  1119ae:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  1119b5:	e8 26 d6 ff ff       	call   10efe0 <pbuf_alloc>
  1119ba:	89 45 d4             	mov    %eax,0xffffffd4(%ebp)
  1119bd:	83 7d d4 00          	cmpl   $0x0,0xffffffd4(%ebp)
  1119c1:	75 05                	jne    1119c8 <tcp_enqueue+0x1f8>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: could not allocate memory for zero-copy pbuf\n"));
        goto memerr;
  1119c3:	e9 44 04 00 00       	jmp    111e0c <tcp_enqueue+0x63c>
      }
      ++queuelen;
  1119c8:	80 45 f7 01          	addb   $0x1,0xfffffff7(%ebp)
      p->payload = ptr;
  1119cc:	8b 55 d4             	mov    0xffffffd4(%ebp),%edx
  1119cf:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  1119d2:	89 42 04             	mov    %eax,0x4(%edx)
      seg->dataptr = ptr;
  1119d5:	8b 55 d8             	mov    0xffffffd8(%ebp),%edx
  1119d8:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  1119db:	89 42 08             	mov    %eax,0x8(%edx)

      /* Second, allocate a pbuf for the headers. */
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, 0, PBUF_RAM)) == NULL) {
  1119de:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  1119e5:	00 
  1119e6:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  1119ed:	00 
  1119ee:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  1119f5:	e8 e6 d5 ff ff       	call   10efe0 <pbuf_alloc>
  1119fa:	89 c2                	mov    %eax,%edx
  1119fc:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  1119ff:	89 50 04             	mov    %edx,0x4(%eax)
  111a02:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  111a05:	8b 40 04             	mov    0x4(%eax),%eax
  111a08:	85 c0                	test   %eax,%eax
  111a0a:	75 10                	jne    111a1c <tcp_enqueue+0x24c>
        /* If allocation fails, we have to deallocate the data pbuf as
         * well. */
        pbuf_free(p);
  111a0c:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
  111a0f:	89 04 24             	mov    %eax,(%esp)
  111a12:	e8 a9 da ff ff       	call   10f4c0 <pbuf_free>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: could not allocate memory for header pbuf\n"));
        goto memerr;
  111a17:	e9 f0 03 00 00       	jmp    111e0c <tcp_enqueue+0x63c>
      }
      ++queuelen;
  111a1c:	80 45 f7 01          	addb   $0x1,0xfffffff7(%ebp)

      /* Concatenate the headers and data pbufs together. */
      pbuf_cat(seg->p, p);
  111a20:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  111a23:	8b 50 04             	mov    0x4(%eax),%edx
  111a26:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
  111a29:	89 44 24 04          	mov    %eax,0x4(%esp)
  111a2d:	89 14 24             	mov    %edx,(%esp)
  111a30:	e8 1b dc ff ff       	call   10f650 <pbuf_cat>
      p = NULL;
  111a35:	c7 45 d4 00 00 00 00 	movl   $0x0,0xffffffd4(%ebp)
    }

    /* Now that there are more segments queued, we check again if the
    length of the queue exceeds the configured maximum. */
    if (queuelen > TCP_SND_QUEUELEN) {
  111a3c:	80 7d f7 40          	cmpb   $0x40,0xfffffff7(%ebp)
  111a40:	76 05                	jbe    111a47 <tcp_enqueue+0x277>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: queue too long %u (%u)\n", queuelen, TCP_SND_QUEUELEN));
      goto memerr;
  111a42:	e9 c5 03 00 00       	jmp    111e0c <tcp_enqueue+0x63c>
    }

    seg->len = seglen;
  111a47:	8b 55 d8             	mov    0xffffffd8(%ebp),%edx
  111a4a:	0f b7 45 ee          	movzwl 0xffffffee(%ebp),%eax
  111a4e:	66 89 42 0c          	mov    %ax,0xc(%edx)
#if 0 /* Was commented out. TODO: can someone say why this is here? */
    if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
      ++seg->len;
    }
#endif
    /* Build TCP header. */
    if (pbuf_header(seg->p, TCP_HLEN)) {
  111a52:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  111a55:	8b 40 04             	mov    0x4(%eax),%eax
  111a58:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  111a5f:	00 
  111a60:	89 04 24             	mov    %eax,(%esp)
  111a63:	e8 58 d9 ff ff       	call   10f3c0 <pbuf_header>
  111a68:	84 c0                	test   %al,%al
  111a6a:	74 15                	je     111a81 <tcp_enqueue+0x2b1>

      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: no room for TCP header in pbuf.\n"));

      TCP_STATS_INC(tcp.err);
  111a6c:	0f b7 05 78 15 14 00 	movzwl 0x141578,%eax
  111a73:	83 c0 01             	add    $0x1,%eax
  111a76:	66 a3 78 15 14 00    	mov    %ax,0x141578
      goto memerr;
  111a7c:	e9 8b 03 00 00       	jmp    111e0c <tcp_enqueue+0x63c>
    }
    seg->tcphdr = seg->p->payload;
  111a81:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  111a84:	8b 40 04             	mov    0x4(%eax),%eax
  111a87:	8b 40 04             	mov    0x4(%eax),%eax
  111a8a:	89 c2                	mov    %eax,%edx
  111a8c:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  111a8f:	89 50 10             	mov    %edx,0x10(%eax)
    seg->tcphdr->src = htons(pcb->local_port);
  111a92:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  111a95:	8b 58 10             	mov    0x10(%eax),%ebx
  111a98:	8b 45 08             	mov    0x8(%ebp),%eax
  111a9b:	0f b7 40 1c          	movzwl 0x1c(%eax),%eax
  111a9f:	0f b7 c0             	movzwl %ax,%eax
  111aa2:	89 04 24             	mov    %eax,(%esp)
  111aa5:	e8 d6 c7 ff ff       	call   10e280 <htons>
  111aaa:	66 89 03             	mov    %ax,(%ebx)
    seg->tcphdr->dest = htons(pcb->remote_port);
  111aad:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  111ab0:	8b 58 10             	mov    0x10(%eax),%ebx
  111ab3:	8b 45 08             	mov    0x8(%ebp),%eax
  111ab6:	0f b7 40 1e          	movzwl 0x1e(%eax),%eax
  111aba:	0f b7 c0             	movzwl %ax,%eax
  111abd:	89 04 24             	mov    %eax,(%esp)
  111ac0:	e8 bb c7 ff ff       	call   10e280 <htons>
  111ac5:	66 89 43 02          	mov    %ax,0x2(%ebx)
    seg->tcphdr->seqno = htonl(seqno);
  111ac9:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  111acc:	8b 58 10             	mov    0x10(%eax),%ebx
  111acf:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  111ad2:	89 04 24             	mov    %eax,(%esp)
  111ad5:	e8 f6 c7 ff ff       	call   10e2d0 <htonl>
  111ada:	89 43 04             	mov    %eax,0x4(%ebx)
    seg->tcphdr->urgp = 0;
  111add:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  111ae0:	8b 40 10             	mov    0x10(%eax),%eax
  111ae3:	66 c7 40 12 00 00    	movw   $0x0,0x12(%eax)
    TCPH_FLAGS_SET(seg->tcphdr, flags);
  111ae9:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  111aec:	8b 58 10             	mov    0x10(%eax),%ebx
  111aef:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  111af2:	8b 40 10             	mov    0x10(%eax),%eax
  111af5:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  111af9:	0f b7 c0             	movzwl %ax,%eax
  111afc:	89 04 24             	mov    %eax,(%esp)
  111aff:	e8 ac c7 ff ff       	call   10e2b0 <ntohs>
  111b04:	89 c2                	mov    %eax,%edx
  111b06:	83 e2 c0             	and    $0xffffffc0,%edx
  111b09:	0f b6 45 c0          	movzbl 0xffffffc0(%ebp),%eax
  111b0d:	09 d0                	or     %edx,%eax
  111b0f:	0f b7 c0             	movzwl %ax,%eax
  111b12:	89 04 24             	mov    %eax,(%esp)
  111b15:	e8 66 c7 ff ff       	call   10e280 <htons>
  111b1a:	66 89 43 0c          	mov    %ax,0xc(%ebx)
    /* don't fill in tcphdr->ackno and tcphdr->wnd until later */

    /* Copy the options into the header, if they are present. */
    if (optdata == NULL) {
  111b1e:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  111b22:	75 32                	jne    111b56 <tcp_enqueue+0x386>
      TCPH_HDRLEN_SET(seg->tcphdr, 5);
  111b24:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  111b27:	8b 58 10             	mov    0x10(%eax),%ebx
  111b2a:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  111b2d:	8b 40 10             	mov    0x10(%eax),%eax
  111b30:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  111b34:	0f b7 c0             	movzwl %ax,%eax
  111b37:	89 04 24             	mov    %eax,(%esp)
  111b3a:	e8 71 c7 ff ff       	call   10e2b0 <ntohs>
  111b3f:	83 e0 3f             	and    $0x3f,%eax
  111b42:	80 cc 50             	or     $0x50,%ah
  111b45:	0f b7 c0             	movzwl %ax,%eax
  111b48:	89 04 24             	mov    %eax,(%esp)
  111b4b:	e8 30 c7 ff ff       	call   10e280 <htons>
  111b50:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  111b54:	eb 5e                	jmp    111bb4 <tcp_enqueue+0x3e4>
    }
    else {
      TCPH_HDRLEN_SET(seg->tcphdr, (5 + optlen / 4));
  111b56:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  111b59:	8b 70 10             	mov    0x10(%eax),%esi
  111b5c:	0f b6 45 b8          	movzbl 0xffffffb8(%ebp),%eax
  111b60:	c0 e8 02             	shr    $0x2,%al
  111b63:	0f b6 c0             	movzbl %al,%eax
  111b66:	83 c0 05             	add    $0x5,%eax
  111b69:	89 c3                	mov    %eax,%ebx
  111b6b:	c1 e3 0c             	shl    $0xc,%ebx
  111b6e:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  111b71:	8b 40 10             	mov    0x10(%eax),%eax
  111b74:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  111b78:	0f b7 c0             	movzwl %ax,%eax
  111b7b:	89 04 24             	mov    %eax,(%esp)
  111b7e:	e8 2d c7 ff ff       	call   10e2b0 <ntohs>
  111b83:	83 e0 3f             	and    $0x3f,%eax
  111b86:	09 d8                	or     %ebx,%eax
  111b88:	0f b7 c0             	movzwl %ax,%eax
  111b8b:	89 04 24             	mov    %eax,(%esp)
  111b8e:	e8 ed c6 ff ff       	call   10e280 <htons>
  111b93:	66 89 46 0c          	mov    %ax,0xc(%esi)
      /* Copy options into data portion of segment.
       Options can thus only be sent in non data carrying
       segments such as SYN|ACK. */
      memcpy(seg->dataptr, optdata, optlen);
  111b97:	0f b6 55 b8          	movzbl 0xffffffb8(%ebp),%edx
  111b9b:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  111b9e:	8b 48 08             	mov    0x8(%eax),%ecx
  111ba1:	89 54 24 08          	mov    %edx,0x8(%esp)
  111ba5:	8b 45 1c             	mov    0x1c(%ebp),%eax
  111ba8:	89 44 24 04          	mov    %eax,0x4(%esp)
  111bac:	89 0c 24             	mov    %ecx,(%esp)
  111baf:	e8 dc 42 ff ff       	call   105e90 <memcpy>
    }
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | DBG_TRACE, ("tcp_enqueue: queueing %lu:%lu (0x%x)\n",
      ntohl(seg->tcphdr->seqno),
      ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg),
      flags));

    left -= seglen;
  111bb4:	0f b7 45 ee          	movzwl 0xffffffee(%ebp),%eax
  111bb8:	29 45 e4             	sub    %eax,0xffffffe4(%ebp)
    seqno += seglen;
  111bbb:	0f b7 45 ee          	movzwl 0xffffffee(%ebp),%eax
  111bbf:	01 45 e8             	add    %eax,0xffffffe8(%ebp)
    ptr = (void *)((char *)ptr + seglen);
  111bc2:	0f b7 45 ee          	movzwl 0xffffffee(%ebp),%eax
  111bc6:	89 c2                	mov    %eax,%edx
  111bc8:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  111bcb:	8d 04 02             	lea    (%edx,%eax,1),%eax
  111bce:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
  111bd1:	83 7d e0 00          	cmpl   $0x0,0xffffffe0(%ebp)
  111bd5:	0f 84 84 fc ff ff    	je     11185f <tcp_enqueue+0x8f>
  111bdb:	83 7d e4 00          	cmpl   $0x0,0xffffffe4(%ebp)
  111bdf:	0f 85 7a fc ff ff    	jne    11185f <tcp_enqueue+0x8f>
  }


  /* Now that the data to be enqueued has been broken up into TCP
  segments in the queue variable, we add them to the end of the
  pcb->unsent queue. */
  if (pcb->unsent == NULL) {
  111be5:	8b 45 08             	mov    0x8(%ebp),%eax
  111be8:	8b 40 70             	mov    0x70(%eax),%eax
  111beb:	85 c0                	test   %eax,%eax
  111bed:	75 09                	jne    111bf8 <tcp_enqueue+0x428>
    useg = NULL;
  111bef:	c7 45 dc 00 00 00 00 	movl   $0x0,0xffffffdc(%ebp)
  111bf6:	eb 1c                	jmp    111c14 <tcp_enqueue+0x444>
  }
  else {
    for (useg = pcb->unsent; useg->next != NULL; useg = useg->next);
  111bf8:	8b 45 08             	mov    0x8(%ebp),%eax
  111bfb:	8b 40 70             	mov    0x70(%eax),%eax
  111bfe:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
  111c01:	eb 08                	jmp    111c0b <tcp_enqueue+0x43b>
  111c03:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  111c06:	8b 00                	mov    (%eax),%eax
  111c08:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
  111c0b:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  111c0e:	8b 00                	mov    (%eax),%eax
  111c10:	85 c0                	test   %eax,%eax
  111c12:	75 ef                	jne    111c03 <tcp_enqueue+0x433>
  }

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
  111c14:	83 7d dc 00          	cmpl   $0x0,0xffffffdc(%ebp)
  111c18:	0f 84 32 01 00 00    	je     111d50 <tcp_enqueue+0x580>
  111c1e:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  111c21:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  111c25:	0f b7 c0             	movzwl %ax,%eax
  111c28:	89 45 b0             	mov    %eax,0xffffffb0(%ebp)
  111c2b:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  111c2e:	8b 40 10             	mov    0x10(%eax),%eax
  111c31:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  111c35:	0f b7 c0             	movzwl %ax,%eax
  111c38:	89 04 24             	mov    %eax,(%esp)
  111c3b:	e8 70 c6 ff ff       	call   10e2b0 <ntohs>
  111c40:	0f b7 c0             	movzwl %ax,%eax
  111c43:	83 e0 01             	and    $0x1,%eax
  111c46:	84 c0                	test   %al,%al
  111c48:	75 1f                	jne    111c69 <tcp_enqueue+0x499>
  111c4a:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  111c4d:	8b 40 10             	mov    0x10(%eax),%eax
  111c50:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  111c54:	0f b7 c0             	movzwl %ax,%eax
  111c57:	89 04 24             	mov    %eax,(%esp)
  111c5a:	e8 51 c6 ff ff       	call   10e2b0 <ntohs>
  111c5f:	0f b7 c0             	movzwl %ax,%eax
  111c62:	83 e0 02             	and    $0x2,%eax
  111c65:	85 c0                	test   %eax,%eax
  111c67:	74 09                	je     111c72 <tcp_enqueue+0x4a2>
  111c69:	c7 45 b4 01 00 00 00 	movl   $0x1,0xffffffb4(%ebp)
  111c70:	eb 07                	jmp    111c79 <tcp_enqueue+0x4a9>
  111c72:	c7 45 b4 00 00 00 00 	movl   $0x0,0xffffffb4(%ebp)
  111c79:	8b 45 b0             	mov    0xffffffb0(%ebp),%eax
  111c7c:	03 45 b4             	add    0xffffffb4(%ebp),%eax
  111c7f:	85 c0                	test   %eax,%eax
  111c81:	0f 84 c9 00 00 00    	je     111d50 <tcp_enqueue+0x580>
  111c87:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  111c8a:	8b 40 10             	mov    0x10(%eax),%eax
  111c8d:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  111c91:	0f b7 c0             	movzwl %ax,%eax
  111c94:	89 04 24             	mov    %eax,(%esp)
  111c97:	e8 14 c6 ff ff       	call   10e2b0 <ntohs>
  111c9c:	0f b7 c0             	movzwl %ax,%eax
  111c9f:	83 e0 03             	and    $0x3,%eax
  111ca2:	85 c0                	test   %eax,%eax
  111ca4:	0f 85 a6 00 00 00    	jne    111d50 <tcp_enqueue+0x580>
  111caa:	0f b6 45 c0          	movzbl 0xffffffc0(%ebp),%eax
  111cae:	83 e0 03             	and    $0x3,%eax
  111cb1:	85 c0                	test   %eax,%eax
  111cb3:	0f 85 97 00 00 00    	jne    111d50 <tcp_enqueue+0x580>
  111cb9:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  111cbc:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  111cc0:	0f b7 d0             	movzwl %ax,%edx
  111cc3:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  111cc6:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  111cca:	0f b7 c0             	movzwl %ax,%eax
  111ccd:	01 c2                	add    %eax,%edx
  111ccf:	8b 45 08             	mov    0x8(%ebp),%eax
  111cd2:	0f b7 40 34          	movzwl 0x34(%eax),%eax
  111cd6:	0f b7 c0             	movzwl %ax,%eax
  111cd9:	39 c2                	cmp    %eax,%edx
  111cdb:	7f 73                	jg     111d50 <tcp_enqueue+0x580>
    TCP_TCPLEN(useg) != 0 &&
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
    !(flags & (TCP_SYN | TCP_FIN)) &&
    useg->len + queue->len <= pcb->mss) {
    /* Remove TCP header from first segment. */
    pbuf_header(queue->p, -TCP_HLEN);
  111cdd:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  111ce0:	8b 40 04             	mov    0x4(%eax),%eax
  111ce3:	c7 44 24 04 ec ff ff 	movl   $0xffffffec,0x4(%esp)
  111cea:	ff 
  111ceb:	89 04 24             	mov    %eax,(%esp)
  111cee:	e8 cd d6 ff ff       	call   10f3c0 <pbuf_header>
    pbuf_cat(useg->p, queue->p);
  111cf3:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  111cf6:	8b 50 04             	mov    0x4(%eax),%edx
  111cf9:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  111cfc:	8b 40 04             	mov    0x4(%eax),%eax
  111cff:	89 54 24 04          	mov    %edx,0x4(%esp)
  111d03:	89 04 24             	mov    %eax,(%esp)
  111d06:	e8 45 d9 ff ff       	call   10f650 <pbuf_cat>
    useg->len += queue->len;
  111d0b:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  111d0e:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
  111d12:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  111d15:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  111d19:	01 c2                	add    %eax,%edx
  111d1b:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  111d1e:	66 89 50 0c          	mov    %dx,0xc(%eax)
    useg->next = queue->next;
  111d22:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  111d25:	8b 10                	mov    (%eax),%edx
  111d27:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  111d2a:	89 10                	mov    %edx,(%eax)

    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | DBG_TRACE | DBG_STATE, ("tcp_enqueue: chaining, new len %u\n", useg->len));
    if (seg == queue) {
  111d2c:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  111d2f:	3b 45 e0             	cmp    0xffffffe0(%ebp),%eax
  111d32:	75 07                	jne    111d3b <tcp_enqueue+0x56b>
      seg = NULL;
  111d34:	c7 45 d8 00 00 00 00 	movl   $0x0,0xffffffd8(%ebp)
    }
    memp_free(MEMP_TCP_SEG, queue);
  111d3b:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  111d3e:	89 44 24 04          	mov    %eax,0x4(%esp)
  111d42:	c7 04 24 05 00 00 00 	movl   $0x5,(%esp)
  111d49:	e8 72 cd ff ff       	call   10eac0 <memp_free>
  111d4e:	eb 19                	jmp    111d69 <tcp_enqueue+0x599>
  }
  else {
    if (useg == NULL) {
  111d50:	83 7d dc 00          	cmpl   $0x0,0xffffffdc(%ebp)
  111d54:	75 0b                	jne    111d61 <tcp_enqueue+0x591>
      pcb->unsent = queue;
  111d56:	8b 55 08             	mov    0x8(%ebp),%edx
  111d59:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  111d5c:	89 42 70             	mov    %eax,0x70(%edx)
  111d5f:	eb 08                	jmp    111d69 <tcp_enqueue+0x599>

    }
    else {
      useg->next = queue;
  111d61:	8b 55 dc             	mov    0xffffffdc(%ebp),%edx
  111d64:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  111d67:	89 02                	mov    %eax,(%edx)
    }
  }
  if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
  111d69:	0f b6 45 c0          	movzbl 0xffffffc0(%ebp),%eax
  111d6d:	83 e0 02             	and    $0x2,%eax
  111d70:	85 c0                	test   %eax,%eax
  111d72:	75 0b                	jne    111d7f <tcp_enqueue+0x5af>
  111d74:	0f b6 45 c0          	movzbl 0xffffffc0(%ebp),%eax
  111d78:	83 e0 01             	and    $0x1,%eax
  111d7b:	84 c0                	test   %al,%al
  111d7d:	74 05                	je     111d84 <tcp_enqueue+0x5b4>
    ++len;
  111d7f:	66 83 45 c4 01       	addw   $0x1,0xffffffc4(%ebp)
  }
  pcb->snd_lbb += len;
  111d84:	8b 45 08             	mov    0x8(%ebp),%eax
  111d87:	8b 50 64             	mov    0x64(%eax),%edx
  111d8a:	0f b7 45 c4          	movzwl 0xffffffc4(%ebp),%eax
  111d8e:	01 c2                	add    %eax,%edx
  111d90:	8b 45 08             	mov    0x8(%ebp),%eax
  111d93:	89 50 64             	mov    %edx,0x64(%eax)
  pcb->snd_buf -= len;
  111d96:	8b 45 08             	mov    0x8(%ebp),%eax
  111d99:	0f b7 40 6a          	movzwl 0x6a(%eax),%eax
  111d9d:	89 c2                	mov    %eax,%edx
  111d9f:	66 2b 55 c4          	sub    0xffffffc4(%ebp),%dx
  111da3:	8b 45 08             	mov    0x8(%ebp),%eax
  111da6:	66 89 50 6a          	mov    %dx,0x6a(%eax)
  pcb->snd_queuelen = queuelen;
  111daa:	8b 55 08             	mov    0x8(%ebp),%edx
  111dad:	0f b6 45 f7          	movzbl 0xfffffff7(%ebp),%eax
  111db1:	88 42 6c             	mov    %al,0x6c(%edx)
  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue: %d (after enqueued)\n", pcb->snd_queuelen));
  if (pcb->snd_queuelen != 0) {
  111db4:	8b 45 08             	mov    0x8(%ebp),%eax
  111db7:	0f b6 40 6c          	movzbl 0x6c(%eax),%eax
  111dbb:	84 c0                	test   %al,%al
  111dbd:	74 00                	je     111dbf <tcp_enqueue+0x5ef>
    LWIP_ASSERT("tcp_enqueue: valid queue length", pcb->unacked != NULL ||
      pcb->unsent != NULL);

  }

  /* Set the PSH flag in the last segment that we enqueued, but only
  if the segment has data (indicated by seglen > 0). */
  if (seg != NULL && seglen > 0 && seg->tcphdr != NULL) {
  111dbf:	83 7d d8 00          	cmpl   $0x0,0xffffffd8(%ebp)
  111dc3:	74 3e                	je     111e03 <tcp_enqueue+0x633>
  111dc5:	66 83 7d ee 00       	cmpw   $0x0,0xffffffee(%ebp)
  111dca:	74 37                	je     111e03 <tcp_enqueue+0x633>
  111dcc:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  111dcf:	8b 40 10             	mov    0x10(%eax),%eax
  111dd2:	85 c0                	test   %eax,%eax
  111dd4:	74 2d                	je     111e03 <tcp_enqueue+0x633>
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
  111dd6:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  111dd9:	8b 58 10             	mov    0x10(%eax),%ebx
  111ddc:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  111ddf:	8b 40 10             	mov    0x10(%eax),%eax
  111de2:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  111de6:	0f b7 c0             	movzwl %ax,%eax
  111de9:	89 04 24             	mov    %eax,(%esp)
  111dec:	e8 bf c4 ff ff       	call   10e2b0 <ntohs>
  111df1:	83 c8 08             	or     $0x8,%eax
  111df4:	0f b7 c0             	movzwl %ax,%eax
  111df7:	89 04 24             	mov    %eax,(%esp)
  111dfa:	e8 81 c4 ff ff       	call   10e280 <htons>
  111dff:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  }

  return ERR_OK;
  111e03:	c7 45 a8 00 00 00 00 	movl   $0x0,0xffffffa8(%ebp)
  111e0a:	eb 33                	jmp    111e3f <tcp_enqueue+0x66f>
  memerr:
  TCP_STATS_INC(tcp.memerr);
  111e0c:	0f b7 05 70 15 14 00 	movzwl 0x141570,%eax
  111e13:	83 c0 01             	add    $0x1,%eax
  111e16:	66 a3 70 15 14 00    	mov    %ax,0x141570

  if (queue != NULL) {
  111e1c:	83 7d e0 00          	cmpl   $0x0,0xffffffe0(%ebp)
  111e20:	74 0b                	je     111e2d <tcp_enqueue+0x65d>
    tcp_segs_free(queue);
  111e22:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  111e25:	89 04 24             	mov    %eax,(%esp)
  111e28:	e8 b3 f2 ff ff       	call   1110e0 <tcp_segs_free>
  }
  if (pcb->snd_queuelen != 0) {
  111e2d:	8b 45 08             	mov    0x8(%ebp),%eax
  111e30:	0f b6 40 6c          	movzbl 0x6c(%eax),%eax
  111e34:	84 c0                	test   %al,%al
  111e36:	74 00                	je     111e38 <tcp_enqueue+0x668>
    LWIP_ASSERT("tcp_enqueue: valid queue length", pcb->unacked != NULL ||
      pcb->unsent != NULL);

  }
  LWIP_DEBUGF(TCP_QLEN_DEBUG | DBG_STATE, ("tcp_enqueue: %d (with mem err)\n", pcb->snd_queuelen));
  return ERR_MEM;
  111e38:	c7 45 a8 ff ff ff ff 	movl   $0xffffffff,0xffffffa8(%ebp)
  111e3f:	8b 45 a8             	mov    0xffffffa8(%ebp),%eax
}
  111e42:	83 c4 60             	add    $0x60,%esp
  111e45:	5b                   	pop    %ebx
  111e46:	5e                   	pop    %esi
  111e47:	5d                   	pop    %ebp
  111e48:	c3                   	ret    
  111e49:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

00111e50 <tcp_output>:

/* find out what we can send and send it */
err_t
tcp_output(struct tcp_pcb *pcb)
{
  111e50:	55                   	push   %ebp
  111e51:	89 e5                	mov    %esp,%ebp
  111e53:	53                   	push   %ebx
  111e54:	83 ec 64             	sub    $0x64,%esp
  struct pbuf *p;
  struct tcp_hdr *tcphdr;
  struct tcp_seg *seg, *useg;
  u32_t wnd;
#if TCP_CWND_DEBUG
  int i = 0;
#endif /* TCP_CWND_DEBUG */

  /* First, check if we are invoked by the TCP input processing
     code. If so, we do not output anything. Instead, we rely on the
     input processing code to call us when input processing is done
     with. */
  if (tcp_input_pcb == pcb) {
  111e57:	a1 68 16 14 00       	mov    0x141668,%eax
  111e5c:	3b 45 08             	cmp    0x8(%ebp),%eax
  111e5f:	75 0c                	jne    111e6d <tcp_output+0x1d>
    return ERR_OK;
  111e61:	c7 45 c0 00 00 00 00 	movl   $0x0,0xffffffc0(%ebp)
  111e68:	e9 5f 04 00 00       	jmp    1122cc <tcp_output+0x47c>
  }

  wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);
  111e6d:	8b 45 08             	mov    0x8(%ebp),%eax
  111e70:	0f b7 40 4a          	movzwl 0x4a(%eax),%eax
  111e74:	0f b7 d0             	movzwl %ax,%edx
  111e77:	8b 45 08             	mov    0x8(%ebp),%eax
  111e7a:	8b 40 58             	mov    0x58(%eax),%eax
  111e7d:	89 45 c4             	mov    %eax,0xffffffc4(%ebp)
  111e80:	89 55 bc             	mov    %edx,0xffffffbc(%ebp)
  111e83:	8b 45 c4             	mov    0xffffffc4(%ebp),%eax
  111e86:	39 45 bc             	cmp    %eax,0xffffffbc(%ebp)
  111e89:	76 06                	jbe    111e91 <tcp_output+0x41>
  111e8b:	8b 4d c4             	mov    0xffffffc4(%ebp),%ecx
  111e8e:	89 4d bc             	mov    %ecx,0xffffffbc(%ebp)
  111e91:	8b 45 bc             	mov    0xffffffbc(%ebp),%eax
  111e94:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)


  seg = pcb->unsent;
  111e97:	8b 45 08             	mov    0x8(%ebp),%eax
  111e9a:	8b 40 70             	mov    0x70(%eax),%eax
  111e9d:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)

  /* useg should point to last segment on unacked queue */
  useg = pcb->unacked;
  111ea0:	8b 45 08             	mov    0x8(%ebp),%eax
  111ea3:	8b 40 74             	mov    0x74(%eax),%eax
  111ea6:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  if (useg != NULL) {
  111ea9:	83 7d f4 00          	cmpl   $0x0,0xfffffff4(%ebp)
  111ead:	74 13                	je     111ec2 <tcp_output+0x72>
    for (; useg->next != NULL; useg = useg->next);
  111eaf:	eb 08                	jmp    111eb9 <tcp_output+0x69>
  111eb1:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  111eb4:	8b 00                	mov    (%eax),%eax
  111eb6:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  111eb9:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  111ebc:	8b 00                	mov    (%eax),%eax
  111ebe:	85 c0                	test   %eax,%eax
  111ec0:	75 ef                	jne    111eb1 <tcp_output+0x61>
  }                                                                             

   
  /* If the TF_ACK_NOW flag is set, we check if there is data that is
     to be sent. If data is to be sent out, we'll just piggyback our
     acknowledgement with the outgoing segment. If no data will be
     sent (either because the ->unsent queue is empty or because the
     window doesn't allow it) we'll have to construct an empty ACK
     segment and send it. */
  if (pcb->flags & TF_ACK_NOW &&
  111ec2:	8b 45 08             	mov    0x8(%ebp),%eax
  111ec5:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  111ec9:	0f b6 c0             	movzbl %al,%eax
  111ecc:	83 e0 02             	and    $0x2,%eax
  111ecf:	85 c0                	test   %eax,%eax
  111ed1:	0f 84 b7 03 00 00    	je     11228e <tcp_output+0x43e>
  111ed7:	83 7d f0 00          	cmpl   $0x0,0xfffffff0(%ebp)
  111edb:	74 31                	je     111f0e <tcp_output+0xbe>
  111edd:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  111ee0:	8b 40 10             	mov    0x10(%eax),%eax
  111ee3:	8b 40 04             	mov    0x4(%eax),%eax
  111ee6:	89 04 24             	mov    %eax,(%esp)
  111ee9:	e8 22 c4 ff ff       	call   10e310 <ntohl>
  111eee:	89 c2                	mov    %eax,%edx
  111ef0:	8b 45 08             	mov    0x8(%ebp),%eax
  111ef3:	8b 40 44             	mov    0x44(%eax),%eax
  111ef6:	29 c2                	sub    %eax,%edx
  111ef8:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  111efb:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  111eff:	0f b7 c0             	movzwl %ax,%eax
  111f02:	8d 04 02             	lea    (%edx,%eax,1),%eax
  111f05:	3b 45 f8             	cmp    0xfffffff8(%ebp),%eax
  111f08:	0f 86 80 03 00 00    	jbe    11228e <tcp_output+0x43e>
     (seg == NULL ||
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
    pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  111f0e:	8b 45 08             	mov    0x8(%ebp),%eax
  111f11:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  111f15:	89 c2                	mov    %eax,%edx
  111f17:	83 e2 fc             	and    $0xfffffffc,%edx
  111f1a:	8b 45 08             	mov    0x8(%ebp),%eax
  111f1d:	88 50 20             	mov    %dl,0x20(%eax)
    p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  111f20:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  111f27:	00 
  111f28:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  111f2f:	00 
  111f30:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  111f37:	e8 a4 d0 ff ff       	call   10efe0 <pbuf_alloc>
  111f3c:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
    if (p == NULL) {
  111f3f:	83 7d e8 00          	cmpl   $0x0,0xffffffe8(%ebp)
  111f43:	75 0c                	jne    111f51 <tcp_output+0x101>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: (ACK) could not allocate pbuf\n"));
      return ERR_BUF;
  111f45:	c7 45 c0 fe ff ff ff 	movl   $0xfffffffe,0xffffffc0(%ebp)
  111f4c:	e9 7b 03 00 00       	jmp    1122cc <tcp_output+0x47c>
    }
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: sending ACK for %lu\n", pcb->rcv_nxt));

    tcphdr = p->payload;
  111f51:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  111f54:	8b 40 04             	mov    0x4(%eax),%eax
  111f57:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
    tcphdr->src = htons(pcb->local_port);
  111f5a:	8b 45 08             	mov    0x8(%ebp),%eax
  111f5d:	0f b7 40 1c          	movzwl 0x1c(%eax),%eax
  111f61:	0f b7 c0             	movzwl %ax,%eax
  111f64:	89 04 24             	mov    %eax,(%esp)
  111f67:	e8 14 c3 ff ff       	call   10e280 <htons>
  111f6c:	89 c2                	mov    %eax,%edx
  111f6e:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  111f71:	66 89 10             	mov    %dx,(%eax)
    tcphdr->dest = htons(pcb->remote_port);
  111f74:	8b 45 08             	mov    0x8(%ebp),%eax
  111f77:	0f b7 40 1e          	movzwl 0x1e(%eax),%eax
  111f7b:	0f b7 c0             	movzwl %ax,%eax
  111f7e:	89 04 24             	mov    %eax,(%esp)
  111f81:	e8 fa c2 ff ff       	call   10e280 <htons>
  111f86:	89 c2                	mov    %eax,%edx
  111f88:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  111f8b:	66 89 50 02          	mov    %dx,0x2(%eax)
    tcphdr->seqno = htonl(pcb->snd_nxt);
  111f8f:	8b 45 08             	mov    0x8(%ebp),%eax
  111f92:	8b 40 50             	mov    0x50(%eax),%eax
  111f95:	89 04 24             	mov    %eax,(%esp)
  111f98:	e8 33 c3 ff ff       	call   10e2d0 <htonl>
  111f9d:	89 c2                	mov    %eax,%edx
  111f9f:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  111fa2:	89 50 04             	mov    %edx,0x4(%eax)
    tcphdr->ackno = htonl(pcb->rcv_nxt);
  111fa5:	8b 45 08             	mov    0x8(%ebp),%eax
  111fa8:	8b 40 24             	mov    0x24(%eax),%eax
  111fab:	89 04 24             	mov    %eax,(%esp)
  111fae:	e8 1d c3 ff ff       	call   10e2d0 <htonl>
  111fb3:	89 c2                	mov    %eax,%edx
  111fb5:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  111fb8:	89 50 08             	mov    %edx,0x8(%eax)
    TCPH_FLAGS_SET(tcphdr, TCP_ACK);
  111fbb:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  111fbe:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  111fc2:	0f b7 c0             	movzwl %ax,%eax
  111fc5:	89 04 24             	mov    %eax,(%esp)
  111fc8:	e8 e3 c2 ff ff       	call   10e2b0 <ntohs>
  111fcd:	83 e0 c0             	and    $0xffffffc0,%eax
  111fd0:	83 c8 10             	or     $0x10,%eax
  111fd3:	0f b7 c0             	movzwl %ax,%eax
  111fd6:	89 04 24             	mov    %eax,(%esp)
  111fd9:	e8 a2 c2 ff ff       	call   10e280 <htons>
  111fde:	89 c2                	mov    %eax,%edx
  111fe0:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  111fe3:	66 89 50 0c          	mov    %dx,0xc(%eax)
    tcphdr->wnd = htons(pcb->rcv_wnd);
  111fe7:	8b 45 08             	mov    0x8(%ebp),%eax
  111fea:	0f b7 40 28          	movzwl 0x28(%eax),%eax
  111fee:	0f b7 c0             	movzwl %ax,%eax
  111ff1:	89 04 24             	mov    %eax,(%esp)
  111ff4:	e8 87 c2 ff ff       	call   10e280 <htons>
  111ff9:	89 c2                	mov    %eax,%edx
  111ffb:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  111ffe:	66 89 50 0e          	mov    %dx,0xe(%eax)
    tcphdr->urgp = 0;
  112002:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  112005:	66 c7 40 12 00 00    	movw   $0x0,0x12(%eax)
    TCPH_HDRLEN_SET(tcphdr, 5);
  11200b:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  11200e:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  112012:	0f b7 c0             	movzwl %ax,%eax
  112015:	89 04 24             	mov    %eax,(%esp)
  112018:	e8 93 c2 ff ff       	call   10e2b0 <ntohs>
  11201d:	83 e0 3f             	and    $0x3f,%eax
  112020:	80 cc 50             	or     $0x50,%ah
  112023:	0f b7 c0             	movzwl %ax,%eax
  112026:	89 04 24             	mov    %eax,(%esp)
  112029:	e8 52 c2 ff ff       	call   10e280 <htons>
  11202e:	89 c2                	mov    %eax,%edx
  112030:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  112033:	66 89 50 0c          	mov    %dx,0xc(%eax)

    tcphdr->chksum = 0;
  112037:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  11203a:	66 c7 40 10 00 00    	movw   $0x0,0x10(%eax)
    tcphdr->chksum = inet_chksum_pseudo(p, &(pcb->local_ip), &(pcb->remote_ip),
  112040:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  112043:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  112047:	0f b7 c0             	movzwl %ax,%eax
  11204a:	8b 55 08             	mov    0x8(%ebp),%edx
  11204d:	83 c2 04             	add    $0x4,%edx
  112050:	8b 4d 08             	mov    0x8(%ebp),%ecx
  112053:	89 44 24 10          	mov    %eax,0x10(%esp)
  112057:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
  11205e:	00 
  11205f:	89 54 24 08          	mov    %edx,0x8(%esp)
  112063:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  112067:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  11206a:	89 04 24             	mov    %eax,(%esp)
  11206d:	e8 ce bb ff ff       	call   10dc40 <inet_chksum_pseudo>
  112072:	89 c2                	mov    %eax,%edx
  112074:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  112077:	66 89 50 10          	mov    %dx,0x10(%eax)
          IP_PROTO_TCP, p->tot_len);

    ip_output(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
  11207b:	8b 45 08             	mov    0x8(%ebp),%eax
  11207e:	0f b6 40 0a          	movzbl 0xa(%eax),%eax
  112082:	0f b6 d8             	movzbl %al,%ebx
  112085:	8b 45 08             	mov    0x8(%ebp),%eax
  112088:	0f b6 40 0b          	movzbl 0xb(%eax),%eax
  11208c:	0f b6 c0             	movzbl %al,%eax
  11208f:	8b 55 08             	mov    0x8(%ebp),%edx
  112092:	83 c2 04             	add    $0x4,%edx
  112095:	8b 4d 08             	mov    0x8(%ebp),%ecx
  112098:	c7 44 24 14 06 00 00 	movl   $0x6,0x14(%esp)
  11209f:	00 
  1120a0:	89 5c 24 10          	mov    %ebx,0x10(%esp)
  1120a4:	89 44 24 0c          	mov    %eax,0xc(%esp)
  1120a8:	89 54 24 08          	mov    %edx,0x8(%esp)
  1120ac:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1120b0:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  1120b3:	89 04 24             	mov    %eax,(%esp)
  1120b6:	e8 55 b1 ff ff       	call   10d210 <ip_output>
        IP_PROTO_TCP);
    pbuf_free(p);
  1120bb:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  1120be:	89 04 24             	mov    %eax,(%esp)
  1120c1:	e8 fa d3 ff ff       	call   10f4c0 <pbuf_free>

    return ERR_OK;
  1120c6:	c7 45 c0 00 00 00 00 	movl   $0x0,0xffffffc0(%ebp)
  1120cd:	e9 fa 01 00 00       	jmp    1122cc <tcp_output+0x47c>
  }

#if TCP_OUTPUT_DEBUG
  if (seg == NULL) {
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: nothing to send (%p)\n", pcb->unsent));
  }
#endif /* TCP_OUTPUT_DEBUG */
#if TCP_CWND_DEBUG
  if (seg == NULL) {
    LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_output: snd_wnd %lu, cwnd %lu, wnd %lu, seg == NULL, ack %lu\n",
                            pcb->snd_wnd, pcb->cwnd, wnd,
                            pcb->lastack));
  } else {
    LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_output: snd_wnd %lu, cwnd %lu, wnd %lu, effwnd %lu, seq %lu, ack %lu\n",
                            pcb->snd_wnd, pcb->cwnd, wnd,
                            ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                            ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */

  while (seg != NULL &&
  ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
#if TCP_CWND_DEBUG
    LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_output: snd_wnd %lu, cwnd %lu, wnd %lu, effwnd %lu, seq %lu, ack %lu, i%d\n",
                            pcb->snd_wnd, pcb->cwnd, wnd,
                            ntohl(seg->tcphdr->seqno) + seg->len -
                            pcb->lastack,
                            ntohl(seg->tcphdr->seqno), pcb->lastack, i));
    ++i;
#endif /* TCP_CWND_DEBUG */

    pcb->unsent = seg->next;
  1120d2:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  1120d5:	8b 10                	mov    (%eax),%edx
  1120d7:	8b 45 08             	mov    0x8(%ebp),%eax
  1120da:	89 50 70             	mov    %edx,0x70(%eax)

    if (pcb->state != SYN_SENT) {
  1120dd:	8b 45 08             	mov    0x8(%ebp),%eax
  1120e0:	8b 40 10             	mov    0x10(%eax),%eax
  1120e3:	83 f8 02             	cmp    $0x2,%eax
  1120e6:	74 3f                	je     112127 <tcp_output+0x2d7>
      TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
  1120e8:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  1120eb:	8b 58 10             	mov    0x10(%eax),%ebx
  1120ee:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  1120f1:	8b 40 10             	mov    0x10(%eax),%eax
  1120f4:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  1120f8:	0f b7 c0             	movzwl %ax,%eax
  1120fb:	89 04 24             	mov    %eax,(%esp)
  1120fe:	e8 ad c1 ff ff       	call   10e2b0 <ntohs>
  112103:	83 c8 10             	or     $0x10,%eax
  112106:	0f b7 c0             	movzwl %ax,%eax
  112109:	89 04 24             	mov    %eax,(%esp)
  11210c:	e8 6f c1 ff ff       	call   10e280 <htons>
  112111:	66 89 43 0c          	mov    %ax,0xc(%ebx)
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  112115:	8b 45 08             	mov    0x8(%ebp),%eax
  112118:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  11211c:	89 c2                	mov    %eax,%edx
  11211e:	83 e2 fc             	and    $0xfffffffc,%edx
  112121:	8b 45 08             	mov    0x8(%ebp),%eax
  112124:	88 50 20             	mov    %dl,0x20(%eax)
    }

    tcp_output_segment(seg, pcb);
  112127:	8b 45 08             	mov    0x8(%ebp),%eax
  11212a:	89 44 24 04          	mov    %eax,0x4(%esp)
  11212e:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  112131:	89 04 24             	mov    %eax,(%esp)
  112134:	e8 a7 01 00 00       	call   1122e0 <tcp_output_segment>
    pcb->snd_nxt = ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
  112139:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  11213c:	8b 40 10             	mov    0x10(%eax),%eax
  11213f:	8b 40 04             	mov    0x4(%eax),%eax
  112142:	89 04 24             	mov    %eax,(%esp)
  112145:	e8 c6 c1 ff ff       	call   10e310 <ntohl>
  11214a:	89 45 c8             	mov    %eax,0xffffffc8(%ebp)
  11214d:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  112150:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  112154:	0f b7 c0             	movzwl %ax,%eax
  112157:	89 45 cc             	mov    %eax,0xffffffcc(%ebp)
  11215a:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  11215d:	8b 40 10             	mov    0x10(%eax),%eax
  112160:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  112164:	0f b7 c0             	movzwl %ax,%eax
  112167:	89 04 24             	mov    %eax,(%esp)
  11216a:	e8 41 c1 ff ff       	call   10e2b0 <ntohs>
  11216f:	0f b7 c0             	movzwl %ax,%eax
  112172:	83 e0 01             	and    $0x1,%eax
  112175:	84 c0                	test   %al,%al
  112177:	75 1f                	jne    112198 <tcp_output+0x348>
  112179:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  11217c:	8b 40 10             	mov    0x10(%eax),%eax
  11217f:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  112183:	0f b7 c0             	movzwl %ax,%eax
  112186:	89 04 24             	mov    %eax,(%esp)
  112189:	e8 22 c1 ff ff       	call   10e2b0 <ntohs>
  11218e:	0f b7 c0             	movzwl %ax,%eax
  112191:	83 e0 02             	and    $0x2,%eax
  112194:	85 c0                	test   %eax,%eax
  112196:	74 09                	je     1121a1 <tcp_output+0x351>
  112198:	c7 45 d0 01 00 00 00 	movl   $0x1,0xffffffd0(%ebp)
  11219f:	eb 07                	jmp    1121a8 <tcp_output+0x358>
  1121a1:	c7 45 d0 00 00 00 00 	movl   $0x0,0xffffffd0(%ebp)
  1121a8:	8b 45 cc             	mov    0xffffffcc(%ebp),%eax
  1121ab:	03 45 d0             	add    0xffffffd0(%ebp),%eax
  1121ae:	8b 55 c8             	mov    0xffffffc8(%ebp),%edx
  1121b1:	01 c2                	add    %eax,%edx
  1121b3:	8b 45 08             	mov    0x8(%ebp),%eax
  1121b6:	89 50 50             	mov    %edx,0x50(%eax)
    if (TCP_SEQ_LT(pcb->snd_max, pcb->snd_nxt)) {
  1121b9:	8b 45 08             	mov    0x8(%ebp),%eax
  1121bc:	8b 40 54             	mov    0x54(%eax),%eax
  1121bf:	89 c2                	mov    %eax,%edx
  1121c1:	8b 45 08             	mov    0x8(%ebp),%eax
  1121c4:	8b 40 50             	mov    0x50(%eax),%eax
  1121c7:	89 d1                	mov    %edx,%ecx
  1121c9:	66 29 c1             	sub    %ax,%cx
  1121cc:	89 c8                	mov    %ecx,%eax
  1121ce:	66 85 c0             	test   %ax,%ax
  1121d1:	79 0c                	jns    1121df <tcp_output+0x38f>
      pcb->snd_max = pcb->snd_nxt;
  1121d3:	8b 45 08             	mov    0x8(%ebp),%eax
  1121d6:	8b 50 50             	mov    0x50(%eax),%edx
  1121d9:	8b 45 08             	mov    0x8(%ebp),%eax
  1121dc:	89 50 54             	mov    %edx,0x54(%eax)
    }
    /* put segment on unacknowledged list if length > 0 */
    if (TCP_TCPLEN(seg) > 0) {
  1121df:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  1121e2:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  1121e6:	0f b7 c0             	movzwl %ax,%eax
  1121e9:	89 45 d4             	mov    %eax,0xffffffd4(%ebp)
  1121ec:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  1121ef:	8b 40 10             	mov    0x10(%eax),%eax
  1121f2:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  1121f6:	0f b7 c0             	movzwl %ax,%eax
  1121f9:	89 04 24             	mov    %eax,(%esp)
  1121fc:	e8 af c0 ff ff       	call   10e2b0 <ntohs>
  112201:	0f b7 c0             	movzwl %ax,%eax
  112204:	83 e0 01             	and    $0x1,%eax
  112207:	84 c0                	test   %al,%al
  112209:	75 1f                	jne    11222a <tcp_output+0x3da>
  11220b:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  11220e:	8b 40 10             	mov    0x10(%eax),%eax
  112211:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  112215:	0f b7 c0             	movzwl %ax,%eax
  112218:	89 04 24             	mov    %eax,(%esp)
  11221b:	e8 90 c0 ff ff       	call   10e2b0 <ntohs>
  112220:	0f b7 c0             	movzwl %ax,%eax
  112223:	83 e0 02             	and    $0x2,%eax
  112226:	85 c0                	test   %eax,%eax
  112228:	74 09                	je     112233 <tcp_output+0x3e3>
  11222a:	c7 45 d8 01 00 00 00 	movl   $0x1,0xffffffd8(%ebp)
  112231:	eb 07                	jmp    11223a <tcp_output+0x3ea>
  112233:	c7 45 d8 00 00 00 00 	movl   $0x0,0xffffffd8(%ebp)
  11223a:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
  11223d:	03 45 d8             	add    0xffffffd8(%ebp),%eax
  112240:	85 c0                	test   %eax,%eax
  112242:	7e 36                	jle    11227a <tcp_output+0x42a>
      seg->next = NULL;
  112244:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  112247:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
      if (pcb->unacked == NULL) {
  11224d:	8b 45 08             	mov    0x8(%ebp),%eax
  112250:	8b 40 74             	mov    0x74(%eax),%eax
  112253:	85 c0                	test   %eax,%eax
  112255:	75 11                	jne    112268 <tcp_output+0x418>
        pcb->unacked = seg;
  112257:	8b 45 08             	mov    0x8(%ebp),%eax
  11225a:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
  11225d:	89 50 74             	mov    %edx,0x74(%eax)
        useg = seg;
  112260:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  112263:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  112266:	eb 1d                	jmp    112285 <tcp_output+0x435>
      } else {
        useg->next = seg;
  112268:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
  11226b:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  11226e:	89 02                	mov    %eax,(%edx)
        useg = useg->next;
  112270:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  112273:	8b 00                	mov    (%eax),%eax
  112275:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  112278:	eb 0b                	jmp    112285 <tcp_output+0x435>
      }
    } else {
      tcp_seg_free(seg);
  11227a:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  11227d:	89 04 24             	mov    %eax,(%esp)
  112280:	e8 9b ee ff ff       	call   111120 <tcp_seg_free>
    }
    seg = pcb->unsent;
  112285:	8b 45 08             	mov    0x8(%ebp),%eax
  112288:	8b 40 70             	mov    0x70(%eax),%eax
  11228b:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
  11228e:	83 7d f0 00          	cmpl   $0x0,0xfffffff0(%ebp)
  112292:	74 31                	je     1122c5 <tcp_output+0x475>
  112294:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  112297:	8b 40 10             	mov    0x10(%eax),%eax
  11229a:	8b 40 04             	mov    0x4(%eax),%eax
  11229d:	89 04 24             	mov    %eax,(%esp)
  1122a0:	e8 6b c0 ff ff       	call   10e310 <ntohl>
  1122a5:	89 c2                	mov    %eax,%edx
  1122a7:	8b 45 08             	mov    0x8(%ebp),%eax
  1122aa:	8b 40 44             	mov    0x44(%eax),%eax
  1122ad:	29 c2                	sub    %eax,%edx
  1122af:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  1122b2:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  1122b6:	0f b7 c0             	movzwl %ax,%eax
  1122b9:	8d 04 02             	lea    (%edx,%eax,1),%eax
  1122bc:	3b 45 f8             	cmp    0xfffffff8(%ebp),%eax
  1122bf:	0f 86 0d fe ff ff    	jbe    1120d2 <tcp_output+0x282>
  }
  return ERR_OK;
  1122c5:	c7 45 c0 00 00 00 00 	movl   $0x0,0xffffffc0(%ebp)
  1122cc:	8b 45 c0             	mov    0xffffffc0(%ebp),%eax
}
  1122cf:	83 c4 64             	add    $0x64,%esp
  1122d2:	5b                   	pop    %ebx
  1122d3:	5d                   	pop    %ebp
  1122d4:	c3                   	ret    
  1122d5:	8d 74 26 00          	lea    0x0(%esi),%esi
  1122d9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

001122e0 <tcp_output_segment>:

static void
tcp_output_segment(struct tcp_seg *seg, struct tcp_pcb *pcb)
{
  1122e0:	55                   	push   %ebp
  1122e1:	89 e5                	mov    %esp,%ebp
  1122e3:	56                   	push   %esi
  1122e4:	53                   	push   %ebx
  1122e5:	83 ec 30             	sub    $0x30,%esp
  u16_t len;
  struct netif *netif;

  /* The TCP header has already been constructed, but the ackno and
   wnd fields remain. */
  seg->tcphdr->ackno = htonl(pcb->rcv_nxt);
  1122e8:	8b 45 08             	mov    0x8(%ebp),%eax
  1122eb:	8b 58 10             	mov    0x10(%eax),%ebx
  1122ee:	8b 45 0c             	mov    0xc(%ebp),%eax
  1122f1:	8b 40 24             	mov    0x24(%eax),%eax
  1122f4:	89 04 24             	mov    %eax,(%esp)
  1122f7:	e8 d4 bf ff ff       	call   10e2d0 <htonl>
  1122fc:	89 43 08             	mov    %eax,0x8(%ebx)

  /* silly window avoidance */
  if (pcb->rcv_wnd < pcb->mss) {
  1122ff:	8b 45 0c             	mov    0xc(%ebp),%eax
  112302:	0f b7 50 28          	movzwl 0x28(%eax),%edx
  112306:	8b 45 0c             	mov    0xc(%ebp),%eax
  112309:	0f b7 40 34          	movzwl 0x34(%eax),%eax
  11230d:	66 39 c2             	cmp    %ax,%dx
  112310:	73 0e                	jae    112320 <tcp_output_segment+0x40>
    seg->tcphdr->wnd = 0;
  112312:	8b 45 08             	mov    0x8(%ebp),%eax
  112315:	8b 40 10             	mov    0x10(%eax),%eax
  112318:	66 c7 40 0e 00 00    	movw   $0x0,0xe(%eax)
  11231e:	eb 1c                	jmp    11233c <tcp_output_segment+0x5c>
  } else {
    /* advertise our receive window size in this TCP segment */
    seg->tcphdr->wnd = htons(pcb->rcv_wnd);
  112320:	8b 45 08             	mov    0x8(%ebp),%eax
  112323:	8b 58 10             	mov    0x10(%eax),%ebx
  112326:	8b 45 0c             	mov    0xc(%ebp),%eax
  112329:	0f b7 40 28          	movzwl 0x28(%eax),%eax
  11232d:	0f b7 c0             	movzwl %ax,%eax
  112330:	89 04 24             	mov    %eax,(%esp)
  112333:	e8 48 bf ff ff       	call   10e280 <htons>
  112338:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  }

  /* If we don't have a local IP address, we get one by
     calling ip_route(). */
  if (ip_addr_isany(&(pcb->local_ip))) {
  11233c:	8b 45 0c             	mov    0xc(%ebp),%eax
  11233f:	85 c0                	test   %eax,%eax
  112341:	74 09                	je     11234c <tcp_output_segment+0x6c>
  112343:	8b 45 0c             	mov    0xc(%ebp),%eax
  112346:	8b 00                	mov    (%eax),%eax
  112348:	85 c0                	test   %eax,%eax
  11234a:	75 3f                	jne    11238b <tcp_output_segment+0xab>
    netif = ip_route(&(pcb->remote_ip));
  11234c:	8b 45 0c             	mov    0xc(%ebp),%eax
  11234f:	83 c0 04             	add    $0x4,%eax
  112352:	89 04 24             	mov    %eax,(%esp)
  112355:	e8 a6 a7 ff ff       	call   10cb00 <ip_route>
  11235a:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
    if (netif == NULL) {
  11235d:	83 7d f4 00          	cmpl   $0x0,0xfffffff4(%ebp)
  112361:	0f 84 5c 01 00 00    	je     1124c3 <tcp_output_segment+0x1e3>
      return;
    }
    ip_addr_set(&(pcb->local_ip), &(netif->ip_addr));
  112367:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  11236a:	83 c0 04             	add    $0x4,%eax
  11236d:	85 c0                	test   %eax,%eax
  11236f:	74 0b                	je     11237c <tcp_output_segment+0x9c>
  112371:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  112374:	8b 40 04             	mov    0x4(%eax),%eax
  112377:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
  11237a:	eb 07                	jmp    112383 <tcp_output_segment+0xa3>
  11237c:	c7 45 e4 00 00 00 00 	movl   $0x0,0xffffffe4(%ebp)
  112383:	8b 45 0c             	mov    0xc(%ebp),%eax
  112386:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
  112389:	89 10                	mov    %edx,(%eax)
  }

  pcb->rtime = 0;
  11238b:	8b 45 0c             	mov    0xc(%ebp),%eax
  11238e:	66 c7 40 32 00 00    	movw   $0x0,0x32(%eax)

  if (pcb->rttest == 0) {
  112394:	8b 45 0c             	mov    0xc(%ebp),%eax
  112397:	0f b7 40 36          	movzwl 0x36(%eax),%eax
  11239b:	66 85 c0             	test   %ax,%ax
  11239e:	75 27                	jne    1123c7 <tcp_output_segment+0xe7>
    pcb->rttest = tcp_ticks;
  1123a0:	a1 58 16 14 00       	mov    0x141658,%eax
  1123a5:	89 c2                	mov    %eax,%edx
  1123a7:	8b 45 0c             	mov    0xc(%ebp),%eax
  1123aa:	66 89 50 36          	mov    %dx,0x36(%eax)
    pcb->rtseq = ntohl(seg->tcphdr->seqno);
  1123ae:	8b 45 08             	mov    0x8(%ebp),%eax
  1123b1:	8b 40 10             	mov    0x10(%eax),%eax
  1123b4:	8b 40 04             	mov    0x4(%eax),%eax
  1123b7:	89 04 24             	mov    %eax,(%esp)
  1123ba:	e8 51 bf ff ff       	call   10e310 <ntohl>
  1123bf:	89 c2                	mov    %eax,%edx
  1123c1:	8b 45 0c             	mov    0xc(%ebp),%eax
  1123c4:	89 50 38             	mov    %edx,0x38(%eax)

    LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_output_segment: rtseq %lu\n", pcb->rtseq));
  }
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output_segment: %lu:%lu\n",
          htonl(seg->tcphdr->seqno), htonl(seg->tcphdr->seqno) +
          seg->len));

  len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
  1123c7:	8b 45 08             	mov    0x8(%ebp),%eax
  1123ca:	8b 40 10             	mov    0x10(%eax),%eax
  1123cd:	89 c2                	mov    %eax,%edx
  1123cf:	8b 45 08             	mov    0x8(%ebp),%eax
  1123d2:	8b 40 04             	mov    0x4(%eax),%eax
  1123d5:	8b 40 04             	mov    0x4(%eax),%eax
  1123d8:	89 d1                	mov    %edx,%ecx
  1123da:	66 29 c1             	sub    %ax,%cx
  1123dd:	89 c8                	mov    %ecx,%eax
  1123df:	66 89 45 f2          	mov    %ax,0xfffffff2(%ebp)

  seg->p->len -= len;
  1123e3:	8b 45 08             	mov    0x8(%ebp),%eax
  1123e6:	8b 50 04             	mov    0x4(%eax),%edx
  1123e9:	8b 45 08             	mov    0x8(%ebp),%eax
  1123ec:	8b 40 04             	mov    0x4(%eax),%eax
  1123ef:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  1123f3:	66 2b 45 f2          	sub    0xfffffff2(%ebp),%ax
  1123f7:	66 89 42 0a          	mov    %ax,0xa(%edx)
  seg->p->tot_len -= len;
  1123fb:	8b 45 08             	mov    0x8(%ebp),%eax
  1123fe:	8b 50 04             	mov    0x4(%eax),%edx
  112401:	8b 45 08             	mov    0x8(%ebp),%eax
  112404:	8b 40 04             	mov    0x4(%eax),%eax
  112407:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  11240b:	66 2b 45 f2          	sub    0xfffffff2(%ebp),%ax
  11240f:	66 89 42 08          	mov    %ax,0x8(%edx)

  seg->p->payload = seg->tcphdr;
  112413:	8b 45 08             	mov    0x8(%ebp),%eax
  112416:	8b 50 04             	mov    0x4(%eax),%edx
  112419:	8b 45 08             	mov    0x8(%ebp),%eax
  11241c:	8b 40 10             	mov    0x10(%eax),%eax
  11241f:	89 42 04             	mov    %eax,0x4(%edx)

  seg->tcphdr->chksum = 0;
  112422:	8b 45 08             	mov    0x8(%ebp),%eax
  112425:	8b 40 10             	mov    0x10(%eax),%eax
  112428:	66 c7 40 10 00 00    	movw   $0x0,0x10(%eax)
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p,
  11242e:	8b 45 08             	mov    0x8(%ebp),%eax
  112431:	8b 70 10             	mov    0x10(%eax),%esi
  112434:	8b 45 08             	mov    0x8(%ebp),%eax
  112437:	8b 40 04             	mov    0x4(%eax),%eax
  11243a:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  11243e:	0f b7 d0             	movzwl %ax,%edx
  112441:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  112444:	83 c1 04             	add    $0x4,%ecx
  112447:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  11244a:	8b 45 08             	mov    0x8(%ebp),%eax
  11244d:	8b 40 04             	mov    0x4(%eax),%eax
  112450:	89 54 24 10          	mov    %edx,0x10(%esp)
  112454:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
  11245b:	00 
  11245c:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  112460:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  112464:	89 04 24             	mov    %eax,(%esp)
  112467:	e8 d4 b7 ff ff       	call   10dc40 <inet_chksum_pseudo>
  11246c:	66 89 46 10          	mov    %ax,0x10(%esi)
             &(pcb->local_ip),
             &(pcb->remote_ip),
             IP_PROTO_TCP, seg->p->tot_len);
  TCP_STATS_INC(tcp.xmit);
  112470:	0f b7 05 62 15 14 00 	movzwl 0x141562,%eax
  112477:	83 c0 01             	add    $0x1,%eax
  11247a:	66 a3 62 15 14 00    	mov    %ax,0x141562

  ip_output(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
  112480:	8b 45 0c             	mov    0xc(%ebp),%eax
  112483:	0f b6 40 0a          	movzbl 0xa(%eax),%eax
  112487:	0f b6 d0             	movzbl %al,%edx
  11248a:	8b 45 0c             	mov    0xc(%ebp),%eax
  11248d:	0f b6 40 0b          	movzbl 0xb(%eax),%eax
  112491:	0f b6 c8             	movzbl %al,%ecx
  112494:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  112497:	83 c3 04             	add    $0x4,%ebx
  11249a:	8b 75 0c             	mov    0xc(%ebp),%esi
  11249d:	8b 45 08             	mov    0x8(%ebp),%eax
  1124a0:	8b 40 04             	mov    0x4(%eax),%eax
  1124a3:	c7 44 24 14 06 00 00 	movl   $0x6,0x14(%esp)
  1124aa:	00 
  1124ab:	89 54 24 10          	mov    %edx,0x10(%esp)
  1124af:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
  1124b3:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  1124b7:	89 74 24 04          	mov    %esi,0x4(%esp)
  1124bb:	89 04 24             	mov    %eax,(%esp)
  1124be:	e8 4d ad ff ff       	call   10d210 <ip_output>
      IP_PROTO_TCP);
}
  1124c3:	83 c4 30             	add    $0x30,%esp
  1124c6:	5b                   	pop    %ebx
  1124c7:	5e                   	pop    %esi
  1124c8:	5d                   	pop    %ebp
  1124c9:	c3                   	ret    
  1124ca:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

001124d0 <tcp_rst>:

void
tcp_rst(u32_t seqno, u32_t ackno,
  struct ip_addr *local_ip, struct ip_addr *remote_ip,
  u16_t local_port, u16_t remote_port)
{
  1124d0:	55                   	push   %ebp
  1124d1:	89 e5                	mov    %esp,%ebp
  1124d3:	83 ec 38             	sub    $0x38,%esp
  1124d6:	8b 45 18             	mov    0x18(%ebp),%eax
  1124d9:	8b 55 1c             	mov    0x1c(%ebp),%edx
  1124dc:	66 89 45 ec          	mov    %ax,0xffffffec(%ebp)
  1124e0:	66 89 55 e8          	mov    %dx,0xffffffe8(%ebp)
  struct pbuf *p;
  struct tcp_hdr *tcphdr;
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  1124e4:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  1124eb:	00 
  1124ec:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  1124f3:	00 
  1124f4:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  1124fb:	e8 e0 ca ff ff       	call   10efe0 <pbuf_alloc>
  112500:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  if (p == NULL) {
  112503:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  112507:	75 05                	jne    11250e <tcp_rst+0x3e>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_rst: could not allocate memory for pbuf\n"));
      return;
  112509:	e9 5b 01 00 00       	jmp    112669 <tcp_rst+0x199>
  }

  tcphdr = p->payload;
  11250e:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  112511:	8b 40 04             	mov    0x4(%eax),%eax
  112514:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  tcphdr->src = htons(local_port);
  112517:	0f b7 45 ec          	movzwl 0xffffffec(%ebp),%eax
  11251b:	89 04 24             	mov    %eax,(%esp)
  11251e:	e8 5d bd ff ff       	call   10e280 <htons>
  112523:	89 c2                	mov    %eax,%edx
  112525:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  112528:	66 89 10             	mov    %dx,(%eax)
  tcphdr->dest = htons(remote_port);
  11252b:	0f b7 45 e8          	movzwl 0xffffffe8(%ebp),%eax
  11252f:	89 04 24             	mov    %eax,(%esp)
  112532:	e8 49 bd ff ff       	call   10e280 <htons>
  112537:	89 c2                	mov    %eax,%edx
  112539:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  11253c:	66 89 50 02          	mov    %dx,0x2(%eax)
  tcphdr->seqno = htonl(seqno);
  112540:	8b 45 08             	mov    0x8(%ebp),%eax
  112543:	89 04 24             	mov    %eax,(%esp)
  112546:	e8 85 bd ff ff       	call   10e2d0 <htonl>
  11254b:	89 c2                	mov    %eax,%edx
  11254d:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  112550:	89 50 04             	mov    %edx,0x4(%eax)
  tcphdr->ackno = htonl(ackno);
  112553:	8b 45 0c             	mov    0xc(%ebp),%eax
  112556:	89 04 24             	mov    %eax,(%esp)
  112559:	e8 72 bd ff ff       	call   10e2d0 <htonl>
  11255e:	89 c2                	mov    %eax,%edx
  112560:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  112563:	89 50 08             	mov    %edx,0x8(%eax)
  TCPH_FLAGS_SET(tcphdr, TCP_RST | TCP_ACK);
  112566:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  112569:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  11256d:	0f b7 c0             	movzwl %ax,%eax
  112570:	89 04 24             	mov    %eax,(%esp)
  112573:	e8 38 bd ff ff       	call   10e2b0 <ntohs>
  112578:	83 e0 c0             	and    $0xffffffc0,%eax
  11257b:	83 c8 14             	or     $0x14,%eax
  11257e:	0f b7 c0             	movzwl %ax,%eax
  112581:	89 04 24             	mov    %eax,(%esp)
  112584:	e8 f7 bc ff ff       	call   10e280 <htons>
  112589:	89 c2                	mov    %eax,%edx
  11258b:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  11258e:	66 89 50 0c          	mov    %dx,0xc(%eax)
  tcphdr->wnd = htons(TCP_WND);
  112592:	c7 04 24 00 20 00 00 	movl   $0x2000,(%esp)
  112599:	e8 e2 bc ff ff       	call   10e280 <htons>
  11259e:	89 c2                	mov    %eax,%edx
  1125a0:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1125a3:	66 89 50 0e          	mov    %dx,0xe(%eax)
  tcphdr->urgp = 0;
  1125a7:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1125aa:	66 c7 40 12 00 00    	movw   $0x0,0x12(%eax)
  TCPH_HDRLEN_SET(tcphdr, 5);
  1125b0:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1125b3:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  1125b7:	0f b7 c0             	movzwl %ax,%eax
  1125ba:	89 04 24             	mov    %eax,(%esp)
  1125bd:	e8 ee bc ff ff       	call   10e2b0 <ntohs>
  1125c2:	83 e0 3f             	and    $0x3f,%eax
  1125c5:	80 cc 50             	or     $0x50,%ah
  1125c8:	0f b7 c0             	movzwl %ax,%eax
  1125cb:	89 04 24             	mov    %eax,(%esp)
  1125ce:	e8 ad bc ff ff       	call   10e280 <htons>
  1125d3:	89 c2                	mov    %eax,%edx
  1125d5:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1125d8:	66 89 50 0c          	mov    %dx,0xc(%eax)

  tcphdr->chksum = 0;
  1125dc:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1125df:	66 c7 40 10 00 00    	movw   $0x0,0x10(%eax)
  tcphdr->chksum = inet_chksum_pseudo(p, local_ip, remote_ip,
  1125e5:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1125e8:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  1125ec:	0f b7 c0             	movzwl %ax,%eax
  1125ef:	89 44 24 10          	mov    %eax,0x10(%esp)
  1125f3:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
  1125fa:	00 
  1125fb:	8b 45 14             	mov    0x14(%ebp),%eax
  1125fe:	89 44 24 08          	mov    %eax,0x8(%esp)
  112602:	8b 45 10             	mov    0x10(%ebp),%eax
  112605:	89 44 24 04          	mov    %eax,0x4(%esp)
  112609:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  11260c:	89 04 24             	mov    %eax,(%esp)
  11260f:	e8 2c b6 ff ff       	call   10dc40 <inet_chksum_pseudo>
  112614:	89 c2                	mov    %eax,%edx
  112616:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  112619:	66 89 50 10          	mov    %dx,0x10(%eax)
              IP_PROTO_TCP, p->tot_len);

  TCP_STATS_INC(tcp.xmit);
  11261d:	0f b7 05 62 15 14 00 	movzwl 0x141562,%eax
  112624:	83 c0 01             	add    $0x1,%eax
  112627:	66 a3 62 15 14 00    	mov    %ax,0x141562
   /* Send output with hardcoded TTL since we have no access to the pcb */
  ip_output(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
  11262d:	c7 44 24 14 06 00 00 	movl   $0x6,0x14(%esp)
  112634:	00 
  112635:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  11263c:	00 
  11263d:	c7 44 24 0c ff 00 00 	movl   $0xff,0xc(%esp)
  112644:	00 
  112645:	8b 45 14             	mov    0x14(%ebp),%eax
  112648:	89 44 24 08          	mov    %eax,0x8(%esp)
  11264c:	8b 45 10             	mov    0x10(%ebp),%eax
  11264f:	89 44 24 04          	mov    %eax,0x4(%esp)
  112653:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  112656:	89 04 24             	mov    %eax,(%esp)
  112659:	e8 b2 ab ff ff       	call   10d210 <ip_output>
  pbuf_free(p);
  11265e:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  112661:	89 04 24             	mov    %eax,(%esp)
  112664:	e8 57 ce ff ff       	call   10f4c0 <pbuf_free>
  LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_rst: seqno %lu ackno %lu.\n", seqno, ackno));
}
  112669:	c9                   	leave  
  11266a:	c3                   	ret    
  11266b:	90                   	nop    
  11266c:	8d 74 26 00          	lea    0x0(%esi),%esi

00112670 <tcp_rexmit>:

void
tcp_rexmit(struct tcp_pcb *pcb)
{
  112670:	55                   	push   %ebp
  112671:	89 e5                	mov    %esp,%ebp
  112673:	83 ec 18             	sub    $0x18,%esp
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
  112676:	8b 45 08             	mov    0x8(%ebp),%eax
  112679:	8b 40 74             	mov    0x74(%eax),%eax
  11267c:	85 c0                	test   %eax,%eax
  11267e:	74 7d                	je     1126fd <tcp_rexmit+0x8d>
    return;
  }

  /* Move all unacked segments to the unsent queue. */
  for (seg = pcb->unacked; seg->next != NULL; seg = seg->next);
  112680:	8b 45 08             	mov    0x8(%ebp),%eax
  112683:	8b 40 74             	mov    0x74(%eax),%eax
  112686:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  112689:	eb 08                	jmp    112693 <tcp_rexmit+0x23>
  11268b:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  11268e:	8b 00                	mov    (%eax),%eax
  112690:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  112693:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  112696:	8b 00                	mov    (%eax),%eax
  112698:	85 c0                	test   %eax,%eax
  11269a:	75 ef                	jne    11268b <tcp_rexmit+0x1b>

  seg->next = pcb->unsent;
  11269c:	8b 45 08             	mov    0x8(%ebp),%eax
  11269f:	8b 50 70             	mov    0x70(%eax),%edx
  1126a2:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1126a5:	89 10                	mov    %edx,(%eax)
  pcb->unsent = pcb->unacked;
  1126a7:	8b 45 08             	mov    0x8(%ebp),%eax
  1126aa:	8b 50 74             	mov    0x74(%eax),%edx
  1126ad:	8b 45 08             	mov    0x8(%ebp),%eax
  1126b0:	89 50 70             	mov    %edx,0x70(%eax)

  pcb->unacked = NULL;
  1126b3:	8b 45 08             	mov    0x8(%ebp),%eax
  1126b6:	c7 40 74 00 00 00 00 	movl   $0x0,0x74(%eax)


  pcb->snd_nxt = ntohl(pcb->unsent->tcphdr->seqno);
  1126bd:	8b 45 08             	mov    0x8(%ebp),%eax
  1126c0:	8b 40 70             	mov    0x70(%eax),%eax
  1126c3:	8b 40 10             	mov    0x10(%eax),%eax
  1126c6:	8b 40 04             	mov    0x4(%eax),%eax
  1126c9:	89 04 24             	mov    %eax,(%esp)
  1126cc:	e8 3f bc ff ff       	call   10e310 <ntohl>
  1126d1:	89 c2                	mov    %eax,%edx
  1126d3:	8b 45 08             	mov    0x8(%ebp),%eax
  1126d6:	89 50 50             	mov    %edx,0x50(%eax)

  ++pcb->nrtx;
  1126d9:	8b 45 08             	mov    0x8(%ebp),%eax
  1126dc:	0f b6 40 42          	movzbl 0x42(%eax),%eax
  1126e0:	8d 50 01             	lea    0x1(%eax),%edx
  1126e3:	8b 45 08             	mov    0x8(%ebp),%eax
  1126e6:	88 50 42             	mov    %dl,0x42(%eax)

  /* Don't take any rtt measurements after retransmitting. */
  pcb->rttest = 0;
  1126e9:	8b 45 08             	mov    0x8(%ebp),%eax
  1126ec:	66 c7 40 36 00 00    	movw   $0x0,0x36(%eax)

  /* Do the actual retransmission. */
  tcp_output(pcb);
  1126f2:	8b 45 08             	mov    0x8(%ebp),%eax
  1126f5:	89 04 24             	mov    %eax,(%esp)
  1126f8:	e8 53 f7 ff ff       	call   111e50 <tcp_output>

}
  1126fd:	c9                   	leave  
  1126fe:	c3                   	ret    
  1126ff:	90                   	nop    

00112700 <tcp_keepalive>:

void
tcp_keepalive(struct tcp_pcb *pcb)
{
  112700:	55                   	push   %ebp
  112701:	89 e5                	mov    %esp,%ebp
  112703:	83 ec 28             	sub    $0x28,%esp
   struct pbuf *p;
   struct tcp_hdr *tcphdr;

   LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: sending KEEPALIVE probe to %u.%u.%u.%u\n",
                           ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                           ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip)));

   LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: tcp_ticks %ld   pcb->tmr %ld  pcb->keep_cnt %ld\n", tcp_ticks, pcb->tmr, pcb->keep_cnt));
   
   p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  112706:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  11270d:	00 
  11270e:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  112715:	00 
  112716:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  11271d:	e8 be c8 ff ff       	call   10efe0 <pbuf_alloc>
  112722:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)

   if(p == NULL) {
  112725:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  112729:	75 05                	jne    112730 <tcp_keepalive+0x30>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: could not allocate memory for pbuf\n"));
      return;
  11272b:	e9 56 01 00 00       	jmp    112886 <tcp_keepalive+0x186>
   }

   tcphdr = p->payload;
  112730:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  112733:	8b 40 04             	mov    0x4(%eax),%eax
  112736:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
   tcphdr->src = htons(pcb->local_port);
  112739:	8b 45 08             	mov    0x8(%ebp),%eax
  11273c:	0f b7 40 1c          	movzwl 0x1c(%eax),%eax
  112740:	0f b7 c0             	movzwl %ax,%eax
  112743:	89 04 24             	mov    %eax,(%esp)
  112746:	e8 35 bb ff ff       	call   10e280 <htons>
  11274b:	89 c2                	mov    %eax,%edx
  11274d:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  112750:	66 89 10             	mov    %dx,(%eax)
   tcphdr->dest = htons(pcb->remote_port);
  112753:	8b 45 08             	mov    0x8(%ebp),%eax
  112756:	0f b7 40 1e          	movzwl 0x1e(%eax),%eax
  11275a:	0f b7 c0             	movzwl %ax,%eax
  11275d:	89 04 24             	mov    %eax,(%esp)
  112760:	e8 1b bb ff ff       	call   10e280 <htons>
  112765:	89 c2                	mov    %eax,%edx
  112767:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  11276a:	66 89 50 02          	mov    %dx,0x2(%eax)
   tcphdr->seqno = htonl(pcb->snd_nxt - 1);
  11276e:	8b 45 08             	mov    0x8(%ebp),%eax
  112771:	8b 40 50             	mov    0x50(%eax),%eax
  112774:	83 e8 01             	sub    $0x1,%eax
  112777:	89 04 24             	mov    %eax,(%esp)
  11277a:	e8 51 bb ff ff       	call   10e2d0 <htonl>
  11277f:	89 c2                	mov    %eax,%edx
  112781:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  112784:	89 50 04             	mov    %edx,0x4(%eax)
   tcphdr->ackno = htonl(pcb->rcv_nxt);
  112787:	8b 45 08             	mov    0x8(%ebp),%eax
  11278a:	8b 40 24             	mov    0x24(%eax),%eax
  11278d:	89 04 24             	mov    %eax,(%esp)
  112790:	e8 3b bb ff ff       	call   10e2d0 <htonl>
  112795:	89 c2                	mov    %eax,%edx
  112797:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  11279a:	89 50 08             	mov    %edx,0x8(%eax)
   tcphdr->wnd = htons(pcb->rcv_wnd);
  11279d:	8b 45 08             	mov    0x8(%ebp),%eax
  1127a0:	0f b7 40 28          	movzwl 0x28(%eax),%eax
  1127a4:	0f b7 c0             	movzwl %ax,%eax
  1127a7:	89 04 24             	mov    %eax,(%esp)
  1127aa:	e8 d1 ba ff ff       	call   10e280 <htons>
  1127af:	89 c2                	mov    %eax,%edx
  1127b1:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1127b4:	66 89 50 0e          	mov    %dx,0xe(%eax)
   tcphdr->urgp = 0;
  1127b8:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1127bb:	66 c7 40 12 00 00    	movw   $0x0,0x12(%eax)
   TCPH_HDRLEN_SET(tcphdr, 5);
  1127c1:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1127c4:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  1127c8:	0f b7 c0             	movzwl %ax,%eax
  1127cb:	89 04 24             	mov    %eax,(%esp)
  1127ce:	e8 dd ba ff ff       	call   10e2b0 <ntohs>
  1127d3:	83 e0 3f             	and    $0x3f,%eax
  1127d6:	80 cc 50             	or     $0x50,%ah
  1127d9:	0f b7 c0             	movzwl %ax,%eax
  1127dc:	89 04 24             	mov    %eax,(%esp)
  1127df:	e8 9c ba ff ff       	call   10e280 <htons>
  1127e4:	89 c2                	mov    %eax,%edx
  1127e6:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1127e9:	66 89 50 0c          	mov    %dx,0xc(%eax)
   
   tcphdr->chksum = 0;
  1127ed:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1127f0:	66 c7 40 10 00 00    	movw   $0x0,0x10(%eax)
   tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip, IP_PROTO_TCP, p->tot_len);
  1127f6:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1127f9:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  1127fd:	0f b7 c0             	movzwl %ax,%eax
  112800:	8b 55 08             	mov    0x8(%ebp),%edx
  112803:	83 c2 04             	add    $0x4,%edx
  112806:	8b 4d 08             	mov    0x8(%ebp),%ecx
  112809:	89 44 24 10          	mov    %eax,0x10(%esp)
  11280d:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
  112814:	00 
  112815:	89 54 24 08          	mov    %edx,0x8(%esp)
  112819:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  11281d:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  112820:	89 04 24             	mov    %eax,(%esp)
  112823:	e8 18 b4 ff ff       	call   10dc40 <inet_chksum_pseudo>
  112828:	89 c2                	mov    %eax,%edx
  11282a:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  11282d:	66 89 50 10          	mov    %dx,0x10(%eax)

  TCP_STATS_INC(tcp.xmit);
  112831:	0f b7 05 62 15 14 00 	movzwl 0x141562,%eax
  112838:	83 c0 01             	add    $0x1,%eax
  11283b:	66 a3 62 15 14 00    	mov    %ax,0x141562

   /* Send output to IP */
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
  112841:	8b 45 08             	mov    0x8(%ebp),%eax
  112844:	0f b6 40 0b          	movzbl 0xb(%eax),%eax
  112848:	0f b6 c0             	movzbl %al,%eax
  11284b:	8b 55 08             	mov    0x8(%ebp),%edx
  11284e:	83 c2 04             	add    $0x4,%edx
  112851:	8b 4d 08             	mov    0x8(%ebp),%ecx
  112854:	c7 44 24 14 06 00 00 	movl   $0x6,0x14(%esp)
  11285b:	00 
  11285c:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  112863:	00 
  112864:	89 44 24 0c          	mov    %eax,0xc(%esp)
  112868:	89 54 24 08          	mov    %edx,0x8(%esp)
  11286c:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  112870:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  112873:	89 04 24             	mov    %eax,(%esp)
  112876:	e8 95 a9 ff ff       	call   10d210 <ip_output>

  pbuf_free(p);
  11287b:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  11287e:	89 04 24             	mov    %eax,(%esp)
  112881:	e8 3a cc ff ff       	call   10f4c0 <pbuf_free>

  LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_keepalive: seqno %lu ackno %lu.\n", pcb->snd_nxt - 1, pcb->rcv_nxt));
}
  112886:	c9                   	leave  
  112887:	c3                   	ret    
  112888:	90                   	nop    
  112889:	90                   	nop    
  11288a:	90                   	nop    
  11288b:	90                   	nop    
  11288c:	90                   	nop    
  11288d:	90                   	nop    
  11288e:	90                   	nop    
  11288f:	90                   	nop    

00112890 <tcp_input>:
 */

void
tcp_input(struct pbuf *p, struct netif *inp)
{
  112890:	55                   	push   %ebp
  112891:	89 e5                	mov    %esp,%ebp
  112893:	57                   	push   %edi
  112894:	56                   	push   %esi
  112895:	53                   	push   %ebx
  112896:	83 ec 4c             	sub    $0x4c,%esp
  struct tcp_pcb *pcb, *prev;
  struct tcp_pcb_listen *lpcb;
  u8_t hdrlen;
  err_t err;

#if SO_REUSE
  struct tcp_pcb *pcb_temp;
  int reuse = 0;
  112899:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  int reuse_port = 0;
  1128a0:	c7 45 f0 00 00 00 00 	movl   $0x0,0xfffffff0(%ebp)
#endif /* SO_REUSE */

  PERF_START;

  TCP_STATS_INC(tcp.recv);
  1128a7:	0f b7 05 66 15 14 00 	movzwl 0x141566,%eax
  1128ae:	83 c0 01             	add    $0x1,%eax
  1128b1:	66 a3 66 15 14 00    	mov    %ax,0x141566

  iphdr = p->payload;
  1128b7:	8b 45 08             	mov    0x8(%ebp),%eax
  1128ba:	8b 40 04             	mov    0x4(%eax),%eax
  1128bd:	a3 08 99 13 00       	mov    %eax,0x139908
  tcphdr = (struct tcp_hdr *)((u8_t *)p->payload + IPH_HL(iphdr) * 4);
  1128c2:	8b 45 08             	mov    0x8(%ebp),%eax
  1128c5:	8b 40 04             	mov    0x4(%eax),%eax
  1128c8:	89 c3                	mov    %eax,%ebx
  1128ca:	a1 08 99 13 00       	mov    0x139908,%eax
  1128cf:	0f b7 00             	movzwl (%eax),%eax
  1128d2:	0f b7 c0             	movzwl %ax,%eax
  1128d5:	89 04 24             	mov    %eax,(%esp)
  1128d8:	e8 d3 b9 ff ff       	call   10e2b0 <ntohs>
  1128dd:	66 c1 e8 08          	shr    $0x8,%ax
  1128e1:	0f b7 c0             	movzwl %ax,%eax
  1128e4:	83 e0 0f             	and    $0xf,%eax
  1128e7:	c1 e0 02             	shl    $0x2,%eax
  1128ea:	8d 04 03             	lea    (%ebx,%eax,1),%eax
  1128ed:	a3 04 99 13 00       	mov    %eax,0x139904

#if TCP_INPUT_DEBUG
  tcp_debug_print(tcphdr);
#endif

  /* remove header from payload */
  if (pbuf_header(p, -((s16_t)(IPH_HL(iphdr) * 4))) || (p->tot_len < sizeof(struct tcp_hdr))) {
  1128f2:	a1 08 99 13 00       	mov    0x139908,%eax
  1128f7:	0f b7 00             	movzwl (%eax),%eax
  1128fa:	0f b7 c0             	movzwl %ax,%eax
  1128fd:	89 04 24             	mov    %eax,(%esp)
  112900:	e8 ab b9 ff ff       	call   10e2b0 <ntohs>
  112905:	66 c1 e8 08          	shr    $0x8,%ax
  112909:	0f b7 c0             	movzwl %ax,%eax
  11290c:	83 e0 0f             	and    $0xf,%eax
  11290f:	c1 e0 02             	shl    $0x2,%eax
  112912:	f7 d8                	neg    %eax
  112914:	98                   	cwtl   
  112915:	89 44 24 04          	mov    %eax,0x4(%esp)
  112919:	8b 45 08             	mov    0x8(%ebp),%eax
  11291c:	89 04 24             	mov    %eax,(%esp)
  11291f:	e8 9c ca ff ff       	call   10f3c0 <pbuf_header>
  112924:	84 c0                	test   %al,%al
  112926:	75 0d                	jne    112935 <tcp_input+0xa5>
  112928:	8b 45 08             	mov    0x8(%ebp),%eax
  11292b:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  11292f:	66 83 f8 13          	cmp    $0x13,%ax
  112933:	77 30                	ja     112965 <tcp_input+0xd5>
    /* drop short packets */
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: short packet (%u bytes) discarded\n", p->tot_len));
    TCP_STATS_INC(tcp.lenerr);
  112935:	0f b7 05 6e 15 14 00 	movzwl 0x14156e,%eax
  11293c:	83 c0 01             	add    $0x1,%eax
  11293f:	66 a3 6e 15 14 00    	mov    %ax,0x14156e
    TCP_STATS_INC(tcp.drop);
  112945:	0f b7 05 6a 15 14 00 	movzwl 0x14156a,%eax
  11294c:	83 c0 01             	add    $0x1,%eax
  11294f:	66 a3 6a 15 14 00    	mov    %ax,0x14156a
    pbuf_free(p);
  112955:	8b 45 08             	mov    0x8(%ebp),%eax
  112958:	89 04 24             	mov    %eax,(%esp)
  11295b:	e8 60 cb ff ff       	call   10f4c0 <pbuf_free>
    return;
  112960:	e9 2c 07 00 00       	jmp    113091 <tcp_input+0x801>
  }

  /* Don't even process incoming broadcasts/multicasts. */
  if (ip_addr_isbroadcast(&(iphdr->dest), &(inp->netmask)) ||
  112965:	a1 08 99 13 00       	mov    0x139908,%eax
  11296a:	8b 50 10             	mov    0x10(%eax),%edx
  11296d:	8b 45 0c             	mov    0xc(%ebp),%eax
  112970:	8b 40 08             	mov    0x8(%eax),%eax
  112973:	f7 d0                	not    %eax
  112975:	21 c2                	and    %eax,%edx
  112977:	8b 45 0c             	mov    0xc(%ebp),%eax
  11297a:	8b 40 08             	mov    0x8(%eax),%eax
  11297d:	f7 d0                	not    %eax
  11297f:	39 c2                	cmp    %eax,%edx
  112981:	74 3f                	je     1129c2 <tcp_input+0x132>
  112983:	a1 08 99 13 00       	mov    0x139908,%eax
  112988:	8b 40 10             	mov    0x10(%eax),%eax
  11298b:	83 f8 ff             	cmp    $0xffffffff,%eax
  11298e:	74 32                	je     1129c2 <tcp_input+0x132>
  112990:	a1 08 99 13 00       	mov    0x139908,%eax
  112995:	8b 40 10             	mov    0x10(%eax),%eax
  112998:	85 c0                	test   %eax,%eax
  11299a:	74 26                	je     1129c2 <tcp_input+0x132>
  11299c:	a1 08 99 13 00       	mov    0x139908,%eax
  1129a1:	8b 58 10             	mov    0x10(%eax),%ebx
  1129a4:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  1129ab:	e8 60 b9 ff ff       	call   10e310 <ntohl>
  1129b0:	21 c3                	and    %eax,%ebx
  1129b2:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  1129b9:	e8 52 b9 ff ff       	call   10e310 <ntohl>
  1129be:	39 c3                	cmp    %eax,%ebx
  1129c0:	75 10                	jne    1129d2 <tcp_input+0x142>
     ip_addr_ismulticast(&(iphdr->dest))) {
    pbuf_free(p);
  1129c2:	8b 45 08             	mov    0x8(%ebp),%eax
  1129c5:	89 04 24             	mov    %eax,(%esp)
  1129c8:	e8 f3 ca ff ff       	call   10f4c0 <pbuf_free>
    return;
  1129cd:	e9 bf 06 00 00       	jmp    113091 <tcp_input+0x801>
  }

  /* Verify TCP checksum. */
  if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
  1129d2:	8b 45 08             	mov    0x8(%ebp),%eax
  1129d5:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  1129d9:	0f b7 d0             	movzwl %ax,%edx
  1129dc:	a1 08 99 13 00       	mov    0x139908,%eax
  1129e1:	8d 48 10             	lea    0x10(%eax),%ecx
  1129e4:	a1 08 99 13 00       	mov    0x139908,%eax
  1129e9:	83 c0 0c             	add    $0xc,%eax
  1129ec:	89 54 24 10          	mov    %edx,0x10(%esp)
  1129f0:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
  1129f7:	00 
  1129f8:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  1129fc:	89 44 24 04          	mov    %eax,0x4(%esp)
  112a00:	8b 45 08             	mov    0x8(%ebp),%eax
  112a03:	89 04 24             	mov    %eax,(%esp)
  112a06:	e8 35 b2 ff ff       	call   10dc40 <inet_chksum_pseudo>
  112a0b:	66 85 c0             	test   %ax,%ax
  112a0e:	74 30                	je     112a40 <tcp_input+0x1b0>
      (struct ip_addr *)&(iphdr->dest),
      IP_PROTO_TCP, p->tot_len) != 0) {
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packet discarded due to failing checksum 0x%04x\n",
        inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src), (struct ip_addr *)&(iphdr->dest),
      IP_PROTO_TCP, p->tot_len)));
#if TCP_DEBUG
    tcp_debug_print(tcphdr);
#endif /* TCP_DEBUG */
    TCP_STATS_INC(tcp.chkerr);
  112a10:	0f b7 05 6c 15 14 00 	movzwl 0x14156c,%eax
  112a17:	83 c0 01             	add    $0x1,%eax
  112a1a:	66 a3 6c 15 14 00    	mov    %ax,0x14156c
    TCP_STATS_INC(tcp.drop);
  112a20:	0f b7 05 6a 15 14 00 	movzwl 0x14156a,%eax
  112a27:	83 c0 01             	add    $0x1,%eax
  112a2a:	66 a3 6a 15 14 00    	mov    %ax,0x14156a

    pbuf_free(p);
  112a30:	8b 45 08             	mov    0x8(%ebp),%eax
  112a33:	89 04 24             	mov    %eax,(%esp)
  112a36:	e8 85 ca ff ff       	call   10f4c0 <pbuf_free>
    return;
  112a3b:	e9 51 06 00 00       	jmp    113091 <tcp_input+0x801>
  }

  /* Move the payload pointer in the pbuf so that it points to the
     TCP data instead of the TCP header. */
  hdrlen = TCPH_HDRLEN(tcphdr);
  112a40:	a1 04 99 13 00       	mov    0x139904,%eax
  112a45:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  112a49:	0f b7 c0             	movzwl %ax,%eax
  112a4c:	89 04 24             	mov    %eax,(%esp)
  112a4f:	e8 5c b8 ff ff       	call   10e2b0 <ntohs>
  112a54:	66 c1 e8 0c          	shr    $0xc,%ax
  112a58:	88 45 e6             	mov    %al,0xffffffe6(%ebp)
  pbuf_header(p, -(hdrlen * 4));
  112a5b:	0f b6 45 e6          	movzbl 0xffffffe6(%ebp),%eax
  112a5f:	c1 e0 02             	shl    $0x2,%eax
  112a62:	f7 d8                	neg    %eax
  112a64:	98                   	cwtl   
  112a65:	89 44 24 04          	mov    %eax,0x4(%esp)
  112a69:	8b 45 08             	mov    0x8(%ebp),%eax
  112a6c:	89 04 24             	mov    %eax,(%esp)
  112a6f:	e8 4c c9 ff ff       	call   10f3c0 <pbuf_header>

  /* Convert fields in TCP header to host byte order. */
  tcphdr->src = ntohs(tcphdr->src);
  112a74:	8b 1d 04 99 13 00    	mov    0x139904,%ebx
  112a7a:	a1 04 99 13 00       	mov    0x139904,%eax
  112a7f:	0f b7 00             	movzwl (%eax),%eax
  112a82:	0f b7 c0             	movzwl %ax,%eax
  112a85:	89 04 24             	mov    %eax,(%esp)
  112a88:	e8 23 b8 ff ff       	call   10e2b0 <ntohs>
  112a8d:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = ntohs(tcphdr->dest);
  112a90:	8b 1d 04 99 13 00    	mov    0x139904,%ebx
  112a96:	a1 04 99 13 00       	mov    0x139904,%eax
  112a9b:	0f b7 40 02          	movzwl 0x2(%eax),%eax
  112a9f:	0f b7 c0             	movzwl %ax,%eax
  112aa2:	89 04 24             	mov    %eax,(%esp)
  112aa5:	e8 06 b8 ff ff       	call   10e2b0 <ntohs>
  112aaa:	66 89 43 02          	mov    %ax,0x2(%ebx)
  seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
  112aae:	8b 1d 04 99 13 00    	mov    0x139904,%ebx
  112ab4:	a1 04 99 13 00       	mov    0x139904,%eax
  112ab9:	8b 40 04             	mov    0x4(%eax),%eax
  112abc:	89 04 24             	mov    %eax,(%esp)
  112abf:	e8 4c b8 ff ff       	call   10e310 <ntohl>
  112ac4:	89 43 04             	mov    %eax,0x4(%ebx)
  112ac7:	8b 43 04             	mov    0x4(%ebx),%eax
  112aca:	a3 0c 99 13 00       	mov    %eax,0x13990c
  ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
  112acf:	8b 1d 04 99 13 00    	mov    0x139904,%ebx
  112ad5:	a1 04 99 13 00       	mov    0x139904,%eax
  112ada:	8b 40 08             	mov    0x8(%eax),%eax
  112add:	89 04 24             	mov    %eax,(%esp)
  112ae0:	e8 2b b8 ff ff       	call   10e310 <ntohl>
  112ae5:	89 43 08             	mov    %eax,0x8(%ebx)
  112ae8:	8b 43 08             	mov    0x8(%ebx),%eax
  112aeb:	a3 10 99 13 00       	mov    %eax,0x139910
  tcphdr->wnd = ntohs(tcphdr->wnd);
  112af0:	8b 1d 04 99 13 00    	mov    0x139904,%ebx
  112af6:	a1 04 99 13 00       	mov    0x139904,%eax
  112afb:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
  112aff:	0f b7 c0             	movzwl %ax,%eax
  112b02:	89 04 24             	mov    %eax,(%esp)
  112b05:	e8 a6 b7 ff ff       	call   10e2b0 <ntohs>
  112b0a:	66 89 43 0e          	mov    %ax,0xe(%ebx)

  flags = TCPH_FLAGS(tcphdr) & TCP_FLAGS;
  112b0e:	a1 04 99 13 00       	mov    0x139904,%eax
  112b13:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  112b17:	0f b7 c0             	movzwl %ax,%eax
  112b1a:	89 04 24             	mov    %eax,(%esp)
  112b1d:	e8 8e b7 ff ff       	call   10e2b0 <ntohs>
  112b22:	83 e0 3f             	and    $0x3f,%eax
  112b25:	a2 14 99 13 00       	mov    %al,0x139914
  tcplen = p->tot_len + ((flags & TCP_FIN || flags & TCP_SYN)? 1: 0);
  112b2a:	8b 45 08             	mov    0x8(%ebp),%eax
  112b2d:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  112b31:	66 89 45 ce          	mov    %ax,0xffffffce(%ebp)
  112b35:	0f b6 05 14 99 13 00 	movzbl 0x139914,%eax
  112b3c:	0f b6 c0             	movzbl %al,%eax
  112b3f:	83 e0 01             	and    $0x1,%eax
  112b42:	84 c0                	test   %al,%al
  112b44:	75 11                	jne    112b57 <tcp_input+0x2c7>
  112b46:	0f b6 05 14 99 13 00 	movzbl 0x139914,%eax
  112b4d:	0f b6 c0             	movzbl %al,%eax
  112b50:	83 e0 02             	and    $0x2,%eax
  112b53:	85 c0                	test   %eax,%eax
  112b55:	74 09                	je     112b60 <tcp_input+0x2d0>
  112b57:	c7 45 d0 01 00 00 00 	movl   $0x1,0xffffffd0(%ebp)
  112b5e:	eb 07                	jmp    112b67 <tcp_input+0x2d7>
  112b60:	c7 45 d0 00 00 00 00 	movl   $0x0,0xffffffd0(%ebp)
  112b67:	0f b7 45 d0          	movzwl 0xffffffd0(%ebp),%eax
  112b6b:	66 03 45 ce          	add    0xffffffce(%ebp),%ax
  112b6f:	66 a3 16 99 13 00    	mov    %ax,0x139916

  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;
  112b75:	c7 45 dc 00 00 00 00 	movl   $0x0,0xffffffdc(%ebp)

#if SO_REUSE
  pcb_temp = tcp_active_pcbs;
  112b7c:	a1 54 16 14 00       	mov    0x141654,%eax
  112b81:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
  
 again_1:
  
  /* Iterate through the TCP pcb list for a fully matching pcb */
  for(pcb = pcb_temp; pcb != NULL; pcb = pcb->next) {
  112b84:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  112b87:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
  112b8a:	e9 d0 00 00 00       	jmp    112c5f <tcp_input+0x3cf>
#else  /* SO_REUSE */
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
#endif  /* SO_REUSE */
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
    if (pcb->remote_port == tcphdr->src &&
  112b8f:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  112b92:	0f b7 50 1e          	movzwl 0x1e(%eax),%edx
  112b96:	a1 04 99 13 00       	mov    0x139904,%eax
  112b9b:	0f b7 00             	movzwl (%eax),%eax
  112b9e:	66 39 c2             	cmp    %ax,%dx
  112ba1:	0f 85 a9 00 00 00    	jne    112c50 <tcp_input+0x3c0>
  112ba7:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  112baa:	0f b7 50 1c          	movzwl 0x1c(%eax),%edx
  112bae:	a1 04 99 13 00       	mov    0x139904,%eax
  112bb3:	0f b7 40 02          	movzwl 0x2(%eax),%eax
  112bb7:	66 39 c2             	cmp    %ax,%dx
  112bba:	0f 85 90 00 00 00    	jne    112c50 <tcp_input+0x3c0>
  112bc0:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  112bc3:	8b 50 04             	mov    0x4(%eax),%edx
  112bc6:	a1 08 99 13 00       	mov    0x139908,%eax
  112bcb:	8b 40 0c             	mov    0xc(%eax),%eax
  112bce:	39 c2                	cmp    %eax,%edx
  112bd0:	75 7e                	jne    112c50 <tcp_input+0x3c0>
  112bd2:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  112bd5:	8b 10                	mov    (%eax),%edx
  112bd7:	a1 08 99 13 00       	mov    0x139908,%eax
  112bdc:	8b 40 10             	mov    0x10(%eax),%eax
  112bdf:	39 c2                	cmp    %eax,%edx
  112be1:	75 6d                	jne    112c50 <tcp_input+0x3c0>
       pcb->local_port == tcphdr->dest &&
       ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
       ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest))) {

#if SO_REUSE
      if(pcb->so_options & SOF_REUSEPORT) {
  112be3:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  112be6:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  112bea:	0f b7 c0             	movzwl %ax,%eax
  112bed:	25 00 02 00 00       	and    $0x200,%eax
  112bf2:	85 c0                	test   %eax,%eax
  112bf4:	74 32                	je     112c28 <tcp_input+0x398>
        if(reuse) {
  112bf6:	83 7d ec 00          	cmpl   $0x0,0xffffffec(%ebp)
  112bfa:	74 02                	je     112bfe <tcp_input+0x36e>
  112bfc:	eb 07                	jmp    112c05 <tcp_input+0x375>
          /* We processed one PCB already */
          LWIP_DEBUGF(TCP_INPUT_DEBUG,("tcp_input: second or later PCB and SOF_REUSEPORT set.\n"));
        } else {
          /* First PCB with this address */
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: first PCB and SOF_REUSEPORT set.\n"));
          reuse = 1;
  112bfe:	c7 45 ec 01 00 00 00 	movl   $0x1,0xffffffec(%ebp)
        }
        
        reuse_port = 1; 
  112c05:	c7 45 f0 01 00 00 00 	movl   $0x1,0xfffffff0(%ebp)
        p->ref++;
  112c0c:	8b 45 08             	mov    0x8(%ebp),%eax
  112c0f:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
  112c13:	8d 50 01             	lea    0x1(%eax),%edx
  112c16:	8b 45 08             	mov    0x8(%ebp),%eax
  112c19:	66 89 50 0e          	mov    %dx,0xe(%eax)
        
        /* We want to search on next socket after receiving */
        pcb_temp = pcb->next;
  112c1d:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  112c20:	8b 40 0c             	mov    0xc(%eax),%eax
  112c23:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
  112c26:	eb 00                	jmp    112c28 <tcp_input+0x398>
        
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: reference counter on PBUF set to %i\n", p->ref));
      } else  {
        if(reuse) {
          /* We processed one PCB already */
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: second or later PCB but SOF_REUSEPORT not set !\n"));
        }
      }
#endif /* SO_REUSE */

      /* Move this PCB to the front of the list so that subsequent
   lookups will be faster (we exploit locality in TCP segment
   arrivals). */
      LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
      if (prev != NULL) {
  112c28:	83 7d dc 00          	cmpl   $0x0,0xffffffdc(%ebp)
  112c2c:	74 3b                	je     112c69 <tcp_input+0x3d9>
  prev->next = pcb->next;
  112c2e:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  112c31:	8b 50 0c             	mov    0xc(%eax),%edx
  112c34:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  112c37:	89 50 0c             	mov    %edx,0xc(%eax)
  pcb->next = tcp_active_pcbs;
  112c3a:	8b 15 54 16 14 00    	mov    0x141654,%edx
  112c40:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  112c43:	89 50 0c             	mov    %edx,0xc(%eax)
  tcp_active_pcbs = pcb;
  112c46:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  112c49:	a3 54 16 14 00       	mov    %eax,0x141654
      }
      LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
      break;
  112c4e:	eb 19                	jmp    112c69 <tcp_input+0x3d9>
    }
    prev = pcb;
  112c50:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  112c53:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
  112c56:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  112c59:	8b 40 0c             	mov    0xc(%eax),%eax
  112c5c:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
  112c5f:	83 7d d8 00          	cmpl   $0x0,0xffffffd8(%ebp)
  112c63:	0f 85 26 ff ff ff    	jne    112b8f <tcp_input+0x2ff>
  }

  if (pcb == NULL) {
  112c69:	83 7d d8 00          	cmpl   $0x0,0xffffffd8(%ebp)
  112c6d:	0f 85 24 01 00 00    	jne    112d97 <tcp_input+0x507>
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */

    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  112c73:	a1 64 16 14 00       	mov    0x141664,%eax
  112c78:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
  112c7b:	eb 70                	jmp    112ced <tcp_input+0x45d>
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
      if (pcb->remote_port == tcphdr->src &&
  112c7d:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  112c80:	0f b7 50 1e          	movzwl 0x1e(%eax),%edx
  112c84:	a1 04 99 13 00       	mov    0x139904,%eax
  112c89:	0f b7 00             	movzwl (%eax),%eax
  112c8c:	66 39 c2             	cmp    %ax,%dx
  112c8f:	75 53                	jne    112ce4 <tcp_input+0x454>
  112c91:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  112c94:	0f b7 50 1c          	movzwl 0x1c(%eax),%edx
  112c98:	a1 04 99 13 00       	mov    0x139904,%eax
  112c9d:	0f b7 40 02          	movzwl 0x2(%eax),%eax
  112ca1:	66 39 c2             	cmp    %ax,%dx
  112ca4:	75 3e                	jne    112ce4 <tcp_input+0x454>
  112ca6:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  112ca9:	8b 50 04             	mov    0x4(%eax),%edx
  112cac:	a1 08 99 13 00       	mov    0x139908,%eax
  112cb1:	8b 40 0c             	mov    0xc(%eax),%eax
  112cb4:	39 c2                	cmp    %eax,%edx
  112cb6:	75 2c                	jne    112ce4 <tcp_input+0x454>
  112cb8:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  112cbb:	8b 10                	mov    (%eax),%edx
  112cbd:	a1 08 99 13 00       	mov    0x139908,%eax
  112cc2:	8b 40 10             	mov    0x10(%eax),%eax
  112cc5:	39 c2                	cmp    %eax,%edx
  112cc7:	75 1b                	jne    112ce4 <tcp_input+0x454>
   pcb->local_port == tcphdr->dest &&
   ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
         ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest))) {
  /* We don't really care enough to move this PCB to the front
     of the list since we are not very likely to receive that
     many segments for connections in TIME-WAIT. */
  LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for TIME_WAITing connection.\n"));
  tcp_timewait_input(pcb);
  112cc9:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  112ccc:	89 04 24             	mov    %eax,(%esp)
  112ccf:	e8 3c 06 00 00       	call   113310 <tcp_timewait_input>
  pbuf_free(p);
  112cd4:	8b 45 08             	mov    0x8(%ebp),%eax
  112cd7:	89 04 24             	mov    %eax,(%esp)
  112cda:	e8 e1 c7 ff ff       	call   10f4c0 <pbuf_free>
  return;
  112cdf:	e9 ad 03 00 00       	jmp    113091 <tcp_input+0x801>
  112ce4:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  112ce7:	8b 40 0c             	mov    0xc(%eax),%eax
  112cea:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
  112ced:	83 7d d8 00          	cmpl   $0x0,0xffffffd8(%ebp)
  112cf1:	75 8a                	jne    112c7d <tcp_input+0x3ed>
      }
    }

  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
  112cf3:	c7 45 dc 00 00 00 00 	movl   $0x0,0xffffffdc(%ebp)
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  112cfa:	a1 5c 16 14 00       	mov    0x14165c,%eax
  112cff:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
  112d02:	e9 86 00 00 00       	jmp    112d8d <tcp_input+0x4fd>
      if ((ip_addr_isany(&(lpcb->local_ip)) ||
  112d07:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  112d0a:	85 c0                	test   %eax,%eax
  112d0c:	74 1a                	je     112d28 <tcp_input+0x498>
  112d0e:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  112d11:	8b 00                	mov    (%eax),%eax
  112d13:	85 c0                	test   %eax,%eax
  112d15:	74 11                	je     112d28 <tcp_input+0x498>
  112d17:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  112d1a:	8b 10                	mov    (%eax),%edx
  112d1c:	a1 08 99 13 00       	mov    0x139908,%eax
  112d21:	8b 40 10             	mov    0x10(%eax),%eax
  112d24:	39 c2                	cmp    %eax,%edx
  112d26:	75 56                	jne    112d7e <tcp_input+0x4ee>
  112d28:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  112d2b:	0f b7 50 1c          	movzwl 0x1c(%eax),%edx
  112d2f:	a1 04 99 13 00       	mov    0x139904,%eax
  112d34:	0f b7 40 02          	movzwl 0x2(%eax),%eax
  112d38:	66 39 c2             	cmp    %ax,%dx
  112d3b:	75 41                	jne    112d7e <tcp_input+0x4ee>
    ip_addr_cmp(&(lpcb->local_ip), &(iphdr->dest))) &&
   lpcb->local_port == tcphdr->dest) {
  /* Move this PCB to the front of the list so that subsequent
     lookups will be faster (we exploit locality in TCP segment
     arrivals). */
  if (prev != NULL) {
  112d3d:	83 7d dc 00          	cmpl   $0x0,0xffffffdc(%ebp)
  112d41:	74 20                	je     112d63 <tcp_input+0x4d3>
    ((struct tcp_pcb_listen *)prev)->next = lpcb->next;
  112d43:	8b 55 dc             	mov    0xffffffdc(%ebp),%edx
  112d46:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  112d49:	8b 40 0c             	mov    0xc(%eax),%eax
  112d4c:	89 42 0c             	mov    %eax,0xc(%edx)
          /* our successor is the remainder of the listening list */
    lpcb->next = tcp_listen_pcbs.listen_pcbs;
  112d4f:	8b 15 5c 16 14 00    	mov    0x14165c,%edx
  112d55:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  112d58:	89 50 0c             	mov    %edx,0xc(%eax)
          /* put this listening pcb at the head of the listening list */
    tcp_listen_pcbs.listen_pcbs = lpcb;
  112d5b:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  112d5e:	a3 5c 16 14 00       	mov    %eax,0x14165c
  }

  LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for LISTENing connection.\n"));
  tcp_listen_input(lpcb);
  112d63:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  112d66:	89 04 24             	mov    %eax,(%esp)
  112d69:	e8 32 03 00 00       	call   1130a0 <tcp_listen_input>
  pbuf_free(p);
  112d6e:	8b 45 08             	mov    0x8(%ebp),%eax
  112d71:	89 04 24             	mov    %eax,(%esp)
  112d74:	e8 47 c7 ff ff       	call   10f4c0 <pbuf_free>
  return;
  112d79:	e9 13 03 00 00       	jmp    113091 <tcp_input+0x801>
      }
      prev = (struct tcp_pcb *)lpcb;
  112d7e:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  112d81:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
  112d84:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  112d87:	8b 40 0c             	mov    0xc(%eax),%eax
  112d8a:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
  112d8d:	83 7d e0 00          	cmpl   $0x0,0xffffffe0(%ebp)
  112d91:	0f 85 70 ff ff ff    	jne    112d07 <tcp_input+0x477>
    }
  }

#if TCP_INPUT_DEBUG
  LWIP_DEBUGF(TCP_INPUT_DEBUG, ("+-+-+-+-+-+-+-+-+-+-+-+-+-+- tcp_input: flags "));
  tcp_debug_print_flags(TCPH_FLAGS(tcphdr));
  LWIP_DEBUGF(TCP_INPUT_DEBUG, ("-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"));
#endif /* TCP_INPUT_DEBUG */


  if (pcb != NULL) {
  112d97:	83 7d d8 00          	cmpl   $0x0,0xffffffd8(%ebp)
  112d9b:	0f 84 36 02 00 00    	je     112fd7 <tcp_input+0x747>
    /* The incoming segment belongs to a connection. */
#if TCP_INPUT_DEBUG
#if TCP_DEBUG
    tcp_debug_print_state(pcb->state);
#endif /* TCP_DEBUG */
#endif /* TCP_INPUT_DEBUG */

    /* Set up a tcp_seg structure. */
    inseg.next = NULL;
  112da1:	c7 05 f0 98 13 00 00 	movl   $0x0,0x1398f0
  112da8:	00 00 00 
    inseg.len = p->tot_len;
  112dab:	8b 45 08             	mov    0x8(%ebp),%eax
  112dae:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  112db2:	66 a3 fc 98 13 00    	mov    %ax,0x1398fc
    inseg.dataptr = p->payload;
  112db8:	8b 45 08             	mov    0x8(%ebp),%eax
  112dbb:	8b 40 04             	mov    0x4(%eax),%eax
  112dbe:	a3 f8 98 13 00       	mov    %eax,0x1398f8
    inseg.p = p;
  112dc3:	8b 45 08             	mov    0x8(%ebp),%eax
  112dc6:	a3 f4 98 13 00       	mov    %eax,0x1398f4
    inseg.tcphdr = tcphdr;
  112dcb:	a1 04 99 13 00       	mov    0x139904,%eax
  112dd0:	a3 00 99 13 00       	mov    %eax,0x139900

    recv_data = NULL;
  112dd5:	c7 05 1c 99 13 00 00 	movl   $0x0,0x13991c
  112ddc:	00 00 00 
    recv_flags = 0;
  112ddf:	c6 05 18 99 13 00 00 	movb   $0x0,0x139918

    tcp_input_pcb = pcb;
  112de6:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  112de9:	a3 68 16 14 00       	mov    %eax,0x141668
    err = tcp_process(pcb);
  112dee:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  112df1:	89 04 24             	mov    %eax,(%esp)
  112df4:	e8 97 05 00 00       	call   113390 <tcp_process>
  112df9:	88 45 e7             	mov    %al,0xffffffe7(%ebp)
    tcp_input_pcb = NULL;
  112dfc:	c7 05 68 16 14 00 00 	movl   $0x0,0x141668
  112e03:	00 00 00 
    /* A return value of ERR_ABRT means that tcp_abort() was called
       and that the pcb has been freed. If so, we don't do anything. */
    if (err != ERR_ABRT) {
  112e06:	80 7d e7 fd          	cmpb   $0xfd,0xffffffe7(%ebp)
  112e0a:	0f 84 a4 01 00 00    	je     112fb4 <tcp_input+0x724>
      if (recv_flags & TF_RESET) {
  112e10:	0f b6 05 18 99 13 00 	movzbl 0x139918,%eax
  112e17:	0f b6 c0             	movzbl %al,%eax
  112e1a:	83 e0 08             	and    $0x8,%eax
  112e1d:	85 c0                	test   %eax,%eax
  112e1f:	74 54                	je     112e75 <tcp_input+0x5e5>
  /* TF_RESET means that the connection was reset by the other
     end. We then call the error callback to inform the
     application that the connection is dead before we
     deallocate the PCB. */
  TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_RST);
  112e21:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  112e24:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
  112e2a:	85 c0                	test   %eax,%eax
  112e2c:	74 1c                	je     112e4a <tcp_input+0x5ba>
  112e2e:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  112e31:	8b 90 90 00 00 00    	mov    0x90(%eax),%edx
  112e37:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  112e3a:	8b 40 18             	mov    0x18(%eax),%eax
  112e3d:	c7 44 24 04 fc ff ff 	movl   $0xfffffffc,0x4(%esp)
  112e44:	ff 
  112e45:	89 04 24             	mov    %eax,(%esp)
  112e48:	ff d2                	call   *%edx
  tcp_pcb_remove(&tcp_active_pcbs, pcb);
  112e4a:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  112e4d:	89 44 24 04          	mov    %eax,0x4(%esp)
  112e51:	c7 04 24 54 16 14 00 	movl   $0x141654,(%esp)
  112e58:	e8 93 e7 ff ff       	call   1115f0 <tcp_pcb_remove>
  memp_free(MEMP_TCP_PCB, pcb);
  112e5d:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  112e60:	89 44 24 04          	mov    %eax,0x4(%esp)
  112e64:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  112e6b:	e8 50 bc ff ff       	call   10eac0 <memp_free>
  112e70:	e9 3f 01 00 00       	jmp    112fb4 <tcp_input+0x724>
      } else if (recv_flags & TF_CLOSED) {
  112e75:	0f b6 05 18 99 13 00 	movzbl 0x139918,%eax
  112e7c:	0f b6 c0             	movzbl %al,%eax
  112e7f:	83 e0 10             	and    $0x10,%eax
  112e82:	85 c0                	test   %eax,%eax
  112e84:	74 2b                	je     112eb1 <tcp_input+0x621>
  /* The connection has been closed and we will deallocate the
     PCB. */
  tcp_pcb_remove(&tcp_active_pcbs, pcb);
  112e86:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  112e89:	89 44 24 04          	mov    %eax,0x4(%esp)
  112e8d:	c7 04 24 54 16 14 00 	movl   $0x141654,(%esp)
  112e94:	e8 57 e7 ff ff       	call   1115f0 <tcp_pcb_remove>
  memp_free(MEMP_TCP_PCB, pcb);
  112e99:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  112e9c:	89 44 24 04          	mov    %eax,0x4(%esp)
  112ea0:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  112ea7:	e8 14 bc ff ff       	call   10eac0 <memp_free>
  112eac:	e9 03 01 00 00       	jmp    112fb4 <tcp_input+0x724>
      } else {
  err = ERR_OK;
  112eb1:	c6 45 e7 00          	movb   $0x0,0xffffffe7(%ebp)
  /* If the application has registered a "sent" function to be
     called when new send buffer space is available, we call it
     now. */
  if (pcb->acked > 0) {
  112eb5:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  112eb8:	0f b7 40 68          	movzwl 0x68(%eax),%eax
  112ebc:	66 85 c0             	test   %ax,%ax
  112ebf:	74 33                	je     112ef4 <tcp_input+0x664>
    TCP_EVENT_SENT(pcb, pcb->acked, err);
  112ec1:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  112ec4:	8b 40 7c             	mov    0x7c(%eax),%eax
  112ec7:	85 c0                	test   %eax,%eax
  112ec9:	74 29                	je     112ef4 <tcp_input+0x664>
  112ecb:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  112ece:	8b 58 7c             	mov    0x7c(%eax),%ebx
  112ed1:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  112ed4:	0f b7 40 68          	movzwl 0x68(%eax),%eax
  112ed8:	0f b7 d0             	movzwl %ax,%edx
  112edb:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  112ede:	8b 48 18             	mov    0x18(%eax),%ecx
  112ee1:	89 54 24 08          	mov    %edx,0x8(%esp)
  112ee5:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  112ee8:	89 44 24 04          	mov    %eax,0x4(%esp)
  112eec:	89 0c 24             	mov    %ecx,(%esp)
  112eef:	ff d3                	call   *%ebx
  112ef1:	88 45 e7             	mov    %al,0xffffffe7(%ebp)
  }

  if (recv_data != NULL) {
  112ef4:	a1 1c 99 13 00       	mov    0x13991c,%eax
  112ef9:	85 c0                	test   %eax,%eax
  112efb:	74 4c                	je     112f49 <tcp_input+0x6b9>
    /* Notify application that data has been received. */
    TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
  112efd:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  112f00:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
  112f06:	85 c0                	test   %eax,%eax
  112f08:	74 32                	je     112f3c <tcp_input+0x6ac>
  112f0a:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  112f0d:	8b 98 80 00 00 00    	mov    0x80(%eax),%ebx
  112f13:	8b 15 1c 99 13 00    	mov    0x13991c,%edx
  112f19:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  112f1c:	8b 48 18             	mov    0x18(%eax),%ecx
  112f1f:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  112f26:	00 
  112f27:	89 54 24 08          	mov    %edx,0x8(%esp)
  112f2b:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  112f2e:	89 44 24 04          	mov    %eax,0x4(%esp)
  112f32:	89 0c 24             	mov    %ecx,(%esp)
  112f35:	ff d3                	call   *%ebx
  112f37:	88 45 e7             	mov    %al,0xffffffe7(%ebp)
  112f3a:	eb 0d                	jmp    112f49 <tcp_input+0x6b9>
  112f3c:	a1 1c 99 13 00       	mov    0x13991c,%eax
  112f41:	89 04 24             	mov    %eax,(%esp)
  112f44:	e8 77 c5 ff ff       	call   10f4c0 <pbuf_free>
  }

  /* If a FIN segment was received, we call the callback
     function with a NULL buffer to indicate EOF. */
  if (recv_flags & TF_GOT_FIN) {
  112f49:	0f b6 05 18 99 13 00 	movzbl 0x139918,%eax
  112f50:	0f b6 c0             	movzbl %al,%eax
  112f53:	83 e0 20             	and    $0x20,%eax
  112f56:	85 c0                	test   %eax,%eax
  112f58:	74 49                	je     112fa3 <tcp_input+0x713>
    TCP_EVENT_RECV(pcb, NULL, ERR_OK, err);
  112f5a:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  112f5d:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
  112f63:	85 c0                	test   %eax,%eax
  112f65:	74 30                	je     112f97 <tcp_input+0x707>
  112f67:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  112f6a:	8b 88 80 00 00 00    	mov    0x80(%eax),%ecx
  112f70:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  112f73:	8b 50 18             	mov    0x18(%eax),%edx
  112f76:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  112f7d:	00 
  112f7e:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  112f85:	00 
  112f86:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  112f89:	89 44 24 04          	mov    %eax,0x4(%esp)
  112f8d:	89 14 24             	mov    %edx,(%esp)
  112f90:	ff d1                	call   *%ecx
  112f92:	88 45 e7             	mov    %al,0xffffffe7(%ebp)
  112f95:	eb 0c                	jmp    112fa3 <tcp_input+0x713>
  112f97:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  112f9e:	e8 1d c5 ff ff       	call   10f4c0 <pbuf_free>
  }
  /* If there were no errors, we try to send something out. */
  if (err == ERR_OK) {
  112fa3:	80 7d e7 00          	cmpb   $0x0,0xffffffe7(%ebp)
  112fa7:	75 0b                	jne    112fb4 <tcp_input+0x724>
    tcp_output(pcb);
  112fa9:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  112fac:	89 04 24             	mov    %eax,(%esp)
  112faf:	e8 9c ee ff ff       	call   111e50 <tcp_output>
  }
      }
    }


    /* We deallocate the incoming pbuf. If it was buffered by the
       application, the application should have called pbuf_ref() to
       increase the reference counter in the pbuf. If so, the buffer
       isn't actually deallocated by the call to pbuf_free(), only the
       reference count is decreased. */
    pbuf_free(inseg.p);
  112fb4:	a1 f4 98 13 00       	mov    0x1398f4,%eax
  112fb9:	89 04 24             	mov    %eax,(%esp)
  112fbc:	e8 ff c4 ff ff       	call   10f4c0 <pbuf_free>
#if TCP_INPUT_DEBUG
#if TCP_DEBUG
    tcp_debug_print_state(pcb->state);
#endif /* TCP_DEBUG */
#endif /* TCP_INPUT_DEBUG */
#if SO_REUSE
    /* First socket should receive now */
    if(reuse_port) {
  112fc1:	83 7d f0 00          	cmpl   $0x0,0xfffffff0(%ebp)
  112fc5:	0f 84 c6 00 00 00    	je     113091 <tcp_input+0x801>
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: searching next PCB.\n"));
      reuse_port = 0;
  112fcb:	c7 45 f0 00 00 00 00 	movl   $0x0,0xfffffff0(%ebp)
      
      /* We are searching connected sockets */
      goto again_1;
  112fd2:	e9 ad fb ff ff       	jmp    112b84 <tcp_input+0x2f4>
    }
#endif /* SO_REUSE */

  } else {
#if SO_REUSE
    if(reuse) {
  112fd7:	83 7d ec 00          	cmpl   $0x0,0xffffffec(%ebp)
  112fdb:	74 10                	je     112fed <tcp_input+0x75d>
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: freeing PBUF with reference counter set to %i\n", p->ref));
      pbuf_free(p);
  112fdd:	8b 45 08             	mov    0x8(%ebp),%eax
  112fe0:	89 04 24             	mov    %eax,(%esp)
  112fe3:	e8 d8 c4 ff ff       	call   10f4c0 <pbuf_free>
      goto end;
  112fe8:	e9 a4 00 00 00       	jmp    113091 <tcp_input+0x801>
    }
#endif /* SO_REUSE */
    /* If no matching PCB was found, send a TCP RST (reset) to the
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
  112fed:	a1 04 99 13 00       	mov    0x139904,%eax
  112ff2:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  112ff6:	0f b7 c0             	movzwl %ax,%eax
  112ff9:	89 04 24             	mov    %eax,(%esp)
  112ffc:	e8 af b2 ff ff       	call   10e2b0 <ntohs>
  113001:	0f b7 c0             	movzwl %ax,%eax
  113004:	83 e0 04             	and    $0x4,%eax
  113007:	85 c0                	test   %eax,%eax
  113009:	75 7b                	jne    113086 <tcp_input+0x7f6>
      TCP_STATS_INC(tcp.proterr);
  11300b:	0f b7 05 74 15 14 00 	movzwl 0x141574,%eax
  113012:	83 c0 01             	add    $0x1,%eax
  113015:	66 a3 74 15 14 00    	mov    %ax,0x141574
      TCP_STATS_INC(tcp.drop);
  11301b:	0f b7 05 6a 15 14 00 	movzwl 0x14156a,%eax
  113022:	83 c0 01             	add    $0x1,%eax
  113025:	66 a3 6a 15 14 00    	mov    %ax,0x14156a
      tcp_rst(ackno, seqno + tcplen,
  11302b:	a1 04 99 13 00       	mov    0x139904,%eax
  113030:	0f b7 00             	movzwl (%eax),%eax
  113033:	0f b7 f0             	movzwl %ax,%esi
  113036:	a1 04 99 13 00       	mov    0x139904,%eax
  11303b:	0f b7 40 02          	movzwl 0x2(%eax),%eax
  11303f:	0f b7 f8             	movzwl %ax,%edi
  113042:	a1 08 99 13 00       	mov    0x139908,%eax
  113047:	8d 48 0c             	lea    0xc(%eax),%ecx
  11304a:	a1 08 99 13 00       	mov    0x139908,%eax
  11304f:	8d 58 10             	lea    0x10(%eax),%ebx
  113052:	0f b7 05 16 99 13 00 	movzwl 0x139916,%eax
  113059:	0f b7 d0             	movzwl %ax,%edx
  11305c:	a1 0c 99 13 00       	mov    0x13990c,%eax
  113061:	8d 04 02             	lea    (%edx,%eax,1),%eax
  113064:	8b 15 10 99 13 00    	mov    0x139910,%edx
  11306a:	89 74 24 14          	mov    %esi,0x14(%esp)
  11306e:	89 7c 24 10          	mov    %edi,0x10(%esp)
  113072:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
  113076:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  11307a:	89 44 24 04          	mov    %eax,0x4(%esp)
  11307e:	89 14 24             	mov    %edx,(%esp)
  113081:	e8 4a f4 ff ff       	call   1124d0 <tcp_rst>
        &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
    }
    pbuf_free(p);
  113086:	8b 45 08             	mov    0x8(%ebp),%eax
  113089:	89 04 24             	mov    %eax,(%esp)
  11308c:	e8 2f c4 ff ff       	call   10f4c0 <pbuf_free>
  }
#if SO_REUSE
 end:
#endif /* SO_REUSE */
  LWIP_ASSERT("tcp_input: tcp_pcbs_sane()", tcp_pcbs_sane());
  PERF_STOP("tcp_input");
}
  113091:	83 c4 4c             	add    $0x4c,%esp
  113094:	5b                   	pop    %ebx
  113095:	5e                   	pop    %esi
  113096:	5f                   	pop    %edi
  113097:	5d                   	pop    %ebp
  113098:	c3                   	ret    
  113099:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

001130a0 <tcp_listen_input>:

/* tcp_listen_input():
 *
 * Called by tcp_input() when a segment arrives for a listening
 * connection.
 */

static err_t
tcp_listen_input(struct tcp_pcb_listen *pcb)
{
  1130a0:	55                   	push   %ebp
  1130a1:	89 e5                	mov    %esp,%ebp
  1130a3:	57                   	push   %edi
  1130a4:	56                   	push   %esi
  1130a5:	53                   	push   %ebx
  1130a6:	83 ec 3c             	sub    $0x3c,%esp
  struct tcp_pcb *npcb;
  u32_t optdata;

  /* In the LISTEN state, we check for incoming SYN segments,
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
  1130a9:	0f b6 05 14 99 13 00 	movzbl 0x139914,%eax
  1130b0:	0f b6 c0             	movzbl %al,%eax
  1130b3:	83 e0 10             	and    $0x10,%eax
  1130b6:	85 c0                	test   %eax,%eax
  1130b8:	74 61                	je     11311b <tcp_listen_input+0x7b>
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno + 1, seqno + tcplen,
  1130ba:	a1 04 99 13 00       	mov    0x139904,%eax
  1130bf:	0f b7 00             	movzwl (%eax),%eax
  1130c2:	0f b7 d8             	movzwl %ax,%ebx
  1130c5:	a1 04 99 13 00       	mov    0x139904,%eax
  1130ca:	0f b7 40 02          	movzwl 0x2(%eax),%eax
  1130ce:	0f b7 f0             	movzwl %ax,%esi
  1130d1:	a1 08 99 13 00       	mov    0x139908,%eax
  1130d6:	8d 78 0c             	lea    0xc(%eax),%edi
  1130d9:	a1 08 99 13 00       	mov    0x139908,%eax
  1130de:	8d 48 10             	lea    0x10(%eax),%ecx
  1130e1:	0f b7 05 16 99 13 00 	movzwl 0x139916,%eax
  1130e8:	0f b7 d0             	movzwl %ax,%edx
  1130eb:	a1 0c 99 13 00       	mov    0x13990c,%eax
  1130f0:	01 c2                	add    %eax,%edx
  1130f2:	a1 10 99 13 00       	mov    0x139910,%eax
  1130f7:	83 c0 01             	add    $0x1,%eax
  1130fa:	89 5c 24 14          	mov    %ebx,0x14(%esp)
  1130fe:	89 74 24 10          	mov    %esi,0x10(%esp)
  113102:	89 7c 24 0c          	mov    %edi,0xc(%esp)
  113106:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  11310a:	89 54 24 04          	mov    %edx,0x4(%esp)
  11310e:	89 04 24             	mov    %eax,(%esp)
  113111:	e8 ba f3 ff ff       	call   1124d0 <tcp_rst>
  113116:	e9 d6 01 00 00       	jmp    1132f1 <tcp_listen_input+0x251>
      &(iphdr->dest), &(iphdr->src),
      tcphdr->dest, tcphdr->src);
  } else if (flags & TCP_SYN) {
  11311b:	0f b6 05 14 99 13 00 	movzbl 0x139914,%eax
  113122:	0f b6 c0             	movzbl %al,%eax
  113125:	83 e0 02             	and    $0x2,%eax
  113128:	85 c0                	test   %eax,%eax
  11312a:	0f 84 c1 01 00 00    	je     1132f1 <tcp_listen_input+0x251>
    LWIP_DEBUGF(TCP_DEBUG, ("TCP connection request %u -> %u.\n", tcphdr->src, tcphdr->dest));
    npcb = tcp_alloc(pcb->prio);
  113130:	8b 45 08             	mov    0x8(%ebp),%eax
  113133:	0f b6 40 14          	movzbl 0x14(%eax),%eax
  113137:	0f b6 c0             	movzbl %al,%eax
  11313a:	89 04 24             	mov    %eax,(%esp)
  11313d:	e8 1e e2 ff ff       	call   111360 <tcp_alloc>
  113142:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
    /* If a new PCB could not be created (probably due to lack of memory),
       we don't do anything, but rely on the sender will retransmit the
       SYN at a time when we have more memory available. */
    if (npcb == NULL) {
  113145:	83 7d f0 00          	cmpl   $0x0,0xfffffff0(%ebp)
  113149:	75 1c                	jne    113167 <tcp_listen_input+0xc7>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_listen_input: could not allocate PCB\n"));
      TCP_STATS_INC(tcp.memerr);
  11314b:	0f b7 05 70 15 14 00 	movzwl 0x141570,%eax
  113152:	83 c0 01             	add    $0x1,%eax
  113155:	66 a3 70 15 14 00    	mov    %ax,0x141570
      return ERR_MEM;
  11315b:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,0xffffffd8(%ebp)
  113162:	e9 91 01 00 00       	jmp    1132f8 <tcp_listen_input+0x258>
    }
    /* Set up the new PCB. */
    ip_addr_set(&(npcb->local_ip), &(iphdr->dest));
  113167:	a1 08 99 13 00       	mov    0x139908,%eax
  11316c:	83 c0 10             	add    $0x10,%eax
  11316f:	85 c0                	test   %eax,%eax
  113171:	74 0d                	je     113180 <tcp_listen_input+0xe0>
  113173:	a1 08 99 13 00       	mov    0x139908,%eax
  113178:	8b 40 10             	mov    0x10(%eax),%eax
  11317b:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
  11317e:	eb 07                	jmp    113187 <tcp_listen_input+0xe7>
  113180:	c7 45 dc 00 00 00 00 	movl   $0x0,0xffffffdc(%ebp)
  113187:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  11318a:	8b 55 dc             	mov    0xffffffdc(%ebp),%edx
  11318d:	89 10                	mov    %edx,(%eax)
    npcb->local_port = pcb->local_port;
  11318f:	8b 45 08             	mov    0x8(%ebp),%eax
  113192:	0f b7 50 1c          	movzwl 0x1c(%eax),%edx
  113196:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  113199:	66 89 50 1c          	mov    %dx,0x1c(%eax)
    ip_addr_set(&(npcb->remote_ip), &(iphdr->src));
  11319d:	a1 08 99 13 00       	mov    0x139908,%eax
  1131a2:	83 c0 0c             	add    $0xc,%eax
  1131a5:	85 c0                	test   %eax,%eax
  1131a7:	74 0d                	je     1131b6 <tcp_listen_input+0x116>
  1131a9:	a1 08 99 13 00       	mov    0x139908,%eax
  1131ae:	8b 40 0c             	mov    0xc(%eax),%eax
  1131b1:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
  1131b4:	eb 07                	jmp    1131bd <tcp_listen_input+0x11d>
  1131b6:	c7 45 e0 00 00 00 00 	movl   $0x0,0xffffffe0(%ebp)
  1131bd:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  1131c0:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
  1131c3:	89 50 04             	mov    %edx,0x4(%eax)
    npcb->remote_port = tcphdr->src;
  1131c6:	a1 04 99 13 00       	mov    0x139904,%eax
  1131cb:	0f b7 10             	movzwl (%eax),%edx
  1131ce:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  1131d1:	66 89 50 1e          	mov    %dx,0x1e(%eax)
    npcb->state = SYN_RCVD;
  1131d5:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  1131d8:	c7 40 10 03 00 00 00 	movl   $0x3,0x10(%eax)
    npcb->rcv_nxt = seqno + 1;
  1131df:	a1 0c 99 13 00       	mov    0x13990c,%eax
  1131e4:	8d 50 01             	lea    0x1(%eax),%edx
  1131e7:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  1131ea:	89 50 24             	mov    %edx,0x24(%eax)
    npcb->snd_wnd = tcphdr->wnd;
  1131ed:	a1 04 99 13 00       	mov    0x139904,%eax
  1131f2:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
  1131f6:	0f b7 d0             	movzwl %ax,%edx
  1131f9:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  1131fc:	89 50 58             	mov    %edx,0x58(%eax)
    npcb->ssthresh = npcb->snd_wnd;
  1131ff:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  113202:	8b 40 58             	mov    0x58(%eax),%eax
  113205:	89 c2                	mov    %eax,%edx
  113207:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  11320a:	66 89 50 4c          	mov    %dx,0x4c(%eax)
    npcb->snd_wl1 = seqno - 1;/* initialise to seqno-1 to force window update */
  11320e:	a1 0c 99 13 00       	mov    0x13990c,%eax
  113213:	8d 50 ff             	lea    0xffffffff(%eax),%edx
  113216:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  113219:	89 50 5c             	mov    %edx,0x5c(%eax)
    npcb->callback_arg = pcb->callback_arg;
  11321c:	8b 45 08             	mov    0x8(%ebp),%eax
  11321f:	8b 50 18             	mov    0x18(%eax),%edx
  113222:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  113225:	89 50 18             	mov    %edx,0x18(%eax)
#if LWIP_CALLBACK_API
    npcb->accept = pcb->accept;
  113228:	8b 45 08             	mov    0x8(%ebp),%eax
  11322b:	8b 50 20             	mov    0x20(%eax),%edx
  11322e:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  113231:	89 90 88 00 00 00    	mov    %edx,0x88(%eax)
#endif /* LWIP_CALLBACK_API */
    /* inherit socket options */
    npcb->so_options = pcb->so_options & (SOF_DEBUG|SOF_DONTROUTE|SOF_KEEPALIVE|SOF_OOBINLINE|SOF_LINGER);
  113237:	8b 45 08             	mov    0x8(%ebp),%eax
  11323a:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  11323e:	89 c2                	mov    %eax,%edx
  113240:	66 81 e2 99 01       	and    $0x199,%dx
  113245:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  113248:	66 89 50 08          	mov    %dx,0x8(%eax)
    /* Register the new PCB so that we can begin receiving segments
       for it. */
    TCP_REG(&tcp_active_pcbs, npcb);
  11324c:	8b 15 54 16 14 00    	mov    0x141654,%edx
  113252:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  113255:	89 50 0c             	mov    %edx,0xc(%eax)
  113258:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  11325b:	a3 54 16 14 00       	mov    %eax,0x141654
  113260:	e8 6b 68 00 00       	call   119ad0 <tcp_timer_needed>

    /* Parse any options in the SYN. */
    tcp_parseopt(npcb);
  113265:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  113268:	89 04 24             	mov    %eax,(%esp)
  11326b:	e8 40 18 00 00       	call   114ab0 <tcp_parseopt>

    /* Build an MSS option. */
    optdata = htonl(((u32_t)2 << 24) |
  113270:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  113273:	0f b7 40 34          	movzwl 0x34(%eax),%eax
  113277:	66 c1 e8 08          	shr    $0x8,%ax
  11327b:	0f b7 c0             	movzwl %ax,%eax
  11327e:	89 c2                	mov    %eax,%edx
  113280:	c1 e2 08             	shl    $0x8,%edx
  113283:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  113286:	0f b7 40 34          	movzwl 0x34(%eax),%eax
  11328a:	0f b7 c0             	movzwl %ax,%eax
  11328d:	25 ff 00 00 00       	and    $0xff,%eax
  113292:	09 d0                	or     %edx,%eax
  113294:	0d 00 00 04 02       	or     $0x2040000,%eax
  113299:	89 04 24             	mov    %eax,(%esp)
  11329c:	e8 2f b0 ff ff       	call   10e2d0 <htonl>
  1132a1:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
        ((u32_t)4 << 16) |
        (((u32_t)npcb->mss / 256) << 8) |
        (npcb->mss & 255));
    /* Send a SYN|ACK together with the MSS option. */
    tcp_enqueue(npcb, NULL, 0, TCP_SYN | TCP_ACK, 0, (u8_t *)&optdata, 4);
  1132a4:	8d 45 ec             	lea    0xffffffec(%ebp),%eax
  1132a7:	c7 44 24 18 04 00 00 	movl   $0x4,0x18(%esp)
  1132ae:	00 
  1132af:	89 44 24 14          	mov    %eax,0x14(%esp)
  1132b3:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  1132ba:	00 
  1132bb:	c7 44 24 0c 12 00 00 	movl   $0x12,0xc(%esp)
  1132c2:	00 
  1132c3:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  1132ca:	00 
  1132cb:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  1132d2:	00 
  1132d3:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  1132d6:	89 04 24             	mov    %eax,(%esp)
  1132d9:	e8 f2 e4 ff ff       	call   1117d0 <tcp_enqueue>
    return tcp_output(npcb);
  1132de:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  1132e1:	89 04 24             	mov    %eax,(%esp)
  1132e4:	e8 67 eb ff ff       	call   111e50 <tcp_output>
  1132e9:	0f be c0             	movsbl %al,%eax
  1132ec:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
  1132ef:	eb 07                	jmp    1132f8 <tcp_listen_input+0x258>
  }
  return ERR_OK;
  1132f1:	c7 45 d8 00 00 00 00 	movl   $0x0,0xffffffd8(%ebp)
  1132f8:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
}
  1132fb:	83 c4 3c             	add    $0x3c,%esp
  1132fe:	5b                   	pop    %ebx
  1132ff:	5e                   	pop    %esi
  113300:	5f                   	pop    %edi
  113301:	5d                   	pop    %ebp
  113302:	c3                   	ret    
  113303:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  113309:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00113310 <tcp_timewait_input>:

/* tcp_timewait_input():
 *
 * Called by tcp_input() when a segment arrives for a connection in
 * TIME_WAIT.
 */

static err_t
tcp_timewait_input(struct tcp_pcb *pcb)
{
  113310:	55                   	push   %ebp
  113311:	89 e5                	mov    %esp,%ebp
  113313:	83 ec 08             	sub    $0x8,%esp
  if (TCP_SEQ_GT(seqno + tcplen, pcb->rcv_nxt)) {
  113316:	a1 0c 99 13 00       	mov    0x13990c,%eax
  11331b:	89 c2                	mov    %eax,%edx
  11331d:	0f b7 05 16 99 13 00 	movzwl 0x139916,%eax
  113324:	01 c2                	add    %eax,%edx
  113326:	8b 45 08             	mov    0x8(%ebp),%eax
  113329:	8b 40 24             	mov    0x24(%eax),%eax
  11332c:	89 d1                	mov    %edx,%ecx
  11332e:	66 29 c1             	sub    %ax,%cx
  113331:	89 c8                	mov    %ecx,%eax
  113333:	66 85 c0             	test   %ax,%ax
  113336:	7e 17                	jle    11334f <tcp_timewait_input+0x3f>
    pcb->rcv_nxt = seqno + tcplen;
  113338:	0f b7 05 16 99 13 00 	movzwl 0x139916,%eax
  11333f:	0f b7 d0             	movzwl %ax,%edx
  113342:	a1 0c 99 13 00       	mov    0x13990c,%eax
  113347:	01 c2                	add    %eax,%edx
  113349:	8b 45 08             	mov    0x8(%ebp),%eax
  11334c:	89 50 24             	mov    %edx,0x24(%eax)
  }
  if (tcplen > 0) {
  11334f:	0f b7 05 16 99 13 00 	movzwl 0x139916,%eax
  113356:	66 85 c0             	test   %ax,%ax
  113359:	74 1d                	je     113378 <tcp_timewait_input+0x68>
    tcp_ack_now(pcb);
  11335b:	8b 45 08             	mov    0x8(%ebp),%eax
  11335e:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  113362:	89 c2                	mov    %eax,%edx
  113364:	83 ca 02             	or     $0x2,%edx
  113367:	8b 45 08             	mov    0x8(%ebp),%eax
  11336a:	88 50 20             	mov    %dl,0x20(%eax)
  11336d:	8b 45 08             	mov    0x8(%ebp),%eax
  113370:	89 04 24             	mov    %eax,(%esp)
  113373:	e8 d8 ea ff ff       	call   111e50 <tcp_output>
  }
  return tcp_output(pcb);
  113378:	8b 45 08             	mov    0x8(%ebp),%eax
  11337b:	89 04 24             	mov    %eax,(%esp)
  11337e:	e8 cd ea ff ff       	call   111e50 <tcp_output>
  113383:	0f be c0             	movsbl %al,%eax
}
  113386:	c9                   	leave  
  113387:	c3                   	ret    
  113388:	90                   	nop    
  113389:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

00113390 <tcp_process>:

/* tcp_process
 *
 * Implements the TCP state machine. Called by tcp_input. In some
 * states tcp_receive() is called to receive data. The tcp_seg
 * argument will be freed by the caller (tcp_input()) unless the
 * recv_data pointer in the pcb is set.
 */

static err_t
tcp_process(struct tcp_pcb *pcb)
{
  113390:	55                   	push   %ebp
  113391:	89 e5                	mov    %esp,%ebp
  113393:	83 ec 28             	sub    $0x28,%esp
  struct tcp_seg *rseg;
  u8_t acceptable = 0;
  113396:	c6 45 fe 00          	movb   $0x0,0xfffffffe(%ebp)
  err_t err;


  err = ERR_OK;
  11339a:	c6 45 ff 00          	movb   $0x0,0xffffffff(%ebp)

  /* Process incoming RST segments. */
  if (flags & TCP_RST) {
  11339e:	0f b6 05 14 99 13 00 	movzbl 0x139914,%eax
  1133a5:	0f b6 c0             	movzbl %al,%eax
  1133a8:	83 e0 04             	and    $0x4,%eax
  1133ab:	85 c0                	test   %eax,%eax
  1133ad:	0f 84 99 00 00 00    	je     11344c <tcp_process+0xbc>
    /* First, determine if the reset is acceptable. */
    if (pcb->state == SYN_SENT) {
  1133b3:	8b 45 08             	mov    0x8(%ebp),%eax
  1133b6:	8b 40 10             	mov    0x10(%eax),%eax
  1133b9:	83 f8 02             	cmp    $0x2,%eax
  1133bc:	75 15                	jne    1133d3 <tcp_process+0x43>
      if (ackno == pcb->snd_nxt) {
  1133be:	8b 45 08             	mov    0x8(%ebp),%eax
  1133c1:	8b 50 50             	mov    0x50(%eax),%edx
  1133c4:	a1 10 99 13 00       	mov    0x139910,%eax
  1133c9:	39 c2                	cmp    %eax,%edx
  1133cb:	75 48                	jne    113415 <tcp_process+0x85>
  acceptable = 1;
  1133cd:	c6 45 fe 01          	movb   $0x1,0xfffffffe(%ebp)
  1133d1:	eb 42                	jmp    113415 <tcp_process+0x85>
      }
    } else {
      if (TCP_SEQ_GEQ(seqno, pcb->rcv_nxt) &&
  1133d3:	a1 0c 99 13 00       	mov    0x13990c,%eax
  1133d8:	89 c2                	mov    %eax,%edx
  1133da:	8b 45 08             	mov    0x8(%ebp),%eax
  1133dd:	8b 40 24             	mov    0x24(%eax),%eax
  1133e0:	89 d1                	mov    %edx,%ecx
  1133e2:	66 29 c1             	sub    %ax,%cx
  1133e5:	89 c8                	mov    %ecx,%eax
  1133e7:	66 85 c0             	test   %ax,%ax
  1133ea:	78 29                	js     113415 <tcp_process+0x85>
  1133ec:	a1 0c 99 13 00       	mov    0x13990c,%eax
  1133f1:	89 c1                	mov    %eax,%ecx
  1133f3:	8b 45 08             	mov    0x8(%ebp),%eax
  1133f6:	8b 40 24             	mov    0x24(%eax),%eax
  1133f9:	89 c2                	mov    %eax,%edx
  1133fb:	8b 45 08             	mov    0x8(%ebp),%eax
  1133fe:	0f b7 40 28          	movzwl 0x28(%eax),%eax
  113402:	8d 04 02             	lea    (%edx,%eax,1),%eax
  113405:	89 ca                	mov    %ecx,%edx
  113407:	66 29 c2             	sub    %ax,%dx
  11340a:	89 d0                	mov    %edx,%eax
  11340c:	66 85 c0             	test   %ax,%ax
  11340f:	7f 04                	jg     113415 <tcp_process+0x85>
   TCP_SEQ_LEQ(seqno, pcb->rcv_nxt + pcb->rcv_wnd)) {
  acceptable = 1;
  113411:	c6 45 fe 01          	movb   $0x1,0xfffffffe(%ebp)
      }
    }

    if (acceptable) {
  113415:	80 7d fe 00          	cmpb   $0x0,0xfffffffe(%ebp)
  113419:	74 25                	je     113440 <tcp_process+0xb0>
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: Connection RESET\n"));
      LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
      recv_flags = TF_RESET;
  11341b:	c6 05 18 99 13 00 08 	movb   $0x8,0x139918
      pcb->flags &= ~TF_ACK_DELAY;
  113422:	8b 45 08             	mov    0x8(%ebp),%eax
  113425:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  113429:	89 c2                	mov    %eax,%edx
  11342b:	83 e2 fe             	and    $0xfffffffe,%edx
  11342e:	8b 45 08             	mov    0x8(%ebp),%eax
  113431:	88 50 20             	mov    %dl,0x20(%eax)
      return ERR_RST;
  113434:	c7 45 e8 fc ff ff ff 	movl   $0xfffffffc,0xffffffe8(%ebp)
  11343b:	e9 4a 06 00 00       	jmp    113a8a <tcp_process+0x6fa>
    } else {
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: unacceptable reset seqno %lu rcv_nxt %lu\n",
       seqno, pcb->rcv_nxt));
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_process: unacceptable reset seqno %lu rcv_nxt %lu\n",
       seqno, pcb->rcv_nxt));
      return ERR_OK;
  113440:	c7 45 e8 00 00 00 00 	movl   $0x0,0xffffffe8(%ebp)
  113447:	e9 3e 06 00 00       	jmp    113a8a <tcp_process+0x6fa>
    }
  }

  /* Update the PCB (in)activity timer. */
  pcb->tmr = tcp_ticks;
  11344c:	8b 15 58 16 14 00    	mov    0x141658,%edx
  113452:	8b 45 08             	mov    0x8(%ebp),%eax
  113455:	89 50 2c             	mov    %edx,0x2c(%eax)
  pcb->keep_cnt = 0;
  113458:	8b 45 08             	mov    0x8(%ebp),%eax
  11345b:	c6 80 98 00 00 00 00 	movb   $0x0,0x98(%eax)

  /* Do different things depending on the TCP state. */
  switch (pcb->state) {
  113462:	8b 45 08             	mov    0x8(%ebp),%eax
  113465:	8b 40 10             	mov    0x10(%eax),%eax
  113468:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  11346b:	83 7d ec 09          	cmpl   $0x9,0xffffffec(%ebp)
  11346f:	0f 87 0e 06 00 00    	ja     113a83 <tcp_process+0x6f3>
  113475:	8b 4d ec             	mov    0xffffffec(%ebp),%ecx
  113478:	8b 04 8d 28 af 11 00 	mov    0x11af28(,%ecx,4),%eax
  11347f:	ff e0                	jmp    *%eax
  case SYN_SENT:
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("SYN-SENT: ackno %lu pcb->snd_nxt %lu unacked %lu\n", ackno,
     pcb->snd_nxt, ntohl(pcb->unacked->tcphdr->seqno)));
    if ((flags & TCP_ACK) && (flags & TCP_SYN)
  113481:	0f b6 05 14 99 13 00 	movzbl 0x139914,%eax
  113488:	0f b6 c0             	movzbl %al,%eax
  11348b:	83 e0 10             	and    $0x10,%eax
  11348e:	85 c0                	test   %eax,%eax
  113490:	0f 84 ed 05 00 00    	je     113a83 <tcp_process+0x6f3>
  113496:	0f b6 05 14 99 13 00 	movzbl 0x139914,%eax
  11349d:	0f b6 c0             	movzbl %al,%eax
  1134a0:	83 e0 02             	and    $0x2,%eax
  1134a3:	85 c0                	test   %eax,%eax
  1134a5:	0f 84 d8 05 00 00    	je     113a83 <tcp_process+0x6f3>
  1134ab:	8b 45 08             	mov    0x8(%ebp),%eax
  1134ae:	8b 40 74             	mov    0x74(%eax),%eax
  1134b1:	8b 40 10             	mov    0x10(%eax),%eax
  1134b4:	8b 40 04             	mov    0x4(%eax),%eax
  1134b7:	89 04 24             	mov    %eax,(%esp)
  1134ba:	e8 51 ae ff ff       	call   10e310 <ntohl>
  1134bf:	8d 50 01             	lea    0x1(%eax),%edx
  1134c2:	a1 10 99 13 00       	mov    0x139910,%eax
  1134c7:	39 c2                	cmp    %eax,%edx
  1134c9:	0f 85 b4 05 00 00    	jne    113a83 <tcp_process+0x6f3>
        && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
      pcb->rcv_nxt = seqno + 1;
  1134cf:	a1 0c 99 13 00       	mov    0x13990c,%eax
  1134d4:	8d 50 01             	lea    0x1(%eax),%edx
  1134d7:	8b 45 08             	mov    0x8(%ebp),%eax
  1134da:	89 50 24             	mov    %edx,0x24(%eax)
      pcb->lastack = ackno;
  1134dd:	8b 15 10 99 13 00    	mov    0x139910,%edx
  1134e3:	8b 45 08             	mov    0x8(%ebp),%eax
  1134e6:	89 50 44             	mov    %edx,0x44(%eax)
      pcb->snd_wnd = tcphdr->wnd;
  1134e9:	a1 04 99 13 00       	mov    0x139904,%eax
  1134ee:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
  1134f2:	0f b7 d0             	movzwl %ax,%edx
  1134f5:	8b 45 08             	mov    0x8(%ebp),%eax
  1134f8:	89 50 58             	mov    %edx,0x58(%eax)
      pcb->snd_wl1 = seqno - 1; /* initialise to seqno - 1 to force window update */
  1134fb:	a1 0c 99 13 00       	mov    0x13990c,%eax
  113500:	8d 50 ff             	lea    0xffffffff(%eax),%edx
  113503:	8b 45 08             	mov    0x8(%ebp),%eax
  113506:	89 50 5c             	mov    %edx,0x5c(%eax)
      pcb->state = ESTABLISHED;
  113509:	8b 45 08             	mov    0x8(%ebp),%eax
  11350c:	c7 40 10 04 00 00 00 	movl   $0x4,0x10(%eax)
      pcb->cwnd = pcb->mss;
  113513:	8b 45 08             	mov    0x8(%ebp),%eax
  113516:	0f b7 50 34          	movzwl 0x34(%eax),%edx
  11351a:	8b 45 08             	mov    0x8(%ebp),%eax
  11351d:	66 89 50 4a          	mov    %dx,0x4a(%eax)
      --pcb->snd_queuelen;
  113521:	8b 45 08             	mov    0x8(%ebp),%eax
  113524:	0f b6 40 6c          	movzbl 0x6c(%eax),%eax
  113528:	8d 50 ff             	lea    0xffffffff(%eax),%edx
  11352b:	8b 45 08             	mov    0x8(%ebp),%eax
  11352e:	88 50 6c             	mov    %dl,0x6c(%eax)
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_process: SYN-SENT --queuelen %u\n", (unsigned int)pcb->snd_queuelen));
      rseg = pcb->unacked;
  113531:	8b 45 08             	mov    0x8(%ebp),%eax
  113534:	8b 40 74             	mov    0x74(%eax),%eax
  113537:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
      pcb->unacked = rseg->next;
  11353a:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  11353d:	8b 10                	mov    (%eax),%edx
  11353f:	8b 45 08             	mov    0x8(%ebp),%eax
  113542:	89 50 74             	mov    %edx,0x74(%eax)
      tcp_seg_free(rseg);
  113545:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  113548:	89 04 24             	mov    %eax,(%esp)
  11354b:	e8 d0 db ff ff       	call   111120 <tcp_seg_free>

      /* Parse any options in the SYNACK. */
      tcp_parseopt(pcb);
  113550:	8b 45 08             	mov    0x8(%ebp),%eax
  113553:	89 04 24             	mov    %eax,(%esp)
  113556:	e8 55 15 00 00       	call   114ab0 <tcp_parseopt>

      /* Call the user specified function to call when sucessfully
       * connected. */
      TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
  11355b:	8b 45 08             	mov    0x8(%ebp),%eax
  11355e:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
  113564:	85 c0                	test   %eax,%eax
  113566:	74 26                	je     11358e <tcp_process+0x1fe>
  113568:	8b 45 08             	mov    0x8(%ebp),%eax
  11356b:	8b 88 84 00 00 00    	mov    0x84(%eax),%ecx
  113571:	8b 45 08             	mov    0x8(%ebp),%eax
  113574:	8b 50 18             	mov    0x18(%eax),%edx
  113577:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  11357e:	00 
  11357f:	8b 45 08             	mov    0x8(%ebp),%eax
  113582:	89 44 24 04          	mov    %eax,0x4(%esp)
  113586:	89 14 24             	mov    %edx,(%esp)
  113589:	ff d1                	call   *%ecx
  11358b:	88 45 ff             	mov    %al,0xffffffff(%ebp)
      tcp_ack(pcb);
  11358e:	8b 45 08             	mov    0x8(%ebp),%eax
  113591:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  113595:	0f b6 c0             	movzbl %al,%eax
  113598:	83 e0 01             	and    $0x1,%eax
  11359b:	84 c0                	test   %al,%al
  11359d:	74 34                	je     1135d3 <tcp_process+0x243>
  11359f:	8b 45 08             	mov    0x8(%ebp),%eax
  1135a2:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  1135a6:	89 c2                	mov    %eax,%edx
  1135a8:	83 e2 fe             	and    $0xfffffffe,%edx
  1135ab:	8b 45 08             	mov    0x8(%ebp),%eax
  1135ae:	88 50 20             	mov    %dl,0x20(%eax)
  1135b1:	8b 45 08             	mov    0x8(%ebp),%eax
  1135b4:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  1135b8:	89 c2                	mov    %eax,%edx
  1135ba:	83 ca 02             	or     $0x2,%edx
  1135bd:	8b 45 08             	mov    0x8(%ebp),%eax
  1135c0:	88 50 20             	mov    %dl,0x20(%eax)
  1135c3:	8b 45 08             	mov    0x8(%ebp),%eax
  1135c6:	89 04 24             	mov    %eax,(%esp)
  1135c9:	e8 82 e8 ff ff       	call   111e50 <tcp_output>
  1135ce:	e9 b0 04 00 00       	jmp    113a83 <tcp_process+0x6f3>
  1135d3:	8b 45 08             	mov    0x8(%ebp),%eax
  1135d6:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  1135da:	89 c2                	mov    %eax,%edx
  1135dc:	83 ca 01             	or     $0x1,%edx
  1135df:	8b 45 08             	mov    0x8(%ebp),%eax
  1135e2:	88 50 20             	mov    %dl,0x20(%eax)
    }
    break;
  1135e5:	e9 99 04 00 00       	jmp    113a83 <tcp_process+0x6f3>
  case SYN_RCVD:
    if (flags & TCP_ACK &&
  1135ea:	0f b6 05 14 99 13 00 	movzbl 0x139914,%eax
  1135f1:	0f b6 c0             	movzbl %al,%eax
  1135f4:	83 e0 10             	and    $0x10,%eax
  1135f7:	85 c0                	test   %eax,%eax
  1135f9:	0f 84 84 04 00 00    	je     113a83 <tcp_process+0x6f3>
  1135ff:	0f b6 05 14 99 13 00 	movzbl 0x139914,%eax
  113606:	0f b6 c0             	movzbl %al,%eax
  113609:	83 e0 04             	and    $0x4,%eax
  11360c:	85 c0                	test   %eax,%eax
  11360e:	0f 85 6f 04 00 00    	jne    113a83 <tcp_process+0x6f3>
       !(flags & TCP_RST)) {
      if (TCP_SEQ_LT(pcb->lastack, ackno) &&
  113614:	8b 45 08             	mov    0x8(%ebp),%eax
  113617:	8b 40 44             	mov    0x44(%eax),%eax
  11361a:	89 c2                	mov    %eax,%edx
  11361c:	a1 10 99 13 00       	mov    0x139910,%eax
  113621:	89 d1                	mov    %edx,%ecx
  113623:	66 29 c1             	sub    %ax,%cx
  113626:	89 c8                	mov    %ecx,%eax
  113628:	66 85 c0             	test   %ax,%ax
  11362b:	0f 89 52 04 00 00    	jns    113a83 <tcp_process+0x6f3>
  113631:	a1 10 99 13 00       	mov    0x139910,%eax
  113636:	89 c2                	mov    %eax,%edx
  113638:	8b 45 08             	mov    0x8(%ebp),%eax
  11363b:	8b 40 50             	mov    0x50(%eax),%eax
  11363e:	89 d1                	mov    %edx,%ecx
  113640:	66 29 c1             	sub    %ax,%cx
  113643:	89 c8                	mov    %ecx,%eax
  113645:	66 85 c0             	test   %ax,%ax
  113648:	0f 8f 35 04 00 00    	jg     113a83 <tcp_process+0x6f3>
          TCP_SEQ_LEQ(ackno, pcb->snd_nxt)) {
        pcb->state = ESTABLISHED;
  11364e:	8b 45 08             	mov    0x8(%ebp),%eax
  113651:	c7 40 10 04 00 00 00 	movl   $0x4,0x10(%eax)
        LWIP_DEBUGF(TCP_DEBUG, ("TCP connection established %u -> %u.\n", inseg.tcphdr->src, inseg.tcphdr->dest));
#if LWIP_CALLBACK_API
        LWIP_ASSERT("pcb->accept != NULL", pcb->accept != NULL);
#endif
        /* Call the accept function. */
        TCP_EVENT_ACCEPT(pcb, ERR_OK, err);
  113658:	8b 45 08             	mov    0x8(%ebp),%eax
  11365b:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
  113661:	85 c0                	test   %eax,%eax
  113663:	74 26                	je     11368b <tcp_process+0x2fb>
  113665:	8b 45 08             	mov    0x8(%ebp),%eax
  113668:	8b 88 88 00 00 00    	mov    0x88(%eax),%ecx
  11366e:	8b 45 08             	mov    0x8(%ebp),%eax
  113671:	8b 50 18             	mov    0x18(%eax),%edx
  113674:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  11367b:	00 
  11367c:	8b 45 08             	mov    0x8(%ebp),%eax
  11367f:	89 44 24 04          	mov    %eax,0x4(%esp)
  113683:	89 14 24             	mov    %edx,(%esp)
  113686:	ff d1                	call   *%ecx
  113688:	88 45 ff             	mov    %al,0xffffffff(%ebp)
        if (err != ERR_OK) {
  11368b:	80 7d ff 00          	cmpb   $0x0,0xffffffff(%ebp)
  11368f:	74 17                	je     1136a8 <tcp_process+0x318>
          /* If the accept function returns with an error, we abort
           * the connection. */
          tcp_abort(pcb);
  113691:	8b 45 08             	mov    0x8(%ebp),%eax
  113694:	89 04 24             	mov    %eax,(%esp)
  113697:	e8 b4 cc ff ff       	call   110350 <tcp_abort>
          return ERR_ABRT;
  11369c:	c7 45 e8 fd ff ff ff 	movl   $0xfffffffd,0xffffffe8(%ebp)
  1136a3:	e9 e2 03 00 00       	jmp    113a8a <tcp_process+0x6fa>
        }
        /* If there was any data contained within this ACK,
         * we'd better pass it on to the application as well. */
        tcp_receive(pcb);
  1136a8:	8b 45 08             	mov    0x8(%ebp),%eax
  1136ab:	89 04 24             	mov    %eax,(%esp)
  1136ae:	e8 dd 03 00 00       	call   113a90 <tcp_receive>
        pcb->cwnd = pcb->mss;
  1136b3:	8b 45 08             	mov    0x8(%ebp),%eax
  1136b6:	0f b7 50 34          	movzwl 0x34(%eax),%edx
  1136ba:	8b 45 08             	mov    0x8(%ebp),%eax
  1136bd:	66 89 50 4a          	mov    %dx,0x4a(%eax)
      }
    }
    break;
  1136c1:	e9 bd 03 00 00       	jmp    113a83 <tcp_process+0x6f3>
  case CLOSE_WAIT:
    /* FALLTHROUGH */
  case ESTABLISHED:
    tcp_receive(pcb);
  1136c6:	8b 45 08             	mov    0x8(%ebp),%eax
  1136c9:	89 04 24             	mov    %eax,(%esp)
  1136cc:	e8 bf 03 00 00       	call   113a90 <tcp_receive>
    if (flags & TCP_FIN) {
  1136d1:	0f b6 05 14 99 13 00 	movzbl 0x139914,%eax
  1136d8:	0f b6 c0             	movzbl %al,%eax
  1136db:	83 e0 01             	and    $0x1,%eax
  1136de:	84 c0                	test   %al,%al
  1136e0:	0f 84 9d 03 00 00    	je     113a83 <tcp_process+0x6f3>
      tcp_ack_now(pcb);
  1136e6:	8b 45 08             	mov    0x8(%ebp),%eax
  1136e9:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  1136ed:	89 c2                	mov    %eax,%edx
  1136ef:	83 ca 02             	or     $0x2,%edx
  1136f2:	8b 45 08             	mov    0x8(%ebp),%eax
  1136f5:	88 50 20             	mov    %dl,0x20(%eax)
  1136f8:	8b 45 08             	mov    0x8(%ebp),%eax
  1136fb:	89 04 24             	mov    %eax,(%esp)
  1136fe:	e8 4d e7 ff ff       	call   111e50 <tcp_output>
      pcb->state = CLOSE_WAIT;
  113703:	8b 45 08             	mov    0x8(%ebp),%eax
  113706:	c7 40 10 07 00 00 00 	movl   $0x7,0x10(%eax)
    }
    break;
  11370d:	e9 71 03 00 00       	jmp    113a83 <tcp_process+0x6f3>
  case FIN_WAIT_1:
    tcp_receive(pcb);
  113712:	8b 45 08             	mov    0x8(%ebp),%eax
  113715:	89 04 24             	mov    %eax,(%esp)
  113718:	e8 73 03 00 00       	call   113a90 <tcp_receive>
    if (flags & TCP_FIN) {
  11371d:	0f b6 05 14 99 13 00 	movzbl 0x139914,%eax
  113724:	0f b6 c0             	movzbl %al,%eax
  113727:	83 e0 01             	and    $0x1,%eax
  11372a:	84 c0                	test   %al,%al
  11372c:	0f 84 12 01 00 00    	je     113844 <tcp_process+0x4b4>
      if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  113732:	0f b6 05 14 99 13 00 	movzbl 0x139914,%eax
  113739:	0f b6 c0             	movzbl %al,%eax
  11373c:	83 e0 10             	and    $0x10,%eax
  11373f:	85 c0                	test   %eax,%eax
  113741:	0f 84 d1 00 00 00    	je     113818 <tcp_process+0x488>
  113747:	8b 45 08             	mov    0x8(%ebp),%eax
  11374a:	8b 50 50             	mov    0x50(%eax),%edx
  11374d:	a1 10 99 13 00       	mov    0x139910,%eax
  113752:	39 c2                	cmp    %eax,%edx
  113754:	0f 85 be 00 00 00    	jne    113818 <tcp_process+0x488>
        LWIP_DEBUGF(TCP_DEBUG,
         ("TCP connection closed %d -> %d.\n", inseg.tcphdr->src, inseg.tcphdr->dest));
  tcp_ack_now(pcb);
  11375a:	8b 45 08             	mov    0x8(%ebp),%eax
  11375d:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  113761:	89 c2                	mov    %eax,%edx
  113763:	83 ca 02             	or     $0x2,%edx
  113766:	8b 45 08             	mov    0x8(%ebp),%eax
  113769:	88 50 20             	mov    %dl,0x20(%eax)
  11376c:	8b 45 08             	mov    0x8(%ebp),%eax
  11376f:	89 04 24             	mov    %eax,(%esp)
  113772:	e8 d9 e6 ff ff       	call   111e50 <tcp_output>
  tcp_pcb_purge(pcb);
  113777:	8b 45 08             	mov    0x8(%ebp),%eax
  11377a:	89 04 24             	mov    %eax,(%esp)
  11377d:	e8 ee dd ff ff       	call   111570 <tcp_pcb_purge>
  TCP_RMV(&tcp_active_pcbs, pcb);
  113782:	a1 54 16 14 00       	mov    0x141654,%eax
  113787:	3b 45 08             	cmp    0x8(%ebp),%eax
  11378a:	75 0f                	jne    11379b <tcp_process+0x40b>
  11378c:	a1 54 16 14 00       	mov    0x141654,%eax
  113791:	8b 40 0c             	mov    0xc(%eax),%eax
  113794:	a3 54 16 14 00       	mov    %eax,0x141654
  113799:	eb 4b                	jmp    1137e6 <tcp_process+0x456>
  11379b:	a1 54 16 14 00       	mov    0x141654,%eax
  1137a0:	a3 60 16 14 00       	mov    %eax,0x141660
  1137a5:	eb 36                	jmp    1137dd <tcp_process+0x44d>
  1137a7:	a1 60 16 14 00       	mov    0x141660,%eax
  1137ac:	8b 40 0c             	mov    0xc(%eax),%eax
  1137af:	85 c0                	test   %eax,%eax
  1137b1:	74 1d                	je     1137d0 <tcp_process+0x440>
  1137b3:	a1 60 16 14 00       	mov    0x141660,%eax
  1137b8:	8b 40 0c             	mov    0xc(%eax),%eax
  1137bb:	3b 45 08             	cmp    0x8(%ebp),%eax
  1137be:	75 10                	jne    1137d0 <tcp_process+0x440>
  1137c0:	a1 60 16 14 00       	mov    0x141660,%eax
  1137c5:	8b 55 08             	mov    0x8(%ebp),%edx
  1137c8:	8b 52 0c             	mov    0xc(%edx),%edx
  1137cb:	89 50 0c             	mov    %edx,0xc(%eax)
  1137ce:	eb 16                	jmp    1137e6 <tcp_process+0x456>
  1137d0:	a1 60 16 14 00       	mov    0x141660,%eax
  1137d5:	8b 40 0c             	mov    0xc(%eax),%eax
  1137d8:	a3 60 16 14 00       	mov    %eax,0x141660
  1137dd:	a1 60 16 14 00       	mov    0x141660,%eax
  1137e2:	85 c0                	test   %eax,%eax
  1137e4:	75 c1                	jne    1137a7 <tcp_process+0x417>
  1137e6:	8b 45 08             	mov    0x8(%ebp),%eax
  1137e9:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
  pcb->state = TIME_WAIT;
  1137f0:	8b 45 08             	mov    0x8(%ebp),%eax
  1137f3:	c7 40 10 0a 00 00 00 	movl   $0xa,0x10(%eax)
  TCP_REG(&tcp_tw_pcbs, pcb);
  1137fa:	8b 15 64 16 14 00    	mov    0x141664,%edx
  113800:	8b 45 08             	mov    0x8(%ebp),%eax
  113803:	89 50 0c             	mov    %edx,0xc(%eax)
  113806:	8b 45 08             	mov    0x8(%ebp),%eax
  113809:	a3 64 16 14 00       	mov    %eax,0x141664
  11380e:	e8 bd 62 00 00       	call   119ad0 <tcp_timer_needed>
  113813:	e9 6b 02 00 00       	jmp    113a83 <tcp_process+0x6f3>
      } else {
  tcp_ack_now(pcb);
  113818:	8b 45 08             	mov    0x8(%ebp),%eax
  11381b:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  11381f:	89 c2                	mov    %eax,%edx
  113821:	83 ca 02             	or     $0x2,%edx
  113824:	8b 45 08             	mov    0x8(%ebp),%eax
  113827:	88 50 20             	mov    %dl,0x20(%eax)
  11382a:	8b 45 08             	mov    0x8(%ebp),%eax
  11382d:	89 04 24             	mov    %eax,(%esp)
  113830:	e8 1b e6 ff ff       	call   111e50 <tcp_output>
  pcb->state = CLOSING;
  113835:	8b 45 08             	mov    0x8(%ebp),%eax
  113838:	c7 40 10 08 00 00 00 	movl   $0x8,0x10(%eax)
  11383f:	e9 3f 02 00 00       	jmp    113a83 <tcp_process+0x6f3>
      }
    } else if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  113844:	0f b6 05 14 99 13 00 	movzbl 0x139914,%eax
  11384b:	0f b6 c0             	movzbl %al,%eax
  11384e:	83 e0 10             	and    $0x10,%eax
  113851:	85 c0                	test   %eax,%eax
  113853:	0f 84 2a 02 00 00    	je     113a83 <tcp_process+0x6f3>
  113859:	8b 45 08             	mov    0x8(%ebp),%eax
  11385c:	8b 50 50             	mov    0x50(%eax),%edx
  11385f:	a1 10 99 13 00       	mov    0x139910,%eax
  113864:	39 c2                	cmp    %eax,%edx
  113866:	0f 85 17 02 00 00    	jne    113a83 <tcp_process+0x6f3>
      pcb->state = FIN_WAIT_2;
  11386c:	8b 45 08             	mov    0x8(%ebp),%eax
  11386f:	c7 40 10 06 00 00 00 	movl   $0x6,0x10(%eax)
    }
    break;
  113876:	e9 08 02 00 00       	jmp    113a83 <tcp_process+0x6f3>
  case FIN_WAIT_2:
    tcp_receive(pcb);
  11387b:	8b 45 08             	mov    0x8(%ebp),%eax
  11387e:	89 04 24             	mov    %eax,(%esp)
  113881:	e8 0a 02 00 00       	call   113a90 <tcp_receive>
    if (flags & TCP_FIN) {
  113886:	0f b6 05 14 99 13 00 	movzbl 0x139914,%eax
  11388d:	0f b6 c0             	movzbl %al,%eax
  113890:	83 e0 01             	and    $0x1,%eax
  113893:	84 c0                	test   %al,%al
  113895:	0f 84 e8 01 00 00    	je     113a83 <tcp_process+0x6f3>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %u -> %u.\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_ack_now(pcb);
  11389b:	8b 45 08             	mov    0x8(%ebp),%eax
  11389e:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  1138a2:	89 c2                	mov    %eax,%edx
  1138a4:	83 ca 02             	or     $0x2,%edx
  1138a7:	8b 45 08             	mov    0x8(%ebp),%eax
  1138aa:	88 50 20             	mov    %dl,0x20(%eax)
  1138ad:	8b 45 08             	mov    0x8(%ebp),%eax
  1138b0:	89 04 24             	mov    %eax,(%esp)
  1138b3:	e8 98 e5 ff ff       	call   111e50 <tcp_output>
      tcp_pcb_purge(pcb);
  1138b8:	8b 45 08             	mov    0x8(%ebp),%eax
  1138bb:	89 04 24             	mov    %eax,(%esp)
  1138be:	e8 ad dc ff ff       	call   111570 <tcp_pcb_purge>
      TCP_RMV(&tcp_active_pcbs, pcb);
  1138c3:	a1 54 16 14 00       	mov    0x141654,%eax
  1138c8:	3b 45 08             	cmp    0x8(%ebp),%eax
  1138cb:	75 0f                	jne    1138dc <tcp_process+0x54c>
  1138cd:	a1 54 16 14 00       	mov    0x141654,%eax
  1138d2:	8b 40 0c             	mov    0xc(%eax),%eax
  1138d5:	a3 54 16 14 00       	mov    %eax,0x141654
  1138da:	eb 4b                	jmp    113927 <tcp_process+0x597>
  1138dc:	a1 54 16 14 00       	mov    0x141654,%eax
  1138e1:	a3 60 16 14 00       	mov    %eax,0x141660
  1138e6:	eb 36                	jmp    11391e <tcp_process+0x58e>
  1138e8:	a1 60 16 14 00       	mov    0x141660,%eax
  1138ed:	8b 40 0c             	mov    0xc(%eax),%eax
  1138f0:	85 c0                	test   %eax,%eax
  1138f2:	74 1d                	je     113911 <tcp_process+0x581>
  1138f4:	a1 60 16 14 00       	mov    0x141660,%eax
  1138f9:	8b 40 0c             	mov    0xc(%eax),%eax
  1138fc:	3b 45 08             	cmp    0x8(%ebp),%eax
  1138ff:	75 10                	jne    113911 <tcp_process+0x581>
  113901:	a1 60 16 14 00       	mov    0x141660,%eax
  113906:	8b 55 08             	mov    0x8(%ebp),%edx
  113909:	8b 52 0c             	mov    0xc(%edx),%edx
  11390c:	89 50 0c             	mov    %edx,0xc(%eax)
  11390f:	eb 16                	jmp    113927 <tcp_process+0x597>
  113911:	a1 60 16 14 00       	mov    0x141660,%eax
  113916:	8b 40 0c             	mov    0xc(%eax),%eax
  113919:	a3 60 16 14 00       	mov    %eax,0x141660
  11391e:	a1 60 16 14 00       	mov    0x141660,%eax
  113923:	85 c0                	test   %eax,%eax
  113925:	75 c1                	jne    1138e8 <tcp_process+0x558>
  113927:	8b 45 08             	mov    0x8(%ebp),%eax
  11392a:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
      pcb->state = TIME_WAIT;
  113931:	8b 45 08             	mov    0x8(%ebp),%eax
  113934:	c7 40 10 0a 00 00 00 	movl   $0xa,0x10(%eax)
      TCP_REG(&tcp_tw_pcbs, pcb);
  11393b:	8b 15 64 16 14 00    	mov    0x141664,%edx
  113941:	8b 45 08             	mov    0x8(%ebp),%eax
  113944:	89 50 0c             	mov    %edx,0xc(%eax)
  113947:	8b 45 08             	mov    0x8(%ebp),%eax
  11394a:	a3 64 16 14 00       	mov    %eax,0x141664
  11394f:	e8 7c 61 00 00       	call   119ad0 <tcp_timer_needed>
    }
    break;
  113954:	e9 2a 01 00 00       	jmp    113a83 <tcp_process+0x6f3>
  case CLOSING:
    tcp_receive(pcb);
  113959:	8b 45 08             	mov    0x8(%ebp),%eax
  11395c:	89 04 24             	mov    %eax,(%esp)
  11395f:	e8 2c 01 00 00       	call   113a90 <tcp_receive>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  113964:	0f b6 05 14 99 13 00 	movzbl 0x139914,%eax
  11396b:	0f b6 c0             	movzbl %al,%eax
  11396e:	83 e0 10             	and    $0x10,%eax
  113971:	85 c0                	test   %eax,%eax
  113973:	0f 84 0a 01 00 00    	je     113a83 <tcp_process+0x6f3>
  113979:	8b 45 08             	mov    0x8(%ebp),%eax
  11397c:	8b 50 50             	mov    0x50(%eax),%edx
  11397f:	a1 10 99 13 00       	mov    0x139910,%eax
  113984:	39 c2                	cmp    %eax,%edx
  113986:	0f 85 f7 00 00 00    	jne    113a83 <tcp_process+0x6f3>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %u -> %u.\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_ack_now(pcb);
  11398c:	8b 45 08             	mov    0x8(%ebp),%eax
  11398f:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  113993:	89 c2                	mov    %eax,%edx
  113995:	83 ca 02             	or     $0x2,%edx
  113998:	8b 45 08             	mov    0x8(%ebp),%eax
  11399b:	88 50 20             	mov    %dl,0x20(%eax)
  11399e:	8b 45 08             	mov    0x8(%ebp),%eax
  1139a1:	89 04 24             	mov    %eax,(%esp)
  1139a4:	e8 a7 e4 ff ff       	call   111e50 <tcp_output>
      tcp_pcb_purge(pcb);
  1139a9:	8b 45 08             	mov    0x8(%ebp),%eax
  1139ac:	89 04 24             	mov    %eax,(%esp)
  1139af:	e8 bc db ff ff       	call   111570 <tcp_pcb_purge>
      TCP_RMV(&tcp_active_pcbs, pcb);
  1139b4:	a1 54 16 14 00       	mov    0x141654,%eax
  1139b9:	3b 45 08             	cmp    0x8(%ebp),%eax
  1139bc:	75 0f                	jne    1139cd <tcp_process+0x63d>
  1139be:	a1 54 16 14 00       	mov    0x141654,%eax
  1139c3:	8b 40 0c             	mov    0xc(%eax),%eax
  1139c6:	a3 54 16 14 00       	mov    %eax,0x141654
  1139cb:	eb 4b                	jmp    113a18 <tcp_process+0x688>
  1139cd:	a1 54 16 14 00       	mov    0x141654,%eax
  1139d2:	a3 60 16 14 00       	mov    %eax,0x141660
  1139d7:	eb 36                	jmp    113a0f <tcp_process+0x67f>
  1139d9:	a1 60 16 14 00       	mov    0x141660,%eax
  1139de:	8b 40 0c             	mov    0xc(%eax),%eax
  1139e1:	85 c0                	test   %eax,%eax
  1139e3:	74 1d                	je     113a02 <tcp_process+0x672>
  1139e5:	a1 60 16 14 00       	mov    0x141660,%eax
  1139ea:	8b 40 0c             	mov    0xc(%eax),%eax
  1139ed:	3b 45 08             	cmp    0x8(%ebp),%eax
  1139f0:	75 10                	jne    113a02 <tcp_process+0x672>
  1139f2:	a1 60 16 14 00       	mov    0x141660,%eax
  1139f7:	8b 55 08             	mov    0x8(%ebp),%edx
  1139fa:	8b 52 0c             	mov    0xc(%edx),%edx
  1139fd:	89 50 0c             	mov    %edx,0xc(%eax)
  113a00:	eb 16                	jmp    113a18 <tcp_process+0x688>
  113a02:	a1 60 16 14 00       	mov    0x141660,%eax
  113a07:	8b 40 0c             	mov    0xc(%eax),%eax
  113a0a:	a3 60 16 14 00       	mov    %eax,0x141660
  113a0f:	a1 60 16 14 00       	mov    0x141660,%eax
  113a14:	85 c0                	test   %eax,%eax
  113a16:	75 c1                	jne    1139d9 <tcp_process+0x649>
  113a18:	8b 45 08             	mov    0x8(%ebp),%eax
  113a1b:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
      pcb->state = TIME_WAIT;
  113a22:	8b 45 08             	mov    0x8(%ebp),%eax
  113a25:	c7 40 10 0a 00 00 00 	movl   $0xa,0x10(%eax)
      TCP_REG(&tcp_tw_pcbs, pcb);
  113a2c:	8b 15 64 16 14 00    	mov    0x141664,%edx
  113a32:	8b 45 08             	mov    0x8(%ebp),%eax
  113a35:	89 50 0c             	mov    %edx,0xc(%eax)
  113a38:	8b 45 08             	mov    0x8(%ebp),%eax
  113a3b:	a3 64 16 14 00       	mov    %eax,0x141664
  113a40:	e8 8b 60 00 00       	call   119ad0 <tcp_timer_needed>
    }
    break;
  113a45:	eb 3c                	jmp    113a83 <tcp_process+0x6f3>
  case LAST_ACK:
    tcp_receive(pcb);
  113a47:	8b 45 08             	mov    0x8(%ebp),%eax
  113a4a:	89 04 24             	mov    %eax,(%esp)
  113a4d:	e8 3e 00 00 00       	call   113a90 <tcp_receive>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  113a52:	0f b6 05 14 99 13 00 	movzbl 0x139914,%eax
  113a59:	0f b6 c0             	movzbl %al,%eax
  113a5c:	83 e0 10             	and    $0x10,%eax
  113a5f:	85 c0                	test   %eax,%eax
  113a61:	74 20                	je     113a83 <tcp_process+0x6f3>
  113a63:	8b 45 08             	mov    0x8(%ebp),%eax
  113a66:	8b 50 50             	mov    0x50(%eax),%edx
  113a69:	a1 10 99 13 00       	mov    0x139910,%eax
  113a6e:	39 c2                	cmp    %eax,%edx
  113a70:	75 11                	jne    113a83 <tcp_process+0x6f3>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %u -> %u.\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      pcb->state = CLOSED;
  113a72:	8b 45 08             	mov    0x8(%ebp),%eax
  113a75:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
      recv_flags = TF_CLOSED;
  113a7c:	c6 05 18 99 13 00 10 	movb   $0x10,0x139918
    }
    break;
  default:
    break;
  }

  return ERR_OK;
  113a83:	c7 45 e8 00 00 00 00 	movl   $0x0,0xffffffe8(%ebp)
  113a8a:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
}
  113a8d:	c9                   	leave  
  113a8e:	c3                   	ret    
  113a8f:	90                   	nop    

00113a90 <tcp_receive>:

/* tcp_receive:
 *
 * Called by tcp_process. Checks if the given segment is an ACK for outstanding
 * data, and if so frees the memory of the buffered data. Next, is places the
 * segment on any of the receive queues (pcb->recved or pcb->ooseq). If the segment
 * is buffered, the pbuf is referenced by pbuf_ref so that it will not be freed until
 * i it has been removed from the buffer.
 *
 * If the incoming segment constitutes an ACK for a segment that was used for RTT
 * estimation, the RTT is estimated here as well.
 */

static void
tcp_receive(struct tcp_pcb *pcb)
{
  113a90:	55                   	push   %ebp
  113a91:	89 e5                	mov    %esp,%ebp
  113a93:	53                   	push   %ebx
  113a94:	83 ec 74             	sub    $0x74,%esp
  struct tcp_seg *next;
#if TCP_QUEUE_OOSEQ
  struct tcp_seg *prev, *cseg;
#endif
  struct pbuf *p;
  s32_t off;
  int m;
  u32_t right_wnd_edge;


  if (flags & TCP_ACK) {
  113a97:	0f b6 05 14 99 13 00 	movzbl 0x139914,%eax
  113a9e:	0f b6 c0             	movzbl %al,%eax
  113aa1:	83 e0 10             	and    $0x10,%eax
  113aa4:	85 c0                	test   %eax,%eax
  113aa6:	0f 84 53 06 00 00    	je     1140ff <tcp_receive+0x66f>
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl1;
  113aac:	8b 45 08             	mov    0x8(%ebp),%eax
  113aaf:	8b 50 58             	mov    0x58(%eax),%edx
  113ab2:	8b 45 08             	mov    0x8(%ebp),%eax
  113ab5:	8b 40 5c             	mov    0x5c(%eax),%eax
  113ab8:	8d 04 02             	lea    (%edx,%eax,1),%eax
  113abb:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
  113abe:	8b 45 08             	mov    0x8(%ebp),%eax
  113ac1:	8b 40 5c             	mov    0x5c(%eax),%eax
  113ac4:	89 c2                	mov    %eax,%edx
  113ac6:	a1 0c 99 13 00       	mov    0x13990c,%eax
  113acb:	89 d1                	mov    %edx,%ecx
  113acd:	66 29 c1             	sub    %ax,%cx
  113ad0:	89 c8                	mov    %ecx,%eax
  113ad2:	66 85 c0             	test   %ax,%ax
  113ad5:	78 4d                	js     113b24 <tcp_receive+0x94>
  113ad7:	8b 45 08             	mov    0x8(%ebp),%eax
  113ada:	8b 50 5c             	mov    0x5c(%eax),%edx
  113add:	a1 0c 99 13 00       	mov    0x13990c,%eax
  113ae2:	39 c2                	cmp    %eax,%edx
  113ae4:	75 19                	jne    113aff <tcp_receive+0x6f>
  113ae6:	8b 45 08             	mov    0x8(%ebp),%eax
  113ae9:	8b 40 60             	mov    0x60(%eax),%eax
  113aec:	89 c2                	mov    %eax,%edx
  113aee:	a1 10 99 13 00       	mov    0x139910,%eax
  113af3:	89 d3                	mov    %edx,%ebx
  113af5:	66 29 c3             	sub    %ax,%bx
  113af8:	89 d8                	mov    %ebx,%eax
  113afa:	66 85 c0             	test   %ax,%ax
  113afd:	78 25                	js     113b24 <tcp_receive+0x94>
  113aff:	8b 45 08             	mov    0x8(%ebp),%eax
  113b02:	8b 50 60             	mov    0x60(%eax),%edx
  113b05:	a1 10 99 13 00       	mov    0x139910,%eax
  113b0a:	39 c2                	cmp    %eax,%edx
  113b0c:	75 40                	jne    113b4e <tcp_receive+0xbe>
  113b0e:	a1 04 99 13 00       	mov    0x139904,%eax
  113b13:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
  113b17:	0f b7 d0             	movzwl %ax,%edx
  113b1a:	8b 45 08             	mov    0x8(%ebp),%eax
  113b1d:	8b 40 58             	mov    0x58(%eax),%eax
  113b20:	39 c2                	cmp    %eax,%edx
  113b22:	76 2a                	jbe    113b4e <tcp_receive+0xbe>
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
       (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
      pcb->snd_wnd = tcphdr->wnd;
  113b24:	a1 04 99 13 00       	mov    0x139904,%eax
  113b29:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
  113b2d:	0f b7 d0             	movzwl %ax,%edx
  113b30:	8b 45 08             	mov    0x8(%ebp),%eax
  113b33:	89 50 58             	mov    %edx,0x58(%eax)
      pcb->snd_wl1 = seqno;
  113b36:	8b 15 0c 99 13 00    	mov    0x13990c,%edx
  113b3c:	8b 45 08             	mov    0x8(%ebp),%eax
  113b3f:	89 50 5c             	mov    %edx,0x5c(%eax)
      pcb->snd_wl2 = ackno;
  113b42:	8b 15 10 99 13 00    	mov    0x139910,%edx
  113b48:	8b 45 08             	mov    0x8(%ebp),%eax
  113b4b:	89 50 60             	mov    %edx,0x60(%eax)
      LWIP_DEBUGF(TCP_WND_DEBUG, ("tcp_receive: window update %lu\n", pcb->snd_wnd));
#if TCP_WND_DEBUG
    } else {
      if (pcb->snd_wnd != tcphdr->wnd) {
        LWIP_DEBUGF(TCP_WND_DEBUG, ("tcp_receive: no window update lastack %lu snd_max %lu ackno %lu wl1 %lu seqno %lu wl2 %lu\n",
                               pcb->lastack, pcb->snd_max, ackno, pcb->snd_wl1, seqno, pcb->snd_wl2));
      }
#endif /* TCP_WND_DEBUG */
    }


    if (pcb->lastack == ackno) {
  113b4e:	8b 45 08             	mov    0x8(%ebp),%eax
  113b51:	8b 50 44             	mov    0x44(%eax),%edx
  113b54:	a1 10 99 13 00       	mov    0x139910,%eax
  113b59:	39 c2                	cmp    %eax,%edx
  113b5b:	0f 85 25 01 00 00    	jne    113c86 <tcp_receive+0x1f6>
      pcb->acked = 0;
  113b61:	8b 45 08             	mov    0x8(%ebp),%eax
  113b64:	66 c7 40 68 00 00    	movw   $0x0,0x68(%eax)

      if (pcb->snd_wl1 + pcb->snd_wnd == right_wnd_edge){
  113b6a:	8b 45 08             	mov    0x8(%ebp),%eax
  113b6d:	8b 50 5c             	mov    0x5c(%eax),%edx
  113b70:	8b 45 08             	mov    0x8(%ebp),%eax
  113b73:	8b 40 58             	mov    0x58(%eax),%eax
  113b76:	8d 04 02             	lea    (%edx,%eax,1),%eax
  113b79:	3b 45 f4             	cmp    0xfffffff4(%ebp),%eax
  113b7c:	0f 85 f6 03 00 00    	jne    113f78 <tcp_receive+0x4e8>
  ++pcb->dupacks;
  113b82:	8b 45 08             	mov    0x8(%ebp),%eax
  113b85:	0f b6 40 48          	movzbl 0x48(%eax),%eax
  113b89:	8d 50 01             	lea    0x1(%eax),%edx
  113b8c:	8b 45 08             	mov    0x8(%ebp),%eax
  113b8f:	88 50 48             	mov    %dl,0x48(%eax)
  if (pcb->dupacks >= 3 && pcb->unacked != NULL) {
  113b92:	8b 45 08             	mov    0x8(%ebp),%eax
  113b95:	0f b6 40 48          	movzbl 0x48(%eax),%eax
  113b99:	3c 02                	cmp    $0x2,%al
  113b9b:	0f 86 d7 03 00 00    	jbe    113f78 <tcp_receive+0x4e8>
  113ba1:	8b 45 08             	mov    0x8(%ebp),%eax
  113ba4:	8b 40 74             	mov    0x74(%eax),%eax
  113ba7:	85 c0                	test   %eax,%eax
  113ba9:	0f 84 c9 03 00 00    	je     113f78 <tcp_receive+0x4e8>
    if (!(pcb->flags & TF_INFR)) {
  113baf:	8b 45 08             	mov    0x8(%ebp),%eax
  113bb2:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  113bb6:	0f b6 c0             	movzbl %al,%eax
  113bb9:	83 e0 04             	and    $0x4,%eax
  113bbc:	85 c0                	test   %eax,%eax
  113bbe:	0f 85 86 00 00 00    	jne    113c4a <tcp_receive+0x1ba>
      /* This is fast retransmit. Retransmit the first unacked segment. */
      LWIP_DEBUGF(TCP_FR_DEBUG, ("tcp_receive: dupacks %u (%lu), fast retransmit %lu\n",
          (unsigned int)pcb->dupacks, pcb->lastack,
          ntohl(pcb->unacked->tcphdr->seqno)));
      tcp_rexmit(pcb);
  113bc4:	8b 45 08             	mov    0x8(%ebp),%eax
  113bc7:	89 04 24             	mov    %eax,(%esp)
  113bca:	e8 a1 ea ff ff       	call   112670 <tcp_rexmit>
      /* Set ssthresh to max (FlightSize / 2, 2*SMSS) */
      pcb->ssthresh = LWIP_MAX((pcb->snd_max -
  113bcf:	8b 45 08             	mov    0x8(%ebp),%eax
  113bd2:	0f b7 40 34          	movzwl 0x34(%eax),%eax
  113bd6:	0f b7 c0             	movzwl %ax,%eax
  113bd9:	01 c0                	add    %eax,%eax
  113bdb:	89 c1                	mov    %eax,%ecx
  113bdd:	8b 45 08             	mov    0x8(%ebp),%eax
  113be0:	8b 50 54             	mov    0x54(%eax),%edx
  113be3:	8b 45 08             	mov    0x8(%ebp),%eax
  113be6:	8b 40 44             	mov    0x44(%eax),%eax
  113be9:	89 d3                	mov    %edx,%ebx
  113beb:	29 c3                	sub    %eax,%ebx
  113bed:	89 d8                	mov    %ebx,%eax
  113bef:	89 c2                	mov    %eax,%edx
  113bf1:	d1 ea                	shr    %edx
  113bf3:	89 55 9c             	mov    %edx,0xffffff9c(%ebp)
  113bf6:	89 4d a0             	mov    %ecx,0xffffffa0(%ebp)
  113bf9:	8b 4d 9c             	mov    0xffffff9c(%ebp),%ecx
  113bfc:	39 4d a0             	cmp    %ecx,0xffffffa0(%ebp)
  113bff:	73 06                	jae    113c07 <tcp_receive+0x177>
  113c01:	8b 5d 9c             	mov    0xffffff9c(%ebp),%ebx
  113c04:	89 5d a0             	mov    %ebx,0xffffffa0(%ebp)
  113c07:	0f b7 55 a0          	movzwl 0xffffffa0(%ebp),%edx
  113c0b:	8b 45 08             	mov    0x8(%ebp),%eax
  113c0e:	66 89 50 4c          	mov    %dx,0x4c(%eax)
          pcb->lastack) / 2,
         2 * pcb->mss);

      pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
  113c12:	8b 45 08             	mov    0x8(%ebp),%eax
  113c15:	0f b7 48 4c          	movzwl 0x4c(%eax),%ecx
  113c19:	8b 45 08             	mov    0x8(%ebp),%eax
  113c1c:	0f b7 40 34          	movzwl 0x34(%eax),%eax
  113c20:	0f b7 d0             	movzwl %ax,%edx
  113c23:	89 d0                	mov    %edx,%eax
  113c25:	01 c0                	add    %eax,%eax
  113c27:	01 d0                	add    %edx,%eax
  113c29:	8d 14 01             	lea    (%ecx,%eax,1),%edx
  113c2c:	8b 45 08             	mov    0x8(%ebp),%eax
  113c2f:	66 89 50 4a          	mov    %dx,0x4a(%eax)
      pcb->flags |= TF_INFR;
  113c33:	8b 45 08             	mov    0x8(%ebp),%eax
  113c36:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  113c3a:	89 c2                	mov    %eax,%edx
  113c3c:	83 ca 04             	or     $0x4,%edx
  113c3f:	8b 45 08             	mov    0x8(%ebp),%eax
  113c42:	88 50 20             	mov    %dl,0x20(%eax)
  113c45:	e9 2e 03 00 00       	jmp    113f78 <tcp_receive+0x4e8>
    } else {
      /* Inflate the congestion window, but not if it means that
         the value overflows. */
      if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
  113c4a:	8b 45 08             	mov    0x8(%ebp),%eax
  113c4d:	0f b7 50 4a          	movzwl 0x4a(%eax),%edx
  113c51:	8b 45 08             	mov    0x8(%ebp),%eax
  113c54:	0f b7 40 34          	movzwl 0x34(%eax),%eax
  113c58:	01 c2                	add    %eax,%edx
  113c5a:	8b 45 08             	mov    0x8(%ebp),%eax
  113c5d:	0f b7 40 4a          	movzwl 0x4a(%eax),%eax
  113c61:	66 39 c2             	cmp    %ax,%dx
  113c64:	0f 86 0e 03 00 00    	jbe    113f78 <tcp_receive+0x4e8>
        pcb->cwnd += pcb->mss;
  113c6a:	8b 45 08             	mov    0x8(%ebp),%eax
  113c6d:	0f b7 50 4a          	movzwl 0x4a(%eax),%edx
  113c71:	8b 45 08             	mov    0x8(%ebp),%eax
  113c74:	0f b7 40 34          	movzwl 0x34(%eax),%eax
  113c78:	01 c2                	add    %eax,%edx
  113c7a:	8b 45 08             	mov    0x8(%ebp),%eax
  113c7d:	66 89 50 4a          	mov    %dx,0x4a(%eax)
  113c81:	e9 f2 02 00 00       	jmp    113f78 <tcp_receive+0x4e8>
      }
    }
  }
      } else {
  LWIP_DEBUGF(TCP_FR_DEBUG, ("tcp_receive: dupack averted %lu %lu\n",
            pcb->snd_wl1 + pcb->snd_wnd, right_wnd_edge));
      }
    } else if (TCP_SEQ_LT(pcb->lastack, ackno) &&
  113c86:	8b 45 08             	mov    0x8(%ebp),%eax
  113c89:	8b 40 44             	mov    0x44(%eax),%eax
  113c8c:	89 c2                	mov    %eax,%edx
  113c8e:	a1 10 99 13 00       	mov    0x139910,%eax
  113c93:	89 d1                	mov    %edx,%ecx
  113c95:	66 29 c1             	sub    %ax,%cx
  113c98:	89 c8                	mov    %ecx,%eax
  113c9a:	66 85 c0             	test   %ax,%ax
  113c9d:	0f 89 d5 02 00 00    	jns    113f78 <tcp_receive+0x4e8>
  113ca3:	a1 10 99 13 00       	mov    0x139910,%eax
  113ca8:	89 c2                	mov    %eax,%edx
  113caa:	8b 45 08             	mov    0x8(%ebp),%eax
  113cad:	8b 40 54             	mov    0x54(%eax),%eax
  113cb0:	89 d3                	mov    %edx,%ebx
  113cb2:	66 29 c3             	sub    %ax,%bx
  113cb5:	89 d8                	mov    %ebx,%eax
  113cb7:	66 85 c0             	test   %ax,%ax
  113cba:	0f 8f b8 02 00 00    	jg     113f78 <tcp_receive+0x4e8>
              TCP_SEQ_LEQ(ackno, pcb->snd_max)) {
      /* We come here when the ACK acknowledges new data. */

      /* Reset the "IN Fast Retransmit" flag, since we are no longer
         in fast retransmit. Also reset the congestion window to the
         slow start threshold. */
      if (pcb->flags & TF_INFR) {
  113cc0:	8b 45 08             	mov    0x8(%ebp),%eax
  113cc3:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  113cc7:	0f b6 c0             	movzbl %al,%eax
  113cca:	83 e0 04             	and    $0x4,%eax
  113ccd:	85 c0                	test   %eax,%eax
  113ccf:	74 20                	je     113cf1 <tcp_receive+0x261>
  pcb->flags &= ~TF_INFR;
  113cd1:	8b 45 08             	mov    0x8(%ebp),%eax
  113cd4:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  113cd8:	89 c2                	mov    %eax,%edx
  113cda:	83 e2 fb             	and    $0xfffffffb,%edx
  113cdd:	8b 45 08             	mov    0x8(%ebp),%eax
  113ce0:	88 50 20             	mov    %dl,0x20(%eax)
  pcb->cwnd = pcb->ssthresh;
  113ce3:	8b 45 08             	mov    0x8(%ebp),%eax
  113ce6:	0f b7 50 4c          	movzwl 0x4c(%eax),%edx
  113cea:	8b 45 08             	mov    0x8(%ebp),%eax
  113ced:	66 89 50 4a          	mov    %dx,0x4a(%eax)
      }

      /* Reset the number of retransmissions. */
      pcb->nrtx = 0;
  113cf1:	8b 45 08             	mov    0x8(%ebp),%eax
  113cf4:	c6 40 42 00          	movb   $0x0,0x42(%eax)

      /* Reset the retransmission time-out. */
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
  113cf8:	8b 45 08             	mov    0x8(%ebp),%eax
  113cfb:	0f b7 40 3c          	movzwl 0x3c(%eax),%eax
  113cff:	66 c1 f8 03          	sar    $0x3,%ax
  113d03:	89 c2                	mov    %eax,%edx
  113d05:	8b 45 08             	mov    0x8(%ebp),%eax
  113d08:	0f b7 40 3e          	movzwl 0x3e(%eax),%eax
  113d0c:	01 c2                	add    %eax,%edx
  113d0e:	8b 45 08             	mov    0x8(%ebp),%eax
  113d11:	66 89 50 40          	mov    %dx,0x40(%eax)

      /* Update the send buffer space. */
      pcb->acked = ackno - pcb->lastack;
  113d15:	a1 10 99 13 00       	mov    0x139910,%eax
  113d1a:	89 c2                	mov    %eax,%edx
  113d1c:	8b 45 08             	mov    0x8(%ebp),%eax
  113d1f:	8b 40 44             	mov    0x44(%eax),%eax
  113d22:	66 29 c2             	sub    %ax,%dx
  113d25:	8b 45 08             	mov    0x8(%ebp),%eax
  113d28:	66 89 50 68          	mov    %dx,0x68(%eax)
      pcb->snd_buf += pcb->acked;
  113d2c:	8b 45 08             	mov    0x8(%ebp),%eax
  113d2f:	0f b7 50 6a          	movzwl 0x6a(%eax),%edx
  113d33:	8b 45 08             	mov    0x8(%ebp),%eax
  113d36:	0f b7 40 68          	movzwl 0x68(%eax),%eax
  113d3a:	01 c2                	add    %eax,%edx
  113d3c:	8b 45 08             	mov    0x8(%ebp),%eax
  113d3f:	66 89 50 6a          	mov    %dx,0x6a(%eax)

      /* Reset the fast retransmit variables. */
      pcb->dupacks = 0;
  113d43:	8b 45 08             	mov    0x8(%ebp),%eax
  113d46:	c6 40 48 00          	movb   $0x0,0x48(%eax)
      pcb->lastack = ackno;
  113d4a:	8b 15 10 99 13 00    	mov    0x139910,%edx
  113d50:	8b 45 08             	mov    0x8(%ebp),%eax
  113d53:	89 50 44             	mov    %edx,0x44(%eax)

      /* Update the congestion control variables (cwnd and
         ssthresh). */
      if (pcb->state >= ESTABLISHED) {
  113d56:	8b 45 08             	mov    0x8(%ebp),%eax
  113d59:	8b 40 10             	mov    0x10(%eax),%eax
  113d5c:	83 f8 03             	cmp    $0x3,%eax
  113d5f:	0f 86 ed 00 00 00    	jbe    113e52 <tcp_receive+0x3c2>
        if (pcb->cwnd < pcb->ssthresh) {
  113d65:	8b 45 08             	mov    0x8(%ebp),%eax
  113d68:	0f b7 50 4a          	movzwl 0x4a(%eax),%edx
  113d6c:	8b 45 08             	mov    0x8(%ebp),%eax
  113d6f:	0f b7 40 4c          	movzwl 0x4c(%eax),%eax
  113d73:	66 39 c2             	cmp    %ax,%dx
  113d76:	73 3c                	jae    113db4 <tcp_receive+0x324>
    if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
  113d78:	8b 45 08             	mov    0x8(%ebp),%eax
  113d7b:	0f b7 50 4a          	movzwl 0x4a(%eax),%edx
  113d7f:	8b 45 08             	mov    0x8(%ebp),%eax
  113d82:	0f b7 40 34          	movzwl 0x34(%eax),%eax
  113d86:	01 c2                	add    %eax,%edx
  113d88:	8b 45 08             	mov    0x8(%ebp),%eax
  113d8b:	0f b7 40 4a          	movzwl 0x4a(%eax),%eax
  113d8f:	66 39 c2             	cmp    %ax,%dx
  113d92:	0f 86 ba 00 00 00    	jbe    113e52 <tcp_receive+0x3c2>
      pcb->cwnd += pcb->mss;
  113d98:	8b 45 08             	mov    0x8(%ebp),%eax
  113d9b:	0f b7 50 4a          	movzwl 0x4a(%eax),%edx
  113d9f:	8b 45 08             	mov    0x8(%ebp),%eax
  113da2:	0f b7 40 34          	movzwl 0x34(%eax),%eax
  113da6:	01 c2                	add    %eax,%edx
  113da8:	8b 45 08             	mov    0x8(%ebp),%eax
  113dab:	66 89 50 4a          	mov    %dx,0x4a(%eax)
  113daf:	e9 9e 00 00 00       	jmp    113e52 <tcp_receive+0x3c2>
    }
          LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_receive: slow start cwnd %u\n", pcb->cwnd));
        } else {
    u16_t new_cwnd = (pcb->cwnd + pcb->mss * pcb->mss / pcb->cwnd);
  113db4:	8b 45 08             	mov    0x8(%ebp),%eax
  113db7:	0f b7 48 4a          	movzwl 0x4a(%eax),%ecx
  113dbb:	8b 45 08             	mov    0x8(%ebp),%eax
  113dbe:	0f b7 40 34          	movzwl 0x34(%eax),%eax
  113dc2:	0f b7 d0             	movzwl %ax,%edx
  113dc5:	8b 45 08             	mov    0x8(%ebp),%eax
  113dc8:	0f b7 40 34          	movzwl 0x34(%eax),%eax
  113dcc:	0f b7 c0             	movzwl %ax,%eax
  113dcf:	0f af d0             	imul   %eax,%edx
  113dd2:	8b 45 08             	mov    0x8(%ebp),%eax
  113dd5:	0f b7 40 4a          	movzwl 0x4a(%eax),%eax
  113dd9:	0f b7 c0             	movzwl %ax,%eax
  113ddc:	89 c3                	mov    %eax,%ebx
  113dde:	89 d0                	mov    %edx,%eax
  113de0:	c1 fa 1f             	sar    $0x1f,%edx
  113de3:	f7 fb                	idiv   %ebx
  113de5:	8d 04 01             	lea    (%ecx,%eax,1),%eax
  113de8:	66 89 45 fa          	mov    %ax,0xfffffffa(%ebp)
    if (new_cwnd > pcb->cwnd) {
  113dec:	8b 45 08             	mov    0x8(%ebp),%eax
  113def:	0f b7 40 4a          	movzwl 0x4a(%eax),%eax
  113df3:	66 3b 45 fa          	cmp    0xfffffffa(%ebp),%ax
  113df7:	73 59                	jae    113e52 <tcp_receive+0x3c2>
      pcb->cwnd = new_cwnd;
  113df9:	8b 55 08             	mov    0x8(%ebp),%edx
  113dfc:	0f b7 45 fa          	movzwl 0xfffffffa(%ebp),%eax
  113e00:	66 89 42 4a          	mov    %ax,0x4a(%edx)
    }
          LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_receive: congestion avoidance cwnd %u\n", pcb->cwnd));
        }
      }
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: ACK for %lu, unacked->seqno %lu:%lu\n",
                               ackno,
                               pcb->unacked != NULL?
                               ntohl(pcb->unacked->tcphdr->seqno): 0,
                               pcb->unacked != NULL?
                               ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
   ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
  113e04:	eb 4c                	jmp    113e52 <tcp_receive+0x3c2>
      TCP_SEQ_LEQ(ntohl(pcb->unacked->tcphdr->seqno) +
      TCP_TCPLEN(pcb->unacked), ackno)) {
  LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %lu:%lu from pcb->unacked\n",
         ntohl(pcb->unacked->tcphdr->seqno),
         ntohl(pcb->unacked->tcphdr->seqno) +
         TCP_TCPLEN(pcb->unacked)));

  next = pcb->unacked;
  113e06:	8b 45 08             	mov    0x8(%ebp),%eax
  113e09:	8b 40 74             	mov    0x74(%eax),%eax
  113e0c:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
  pcb->unacked = pcb->unacked->next;
  113e0f:	8b 45 08             	mov    0x8(%ebp),%eax
  113e12:	8b 40 74             	mov    0x74(%eax),%eax
  113e15:	8b 10                	mov    (%eax),%edx
  113e17:	8b 45 08             	mov    0x8(%ebp),%eax
  113e1a:	89 50 74             	mov    %edx,0x74(%eax)

  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %u ... ", (unsigned int)pcb->snd_queuelen));
  pcb->snd_queuelen -= pbuf_clen(next->p);
  113e1d:	8b 45 08             	mov    0x8(%ebp),%eax
  113e20:	0f b6 58 6c          	movzbl 0x6c(%eax),%ebx
  113e24:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  113e27:	8b 40 04             	mov    0x4(%eax),%eax
  113e2a:	89 04 24             	mov    %eax,(%esp)
  113e2d:	e8 ce b7 ff ff       	call   10f600 <pbuf_clen>
  113e32:	89 da                	mov    %ebx,%edx
  113e34:	28 c2                	sub    %al,%dl
  113e36:	8b 45 08             	mov    0x8(%ebp),%eax
  113e39:	88 50 6c             	mov    %dl,0x6c(%eax)
  tcp_seg_free(next);
  113e3c:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  113e3f:	89 04 24             	mov    %eax,(%esp)
  113e42:	e8 d9 d2 ff ff       	call   111120 <tcp_seg_free>

  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%u (after freeing unacked)\n", (unsigned int)pcb->snd_queuelen));
  if (pcb->snd_queuelen != 0) {
  113e47:	8b 45 08             	mov    0x8(%ebp),%eax
  113e4a:	0f b6 40 6c          	movzbl 0x6c(%eax),%eax
  113e4e:	84 c0                	test   %al,%al
  113e50:	74 00                	je     113e52 <tcp_receive+0x3c2>
  113e52:	8b 45 08             	mov    0x8(%ebp),%eax
  113e55:	8b 40 74             	mov    0x74(%eax),%eax
  113e58:	85 c0                	test   %eax,%eax
  113e5a:	0f 84 9d 00 00 00    	je     113efd <tcp_receive+0x46d>
  113e60:	8b 45 08             	mov    0x8(%ebp),%eax
  113e63:	8b 40 74             	mov    0x74(%eax),%eax
  113e66:	8b 40 10             	mov    0x10(%eax),%eax
  113e69:	8b 40 04             	mov    0x4(%eax),%eax
  113e6c:	89 04 24             	mov    %eax,(%esp)
  113e6f:	e8 9c a4 ff ff       	call   10e310 <ntohl>
  113e74:	66 89 45 a4          	mov    %ax,0xffffffa4(%ebp)
  113e78:	8b 45 08             	mov    0x8(%ebp),%eax
  113e7b:	8b 40 74             	mov    0x74(%eax),%eax
  113e7e:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  113e82:	66 89 45 a6          	mov    %ax,0xffffffa6(%ebp)
  113e86:	8b 45 08             	mov    0x8(%ebp),%eax
  113e89:	8b 40 74             	mov    0x74(%eax),%eax
  113e8c:	8b 40 10             	mov    0x10(%eax),%eax
  113e8f:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  113e93:	0f b7 c0             	movzwl %ax,%eax
  113e96:	89 04 24             	mov    %eax,(%esp)
  113e99:	e8 12 a4 ff ff       	call   10e2b0 <ntohs>
  113e9e:	0f b7 c0             	movzwl %ax,%eax
  113ea1:	83 e0 01             	and    $0x1,%eax
  113ea4:	84 c0                	test   %al,%al
  113ea6:	75 22                	jne    113eca <tcp_receive+0x43a>
  113ea8:	8b 45 08             	mov    0x8(%ebp),%eax
  113eab:	8b 40 74             	mov    0x74(%eax),%eax
  113eae:	8b 40 10             	mov    0x10(%eax),%eax
  113eb1:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  113eb5:	0f b7 c0             	movzwl %ax,%eax
  113eb8:	89 04 24             	mov    %eax,(%esp)
  113ebb:	e8 f0 a3 ff ff       	call   10e2b0 <ntohs>
  113ec0:	0f b7 c0             	movzwl %ax,%eax
  113ec3:	83 e0 02             	and    $0x2,%eax
  113ec6:	85 c0                	test   %eax,%eax
  113ec8:	74 09                	je     113ed3 <tcp_receive+0x443>
  113eca:	c7 45 a8 01 00 00 00 	movl   $0x1,0xffffffa8(%ebp)
  113ed1:	eb 07                	jmp    113eda <tcp_receive+0x44a>
  113ed3:	c7 45 a8 00 00 00 00 	movl   $0x0,0xffffffa8(%ebp)
  113eda:	0f b7 45 a8          	movzwl 0xffffffa8(%ebp),%eax
  113ede:	66 03 45 a6          	add    0xffffffa6(%ebp),%ax
  113ee2:	0f b7 55 a4          	movzwl 0xffffffa4(%ebp),%edx
  113ee6:	01 c2                	add    %eax,%edx
  113ee8:	a1 10 99 13 00       	mov    0x139910,%eax
  113eed:	89 d1                	mov    %edx,%ecx
  113eef:	66 29 c1             	sub    %ax,%cx
  113ef2:	89 c8                	mov    %ecx,%eax
  113ef4:	66 85 c0             	test   %ax,%ax
  113ef7:	0f 8e 09 ff ff ff    	jle    113e06 <tcp_receive+0x376>
    LWIP_ASSERT("tcp_receive: valid queue length", pcb->unacked != NULL ||
     pcb->unsent != NULL);
  }
      }
      pcb->polltmr = 0;
  113efd:	8b 45 08             	mov    0x8(%ebp),%eax
  113f00:	c6 40 30 00          	movb   $0x0,0x30(%eax)
    }

      /* We go through the ->unsent list to see if any of the segments
         on the list are acknowledged by the ACK. This may seem
         strange since an "unsent" segment shouldn't be acked. The
         rationale is that lwIP puts all outstanding segments on the
         ->unsent list after a retransmission, so these segments may
         in fact have been sent once. */
      while (pcb->unsent != NULL &&
  113f04:	eb 72                	jmp    113f78 <tcp_receive+0x4e8>
      TCP_SEQ_LEQ(ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent),
                        ackno) &&
      TCP_SEQ_LEQ(ackno, pcb->snd_max)) {
  LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %lu:%lu from pcb->unsent\n",
         ntohl(pcb->unsent->tcphdr->seqno),
         ntohl(pcb->unsent->tcphdr->seqno) +
         TCP_TCPLEN(pcb->unsent)));

  next = pcb->unsent;
  113f06:	8b 45 08             	mov    0x8(%ebp),%eax
  113f09:	8b 40 70             	mov    0x70(%eax),%eax
  113f0c:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
  pcb->unsent = pcb->unsent->next;
  113f0f:	8b 45 08             	mov    0x8(%ebp),%eax
  113f12:	8b 40 70             	mov    0x70(%eax),%eax
  113f15:	8b 10                	mov    (%eax),%edx
  113f17:	8b 45 08             	mov    0x8(%ebp),%eax
  113f1a:	89 50 70             	mov    %edx,0x70(%eax)
  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %u ... ", (unsigned int)pcb->snd_queuelen));
  pcb->snd_queuelen -= pbuf_clen(next->p);
  113f1d:	8b 45 08             	mov    0x8(%ebp),%eax
  113f20:	0f b6 58 6c          	movzbl 0x6c(%eax),%ebx
  113f24:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  113f27:	8b 40 04             	mov    0x4(%eax),%eax
  113f2a:	89 04 24             	mov    %eax,(%esp)
  113f2d:	e8 ce b6 ff ff       	call   10f600 <pbuf_clen>
  113f32:	89 da                	mov    %ebx,%edx
  113f34:	28 c2                	sub    %al,%dl
  113f36:	8b 45 08             	mov    0x8(%ebp),%eax
  113f39:	88 50 6c             	mov    %dl,0x6c(%eax)
  tcp_seg_free(next);
  113f3c:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  113f3f:	89 04 24             	mov    %eax,(%esp)
  113f42:	e8 d9 d1 ff ff       	call   111120 <tcp_seg_free>
  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%u (after freeing unsent)\n", (unsigned int)pcb->snd_queuelen));
  if (pcb->snd_queuelen != 0) {
  113f47:	8b 45 08             	mov    0x8(%ebp),%eax
  113f4a:	0f b6 40 6c          	movzbl 0x6c(%eax),%eax
  113f4e:	84 c0                	test   %al,%al
  113f50:	74 00                	je     113f52 <tcp_receive+0x4c2>
    LWIP_ASSERT("tcp_receive: valid queue length", pcb->unacked != NULL ||
     pcb->unsent != NULL);
  }

        if (pcb->unsent != NULL) {
  113f52:	8b 45 08             	mov    0x8(%ebp),%eax
  113f55:	8b 40 70             	mov    0x70(%eax),%eax
  113f58:	85 c0                	test   %eax,%eax
  113f5a:	74 1c                	je     113f78 <tcp_receive+0x4e8>
          pcb->snd_nxt = htonl(pcb->unsent->tcphdr->seqno);
  113f5c:	8b 45 08             	mov    0x8(%ebp),%eax
  113f5f:	8b 40 70             	mov    0x70(%eax),%eax
  113f62:	8b 40 10             	mov    0x10(%eax),%eax
  113f65:	8b 40 04             	mov    0x4(%eax),%eax
  113f68:	89 04 24             	mov    %eax,(%esp)
  113f6b:	e8 60 a3 ff ff       	call   10e2d0 <htonl>
  113f70:	89 c2                	mov    %eax,%edx
  113f72:	8b 45 08             	mov    0x8(%ebp),%eax
  113f75:	89 50 50             	mov    %edx,0x50(%eax)
  113f78:	8b 45 08             	mov    0x8(%ebp),%eax
  113f7b:	8b 40 70             	mov    0x70(%eax),%eax
  113f7e:	85 c0                	test   %eax,%eax
  113f80:	0f 84 b6 00 00 00    	je     11403c <tcp_receive+0x5ac>
  113f86:	8b 45 08             	mov    0x8(%ebp),%eax
  113f89:	8b 40 70             	mov    0x70(%eax),%eax
  113f8c:	8b 40 10             	mov    0x10(%eax),%eax
  113f8f:	8b 40 04             	mov    0x4(%eax),%eax
  113f92:	89 04 24             	mov    %eax,(%esp)
  113f95:	e8 76 a3 ff ff       	call   10e310 <ntohl>
  113f9a:	66 89 45 ac          	mov    %ax,0xffffffac(%ebp)
  113f9e:	8b 45 08             	mov    0x8(%ebp),%eax
  113fa1:	8b 40 70             	mov    0x70(%eax),%eax
  113fa4:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  113fa8:	66 89 45 ae          	mov    %ax,0xffffffae(%ebp)
  113fac:	8b 45 08             	mov    0x8(%ebp),%eax
  113faf:	8b 40 70             	mov    0x70(%eax),%eax
  113fb2:	8b 40 10             	mov    0x10(%eax),%eax
  113fb5:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  113fb9:	0f b7 c0             	movzwl %ax,%eax
  113fbc:	89 04 24             	mov    %eax,(%esp)
  113fbf:	e8 ec a2 ff ff       	call   10e2b0 <ntohs>
  113fc4:	0f b7 c0             	movzwl %ax,%eax
  113fc7:	83 e0 01             	and    $0x1,%eax
  113fca:	84 c0                	test   %al,%al
  113fcc:	75 22                	jne    113ff0 <tcp_receive+0x560>
  113fce:	8b 45 08             	mov    0x8(%ebp),%eax
  113fd1:	8b 40 70             	mov    0x70(%eax),%eax
  113fd4:	8b 40 10             	mov    0x10(%eax),%eax
  113fd7:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  113fdb:	0f b7 c0             	movzwl %ax,%eax
  113fde:	89 04 24             	mov    %eax,(%esp)
  113fe1:	e8 ca a2 ff ff       	call   10e2b0 <ntohs>
  113fe6:	0f b7 c0             	movzwl %ax,%eax
  113fe9:	83 e0 02             	and    $0x2,%eax
  113fec:	85 c0                	test   %eax,%eax
  113fee:	74 09                	je     113ff9 <tcp_receive+0x569>
  113ff0:	c7 45 b0 01 00 00 00 	movl   $0x1,0xffffffb0(%ebp)
  113ff7:	eb 07                	jmp    114000 <tcp_receive+0x570>
  113ff9:	c7 45 b0 00 00 00 00 	movl   $0x0,0xffffffb0(%ebp)
  114000:	0f b7 45 b0          	movzwl 0xffffffb0(%ebp),%eax
  114004:	66 03 45 ae          	add    0xffffffae(%ebp),%ax
  114008:	0f b7 55 ac          	movzwl 0xffffffac(%ebp),%edx
  11400c:	01 c2                	add    %eax,%edx
  11400e:	a1 10 99 13 00       	mov    0x139910,%eax
  114013:	89 d3                	mov    %edx,%ebx
  114015:	66 29 c3             	sub    %ax,%bx
  114018:	89 d8                	mov    %ebx,%eax
  11401a:	66 85 c0             	test   %ax,%ax
  11401d:	7f 1d                	jg     11403c <tcp_receive+0x5ac>
  11401f:	a1 10 99 13 00       	mov    0x139910,%eax
  114024:	89 c2                	mov    %eax,%edx
  114026:	8b 45 08             	mov    0x8(%ebp),%eax
  114029:	8b 40 54             	mov    0x54(%eax),%eax
  11402c:	89 d1                	mov    %edx,%ecx
  11402e:	66 29 c1             	sub    %ax,%cx
  114031:	89 c8                	mov    %ecx,%eax
  114033:	66 85 c0             	test   %ax,%ax
  114036:	0f 8e ca fe ff ff    	jle    113f06 <tcp_receive+0x476>
        }
      }

    /* End of ACK for new data processing. */

    LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: pcb->rttest %u rtseq %lu ackno %lu\n",
     pcb->rttest, pcb->rtseq, ackno));

    /* RTT estimation calculations. This is done by checking if the
       incoming segment acknowledges the segment we use to take a
       round-trip time measurement. */
    if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
  11403c:	8b 45 08             	mov    0x8(%ebp),%eax
  11403f:	0f b7 40 36          	movzwl 0x36(%eax),%eax
  114043:	66 85 c0             	test   %ax,%ax
  114046:	0f 84 b3 00 00 00    	je     1140ff <tcp_receive+0x66f>
  11404c:	8b 45 08             	mov    0x8(%ebp),%eax
  11404f:	8b 40 38             	mov    0x38(%eax),%eax
  114052:	89 c2                	mov    %eax,%edx
  114054:	a1 10 99 13 00       	mov    0x139910,%eax
  114059:	89 d3                	mov    %edx,%ebx
  11405b:	66 29 c3             	sub    %ax,%bx
  11405e:	89 d8                	mov    %ebx,%eax
  114060:	66 85 c0             	test   %ax,%ax
  114063:	0f 89 96 00 00 00    	jns    1140ff <tcp_receive+0x66f>
      m = tcp_ticks - pcb->rttest;
  114069:	8b 15 58 16 14 00    	mov    0x141658,%edx
  11406f:	8b 45 08             	mov    0x8(%ebp),%eax
  114072:	0f b7 40 36          	movzwl 0x36(%eax),%eax
  114076:	0f b7 c0             	movzwl %ax,%eax
  114079:	89 d1                	mov    %edx,%ecx
  11407b:	29 c1                	sub    %eax,%ecx
  11407d:	89 c8                	mov    %ecx,%eax
  11407f:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: experienced rtt %u ticks (%u msec).\n",
       m, m * TCP_SLOW_INTERVAL));

      /* This is taken directly from VJs original code in his paper */
      m = m - (pcb->sa >> 3);
  114082:	8b 45 08             	mov    0x8(%ebp),%eax
  114085:	0f b7 40 3c          	movzwl 0x3c(%eax),%eax
  114089:	66 c1 f8 03          	sar    $0x3,%ax
  11408d:	98                   	cwtl   
  11408e:	29 45 f0             	sub    %eax,0xfffffff0(%ebp)
      pcb->sa += m;
  114091:	8b 45 08             	mov    0x8(%ebp),%eax
  114094:	0f b7 40 3c          	movzwl 0x3c(%eax),%eax
  114098:	89 c2                	mov    %eax,%edx
  11409a:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  11409d:	8d 04 02             	lea    (%edx,%eax,1),%eax
  1140a0:	89 c2                	mov    %eax,%edx
  1140a2:	8b 45 08             	mov    0x8(%ebp),%eax
  1140a5:	66 89 50 3c          	mov    %dx,0x3c(%eax)
      if (m < 0) {
  1140a9:	83 7d f0 00          	cmpl   $0x0,0xfffffff0(%ebp)
  1140ad:	79 03                	jns    1140b2 <tcp_receive+0x622>
  m = -m;
  1140af:	f7 5d f0             	negl   0xfffffff0(%ebp)
      }
      m = m - (pcb->sv >> 2);
  1140b2:	8b 45 08             	mov    0x8(%ebp),%eax
  1140b5:	0f b7 40 3e          	movzwl 0x3e(%eax),%eax
  1140b9:	66 c1 f8 02          	sar    $0x2,%ax
  1140bd:	98                   	cwtl   
  1140be:	29 45 f0             	sub    %eax,0xfffffff0(%ebp)
      pcb->sv += m;
  1140c1:	8b 45 08             	mov    0x8(%ebp),%eax
  1140c4:	0f b7 40 3e          	movzwl 0x3e(%eax),%eax
  1140c8:	89 c2                	mov    %eax,%edx
  1140ca:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  1140cd:	8d 04 02             	lea    (%edx,%eax,1),%eax
  1140d0:	89 c2                	mov    %eax,%edx
  1140d2:	8b 45 08             	mov    0x8(%ebp),%eax
  1140d5:	66 89 50 3e          	mov    %dx,0x3e(%eax)
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
  1140d9:	8b 45 08             	mov    0x8(%ebp),%eax
  1140dc:	0f b7 40 3c          	movzwl 0x3c(%eax),%eax
  1140e0:	66 c1 f8 03          	sar    $0x3,%ax
  1140e4:	89 c2                	mov    %eax,%edx
  1140e6:	8b 45 08             	mov    0x8(%ebp),%eax
  1140e9:	0f b7 40 3e          	movzwl 0x3e(%eax),%eax
  1140ed:	01 c2                	add    %eax,%edx
  1140ef:	8b 45 08             	mov    0x8(%ebp),%eax
  1140f2:	66 89 50 40          	mov    %dx,0x40(%eax)

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: RTO %u (%u miliseconds)\n",
           pcb->rto, pcb->rto * TCP_SLOW_INTERVAL));

      pcb->rttest = 0;
  1140f6:	8b 45 08             	mov    0x8(%ebp),%eax
  1140f9:	66 c7 40 36 00 00    	movw   $0x0,0x36(%eax)
    }
  }

  /* If the incoming segment contains data, we must process it
     further. */
  if (tcplen > 0) {
  1140ff:	0f b7 05 16 99 13 00 	movzwl 0x139916,%eax
  114106:	66 85 c0             	test   %ax,%ax
  114109:	0f 84 31 09 00 00    	je     114a40 <tcp_receive+0xfb0>
    /* This code basically does three things:

     +) If the incoming segment contains data that is the next
        in-sequence data, this data is passed to the application. This
        might involve trimming the first edge of the data. The rcv_nxt
        variable and the advertised window are adjusted.

     +) If the incoming segment has data that is above the next
        sequence number expected (->rcv_nxt), the segment is placed on
        the ->ooseq queue. This is done by finding the appropriate
        place in the ->ooseq queue (which is ordered by sequence
        number) and trim the segment in both ends if needed. An
        immediate ACK is sent to indicate that we received an
        out-of-sequence segment.

     +) Finally, we check if the first segment on the ->ooseq queue
        now is in sequence (i.e., if rcv_nxt >= ooseq->seqno). If
        rcv_nxt > ooseq->seqno, we must trim the first edge of the
        segment on ->ooseq before we adjust rcv_nxt. The data in the
        segments that are now on sequence are chained onto the
        incoming segment so that we only need to call the application
        once.
    */

    /* First, we check if we must trim the first edge. We have to do
       this if the sequence number of the incoming segment is less
       than rcv_nxt, and the sequence number plus the length of the
       segment is larger than rcv_nxt. */
    if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
  11410f:	a1 0c 99 13 00       	mov    0x13990c,%eax
  114114:	89 c2                	mov    %eax,%edx
  114116:	8b 45 08             	mov    0x8(%ebp),%eax
  114119:	8b 40 24             	mov    0x24(%eax),%eax
  11411c:	89 d3                	mov    %edx,%ebx
  11411e:	66 29 c3             	sub    %ax,%bx
  114121:	89 d8                	mov    %ebx,%eax
  114123:	66 85 c0             	test   %ax,%ax
  114126:	0f 89 57 01 00 00    	jns    114283 <tcp_receive+0x7f3>
      if (TCP_SEQ_LT(pcb->rcv_nxt, seqno + tcplen)) {
  11412c:	8b 45 08             	mov    0x8(%ebp),%eax
  11412f:	8b 40 24             	mov    0x24(%eax),%eax
  114132:	89 c1                	mov    %eax,%ecx
  114134:	a1 0c 99 13 00       	mov    0x13990c,%eax
  114139:	89 c2                	mov    %eax,%edx
  11413b:	0f b7 05 16 99 13 00 	movzwl 0x139916,%eax
  114142:	8d 04 02             	lea    (%edx,%eax,1),%eax
  114145:	89 ca                	mov    %ecx,%edx
  114147:	66 29 c2             	sub    %ax,%dx
  11414a:	89 d0                	mov    %edx,%eax
  11414c:	66 85 c0             	test   %ax,%ax
  11414f:	0f 89 11 01 00 00    	jns    114266 <tcp_receive+0x7d6>
  /* Trimming the first edge is done by pushing the payload
     pointer in the pbuf downwards. This is somewhat tricky since
     we do not want to discard the full contents of the pbuf up to
     the new starting point of the data since we have to keep the
     TCP header which is present in the first pbuf in the chain.

     What is done is really quite a nasty hack: the first pbuf in
     the pbuf chain is pointed to by inseg.p. Since we need to be
     able to deallocate the whole pbuf, we cannot change this
     inseg.p pointer to point to any of the later pbufs in the
     chain. Instead, we point the ->payload pointer in the first
     pbuf to data in one of the later pbufs. We also set the
     inseg.data pointer to point to the right place. This way, the
     ->p pointer will still point to the first pbuf, but the
     ->p->payload pointer will point to data in another pbuf.

     After we are done with adjusting the pbuf pointers we must
     adjust the ->data pointer in the seg and the segment
     length.*/
  off = pcb->rcv_nxt - seqno;
  114155:	8b 45 08             	mov    0x8(%ebp),%eax
  114158:	8b 40 24             	mov    0x24(%eax),%eax
  11415b:	89 c2                	mov    %eax,%edx
  11415d:	a1 0c 99 13 00       	mov    0x13990c,%eax
  114162:	89 d1                	mov    %edx,%ecx
  114164:	66 29 c1             	sub    %ax,%cx
  114167:	89 c8                	mov    %ecx,%eax
  114169:	66 89 45 ee          	mov    %ax,0xffffffee(%ebp)
  if (inseg.p->len < off) {
  11416d:	a1 f4 98 13 00       	mov    0x1398f4,%eax
  114172:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  114176:	0f b7 d0             	movzwl %ax,%edx
  114179:	0f bf 45 ee          	movswl 0xffffffee(%ebp),%eax
  11417d:	39 c2                	cmp    %eax,%edx
  11417f:	7d 7c                	jge    1141fd <tcp_receive+0x76d>
    p = inseg.p;
  114181:	a1 f4 98 13 00       	mov    0x1398f4,%eax
  114186:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
    while (p->len < off) {
  114189:	eb 48                	jmp    1141d3 <tcp_receive+0x743>
      off -= p->len;
  11418b:	0f b7 55 ee          	movzwl 0xffffffee(%ebp),%edx
  11418f:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  114192:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  114196:	89 d3                	mov    %edx,%ebx
  114198:	66 29 c3             	sub    %ax,%bx
  11419b:	89 d8                	mov    %ebx,%eax
  11419d:	66 89 45 ee          	mov    %ax,0xffffffee(%ebp)
      inseg.p->tot_len -= p->len;
  1141a1:	8b 0d f4 98 13 00    	mov    0x1398f4,%ecx
  1141a7:	a1 f4 98 13 00       	mov    0x1398f4,%eax
  1141ac:	0f b7 50 08          	movzwl 0x8(%eax),%edx
  1141b0:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  1141b3:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  1141b7:	89 d3                	mov    %edx,%ebx
  1141b9:	66 29 c3             	sub    %ax,%bx
  1141bc:	89 d8                	mov    %ebx,%eax
  1141be:	66 89 41 08          	mov    %ax,0x8(%ecx)
      p->len = 0;
  1141c2:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  1141c5:	66 c7 40 0a 00 00    	movw   $0x0,0xa(%eax)
      p = p->next;
  1141cb:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  1141ce:	8b 00                	mov    (%eax),%eax
  1141d0:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
  1141d3:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  1141d6:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  1141da:	0f b7 d0             	movzwl %ax,%edx
  1141dd:	0f bf 45 ee          	movswl 0xffffffee(%ebp),%eax
  1141e1:	39 c2                	cmp    %eax,%edx
  1141e3:	7c a6                	jl     11418b <tcp_receive+0x6fb>
    }
    pbuf_header(p, -off);
  1141e5:	0f b7 45 ee          	movzwl 0xffffffee(%ebp),%eax
  1141e9:	f7 d8                	neg    %eax
  1141eb:	98                   	cwtl   
  1141ec:	89 44 24 04          	mov    %eax,0x4(%esp)
  1141f0:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  1141f3:	89 04 24             	mov    %eax,(%esp)
  1141f6:	e8 c5 b1 ff ff       	call   10f3c0 <pbuf_header>
  1141fb:	eb 19                	jmp    114216 <tcp_receive+0x786>
  } else {
    pbuf_header(inseg.p, -off);
  1141fd:	0f b7 45 ee          	movzwl 0xffffffee(%ebp),%eax
  114201:	f7 d8                	neg    %eax
  114203:	98                   	cwtl   
  114204:	8b 15 f4 98 13 00    	mov    0x1398f4,%edx
  11420a:	89 44 24 04          	mov    %eax,0x4(%esp)
  11420e:	89 14 24             	mov    %edx,(%esp)
  114211:	e8 aa b1 ff ff       	call   10f3c0 <pbuf_header>
  }
  inseg.dataptr = inseg.p->payload;
  114216:	a1 f4 98 13 00       	mov    0x1398f4,%eax
  11421b:	8b 40 04             	mov    0x4(%eax),%eax
  11421e:	a3 f8 98 13 00       	mov    %eax,0x1398f8
  inseg.len -= pcb->rcv_nxt - seqno;
  114223:	0f b7 0d fc 98 13 00 	movzwl 0x1398fc,%ecx
  11422a:	8b 45 08             	mov    0x8(%ebp),%eax
  11422d:	8b 40 24             	mov    0x24(%eax),%eax
  114230:	89 c2                	mov    %eax,%edx
  114232:	a1 0c 99 13 00       	mov    0x13990c,%eax
  114237:	89 d3                	mov    %edx,%ebx
  114239:	66 29 c3             	sub    %ax,%bx
  11423c:	89 d8                	mov    %ebx,%eax
  11423e:	89 ca                	mov    %ecx,%edx
  114240:	66 29 c2             	sub    %ax,%dx
  114243:	89 d0                	mov    %edx,%eax
  114245:	66 a3 fc 98 13 00    	mov    %ax,0x1398fc
  inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
  11424b:	8b 15 00 99 13 00    	mov    0x139900,%edx
  114251:	8b 45 08             	mov    0x8(%ebp),%eax
  114254:	8b 40 24             	mov    0x24(%eax),%eax
  114257:	a3 0c 99 13 00       	mov    %eax,0x13990c
  11425c:	a1 0c 99 13 00       	mov    0x13990c,%eax
  114261:	89 42 04             	mov    %eax,0x4(%edx)
  114264:	eb 1d                	jmp    114283 <tcp_receive+0x7f3>
      }
      else{
  /* the whole segment is < rcv_nxt */
  /* must be a duplicate of a packet that has already been correctly handled */

  LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: duplicate seqno %lu\n", seqno));
  tcp_ack_now(pcb);
  114266:	8b 45 08             	mov    0x8(%ebp),%eax
  114269:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  11426d:	89 c2                	mov    %eax,%edx
  11426f:	83 ca 02             	or     $0x2,%edx
  114272:	8b 45 08             	mov    0x8(%ebp),%eax
  114275:	88 50 20             	mov    %dl,0x20(%eax)
  114278:	8b 45 08             	mov    0x8(%ebp),%eax
  11427b:	89 04 24             	mov    %eax,(%esp)
  11427e:	e8 cd db ff ff       	call   111e50 <tcp_output>
      }
    }

    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_GEQ(seqno, pcb->rcv_nxt) &&
  114283:	a1 0c 99 13 00       	mov    0x13990c,%eax
  114288:	89 c2                	mov    %eax,%edx
  11428a:	8b 45 08             	mov    0x8(%ebp),%eax
  11428d:	8b 40 24             	mov    0x24(%eax),%eax
  114290:	89 d1                	mov    %edx,%ecx
  114292:	66 29 c1             	sub    %ax,%cx
  114295:	89 c8                	mov    %ecx,%eax
  114297:	66 85 c0             	test   %ax,%ax
  11429a:	0f 88 fb 07 00 00    	js     114a9b <tcp_receive+0x100b>
  1142a0:	a1 0c 99 13 00       	mov    0x13990c,%eax
  1142a5:	89 c1                	mov    %eax,%ecx
  1142a7:	8b 45 08             	mov    0x8(%ebp),%eax
  1142aa:	8b 40 24             	mov    0x24(%eax),%eax
  1142ad:	89 c2                	mov    %eax,%edx
  1142af:	8b 45 08             	mov    0x8(%ebp),%eax
  1142b2:	0f b7 40 28          	movzwl 0x28(%eax),%eax
  1142b6:	8d 04 02             	lea    (%edx,%eax,1),%eax
  1142b9:	89 cb                	mov    %ecx,%ebx
  1142bb:	66 29 c3             	sub    %ax,%bx
  1142be:	89 d8                	mov    %ebx,%eax
  1142c0:	66 85 c0             	test   %ax,%ax
  1142c3:	0f 89 d2 07 00 00    	jns    114a9b <tcp_receive+0x100b>
       TCP_SEQ_LT(seqno, pcb->rcv_nxt + pcb->rcv_wnd)) {
      if (pcb->rcv_nxt == seqno) {
  1142c9:	8b 45 08             	mov    0x8(%ebp),%eax
  1142cc:	8b 50 24             	mov    0x24(%eax),%edx
  1142cf:	a1 0c 99 13 00       	mov    0x13990c,%eax
  1142d4:	39 c2                	cmp    %eax,%edx
  1142d6:	0f 85 fc 03 00 00    	jne    1146d8 <tcp_receive+0xc48>
  /* The incoming segment is the next in sequence. We check if
           we have to trim the end of the segment and update rcv_nxt
           and pass the data to the application. */
#if TCP_QUEUE_OOSEQ
  if (pcb->ooseq != NULL &&
  1142dc:	8b 45 08             	mov    0x8(%ebp),%eax
  1142df:	8b 40 78             	mov    0x78(%eax),%eax
  1142e2:	85 c0                	test   %eax,%eax
  1142e4:	74 65                	je     11434b <tcp_receive+0x8bb>
  1142e6:	8b 45 08             	mov    0x8(%ebp),%eax
  1142e9:	8b 40 78             	mov    0x78(%eax),%eax
  1142ec:	8b 40 10             	mov    0x10(%eax),%eax
  1142ef:	8b 40 04             	mov    0x4(%eax),%eax
  1142f2:	89 c1                	mov    %eax,%ecx
  1142f4:	0f b7 15 fc 98 13 00 	movzwl 0x1398fc,%edx
  1142fb:	a1 0c 99 13 00       	mov    0x13990c,%eax
  114300:	8d 04 02             	lea    (%edx,%eax,1),%eax
  114303:	89 ca                	mov    %ecx,%edx
  114305:	66 29 c2             	sub    %ax,%dx
  114308:	89 d0                	mov    %edx,%eax
  11430a:	66 85 c0             	test   %ax,%ax
  11430d:	7f 3c                	jg     11434b <tcp_receive+0x8bb>
     TCP_SEQ_LEQ(pcb->ooseq->tcphdr->seqno, seqno + inseg.len)) {
    /* We have to trim the second edge of the incoming
             segment. */
    inseg.len = pcb->ooseq->tcphdr->seqno - seqno;
  11430f:	8b 45 08             	mov    0x8(%ebp),%eax
  114312:	8b 40 78             	mov    0x78(%eax),%eax
  114315:	8b 40 10             	mov    0x10(%eax),%eax
  114318:	8b 40 04             	mov    0x4(%eax),%eax
  11431b:	89 c2                	mov    %eax,%edx
  11431d:	a1 0c 99 13 00       	mov    0x13990c,%eax
  114322:	89 d1                	mov    %edx,%ecx
  114324:	66 29 c1             	sub    %ax,%cx
  114327:	89 c8                	mov    %ecx,%eax
  114329:	66 a3 fc 98 13 00    	mov    %ax,0x1398fc
    pbuf_realloc(inseg.p, inseg.len);
  11432f:	0f b7 05 fc 98 13 00 	movzwl 0x1398fc,%eax
  114336:	0f b7 c0             	movzwl %ax,%eax
  114339:	8b 15 f4 98 13 00    	mov    0x1398f4,%edx
  11433f:	89 44 24 04          	mov    %eax,0x4(%esp)
  114343:	89 14 24             	mov    %edx,(%esp)
  114346:	e8 65 af ff ff       	call   10f2b0 <pbuf_realloc>
  }
#endif /* TCP_QUEUE_OOSEQ */

  tcplen = TCP_TCPLEN(&inseg);
  11434b:	0f b7 1d fc 98 13 00 	movzwl 0x1398fc,%ebx
  114352:	66 89 5d b6          	mov    %bx,0xffffffb6(%ebp)
  114356:	a1 00 99 13 00       	mov    0x139900,%eax
  11435b:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  11435f:	0f b7 c0             	movzwl %ax,%eax
  114362:	89 04 24             	mov    %eax,(%esp)
  114365:	e8 46 9f ff ff       	call   10e2b0 <ntohs>
  11436a:	0f b7 c0             	movzwl %ax,%eax
  11436d:	83 e0 01             	and    $0x1,%eax
  114370:	84 c0                	test   %al,%al
  114372:	75 1e                	jne    114392 <tcp_receive+0x902>
  114374:	a1 00 99 13 00       	mov    0x139900,%eax
  114379:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  11437d:	0f b7 c0             	movzwl %ax,%eax
  114380:	89 04 24             	mov    %eax,(%esp)
  114383:	e8 28 9f ff ff       	call   10e2b0 <ntohs>
  114388:	0f b7 c0             	movzwl %ax,%eax
  11438b:	83 e0 02             	and    $0x2,%eax
  11438e:	85 c0                	test   %eax,%eax
  114390:	74 09                	je     11439b <tcp_receive+0x90b>
  114392:	c7 45 b8 01 00 00 00 	movl   $0x1,0xffffffb8(%ebp)
  114399:	eb 07                	jmp    1143a2 <tcp_receive+0x912>
  11439b:	c7 45 b8 00 00 00 00 	movl   $0x0,0xffffffb8(%ebp)
  1143a2:	0f b7 45 b8          	movzwl 0xffffffb8(%ebp),%eax
  1143a6:	66 03 45 b6          	add    0xffffffb6(%ebp),%ax
  1143aa:	66 a3 16 99 13 00    	mov    %ax,0x139916

  pcb->rcv_nxt += tcplen;
  1143b0:	8b 45 08             	mov    0x8(%ebp),%eax
  1143b3:	8b 50 24             	mov    0x24(%eax),%edx
  1143b6:	0f b7 05 16 99 13 00 	movzwl 0x139916,%eax
  1143bd:	0f b7 c0             	movzwl %ax,%eax
  1143c0:	01 c2                	add    %eax,%edx
  1143c2:	8b 45 08             	mov    0x8(%ebp),%eax
  1143c5:	89 50 24             	mov    %edx,0x24(%eax)

  /* Update the receiver's (our) window. */
  if (pcb->rcv_wnd < tcplen) {
  1143c8:	8b 45 08             	mov    0x8(%ebp),%eax
  1143cb:	0f b7 50 28          	movzwl 0x28(%eax),%edx
  1143cf:	0f b7 05 16 99 13 00 	movzwl 0x139916,%eax
  1143d6:	66 39 c2             	cmp    %ax,%dx
  1143d9:	73 0b                	jae    1143e6 <tcp_receive+0x956>
    pcb->rcv_wnd = 0;
  1143db:	8b 45 08             	mov    0x8(%ebp),%eax
  1143de:	66 c7 40 28 00 00    	movw   $0x0,0x28(%eax)
  1143e4:	eb 18                	jmp    1143fe <tcp_receive+0x96e>
  } else {
    pcb->rcv_wnd -= tcplen;
  1143e6:	8b 45 08             	mov    0x8(%ebp),%eax
  1143e9:	0f b7 50 28          	movzwl 0x28(%eax),%edx
  1143ed:	0f b7 05 16 99 13 00 	movzwl 0x139916,%eax
  1143f4:	66 29 c2             	sub    %ax,%dx
  1143f7:	8b 45 08             	mov    0x8(%ebp),%eax
  1143fa:	66 89 50 28          	mov    %dx,0x28(%eax)
  }

  /* If there is data in the segment, we make preparations to
     pass this up to the application. The ->recv_data variable
     is used for holding the pbuf that goes to the
     application. The code for reassembling out-of-sequence data
     chains its data on this pbuf as well.

     If the segment was a FIN, we set the TF_GOT_FIN flag that will
     be used to indicate to the application that the remote side has
     closed its end of the connection. */
  if (inseg.p->tot_len > 0) {
  1143fe:	a1 f4 98 13 00       	mov    0x1398f4,%eax
  114403:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  114407:	66 85 c0             	test   %ax,%ax
  11440a:	74 14                	je     114420 <tcp_receive+0x990>
    recv_data = inseg.p;
  11440c:	a1 f4 98 13 00       	mov    0x1398f4,%eax
  114411:	a3 1c 99 13 00       	mov    %eax,0x13991c
    /* Since this pbuf now is the responsibility of the
       application, we delete our reference to it so that we won't
       (mistakingly) deallocate it. */
    inseg.p = NULL;
  114416:	c7 05 f4 98 13 00 00 	movl   $0x0,0x1398f4
  11441d:	00 00 00 
  }
  if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
  114420:	a1 00 99 13 00       	mov    0x139900,%eax
  114425:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  114429:	0f b7 c0             	movzwl %ax,%eax
  11442c:	89 04 24             	mov    %eax,(%esp)
  11442f:	e8 7c 9e ff ff       	call   10e2b0 <ntohs>
  114434:	0f b7 c0             	movzwl %ax,%eax
  114437:	83 e0 01             	and    $0x1,%eax
  11443a:	84 c0                	test   %al,%al
  11443c:	0f 84 16 02 00 00    	je     114658 <tcp_receive+0xbc8>
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: received FIN.\n"));
    recv_flags = TF_GOT_FIN;
  114442:	c6 05 18 99 13 00 20 	movb   $0x20,0x139918
  }

#if TCP_QUEUE_OOSEQ
  /* We now check if we have segments on the ->ooseq queue that
           is now in sequence. */
  while (pcb->ooseq != NULL &&
  114449:	e9 0a 02 00 00       	jmp    114658 <tcp_receive+0xbc8>
        pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {

    cseg = pcb->ooseq;
  11444e:	8b 45 08             	mov    0x8(%ebp),%eax
  114451:	8b 40 78             	mov    0x78(%eax),%eax
  114454:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
    seqno = pcb->ooseq->tcphdr->seqno;
  114457:	8b 45 08             	mov    0x8(%ebp),%eax
  11445a:	8b 40 78             	mov    0x78(%eax),%eax
  11445d:	8b 40 10             	mov    0x10(%eax),%eax
  114460:	8b 40 04             	mov    0x4(%eax),%eax
  114463:	a3 0c 99 13 00       	mov    %eax,0x13990c

    pcb->rcv_nxt += TCP_TCPLEN(cseg);
  114468:	8b 45 08             	mov    0x8(%ebp),%eax
  11446b:	8b 40 24             	mov    0x24(%eax),%eax
  11446e:	89 45 bc             	mov    %eax,0xffffffbc(%ebp)
  114471:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
  114474:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  114478:	0f b7 c0             	movzwl %ax,%eax
  11447b:	89 45 c0             	mov    %eax,0xffffffc0(%ebp)
  11447e:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
  114481:	8b 40 10             	mov    0x10(%eax),%eax
  114484:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  114488:	0f b7 c0             	movzwl %ax,%eax
  11448b:	89 04 24             	mov    %eax,(%esp)
  11448e:	e8 1d 9e ff ff       	call   10e2b0 <ntohs>
  114493:	0f b7 c0             	movzwl %ax,%eax
  114496:	83 e0 01             	and    $0x1,%eax
  114499:	84 c0                	test   %al,%al
  11449b:	75 1f                	jne    1144bc <tcp_receive+0xa2c>
  11449d:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
  1144a0:	8b 40 10             	mov    0x10(%eax),%eax
  1144a3:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  1144a7:	0f b7 c0             	movzwl %ax,%eax
  1144aa:	89 04 24             	mov    %eax,(%esp)
  1144ad:	e8 fe 9d ff ff       	call   10e2b0 <ntohs>
  1144b2:	0f b7 c0             	movzwl %ax,%eax
  1144b5:	83 e0 02             	and    $0x2,%eax
  1144b8:	85 c0                	test   %eax,%eax
  1144ba:	74 09                	je     1144c5 <tcp_receive+0xa35>
  1144bc:	c7 45 c4 01 00 00 00 	movl   $0x1,0xffffffc4(%ebp)
  1144c3:	eb 07                	jmp    1144cc <tcp_receive+0xa3c>
  1144c5:	c7 45 c4 00 00 00 00 	movl   $0x0,0xffffffc4(%ebp)
  1144cc:	8b 45 c0             	mov    0xffffffc0(%ebp),%eax
  1144cf:	03 45 c4             	add    0xffffffc4(%ebp),%eax
  1144d2:	8b 55 bc             	mov    0xffffffbc(%ebp),%edx
  1144d5:	01 c2                	add    %eax,%edx
  1144d7:	8b 45 08             	mov    0x8(%ebp),%eax
  1144da:	89 50 24             	mov    %edx,0x24(%eax)
    if (pcb->rcv_wnd < TCP_TCPLEN(cseg)) {
  1144dd:	8b 45 08             	mov    0x8(%ebp),%eax
  1144e0:	0f b7 40 28          	movzwl 0x28(%eax),%eax
  1144e4:	0f b7 c0             	movzwl %ax,%eax
  1144e7:	89 45 c8             	mov    %eax,0xffffffc8(%ebp)
  1144ea:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
  1144ed:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  1144f1:	0f b7 c0             	movzwl %ax,%eax
  1144f4:	89 45 cc             	mov    %eax,0xffffffcc(%ebp)
  1144f7:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
  1144fa:	8b 40 10             	mov    0x10(%eax),%eax
  1144fd:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  114501:	0f b7 c0             	movzwl %ax,%eax
  114504:	89 04 24             	mov    %eax,(%esp)
  114507:	e8 a4 9d ff ff       	call   10e2b0 <ntohs>
  11450c:	0f b7 c0             	movzwl %ax,%eax
  11450f:	83 e0 01             	and    $0x1,%eax
  114512:	84 c0                	test   %al,%al
  114514:	75 1f                	jne    114535 <tcp_receive+0xaa5>
  114516:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
  114519:	8b 40 10             	mov    0x10(%eax),%eax
  11451c:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  114520:	0f b7 c0             	movzwl %ax,%eax
  114523:	89 04 24             	mov    %eax,(%esp)
  114526:	e8 85 9d ff ff       	call   10e2b0 <ntohs>
  11452b:	0f b7 c0             	movzwl %ax,%eax
  11452e:	83 e0 02             	and    $0x2,%eax
  114531:	85 c0                	test   %eax,%eax
  114533:	74 09                	je     11453e <tcp_receive+0xaae>
  114535:	c7 45 d0 01 00 00 00 	movl   $0x1,0xffffffd0(%ebp)
  11453c:	eb 07                	jmp    114545 <tcp_receive+0xab5>
  11453e:	c7 45 d0 00 00 00 00 	movl   $0x0,0xffffffd0(%ebp)
  114545:	8b 45 cc             	mov    0xffffffcc(%ebp),%eax
  114548:	03 45 d0             	add    0xffffffd0(%ebp),%eax
  11454b:	39 45 c8             	cmp    %eax,0xffffffc8(%ebp)
  11454e:	7d 0b                	jge    11455b <tcp_receive+0xacb>
      pcb->rcv_wnd = 0;
  114550:	8b 45 08             	mov    0x8(%ebp),%eax
  114553:	66 c7 40 28 00 00    	movw   $0x0,0x28(%eax)
  114559:	eb 7a                	jmp    1145d5 <tcp_receive+0xb45>
    } else {
      pcb->rcv_wnd -= TCP_TCPLEN(cseg);
  11455b:	8b 45 08             	mov    0x8(%ebp),%eax
  11455e:	0f b7 40 28          	movzwl 0x28(%eax),%eax
  114562:	66 89 45 d4          	mov    %ax,0xffffffd4(%ebp)
  114566:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
  114569:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  11456d:	66 89 45 d6          	mov    %ax,0xffffffd6(%ebp)
  114571:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
  114574:	8b 40 10             	mov    0x10(%eax),%eax
  114577:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  11457b:	0f b7 c0             	movzwl %ax,%eax
  11457e:	89 04 24             	mov    %eax,(%esp)
  114581:	e8 2a 9d ff ff       	call   10e2b0 <ntohs>
  114586:	0f b7 c0             	movzwl %ax,%eax
  114589:	83 e0 01             	and    $0x1,%eax
  11458c:	84 c0                	test   %al,%al
  11458e:	75 1f                	jne    1145af <tcp_receive+0xb1f>
  114590:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
  114593:	8b 40 10             	mov    0x10(%eax),%eax
  114596:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  11459a:	0f b7 c0             	movzwl %ax,%eax
  11459d:	89 04 24             	mov    %eax,(%esp)
  1145a0:	e8 0b 9d ff ff       	call   10e2b0 <ntohs>
  1145a5:	0f b7 c0             	movzwl %ax,%eax
  1145a8:	83 e0 02             	and    $0x2,%eax
  1145ab:	85 c0                	test   %eax,%eax
  1145ad:	74 09                	je     1145b8 <tcp_receive+0xb28>
  1145af:	c7 45 d8 01 00 00 00 	movl   $0x1,0xffffffd8(%ebp)
  1145b6:	eb 07                	jmp    1145bf <tcp_receive+0xb2f>
  1145b8:	c7 45 d8 00 00 00 00 	movl   $0x0,0xffffffd8(%ebp)
  1145bf:	0f b7 45 d8          	movzwl 0xffffffd8(%ebp),%eax
  1145c3:	66 03 45 d6          	add    0xffffffd6(%ebp),%ax
  1145c7:	0f b7 55 d4          	movzwl 0xffffffd4(%ebp),%edx
  1145cb:	66 29 c2             	sub    %ax,%dx
  1145ce:	8b 45 08             	mov    0x8(%ebp),%eax
  1145d1:	66 89 50 28          	mov    %dx,0x28(%eax)
    }
    if (cseg->p->tot_len > 0) {
  1145d5:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
  1145d8:	8b 40 04             	mov    0x4(%eax),%eax
  1145db:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  1145df:	66 85 c0             	test   %ax,%ax
  1145e2:	74 38                	je     11461c <tcp_receive+0xb8c>
      /* Chain this pbuf onto the pbuf that we will pass to
         the application. */
      if (recv_data) {
  1145e4:	a1 1c 99 13 00       	mov    0x13991c,%eax
  1145e9:	85 c0                	test   %eax,%eax
  1145eb:	74 1a                	je     114607 <tcp_receive+0xb77>
              pbuf_cat(recv_data, cseg->p);
  1145ed:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
  1145f0:	8b 40 04             	mov    0x4(%eax),%eax
  1145f3:	8b 15 1c 99 13 00    	mov    0x13991c,%edx
  1145f9:	89 44 24 04          	mov    %eax,0x4(%esp)
  1145fd:	89 14 24             	mov    %edx,(%esp)
  114600:	e8 4b b0 ff ff       	call   10f650 <pbuf_cat>
  114605:	eb 0b                	jmp    114612 <tcp_receive+0xb82>
            } else {
        recv_data = cseg->p;
  114607:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
  11460a:	8b 40 04             	mov    0x4(%eax),%eax
  11460d:	a3 1c 99 13 00       	mov    %eax,0x13991c
      }
      cseg->p = NULL;
  114612:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
  114615:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    }
    if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
  11461c:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
  11461f:	8b 40 10             	mov    0x10(%eax),%eax
  114622:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  114626:	0f b7 c0             	movzwl %ax,%eax
  114629:	89 04 24             	mov    %eax,(%esp)
  11462c:	e8 7f 9c ff ff       	call   10e2b0 <ntohs>
  114631:	0f b7 c0             	movzwl %ax,%eax
  114634:	83 e0 01             	and    $0x1,%eax
  114637:	84 c0                	test   %al,%al
  114639:	74 07                	je     114642 <tcp_receive+0xbb2>
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: dequeued FIN.\n"));
      recv_flags = TF_GOT_FIN;
  11463b:	c6 05 18 99 13 00 20 	movb   $0x20,0x139918
    }


    pcb->ooseq = cseg->next;
  114642:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
  114645:	8b 10                	mov    (%eax),%edx
  114647:	8b 45 08             	mov    0x8(%ebp),%eax
  11464a:	89 50 78             	mov    %edx,0x78(%eax)
    tcp_seg_free(cseg);
  11464d:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
  114650:	89 04 24             	mov    %eax,(%esp)
  114653:	e8 c8 ca ff ff       	call   111120 <tcp_seg_free>
  114658:	8b 45 08             	mov    0x8(%ebp),%eax
  11465b:	8b 40 78             	mov    0x78(%eax),%eax
  11465e:	85 c0                	test   %eax,%eax
  114660:	74 1a                	je     11467c <tcp_receive+0xbec>
  114662:	8b 45 08             	mov    0x8(%ebp),%eax
  114665:	8b 40 78             	mov    0x78(%eax),%eax
  114668:	8b 40 10             	mov    0x10(%eax),%eax
  11466b:	8b 50 04             	mov    0x4(%eax),%edx
  11466e:	8b 45 08             	mov    0x8(%ebp),%eax
  114671:	8b 40 24             	mov    0x24(%eax),%eax
  114674:	39 c2                	cmp    %eax,%edx
  114676:	0f 84 d2 fd ff ff    	je     11444e <tcp_receive+0x9be>
  }
#endif /* TCP_QUEUE_OOSEQ */


  /* Acknowledge the segment(s). */
  tcp_ack(pcb);
  11467c:	8b 45 08             	mov    0x8(%ebp),%eax
  11467f:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  114683:	0f b6 c0             	movzbl %al,%eax
  114686:	83 e0 01             	and    $0x1,%eax
  114689:	84 c0                	test   %al,%al
  11468b:	74 34                	je     1146c1 <tcp_receive+0xc31>
  11468d:	8b 45 08             	mov    0x8(%ebp),%eax
  114690:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  114694:	89 c2                	mov    %eax,%edx
  114696:	83 e2 fe             	and    $0xfffffffe,%edx
  114699:	8b 45 08             	mov    0x8(%ebp),%eax
  11469c:	88 50 20             	mov    %dl,0x20(%eax)
  11469f:	8b 45 08             	mov    0x8(%ebp),%eax
  1146a2:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  1146a6:	89 c2                	mov    %eax,%edx
  1146a8:	83 ca 02             	or     $0x2,%edx
  1146ab:	8b 45 08             	mov    0x8(%ebp),%eax
  1146ae:	88 50 20             	mov    %dl,0x20(%eax)
  1146b1:	8b 45 08             	mov    0x8(%ebp),%eax
  1146b4:	89 04 24             	mov    %eax,(%esp)
  1146b7:	e8 94 d7 ff ff       	call   111e50 <tcp_output>
  1146bc:	e9 da 03 00 00       	jmp    114a9b <tcp_receive+0x100b>
  1146c1:	8b 45 08             	mov    0x8(%ebp),%eax
  1146c4:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  1146c8:	89 c2                	mov    %eax,%edx
  1146ca:	83 ca 01             	or     $0x1,%edx
  1146cd:	8b 45 08             	mov    0x8(%ebp),%eax
  1146d0:	88 50 20             	mov    %dl,0x20(%eax)
  1146d3:	e9 c3 03 00 00       	jmp    114a9b <tcp_receive+0x100b>

      } else {
  /* We get here if the incoming segment is out-of-sequence. */
  tcp_ack_now(pcb);
  1146d8:	8b 45 08             	mov    0x8(%ebp),%eax
  1146db:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  1146df:	89 c2                	mov    %eax,%edx
  1146e1:	83 ca 02             	or     $0x2,%edx
  1146e4:	8b 45 08             	mov    0x8(%ebp),%eax
  1146e7:	88 50 20             	mov    %dl,0x20(%eax)
  1146ea:	8b 45 08             	mov    0x8(%ebp),%eax
  1146ed:	89 04 24             	mov    %eax,(%esp)
  1146f0:	e8 5b d7 ff ff       	call   111e50 <tcp_output>
#if TCP_QUEUE_OOSEQ
  /* We queue the segment on the ->ooseq queue. */
  if (pcb->ooseq == NULL) {
  1146f5:	8b 45 08             	mov    0x8(%ebp),%eax
  1146f8:	8b 40 78             	mov    0x78(%eax),%eax
  1146fb:	85 c0                	test   %eax,%eax
  1146fd:	75 19                	jne    114718 <tcp_receive+0xc88>
    pcb->ooseq = tcp_seg_copy(&inseg);
  1146ff:	c7 04 24 f0 98 13 00 	movl   $0x1398f0,(%esp)
  114706:	e8 85 ca ff ff       	call   111190 <tcp_seg_copy>
  11470b:	89 c2                	mov    %eax,%edx
  11470d:	8b 45 08             	mov    0x8(%ebp),%eax
  114710:	89 50 78             	mov    %edx,0x78(%eax)
  114713:	e9 83 03 00 00       	jmp    114a9b <tcp_receive+0x100b>
  } else {
    /* If the queue is not empty, we walk through the queue and
    try to find a place where the sequence number of the
    incoming segment is between the sequence numbers of the
    previous and the next segment on the ->ooseq queue. That is
    the place where we put the incoming segment. If needed, we
    trim the second edges of the previous and the incoming
    segment so that it will fit into the sequence.

    If the incoming segment has the same sequence number as a
    segment on the ->ooseq queue, we discard the segment that
    contains less data. */

    prev = NULL;
  114718:	c7 45 e0 00 00 00 00 	movl   $0x0,0xffffffe0(%ebp)
    for(next = pcb->ooseq; next != NULL; next = next->next) {
  11471f:	8b 45 08             	mov    0x8(%ebp),%eax
  114722:	8b 40 78             	mov    0x78(%eax),%eax
  114725:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
  114728:	e9 07 03 00 00       	jmp    114a34 <tcp_receive+0xfa4>
      if (seqno == next->tcphdr->seqno) {
  11472d:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  114730:	8b 40 10             	mov    0x10(%eax),%eax
  114733:	8b 50 04             	mov    0x4(%eax),%edx
  114736:	a1 0c 99 13 00       	mov    0x13990c,%eax
  11473b:	39 c2                	cmp    %eax,%edx
  11473d:	75 5b                	jne    11479a <tcp_receive+0xd0a>
        /* The sequence number of the incoming segment is the
                 same as the sequence number of the segment on
                 ->ooseq. We check the lengths to see which one to
                 discard. */
        if (inseg.len > next->len) {
  11473f:	0f b7 05 fc 98 13 00 	movzwl 0x1398fc,%eax
  114746:	8b 55 dc             	mov    0xffffffdc(%ebp),%edx
  114749:	0f b7 52 0c          	movzwl 0xc(%edx),%edx
  11474d:	66 39 d0             	cmp    %dx,%ax
  114750:	0f 86 45 03 00 00    	jbe    114a9b <tcp_receive+0x100b>
    /* The incoming segment is larger than the old
                   segment. We replace the old segment with the new
                   one. */
    cseg = tcp_seg_copy(&inseg);
  114756:	c7 04 24 f0 98 13 00 	movl   $0x1398f0,(%esp)
  11475d:	e8 2e ca ff ff       	call   111190 <tcp_seg_copy>
  114762:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
    if (cseg != NULL) {
  114765:	83 7d e4 00          	cmpl   $0x0,0xffffffe4(%ebp)
  114769:	0f 84 2c 03 00 00    	je     114a9b <tcp_receive+0x100b>
      cseg->next = next->next;
  11476f:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  114772:	8b 10                	mov    (%eax),%edx
  114774:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
  114777:	89 10                	mov    %edx,(%eax)
      if (prev != NULL) {
  114779:	83 7d e0 00          	cmpl   $0x0,0xffffffe0(%ebp)
  11477d:	74 0d                	je     11478c <tcp_receive+0xcfc>
        prev->next = cseg;
  11477f:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
  114782:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
  114785:	89 02                	mov    %eax,(%edx)
  114787:	e9 0f 03 00 00       	jmp    114a9b <tcp_receive+0x100b>
      } else {
        pcb->ooseq = cseg;
  11478c:	8b 55 08             	mov    0x8(%ebp),%edx
  11478f:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
  114792:	89 42 78             	mov    %eax,0x78(%edx)
      }
    }
    break;
  114795:	e9 01 03 00 00       	jmp    114a9b <tcp_receive+0x100b>
        } else {
    /* Either the lenghts are the same or the incoming
                   segment was smaller than the old one; in either
                   case, we ditch the incoming segment. */
    break;
        }
      } else {
        if (prev == NULL) {
  11479a:	83 7d e0 00          	cmpl   $0x0,0xffffffe0(%ebp)
  11479e:	0f 85 ab 00 00 00    	jne    11484f <tcp_receive+0xdbf>
    if (TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {
  1147a4:	a1 0c 99 13 00       	mov    0x13990c,%eax
  1147a9:	89 c2                	mov    %eax,%edx
  1147ab:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  1147ae:	8b 40 10             	mov    0x10(%eax),%eax
  1147b1:	8b 40 04             	mov    0x4(%eax),%eax
  1147b4:	89 d1                	mov    %edx,%ecx
  1147b6:	66 29 c1             	sub    %ax,%cx
  1147b9:	89 c8                	mov    %ecx,%eax
  1147bb:	66 85 c0             	test   %ax,%ax
  1147be:	0f 89 b4 01 00 00    	jns    114978 <tcp_receive+0xee8>
      /* The sequence number of the incoming segment is lower
         than the sequence number of the first segment on the
         queue. We put the incoming segment first on the
         queue. */

      if (TCP_SEQ_GT(seqno + inseg.len, next->tcphdr->seqno)) {
  1147c4:	0f b7 15 fc 98 13 00 	movzwl 0x1398fc,%edx
  1147cb:	a1 0c 99 13 00       	mov    0x13990c,%eax
  1147d0:	01 c2                	add    %eax,%edx
  1147d2:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  1147d5:	8b 40 10             	mov    0x10(%eax),%eax
  1147d8:	8b 40 04             	mov    0x4(%eax),%eax
  1147db:	89 d3                	mov    %edx,%ebx
  1147dd:	66 29 c3             	sub    %ax,%bx
  1147e0:	89 d8                	mov    %ebx,%eax
  1147e2:	66 85 c0             	test   %ax,%ax
  1147e5:	7e 39                	jle    114820 <tcp_receive+0xd90>
        /* We need to trim the incoming segment. */
        inseg.len = next->tcphdr->seqno - seqno;
  1147e7:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  1147ea:	8b 40 10             	mov    0x10(%eax),%eax
  1147ed:	8b 40 04             	mov    0x4(%eax),%eax
  1147f0:	89 c2                	mov    %eax,%edx
  1147f2:	a1 0c 99 13 00       	mov    0x13990c,%eax
  1147f7:	89 d1                	mov    %edx,%ecx
  1147f9:	66 29 c1             	sub    %ax,%cx
  1147fc:	89 c8                	mov    %ecx,%eax
  1147fe:	66 a3 fc 98 13 00    	mov    %ax,0x1398fc
        pbuf_realloc(inseg.p, inseg.len);
  114804:	0f b7 05 fc 98 13 00 	movzwl 0x1398fc,%eax
  11480b:	0f b7 c0             	movzwl %ax,%eax
  11480e:	8b 15 f4 98 13 00    	mov    0x1398f4,%edx
  114814:	89 44 24 04          	mov    %eax,0x4(%esp)
  114818:	89 14 24             	mov    %edx,(%esp)
  11481b:	e8 90 aa ff ff       	call   10f2b0 <pbuf_realloc>
      }
      cseg = tcp_seg_copy(&inseg);
  114820:	c7 04 24 f0 98 13 00 	movl   $0x1398f0,(%esp)
  114827:	e8 64 c9 ff ff       	call   111190 <tcp_seg_copy>
  11482c:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
      if (cseg != NULL) {
  11482f:	83 7d e4 00          	cmpl   $0x0,0xffffffe4(%ebp)
  114833:	0f 84 62 02 00 00    	je     114a9b <tcp_receive+0x100b>
        cseg->next = next;
  114839:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
  11483c:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  11483f:	89 02                	mov    %eax,(%edx)
        pcb->ooseq = cseg;
  114841:	8b 55 08             	mov    0x8(%ebp),%edx
  114844:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
  114847:	89 42 78             	mov    %eax,0x78(%edx)
      }
      break;
  11484a:	e9 4c 02 00 00       	jmp    114a9b <tcp_receive+0x100b>
    }
        } else if (TCP_SEQ_LT(prev->tcphdr->seqno, seqno) &&
  11484f:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  114852:	8b 40 10             	mov    0x10(%eax),%eax
  114855:	8b 40 04             	mov    0x4(%eax),%eax
  114858:	89 c2                	mov    %eax,%edx
  11485a:	a1 0c 99 13 00       	mov    0x13990c,%eax
  11485f:	89 d3                	mov    %edx,%ebx
  114861:	66 29 c3             	sub    %ax,%bx
  114864:	89 d8                	mov    %ebx,%eax
  114866:	66 85 c0             	test   %ax,%ax
  114869:	0f 89 09 01 00 00    	jns    114978 <tcp_receive+0xee8>
  11486f:	a1 0c 99 13 00       	mov    0x13990c,%eax
  114874:	89 c2                	mov    %eax,%edx
  114876:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  114879:	8b 40 10             	mov    0x10(%eax),%eax
  11487c:	8b 40 04             	mov    0x4(%eax),%eax
  11487f:	89 d1                	mov    %edx,%ecx
  114881:	66 29 c1             	sub    %ax,%cx
  114884:	89 c8                	mov    %ecx,%eax
  114886:	66 85 c0             	test   %ax,%ax
  114889:	0f 89 e9 00 00 00    	jns    114978 <tcp_receive+0xee8>
     TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {
    /* The sequence number of the incoming segment is in
                   between the sequence numbers of the previous and
                   the next segment on ->ooseq. We trim and insert the
                   incoming segment and trim the previous segment, if
                   needed. */
    if (TCP_SEQ_GT(seqno + inseg.len, next->tcphdr->seqno)) {
  11488f:	0f b7 15 fc 98 13 00 	movzwl 0x1398fc,%edx
  114896:	a1 0c 99 13 00       	mov    0x13990c,%eax
  11489b:	01 c2                	add    %eax,%edx
  11489d:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  1148a0:	8b 40 10             	mov    0x10(%eax),%eax
  1148a3:	8b 40 04             	mov    0x4(%eax),%eax
  1148a6:	89 d3                	mov    %edx,%ebx
  1148a8:	66 29 c3             	sub    %ax,%bx
  1148ab:	89 d8                	mov    %ebx,%eax
  1148ad:	66 85 c0             	test   %ax,%ax
  1148b0:	7e 39                	jle    1148eb <tcp_receive+0xe5b>
      /* We need to trim the incoming segment. */
      inseg.len = next->tcphdr->seqno - seqno;
  1148b2:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  1148b5:	8b 40 10             	mov    0x10(%eax),%eax
  1148b8:	8b 40 04             	mov    0x4(%eax),%eax
  1148bb:	89 c2                	mov    %eax,%edx
  1148bd:	a1 0c 99 13 00       	mov    0x13990c,%eax
  1148c2:	89 d1                	mov    %edx,%ecx
  1148c4:	66 29 c1             	sub    %ax,%cx
  1148c7:	89 c8                	mov    %ecx,%eax
  1148c9:	66 a3 fc 98 13 00    	mov    %ax,0x1398fc
      pbuf_realloc(inseg.p, inseg.len);
  1148cf:	0f b7 05 fc 98 13 00 	movzwl 0x1398fc,%eax
  1148d6:	0f b7 c0             	movzwl %ax,%eax
  1148d9:	8b 15 f4 98 13 00    	mov    0x1398f4,%edx
  1148df:	89 44 24 04          	mov    %eax,0x4(%esp)
  1148e3:	89 14 24             	mov    %edx,(%esp)
  1148e6:	e8 c5 a9 ff ff       	call   10f2b0 <pbuf_realloc>
    }

    cseg = tcp_seg_copy(&inseg);
  1148eb:	c7 04 24 f0 98 13 00 	movl   $0x1398f0,(%esp)
  1148f2:	e8 99 c8 ff ff       	call   111190 <tcp_seg_copy>
  1148f7:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
    if (cseg != NULL) {
  1148fa:	83 7d e4 00          	cmpl   $0x0,0xffffffe4(%ebp)
  1148fe:	0f 84 97 01 00 00    	je     114a9b <tcp_receive+0x100b>
      cseg->next = next;
  114904:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
  114907:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  11490a:	89 02                	mov    %eax,(%edx)
      prev->next = cseg;
  11490c:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
  11490f:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
  114912:	89 02                	mov    %eax,(%edx)
      if (TCP_SEQ_GT(prev->tcphdr->seqno + prev->len, seqno)) {
  114914:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  114917:	8b 40 10             	mov    0x10(%eax),%eax
  11491a:	8b 40 04             	mov    0x4(%eax),%eax
  11491d:	89 c2                	mov    %eax,%edx
  11491f:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  114922:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  114926:	01 c2                	add    %eax,%edx
  114928:	a1 0c 99 13 00       	mov    0x13990c,%eax
  11492d:	89 d3                	mov    %edx,%ebx
  11492f:	66 29 c3             	sub    %ax,%bx
  114932:	89 d8                	mov    %ebx,%eax
  114934:	66 85 c0             	test   %ax,%ax
  114937:	0f 8e 5e 01 00 00    	jle    114a9b <tcp_receive+0x100b>
        /* We need to trim the prev segment. */
        prev->len = seqno - prev->tcphdr->seqno;
  11493d:	a1 0c 99 13 00       	mov    0x13990c,%eax
  114942:	89 c2                	mov    %eax,%edx
  114944:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  114947:	8b 40 10             	mov    0x10(%eax),%eax
  11494a:	8b 40 04             	mov    0x4(%eax),%eax
  11494d:	66 29 c2             	sub    %ax,%dx
  114950:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  114953:	66 89 50 0c          	mov    %dx,0xc(%eax)
        pbuf_realloc(prev->p, prev->len);
  114957:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  11495a:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  11495e:	0f b7 d0             	movzwl %ax,%edx
  114961:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  114964:	8b 40 04             	mov    0x4(%eax),%eax
  114967:	89 54 24 04          	mov    %edx,0x4(%esp)
  11496b:	89 04 24             	mov    %eax,(%esp)
  11496e:	e8 3d a9 ff ff       	call   10f2b0 <pbuf_realloc>
      }
    }
    break;
  114973:	e9 23 01 00 00       	jmp    114a9b <tcp_receive+0x100b>
    }
        /* If the "next" segment is the last segment on the
                 ooseq queue, we add the incoming segment to the end
                 of the list. */
        if (next->next == NULL &&
  114978:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  11497b:	8b 00                	mov    (%eax),%eax
  11497d:	85 c0                	test   %eax,%eax
  11497f:	0f 85 a1 00 00 00    	jne    114a26 <tcp_receive+0xf96>
  114985:	a1 0c 99 13 00       	mov    0x13990c,%eax
  11498a:	89 c2                	mov    %eax,%edx
  11498c:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  11498f:	8b 40 10             	mov    0x10(%eax),%eax
  114992:	8b 40 04             	mov    0x4(%eax),%eax
  114995:	89 d1                	mov    %edx,%ecx
  114997:	66 29 c1             	sub    %ax,%cx
  11499a:	89 c8                	mov    %ecx,%eax
  11499c:	66 85 c0             	test   %ax,%ax
  11499f:	0f 8e 81 00 00 00    	jle    114a26 <tcp_receive+0xf96>
     TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
    next->next = tcp_seg_copy(&inseg);
  1149a5:	c7 04 24 f0 98 13 00 	movl   $0x1398f0,(%esp)
  1149ac:	e8 df c7 ff ff       	call   111190 <tcp_seg_copy>
  1149b1:	89 c2                	mov    %eax,%edx
  1149b3:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  1149b6:	89 10                	mov    %edx,(%eax)
    if (next->next != NULL) {
  1149b8:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  1149bb:	8b 00                	mov    (%eax),%eax
  1149bd:	85 c0                	test   %eax,%eax
  1149bf:	0f 84 d6 00 00 00    	je     114a9b <tcp_receive+0x100b>
      if (TCP_SEQ_GT(next->tcphdr->seqno + next->len, seqno)) {
  1149c5:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  1149c8:	8b 40 10             	mov    0x10(%eax),%eax
  1149cb:	8b 40 04             	mov    0x4(%eax),%eax
  1149ce:	89 c2                	mov    %eax,%edx
  1149d0:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  1149d3:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  1149d7:	01 c2                	add    %eax,%edx
  1149d9:	a1 0c 99 13 00       	mov    0x13990c,%eax
  1149de:	89 d3                	mov    %edx,%ebx
  1149e0:	66 29 c3             	sub    %ax,%bx
  1149e3:	89 d8                	mov    %ebx,%eax
  1149e5:	66 85 c0             	test   %ax,%ax
  1149e8:	0f 8e ad 00 00 00    	jle    114a9b <tcp_receive+0x100b>
        /* We need to trim the last segment. */
        next->len = seqno - next->tcphdr->seqno;
  1149ee:	a1 0c 99 13 00       	mov    0x13990c,%eax
  1149f3:	89 c2                	mov    %eax,%edx
  1149f5:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  1149f8:	8b 40 10             	mov    0x10(%eax),%eax
  1149fb:	8b 40 04             	mov    0x4(%eax),%eax
  1149fe:	66 29 c2             	sub    %ax,%dx
  114a01:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  114a04:	66 89 50 0c          	mov    %dx,0xc(%eax)
        pbuf_realloc(next->p, next->len);
  114a08:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  114a0b:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  114a0f:	0f b7 d0             	movzwl %ax,%edx
  114a12:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  114a15:	8b 40 04             	mov    0x4(%eax),%eax
  114a18:	89 54 24 04          	mov    %edx,0x4(%esp)
  114a1c:	89 04 24             	mov    %eax,(%esp)
  114a1f:	e8 8c a8 ff ff       	call   10f2b0 <pbuf_realloc>
      }
    }
    break;
  114a24:	eb 75                	jmp    114a9b <tcp_receive+0x100b>
        }
      }
      prev = next;
  114a26:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  114a29:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
  114a2c:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  114a2f:	8b 00                	mov    (%eax),%eax
  114a31:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
  114a34:	83 7d dc 00          	cmpl   $0x0,0xffffffdc(%ebp)
  114a38:	0f 85 ef fc ff ff    	jne    11472d <tcp_receive+0xc9d>
  114a3e:	eb 5b                	jmp    114a9b <tcp_receive+0x100b>
    }
  }
#endif /* TCP_QUEUE_OOSEQ */

      }
    }
  } else {
    /* Segments with length 0 is taken care of here. Segments that
       fall out of the window are ACKed. */
    if (TCP_SEQ_GT(pcb->rcv_nxt, seqno) ||
  114a40:	8b 45 08             	mov    0x8(%ebp),%eax
  114a43:	8b 40 24             	mov    0x24(%eax),%eax
  114a46:	89 c2                	mov    %eax,%edx
  114a48:	a1 0c 99 13 00       	mov    0x13990c,%eax
  114a4d:	89 d1                	mov    %edx,%ecx
  114a4f:	66 29 c1             	sub    %ax,%cx
  114a52:	89 c8                	mov    %ecx,%eax
  114a54:	66 85 c0             	test   %ax,%ax
  114a57:	7f 25                	jg     114a7e <tcp_receive+0xfee>
  114a59:	a1 0c 99 13 00       	mov    0x13990c,%eax
  114a5e:	89 c1                	mov    %eax,%ecx
  114a60:	8b 45 08             	mov    0x8(%ebp),%eax
  114a63:	8b 40 24             	mov    0x24(%eax),%eax
  114a66:	89 c2                	mov    %eax,%edx
  114a68:	8b 45 08             	mov    0x8(%ebp),%eax
  114a6b:	0f b7 40 28          	movzwl 0x28(%eax),%eax
  114a6f:	8d 04 02             	lea    (%edx,%eax,1),%eax
  114a72:	89 cb                	mov    %ecx,%ebx
  114a74:	66 29 c3             	sub    %ax,%bx
  114a77:	89 d8                	mov    %ebx,%eax
  114a79:	66 85 c0             	test   %ax,%ax
  114a7c:	78 1d                	js     114a9b <tcp_receive+0x100b>
       TCP_SEQ_GEQ(seqno, pcb->rcv_nxt + pcb->rcv_wnd)) {
      tcp_ack_now(pcb);
  114a7e:	8b 45 08             	mov    0x8(%ebp),%eax
  114a81:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  114a85:	89 c2                	mov    %eax,%edx
  114a87:	83 ca 02             	or     $0x2,%edx
  114a8a:	8b 45 08             	mov    0x8(%ebp),%eax
  114a8d:	88 50 20             	mov    %dl,0x20(%eax)
  114a90:	8b 45 08             	mov    0x8(%ebp),%eax
  114a93:	89 04 24             	mov    %eax,(%esp)
  114a96:	e8 b5 d3 ff ff       	call   111e50 <tcp_output>
    }
  }
}
  114a9b:	83 c4 74             	add    $0x74,%esp
  114a9e:	5b                   	pop    %ebx
  114a9f:	5d                   	pop    %ebp
  114aa0:	c3                   	ret    
  114aa1:	eb 0d                	jmp    114ab0 <tcp_parseopt>
  114aa3:	90                   	nop    
  114aa4:	90                   	nop    
  114aa5:	90                   	nop    
  114aa6:	90                   	nop    
  114aa7:	90                   	nop    
  114aa8:	90                   	nop    
  114aa9:	90                   	nop    
  114aaa:	90                   	nop    
  114aab:	90                   	nop    
  114aac:	90                   	nop    
  114aad:	90                   	nop    
  114aae:	90                   	nop    
  114aaf:	90                   	nop    

00114ab0 <tcp_parseopt>:

/*
 * tcp_parseopt:
 *
 * Parses the options contained in the incoming segment. (Code taken
 * from uIP with only small changes.)
 *
 */

static void
tcp_parseopt(struct tcp_pcb *pcb)
{
  114ab0:	55                   	push   %ebp
  114ab1:	89 e5                	mov    %esp,%ebp
  114ab3:	53                   	push   %ebx
  114ab4:	83 ec 24             	sub    $0x24,%esp
  u8_t c;
  u8_t *opts, opt;
  u16_t mss;

  opts = (u8_t *)tcphdr + TCP_HLEN;
  114ab7:	a1 04 99 13 00       	mov    0x139904,%eax
  114abc:	83 c0 14             	add    $0x14,%eax
  114abf:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
  114ac2:	a1 04 99 13 00       	mov    0x139904,%eax
  114ac7:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  114acb:	0f b7 c0             	movzwl %ax,%eax
  114ace:	89 04 24             	mov    %eax,(%esp)
  114ad1:	e8 da 97 ff ff       	call   10e2b0 <ntohs>
  114ad6:	66 c1 e8 0c          	shr    $0xc,%ax
  114ada:	66 83 f8 05          	cmp    $0x5,%ax
  114ade:	0f 86 f1 00 00 00    	jbe    114bd5 <tcp_parseopt+0x125>
    for(c = 0; c < (TCPH_HDRLEN(tcphdr) - 5) << 2 ;) {
  114ae4:	c6 45 f3 00          	movb   $0x0,0xfffffff3(%ebp)
  114ae8:	e9 bb 00 00 00       	jmp    114ba8 <tcp_parseopt+0xf8>
      opt = opts[c];
  114aed:	0f b6 45 f3          	movzbl 0xfffffff3(%ebp),%eax
  114af1:	03 45 f4             	add    0xfffffff4(%ebp),%eax
  114af4:	0f b6 00             	movzbl (%eax),%eax
  114af7:	88 45 f9             	mov    %al,0xfffffff9(%ebp)
      if (opt == 0x00) {
  114afa:	80 7d f9 00          	cmpb   $0x0,0xfffffff9(%ebp)
  114afe:	0f 84 d1 00 00 00    	je     114bd5 <tcp_parseopt+0x125>
        /* End of options. */
  break;
      } else if (opt == 0x01) {
  114b04:	80 7d f9 01          	cmpb   $0x1,0xfffffff9(%ebp)
  114b08:	75 09                	jne    114b13 <tcp_parseopt+0x63>
        ++c;
  114b0a:	80 45 f3 01          	addb   $0x1,0xfffffff3(%ebp)
  114b0e:	e9 95 00 00 00       	jmp    114ba8 <tcp_parseopt+0xf8>
        /* NOP option. */
      } else if (opt == 0x02 &&
  114b13:	80 7d f9 02          	cmpb   $0x2,0xfffffff9(%ebp)
  114b17:	75 68                	jne    114b81 <tcp_parseopt+0xd1>
  114b19:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
  114b1c:	83 c2 01             	add    $0x1,%edx
  114b1f:	0f b6 45 f3          	movzbl 0xfffffff3(%ebp),%eax
  114b23:	8d 04 02             	lea    (%edx,%eax,1),%eax
  114b26:	0f b6 00             	movzbl (%eax),%eax
  114b29:	3c 04                	cmp    $0x4,%al
  114b2b:	75 54                	jne    114b81 <tcp_parseopt+0xd1>
                opts[c + 1] == 0x04) {
        /* An MSS option with the right option length. */
        mss = (opts[c + 2] << 8) | opts[c + 3];
  114b2d:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
  114b30:	83 c2 02             	add    $0x2,%edx
  114b33:	0f b6 45 f3          	movzbl 0xfffffff3(%ebp),%eax
  114b37:	8d 04 02             	lea    (%edx,%eax,1),%eax
  114b3a:	0f b6 00             	movzbl (%eax),%eax
  114b3d:	0f b6 c0             	movzbl %al,%eax
  114b40:	c1 e0 08             	shl    $0x8,%eax
  114b43:	89 c1                	mov    %eax,%ecx
  114b45:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
  114b48:	83 c2 03             	add    $0x3,%edx
  114b4b:	0f b6 45 f3          	movzbl 0xfffffff3(%ebp),%eax
  114b4f:	8d 04 02             	lea    (%edx,%eax,1),%eax
  114b52:	0f b6 00             	movzbl (%eax),%eax
  114b55:	0f b6 c0             	movzbl %al,%eax
  114b58:	09 c8                	or     %ecx,%eax
  114b5a:	66 89 45 fa          	mov    %ax,0xfffffffa(%ebp)
        pcb->mss = mss > TCP_MSS? TCP_MSS: mss;
  114b5e:	0f b7 45 fa          	movzwl 0xfffffffa(%ebp),%eax
  114b62:	66 89 45 ea          	mov    %ax,0xffffffea(%ebp)
  114b66:	66 81 7d ea 00 02    	cmpw   $0x200,0xffffffea(%ebp)
  114b6c:	76 06                	jbe    114b74 <tcp_parseopt+0xc4>
  114b6e:	66 c7 45 ea 00 02    	movw   $0x200,0xffffffea(%ebp)
  114b74:	8b 45 08             	mov    0x8(%ebp),%eax
  114b77:	0f b7 55 ea          	movzwl 0xffffffea(%ebp),%edx
  114b7b:	66 89 50 34          	mov    %dx,0x34(%eax)

        /* And we are done processing options. */
        break;
  114b7f:	eb 54                	jmp    114bd5 <tcp_parseopt+0x125>
      } else {
  if (opts[c + 1] == 0) {
  114b81:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
  114b84:	83 c2 01             	add    $0x1,%edx
  114b87:	0f b6 45 f3          	movzbl 0xfffffff3(%ebp),%eax
  114b8b:	8d 04 02             	lea    (%edx,%eax,1),%eax
  114b8e:	0f b6 00             	movzbl (%eax),%eax
  114b91:	84 c0                	test   %al,%al
  114b93:	74 40                	je     114bd5 <tcp_parseopt+0x125>
          /* If the length field is zero, the options are malformed
             and we don't process them further. */
          break;
        }
        /* All other options have a length field, so that we easily
           can skip past them. */
        c += opts[c + 1];
  114b95:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
  114b98:	83 c2 01             	add    $0x1,%edx
  114b9b:	0f b6 45 f3          	movzbl 0xfffffff3(%ebp),%eax
  114b9f:	8d 04 02             	lea    (%edx,%eax,1),%eax
  114ba2:	0f b6 00             	movzbl (%eax),%eax
  114ba5:	00 45 f3             	add    %al,0xfffffff3(%ebp)
  114ba8:	0f b6 5d f3          	movzbl 0xfffffff3(%ebp),%ebx
  114bac:	a1 04 99 13 00       	mov    0x139904,%eax
  114bb1:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  114bb5:	0f b7 c0             	movzwl %ax,%eax
  114bb8:	89 04 24             	mov    %eax,(%esp)
  114bbb:	e8 f0 96 ff ff       	call   10e2b0 <ntohs>
  114bc0:	66 c1 e8 0c          	shr    $0xc,%ax
  114bc4:	0f b7 c0             	movzwl %ax,%eax
  114bc7:	83 e8 05             	sub    $0x5,%eax
  114bca:	c1 e0 02             	shl    $0x2,%eax
  114bcd:	39 c3                	cmp    %eax,%ebx
  114bcf:	0f 8c 18 ff ff ff    	jl     114aed <tcp_parseopt+0x3d>
      }
    }
  }
}
  114bd5:	83 c4 24             	add    $0x24,%esp
  114bd8:	5b                   	pop    %ebx
  114bd9:	5d                   	pop    %ebp
  114bda:	c3                   	ret    
  114bdb:	90                   	nop    
  114bdc:	90                   	nop    
  114bdd:	90                   	nop    
  114bde:	90                   	nop    
  114bdf:	90                   	nop    

00114be0 <udp_init>:


void
udp_init(void)
{
  114be0:	55                   	push   %ebp
  114be1:	89 e5                	mov    %esp,%ebp
  udp_pcbs = pcb_cache = NULL;
  114be3:	c7 05 24 99 13 00 00 	movl   $0x0,0x139924
  114bea:	00 00 00 
  114bed:	a1 24 99 13 00       	mov    0x139924,%eax
  114bf2:	a3 20 99 13 00       	mov    %eax,0x139920
}
  114bf7:	5d                   	pop    %ebp
  114bf8:	c3                   	ret    
  114bf9:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

00114c00 <udp_input>:

/**
 * Process an incoming UDP datagram.
 *
 * Given an incoming UDP datagram (as a chain of pbufs) this function
 * finds a corresponding UDP PCB and
 *
 * @param pbuf pbuf to be demultiplexed to a UDP PCB.
 * @param netif network interface on which the datagram was received.
 *
 */
void
udp_input(struct pbuf *p, struct netif *inp)
{
  114c00:	55                   	push   %ebp
  114c01:	89 e5                	mov    %esp,%ebp
  114c03:	56                   	push   %esi
  114c04:	53                   	push   %ebx
  114c05:	83 ec 40             	sub    $0x40,%esp
  struct udp_hdr *udphdr;
  struct udp_pcb *pcb;
  struct ip_hdr *iphdr;
  u16_t src, dest;

#if SO_REUSE
  struct udp_pcb *pcb_temp;
  int reuse = 0;
  114c08:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  int reuse_port_1 = 0;
  114c0f:	c7 45 f0 00 00 00 00 	movl   $0x0,0xfffffff0(%ebp)
  int reuse_port_2 = 0;
  114c16:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
#endif /* SO_REUSE */
  
  PERF_START;

  UDP_STATS_INC(udp.recv);
  114c1d:	0f b7 05 4c 15 14 00 	movzwl 0x14154c,%eax
  114c24:	83 c0 01             	add    $0x1,%eax
  114c27:	66 a3 4c 15 14 00    	mov    %ax,0x14154c

  iphdr = p->payload;
  114c2d:	8b 45 08             	mov    0x8(%ebp),%eax
  114c30:	8b 40 04             	mov    0x4(%eax),%eax
  114c33:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)

  if (pbuf_header(p, -((s16_t)(UDP_HLEN + IPH_HL(iphdr) * 4)))) {
  114c36:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  114c39:	0f b7 00             	movzwl (%eax),%eax
  114c3c:	0f b7 c0             	movzwl %ax,%eax
  114c3f:	89 04 24             	mov    %eax,(%esp)
  114c42:	e8 69 96 ff ff       	call   10e2b0 <ntohs>
  114c47:	66 c1 e8 08          	shr    $0x8,%ax
  114c4b:	0f b7 c0             	movzwl %ax,%eax
  114c4e:	83 e0 0f             	and    $0xf,%eax
  114c51:	c1 e0 02             	shl    $0x2,%eax
  114c54:	89 c2                	mov    %eax,%edx
  114c56:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
  114c5b:	66 29 d0             	sub    %dx,%ax
  114c5e:	98                   	cwtl   
  114c5f:	89 44 24 04          	mov    %eax,0x4(%esp)
  114c63:	8b 45 08             	mov    0x8(%ebp),%eax
  114c66:	89 04 24             	mov    %eax,(%esp)
  114c69:	e8 52 a7 ff ff       	call   10f3c0 <pbuf_header>
  114c6e:	84 c0                	test   %al,%al
  114c70:	74 30                	je     114ca2 <udp_input+0xa2>
    /* drop short packets */
    LWIP_DEBUGF(UDP_DEBUG, ("udp_input: short UDP datagram (%u bytes) discarded\n", p->tot_len));
    UDP_STATS_INC(udp.lenerr);
  114c72:	0f b7 05 54 15 14 00 	movzwl 0x141554,%eax
  114c79:	83 c0 01             	add    $0x1,%eax
  114c7c:	66 a3 54 15 14 00    	mov    %ax,0x141554
    UDP_STATS_INC(udp.drop);
  114c82:	0f b7 05 50 15 14 00 	movzwl 0x141550,%eax
  114c89:	83 c0 01             	add    $0x1,%eax
  114c8c:	66 a3 50 15 14 00    	mov    %ax,0x141550
    snmp_inc_udpinerrors();
    pbuf_free(p);
  114c92:	8b 45 08             	mov    0x8(%ebp),%eax
  114c95:	89 04 24             	mov    %eax,(%esp)
  114c98:	e8 23 a8 ff ff       	call   10f4c0 <pbuf_free>
    goto end;
  114c9d:	e9 36 04 00 00       	jmp    1150d8 <udp_input+0x4d8>
  }

  udphdr = (struct udp_hdr *)((u8_t *)p->payload - UDP_HLEN);
  114ca2:	8b 45 08             	mov    0x8(%ebp),%eax
  114ca5:	8b 40 04             	mov    0x4(%eax),%eax
  114ca8:	83 e8 08             	sub    $0x8,%eax
  114cab:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)

  LWIP_DEBUGF(UDP_DEBUG, ("udp_input: received datagram of length %u\n", p->tot_len));

  src = ntohs(udphdr->src);
  114cae:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  114cb1:	0f b7 00             	movzwl (%eax),%eax
  114cb4:	0f b7 c0             	movzwl %ax,%eax
  114cb7:	89 04 24             	mov    %eax,(%esp)
  114cba:	e8 f1 95 ff ff       	call   10e2b0 <ntohs>
  114cbf:	66 89 45 e4          	mov    %ax,0xffffffe4(%ebp)
  dest = ntohs(udphdr->dest);
  114cc3:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  114cc6:	0f b7 40 02          	movzwl 0x2(%eax),%eax
  114cca:	0f b7 c0             	movzwl %ax,%eax
  114ccd:	89 04 24             	mov    %eax,(%esp)
  114cd0:	e8 db 95 ff ff       	call   10e2b0 <ntohs>
  114cd5:	66 89 45 e6          	mov    %ax,0xffffffe6(%ebp)

  udp_debug_print(udphdr);

  /* print the UDP source and destination */
  LWIP_DEBUGF(UDP_DEBUG, ("udp (%u.%u.%u.%u, %u) <-- (%u.%u.%u.%u, %u)\n",
    ip4_addr1(&iphdr->dest), ip4_addr2(&iphdr->dest),
    ip4_addr3(&iphdr->dest), ip4_addr4(&iphdr->dest), ntohs(udphdr->dest),
    ip4_addr1(&iphdr->src), ip4_addr2(&iphdr->src),
    ip4_addr3(&iphdr->src), ip4_addr4(&iphdr->src), ntohs(udphdr->src)));

#if SO_REUSE
  pcb_temp = udp_pcbs;
  114cd9:	a1 20 99 13 00       	mov    0x139920,%eax
  114cde:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
  
 again_1:
  
  /* Iterate through the UDP pcb list for a fully matching pcb */
  for(pcb = pcb_temp; pcb != NULL; pcb = pcb->next) {
  114ce1:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  114ce4:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
  114ce7:	e9 ac 00 00 00       	jmp    114d98 <udp_input+0x198>
#else  /* SO_REUSE */ 
  /* Iterate through the UDP pcb list for a fully matching pcb */
  for(pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
#endif  /* SO_REUSE */ 
    /* print the PCB local and remote address */
    LWIP_DEBUGF(UDP_DEBUG, ("pcb (%u.%u.%u.%u, %u) --- (%u.%u.%u.%u, %u)\n",
      ip4_addr1(&pcb->local_ip), ip4_addr2(&pcb->local_ip),
      ip4_addr3(&pcb->local_ip), ip4_addr4(&pcb->local_ip), pcb->local_port,
      ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
      ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip), pcb->remote_port));

       /* PCB remote port matches UDP source port? */
    if ((pcb->remote_port == src) &&
  114cec:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  114cef:	0f b7 40 14          	movzwl 0x14(%eax),%eax
  114cf3:	66 3b 45 e4          	cmp    0xffffffe4(%ebp),%ax
  114cf7:	0f 85 92 00 00 00    	jne    114d8f <udp_input+0x18f>
  114cfd:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  114d00:	0f b7 40 12          	movzwl 0x12(%eax),%eax
  114d04:	66 3b 45 e6          	cmp    0xffffffe6(%ebp),%ax
  114d08:	0f 85 81 00 00 00    	jne    114d8f <udp_input+0x18f>
  114d0e:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  114d11:	83 c0 04             	add    $0x4,%eax
  114d14:	85 c0                	test   %eax,%eax
  114d16:	74 1a                	je     114d32 <udp_input+0x132>
  114d18:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  114d1b:	8b 40 04             	mov    0x4(%eax),%eax
  114d1e:	85 c0                	test   %eax,%eax
  114d20:	74 10                	je     114d32 <udp_input+0x132>
  114d22:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  114d25:	8b 50 04             	mov    0x4(%eax),%edx
  114d28:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  114d2b:	8b 40 0c             	mov    0xc(%eax),%eax
  114d2e:	39 c2                	cmp    %eax,%edx
  114d30:	75 5d                	jne    114d8f <udp_input+0x18f>
  114d32:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  114d35:	85 c0                	test   %eax,%eax
  114d37:	74 18                	je     114d51 <udp_input+0x151>
  114d39:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  114d3c:	8b 00                	mov    (%eax),%eax
  114d3e:	85 c0                	test   %eax,%eax
  114d40:	74 0f                	je     114d51 <udp_input+0x151>
  114d42:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  114d45:	8b 10                	mov    (%eax),%edx
  114d47:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  114d4a:	8b 40 10             	mov    0x10(%eax),%eax
  114d4d:	39 c2                	cmp    %eax,%edx
  114d4f:	75 3e                	jne    114d8f <udp_input+0x18f>
       /* PCB local port matches UDP destination port? */
       (pcb->local_port == dest) &&
       /* accepting from any remote (source) IP address? or... */
       (ip_addr_isany(&pcb->remote_ip) ||
       /* PCB remote IP address matches UDP source IP address? */
        ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src))) &&
       /* accepting on any local (netif) IP address? or... */
       (ip_addr_isany(&pcb->local_ip) ||
       /* PCB local IP address matches UDP destination IP address? */
        ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest)))) {
#if SO_REUSE
      if(pcb->so_options & SOF_REUSEPORT) {
  114d51:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  114d54:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  114d58:	0f b7 c0             	movzwl %ax,%eax
  114d5b:	25 00 02 00 00       	and    $0x200,%eax
  114d60:	85 c0                	test   %eax,%eax
  114d62:	74 29                	je     114d8d <udp_input+0x18d>
        if(reuse) {
  114d64:	83 7d ec 00          	cmpl   $0x0,0xffffffec(%ebp)
  114d68:	74 02                	je     114d6c <udp_input+0x16c>
  114d6a:	eb 07                	jmp    114d73 <udp_input+0x173>
          /* We processed one PCB already */
          LWIP_DEBUGF(UDP_DEBUG, ("udp_input: second or later PCB and SOF_REUSEPORT set.\n"));
        } else {
          /* First PCB with this address */
          LWIP_DEBUGF(UDP_DEBUG, ("udp_input: first PCB and SOF_REUSEPORT set.\n"));
          reuse = 1;
  114d6c:	c7 45 ec 01 00 00 00 	movl   $0x1,0xffffffec(%ebp)
        }
        
        reuse_port_1 = 1; 
  114d73:	c7 45 f0 01 00 00 00 	movl   $0x1,0xfffffff0(%ebp)
        p->ref++;
  114d7a:	8b 45 08             	mov    0x8(%ebp),%eax
  114d7d:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
  114d81:	8d 50 01             	lea    0x1(%eax),%edx
  114d84:	8b 45 08             	mov    0x8(%ebp),%eax
  114d87:	66 89 50 0e          	mov    %dx,0xe(%eax)
  114d8b:	eb 15                	jmp    114da2 <udp_input+0x1a2>
  114d8d:	eb 13                	jmp    114da2 <udp_input+0x1a2>
  114d8f:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  114d92:	8b 40 0c             	mov    0xc(%eax),%eax
  114d95:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
  114d98:	83 7d dc 00          	cmpl   $0x0,0xffffffdc(%ebp)
  114d9c:	0f 85 4a ff ff ff    	jne    114cec <udp_input+0xec>
        LWIP_DEBUGF(UDP_DEBUG, ("udp_input: reference counter on PBUF set to %i\n", p->ref));
      } else {
        if(reuse) {
          /* We processed one PCB already */
          LWIP_DEBUGF(UDP_DEBUG, ("udp_input: second or later PCB but SOF_REUSEPORT not set !\n"));
        }
      }
#endif /* SO_REUSE */
      break;
    }
  }
  /* no fully matching pcb found? then look for an unconnected pcb */
  if (pcb == NULL) {
  114da2:	83 7d dc 00          	cmpl   $0x0,0xffffffdc(%ebp)
  114da6:	0f 85 a1 00 00 00    	jne    114e4d <udp_input+0x24d>
    /* Iterate through the UDP PCB list for a pcb that matches
       the local address. */

#if SO_REUSE
    pcb_temp = udp_pcbs;
  114dac:	a1 20 99 13 00       	mov    0x139920,%eax
  114db1:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
    
  again_2:

    for(pcb = pcb_temp; pcb != NULL; pcb = pcb->next) {
  114db4:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  114db7:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
  114dba:	e9 84 00 00 00       	jmp    114e43 <udp_input+0x243>
#else  /* SO_REUSE */ 
    for(pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
#endif  /* SO_REUSE */ 
      LWIP_DEBUGF(UDP_DEBUG, ("pcb (%u.%u.%u.%u, %u) --- (%u.%u.%u.%u, %u)\n",
        ip4_addr1(&pcb->local_ip), ip4_addr2(&pcb->local_ip),
        ip4_addr3(&pcb->local_ip), ip4_addr4(&pcb->local_ip), pcb->local_port,
        ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
        ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip), pcb->remote_port));
      /* unconnected? */
      if (((pcb->flags & UDP_FLAGS_CONNECTED) == 0) &&
  114dbf:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  114dc2:	0f b6 40 10          	movzbl 0x10(%eax),%eax
  114dc6:	0f b6 c0             	movzbl %al,%eax
  114dc9:	83 e0 04             	and    $0x4,%eax
  114dcc:	85 c0                	test   %eax,%eax
  114dce:	75 6a                	jne    114e3a <udp_input+0x23a>
  114dd0:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  114dd3:	0f b7 40 12          	movzwl 0x12(%eax),%eax
  114dd7:	66 3b 45 e6          	cmp    0xffffffe6(%ebp),%ax
  114ddb:	75 5d                	jne    114e3a <udp_input+0x23a>
  114ddd:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  114de0:	85 c0                	test   %eax,%eax
  114de2:	74 18                	je     114dfc <udp_input+0x1fc>
  114de4:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  114de7:	8b 00                	mov    (%eax),%eax
  114de9:	85 c0                	test   %eax,%eax
  114deb:	74 0f                	je     114dfc <udp_input+0x1fc>
  114ded:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  114df0:	8b 10                	mov    (%eax),%edx
  114df2:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  114df5:	8b 40 10             	mov    0x10(%eax),%eax
  114df8:	39 c2                	cmp    %eax,%edx
  114dfa:	75 3e                	jne    114e3a <udp_input+0x23a>
         /* destination port matches? */
        (pcb->local_port == dest) &&
        /* not bound to a specific (local) interface address? or... */
        (ip_addr_isany(&pcb->local_ip) ||
        /* ...matching interface address? */
        ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest)))) {
#if SO_REUSE
        if(pcb->so_options & SOF_REUSEPORT) {
  114dfc:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  114dff:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  114e03:	0f b7 c0             	movzwl %ax,%eax
  114e06:	25 00 02 00 00       	and    $0x200,%eax
  114e0b:	85 c0                	test   %eax,%eax
  114e0d:	74 29                	je     114e38 <udp_input+0x238>
          if(reuse) {
  114e0f:	83 7d ec 00          	cmpl   $0x0,0xffffffec(%ebp)
  114e13:	74 02                	je     114e17 <udp_input+0x217>
  114e15:	eb 07                	jmp    114e1e <udp_input+0x21e>
            /* We processed one PCB already */
            LWIP_DEBUGF(UDP_DEBUG, ("udp_input: second or later PCB and SOF_REUSEPORT set.\n"));
          } else {
            /* First PCB with this address */
            LWIP_DEBUGF(UDP_DEBUG, ("udp_input: first PCB and SOF_REUSEPORT set.\n"));
            reuse = 1;
  114e17:	c7 45 ec 01 00 00 00 	movl   $0x1,0xffffffec(%ebp)
          }
          
          reuse_port_2 = 1; 
  114e1e:	c7 45 f4 01 00 00 00 	movl   $0x1,0xfffffff4(%ebp)
          p->ref++;
  114e25:	8b 45 08             	mov    0x8(%ebp),%eax
  114e28:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
  114e2c:	8d 50 01             	lea    0x1(%eax),%edx
  114e2f:	8b 45 08             	mov    0x8(%ebp),%eax
  114e32:	66 89 50 0e          	mov    %dx,0xe(%eax)
  114e36:	eb 15                	jmp    114e4d <udp_input+0x24d>
  114e38:	eb 13                	jmp    114e4d <udp_input+0x24d>
  114e3a:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  114e3d:	8b 40 0c             	mov    0xc(%eax),%eax
  114e40:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
  114e43:	83 7d dc 00          	cmpl   $0x0,0xffffffdc(%ebp)
  114e47:	0f 85 72 ff ff ff    	jne    114dbf <udp_input+0x1bf>
          LWIP_DEBUGF(UDP_DEBUG, ("udp_input: reference counter on PBUF set to %i\n", p->ref));
        } else {
          if(reuse) {
            /* We processed one PCB already */
            LWIP_DEBUGF(UDP_DEBUG, ("udp_input: second or later PCB but SOF_REUSEPORT not set !\n"));
          }
        }
#endif /* SO_REUSE */
        break;
      }
    }
  }

  /* Check checksum if this is a match or if it was directed at us. */
  if (pcb != NULL  || ip_addr_cmp(&inp->ip_addr, &iphdr->dest))
  114e4d:	83 7d dc 00          	cmpl   $0x0,0xffffffdc(%ebp)
  114e51:	75 14                	jne    114e67 <udp_input+0x267>
  114e53:	8b 45 0c             	mov    0xc(%ebp),%eax
  114e56:	8b 50 04             	mov    0x4(%eax),%edx
  114e59:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  114e5c:	8b 40 10             	mov    0x10(%eax),%eax
  114e5f:	39 c2                	cmp    %eax,%edx
  114e61:	0f 85 66 02 00 00    	jne    1150cd <udp_input+0x4cd>
    {
    LWIP_DEBUGF(UDP_DEBUG | DBG_TRACE, ("udp_input: calculating checksum\n"));
    pbuf_header(p, UDP_HLEN);
  114e67:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
  114e6e:	00 
  114e6f:	8b 45 08             	mov    0x8(%ebp),%eax
  114e72:	89 04 24             	mov    %eax,(%esp)
  114e75:	e8 46 a5 ff ff       	call   10f3c0 <pbuf_header>
#ifdef IPv6
    if (iphdr->nexthdr == IP_PROTO_UDPLITE) {
#else
    if (IPH_PROTO(iphdr) == IP_PROTO_UDPLITE) {
  114e7a:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  114e7d:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  114e81:	0f b7 c0             	movzwl %ax,%eax
  114e84:	89 04 24             	mov    %eax,(%esp)
  114e87:	e8 24 94 ff ff       	call   10e2b0 <ntohs>
  114e8c:	0f b7 c0             	movzwl %ax,%eax
  114e8f:	25 ff 00 00 00       	and    $0xff,%eax
  114e94:	3d aa 00 00 00       	cmp    $0xaa,%eax
  114e99:	75 79                	jne    114f14 <udp_input+0x314>
#endif /* IPv4 */
      /* Do the UDP Lite checksum */
      if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
  114e9b:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  114e9e:	0f b7 40 04          	movzwl 0x4(%eax),%eax
  114ea2:	0f b7 c0             	movzwl %ax,%eax
  114ea5:	89 04 24             	mov    %eax,(%esp)
  114ea8:	e8 03 94 ff ff       	call   10e2b0 <ntohs>
  114ead:	0f b7 c0             	movzwl %ax,%eax
  114eb0:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
  114eb3:	83 c2 10             	add    $0x10,%edx
  114eb6:	8b 4d e0             	mov    0xffffffe0(%ebp),%ecx
  114eb9:	83 c1 0c             	add    $0xc,%ecx
  114ebc:	89 44 24 10          	mov    %eax,0x10(%esp)
  114ec0:	c7 44 24 0c aa 00 00 	movl   $0xaa,0xc(%esp)
  114ec7:	00 
  114ec8:	89 54 24 08          	mov    %edx,0x8(%esp)
  114ecc:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  114ed0:	8b 45 08             	mov    0x8(%ebp),%eax
  114ed3:	89 04 24             	mov    %eax,(%esp)
  114ed6:	e8 65 8d ff ff       	call   10dc40 <inet_chksum_pseudo>
  114edb:	66 85 c0             	test   %ax,%ax
  114ede:	0f 84 a6 00 00 00    	je     114f8a <udp_input+0x38a>
         (struct ip_addr *)&(iphdr->dest),
         IP_PROTO_UDPLITE, ntohs(udphdr->len)) != 0) {
  LWIP_DEBUGF(UDP_DEBUG | 2, ("udp_input: UDP Lite datagram discarded due to failing checksum\n"));
  UDP_STATS_INC(udp.chkerr);
  114ee4:	0f b7 05 52 15 14 00 	movzwl 0x141552,%eax
  114eeb:	83 c0 01             	add    $0x1,%eax
  114eee:	66 a3 52 15 14 00    	mov    %ax,0x141552
  UDP_STATS_INC(udp.drop);
  114ef4:	0f b7 05 50 15 14 00 	movzwl 0x141550,%eax
  114efb:	83 c0 01             	add    $0x1,%eax
  114efe:	66 a3 50 15 14 00    	mov    %ax,0x141550
  snmp_inc_udpinerrors();
  pbuf_free(p);
  114f04:	8b 45 08             	mov    0x8(%ebp),%eax
  114f07:	89 04 24             	mov    %eax,(%esp)
  114f0a:	e8 b1 a5 ff ff       	call   10f4c0 <pbuf_free>
  goto end;
  114f0f:	e9 c4 01 00 00       	jmp    1150d8 <udp_input+0x4d8>
      }
    } else {
      if (udphdr->chksum != 0) {
  114f14:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  114f17:	0f b7 40 06          	movzwl 0x6(%eax),%eax
  114f1b:	66 85 c0             	test   %ax,%ax
  114f1e:	74 6a                	je     114f8a <udp_input+0x38a>
  if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
  114f20:	8b 45 08             	mov    0x8(%ebp),%eax
  114f23:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  114f27:	0f b7 c0             	movzwl %ax,%eax
  114f2a:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
  114f2d:	83 c2 10             	add    $0x10,%edx
  114f30:	8b 4d e0             	mov    0xffffffe0(%ebp),%ecx
  114f33:	83 c1 0c             	add    $0xc,%ecx
  114f36:	89 44 24 10          	mov    %eax,0x10(%esp)
  114f3a:	c7 44 24 0c 11 00 00 	movl   $0x11,0xc(%esp)
  114f41:	00 
  114f42:	89 54 24 08          	mov    %edx,0x8(%esp)
  114f46:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  114f4a:	8b 45 08             	mov    0x8(%ebp),%eax
  114f4d:	89 04 24             	mov    %eax,(%esp)
  114f50:	e8 eb 8c ff ff       	call   10dc40 <inet_chksum_pseudo>
  114f55:	66 85 c0             	test   %ax,%ax
  114f58:	74 30                	je     114f8a <udp_input+0x38a>
       (struct ip_addr *)&(iphdr->dest),
        IP_PROTO_UDP, p->tot_len) != 0) {
    LWIP_DEBUGF(UDP_DEBUG | 2, ("udp_input: UDP datagram discarded due to failing checksum\n"));

    UDP_STATS_INC(udp.chkerr);
  114f5a:	0f b7 05 52 15 14 00 	movzwl 0x141552,%eax
  114f61:	83 c0 01             	add    $0x1,%eax
  114f64:	66 a3 52 15 14 00    	mov    %ax,0x141552
    UDP_STATS_INC(udp.drop);
  114f6a:	0f b7 05 50 15 14 00 	movzwl 0x141550,%eax
  114f71:	83 c0 01             	add    $0x1,%eax
  114f74:	66 a3 50 15 14 00    	mov    %ax,0x141550
    snmp_inc_udpinerrors();
    pbuf_free(p);
  114f7a:	8b 45 08             	mov    0x8(%ebp),%eax
  114f7d:	89 04 24             	mov    %eax,(%esp)
  114f80:	e8 3b a5 ff ff       	call   10f4c0 <pbuf_free>
    goto end;
  114f85:	e9 4e 01 00 00       	jmp    1150d8 <udp_input+0x4d8>
  }
      }
    }
    pbuf_header(p, -UDP_HLEN);
  114f8a:	c7 44 24 04 f8 ff ff 	movl   $0xfffffff8,0x4(%esp)
  114f91:	ff 
  114f92:	8b 45 08             	mov    0x8(%ebp),%eax
  114f95:	89 04 24             	mov    %eax,(%esp)
  114f98:	e8 23 a4 ff ff       	call   10f3c0 <pbuf_header>
    if (pcb != NULL) {
  114f9d:	83 7d dc 00          	cmpl   $0x0,0xffffffdc(%ebp)
  114fa1:	74 76                	je     115019 <udp_input+0x419>
      snmp_inc_udpindatagrams();
      pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src), src);
  114fa3:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  114fa6:	8b 70 18             	mov    0x18(%eax),%esi
  114fa9:	0f b7 55 e4          	movzwl 0xffffffe4(%ebp),%edx
  114fad:	8b 4d e0             	mov    0xffffffe0(%ebp),%ecx
  114fb0:	83 c1 0c             	add    $0xc,%ecx
  114fb3:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  114fb6:	8b 58 1c             	mov    0x1c(%eax),%ebx
  114fb9:	89 54 24 10          	mov    %edx,0x10(%esp)
  114fbd:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
  114fc1:	8b 45 08             	mov    0x8(%ebp),%eax
  114fc4:	89 44 24 08          	mov    %eax,0x8(%esp)
  114fc8:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  114fcb:	89 44 24 04          	mov    %eax,0x4(%esp)
  114fcf:	89 1c 24             	mov    %ebx,(%esp)
  114fd2:	ff d6                	call   *%esi
#if SO_REUSE
      /* First socket should receive now */
      if(reuse_port_1 || reuse_port_2) {
  114fd4:	83 7d f0 00          	cmpl   $0x0,0xfffffff0(%ebp)
  114fd8:	75 0a                	jne    114fe4 <udp_input+0x3e4>
  114fda:	83 7d f4 00          	cmpl   $0x0,0xfffffff4(%ebp)
  114fde:	0f 84 f4 00 00 00    	je     1150d8 <udp_input+0x4d8>
        /* We want to search on next socket after receiving */
        pcb_temp = pcb->next;
  114fe4:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  114fe7:	8b 40 0c             	mov    0xc(%eax),%eax
  114fea:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
        
        if(reuse_port_1) {
  114fed:	83 7d f0 00          	cmpl   $0x0,0xfffffff0(%ebp)
  114ff1:	74 13                	je     115006 <udp_input+0x406>
          /* We are searching connected sockets */
          reuse_port_1 = 0;
  114ff3:	c7 45 f0 00 00 00 00 	movl   $0x0,0xfffffff0(%ebp)
          reuse_port_2 = 0;
  114ffa:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
          goto again_1;
  115001:	e9 db fc ff ff       	jmp    114ce1 <udp_input+0xe1>
        } else {
          /* We are searching unconnected sockets */
          reuse_port_1 = 0;
  115006:	c7 45 f0 00 00 00 00 	movl   $0x0,0xfffffff0(%ebp)
          reuse_port_2 = 0;
  11500d:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
          goto again_2;
  115014:	e9 9b fd ff ff       	jmp    114db4 <udp_input+0x1b4>
        }
      }
#endif /* SO_REUSE */ 
    } else {
#if SO_REUSE
      if(reuse) {
  115019:	83 7d ec 00          	cmpl   $0x0,0xffffffec(%ebp)
  11501d:	74 10                	je     11502f <udp_input+0x42f>
        LWIP_DEBUGF(UDP_DEBUG, ("udp_input: freeing PBUF with reference counter set to %i\n", p->ref));
        pbuf_free(p);
  11501f:	8b 45 08             	mov    0x8(%ebp),%eax
  115022:	89 04 24             	mov    %eax,(%esp)
  115025:	e8 96 a4 ff ff       	call   10f4c0 <pbuf_free>
        goto end;
  11502a:	e9 a9 00 00 00       	jmp    1150d8 <udp_input+0x4d8>
      }
#endif /* SO_REUSE */
      LWIP_DEBUGF(UDP_DEBUG | DBG_TRACE, ("udp_input: not for us.\n"));

      /* No match was found, send ICMP destination port unreachable unless
      destination address was broadcast/multicast. */

      if (!ip_addr_isbroadcast(&iphdr->dest, &inp->netmask) &&
  11502f:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  115032:	8b 50 10             	mov    0x10(%eax),%edx
  115035:	8b 45 0c             	mov    0xc(%ebp),%eax
  115038:	8b 40 08             	mov    0x8(%eax),%eax
  11503b:	f7 d0                	not    %eax
  11503d:	21 c2                	and    %eax,%edx
  11503f:	8b 45 0c             	mov    0xc(%ebp),%eax
  115042:	8b 40 08             	mov    0x8(%eax),%eax
  115045:	f7 d0                	not    %eax
  115047:	39 c2                	cmp    %eax,%edx
  115049:	74 55                	je     1150a0 <udp_input+0x4a0>
  11504b:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  11504e:	8b 40 10             	mov    0x10(%eax),%eax
  115051:	83 f8 ff             	cmp    $0xffffffff,%eax
  115054:	74 4a                	je     1150a0 <udp_input+0x4a0>
  115056:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  115059:	8b 40 10             	mov    0x10(%eax),%eax
  11505c:	85 c0                	test   %eax,%eax
  11505e:	74 40                	je     1150a0 <udp_input+0x4a0>
  115060:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  115063:	8b 58 10             	mov    0x10(%eax),%ebx
  115066:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  11506d:	e8 9e 92 ff ff       	call   10e310 <ntohl>
  115072:	21 c3                	and    %eax,%ebx
  115074:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  11507b:	e8 90 92 ff ff       	call   10e310 <ntohl>
  115080:	39 c3                	cmp    %eax,%ebx
  115082:	74 1c                	je     1150a0 <udp_input+0x4a0>
   !ip_addr_ismulticast(&iphdr->dest)) {

  /* adjust pbuf pointer */
  p->payload = iphdr;
  115084:	8b 45 08             	mov    0x8(%ebp),%eax
  115087:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
  11508a:	89 50 04             	mov    %edx,0x4(%eax)
  icmp_dest_unreach(p, ICMP_DUR_PORT);
  11508d:	c7 44 24 04 03 00 00 	movl   $0x3,0x4(%esp)
  115094:	00 
  115095:	8b 45 08             	mov    0x8(%ebp),%eax
  115098:	89 04 24             	mov    %eax,(%esp)
  11509b:	e8 20 79 ff ff       	call   10c9c0 <icmp_dest_unreach>
      }
      UDP_STATS_INC(udp.proterr);
  1150a0:	0f b7 05 5a 15 14 00 	movzwl 0x14155a,%eax
  1150a7:	83 c0 01             	add    $0x1,%eax
  1150aa:	66 a3 5a 15 14 00    	mov    %ax,0x14155a
      UDP_STATS_INC(udp.drop);
  1150b0:	0f b7 05 50 15 14 00 	movzwl 0x141550,%eax
  1150b7:	83 c0 01             	add    $0x1,%eax
  1150ba:	66 a3 50 15 14 00    	mov    %ax,0x141550
    snmp_inc_udpnoports();
      pbuf_free(p);
  1150c0:	8b 45 08             	mov    0x8(%ebp),%eax
  1150c3:	89 04 24             	mov    %eax,(%esp)
  1150c6:	e8 f5 a3 ff ff       	call   10f4c0 <pbuf_free>
  1150cb:	eb 0b                	jmp    1150d8 <udp_input+0x4d8>
    }
  } else {
    pbuf_free(p);
  1150cd:	8b 45 08             	mov    0x8(%ebp),%eax
  1150d0:	89 04 24             	mov    %eax,(%esp)
  1150d3:	e8 e8 a3 ff ff       	call   10f4c0 <pbuf_free>
  }
  end:

  PERF_STOP("udp_input");
}
  1150d8:	83 c4 40             	add    $0x40,%esp
  1150db:	5b                   	pop    %ebx
  1150dc:	5e                   	pop    %esi
  1150dd:	5d                   	pop    %ebp
  1150de:	c3                   	ret    
  1150df:	90                   	nop    

001150e0 <udp_sendto>:

/**
 * Send data to a specified address using UDP.
 *
 * @param pcb UDP PCB used to send the data.
 * @param pbuf chain of pbuf's to be sent.
 * @param dst_ip Destination IP address.
 * @param dst_port Destination UDP port.
 *
 * If the PCB already has a remote address association, it will
 * be restored after the data is sent.
 * 
 * @return lwIP error code.
 * - ERR_OK. Successful. No error occured.
 * - ERR_MEM. Out of memory.
 * - ERR_RTE. Could not find route to destination address.
 *
 * @see udp_disconnect() udp_send()
 */
err_t
udp_sendto(struct udp_pcb *pcb, struct pbuf *p,
  struct ip_addr *dst_ip, u16_t dst_port)
{
  1150e0:	55                   	push   %ebp
  1150e1:	89 e5                	mov    %esp,%ebp
  1150e3:	83 ec 28             	sub    $0x28,%esp
  1150e6:	8b 45 14             	mov    0x14(%ebp),%eax
  1150e9:	66 89 45 ec          	mov    %ax,0xffffffec(%ebp)
  err_t err;
  struct ip_addr pcb_remote_ip;
  u16_t pcb_remote_port;
  /* remember remote peer address of PCB */
  pcb_remote_ip.addr = pcb->remote_ip.addr;
  1150ed:	8b 45 08             	mov    0x8(%ebp),%eax
  1150f0:	8b 40 04             	mov    0x4(%eax),%eax
  1150f3:	89 45 f9             	mov    %eax,0xfffffff9(%ebp)
  pcb_remote_port = pcb->remote_port;
  1150f6:	8b 45 08             	mov    0x8(%ebp),%eax
  1150f9:	0f b7 40 14          	movzwl 0x14(%eax),%eax
  1150fd:	66 89 45 fe          	mov    %ax,0xfffffffe(%ebp)
  /* copy packet destination address to PCB remote peer address */
  pcb->remote_ip.addr = dst_ip->addr;
  115101:	8b 45 10             	mov    0x10(%ebp),%eax
  115104:	8b 10                	mov    (%eax),%edx
  115106:	8b 45 08             	mov    0x8(%ebp),%eax
  115109:	89 50 04             	mov    %edx,0x4(%eax)
  pcb->remote_port = dst_port;
  11510c:	8b 55 08             	mov    0x8(%ebp),%edx
  11510f:	0f b7 45 ec          	movzwl 0xffffffec(%ebp),%eax
  115113:	66 89 42 14          	mov    %ax,0x14(%edx)
  /* send to the packet destination address */
  err = udp_send(pcb, p);
  115117:	8b 45 0c             	mov    0xc(%ebp),%eax
  11511a:	89 44 24 04          	mov    %eax,0x4(%esp)
  11511e:	8b 45 08             	mov    0x8(%ebp),%eax
  115121:	89 04 24             	mov    %eax,(%esp)
  115124:	e8 27 00 00 00       	call   115150 <udp_send>
  115129:	88 45 fd             	mov    %al,0xfffffffd(%ebp)
  /* reset PCB remote peer address */
  pcb->remote_ip.addr = pcb_remote_ip.addr;
  11512c:	8b 55 f9             	mov    0xfffffff9(%ebp),%edx
  11512f:	8b 45 08             	mov    0x8(%ebp),%eax
  115132:	89 50 04             	mov    %edx,0x4(%eax)
  pcb->remote_port = pcb_remote_port;
  115135:	8b 55 08             	mov    0x8(%ebp),%edx
  115138:	0f b7 45 fe          	movzwl 0xfffffffe(%ebp),%eax
  11513c:	66 89 42 14          	mov    %ax,0x14(%edx)
  return err;
  115140:	0f be 45 fd          	movsbl 0xfffffffd(%ebp),%eax
}
  115144:	c9                   	leave  
  115145:	c3                   	ret    
  115146:	8d 76 00             	lea    0x0(%esi),%esi
  115149:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00115150 <udp_send>:

/**
 * Send data using UDP.
 *
 * @param pcb UDP PCB used to send the data.
 * @param pbuf chain of pbuf's to be sent.
 *
 * @return lwIP error code.
 * - ERR_OK. Successful. No error occured.
 * - ERR_MEM. Out of memory.
 * - ERR_RTE. Could not find route to destination address.
 *
 * @see udp_disconnect() udp_sendto()
 */
err_t
udp_send(struct udp_pcb *pcb, struct pbuf *p)
{
  115150:	55                   	push   %ebp
  115151:	89 e5                	mov    %esp,%ebp
  115153:	53                   	push   %ebx
  115154:	83 ec 44             	sub    $0x44,%esp
  struct udp_hdr *udphdr;
  struct netif *netif;
  struct ip_addr *src_ip;
  err_t err;
  struct pbuf *q; /* q will be sent down the stack */

  LWIP_DEBUGF(UDP_DEBUG | DBG_TRACE | 3, ("udp_send\n"));

  /* if the PCB is not yet bound to a port, bind it here */
  if (pcb->local_port == 0) {
  115157:	8b 45 08             	mov    0x8(%ebp),%eax
  11515a:	0f b7 40 12          	movzwl 0x12(%eax),%eax
  11515e:	66 85 c0             	test   %ax,%ax
  115161:	75 35                	jne    115198 <udp_send+0x48>
    LWIP_DEBUGF(UDP_DEBUG | DBG_TRACE | 2, ("udp_send: not yet bound to a port, binding now\n"));
    err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
  115163:	8b 45 08             	mov    0x8(%ebp),%eax
  115166:	0f b7 40 12          	movzwl 0x12(%eax),%eax
  11516a:	0f b7 c0             	movzwl %ax,%eax
  11516d:	8b 55 08             	mov    0x8(%ebp),%edx
  115170:	89 44 24 08          	mov    %eax,0x8(%esp)
  115174:	89 54 24 04          	mov    %edx,0x4(%esp)
  115178:	8b 45 08             	mov    0x8(%ebp),%eax
  11517b:	89 04 24             	mov    %eax,(%esp)
  11517e:	e8 ed 02 00 00       	call   115470 <udp_bind>
  115183:	88 45 f7             	mov    %al,0xfffffff7(%ebp)
    if (err != ERR_OK) {
  115186:	80 7d f7 00          	cmpb   $0x0,0xfffffff7(%ebp)
  11518a:	74 0c                	je     115198 <udp_send+0x48>
      LWIP_DEBUGF(UDP_DEBUG | DBG_TRACE | 2, ("udp_send: forced port bind failed\n"));
      return err;
  11518c:	0f be 45 f7          	movsbl 0xfffffff7(%ebp),%eax
  115190:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
  115193:	e9 c3 02 00 00       	jmp    11545b <udp_send+0x30b>
    }
  }

  /* not enough space to add an UDP header to first pbuf in given p chain? */
  if (pbuf_header(p, UDP_HLEN)) {
  115198:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
  11519f:	00 
  1151a0:	8b 45 0c             	mov    0xc(%ebp),%eax
  1151a3:	89 04 24             	mov    %eax,(%esp)
  1151a6:	e8 15 a2 ff ff       	call   10f3c0 <pbuf_header>
  1151ab:	84 c0                	test   %al,%al
  1151ad:	74 45                	je     1151f4 <udp_send+0xa4>
    /* allocate header in a seperate new pbuf */
    q = pbuf_alloc(PBUF_IP, UDP_HLEN, PBUF_RAM);
  1151af:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  1151b6:	00 
  1151b7:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
  1151be:	00 
  1151bf:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  1151c6:	e8 15 9e ff ff       	call   10efe0 <pbuf_alloc>
  1151cb:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
  1151ce:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  1151d2:	75 0c                	jne    1151e0 <udp_send+0x90>
      LWIP_DEBUGF(UDP_DEBUG | DBG_TRACE | 2, ("udp_send: could not allocate header\n"));
      return ERR_MEM;
  1151d4:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,0xffffffd8(%ebp)
  1151db:	e9 7b 02 00 00       	jmp    11545b <udp_send+0x30b>
    }
    /* chain header q in front of given pbuf p */
    pbuf_chain(q, p);
  1151e0:	8b 45 0c             	mov    0xc(%ebp),%eax
  1151e3:	89 44 24 04          	mov    %eax,0x4(%esp)
  1151e7:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1151ea:	89 04 24             	mov    %eax,(%esp)
  1151ed:	e8 ce a4 ff ff       	call   10f6c0 <pbuf_chain>
  1151f2:	eb 06                	jmp    1151fa <udp_send+0xaa>
    /* { first pbuf q points to header pbuf } */
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
  /* adding a header within p succeeded */
  } else {
    /* first pbuf q equals given pbuf */
    q = p;
  1151f4:	8b 45 0c             	mov    0xc(%ebp),%eax
  1151f7:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: added header in given pbuf %p\n", (void *)p));
  }
  /* { q now represents the packet to be sent } */
  udphdr = q->payload;
  1151fa:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1151fd:	8b 40 04             	mov    0x4(%eax),%eax
  115200:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
  udphdr->src = htons(pcb->local_port);
  115203:	8b 45 08             	mov    0x8(%ebp),%eax
  115206:	0f b7 40 12          	movzwl 0x12(%eax),%eax
  11520a:	0f b7 c0             	movzwl %ax,%eax
  11520d:	89 04 24             	mov    %eax,(%esp)
  115210:	e8 6b 90 ff ff       	call   10e280 <htons>
  115215:	89 c2                	mov    %eax,%edx
  115217:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  11521a:	66 89 10             	mov    %dx,(%eax)
  udphdr->dest = htons(pcb->remote_port);
  11521d:	8b 45 08             	mov    0x8(%ebp),%eax
  115220:	0f b7 40 14          	movzwl 0x14(%eax),%eax
  115224:	0f b7 c0             	movzwl %ax,%eax
  115227:	89 04 24             	mov    %eax,(%esp)
  11522a:	e8 51 90 ff ff       	call   10e280 <htons>
  11522f:	89 c2                	mov    %eax,%edx
  115231:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  115234:	66 89 50 02          	mov    %dx,0x2(%eax)
  /* in UDP, 0 checksum means 'no checksum' */
  udphdr->chksum = 0x0000; 
  115238:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  11523b:	66 c7 40 06 00 00    	movw   $0x0,0x6(%eax)

  /* find the outgoing network interface for this packet */
  if ((netif = ip_route(&(pcb->remote_ip))) == NULL) {
  115241:	8b 45 08             	mov    0x8(%ebp),%eax
  115244:	83 c0 04             	add    $0x4,%eax
  115247:	89 04 24             	mov    %eax,(%esp)
  11524a:	e8 b1 78 ff ff       	call   10cb00 <ip_route>
  11524f:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  115252:	83 7d ec 00          	cmpl   $0x0,0xffffffec(%ebp)
  115256:	75 1c                	jne    115274 <udp_send+0x124>
    LWIP_DEBUGF(UDP_DEBUG | 1, ("udp_send: No route to 0x%lx\n", pcb->remote_ip.addr));
    UDP_STATS_INC(udp.rterr);
  115258:	0f b7 05 58 15 14 00 	movzwl 0x141558,%eax
  11525f:	83 c0 01             	add    $0x1,%eax
  115262:	66 a3 58 15 14 00    	mov    %ax,0x141558
    return ERR_RTE;
  115268:	c7 45 d8 f7 ff ff ff 	movl   $0xfffffff7,0xffffffd8(%ebp)
  11526f:	e9 e7 01 00 00       	jmp    11545b <udp_send+0x30b>
  }
  /* PCB local address is IP_ANY_ADDR? */
  if (ip_addr_isany(&pcb->local_ip)) {
  115274:	8b 45 08             	mov    0x8(%ebp),%eax
  115277:	85 c0                	test   %eax,%eax
  115279:	74 09                	je     115284 <udp_send+0x134>
  11527b:	8b 45 08             	mov    0x8(%ebp),%eax
  11527e:	8b 00                	mov    (%eax),%eax
  115280:	85 c0                	test   %eax,%eax
  115282:	75 0b                	jne    11528f <udp_send+0x13f>
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
  115284:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  115287:	83 c0 04             	add    $0x4,%eax
  11528a:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
  11528d:	eb 06                	jmp    115295 <udp_send+0x145>
  } else {
    /* use UDP PCB local IP address as source address */
    src_ip = &(pcb->local_ip);
  11528f:	8b 45 08             	mov    0x8(%ebp),%eax
  115292:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
  }

  LWIP_DEBUGF(UDP_DEBUG, ("udp_send: sending datagram of length %u\n", q->tot_len));

  /* UDP Lite protocol? */
  if (pcb->flags & UDP_FLAGS_UDPLITE) {
  115295:	8b 45 08             	mov    0x8(%ebp),%eax
  115298:	0f b6 40 10          	movzbl 0x10(%eax),%eax
  11529c:	0f b6 c0             	movzbl %al,%eax
  11529f:	83 e0 02             	and    $0x2,%eax
  1152a2:	85 c0                	test   %eax,%eax
  1152a4:	0f 84 ba 00 00 00    	je     115364 <udp_send+0x214>
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP LITE packet length %u\n", q->tot_len));
    /* set UDP message length in UDP header */
    udphdr->len = htons(pcb->chksum_len);
  1152aa:	8b 45 08             	mov    0x8(%ebp),%eax
  1152ad:	0f b7 40 16          	movzwl 0x16(%eax),%eax
  1152b1:	0f b7 c0             	movzwl %ax,%eax
  1152b4:	89 04 24             	mov    %eax,(%esp)
  1152b7:	e8 c4 8f ff ff       	call   10e280 <htons>
  1152bc:	89 c2                	mov    %eax,%edx
  1152be:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  1152c1:	66 89 50 04          	mov    %dx,0x4(%eax)
    /* calculate checksum */
    udphdr->chksum = inet_chksum_pseudo(q, src_ip, &(pcb->remote_ip),
  1152c5:	8b 45 08             	mov    0x8(%ebp),%eax
  1152c8:	0f b7 40 16          	movzwl 0x16(%eax),%eax
  1152cc:	0f b7 c0             	movzwl %ax,%eax
  1152cf:	8b 55 08             	mov    0x8(%ebp),%edx
  1152d2:	83 c2 04             	add    $0x4,%edx
  1152d5:	89 44 24 10          	mov    %eax,0x10(%esp)
  1152d9:	c7 44 24 0c 11 00 00 	movl   $0x11,0xc(%esp)
  1152e0:	00 
  1152e1:	89 54 24 08          	mov    %edx,0x8(%esp)
  1152e5:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  1152e8:	89 44 24 04          	mov    %eax,0x4(%esp)
  1152ec:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1152ef:	89 04 24             	mov    %eax,(%esp)
  1152f2:	e8 49 89 ff ff       	call   10dc40 <inet_chksum_pseudo>
  1152f7:	89 c2                	mov    %eax,%edx
  1152f9:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  1152fc:	66 89 50 06          	mov    %dx,0x6(%eax)
          IP_PROTO_UDP, pcb->chksum_len);
    /* chksum zero must become 0xffff, as zero means 'no checksum' */
    if (udphdr->chksum == 0x0000) udphdr->chksum = 0xffff;
  115300:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  115303:	0f b7 40 06          	movzwl 0x6(%eax),%eax
  115307:	66 85 c0             	test   %ax,%ax
  11530a:	75 09                	jne    115315 <udp_send+0x1c5>
  11530c:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  11530f:	66 c7 40 06 ff ff    	movw   $0xffff,0x6(%eax)
    /* output to IP */
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: ip_output_if (,,,,IP_PROTO_UDPLITE,)\n"));
    err = ip_output_if (q, src_ip, &pcb->remote_ip, pcb->ttl, pcb->tos, IP_PROTO_UDPLITE, netif);    
  115315:	8b 45 08             	mov    0x8(%ebp),%eax
  115318:	0f b6 40 0a          	movzbl 0xa(%eax),%eax
  11531c:	0f b6 d0             	movzbl %al,%edx
  11531f:	8b 45 08             	mov    0x8(%ebp),%eax
  115322:	0f b6 40 0b          	movzbl 0xb(%eax),%eax
  115326:	0f b6 c8             	movzbl %al,%ecx
  115329:	8b 5d 08             	mov    0x8(%ebp),%ebx
  11532c:	83 c3 04             	add    $0x4,%ebx
  11532f:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  115332:	89 44 24 18          	mov    %eax,0x18(%esp)
  115336:	c7 44 24 14 aa 00 00 	movl   $0xaa,0x14(%esp)
  11533d:	00 
  11533e:	89 54 24 10          	mov    %edx,0x10(%esp)
  115342:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
  115346:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  11534a:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  11534d:	89 44 24 04          	mov    %eax,0x4(%esp)
  115351:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  115354:	89 04 24             	mov    %eax,(%esp)
  115357:	e8 14 7c ff ff       	call   10cf70 <ip_output_if>
  11535c:	88 45 f7             	mov    %al,0xfffffff7(%ebp)
  11535f:	e9 c6 00 00 00       	jmp    11542a <udp_send+0x2da>
  /* UDP */
  } else {
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP packet length %u\n", q->tot_len));
    udphdr->len = htons(q->tot_len);
  115364:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  115367:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  11536b:	0f b7 c0             	movzwl %ax,%eax
  11536e:	89 04 24             	mov    %eax,(%esp)
  115371:	e8 0a 8f ff ff       	call   10e280 <htons>
  115376:	89 c2                	mov    %eax,%edx
  115378:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  11537b:	66 89 50 04          	mov    %dx,0x4(%eax)
    /* calculate checksum */
    if ((pcb->flags & UDP_FLAGS_NOCHKSUM) == 0) {
  11537f:	8b 45 08             	mov    0x8(%ebp),%eax
  115382:	0f b6 40 10          	movzbl 0x10(%eax),%eax
  115386:	0f b6 c0             	movzbl %al,%eax
  115389:	83 e0 01             	and    $0x1,%eax
  11538c:	85 c0                	test   %eax,%eax
  11538e:	75 50                	jne    1153e0 <udp_send+0x290>
      udphdr->chksum = inet_chksum_pseudo(q, src_ip, &pcb->remote_ip, IP_PROTO_UDP, q->tot_len);
  115390:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  115393:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  115397:	0f b7 c0             	movzwl %ax,%eax
  11539a:	8b 55 08             	mov    0x8(%ebp),%edx
  11539d:	83 c2 04             	add    $0x4,%edx
  1153a0:	89 44 24 10          	mov    %eax,0x10(%esp)
  1153a4:	c7 44 24 0c 11 00 00 	movl   $0x11,0xc(%esp)
  1153ab:	00 
  1153ac:	89 54 24 08          	mov    %edx,0x8(%esp)
  1153b0:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  1153b3:	89 44 24 04          	mov    %eax,0x4(%esp)
  1153b7:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1153ba:	89 04 24             	mov    %eax,(%esp)
  1153bd:	e8 7e 88 ff ff       	call   10dc40 <inet_chksum_pseudo>
  1153c2:	89 c2                	mov    %eax,%edx
  1153c4:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  1153c7:	66 89 50 06          	mov    %dx,0x6(%eax)
      /* chksum zero must become 0xffff, as zero means 'no checksum' */
      if (udphdr->chksum == 0x0000) udphdr->chksum = 0xffff;
  1153cb:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  1153ce:	0f b7 40 06          	movzwl 0x6(%eax),%eax
  1153d2:	66 85 c0             	test   %ax,%ax
  1153d5:	75 09                	jne    1153e0 <udp_send+0x290>
  1153d7:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  1153da:	66 c7 40 06 ff ff    	movw   $0xffff,0x6(%eax)
    }
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP checksum 0x%04x\n", udphdr->chksum));
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: ip_output_if (,,,,IP_PROTO_UDP,)\n"));
    /* output to IP */
    err = ip_output_if(q, src_ip, &pcb->remote_ip, pcb->ttl, pcb->tos, IP_PROTO_UDP, netif);    
  1153e0:	8b 45 08             	mov    0x8(%ebp),%eax
  1153e3:	0f b6 40 0a          	movzbl 0xa(%eax),%eax
  1153e7:	0f b6 d0             	movzbl %al,%edx
  1153ea:	8b 45 08             	mov    0x8(%ebp),%eax
  1153ed:	0f b6 40 0b          	movzbl 0xb(%eax),%eax
  1153f1:	0f b6 c8             	movzbl %al,%ecx
  1153f4:	8b 5d 08             	mov    0x8(%ebp),%ebx
  1153f7:	83 c3 04             	add    $0x4,%ebx
  1153fa:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  1153fd:	89 44 24 18          	mov    %eax,0x18(%esp)
  115401:	c7 44 24 14 11 00 00 	movl   $0x11,0x14(%esp)
  115408:	00 
  115409:	89 54 24 10          	mov    %edx,0x10(%esp)
  11540d:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
  115411:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  115415:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  115418:	89 44 24 04          	mov    %eax,0x4(%esp)
  11541c:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  11541f:	89 04 24             	mov    %eax,(%esp)
  115422:	e8 49 7b ff ff       	call   10cf70 <ip_output_if>
  115427:	88 45 f7             	mov    %al,0xfffffff7(%ebp)
  }
  /* TODO: must this be increased even if error occured? */
  snmp_inc_udpoutdatagrams();

  /* did we chain a seperate header pbuf earlier? */
  if (q != p) {
  11542a:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  11542d:	3b 45 0c             	cmp    0xc(%ebp),%eax
  115430:	74 12                	je     115444 <udp_send+0x2f4>
    /* free the header pbuf */
    pbuf_free(q); q = NULL;
  115432:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  115435:	89 04 24             	mov    %eax,(%esp)
  115438:	e8 83 a0 ff ff       	call   10f4c0 <pbuf_free>
  11543d:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)
    /* { p is still referenced by the caller, and will live on } */
  }

  UDP_STATS_INC(udp.xmit);
  115444:	0f b7 05 48 15 14 00 	movzwl 0x141548,%eax
  11544b:	83 c0 01             	add    $0x1,%eax
  11544e:	66 a3 48 15 14 00    	mov    %ax,0x141548
  return err;
  115454:	0f be 45 f7          	movsbl 0xfffffff7(%ebp),%eax
  115458:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
  11545b:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
}
  11545e:	83 c4 44             	add    $0x44,%esp
  115461:	5b                   	pop    %ebx
  115462:	5d                   	pop    %ebp
  115463:	c3                   	ret    
  115464:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  11546a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

00115470 <udp_bind>:

/**
 * Bind an UDP PCB.
 *
 * @param pcb UDP PCB to be bound with a local address ipaddr and port.
 * @param ipaddr local IP address to bind with. Use IP_ADDR_ANY to
 * bind to all local interfaces.
 * @param port local UDP port to bind with.
 *
 * @return lwIP error code.
 * - ERR_OK. Successful. No error occured.
 * - ERR_USE. The specified ipaddr and port are already bound to by
 * another UDP PCB.
 *
 * @see udp_disconnect()
 */
err_t
udp_bind(struct udp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  115470:	55                   	push   %ebp
  115471:	89 e5                	mov    %esp,%ebp
  115473:	83 ec 20             	sub    $0x20,%esp
  115476:	8b 45 10             	mov    0x10(%ebp),%eax
  115479:	66 89 45 ec          	mov    %ax,0xffffffec(%ebp)
  struct udp_pcb *ipcb;
  u8_t rebind;
#if SO_REUSE
  int reuse_port_all_set = 1;
  11547d:	c7 45 fc 01 00 00 00 	movl   $0x1,0xfffffffc(%ebp)
#endif /* SO_REUSE */
  LWIP_DEBUGF(UDP_DEBUG | DBG_TRACE | 3, ("udp_bind(ipaddr = "));
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | DBG_TRACE | 3, (", port = %u)\n", port));

  rebind = 0;
  115484:	c6 45 fb 00          	movb   $0x0,0xfffffffb(%ebp)
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  115488:	a1 20 99 13 00       	mov    0x139920,%eax
  11548d:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  115490:	e9 f7 00 00 00       	jmp    11558c <udp_bind+0x11c>
    /* is this UDP PCB already on active list? */
    if (pcb == ipcb) {
  115495:	8b 45 08             	mov    0x8(%ebp),%eax
  115498:	3b 45 f4             	cmp    0xfffffff4(%ebp),%eax
  11549b:	75 09                	jne    1154a6 <udp_bind+0x36>
      /* pcb may occur at most once in active list */
      LWIP_ASSERT("rebind == 0", rebind == 0);
      /* pcb already in list, just rebind */
      rebind = 1;
  11549d:	c6 45 fb 01          	movb   $0x1,0xfffffffb(%ebp)
  1154a1:	e9 dd 00 00 00       	jmp    115583 <udp_bind+0x113>
    }

#if SO_REUSE == 0
/* this code does not allow upper layer to share a UDP port for
   listening to broadcast or multicast traffic (See SO_REUSE_ADDR and
   SO_REUSE_PORT under *BSD). TODO: See where it fits instead, OR
   combine with implementation of UDP PCB flags. Leon Woestenberg. */
#ifdef LWIP_UDP_TODO
    /* port matches that of PCB in list? */
    else if ((ipcb->local_port == port) &&
       /* IP address matches, or one is IP_ADDR_ANY? */
       (ip_addr_isany(&(ipcb->local_ip)) ||
       ip_addr_isany(ipaddr) ||
       ip_addr_cmp(&(ipcb->local_ip), ipaddr))) {
      /* other PCB already binds to this local IP and port */
      LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: local port %u already bound by another pcb\n", port));
      return ERR_USE;
    }
#endif

#else /* SO_REUSE */
      /* Search through list of PCB's. 
         
      If there is a PCB bound to specified port and IP_ADDR_ANY another PCB can be bound to the interface IP
      or to the loopback address on the same port if SOF_REUSEADDR is set. Any combination of PCB's bound to 
      the same local port, but to one address out of {IP_ADDR_ANY, 127.0.0.1, interface IP} at a time is valid.
      But no two PCB's bound to same local port and same local address is valid.
      
      If SOF_REUSEPORT is set several PCB's can be bound to same local port and same local address also. But then 
      all PCB's must have the SOF_REUSEPORT option set.
      
      When the two options aren't set and specified port is already bound, ERR_USE is returned saying that 
      address is already in use. */
    else if (ipcb->local_port == port) {
  1154a6:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  1154a9:	0f b7 40 12          	movzwl 0x12(%eax),%eax
  1154ad:	66 3b 45 ec          	cmp    0xffffffec(%ebp),%ax
  1154b1:	0f 85 cc 00 00 00    	jne    115583 <udp_bind+0x113>
      if(ip_addr_cmp(&(ipcb->local_ip), ipaddr)) {
  1154b7:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  1154ba:	8b 10                	mov    (%eax),%edx
  1154bc:	8b 45 0c             	mov    0xc(%ebp),%eax
  1154bf:	8b 00                	mov    (%eax),%eax
  1154c1:	39 c2                	cmp    %eax,%edx
  1154c3:	75 50                	jne    115515 <udp_bind+0xa5>
        if(pcb->so_options & SOF_REUSEPORT) {
  1154c5:	8b 45 08             	mov    0x8(%ebp),%eax
  1154c8:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  1154cc:	0f b7 c0             	movzwl %ax,%eax
  1154cf:	25 00 02 00 00       	and    $0x200,%eax
  1154d4:	85 c0                	test   %eax,%eax
  1154d6:	74 31                	je     115509 <udp_bind+0x99>
          LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: in UDP PCB's SO_REUSEPORT set and same address.\n"));
          reuse_port_all_set = (reuse_port_all_set && (ipcb->so_options & SOF_REUSEPORT));
  1154d8:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  1154dc:	74 1c                	je     1154fa <udp_bind+0x8a>
  1154de:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  1154e1:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  1154e5:	0f b7 c0             	movzwl %ax,%eax
  1154e8:	25 00 02 00 00       	and    $0x200,%eax
  1154ed:	85 c0                	test   %eax,%eax
  1154ef:	74 09                	je     1154fa <udp_bind+0x8a>
  1154f1:	c7 45 e0 01 00 00 00 	movl   $0x1,0xffffffe0(%ebp)
  1154f8:	eb 07                	jmp    115501 <udp_bind+0x91>
  1154fa:	c7 45 e0 00 00 00 00 	movl   $0x0,0xffffffe0(%ebp)
  115501:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  115504:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  115507:	eb 7a                	jmp    115583 <udp_bind+0x113>
        }
        else {
          LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: in UDP PCB's SO_REUSEPORT not set and same address.\n"));
          return ERR_USE;
  115509:	c7 45 e4 f6 ff ff ff 	movl   $0xfffffff6,0xffffffe4(%ebp)
  115510:	e9 36 01 00 00       	jmp    11564b <udp_bind+0x1db>
        }
      }
      else if((ip_addr_isany(ipaddr) && !ip_addr_isany(&(ipcb->local_ip))) ||
  115515:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  115519:	74 09                	je     115524 <udp_bind+0xb4>
  11551b:	8b 45 0c             	mov    0xc(%ebp),%eax
  11551e:	8b 00                	mov    (%eax),%eax
  115520:	85 c0                	test   %eax,%eax
  115522:	75 10                	jne    115534 <udp_bind+0xc4>
  115524:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  115527:	85 c0                	test   %eax,%eax
  115529:	74 09                	je     115534 <udp_bind+0xc4>
  11552b:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  11552e:	8b 00                	mov    (%eax),%eax
  115530:	85 c0                	test   %eax,%eax
  115532:	75 1f                	jne    115553 <udp_bind+0xe3>
  115534:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  115538:	74 49                	je     115583 <udp_bind+0x113>
  11553a:	8b 45 0c             	mov    0xc(%ebp),%eax
  11553d:	8b 00                	mov    (%eax),%eax
  11553f:	85 c0                	test   %eax,%eax
  115541:	74 40                	je     115583 <udp_bind+0x113>
  115543:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  115546:	85 c0                	test   %eax,%eax
  115548:	74 09                	je     115553 <udp_bind+0xe3>
  11554a:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  11554d:	8b 00                	mov    (%eax),%eax
  11554f:	85 c0                	test   %eax,%eax
  115551:	75 30                	jne    115583 <udp_bind+0x113>
              (!ip_addr_isany(ipaddr) && ip_addr_isany(&(ipcb->local_ip)))) {
        if(!(pcb->so_options & SOF_REUSEADDR) && !(pcb->so_options & SOF_REUSEPORT)) {
  115553:	8b 45 08             	mov    0x8(%ebp),%eax
  115556:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  11555a:	0f b7 c0             	movzwl %ax,%eax
  11555d:	83 e0 04             	and    $0x4,%eax
  115560:	85 c0                	test   %eax,%eax
  115562:	75 1f                	jne    115583 <udp_bind+0x113>
  115564:	8b 45 08             	mov    0x8(%ebp),%eax
  115567:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  11556b:	0f b7 c0             	movzwl %ax,%eax
  11556e:	25 00 02 00 00       	and    $0x200,%eax
  115573:	85 c0                	test   %eax,%eax
  115575:	75 0c                	jne    115583 <udp_bind+0x113>
          LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: in UDP PCB's SO_REUSEPORT or SO_REUSEADDR not set and not the same address.\n"));
          return ERR_USE;
  115577:	c7 45 e4 f6 ff ff ff 	movl   $0xfffffff6,0xffffffe4(%ebp)
  11557e:	e9 c8 00 00 00       	jmp    11564b <udp_bind+0x1db>
  115583:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  115586:	8b 40 0c             	mov    0xc(%eax),%eax
  115589:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  11558c:	83 7d f4 00          	cmpl   $0x0,0xfffffff4(%ebp)
  115590:	0f 85 ff fe ff ff    	jne    115495 <udp_bind+0x25>
        }           
      }
    }
#endif /* SO_REUSE */

  }

#if SO_REUSE
  /* If SOF_REUSEPORT isn't set in all PCB's bound to specified port and local address specified then 
     {IP, port} can't be reused. */
  if(!reuse_port_all_set) {
  115596:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  11559a:	75 0c                	jne    1155a8 <udp_bind+0x138>
    LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: not all sockets have SO_REUSEPORT set.\n"));
    return ERR_USE;
  11559c:	c7 45 e4 f6 ff ff ff 	movl   $0xfffffff6,0xffffffe4(%ebp)
  1155a3:	e9 a3 00 00 00       	jmp    11564b <udp_bind+0x1db>
  }
#endif /* SO_REUSE */

  ip_addr_set(&pcb->local_ip, ipaddr);
  1155a8:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  1155ac:	74 0a                	je     1155b8 <udp_bind+0x148>
  1155ae:	8b 45 0c             	mov    0xc(%ebp),%eax
  1155b1:	8b 00                	mov    (%eax),%eax
  1155b3:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
  1155b6:	eb 07                	jmp    1155bf <udp_bind+0x14f>
  1155b8:	c7 45 e8 00 00 00 00 	movl   $0x0,0xffffffe8(%ebp)
  1155bf:	8b 45 08             	mov    0x8(%ebp),%eax
  1155c2:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
  1155c5:	89 10                	mov    %edx,(%eax)
  /* no port specified? */
  if (port == 0) {
  1155c7:	66 83 7d ec 00       	cmpw   $0x0,0xffffffec(%ebp)
  1155cc:	75 52                	jne    115620 <udp_bind+0x1b0>
#ifndef UDP_LOCAL_PORT_RANGE_START
#define UDP_LOCAL_PORT_RANGE_START 4096
#define UDP_LOCAL_PORT_RANGE_END   0x7fff
#endif
    port = UDP_LOCAL_PORT_RANGE_START;
  1155ce:	66 c7 45 ec 00 10    	movw   $0x1000,0xffffffec(%ebp)
    ipcb = udp_pcbs;
  1155d4:	a1 20 99 13 00       	mov    0x139920,%eax
  1155d9:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
    while ((ipcb != NULL) && (port != UDP_LOCAL_PORT_RANGE_END)) {
  1155dc:	eb 25                	jmp    115603 <udp_bind+0x193>
      if (ipcb->local_port == port) {
  1155de:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  1155e1:	0f b7 40 12          	movzwl 0x12(%eax),%eax
  1155e5:	66 3b 45 ec          	cmp    0xffffffec(%ebp),%ax
  1155e9:	75 0f                	jne    1155fa <udp_bind+0x18a>
        port++;
  1155eb:	66 83 45 ec 01       	addw   $0x1,0xffffffec(%ebp)
        ipcb = udp_pcbs;
  1155f0:	a1 20 99 13 00       	mov    0x139920,%eax
  1155f5:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  1155f8:	eb 09                	jmp    115603 <udp_bind+0x193>
      } else
        ipcb = ipcb->next;
  1155fa:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  1155fd:	8b 40 0c             	mov    0xc(%eax),%eax
  115600:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  115603:	83 7d f4 00          	cmpl   $0x0,0xfffffff4(%ebp)
  115607:	74 08                	je     115611 <udp_bind+0x1a1>
  115609:	66 81 7d ec ff 7f    	cmpw   $0x7fff,0xffffffec(%ebp)
  11560f:	75 cd                	jne    1155de <udp_bind+0x16e>
    }
    if (ipcb != NULL) {
  115611:	83 7d f4 00          	cmpl   $0x0,0xfffffff4(%ebp)
  115615:	74 09                	je     115620 <udp_bind+0x1b0>
      /* no more ports available in local range */
      LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: out of free UDP ports\n"));
      return ERR_USE;
  115617:	c7 45 e4 f6 ff ff ff 	movl   $0xfffffff6,0xffffffe4(%ebp)
  11561e:	eb 2b                	jmp    11564b <udp_bind+0x1db>
    }
  }
  pcb->local_port = port;
  115620:	8b 55 08             	mov    0x8(%ebp),%edx
  115623:	0f b7 45 ec          	movzwl 0xffffffec(%ebp),%eax
  115627:	66 89 42 12          	mov    %ax,0x12(%edx)
  /* pcb not active yet? */
  if (rebind == 0) {
  11562b:	80 7d fb 00          	cmpb   $0x0,0xfffffffb(%ebp)
  11562f:	75 13                	jne    115644 <udp_bind+0x1d4>
    /* place the PCB on the active list if not already there */
    pcb->next = udp_pcbs;
  115631:	a1 20 99 13 00       	mov    0x139920,%eax
  115636:	8b 55 08             	mov    0x8(%ebp),%edx
  115639:	89 42 0c             	mov    %eax,0xc(%edx)
    udp_pcbs = pcb;
  11563c:	8b 45 08             	mov    0x8(%ebp),%eax
  11563f:	a3 20 99 13 00       	mov    %eax,0x139920
  }
  LWIP_DEBUGF(UDP_DEBUG | DBG_TRACE | DBG_STATE, ("udp_bind: bound to %u.%u.%u.%u, port %u\n",
   (unsigned int)(ntohl(pcb->local_ip.addr) >> 24 & 0xff),
   (unsigned int)(ntohl(pcb->local_ip.addr) >> 16 & 0xff),
   (unsigned int)(ntohl(pcb->local_ip.addr) >> 8 & 0xff),
   (unsigned int)(ntohl(pcb->local_ip.addr) & 0xff), pcb->local_port));
  return ERR_OK;
  115644:	c7 45 e4 00 00 00 00 	movl   $0x0,0xffffffe4(%ebp)
  11564b:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
}
  11564e:	c9                   	leave  
  11564f:	c3                   	ret    

00115650 <udp_connect>:
/**
 * Connect an UDP PCB.
 *
 * This will associate the UDP PCB with the remote address.
 *
 * @param pcb UDP PCB to be connected with remote address ipaddr and port.
 * @param ipaddr remote IP address to connect with.
 * @param port remote UDP port to connect with.
 *
 * @return lwIP error code
 *
 * @see udp_disconnect()
 */
err_t
udp_connect(struct udp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  115650:	55                   	push   %ebp
  115651:	89 e5                	mov    %esp,%ebp
  115653:	83 ec 28             	sub    $0x28,%esp
  115656:	8b 45 10             	mov    0x10(%ebp),%eax
  115659:	66 89 45 ec          	mov    %ax,0xffffffec(%ebp)
  struct udp_pcb *ipcb;

  if (pcb->local_port == 0) {
  11565d:	8b 45 08             	mov    0x8(%ebp),%eax
  115660:	0f b7 40 12          	movzwl 0x12(%eax),%eax
  115664:	66 85 c0             	test   %ax,%ax
  115667:	75 35                	jne    11569e <udp_connect+0x4e>
    err_t err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
  115669:	8b 45 08             	mov    0x8(%ebp),%eax
  11566c:	0f b7 40 12          	movzwl 0x12(%eax),%eax
  115670:	0f b7 c0             	movzwl %ax,%eax
  115673:	8b 55 08             	mov    0x8(%ebp),%edx
  115676:	89 44 24 08          	mov    %eax,0x8(%esp)
  11567a:	89 54 24 04          	mov    %edx,0x4(%esp)
  11567e:	8b 45 08             	mov    0x8(%ebp),%eax
  115681:	89 04 24             	mov    %eax,(%esp)
  115684:	e8 e7 fd ff ff       	call   115470 <udp_bind>
  115689:	88 45 ff             	mov    %al,0xffffffff(%ebp)
    if (err != ERR_OK)
  11568c:	80 7d ff 00          	cmpb   $0x0,0xffffffff(%ebp)
  115690:	74 0c                	je     11569e <udp_connect+0x4e>
      return err;
  115692:	0f be 45 ff          	movsbl 0xffffffff(%ebp),%eax
  115696:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
  115699:	e9 81 00 00 00       	jmp    11571f <udp_connect+0xcf>
  }

  ip_addr_set(&pcb->remote_ip, ipaddr);
  11569e:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  1156a2:	74 0a                	je     1156ae <udp_connect+0x5e>
  1156a4:	8b 45 0c             	mov    0xc(%ebp),%eax
  1156a7:	8b 00                	mov    (%eax),%eax
  1156a9:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
  1156ac:	eb 07                	jmp    1156b5 <udp_connect+0x65>
  1156ae:	c7 45 e8 00 00 00 00 	movl   $0x0,0xffffffe8(%ebp)
  1156b5:	8b 45 08             	mov    0x8(%ebp),%eax
  1156b8:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
  1156bb:	89 50 04             	mov    %edx,0x4(%eax)
  pcb->remote_port = port;
  1156be:	8b 55 08             	mov    0x8(%ebp),%edx
  1156c1:	0f b7 45 ec          	movzwl 0xffffffec(%ebp),%eax
  1156c5:	66 89 42 14          	mov    %ax,0x14(%edx)
  pcb->flags |= UDP_FLAGS_CONNECTED;
  1156c9:	8b 45 08             	mov    0x8(%ebp),%eax
  1156cc:	0f b6 40 10          	movzbl 0x10(%eax),%eax
  1156d0:	89 c2                	mov    %eax,%edx
  1156d2:	83 ca 04             	or     $0x4,%edx
  1156d5:	8b 45 08             	mov    0x8(%ebp),%eax
  1156d8:	88 50 10             	mov    %dl,0x10(%eax)
/** TODO: this functionality belongs in upper layers */
#ifdef LWIP_UDP_TODO
  /* Nail down local IP for netconn_addr()/getsockname() */
  if (ip_addr_isany(&pcb->local_ip) && !ip_addr_isany(&pcb->remote_ip)) {
    struct netif *netif;

    if ((netif = ip_route(&(pcb->remote_ip))) == NULL) {
      LWIP_DEBUGF(UDP_DEBUG, ("udp_connect: No route to 0x%lx\n", pcb->remote_ip.addr));
        UDP_STATS_INC(udp.rterr);
      return ERR_RTE;
    }
    /** TODO: this will bind the udp pcb locally, to the interface which
        is used to route output packets to the remote address. However, we
        might want to accept incoming packets on any interface! */
    pcb->local_ip = netif->ip_addr;
  } else if (ip_addr_isany(&pcb->remote_ip)) {
    pcb->local_ip.addr = 0;
  }
#endif
  LWIP_DEBUGF(UDP_DEBUG | DBG_TRACE | DBG_STATE, ("udp_connect: connected to %u.%u.%u.%u, port %u\n",
   (unsigned int)(ntohl(pcb->remote_ip.addr) >> 24 & 0xff),
   (unsigned int)(ntohl(pcb->remote_ip.addr) >> 16 & 0xff),
   (unsigned int)(ntohl(pcb->remote_ip.addr) >> 8 & 0xff),
   (unsigned int)(ntohl(pcb->remote_ip.addr) & 0xff), pcb->remote_port));

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for(ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  1156db:	a1 20 99 13 00       	mov    0x139920,%eax
  1156e0:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  1156e3:	eb 1a                	jmp    1156ff <udp_connect+0xaf>
    if (pcb == ipcb) {
  1156e5:	8b 45 08             	mov    0x8(%ebp),%eax
  1156e8:	3b 45 f8             	cmp    0xfffffff8(%ebp),%eax
  1156eb:	75 09                	jne    1156f6 <udp_connect+0xa6>
      /* already on the list, just return */
      return ERR_OK;
  1156ed:	c7 45 e4 00 00 00 00 	movl   $0x0,0xffffffe4(%ebp)
  1156f4:	eb 29                	jmp    11571f <udp_connect+0xcf>
  1156f6:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1156f9:	8b 40 0c             	mov    0xc(%eax),%eax
  1156fc:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  1156ff:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  115703:	75 e0                	jne    1156e5 <udp_connect+0x95>
    }
  }
  /* PCB not yet on the list, add PCB now */
  pcb->next = udp_pcbs;
  115705:	a1 20 99 13 00       	mov    0x139920,%eax
  11570a:	8b 55 08             	mov    0x8(%ebp),%edx
  11570d:	89 42 0c             	mov    %eax,0xc(%edx)
  udp_pcbs = pcb;
  115710:	8b 45 08             	mov    0x8(%ebp),%eax
  115713:	a3 20 99 13 00       	mov    %eax,0x139920
  return ERR_OK;
  115718:	c7 45 e4 00 00 00 00 	movl   $0x0,0xffffffe4(%ebp)
  11571f:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
}
  115722:	c9                   	leave  
  115723:	c3                   	ret    
  115724:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  11572a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

00115730 <udp_disconnect>:

void
udp_disconnect(struct udp_pcb *pcb)
{
  115730:	55                   	push   %ebp
  115731:	89 e5                	mov    %esp,%ebp
  /* reset remote address association */
  ip_addr_set(&pcb->remote_ip, IP_ADDR_ANY);
  115733:	b8 bf ad 11 00       	mov    $0x11adbf,%eax
  115738:	8b 10                	mov    (%eax),%edx
  11573a:	8b 45 08             	mov    0x8(%ebp),%eax
  11573d:	89 50 04             	mov    %edx,0x4(%eax)
  pcb->remote_port = 0;
  115740:	8b 45 08             	mov    0x8(%ebp),%eax
  115743:	66 c7 40 14 00 00    	movw   $0x0,0x14(%eax)
  /* mark PCB as unconnected */
  pcb->flags &= ~UDP_FLAGS_CONNECTED;
  115749:	8b 45 08             	mov    0x8(%ebp),%eax
  11574c:	0f b6 40 10          	movzbl 0x10(%eax),%eax
  115750:	89 c2                	mov    %eax,%edx
  115752:	83 e2 fb             	and    $0xfffffffb,%edx
  115755:	8b 45 08             	mov    0x8(%ebp),%eax
  115758:	88 50 10             	mov    %dl,0x10(%eax)
}
  11575b:	5d                   	pop    %ebp
  11575c:	c3                   	ret    
  11575d:	8d 76 00             	lea    0x0(%esi),%esi

00115760 <udp_recv>:

void
udp_recv(struct udp_pcb *pcb,
   void (* recv)(void *arg, struct udp_pcb *upcb, struct pbuf *p,
           struct ip_addr *addr, u16_t port),
   void *recv_arg)
{
  115760:	55                   	push   %ebp
  115761:	89 e5                	mov    %esp,%ebp
  /* remember recv() callback and user data */
  pcb->recv = recv;
  115763:	8b 55 08             	mov    0x8(%ebp),%edx
  115766:	8b 45 0c             	mov    0xc(%ebp),%eax
  115769:	89 42 18             	mov    %eax,0x18(%edx)
  pcb->recv_arg = recv_arg;
  11576c:	8b 55 08             	mov    0x8(%ebp),%edx
  11576f:	8b 45 10             	mov    0x10(%ebp),%eax
  115772:	89 42 1c             	mov    %eax,0x1c(%edx)
}
  115775:	5d                   	pop    %ebp
  115776:	c3                   	ret    
  115777:	89 f6                	mov    %esi,%esi
  115779:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00115780 <udp_remove>:
/**
 * Remove an UDP PCB.
 *
 * @param pcb UDP PCB to be removed. The PCB is removed from the list of
 * UDP PCB's and the data structure is freed from memory.
 *
 * @see udp_new()
 */
void
udp_remove(struct udp_pcb *pcb)
{
  115780:	55                   	push   %ebp
  115781:	89 e5                	mov    %esp,%ebp
  115783:	83 ec 18             	sub    $0x18,%esp
  struct udp_pcb *pcb2;
  /* pcb to be removed is first in list? */
  if (udp_pcbs == pcb) {
  115786:	a1 20 99 13 00       	mov    0x139920,%eax
  11578b:	3b 45 08             	cmp    0x8(%ebp),%eax
  11578e:	75 0f                	jne    11579f <udp_remove+0x1f>
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
  115790:	a1 20 99 13 00       	mov    0x139920,%eax
  115795:	8b 40 0c             	mov    0xc(%eax),%eax
  115798:	a3 20 99 13 00       	mov    %eax,0x139920
  11579d:	eb 3a                	jmp    1157d9 <udp_remove+0x59>
  /* pcb not 1st in list */
  } else for(pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  11579f:	a1 20 99 13 00       	mov    0x139920,%eax
  1157a4:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  1157a7:	eb 2a                	jmp    1157d3 <udp_remove+0x53>
    /* find pcb in udp_pcbs list */
    if (pcb2->next != NULL && pcb2->next == pcb) {
  1157a9:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1157ac:	8b 40 0c             	mov    0xc(%eax),%eax
  1157af:	85 c0                	test   %eax,%eax
  1157b1:	74 17                	je     1157ca <udp_remove+0x4a>
  1157b3:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1157b6:	8b 40 0c             	mov    0xc(%eax),%eax
  1157b9:	3b 45 08             	cmp    0x8(%ebp),%eax
  1157bc:	75 0c                	jne    1157ca <udp_remove+0x4a>
      /* remove pcb from list */
      pcb2->next = pcb->next;
  1157be:	8b 45 08             	mov    0x8(%ebp),%eax
  1157c1:	8b 50 0c             	mov    0xc(%eax),%edx
  1157c4:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1157c7:	89 50 0c             	mov    %edx,0xc(%eax)
  1157ca:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1157cd:	8b 40 0c             	mov    0xc(%eax),%eax
  1157d0:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  1157d3:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  1157d7:	75 d0                	jne    1157a9 <udp_remove+0x29>
    }
  }
  memp_free(MEMP_UDP_PCB, pcb);
  1157d9:	8b 45 08             	mov    0x8(%ebp),%eax
  1157dc:	89 44 24 04          	mov    %eax,0x4(%esp)
  1157e0:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  1157e7:	e8 d4 92 ff ff       	call   10eac0 <memp_free>
}
  1157ec:	c9                   	leave  
  1157ed:	c3                   	ret    
  1157ee:	89 f6                	mov    %esi,%esi

001157f0 <udp_new>:
/**
 * Create a UDP PCB.
 *
 * @return The UDP PCB which was created. NULL if the PCB data structure
 * could not be allocated.
 *
 * @see udp_remove()
 */
struct udp_pcb *
udp_new(void) {
  1157f0:	55                   	push   %ebp
  1157f1:	89 e5                	mov    %esp,%ebp
  1157f3:	83 ec 28             	sub    $0x28,%esp
  struct udp_pcb *pcb;
  pcb = memp_malloc(MEMP_UDP_PCB);
  1157f6:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  1157fd:	e8 ce 91 ff ff       	call   10e9d0 <memp_malloc>
  115802:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  /* could allocate UDP PCB? */
  if (pcb != NULL) {
  115805:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  115809:	74 22                	je     11582d <udp_new+0x3d>
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct udp_pcb));
  11580b:	c7 44 24 08 20 00 00 	movl   $0x20,0x8(%esp)
  115812:	00 
  115813:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  11581a:	00 
  11581b:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  11581e:	89 04 24             	mov    %eax,(%esp)
  115821:	e8 aa 06 ff ff       	call   105ed0 <memset>
    pcb->ttl = UDP_TTL;
  115826:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  115829:	c6 40 0b ff          	movb   $0xff,0xb(%eax)
  }
  
  
  return pcb;
  11582d:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
}
  115830:	c9                   	leave  
  115831:	c3                   	ret    
  115832:	90                   	nop    
  115833:	90                   	nop    
  115834:	90                   	nop    
  115835:	90                   	nop    
  115836:	90                   	nop    
  115837:	90                   	nop    
  115838:	90                   	nop    
  115839:	90                   	nop    
  11583a:	90                   	nop    
  11583b:	90                   	nop    
  11583c:	90                   	nop    
  11583d:	90                   	nop    
  11583e:	90                   	nop    
  11583f:	90                   	nop    

00115840 <netbuf_new>:


struct
netbuf *netbuf_new(void)
{
  115840:	55                   	push   %ebp
  115841:	89 e5                	mov    %esp,%ebp
  115843:	83 ec 18             	sub    $0x18,%esp
  struct netbuf *buf;

  buf = memp_malloc(MEMP_NETBUF);
  115846:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  11584d:	e8 7e 91 ff ff       	call   10e9d0 <memp_malloc>
  115852:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  if (buf != NULL) {
  115855:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  115859:	74 1b                	je     115876 <netbuf_new+0x36>
    buf->p = NULL;
  11585b:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  11585e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    buf->ptr = NULL;
  115864:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  115867:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    return buf;
  11586e:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  115871:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  115874:	eb 07                	jmp    11587d <netbuf_new+0x3d>
  } else {
    return NULL;
  115876:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  11587d:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  }
}
  115880:	c9                   	leave  
  115881:	c3                   	ret    
  115882:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi
  115889:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00115890 <netbuf_delete>:

void
netbuf_delete(struct netbuf *buf)
{
  115890:	55                   	push   %ebp
  115891:	89 e5                	mov    %esp,%ebp
  115893:	83 ec 08             	sub    $0x8,%esp
  if (buf != NULL) {
  115896:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  11589a:	74 3e                	je     1158da <netbuf_delete+0x4a>
    if (buf->p != NULL) {
  11589c:	8b 45 08             	mov    0x8(%ebp),%eax
  11589f:	8b 00                	mov    (%eax),%eax
  1158a1:	85 c0                	test   %eax,%eax
  1158a3:	74 22                	je     1158c7 <netbuf_delete+0x37>
      pbuf_free(buf->p);
  1158a5:	8b 45 08             	mov    0x8(%ebp),%eax
  1158a8:	8b 00                	mov    (%eax),%eax
  1158aa:	89 04 24             	mov    %eax,(%esp)
  1158ad:	e8 0e 9c ff ff       	call   10f4c0 <pbuf_free>
      buf->p = buf->ptr = NULL;
  1158b2:	8b 45 08             	mov    0x8(%ebp),%eax
  1158b5:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  1158bc:	8b 45 08             	mov    0x8(%ebp),%eax
  1158bf:	8b 50 04             	mov    0x4(%eax),%edx
  1158c2:	8b 45 08             	mov    0x8(%ebp),%eax
  1158c5:	89 10                	mov    %edx,(%eax)
    }
    memp_free(MEMP_NETBUF, buf);
  1158c7:	8b 45 08             	mov    0x8(%ebp),%eax
  1158ca:	89 44 24 04          	mov    %eax,0x4(%esp)
  1158ce:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  1158d5:	e8 e6 91 ff ff       	call   10eac0 <memp_free>
  }
}
  1158da:	c9                   	leave  
  1158db:	c3                   	ret    
  1158dc:	8d 74 26 00          	lea    0x0(%esi),%esi

001158e0 <netbuf_alloc>:

void *
netbuf_alloc(struct netbuf *buf, u16_t size)
{
  1158e0:	55                   	push   %ebp
  1158e1:	89 e5                	mov    %esp,%ebp
  1158e3:	83 ec 18             	sub    $0x18,%esp
  1158e6:	8b 45 0c             	mov    0xc(%ebp),%eax
  1158e9:	66 89 45 fc          	mov    %ax,0xfffffffc(%ebp)
  /* Deallocate any previously allocated memory. */
  if (buf->p != NULL) {
  1158ed:	8b 45 08             	mov    0x8(%ebp),%eax
  1158f0:	8b 00                	mov    (%eax),%eax
  1158f2:	85 c0                	test   %eax,%eax
  1158f4:	74 0d                	je     115903 <netbuf_alloc+0x23>
    pbuf_free(buf->p);
  1158f6:	8b 45 08             	mov    0x8(%ebp),%eax
  1158f9:	8b 00                	mov    (%eax),%eax
  1158fb:	89 04 24             	mov    %eax,(%esp)
  1158fe:	e8 bd 9b ff ff       	call   10f4c0 <pbuf_free>
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, size, PBUF_RAM);
  115903:	0f b7 45 fc          	movzwl 0xfffffffc(%ebp),%eax
  115907:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  11590e:	00 
  11590f:	89 44 24 04          	mov    %eax,0x4(%esp)
  115913:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  11591a:	e8 c1 96 ff ff       	call   10efe0 <pbuf_alloc>
  11591f:	89 c2                	mov    %eax,%edx
  115921:	8b 45 08             	mov    0x8(%ebp),%eax
  115924:	89 10                	mov    %edx,(%eax)
  if (buf->p == NULL) {
  115926:	8b 45 08             	mov    0x8(%ebp),%eax
  115929:	8b 00                	mov    (%eax),%eax
  11592b:	85 c0                	test   %eax,%eax
  11592d:	75 09                	jne    115938 <netbuf_alloc+0x58>
     return NULL;
  11592f:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)
  115936:	eb 16                	jmp    11594e <netbuf_alloc+0x6e>
  }
  buf->ptr = buf->p;
  115938:	8b 45 08             	mov    0x8(%ebp),%eax
  11593b:	8b 10                	mov    (%eax),%edx
  11593d:	8b 45 08             	mov    0x8(%ebp),%eax
  115940:	89 50 04             	mov    %edx,0x4(%eax)
  return buf->p->payload;
  115943:	8b 45 08             	mov    0x8(%ebp),%eax
  115946:	8b 00                	mov    (%eax),%eax
  115948:	8b 40 04             	mov    0x4(%eax),%eax
  11594b:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  11594e:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
}
  115951:	c9                   	leave  
  115952:	c3                   	ret    
  115953:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  115959:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00115960 <netbuf_free>:

void
netbuf_free(struct netbuf *buf)
{
  115960:	55                   	push   %ebp
  115961:	89 e5                	mov    %esp,%ebp
  115963:	83 ec 08             	sub    $0x8,%esp
  if (buf->p != NULL) {
  115966:	8b 45 08             	mov    0x8(%ebp),%eax
  115969:	8b 00                	mov    (%eax),%eax
  11596b:	85 c0                	test   %eax,%eax
  11596d:	74 0d                	je     11597c <netbuf_free+0x1c>
    pbuf_free(buf->p);
  11596f:	8b 45 08             	mov    0x8(%ebp),%eax
  115972:	8b 00                	mov    (%eax),%eax
  115974:	89 04 24             	mov    %eax,(%esp)
  115977:	e8 44 9b ff ff       	call   10f4c0 <pbuf_free>
  }
  buf->p = buf->ptr = NULL;
  11597c:	8b 45 08             	mov    0x8(%ebp),%eax
  11597f:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  115986:	8b 45 08             	mov    0x8(%ebp),%eax
  115989:	8b 50 04             	mov    0x4(%eax),%edx
  11598c:	8b 45 08             	mov    0x8(%ebp),%eax
  11598f:	89 10                	mov    %edx,(%eax)
}
  115991:	c9                   	leave  
  115992:	c3                   	ret    
  115993:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  115999:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

001159a0 <netbuf_ref>:

void
netbuf_ref(struct netbuf *buf, void *dataptr, u16_t size)
{
  1159a0:	55                   	push   %ebp
  1159a1:	89 e5                	mov    %esp,%ebp
  1159a3:	83 ec 18             	sub    $0x18,%esp
  1159a6:	8b 45 10             	mov    0x10(%ebp),%eax
  1159a9:	66 89 45 fc          	mov    %ax,0xfffffffc(%ebp)
  if (buf->p != NULL) {
  1159ad:	8b 45 08             	mov    0x8(%ebp),%eax
  1159b0:	8b 00                	mov    (%eax),%eax
  1159b2:	85 c0                	test   %eax,%eax
  1159b4:	74 0d                	je     1159c3 <netbuf_ref+0x23>
    pbuf_free(buf->p);
  1159b6:	8b 45 08             	mov    0x8(%ebp),%eax
  1159b9:	8b 00                	mov    (%eax),%eax
  1159bb:	89 04 24             	mov    %eax,(%esp)
  1159be:	e8 fd 9a ff ff       	call   10f4c0 <pbuf_free>
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, 0, PBUF_REF);
  1159c3:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
  1159ca:	00 
  1159cb:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  1159d2:	00 
  1159d3:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  1159da:	e8 01 96 ff ff       	call   10efe0 <pbuf_alloc>
  1159df:	89 c2                	mov    %eax,%edx
  1159e1:	8b 45 08             	mov    0x8(%ebp),%eax
  1159e4:	89 10                	mov    %edx,(%eax)
  buf->p->payload = dataptr;
  1159e6:	8b 45 08             	mov    0x8(%ebp),%eax
  1159e9:	8b 10                	mov    (%eax),%edx
  1159eb:	8b 45 0c             	mov    0xc(%ebp),%eax
  1159ee:	89 42 04             	mov    %eax,0x4(%edx)
  buf->p->len = buf->p->tot_len = size;
  1159f1:	8b 45 08             	mov    0x8(%ebp),%eax
  1159f4:	8b 08                	mov    (%eax),%ecx
  1159f6:	8b 45 08             	mov    0x8(%ebp),%eax
  1159f9:	8b 10                	mov    (%eax),%edx
  1159fb:	0f b7 45 fc          	movzwl 0xfffffffc(%ebp),%eax
  1159ff:	66 89 42 08          	mov    %ax,0x8(%edx)
  115a03:	0f b7 42 08          	movzwl 0x8(%edx),%eax
  115a07:	66 89 41 0a          	mov    %ax,0xa(%ecx)
  buf->ptr = buf->p;
  115a0b:	8b 45 08             	mov    0x8(%ebp),%eax
  115a0e:	8b 10                	mov    (%eax),%edx
  115a10:	8b 45 08             	mov    0x8(%ebp),%eax
  115a13:	89 50 04             	mov    %edx,0x4(%eax)
}
  115a16:	c9                   	leave  
  115a17:	c3                   	ret    
  115a18:	90                   	nop    
  115a19:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

00115a20 <netbuf_chain>:

void
netbuf_chain(struct netbuf *head, struct netbuf *tail)
{
  115a20:	55                   	push   %ebp
  115a21:	89 e5                	mov    %esp,%ebp
  115a23:	83 ec 08             	sub    $0x8,%esp
  pbuf_chain(head->p, tail->p);
  115a26:	8b 45 0c             	mov    0xc(%ebp),%eax
  115a29:	8b 10                	mov    (%eax),%edx
  115a2b:	8b 45 08             	mov    0x8(%ebp),%eax
  115a2e:	8b 00                	mov    (%eax),%eax
  115a30:	89 54 24 04          	mov    %edx,0x4(%esp)
  115a34:	89 04 24             	mov    %eax,(%esp)
  115a37:	e8 84 9c ff ff       	call   10f6c0 <pbuf_chain>
  head->ptr = head->p;
  115a3c:	8b 45 08             	mov    0x8(%ebp),%eax
  115a3f:	8b 10                	mov    (%eax),%edx
  115a41:	8b 45 08             	mov    0x8(%ebp),%eax
  115a44:	89 50 04             	mov    %edx,0x4(%eax)
  memp_free(MEMP_NETBUF, tail);
  115a47:	8b 45 0c             	mov    0xc(%ebp),%eax
  115a4a:	89 44 24 04          	mov    %eax,0x4(%esp)
  115a4e:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  115a55:	e8 66 90 ff ff       	call   10eac0 <memp_free>
}
  115a5a:	c9                   	leave  
  115a5b:	c3                   	ret    
  115a5c:	8d 74 26 00          	lea    0x0(%esi),%esi

00115a60 <netbuf_len>:

u16_t
netbuf_len(struct netbuf *buf)
{
  115a60:	55                   	push   %ebp
  115a61:	89 e5                	mov    %esp,%ebp
  return buf->p->tot_len;
  115a63:	8b 45 08             	mov    0x8(%ebp),%eax
  115a66:	8b 00                	mov    (%eax),%eax
  115a68:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  115a6c:	0f b7 c0             	movzwl %ax,%eax
}
  115a6f:	5d                   	pop    %ebp
  115a70:	c3                   	ret    
  115a71:	eb 0d                	jmp    115a80 <netbuf_data>
  115a73:	90                   	nop    
  115a74:	90                   	nop    
  115a75:	90                   	nop    
  115a76:	90                   	nop    
  115a77:	90                   	nop    
  115a78:	90                   	nop    
  115a79:	90                   	nop    
  115a7a:	90                   	nop    
  115a7b:	90                   	nop    
  115a7c:	90                   	nop    
  115a7d:	90                   	nop    
  115a7e:	90                   	nop    
  115a7f:	90                   	nop    

00115a80 <netbuf_data>:

err_t
netbuf_data(struct netbuf *buf, void **dataptr, u16_t *len)
{
  115a80:	55                   	push   %ebp
  115a81:	89 e5                	mov    %esp,%ebp
  115a83:	83 ec 04             	sub    $0x4,%esp
  if (buf->ptr == NULL) {
  115a86:	8b 45 08             	mov    0x8(%ebp),%eax
  115a89:	8b 40 04             	mov    0x4(%eax),%eax
  115a8c:	85 c0                	test   %eax,%eax
  115a8e:	75 09                	jne    115a99 <netbuf_data+0x19>
    return ERR_BUF;
  115a90:	c7 45 fc fe ff ff ff 	movl   $0xfffffffe,0xfffffffc(%ebp)
  115a97:	eb 25                	jmp    115abe <netbuf_data+0x3e>
  }
  *dataptr = buf->ptr->payload;
  115a99:	8b 45 08             	mov    0x8(%ebp),%eax
  115a9c:	8b 40 04             	mov    0x4(%eax),%eax
  115a9f:	8b 50 04             	mov    0x4(%eax),%edx
  115aa2:	8b 45 0c             	mov    0xc(%ebp),%eax
  115aa5:	89 10                	mov    %edx,(%eax)
  *len = buf->ptr->len;
  115aa7:	8b 45 08             	mov    0x8(%ebp),%eax
  115aaa:	8b 40 04             	mov    0x4(%eax),%eax
  115aad:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
  115ab1:	8b 45 10             	mov    0x10(%ebp),%eax
  115ab4:	66 89 10             	mov    %dx,(%eax)
  return ERR_OK;
  115ab7:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
  115abe:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
}
  115ac1:	c9                   	leave  
  115ac2:	c3                   	ret    
  115ac3:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  115ac9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00115ad0 <netbuf_next>:

s8_t
netbuf_next(struct netbuf *buf)
{
  115ad0:	55                   	push   %ebp
  115ad1:	89 e5                	mov    %esp,%ebp
  115ad3:	83 ec 04             	sub    $0x4,%esp
  if (buf->ptr->next == NULL) {
  115ad6:	8b 45 08             	mov    0x8(%ebp),%eax
  115ad9:	8b 40 04             	mov    0x4(%eax),%eax
  115adc:	8b 00                	mov    (%eax),%eax
  115ade:	85 c0                	test   %eax,%eax
  115ae0:	75 09                	jne    115aeb <netbuf_next+0x1b>
    return -1;
  115ae2:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,0xfffffffc(%ebp)
  115ae9:	eb 2a                	jmp    115b15 <netbuf_next+0x45>
  }
  buf->ptr = buf->ptr->next;
  115aeb:	8b 45 08             	mov    0x8(%ebp),%eax
  115aee:	8b 40 04             	mov    0x4(%eax),%eax
  115af1:	8b 10                	mov    (%eax),%edx
  115af3:	8b 45 08             	mov    0x8(%ebp),%eax
  115af6:	89 50 04             	mov    %edx,0x4(%eax)
  if (buf->ptr->next == NULL) {
  115af9:	8b 45 08             	mov    0x8(%ebp),%eax
  115afc:	8b 40 04             	mov    0x4(%eax),%eax
  115aff:	8b 00                	mov    (%eax),%eax
  115b01:	85 c0                	test   %eax,%eax
  115b03:	75 09                	jne    115b0e <netbuf_next+0x3e>
    return 1;
  115b05:	c7 45 fc 01 00 00 00 	movl   $0x1,0xfffffffc(%ebp)
  115b0c:	eb 07                	jmp    115b15 <netbuf_next+0x45>
  }
  return 0;
  115b0e:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
  115b15:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
}
  115b18:	c9                   	leave  
  115b19:	c3                   	ret    
  115b1a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

00115b20 <netbuf_first>:

void
netbuf_first(struct netbuf *buf)
{
  115b20:	55                   	push   %ebp
  115b21:	89 e5                	mov    %esp,%ebp
  buf->ptr = buf->p;
  115b23:	8b 45 08             	mov    0x8(%ebp),%eax
  115b26:	8b 10                	mov    (%eax),%edx
  115b28:	8b 45 08             	mov    0x8(%ebp),%eax
  115b2b:	89 50 04             	mov    %edx,0x4(%eax)
}
  115b2e:	5d                   	pop    %ebp
  115b2f:	c3                   	ret    

00115b30 <netbuf_copy_partial>:

void
netbuf_copy_partial(struct netbuf *buf, void *dataptr, u16_t len, u16_t offset)
{
  115b30:	55                   	push   %ebp
  115b31:	89 e5                	mov    %esp,%ebp
  115b33:	83 ec 18             	sub    $0x18,%esp
  115b36:	8b 45 10             	mov    0x10(%ebp),%eax
  115b39:	8b 55 14             	mov    0x14(%ebp),%edx
  115b3c:	66 89 45 ec          	mov    %ax,0xffffffec(%ebp)
  115b40:	66 89 55 e8          	mov    %dx,0xffffffe8(%ebp)
  struct pbuf *p;
  u16_t i, left;

  left = 0;
  115b44:	66 c7 45 fe 00 00    	movw   $0x0,0xfffffffe(%ebp)

  if(buf == NULL || dataptr == NULL) {
  115b4a:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  115b4e:	0f 84 a3 00 00 00    	je     115bf7 <netbuf_copy_partial+0xc7>
  115b54:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  115b58:	75 05                	jne    115b5f <netbuf_copy_partial+0x2f>
    return;
  115b5a:	e9 98 00 00 00       	jmp    115bf7 <netbuf_copy_partial+0xc7>
  }
  
  /* This implementation is bad. It should use bcopy
     instead. */
  for(p = buf->p; left < len && p != NULL; p = p->next) {
  115b5f:	8b 45 08             	mov    0x8(%ebp),%eax
  115b62:	8b 00                	mov    (%eax),%eax
  115b64:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  115b67:	eb 7a                	jmp    115be3 <netbuf_copy_partial+0xb3>
    if (offset != 0 && offset >= p->len) {
  115b69:	66 83 7d e8 00       	cmpw   $0x0,0xffffffe8(%ebp)
  115b6e:	74 1a                	je     115b8a <netbuf_copy_partial+0x5a>
  115b70:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  115b73:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  115b77:	66 3b 45 e8          	cmp    0xffffffe8(%ebp),%ax
  115b7b:	77 0d                	ja     115b8a <netbuf_copy_partial+0x5a>
      offset -= p->len;
  115b7d:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  115b80:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  115b84:	66 29 45 e8          	sub    %ax,0xffffffe8(%ebp)
  115b88:	eb 51                	jmp    115bdb <netbuf_copy_partial+0xab>
    } else {    
      for(i = offset; i < p->len; ++i) {
  115b8a:	0f b7 45 e8          	movzwl 0xffffffe8(%ebp),%eax
  115b8e:	66 89 45 fc          	mov    %ax,0xfffffffc(%ebp)
  115b92:	eb 34                	jmp    115bc8 <netbuf_copy_partial+0x98>
  ((char *)dataptr)[left] = ((char *)p->payload)[i];
  115b94:	0f b7 45 fe          	movzwl 0xfffffffe(%ebp),%eax
  115b98:	89 c2                	mov    %eax,%edx
  115b9a:	8b 45 0c             	mov    0xc(%ebp),%eax
  115b9d:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
  115ba0:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  115ba3:	8b 40 04             	mov    0x4(%eax),%eax
  115ba6:	89 c2                	mov    %eax,%edx
  115ba8:	0f b7 45 fc          	movzwl 0xfffffffc(%ebp),%eax
  115bac:	8d 04 02             	lea    (%edx,%eax,1),%eax
  115baf:	0f b6 00             	movzbl (%eax),%eax
  115bb2:	88 01                	mov    %al,(%ecx)
  if (++left >= len) {
  115bb4:	66 83 45 fe 01       	addw   $0x1,0xfffffffe(%ebp)
  115bb9:	0f b7 45 fe          	movzwl 0xfffffffe(%ebp),%eax
  115bbd:	66 3b 45 ec          	cmp    0xffffffec(%ebp),%ax
  115bc1:	73 34                	jae    115bf7 <netbuf_copy_partial+0xc7>
  115bc3:	66 83 45 fc 01       	addw   $0x1,0xfffffffc(%ebp)
  115bc8:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  115bcb:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  115bcf:	66 3b 45 fc          	cmp    0xfffffffc(%ebp),%ax
  115bd3:	77 bf                	ja     115b94 <netbuf_copy_partial+0x64>
    return;
  }
      }
      offset = 0;
  115bd5:	66 c7 45 e8 00 00    	movw   $0x0,0xffffffe8(%ebp)
  115bdb:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  115bde:	8b 00                	mov    (%eax),%eax
  115be0:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  115be3:	0f b7 45 fe          	movzwl 0xfffffffe(%ebp),%eax
  115be7:	66 3b 45 ec          	cmp    0xffffffec(%ebp),%ax
  115beb:	73 0a                	jae    115bf7 <netbuf_copy_partial+0xc7>
  115bed:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  115bf1:	0f 85 72 ff ff ff    	jne    115b69 <netbuf_copy_partial+0x39>
    }
  }
}
  115bf7:	c9                   	leave  
  115bf8:	c3                   	ret    
  115bf9:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

00115c00 <netbuf_copy>:

void
netbuf_copy(struct netbuf *buf, void *dataptr, u16_t len)
{
  115c00:	55                   	push   %ebp
  115c01:	89 e5                	mov    %esp,%ebp
  115c03:	83 ec 14             	sub    $0x14,%esp
  115c06:	8b 45 10             	mov    0x10(%ebp),%eax
  115c09:	66 89 45 fc          	mov    %ax,0xfffffffc(%ebp)
  netbuf_copy_partial(buf, dataptr, len, 0);
  115c0d:	0f b7 45 fc          	movzwl 0xfffffffc(%ebp),%eax
  115c11:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  115c18:	00 
  115c19:	89 44 24 08          	mov    %eax,0x8(%esp)
  115c1d:	8b 45 0c             	mov    0xc(%ebp),%eax
  115c20:	89 44 24 04          	mov    %eax,0x4(%esp)
  115c24:	8b 45 08             	mov    0x8(%ebp),%eax
  115c27:	89 04 24             	mov    %eax,(%esp)
  115c2a:	e8 01 ff ff ff       	call   115b30 <netbuf_copy_partial>
}
  115c2f:	c9                   	leave  
  115c30:	c3                   	ret    
  115c31:	eb 0d                	jmp    115c40 <netbuf_fromaddr>
  115c33:	90                   	nop    
  115c34:	90                   	nop    
  115c35:	90                   	nop    
  115c36:	90                   	nop    
  115c37:	90                   	nop    
  115c38:	90                   	nop    
  115c39:	90                   	nop    
  115c3a:	90                   	nop    
  115c3b:	90                   	nop    
  115c3c:	90                   	nop    
  115c3d:	90                   	nop    
  115c3e:	90                   	nop    
  115c3f:	90                   	nop    

00115c40 <netbuf_fromaddr>:

struct ip_addr *
netbuf_fromaddr(struct netbuf *buf)
{
  115c40:	55                   	push   %ebp
  115c41:	89 e5                	mov    %esp,%ebp
  return buf->fromaddr;
  115c43:	8b 45 08             	mov    0x8(%ebp),%eax
  115c46:	8b 40 08             	mov    0x8(%eax),%eax
}
  115c49:	5d                   	pop    %ebp
  115c4a:	c3                   	ret    
  115c4b:	90                   	nop    
  115c4c:	8d 74 26 00          	lea    0x0(%esi),%esi

00115c50 <netbuf_fromport>:

u16_t
netbuf_fromport(struct netbuf *buf)
{
  115c50:	55                   	push   %ebp
  115c51:	89 e5                	mov    %esp,%ebp
  return buf->fromport;
  115c53:	8b 45 08             	mov    0x8(%ebp),%eax
  115c56:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  115c5a:	0f b7 c0             	movzwl %ax,%eax
}
  115c5d:	5d                   	pop    %ebp
  115c5e:	c3                   	ret    
  115c5f:	90                   	nop    

00115c60 <netconn_new_with_proto_and_callback>:

struct
netconn *netconn_new_with_proto_and_callback(enum netconn_type t, u16_t proto,
                                   void (*callback)(struct netconn *, enum netconn_evt, u16_t len))
{
  115c60:	55                   	push   %ebp
  115c61:	89 e5                	mov    %esp,%ebp
  115c63:	83 ec 28             	sub    $0x28,%esp
  115c66:	8b 45 0c             	mov    0xc(%ebp),%eax
  115c69:	66 89 45 ec          	mov    %ax,0xffffffec(%ebp)
  struct netconn *conn;
  struct api_msg *msg;

  conn = memp_malloc(MEMP_NETCONN);
  115c6d:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  115c74:	e8 57 8d ff ff       	call   10e9d0 <memp_malloc>
  115c79:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  if (conn == NULL) {
  115c7c:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  115c80:	75 0c                	jne    115c8e <netconn_new_with_proto_and_callback+0x2e>
    return NULL;
  115c82:	c7 45 e8 00 00 00 00 	movl   $0x0,0xffffffe8(%ebp)
  115c89:	e9 42 01 00 00       	jmp    115dd0 <netconn_new_with_proto_and_callback+0x170>
  }
  
  conn->err = ERR_OK;
  115c8e:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  115c91:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
  conn->type = t;
  115c95:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  115c98:	8b 45 08             	mov    0x8(%ebp),%eax
  115c9b:	89 02                	mov    %eax,(%edx)
  conn->pcb.tcp = NULL;
  115c9d:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  115ca0:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)

  if ((conn->mbox = sys_mbox_new()) == SYS_MBOX_NULL) {
  115ca7:	e8 b4 41 00 00       	call   119e60 <sys_mbox_new>
  115cac:	89 c2                	mov    %eax,%edx
  115cae:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  115cb1:	89 50 10             	mov    %edx,0x10(%eax)
  115cb4:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  115cb7:	8b 40 10             	mov    0x10(%eax),%eax
  115cba:	85 c0                	test   %eax,%eax
  115cbc:	75 1f                	jne    115cdd <netconn_new_with_proto_and_callback+0x7d>
    memp_free(MEMP_NETCONN, conn);
  115cbe:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  115cc1:	89 44 24 04          	mov    %eax,0x4(%esp)
  115cc5:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  115ccc:	e8 ef 8d ff ff       	call   10eac0 <memp_free>
    return NULL;
  115cd1:	c7 45 e8 00 00 00 00 	movl   $0x0,0xffffffe8(%ebp)
  115cd8:	e9 f3 00 00 00       	jmp    115dd0 <netconn_new_with_proto_and_callback+0x170>
  }
  conn->recvmbox = SYS_MBOX_NULL;
  115cdd:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  115ce0:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
  conn->acceptmbox = SYS_MBOX_NULL;
  115ce7:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  115cea:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
  conn->sem = SYS_SEM_NULL;
  115cf1:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  115cf4:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
  conn->state = NETCONN_NONE;
  115cfb:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  115cfe:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  conn->socket = 0;
  115d05:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  115d08:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
  conn->callback = callback;
  115d0f:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  115d12:	8b 45 10             	mov    0x10(%ebp),%eax
  115d15:	89 42 28             	mov    %eax,0x28(%edx)
  conn->recv_avail = 0;
  115d18:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  115d1b:	66 c7 40 24 00 00    	movw   $0x0,0x24(%eax)

  if((msg = memp_malloc(MEMP_API_MSG)) == NULL) {
  115d21:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  115d28:	e8 a3 8c ff ff       	call   10e9d0 <memp_malloc>
  115d2d:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  115d30:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  115d34:	75 1c                	jne    115d52 <netconn_new_with_proto_and_callback+0xf2>
    memp_free(MEMP_NETCONN, conn);
  115d36:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  115d39:	89 44 24 04          	mov    %eax,0x4(%esp)
  115d3d:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  115d44:	e8 77 8d ff ff       	call   10eac0 <memp_free>
    return NULL;
  115d49:	c7 45 e8 00 00 00 00 	movl   $0x0,0xffffffe8(%ebp)
  115d50:	eb 7e                	jmp    115dd0 <netconn_new_with_proto_and_callback+0x170>
  }
  
  msg->type = API_MSG_NEWCONN;
  115d52:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  115d55:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  msg->msg.msg.bc.port = proto; /* misusing the port field */
  115d5b:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  115d5e:	0f b7 45 ec          	movzwl 0xffffffec(%ebp),%eax
  115d62:	66 89 42 10          	mov    %ax,0x10(%edx)
  msg->msg.conn = conn;
  115d66:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  115d69:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  115d6c:	89 42 04             	mov    %eax,0x4(%edx)
  api_msg_post(msg);  
  115d6f:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  115d72:	89 04 24             	mov    %eax,(%esp)
  115d75:	e8 36 21 00 00       	call   117eb0 <api_msg_post>
  sys_mbox_fetch(conn->mbox, NULL);
  115d7a:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  115d7d:	8b 40 10             	mov    0x10(%eax),%eax
  115d80:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  115d87:	00 
  115d88:	89 04 24             	mov    %eax,(%esp)
  115d8b:	e8 80 9f ff ff       	call   10fd10 <sys_mbox_fetch>
  memp_free(MEMP_API_MSG, msg);
  115d90:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  115d93:	89 44 24 04          	mov    %eax,0x4(%esp)
  115d97:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  115d9e:	e8 1d 8d ff ff       	call   10eac0 <memp_free>

  if ( conn->err != ERR_OK ) {
  115da3:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  115da6:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
  115daa:	84 c0                	test   %al,%al
  115dac:	74 1c                	je     115dca <netconn_new_with_proto_and_callback+0x16a>
    memp_free(MEMP_NETCONN, conn);
  115dae:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  115db1:	89 44 24 04          	mov    %eax,0x4(%esp)
  115db5:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  115dbc:	e8 ff 8c ff ff       	call   10eac0 <memp_free>
    return NULL;
  115dc1:	c7 45 e8 00 00 00 00 	movl   $0x0,0xffffffe8(%ebp)
  115dc8:	eb 06                	jmp    115dd0 <netconn_new_with_proto_and_callback+0x170>
  }

  return conn;
  115dca:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  115dcd:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
  115dd0:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
}
  115dd3:	c9                   	leave  
  115dd4:	c3                   	ret    
  115dd5:	8d 74 26 00          	lea    0x0(%esi),%esi
  115dd9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00115de0 <netconn_new>:


struct
netconn *netconn_new(enum netconn_type t)
{
  115de0:	55                   	push   %ebp
  115de1:	89 e5                	mov    %esp,%ebp
  115de3:	83 ec 18             	sub    $0x18,%esp
  return netconn_new_with_proto_and_callback(t,0,NULL);
  115de6:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  115ded:	00 
  115dee:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  115df5:	00 
  115df6:	8b 45 08             	mov    0x8(%ebp),%eax
  115df9:	89 04 24             	mov    %eax,(%esp)
  115dfc:	e8 5f fe ff ff       	call   115c60 <netconn_new_with_proto_and_callback>
}
  115e01:	c9                   	leave  
  115e02:	c3                   	ret    
  115e03:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  115e09:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00115e10 <netconn_new_with_callback>:

struct
netconn *netconn_new_with_callback(enum netconn_type t,
                                   void (*callback)(struct netconn *, enum netconn_evt, u16_t len))
{
  115e10:	55                   	push   %ebp
  115e11:	89 e5                	mov    %esp,%ebp
  115e13:	83 ec 18             	sub    $0x18,%esp
  return netconn_new_with_proto_and_callback(t,0,callback);
  115e16:	8b 45 0c             	mov    0xc(%ebp),%eax
  115e19:	89 44 24 08          	mov    %eax,0x8(%esp)
  115e1d:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  115e24:	00 
  115e25:	8b 45 08             	mov    0x8(%ebp),%eax
  115e28:	89 04 24             	mov    %eax,(%esp)
  115e2b:	e8 30 fe ff ff       	call   115c60 <netconn_new_with_proto_and_callback>
}
  115e30:	c9                   	leave  
  115e31:	c3                   	ret    
  115e32:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi
  115e39:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00115e40 <netconn_delete>:


err_t
netconn_delete(struct netconn *conn)
{
  115e40:	55                   	push   %ebp
  115e41:	89 e5                	mov    %esp,%ebp
  115e43:	83 ec 28             	sub    $0x28,%esp
  struct api_msg *msg;
  void *mem;
  
  if (conn == NULL) {
  115e46:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  115e4a:	75 0c                	jne    115e58 <netconn_delete+0x18>
    return ERR_OK;
  115e4c:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  115e53:	e9 69 01 00 00       	jmp    115fc1 <netconn_delete+0x181>
  }
  
  if ((msg = memp_malloc(MEMP_API_MSG)) == NULL) {
  115e58:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  115e5f:	e8 6c 8b ff ff       	call   10e9d0 <memp_malloc>
  115e64:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  115e67:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  115e6b:	75 0c                	jne    115e79 <netconn_delete+0x39>
    return ERR_MEM;
  115e6d:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  115e74:	e9 48 01 00 00       	jmp    115fc1 <netconn_delete+0x181>
  }
  
  msg->type = API_MSG_DELCONN;
  115e79:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  115e7c:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
  msg->msg.conn = conn;
  115e82:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  115e85:	8b 45 08             	mov    0x8(%ebp),%eax
  115e88:	89 42 04             	mov    %eax,0x4(%edx)
  api_msg_post(msg);  
  115e8b:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  115e8e:	89 04 24             	mov    %eax,(%esp)
  115e91:	e8 1a 20 00 00       	call   117eb0 <api_msg_post>
  sys_mbox_fetch(conn->mbox, NULL);
  115e96:	8b 45 08             	mov    0x8(%ebp),%eax
  115e99:	8b 40 10             	mov    0x10(%eax),%eax
  115e9c:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  115ea3:	00 
  115ea4:	89 04 24             	mov    %eax,(%esp)
  115ea7:	e8 64 9e ff ff       	call   10fd10 <sys_mbox_fetch>
  memp_free(MEMP_API_MSG, msg);
  115eac:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  115eaf:	89 44 24 04          	mov    %eax,0x4(%esp)
  115eb3:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  115eba:	e8 01 8c ff ff       	call   10eac0 <memp_free>

  /* Drain the recvmbox. */
  if (conn->recvmbox != SYS_MBOX_NULL) {
  115ebf:	8b 45 08             	mov    0x8(%ebp),%eax
  115ec2:	8b 40 14             	mov    0x14(%eax),%eax
  115ec5:	85 c0                	test   %eax,%eax
  115ec7:	74 5d                	je     115f26 <netconn_delete+0xe6>
    while (sys_arch_mbox_fetch(conn->recvmbox, &mem, 1) != SYS_ARCH_TIMEOUT) {
  115ec9:	eb 21                	jmp    115eec <netconn_delete+0xac>
      if (conn->type == NETCONN_TCP) {
  115ecb:	8b 45 08             	mov    0x8(%ebp),%eax
  115ece:	8b 00                	mov    (%eax),%eax
  115ed0:	85 c0                	test   %eax,%eax
  115ed2:	75 0d                	jne    115ee1 <netconn_delete+0xa1>
  pbuf_free((struct pbuf *)mem);
  115ed4:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  115ed7:	89 04 24             	mov    %eax,(%esp)
  115eda:	e8 e1 95 ff ff       	call   10f4c0 <pbuf_free>
  115edf:	eb 0b                	jmp    115eec <netconn_delete+0xac>
      } else {
  netbuf_delete((struct netbuf *)mem);
  115ee1:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  115ee4:	89 04 24             	mov    %eax,(%esp)
  115ee7:	e8 a4 f9 ff ff       	call   115890 <netbuf_delete>
  115eec:	8b 45 08             	mov    0x8(%ebp),%eax
  115eef:	8b 50 14             	mov    0x14(%eax),%edx
  115ef2:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  115ef9:	00 
  115efa:	8d 45 f8             	lea    0xfffffff8(%ebp),%eax
  115efd:	89 44 24 04          	mov    %eax,0x4(%esp)
  115f01:	89 14 24             	mov    %edx,(%esp)
  115f04:	e8 37 41 00 00       	call   11a040 <sys_arch_mbox_fetch>
  115f09:	83 f8 ff             	cmp    $0xffffffff,%eax
  115f0c:	75 bd                	jne    115ecb <netconn_delete+0x8b>
      }
    }
    sys_mbox_free(conn->recvmbox);
  115f0e:	8b 45 08             	mov    0x8(%ebp),%eax
  115f11:	8b 40 14             	mov    0x14(%eax),%eax
  115f14:	89 04 24             	mov    %eax,(%esp)
  115f17:	e8 04 40 00 00       	call   119f20 <sys_mbox_free>
    conn->recvmbox = SYS_MBOX_NULL;
  115f1c:	8b 45 08             	mov    0x8(%ebp),%eax
  115f1f:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
  }
 

  /* Drain the acceptmbox. */
  if (conn->acceptmbox != SYS_MBOX_NULL) {
  115f26:	8b 45 08             	mov    0x8(%ebp),%eax
  115f29:	8b 40 18             	mov    0x18(%eax),%eax
  115f2c:	85 c0                	test   %eax,%eax
  115f2e:	74 47                	je     115f77 <netconn_delete+0x137>
    while (sys_arch_mbox_fetch(conn->acceptmbox, &mem, 1) != SYS_ARCH_TIMEOUT) {
  115f30:	eb 0b                	jmp    115f3d <netconn_delete+0xfd>
      netconn_delete((struct netconn *)mem);
  115f32:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  115f35:	89 04 24             	mov    %eax,(%esp)
  115f38:	e8 03 ff ff ff       	call   115e40 <netconn_delete>
  115f3d:	8b 45 08             	mov    0x8(%ebp),%eax
  115f40:	8b 50 18             	mov    0x18(%eax),%edx
  115f43:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  115f4a:	00 
  115f4b:	8d 45 f8             	lea    0xfffffff8(%ebp),%eax
  115f4e:	89 44 24 04          	mov    %eax,0x4(%esp)
  115f52:	89 14 24             	mov    %edx,(%esp)
  115f55:	e8 e6 40 00 00       	call   11a040 <sys_arch_mbox_fetch>
  115f5a:	83 f8 ff             	cmp    $0xffffffff,%eax
  115f5d:	75 d3                	jne    115f32 <netconn_delete+0xf2>
    }
    
    sys_mbox_free(conn->acceptmbox);
  115f5f:	8b 45 08             	mov    0x8(%ebp),%eax
  115f62:	8b 40 18             	mov    0x18(%eax),%eax
  115f65:	89 04 24             	mov    %eax,(%esp)
  115f68:	e8 b3 3f 00 00       	call   119f20 <sys_mbox_free>
    conn->acceptmbox = SYS_MBOX_NULL;
  115f6d:	8b 45 08             	mov    0x8(%ebp),%eax
  115f70:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
  }

  sys_mbox_free(conn->mbox);
  115f77:	8b 45 08             	mov    0x8(%ebp),%eax
  115f7a:	8b 40 10             	mov    0x10(%eax),%eax
  115f7d:	89 04 24             	mov    %eax,(%esp)
  115f80:	e8 9b 3f 00 00       	call   119f20 <sys_mbox_free>
  conn->mbox = SYS_MBOX_NULL;
  115f85:	8b 45 08             	mov    0x8(%ebp),%eax
  115f88:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  if (conn->sem != SYS_SEM_NULL) {
  115f8f:	8b 45 08             	mov    0x8(%ebp),%eax
  115f92:	8b 40 1c             	mov    0x1c(%eax),%eax
  115f95:	85 c0                	test   %eax,%eax
  115f97:	74 0e                	je     115fa7 <netconn_delete+0x167>
    sys_sem_free(conn->sem);
  115f99:	8b 45 08             	mov    0x8(%ebp),%eax
  115f9c:	8b 40 1c             	mov    0x1c(%eax),%eax
  115f9f:	89 04 24             	mov    %eax,(%esp)
  115fa2:	e8 f9 3d 00 00       	call   119da0 <sys_sem_free>
  }
  /*  conn->sem = SYS_SEM_NULL;*/
  memp_free(MEMP_NETCONN, conn);
  115fa7:	8b 45 08             	mov    0x8(%ebp),%eax
  115faa:	89 44 24 04          	mov    %eax,0x4(%esp)
  115fae:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  115fb5:	e8 06 8b ff ff       	call   10eac0 <memp_free>
  return ERR_OK;
  115fba:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  115fc1:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  115fc4:	c9                   	leave  
  115fc5:	c3                   	ret    
  115fc6:	8d 76 00             	lea    0x0(%esi),%esi
  115fc9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00115fd0 <netconn_type>:

enum netconn_type
netconn_type(struct netconn *conn)
{
  115fd0:	55                   	push   %ebp
  115fd1:	89 e5                	mov    %esp,%ebp
  return conn->type;
  115fd3:	8b 45 08             	mov    0x8(%ebp),%eax
  115fd6:	8b 00                	mov    (%eax),%eax
}
  115fd8:	5d                   	pop    %ebp
  115fd9:	c3                   	ret    
  115fda:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

00115fe0 <netconn_peer>:

err_t
netconn_peer(struct netconn *conn, struct ip_addr *addr,
       u16_t *port)
{
  115fe0:	55                   	push   %ebp
  115fe1:	89 e5                	mov    %esp,%ebp
  115fe3:	83 ec 08             	sub    $0x8,%esp
  switch (conn->type) {
  115fe6:	8b 45 08             	mov    0x8(%ebp),%eax
  115fe9:	8b 00                	mov    (%eax),%eax
  115feb:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  115fee:	83 7d f8 03          	cmpl   $0x3,0xfffffff8(%ebp)
  115ff2:	77 08                	ja     115ffc <netconn_peer+0x1c>
  115ff4:	83 7d f8 01          	cmpl   $0x1,0xfffffff8(%ebp)
  115ff8:	73 19                	jae    116013 <netconn_peer+0x33>
  115ffa:	eb 5e                	jmp    11605a <netconn_peer+0x7a>
  115ffc:	83 7d f8 04          	cmpl   $0x4,0xfffffff8(%ebp)
  116000:	74 05                	je     116007 <netconn_peer+0x27>
  116002:	e9 84 00 00 00       	jmp    11608b <netconn_peer+0xab>
  case NETCONN_RAW:
    /* return an error as connecting is only a helper for upper layers */
    return ERR_CONN;
  116007:	c7 45 fc fa ff ff ff 	movl   $0xfffffffa,0xfffffffc(%ebp)
  11600e:	e9 86 00 00 00       	jmp    116099 <netconn_peer+0xb9>
  case NETCONN_UDPLITE:
  case NETCONN_UDPNOCHKSUM:
  case NETCONN_UDP:
    if (conn->pcb.udp == NULL ||
  116013:	8b 45 08             	mov    0x8(%ebp),%eax
  116016:	8b 40 08             	mov    0x8(%eax),%eax
  116019:	85 c0                	test   %eax,%eax
  11601b:	74 14                	je     116031 <netconn_peer+0x51>
  11601d:	8b 45 08             	mov    0x8(%ebp),%eax
  116020:	8b 40 08             	mov    0x8(%eax),%eax
  116023:	0f b6 40 10          	movzbl 0x10(%eax),%eax
  116027:	0f b6 c0             	movzbl %al,%eax
  11602a:	83 e0 04             	and    $0x4,%eax
  11602d:	85 c0                	test   %eax,%eax
  11602f:	75 09                	jne    11603a <netconn_peer+0x5a>
  ((conn->pcb.udp->flags & UDP_FLAGS_CONNECTED) == 0))
     return ERR_CONN;
  116031:	c7 45 fc fa ff ff ff 	movl   $0xfffffffa,0xfffffffc(%ebp)
  116038:	eb 5f                	jmp    116099 <netconn_peer+0xb9>
    *addr = (conn->pcb.udp->remote_ip);
  11603a:	8b 45 08             	mov    0x8(%ebp),%eax
  11603d:	8b 40 08             	mov    0x8(%eax),%eax
  116040:	8b 50 04             	mov    0x4(%eax),%edx
  116043:	8b 45 0c             	mov    0xc(%ebp),%eax
  116046:	89 10                	mov    %edx,(%eax)
    *port = conn->pcb.udp->remote_port;
  116048:	8b 45 08             	mov    0x8(%ebp),%eax
  11604b:	8b 40 08             	mov    0x8(%eax),%eax
  11604e:	0f b7 50 14          	movzwl 0x14(%eax),%edx
  116052:	8b 45 10             	mov    0x10(%ebp),%eax
  116055:	66 89 10             	mov    %dx,(%eax)
    break;
  116058:	eb 31                	jmp    11608b <netconn_peer+0xab>
  case NETCONN_TCP:
    if (conn->pcb.tcp == NULL)
  11605a:	8b 45 08             	mov    0x8(%ebp),%eax
  11605d:	8b 40 08             	mov    0x8(%eax),%eax
  116060:	85 c0                	test   %eax,%eax
  116062:	75 09                	jne    11606d <netconn_peer+0x8d>
      return ERR_CONN;
  116064:	c7 45 fc fa ff ff ff 	movl   $0xfffffffa,0xfffffffc(%ebp)
  11606b:	eb 2c                	jmp    116099 <netconn_peer+0xb9>
    *addr = (conn->pcb.tcp->remote_ip);
  11606d:	8b 45 08             	mov    0x8(%ebp),%eax
  116070:	8b 40 08             	mov    0x8(%eax),%eax
  116073:	8b 50 04             	mov    0x4(%eax),%edx
  116076:	8b 45 0c             	mov    0xc(%ebp),%eax
  116079:	89 10                	mov    %edx,(%eax)
    *port = conn->pcb.tcp->remote_port;
  11607b:	8b 45 08             	mov    0x8(%ebp),%eax
  11607e:	8b 40 08             	mov    0x8(%eax),%eax
  116081:	0f b7 50 1e          	movzwl 0x1e(%eax),%edx
  116085:	8b 45 10             	mov    0x10(%ebp),%eax
  116088:	66 89 10             	mov    %dx,(%eax)
    break;
  }
  return (conn->err = ERR_OK);
  11608b:	8b 45 08             	mov    0x8(%ebp),%eax
  11608e:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
  116092:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
  116099:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
}
  11609c:	c9                   	leave  
  11609d:	c3                   	ret    
  11609e:	89 f6                	mov    %esi,%esi

001160a0 <netconn_addr>:

err_t
netconn_addr(struct netconn *conn, struct ip_addr **addr,
       u16_t *port)
{
  1160a0:	55                   	push   %ebp
  1160a1:	89 e5                	mov    %esp,%ebp
  1160a3:	83 ec 04             	sub    $0x4,%esp
  switch (conn->type) {
  1160a6:	8b 45 08             	mov    0x8(%ebp),%eax
  1160a9:	8b 00                	mov    (%eax),%eax
  1160ab:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  1160ae:	83 7d fc 03          	cmpl   $0x3,0xfffffffc(%ebp)
  1160b2:	77 08                	ja     1160bc <netconn_addr+0x1c>
  1160b4:	83 7d fc 01          	cmpl   $0x1,0xfffffffc(%ebp)
  1160b8:	73 29                	jae    1160e3 <netconn_addr+0x43>
  1160ba:	eb 46                	jmp    116102 <netconn_addr+0x62>
  1160bc:	83 7d fc 04          	cmpl   $0x4,0xfffffffc(%ebp)
  1160c0:	74 02                	je     1160c4 <netconn_addr+0x24>
  1160c2:	eb 5b                	jmp    11611f <netconn_addr+0x7f>
  case NETCONN_RAW:
    *addr = &(conn->pcb.raw->local_ip);
  1160c4:	8b 45 08             	mov    0x8(%ebp),%eax
  1160c7:	8b 40 08             	mov    0x8(%eax),%eax
  1160ca:	89 c2                	mov    %eax,%edx
  1160cc:	8b 45 0c             	mov    0xc(%ebp),%eax
  1160cf:	89 10                	mov    %edx,(%eax)
    *port = conn->pcb.raw->protocol;
  1160d1:	8b 45 08             	mov    0x8(%ebp),%eax
  1160d4:	8b 40 08             	mov    0x8(%eax),%eax
  1160d7:	0f b7 50 10          	movzwl 0x10(%eax),%edx
  1160db:	8b 45 10             	mov    0x10(%ebp),%eax
  1160de:	66 89 10             	mov    %dx,(%eax)
    break;
  1160e1:	eb 3c                	jmp    11611f <netconn_addr+0x7f>
  case NETCONN_UDPLITE:
  case NETCONN_UDPNOCHKSUM:
  case NETCONN_UDP:
    *addr = &(conn->pcb.udp->local_ip);
  1160e3:	8b 45 08             	mov    0x8(%ebp),%eax
  1160e6:	8b 40 08             	mov    0x8(%eax),%eax
  1160e9:	89 c2                	mov    %eax,%edx
  1160eb:	8b 45 0c             	mov    0xc(%ebp),%eax
  1160ee:	89 10                	mov    %edx,(%eax)
    *port = conn->pcb.udp->local_port;
  1160f0:	8b 45 08             	mov    0x8(%ebp),%eax
  1160f3:	8b 40 08             	mov    0x8(%eax),%eax
  1160f6:	0f b7 50 12          	movzwl 0x12(%eax),%edx
  1160fa:	8b 45 10             	mov    0x10(%ebp),%eax
  1160fd:	66 89 10             	mov    %dx,(%eax)
    break;
  116100:	eb 1d                	jmp    11611f <netconn_addr+0x7f>
  case NETCONN_TCP:
    *addr = &(conn->pcb.tcp->local_ip);
  116102:	8b 45 08             	mov    0x8(%ebp),%eax
  116105:	8b 40 08             	mov    0x8(%eax),%eax
  116108:	89 c2                	mov    %eax,%edx
  11610a:	8b 45 0c             	mov    0xc(%ebp),%eax
  11610d:	89 10                	mov    %edx,(%eax)
    *port = conn->pcb.tcp->local_port;
  11610f:	8b 45 08             	mov    0x8(%ebp),%eax
  116112:	8b 40 08             	mov    0x8(%eax),%eax
  116115:	0f b7 50 1c          	movzwl 0x1c(%eax),%edx
  116119:	8b 45 10             	mov    0x10(%ebp),%eax
  11611c:	66 89 10             	mov    %dx,(%eax)
    break;
  }
  return (conn->err = ERR_OK);
  11611f:	8b 45 08             	mov    0x8(%ebp),%eax
  116122:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
  116126:	b8 00 00 00 00       	mov    $0x0,%eax
}
  11612b:	c9                   	leave  
  11612c:	c3                   	ret    
  11612d:	8d 76 00             	lea    0x0(%esi),%esi

00116130 <netconn_bind>:

err_t
netconn_bind(struct netconn *conn, struct ip_addr *addr,
      u16_t port)
{
  116130:	55                   	push   %ebp
  116131:	89 e5                	mov    %esp,%ebp
  116133:	83 ec 28             	sub    $0x28,%esp
  116136:	8b 45 10             	mov    0x10(%ebp),%eax
  116139:	66 89 45 ec          	mov    %ax,0xffffffec(%ebp)
  struct api_msg *msg;

  if (conn == NULL) {
  11613d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  116141:	75 0c                	jne    11614f <netconn_bind+0x1f>
    return ERR_VAL;
  116143:	c7 45 e8 f9 ff ff ff 	movl   $0xfffffff9,0xffffffe8(%ebp)
  11614a:	e9 c2 00 00 00       	jmp    116211 <netconn_bind+0xe1>
  }

  if (conn->type != NETCONN_TCP &&
  11614f:	8b 45 08             	mov    0x8(%ebp),%eax
  116152:	8b 00                	mov    (%eax),%eax
  116154:	85 c0                	test   %eax,%eax
  116156:	74 2d                	je     116185 <netconn_bind+0x55>
  116158:	8b 45 08             	mov    0x8(%ebp),%eax
  11615b:	8b 40 14             	mov    0x14(%eax),%eax
  11615e:	85 c0                	test   %eax,%eax
  116160:	75 23                	jne    116185 <netconn_bind+0x55>
     conn->recvmbox == SYS_MBOX_NULL) {
    if ((conn->recvmbox = sys_mbox_new()) == SYS_MBOX_NULL) {
  116162:	e8 f9 3c 00 00       	call   119e60 <sys_mbox_new>
  116167:	89 c2                	mov    %eax,%edx
  116169:	8b 45 08             	mov    0x8(%ebp),%eax
  11616c:	89 50 14             	mov    %edx,0x14(%eax)
  11616f:	8b 45 08             	mov    0x8(%ebp),%eax
  116172:	8b 40 14             	mov    0x14(%eax),%eax
  116175:	85 c0                	test   %eax,%eax
  116177:	75 0c                	jne    116185 <netconn_bind+0x55>
      return ERR_MEM;
  116179:	c7 45 e8 ff ff ff ff 	movl   $0xffffffff,0xffffffe8(%ebp)
  116180:	e9 8c 00 00 00       	jmp    116211 <netconn_bind+0xe1>
    }
  }
  
  if ((msg = memp_malloc(MEMP_API_MSG)) == NULL) {
  116185:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  11618c:	e8 3f 88 ff ff       	call   10e9d0 <memp_malloc>
  116191:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  116194:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  116198:	75 10                	jne    1161aa <netconn_bind+0x7a>
    return (conn->err = ERR_MEM);
  11619a:	8b 45 08             	mov    0x8(%ebp),%eax
  11619d:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  1161a1:	c7 45 e8 ff ff ff ff 	movl   $0xffffffff,0xffffffe8(%ebp)
  1161a8:	eb 67                	jmp    116211 <netconn_bind+0xe1>
  }
  msg->type = API_MSG_BIND;
  1161aa:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1161ad:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
  msg->msg.conn = conn;
  1161b3:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  1161b6:	8b 45 08             	mov    0x8(%ebp),%eax
  1161b9:	89 42 04             	mov    %eax,0x4(%edx)
  msg->msg.msg.bc.ipaddr = addr;
  1161bc:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  1161bf:	8b 45 0c             	mov    0xc(%ebp),%eax
  1161c2:	89 42 0c             	mov    %eax,0xc(%edx)
  msg->msg.msg.bc.port = port;
  1161c5:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  1161c8:	0f b7 45 ec          	movzwl 0xffffffec(%ebp),%eax
  1161cc:	66 89 42 10          	mov    %ax,0x10(%edx)
  api_msg_post(msg);
  1161d0:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1161d3:	89 04 24             	mov    %eax,(%esp)
  1161d6:	e8 d5 1c 00 00       	call   117eb0 <api_msg_post>
  sys_mbox_fetch(conn->mbox, NULL);
  1161db:	8b 45 08             	mov    0x8(%ebp),%eax
  1161de:	8b 40 10             	mov    0x10(%eax),%eax
  1161e1:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  1161e8:	00 
  1161e9:	89 04 24             	mov    %eax,(%esp)
  1161ec:	e8 1f 9b ff ff       	call   10fd10 <sys_mbox_fetch>
  memp_free(MEMP_API_MSG, msg);
  1161f1:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1161f4:	89 44 24 04          	mov    %eax,0x4(%esp)
  1161f8:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  1161ff:	e8 bc 88 ff ff       	call   10eac0 <memp_free>
  return conn->err;
  116204:	8b 45 08             	mov    0x8(%ebp),%eax
  116207:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
  11620b:	0f be c0             	movsbl %al,%eax
  11620e:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
  116211:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
}
  116214:	c9                   	leave  
  116215:	c3                   	ret    
  116216:	8d 76 00             	lea    0x0(%esi),%esi
  116219:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00116220 <netconn_connect>:


err_t
netconn_connect(struct netconn *conn, struct ip_addr *addr,
       u16_t port)
{
  116220:	55                   	push   %ebp
  116221:	89 e5                	mov    %esp,%ebp
  116223:	83 ec 28             	sub    $0x28,%esp
  116226:	8b 45 10             	mov    0x10(%ebp),%eax
  116229:	66 89 45 ec          	mov    %ax,0xffffffec(%ebp)
  struct api_msg *msg;
  
  if (conn == NULL) {
  11622d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  116231:	75 0c                	jne    11623f <netconn_connect+0x1f>
    return ERR_VAL;
  116233:	c7 45 e8 f9 ff ff ff 	movl   $0xfffffff9,0xffffffe8(%ebp)
  11623a:	e9 b2 00 00 00       	jmp    1162f1 <netconn_connect+0xd1>
  }


  if (conn->recvmbox == SYS_MBOX_NULL) {
  11623f:	8b 45 08             	mov    0x8(%ebp),%eax
  116242:	8b 40 14             	mov    0x14(%eax),%eax
  116245:	85 c0                	test   %eax,%eax
  116247:	75 23                	jne    11626c <netconn_connect+0x4c>
    if ((conn->recvmbox = sys_mbox_new()) == SYS_MBOX_NULL) {
  116249:	e8 12 3c 00 00       	call   119e60 <sys_mbox_new>
  11624e:	89 c2                	mov    %eax,%edx
  116250:	8b 45 08             	mov    0x8(%ebp),%eax
  116253:	89 50 14             	mov    %edx,0x14(%eax)
  116256:	8b 45 08             	mov    0x8(%ebp),%eax
  116259:	8b 40 14             	mov    0x14(%eax),%eax
  11625c:	85 c0                	test   %eax,%eax
  11625e:	75 0c                	jne    11626c <netconn_connect+0x4c>
      return ERR_MEM;
  116260:	c7 45 e8 ff ff ff ff 	movl   $0xffffffff,0xffffffe8(%ebp)
  116267:	e9 85 00 00 00       	jmp    1162f1 <netconn_connect+0xd1>
    }
  }
  
  if ((msg = memp_malloc(MEMP_API_MSG)) == NULL) {
  11626c:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  116273:	e8 58 87 ff ff       	call   10e9d0 <memp_malloc>
  116278:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  11627b:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  11627f:	75 09                	jne    11628a <netconn_connect+0x6a>
    return ERR_MEM;
  116281:	c7 45 e8 ff ff ff ff 	movl   $0xffffffff,0xffffffe8(%ebp)
  116288:	eb 67                	jmp    1162f1 <netconn_connect+0xd1>
  }
  msg->type = API_MSG_CONNECT;
  11628a:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  11628d:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
  msg->msg.conn = conn;  
  116293:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  116296:	8b 45 08             	mov    0x8(%ebp),%eax
  116299:	89 42 04             	mov    %eax,0x4(%edx)
  msg->msg.msg.bc.ipaddr = addr;
  11629c:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  11629f:	8b 45 0c             	mov    0xc(%ebp),%eax
  1162a2:	89 42 0c             	mov    %eax,0xc(%edx)
  msg->msg.msg.bc.port = port;
  1162a5:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  1162a8:	0f b7 45 ec          	movzwl 0xffffffec(%ebp),%eax
  1162ac:	66 89 42 10          	mov    %ax,0x10(%edx)
  api_msg_post(msg);
  1162b0:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1162b3:	89 04 24             	mov    %eax,(%esp)
  1162b6:	e8 f5 1b 00 00       	call   117eb0 <api_msg_post>
  sys_mbox_fetch(conn->mbox, NULL);
  1162bb:	8b 45 08             	mov    0x8(%ebp),%eax
  1162be:	8b 40 10             	mov    0x10(%eax),%eax
  1162c1:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  1162c8:	00 
  1162c9:	89 04 24             	mov    %eax,(%esp)
  1162cc:	e8 3f 9a ff ff       	call   10fd10 <sys_mbox_fetch>
  memp_free(MEMP_API_MSG, msg);
  1162d1:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1162d4:	89 44 24 04          	mov    %eax,0x4(%esp)
  1162d8:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  1162df:	e8 dc 87 ff ff       	call   10eac0 <memp_free>
  return conn->err;
  1162e4:	8b 45 08             	mov    0x8(%ebp),%eax
  1162e7:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
  1162eb:	0f be c0             	movsbl %al,%eax
  1162ee:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
  1162f1:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
}
  1162f4:	c9                   	leave  
  1162f5:	c3                   	ret    
  1162f6:	8d 76 00             	lea    0x0(%esi),%esi
  1162f9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00116300 <netconn_disconnect>:

err_t
netconn_disconnect(struct netconn *conn)
{
  116300:	55                   	push   %ebp
  116301:	89 e5                	mov    %esp,%ebp
  116303:	83 ec 28             	sub    $0x28,%esp
  struct api_msg *msg;
  
  if (conn == NULL) {
  116306:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  11630a:	75 09                	jne    116315 <netconn_disconnect+0x15>
    return ERR_VAL;
  11630c:	c7 45 ec f9 ff ff ff 	movl   $0xfffffff9,0xffffffec(%ebp)
  116313:	eb 71                	jmp    116386 <netconn_disconnect+0x86>
  }

  if ((msg = memp_malloc(MEMP_API_MSG)) == NULL) {
  116315:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  11631c:	e8 af 86 ff ff       	call   10e9d0 <memp_malloc>
  116321:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  116324:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  116328:	75 09                	jne    116333 <netconn_disconnect+0x33>
    return ERR_MEM;
  11632a:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  116331:	eb 53                	jmp    116386 <netconn_disconnect+0x86>
  }
  msg->type = API_MSG_DISCONNECT;
  116333:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  116336:	c7 00 04 00 00 00    	movl   $0x4,(%eax)
  msg->msg.conn = conn;  
  11633c:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  11633f:	8b 45 08             	mov    0x8(%ebp),%eax
  116342:	89 42 04             	mov    %eax,0x4(%edx)
  api_msg_post(msg);
  116345:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  116348:	89 04 24             	mov    %eax,(%esp)
  11634b:	e8 60 1b 00 00       	call   117eb0 <api_msg_post>
  sys_mbox_fetch(conn->mbox, NULL);
  116350:	8b 45 08             	mov    0x8(%ebp),%eax
  116353:	8b 40 10             	mov    0x10(%eax),%eax
  116356:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  11635d:	00 
  11635e:	89 04 24             	mov    %eax,(%esp)
  116361:	e8 aa 99 ff ff       	call   10fd10 <sys_mbox_fetch>
  memp_free(MEMP_API_MSG, msg);
  116366:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  116369:	89 44 24 04          	mov    %eax,0x4(%esp)
  11636d:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  116374:	e8 47 87 ff ff       	call   10eac0 <memp_free>
  return conn->err;
  116379:	8b 45 08             	mov    0x8(%ebp),%eax
  11637c:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
  116380:	0f be c0             	movsbl %al,%eax
  116383:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  116386:	8b 45 ec             	mov    0xffffffec(%ebp),%eax

}
  116389:	c9                   	leave  
  11638a:	c3                   	ret    
  11638b:	90                   	nop    
  11638c:	8d 74 26 00          	lea    0x0(%esi),%esi

00116390 <netconn_listen>:

err_t
netconn_listen(struct netconn *conn)
{
  116390:	55                   	push   %ebp
  116391:	89 e5                	mov    %esp,%ebp
  116393:	83 ec 28             	sub    $0x28,%esp
  struct api_msg *msg;

  if (conn == NULL) {
  116396:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  11639a:	75 0c                	jne    1163a8 <netconn_listen+0x18>
    return ERR_VAL;
  11639c:	c7 45 ec f9 ff ff ff 	movl   $0xfffffff9,0xffffffec(%ebp)
  1163a3:	e9 a2 00 00 00       	jmp    11644a <netconn_listen+0xba>
  }

  if (conn->acceptmbox == SYS_MBOX_NULL) {
  1163a8:	8b 45 08             	mov    0x8(%ebp),%eax
  1163ab:	8b 40 18             	mov    0x18(%eax),%eax
  1163ae:	85 c0                	test   %eax,%eax
  1163b0:	75 20                	jne    1163d2 <netconn_listen+0x42>
    conn->acceptmbox = sys_mbox_new();
  1163b2:	e8 a9 3a 00 00       	call   119e60 <sys_mbox_new>
  1163b7:	89 c2                	mov    %eax,%edx
  1163b9:	8b 45 08             	mov    0x8(%ebp),%eax
  1163bc:	89 50 18             	mov    %edx,0x18(%eax)
    if (conn->acceptmbox == SYS_MBOX_NULL) {
  1163bf:	8b 45 08             	mov    0x8(%ebp),%eax
  1163c2:	8b 40 18             	mov    0x18(%eax),%eax
  1163c5:	85 c0                	test   %eax,%eax
  1163c7:	75 09                	jne    1163d2 <netconn_listen+0x42>
      return ERR_MEM;
  1163c9:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  1163d0:	eb 78                	jmp    11644a <netconn_listen+0xba>
    }
  }
  
  if ((msg = memp_malloc(MEMP_API_MSG)) == NULL) {
  1163d2:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  1163d9:	e8 f2 85 ff ff       	call   10e9d0 <memp_malloc>
  1163de:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  1163e1:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  1163e5:	75 10                	jne    1163f7 <netconn_listen+0x67>
    return (conn->err = ERR_MEM);
  1163e7:	8b 45 08             	mov    0x8(%ebp),%eax
  1163ea:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  1163ee:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  1163f5:	eb 53                	jmp    11644a <netconn_listen+0xba>
  }
  msg->type = API_MSG_LISTEN;
  1163f7:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1163fa:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
  msg->msg.conn = conn;
  116400:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  116403:	8b 45 08             	mov    0x8(%ebp),%eax
  116406:	89 42 04             	mov    %eax,0x4(%edx)
  api_msg_post(msg);
  116409:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  11640c:	89 04 24             	mov    %eax,(%esp)
  11640f:	e8 9c 1a 00 00       	call   117eb0 <api_msg_post>
  sys_mbox_fetch(conn->mbox, NULL);
  116414:	8b 45 08             	mov    0x8(%ebp),%eax
  116417:	8b 40 10             	mov    0x10(%eax),%eax
  11641a:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  116421:	00 
  116422:	89 04 24             	mov    %eax,(%esp)
  116425:	e8 e6 98 ff ff       	call   10fd10 <sys_mbox_fetch>
  memp_free(MEMP_API_MSG, msg);
  11642a:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  11642d:	89 44 24 04          	mov    %eax,0x4(%esp)
  116431:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  116438:	e8 83 86 ff ff       	call   10eac0 <memp_free>
  return conn->err;
  11643d:	8b 45 08             	mov    0x8(%ebp),%eax
  116440:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
  116444:	0f be c0             	movsbl %al,%eax
  116447:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  11644a:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  11644d:	c9                   	leave  
  11644e:	c3                   	ret    
  11644f:	90                   	nop    

00116450 <netconn_accept>:

struct netconn *
netconn_accept(struct netconn *conn)
{
  116450:	55                   	push   %ebp
  116451:	89 e5                	mov    %esp,%ebp
  116453:	83 ec 28             	sub    $0x28,%esp
  struct netconn *newconn;
  
  if (conn == NULL) {
  116456:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  11645a:	75 09                	jne    116465 <netconn_accept+0x15>
    return NULL;
  11645c:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  116463:	eb 43                	jmp    1164a8 <netconn_accept+0x58>
  }
  
  sys_mbox_fetch(conn->acceptmbox, (void **)&newconn);
  116465:	8d 55 fc             	lea    0xfffffffc(%ebp),%edx
  116468:	8b 45 08             	mov    0x8(%ebp),%eax
  11646b:	8b 40 18             	mov    0x18(%eax),%eax
  11646e:	89 54 24 04          	mov    %edx,0x4(%esp)
  116472:	89 04 24             	mov    %eax,(%esp)
  116475:	e8 96 98 ff ff       	call   10fd10 <sys_mbox_fetch>
  /* Register event with callback */
  if (conn->callback)
  11647a:	8b 45 08             	mov    0x8(%ebp),%eax
  11647d:	8b 40 28             	mov    0x28(%eax),%eax
  116480:	85 c0                	test   %eax,%eax
  116482:	74 1e                	je     1164a2 <netconn_accept+0x52>
      (*conn->callback)(conn, NETCONN_EVT_RCVMINUS, 0);
  116484:	8b 45 08             	mov    0x8(%ebp),%eax
  116487:	8b 50 28             	mov    0x28(%eax),%edx
  11648a:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  116491:	00 
  116492:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  116499:	00 
  11649a:	8b 45 08             	mov    0x8(%ebp),%eax
  11649d:	89 04 24             	mov    %eax,(%esp)
  1164a0:	ff d2                	call   *%edx
  
  return newconn;
  1164a2:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1164a5:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  1164a8:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  1164ab:	c9                   	leave  
  1164ac:	c3                   	ret    
  1164ad:	8d 76 00             	lea    0x0(%esi),%esi

001164b0 <netconn_recv>:

struct netbuf *
netconn_recv(struct netconn *conn)
{
  1164b0:	55                   	push   %ebp
  1164b1:	89 e5                	mov    %esp,%ebp
  1164b3:	83 ec 28             	sub    $0x28,%esp
  struct api_msg *msg;
  struct netbuf *buf;
  struct pbuf *p;
  u16_t len;
    
  if (conn == NULL) {
  1164b6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  1164ba:	75 0c                	jne    1164c8 <netconn_recv+0x18>
    return NULL;
  1164bc:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  1164c3:	e9 4e 02 00 00       	jmp    116716 <netconn_recv+0x266>
  }
  
  if (conn->recvmbox == SYS_MBOX_NULL) {
  1164c8:	8b 45 08             	mov    0x8(%ebp),%eax
  1164cb:	8b 40 14             	mov    0x14(%eax),%eax
  1164ce:	85 c0                	test   %eax,%eax
  1164d0:	75 13                	jne    1164e5 <netconn_recv+0x35>
    conn->err = ERR_CONN;
  1164d2:	8b 45 08             	mov    0x8(%ebp),%eax
  1164d5:	c6 40 0c fa          	movb   $0xfa,0xc(%eax)
    return NULL;
  1164d9:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  1164e0:	e9 31 02 00 00       	jmp    116716 <netconn_recv+0x266>
  }

  if (conn->err != ERR_OK) {
  1164e5:	8b 45 08             	mov    0x8(%ebp),%eax
  1164e8:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
  1164ec:	84 c0                	test   %al,%al
  1164ee:	74 0c                	je     1164fc <netconn_recv+0x4c>
    return NULL;
  1164f0:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  1164f7:	e9 1a 02 00 00       	jmp    116716 <netconn_recv+0x266>
  }

  if (conn->type == NETCONN_TCP) {
  1164fc:	8b 45 08             	mov    0x8(%ebp),%eax
  1164ff:	8b 00                	mov    (%eax),%eax
  116501:	85 c0                	test   %eax,%eax
  116503:	0f 85 a8 01 00 00    	jne    1166b1 <netconn_recv+0x201>
    if (conn->pcb.tcp->state == LISTEN) {
  116509:	8b 45 08             	mov    0x8(%ebp),%eax
  11650c:	8b 40 08             	mov    0x8(%eax),%eax
  11650f:	8b 40 10             	mov    0x10(%eax),%eax
  116512:	83 f8 01             	cmp    $0x1,%eax
  116515:	75 13                	jne    11652a <netconn_recv+0x7a>
      conn->err = ERR_CONN;
  116517:	8b 45 08             	mov    0x8(%ebp),%eax
  11651a:	c6 40 0c fa          	movb   $0xfa,0xc(%eax)
      return NULL;
  11651e:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  116525:	e9 ec 01 00 00       	jmp    116716 <netconn_recv+0x266>
    }


    buf = memp_malloc(MEMP_NETBUF);
  11652a:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  116531:	e8 9a 84 ff ff       	call   10e9d0 <memp_malloc>
  116536:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)

    if (buf == NULL) {
  116539:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  11653c:	85 c0                	test   %eax,%eax
  11653e:	75 13                	jne    116553 <netconn_recv+0xa3>
      conn->err = ERR_MEM;
  116540:	8b 45 08             	mov    0x8(%ebp),%eax
  116543:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
      return NULL;
  116547:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  11654e:	e9 c3 01 00 00       	jmp    116716 <netconn_recv+0x266>
    }
    
    sys_mbox_fetch(conn->recvmbox, (void **)&p);
  116553:	8d 55 f0             	lea    0xfffffff0(%ebp),%edx
  116556:	8b 45 08             	mov    0x8(%ebp),%eax
  116559:	8b 40 14             	mov    0x14(%eax),%eax
  11655c:	89 54 24 04          	mov    %edx,0x4(%esp)
  116560:	89 04 24             	mov    %eax,(%esp)
  116563:	e8 a8 97 ff ff       	call   10fd10 <sys_mbox_fetch>

    if (p != NULL)
  116568:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  11656b:	85 c0                	test   %eax,%eax
  11656d:	74 21                	je     116590 <netconn_recv+0xe0>
    {
        len = p->tot_len;
  11656f:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  116572:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  116576:	66 89 45 fe          	mov    %ax,0xfffffffe(%ebp)
        conn->recv_avail -= len;
  11657a:	8b 45 08             	mov    0x8(%ebp),%eax
  11657d:	0f b7 40 24          	movzwl 0x24(%eax),%eax
  116581:	89 c2                	mov    %eax,%edx
  116583:	66 2b 55 fe          	sub    0xfffffffe(%ebp),%dx
  116587:	8b 45 08             	mov    0x8(%ebp),%eax
  11658a:	66 89 50 24          	mov    %dx,0x24(%eax)
  11658e:	eb 06                	jmp    116596 <netconn_recv+0xe6>
    }
    else
        len = 0;
  116590:	66 c7 45 fe 00 00    	movw   $0x0,0xfffffffe(%ebp)
    
    /* Register event with callback */
      if (conn->callback)
  116596:	8b 45 08             	mov    0x8(%ebp),%eax
  116599:	8b 40 28             	mov    0x28(%eax),%eax
  11659c:	85 c0                	test   %eax,%eax
  11659e:	74 1e                	je     1165be <netconn_recv+0x10e>
        (*conn->callback)(conn, NETCONN_EVT_RCVMINUS, len);
  1165a0:	8b 45 08             	mov    0x8(%ebp),%eax
  1165a3:	8b 50 28             	mov    0x28(%eax),%edx
  1165a6:	0f b7 45 fe          	movzwl 0xfffffffe(%ebp),%eax
  1165aa:	89 44 24 08          	mov    %eax,0x8(%esp)
  1165ae:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  1165b5:	00 
  1165b6:	8b 45 08             	mov    0x8(%ebp),%eax
  1165b9:	89 04 24             	mov    %eax,(%esp)
  1165bc:	ff d2                	call   *%edx

    /* If we are closed, we indicate that we no longer wish to receive
       data by setting conn->recvmbox to SYS_MBOX_NULL. */
    if (p == NULL) {
  1165be:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  1165c1:	85 c0                	test   %eax,%eax
  1165c3:	75 37                	jne    1165fc <netconn_recv+0x14c>
      memp_free(MEMP_NETBUF, buf);
  1165c5:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  1165c8:	89 44 24 04          	mov    %eax,0x4(%esp)
  1165cc:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  1165d3:	e8 e8 84 ff ff       	call   10eac0 <memp_free>
      sys_mbox_free(conn->recvmbox);
  1165d8:	8b 45 08             	mov    0x8(%ebp),%eax
  1165db:	8b 40 14             	mov    0x14(%eax),%eax
  1165de:	89 04 24             	mov    %eax,(%esp)
  1165e1:	e8 3a 39 00 00       	call   119f20 <sys_mbox_free>
      conn->recvmbox = SYS_MBOX_NULL;
  1165e6:	8b 45 08             	mov    0x8(%ebp),%eax
  1165e9:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
      return NULL;
  1165f0:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  1165f7:	e9 1a 01 00 00       	jmp    116716 <netconn_recv+0x266>
    }

    buf->p = p;
  1165fc:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
  1165ff:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  116602:	89 02                	mov    %eax,(%edx)
    buf->ptr = p;
  116604:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
  116607:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  11660a:	89 42 04             	mov    %eax,0x4(%edx)
    buf->fromport = 0;
  11660d:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  116610:	66 c7 40 0c 00 00    	movw   $0x0,0xc(%eax)
    buf->fromaddr = NULL;
  116616:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  116619:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)

    /* Let the stack know that we have taken the data. */
    if ((msg = memp_malloc(MEMP_API_MSG)) == NULL) {
  116620:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  116627:	e8 a4 83 ff ff       	call   10e9d0 <memp_malloc>
  11662c:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  11662f:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  116633:	75 12                	jne    116647 <netconn_recv+0x197>
      conn->err = ERR_MEM;
  116635:	8b 45 08             	mov    0x8(%ebp),%eax
  116638:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
      return buf;
  11663c:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  11663f:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  116642:	e9 cf 00 00 00       	jmp    116716 <netconn_recv+0x266>
    }
    msg->type = API_MSG_RECV;
  116647:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  11664a:	c7 00 08 00 00 00    	movl   $0x8,(%eax)
    msg->msg.conn = conn;
  116650:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  116653:	8b 45 08             	mov    0x8(%ebp),%eax
  116656:	89 42 04             	mov    %eax,0x4(%edx)
    if (buf != NULL) {
  116659:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  11665c:	85 c0                	test   %eax,%eax
  11665e:	74 12                	je     116672 <netconn_recv+0x1c2>
      msg->msg.msg.len = buf->p->tot_len;
  116660:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  116663:	8b 00                	mov    (%eax),%eax
  116665:	0f b7 50 08          	movzwl 0x8(%eax),%edx
  116669:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  11666c:	66 89 50 0c          	mov    %dx,0xc(%eax)
  116670:	eb 09                	jmp    11667b <netconn_recv+0x1cb>
    } else {
      msg->msg.msg.len = 1;
  116672:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  116675:	66 c7 40 0c 01 00    	movw   $0x1,0xc(%eax)
    }
    api_msg_post(msg);
  11667b:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  11667e:	89 04 24             	mov    %eax,(%esp)
  116681:	e8 2a 18 00 00       	call   117eb0 <api_msg_post>

    sys_mbox_fetch(conn->mbox, NULL);
  116686:	8b 45 08             	mov    0x8(%ebp),%eax
  116689:	8b 40 10             	mov    0x10(%eax),%eax
  11668c:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  116693:	00 
  116694:	89 04 24             	mov    %eax,(%esp)
  116697:	e8 74 96 ff ff       	call   10fd10 <sys_mbox_fetch>
    memp_free(MEMP_API_MSG, msg);
  11669c:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  11669f:	89 44 24 04          	mov    %eax,0x4(%esp)
  1166a3:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  1166aa:	e8 11 84 ff ff       	call   10eac0 <memp_free>
  1166af:	eb 5f                	jmp    116710 <netconn_recv+0x260>
  } else {
    sys_mbox_fetch(conn->recvmbox, (void **)&buf);
  1166b1:	8d 55 f4             	lea    0xfffffff4(%ebp),%edx
  1166b4:	8b 45 08             	mov    0x8(%ebp),%eax
  1166b7:	8b 40 14             	mov    0x14(%eax),%eax
  1166ba:	89 54 24 04          	mov    %edx,0x4(%esp)
  1166be:	89 04 24             	mov    %eax,(%esp)
  1166c1:	e8 4a 96 ff ff       	call   10fd10 <sys_mbox_fetch>
  conn->recv_avail -= buf->p->tot_len;
  1166c6:	8b 45 08             	mov    0x8(%ebp),%eax
  1166c9:	0f b7 50 24          	movzwl 0x24(%eax),%edx
  1166cd:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  1166d0:	8b 00                	mov    (%eax),%eax
  1166d2:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  1166d6:	66 29 c2             	sub    %ax,%dx
  1166d9:	8b 45 08             	mov    0x8(%ebp),%eax
  1166dc:	66 89 50 24          	mov    %dx,0x24(%eax)
    /* Register event with callback */
    if (conn->callback)
  1166e0:	8b 45 08             	mov    0x8(%ebp),%eax
  1166e3:	8b 40 28             	mov    0x28(%eax),%eax
  1166e6:	85 c0                	test   %eax,%eax
  1166e8:	74 26                	je     116710 <netconn_recv+0x260>
        (*conn->callback)(conn, NETCONN_EVT_RCVMINUS, buf->p->tot_len);
  1166ea:	8b 45 08             	mov    0x8(%ebp),%eax
  1166ed:	8b 50 28             	mov    0x28(%eax),%edx
  1166f0:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  1166f3:	8b 00                	mov    (%eax),%eax
  1166f5:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  1166f9:	0f b7 c0             	movzwl %ax,%eax
  1166fc:	89 44 24 08          	mov    %eax,0x8(%esp)
  116700:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  116707:	00 
  116708:	8b 45 08             	mov    0x8(%ebp),%eax
  11670b:	89 04 24             	mov    %eax,(%esp)
  11670e:	ff d2                	call   *%edx
  }

  

    
  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_recv: received %p (err %d)\n", (void *)buf, conn->err));


  return buf;
  116710:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  116713:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  116716:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  116719:	c9                   	leave  
  11671a:	c3                   	ret    
  11671b:	90                   	nop    
  11671c:	8d 74 26 00          	lea    0x0(%esi),%esi

00116720 <netconn_send>:

err_t
netconn_send(struct netconn *conn, struct netbuf *buf)
{
  116720:	55                   	push   %ebp
  116721:	89 e5                	mov    %esp,%ebp
  116723:	83 ec 28             	sub    $0x28,%esp
  struct api_msg *msg;

  if (conn == NULL) {
  116726:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  11672a:	75 0c                	jne    116738 <netconn_send+0x18>
    return ERR_VAL;
  11672c:	c7 45 ec f9 ff ff ff 	movl   $0xfffffff9,0xffffffec(%ebp)
  116733:	e9 a0 00 00 00       	jmp    1167d8 <netconn_send+0xb8>
  }

  if (conn->err != ERR_OK) {
  116738:	8b 45 08             	mov    0x8(%ebp),%eax
  11673b:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
  11673f:	84 c0                	test   %al,%al
  116741:	74 12                	je     116755 <netconn_send+0x35>
    return conn->err;
  116743:	8b 45 08             	mov    0x8(%ebp),%eax
  116746:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
  11674a:	0f be c0             	movsbl %al,%eax
  11674d:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  116750:	e9 83 00 00 00       	jmp    1167d8 <netconn_send+0xb8>
  }

  if ((msg = memp_malloc(MEMP_API_MSG)) == NULL) {
  116755:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  11675c:	e8 6f 82 ff ff       	call   10e9d0 <memp_malloc>
  116761:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  116764:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  116768:	75 10                	jne    11677a <netconn_send+0x5a>
    return (conn->err = ERR_MEM);
  11676a:	8b 45 08             	mov    0x8(%ebp),%eax
  11676d:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  116771:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  116778:	eb 5e                	jmp    1167d8 <netconn_send+0xb8>
  }

  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_send: sending %d bytes\n", buf->p->tot_len));
  msg->type = API_MSG_SEND;
  11677a:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  11677d:	c7 00 07 00 00 00    	movl   $0x7,(%eax)
  msg->msg.conn = conn;
  116783:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  116786:	8b 45 08             	mov    0x8(%ebp),%eax
  116789:	89 42 04             	mov    %eax,0x4(%edx)
  msg->msg.msg.p = buf->p;
  11678c:	8b 45 0c             	mov    0xc(%ebp),%eax
  11678f:	8b 10                	mov    (%eax),%edx
  116791:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  116794:	89 50 0c             	mov    %edx,0xc(%eax)
  api_msg_post(msg);
  116797:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  11679a:	89 04 24             	mov    %eax,(%esp)
  11679d:	e8 0e 17 00 00       	call   117eb0 <api_msg_post>

  sys_mbox_fetch(conn->mbox, NULL);
  1167a2:	8b 45 08             	mov    0x8(%ebp),%eax
  1167a5:	8b 40 10             	mov    0x10(%eax),%eax
  1167a8:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  1167af:	00 
  1167b0:	89 04 24             	mov    %eax,(%esp)
  1167b3:	e8 58 95 ff ff       	call   10fd10 <sys_mbox_fetch>
  memp_free(MEMP_API_MSG, msg);
  1167b8:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1167bb:	89 44 24 04          	mov    %eax,0x4(%esp)
  1167bf:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  1167c6:	e8 f5 82 ff ff       	call   10eac0 <memp_free>
  return conn->err;
  1167cb:	8b 45 08             	mov    0x8(%ebp),%eax
  1167ce:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
  1167d2:	0f be c0             	movsbl %al,%eax
  1167d5:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  1167d8:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  1167db:	c9                   	leave  
  1167dc:	c3                   	ret    
  1167dd:	8d 76 00             	lea    0x0(%esi),%esi

001167e0 <netconn_write>:

err_t
netconn_write(struct netconn *conn, void *dataptr, u16_t size, u8_t copy)
{
  1167e0:	55                   	push   %ebp
  1167e1:	89 e5                	mov    %esp,%ebp
  1167e3:	83 ec 28             	sub    $0x28,%esp
  1167e6:	8b 45 10             	mov    0x10(%ebp),%eax
  1167e9:	8b 55 14             	mov    0x14(%ebp),%edx
  1167ec:	66 89 45 ec          	mov    %ax,0xffffffec(%ebp)
  1167f0:	88 55 e8             	mov    %dl,0xffffffe8(%ebp)
  struct api_msg *msg;
  u16_t len;
  
  if (conn == NULL) {
  1167f3:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  1167f7:	75 0c                	jne    116805 <netconn_write+0x25>
    return ERR_VAL;
  1167f9:	c7 45 e4 f9 ff ff ff 	movl   $0xfffffff9,0xffffffe4(%ebp)
  116800:	e9 e6 01 00 00       	jmp    1169eb <netconn_write+0x20b>
  }

  if (conn->err != ERR_OK) {
  116805:	8b 45 08             	mov    0x8(%ebp),%eax
  116808:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
  11680c:	84 c0                	test   %al,%al
  11680e:	74 12                	je     116822 <netconn_write+0x42>
    return conn->err;
  116810:	8b 45 08             	mov    0x8(%ebp),%eax
  116813:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
  116817:	0f be c0             	movsbl %al,%eax
  11681a:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
  11681d:	e9 c9 01 00 00       	jmp    1169eb <netconn_write+0x20b>
  }
  
  if (conn->sem == SYS_SEM_NULL) {
  116822:	8b 45 08             	mov    0x8(%ebp),%eax
  116825:	8b 40 1c             	mov    0x1c(%eax),%eax
  116828:	85 c0                	test   %eax,%eax
  11682a:	75 2a                	jne    116856 <netconn_write+0x76>
    conn->sem = sys_sem_new(0);
  11682c:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  116833:	e8 18 35 00 00       	call   119d50 <sys_sem_new>
  116838:	89 c2                	mov    %eax,%edx
  11683a:	8b 45 08             	mov    0x8(%ebp),%eax
  11683d:	89 50 1c             	mov    %edx,0x1c(%eax)
    if (conn->sem == SYS_SEM_NULL) {
  116840:	8b 45 08             	mov    0x8(%ebp),%eax
  116843:	8b 40 1c             	mov    0x1c(%eax),%eax
  116846:	85 c0                	test   %eax,%eax
  116848:	75 0c                	jne    116856 <netconn_write+0x76>
      return ERR_MEM;
  11684a:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,0xffffffe4(%ebp)
  116851:	e9 95 01 00 00       	jmp    1169eb <netconn_write+0x20b>
    }
  }

  if ((msg = memp_malloc(MEMP_API_MSG)) == NULL) {
  116856:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  11685d:	e8 6e 81 ff ff       	call   10e9d0 <memp_malloc>
  116862:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  116865:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  116869:	75 13                	jne    11687e <netconn_write+0x9e>
    return (conn->err = ERR_MEM);
  11686b:	8b 45 08             	mov    0x8(%ebp),%eax
  11686e:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  116872:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,0xffffffe4(%ebp)
  116879:	e9 6d 01 00 00       	jmp    1169eb <netconn_write+0x20b>
  }
  msg->type = API_MSG_WRITE;
  11687e:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  116881:	c7 00 09 00 00 00    	movl   $0x9,(%eax)
  msg->msg.conn = conn;
  116887:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  11688a:	8b 45 08             	mov    0x8(%ebp),%eax
  11688d:	89 42 04             	mov    %eax,0x4(%edx)
        

  conn->state = NETCONN_WRITE;
  116890:	8b 45 08             	mov    0x8(%ebp),%eax
  116893:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
  while (conn->err == ERR_OK && size > 0) {
  11689a:	e9 ea 00 00 00       	jmp    116989 <netconn_write+0x1a9>
    msg->msg.msg.w.dataptr = dataptr;
  11689f:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  1168a2:	8b 45 0c             	mov    0xc(%ebp),%eax
  1168a5:	89 42 0c             	mov    %eax,0xc(%edx)
    msg->msg.msg.w.copy = copy;
  1168a8:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  1168ab:	0f b6 45 e8          	movzbl 0xffffffe8(%ebp),%eax
  1168af:	88 42 12             	mov    %al,0x12(%edx)
    
    if (conn->type == NETCONN_TCP) {
  1168b2:	8b 45 08             	mov    0x8(%ebp),%eax
  1168b5:	8b 00                	mov    (%eax),%eax
  1168b7:	85 c0                	test   %eax,%eax
  1168b9:	75 56                	jne    116911 <netconn_write+0x131>
      if (tcp_sndbuf(conn->pcb.tcp) == 0) {
  1168bb:	8b 45 08             	mov    0x8(%ebp),%eax
  1168be:	8b 40 08             	mov    0x8(%eax),%eax
  1168c1:	0f b7 40 6a          	movzwl 0x6a(%eax),%eax
  1168c5:	66 85 c0             	test   %ax,%ax
  1168c8:	75 1d                	jne    1168e7 <netconn_write+0x107>
  sys_sem_wait(conn->sem);
  1168ca:	8b 45 08             	mov    0x8(%ebp),%eax
  1168cd:	8b 40 1c             	mov    0x1c(%eax),%eax
  1168d0:	89 04 24             	mov    %eax,(%esp)
  1168d3:	e8 38 95 ff ff       	call   10fe10 <sys_sem_wait>
  if (conn->err != ERR_OK) {
  1168d8:	8b 45 08             	mov    0x8(%ebp),%eax
  1168db:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
  1168df:	84 c0                	test   %al,%al
  1168e1:	0f 85 b8 00 00 00    	jne    11699f <netconn_write+0x1bf>
    goto ret;
  }
      }
      if (size > tcp_sndbuf(conn->pcb.tcp)) {
  1168e7:	8b 45 08             	mov    0x8(%ebp),%eax
  1168ea:	8b 40 08             	mov    0x8(%eax),%eax
  1168ed:	0f b7 40 6a          	movzwl 0x6a(%eax),%eax
  1168f1:	66 3b 45 ec          	cmp    0xffffffec(%ebp),%ax
  1168f5:	73 10                	jae    116907 <netconn_write+0x127>
  /* We cannot send more than one send buffer's worth of data at a
     time. */
  len = tcp_sndbuf(conn->pcb.tcp);
  1168f7:	8b 45 08             	mov    0x8(%ebp),%eax
  1168fa:	8b 40 08             	mov    0x8(%eax),%eax
  1168fd:	0f b7 40 6a          	movzwl 0x6a(%eax),%eax
  116901:	66 89 45 fe          	mov    %ax,0xfffffffe(%ebp)
  116905:	eb 12                	jmp    116919 <netconn_write+0x139>
      } else {
  len = size;
  116907:	0f b7 45 ec          	movzwl 0xffffffec(%ebp),%eax
  11690b:	66 89 45 fe          	mov    %ax,0xfffffffe(%ebp)
  11690f:	eb 08                	jmp    116919 <netconn_write+0x139>
      }
    } else {
      len = size;
  116911:	0f b7 45 ec          	movzwl 0xffffffec(%ebp),%eax
  116915:	66 89 45 fe          	mov    %ax,0xfffffffe(%ebp)
    }
    
    LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_write: writing %d bytes (%d)\n", len, copy));
    msg->msg.msg.w.len = len;
  116919:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  11691c:	0f b7 45 fe          	movzwl 0xfffffffe(%ebp),%eax
  116920:	66 89 42 10          	mov    %ax,0x10(%edx)
    api_msg_post(msg);
  116924:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  116927:	89 04 24             	mov    %eax,(%esp)
  11692a:	e8 81 15 00 00       	call   117eb0 <api_msg_post>
    sys_mbox_fetch(conn->mbox, NULL);    
  11692f:	8b 45 08             	mov    0x8(%ebp),%eax
  116932:	8b 40 10             	mov    0x10(%eax),%eax
  116935:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  11693c:	00 
  11693d:	89 04 24             	mov    %eax,(%esp)
  116940:	e8 cb 93 ff ff       	call   10fd10 <sys_mbox_fetch>
    if (conn->err == ERR_OK) {
  116945:	8b 45 08             	mov    0x8(%ebp),%eax
  116948:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
  11694c:	84 c0                	test   %al,%al
  11694e:	75 19                	jne    116969 <netconn_write+0x189>
      dataptr = (void *)((char *)dataptr + len);
  116950:	0f b7 45 fe          	movzwl 0xfffffffe(%ebp),%eax
  116954:	89 c2                	mov    %eax,%edx
  116956:	8b 45 0c             	mov    0xc(%ebp),%eax
  116959:	8d 04 02             	lea    (%edx,%eax,1),%eax
  11695c:	89 45 0c             	mov    %eax,0xc(%ebp)
      size -= len;
  11695f:	0f b7 45 fe          	movzwl 0xfffffffe(%ebp),%eax
  116963:	66 29 45 ec          	sub    %ax,0xffffffec(%ebp)
  116967:	eb 20                	jmp    116989 <netconn_write+0x1a9>
    } else if (conn->err == ERR_MEM) {
  116969:	8b 45 08             	mov    0x8(%ebp),%eax
  11696c:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
  116970:	3c ff                	cmp    $0xff,%al
  116972:	75 2b                	jne    11699f <netconn_write+0x1bf>
      conn->err = ERR_OK;
  116974:	8b 45 08             	mov    0x8(%ebp),%eax
  116977:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
      sys_sem_wait(conn->sem);
  11697b:	8b 45 08             	mov    0x8(%ebp),%eax
  11697e:	8b 40 1c             	mov    0x1c(%eax),%eax
  116981:	89 04 24             	mov    %eax,(%esp)
  116984:	e8 87 94 ff ff       	call   10fe10 <sys_sem_wait>
  116989:	8b 45 08             	mov    0x8(%ebp),%eax
  11698c:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
  116990:	84 c0                	test   %al,%al
  116992:	75 0b                	jne    11699f <netconn_write+0x1bf>
  116994:	66 83 7d ec 00       	cmpw   $0x0,0xffffffec(%ebp)
  116999:	0f 85 00 ff ff ff    	jne    11689f <netconn_write+0xbf>
    } else {
      goto ret;
    }
  }
 ret:
  memp_free(MEMP_API_MSG, msg);
  11699f:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1169a2:	89 44 24 04          	mov    %eax,0x4(%esp)
  1169a6:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  1169ad:	e8 0e 81 ff ff       	call   10eac0 <memp_free>
  conn->state = NETCONN_NONE;
  1169b2:	8b 45 08             	mov    0x8(%ebp),%eax
  1169b5:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  if (conn->sem != SYS_SEM_NULL) {
  1169bc:	8b 45 08             	mov    0x8(%ebp),%eax
  1169bf:	8b 40 1c             	mov    0x1c(%eax),%eax
  1169c2:	85 c0                	test   %eax,%eax
  1169c4:	74 18                	je     1169de <netconn_write+0x1fe>
    sys_sem_free(conn->sem);
  1169c6:	8b 45 08             	mov    0x8(%ebp),%eax
  1169c9:	8b 40 1c             	mov    0x1c(%eax),%eax
  1169cc:	89 04 24             	mov    %eax,(%esp)
  1169cf:	e8 cc 33 00 00       	call   119da0 <sys_sem_free>
    conn->sem = SYS_SEM_NULL;
  1169d4:	8b 45 08             	mov    0x8(%ebp),%eax
  1169d7:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
  }
  
  return conn->err;
  1169de:	8b 45 08             	mov    0x8(%ebp),%eax
  1169e1:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
  1169e5:	0f be c0             	movsbl %al,%eax
  1169e8:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
  1169eb:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
}
  1169ee:	c9                   	leave  
  1169ef:	c3                   	ret    

001169f0 <netconn_close>:

err_t
netconn_close(struct netconn *conn)
{
  1169f0:	55                   	push   %ebp
  1169f1:	89 e5                	mov    %esp,%ebp
  1169f3:	83 ec 28             	sub    $0x28,%esp
  struct api_msg *msg;

  if (conn == NULL) {
  1169f6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  1169fa:	75 0c                	jne    116a08 <netconn_close+0x18>
    return ERR_VAL;
  1169fc:	c7 45 ec f9 ff ff ff 	movl   $0xfffffff9,0xffffffec(%ebp)
  116a03:	e9 b4 00 00 00       	jmp    116abc <netconn_close+0xcc>
  }
  if ((msg = memp_malloc(MEMP_API_MSG)) == NULL) {
  116a08:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  116a0f:	e8 bc 7f ff ff       	call   10e9d0 <memp_malloc>
  116a14:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  116a17:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  116a1b:	75 13                	jne    116a30 <netconn_close+0x40>
    return (conn->err = ERR_MEM);
  116a1d:	8b 45 08             	mov    0x8(%ebp),%eax
  116a20:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  116a24:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  116a2b:	e9 8c 00 00 00       	jmp    116abc <netconn_close+0xcc>
  }

  conn->state = NETCONN_CLOSE;
  116a30:	8b 45 08             	mov    0x8(%ebp),%eax
  116a33:	c7 40 04 05 00 00 00 	movl   $0x5,0x4(%eax)
 again:
  msg->type = API_MSG_CLOSE;
  116a3a:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  116a3d:	c7 00 0a 00 00 00    	movl   $0xa,(%eax)
  msg->msg.conn = conn;
  116a43:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  116a46:	8b 45 08             	mov    0x8(%ebp),%eax
  116a49:	89 42 04             	mov    %eax,0x4(%edx)
  api_msg_post(msg);
  116a4c:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  116a4f:	89 04 24             	mov    %eax,(%esp)
  116a52:	e8 59 14 00 00       	call   117eb0 <api_msg_post>
  sys_mbox_fetch(conn->mbox, NULL);
  116a57:	8b 45 08             	mov    0x8(%ebp),%eax
  116a5a:	8b 40 10             	mov    0x10(%eax),%eax
  116a5d:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  116a64:	00 
  116a65:	89 04 24             	mov    %eax,(%esp)
  116a68:	e8 a3 92 ff ff       	call   10fd10 <sys_mbox_fetch>
  if (conn->err == ERR_MEM &&
  116a6d:	8b 45 08             	mov    0x8(%ebp),%eax
  116a70:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
  116a74:	3c ff                	cmp    $0xff,%al
  116a76:	75 1a                	jne    116a92 <netconn_close+0xa2>
  116a78:	8b 45 08             	mov    0x8(%ebp),%eax
  116a7b:	8b 40 1c             	mov    0x1c(%eax),%eax
  116a7e:	85 c0                	test   %eax,%eax
  116a80:	74 10                	je     116a92 <netconn_close+0xa2>
     conn->sem != SYS_SEM_NULL) {
    sys_sem_wait(conn->sem);
  116a82:	8b 45 08             	mov    0x8(%ebp),%eax
  116a85:	8b 40 1c             	mov    0x1c(%eax),%eax
  116a88:	89 04 24             	mov    %eax,(%esp)
  116a8b:	e8 80 93 ff ff       	call   10fe10 <sys_sem_wait>
    goto again;
  116a90:	eb a8                	jmp    116a3a <netconn_close+0x4a>
  }
  conn->state = NETCONN_NONE;
  116a92:	8b 45 08             	mov    0x8(%ebp),%eax
  116a95:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  memp_free(MEMP_API_MSG, msg);
  116a9c:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  116a9f:	89 44 24 04          	mov    %eax,0x4(%esp)
  116aa3:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  116aaa:	e8 11 80 ff ff       	call   10eac0 <memp_free>
  return conn->err;
  116aaf:	8b 45 08             	mov    0x8(%ebp),%eax
  116ab2:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
  116ab6:	0f be c0             	movsbl %al,%eax
  116ab9:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  116abc:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  116abf:	c9                   	leave  
  116ac0:	c3                   	ret    
  116ac1:	eb 0d                	jmp    116ad0 <netconn_err>
  116ac3:	90                   	nop    
  116ac4:	90                   	nop    
  116ac5:	90                   	nop    
  116ac6:	90                   	nop    
  116ac7:	90                   	nop    
  116ac8:	90                   	nop    
  116ac9:	90                   	nop    
  116aca:	90                   	nop    
  116acb:	90                   	nop    
  116acc:	90                   	nop    
  116acd:	90                   	nop    
  116ace:	90                   	nop    
  116acf:	90                   	nop    

00116ad0 <netconn_err>:

err_t
netconn_err(struct netconn *conn)
{
  116ad0:	55                   	push   %ebp
  116ad1:	89 e5                	mov    %esp,%ebp
  return conn->err;
  116ad3:	8b 45 08             	mov    0x8(%ebp),%eax
  116ad6:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
  116ada:	0f be c0             	movsbl %al,%eax
}
  116add:	5d                   	pop    %ebp
  116ade:	c3                   	ret    
  116adf:	90                   	nop    

00116ae0 <recv_raw>:
#if LWIP_RAW
static int
recv_raw(void *arg, struct raw_pcb *pcb, struct pbuf *p,
    struct ip_addr *addr)
{
  116ae0:	55                   	push   %ebp
  116ae1:	89 e5                	mov    %esp,%ebp
  116ae3:	83 ec 28             	sub    $0x28,%esp
  struct netbuf *buf;
  struct netconn *conn;

  conn = arg;
  116ae6:	8b 45 08             	mov    0x8(%ebp),%eax
  116ae9:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  if (!conn) return 0;
  116aec:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  116af0:	75 0c                	jne    116afe <recv_raw+0x1e>
  116af2:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  116af9:	e9 c3 00 00 00       	jmp    116bc1 <recv_raw+0xe1>

  if (conn->recvmbox != SYS_MBOX_NULL) {
  116afe:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  116b01:	8b 40 14             	mov    0x14(%eax),%eax
  116b04:	85 c0                	test   %eax,%eax
  116b06:	0f 84 ae 00 00 00    	je     116bba <recv_raw+0xda>
    if (!(buf = memp_malloc(MEMP_NETBUF))) {
  116b0c:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  116b13:	e8 b8 7e ff ff       	call   10e9d0 <memp_malloc>
  116b18:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  116b1b:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  116b1f:	75 0c                	jne    116b2d <recv_raw+0x4d>
      return 0;
  116b21:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  116b28:	e9 94 00 00 00       	jmp    116bc1 <recv_raw+0xe1>
    }
    pbuf_ref(p);
  116b2d:	8b 45 10             	mov    0x10(%ebp),%eax
  116b30:	89 04 24             	mov    %eax,(%esp)
  116b33:	e8 f8 8a ff ff       	call   10f630 <pbuf_ref>
    buf->p = p;
  116b38:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  116b3b:	8b 45 10             	mov    0x10(%ebp),%eax
  116b3e:	89 02                	mov    %eax,(%edx)
    buf->ptr = p;
  116b40:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  116b43:	8b 45 10             	mov    0x10(%ebp),%eax
  116b46:	89 42 04             	mov    %eax,0x4(%edx)
    buf->fromaddr = addr;
  116b49:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  116b4c:	8b 45 14             	mov    0x14(%ebp),%eax
  116b4f:	89 42 08             	mov    %eax,0x8(%edx)
    buf->fromport = pcb->protocol;
  116b52:	8b 45 0c             	mov    0xc(%ebp),%eax
  116b55:	0f b7 50 10          	movzwl 0x10(%eax),%edx
  116b59:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  116b5c:	66 89 50 0c          	mov    %dx,0xc(%eax)

    conn->recv_avail += p->tot_len;
  116b60:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  116b63:	0f b7 50 24          	movzwl 0x24(%eax),%edx
  116b67:	8b 45 10             	mov    0x10(%ebp),%eax
  116b6a:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  116b6e:	01 c2                	add    %eax,%edx
  116b70:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  116b73:	66 89 50 24          	mov    %dx,0x24(%eax)
    /* Register event with callback */
    if (conn->callback)
  116b77:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  116b7a:	8b 40 28             	mov    0x28(%eax),%eax
  116b7d:	85 c0                	test   %eax,%eax
  116b7f:	74 24                	je     116ba5 <recv_raw+0xc5>
        (*conn->callback)(conn, NETCONN_EVT_RCVPLUS, p->tot_len);
  116b81:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  116b84:	8b 50 28             	mov    0x28(%eax),%edx
  116b87:	8b 45 10             	mov    0x10(%ebp),%eax
  116b8a:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  116b8e:	0f b7 c0             	movzwl %ax,%eax
  116b91:	89 44 24 08          	mov    %eax,0x8(%esp)
  116b95:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  116b9c:	00 
  116b9d:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  116ba0:	89 04 24             	mov    %eax,(%esp)
  116ba3:	ff d2                	call   *%edx
    sys_mbox_post(conn->recvmbox, buf);
  116ba5:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  116ba8:	8b 50 14             	mov    0x14(%eax),%edx
  116bab:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  116bae:	89 44 24 04          	mov    %eax,0x4(%esp)
  116bb2:	89 14 24             	mov    %edx,(%esp)
  116bb5:	e8 d6 33 00 00       	call   119f90 <sys_mbox_post>
  }

  return 0; /* do not eat the packet */
  116bba:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  116bc1:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  116bc4:	c9                   	leave  
  116bc5:	c3                   	ret    
  116bc6:	8d 76 00             	lea    0x0(%esi),%esi
  116bc9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00116bd0 <recv_udp>:
#endif
#if LWIP_UDP
static void
recv_udp(void *arg, struct udp_pcb *pcb, struct pbuf *p,
   struct ip_addr *addr, u16_t port)
{
  116bd0:	55                   	push   %ebp
  116bd1:	89 e5                	mov    %esp,%ebp
  116bd3:	83 ec 28             	sub    $0x28,%esp
  116bd6:	8b 45 18             	mov    0x18(%ebp),%eax
  116bd9:	66 89 45 ec          	mov    %ax,0xffffffec(%ebp)
  struct netbuf *buf;
  struct netconn *conn;

  conn = arg;
  116bdd:	8b 45 08             	mov    0x8(%ebp),%eax
  116be0:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  
  if (conn == NULL) {
  116be3:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  116be7:	75 10                	jne    116bf9 <recv_udp+0x29>
    pbuf_free(p);
  116be9:	8b 45 10             	mov    0x10(%ebp),%eax
  116bec:	89 04 24             	mov    %eax,(%esp)
  116bef:	e8 cc 88 ff ff       	call   10f4c0 <pbuf_free>
    return;
  116bf4:	e9 af 00 00 00       	jmp    116ca8 <recv_udp+0xd8>
  }
  if (conn->recvmbox != SYS_MBOX_NULL) {
  116bf9:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  116bfc:	8b 40 14             	mov    0x14(%eax),%eax
  116bff:	85 c0                	test   %eax,%eax
  116c01:	0f 84 a1 00 00 00    	je     116ca8 <recv_udp+0xd8>
    buf = memp_malloc(MEMP_NETBUF);
  116c07:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  116c0e:	e8 bd 7d ff ff       	call   10e9d0 <memp_malloc>
  116c13:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
    if (buf == NULL) {
  116c16:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  116c1a:	75 0d                	jne    116c29 <recv_udp+0x59>
      pbuf_free(p);
  116c1c:	8b 45 10             	mov    0x10(%ebp),%eax
  116c1f:	89 04 24             	mov    %eax,(%esp)
  116c22:	e8 99 88 ff ff       	call   10f4c0 <pbuf_free>
      return;
  116c27:	eb 7f                	jmp    116ca8 <recv_udp+0xd8>
    } else {
      buf->p = p;
  116c29:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  116c2c:	8b 45 10             	mov    0x10(%ebp),%eax
  116c2f:	89 02                	mov    %eax,(%edx)
      buf->ptr = p;
  116c31:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  116c34:	8b 45 10             	mov    0x10(%ebp),%eax
  116c37:	89 42 04             	mov    %eax,0x4(%edx)
      buf->fromaddr = addr;
  116c3a:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  116c3d:	8b 45 14             	mov    0x14(%ebp),%eax
  116c40:	89 42 08             	mov    %eax,0x8(%edx)
      buf->fromport = port;
  116c43:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  116c46:	0f b7 45 ec          	movzwl 0xffffffec(%ebp),%eax
  116c4a:	66 89 42 0c          	mov    %ax,0xc(%edx)
    }

  conn->recv_avail += p->tot_len;
  116c4e:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  116c51:	0f b7 50 24          	movzwl 0x24(%eax),%edx
  116c55:	8b 45 10             	mov    0x10(%ebp),%eax
  116c58:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  116c5c:	01 c2                	add    %eax,%edx
  116c5e:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  116c61:	66 89 50 24          	mov    %dx,0x24(%eax)
    /* Register event with callback */
    if (conn->callback)
  116c65:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  116c68:	8b 40 28             	mov    0x28(%eax),%eax
  116c6b:	85 c0                	test   %eax,%eax
  116c6d:	74 24                	je     116c93 <recv_udp+0xc3>
        (*conn->callback)(conn, NETCONN_EVT_RCVPLUS, p->tot_len);
  116c6f:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  116c72:	8b 50 28             	mov    0x28(%eax),%edx
  116c75:	8b 45 10             	mov    0x10(%ebp),%eax
  116c78:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  116c7c:	0f b7 c0             	movzwl %ax,%eax
  116c7f:	89 44 24 08          	mov    %eax,0x8(%esp)
  116c83:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  116c8a:	00 
  116c8b:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  116c8e:	89 04 24             	mov    %eax,(%esp)
  116c91:	ff d2                	call   *%edx
    sys_mbox_post(conn->recvmbox, buf);
  116c93:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  116c96:	8b 50 14             	mov    0x14(%eax),%edx
  116c99:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  116c9c:	89 44 24 04          	mov    %eax,0x4(%esp)
  116ca0:	89 14 24             	mov    %edx,(%esp)
  116ca3:	e8 e8 32 00 00       	call   119f90 <sys_mbox_post>
  }
}
  116ca8:	c9                   	leave  
  116ca9:	c3                   	ret    
  116caa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

00116cb0 <recv_tcp>:
#endif /* LWIP_UDP */
#if LWIP_TCP

static err_t
recv_tcp(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
  116cb0:	55                   	push   %ebp
  116cb1:	89 e5                	mov    %esp,%ebp
  116cb3:	83 ec 28             	sub    $0x28,%esp
  116cb6:	8b 45 14             	mov    0x14(%ebp),%eax
  116cb9:	88 45 ec             	mov    %al,0xffffffec(%ebp)
  struct netconn *conn;
  u16_t len;
  
  conn = arg;
  116cbc:	8b 45 08             	mov    0x8(%ebp),%eax
  116cbf:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)

  if (conn == NULL) {
  116cc2:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  116cc6:	75 17                	jne    116cdf <recv_tcp+0x2f>
    pbuf_free(p);
  116cc8:	8b 45 10             	mov    0x10(%ebp),%eax
  116ccb:	89 04 24             	mov    %eax,(%esp)
  116cce:	e8 ed 87 ff ff       	call   10f4c0 <pbuf_free>
    return ERR_VAL;
  116cd3:	c7 45 e8 f9 ff ff ff 	movl   $0xfffffff9,0xffffffe8(%ebp)
  116cda:	e9 85 00 00 00       	jmp    116d64 <recv_tcp+0xb4>
  }

  if (conn->recvmbox != SYS_MBOX_NULL) {
  116cdf:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  116ce2:	8b 40 14             	mov    0x14(%eax),%eax
  116ce5:	85 c0                	test   %eax,%eax
  116ce7:	74 74                	je     116d5d <recv_tcp+0xad>
        
    conn->err = err;
  116ce9:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  116cec:	0f b6 45 ec          	movzbl 0xffffffec(%ebp),%eax
  116cf0:	88 42 0c             	mov    %al,0xc(%edx)
    if (p != NULL) {
  116cf3:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  116cf7:	74 21                	je     116d1a <recv_tcp+0x6a>
        len = p->tot_len;
  116cf9:	8b 45 10             	mov    0x10(%ebp),%eax
  116cfc:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  116d00:	66 89 45 fe          	mov    %ax,0xfffffffe(%ebp)
        conn->recv_avail += len;
  116d04:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  116d07:	0f b7 40 24          	movzwl 0x24(%eax),%eax
  116d0b:	89 c2                	mov    %eax,%edx
  116d0d:	66 03 55 fe          	add    0xfffffffe(%ebp),%dx
  116d11:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  116d14:	66 89 50 24          	mov    %dx,0x24(%eax)
  116d18:	eb 06                	jmp    116d20 <recv_tcp+0x70>
    }
    else
        len = 0;
  116d1a:	66 c7 45 fe 00 00    	movw   $0x0,0xfffffffe(%ebp)
    /* Register event with callback */
    if (conn->callback)
  116d20:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  116d23:	8b 40 28             	mov    0x28(%eax),%eax
  116d26:	85 c0                	test   %eax,%eax
  116d28:	74 1e                	je     116d48 <recv_tcp+0x98>
        (*conn->callback)(conn, NETCONN_EVT_RCVPLUS, len);
  116d2a:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  116d2d:	8b 50 28             	mov    0x28(%eax),%edx
  116d30:	0f b7 45 fe          	movzwl 0xfffffffe(%ebp),%eax
  116d34:	89 44 24 08          	mov    %eax,0x8(%esp)
  116d38:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  116d3f:	00 
  116d40:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  116d43:	89 04 24             	mov    %eax,(%esp)
  116d46:	ff d2                	call   *%edx
    sys_mbox_post(conn->recvmbox, p);
  116d48:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  116d4b:	8b 50 14             	mov    0x14(%eax),%edx
  116d4e:	8b 45 10             	mov    0x10(%ebp),%eax
  116d51:	89 44 24 04          	mov    %eax,0x4(%esp)
  116d55:	89 14 24             	mov    %edx,(%esp)
  116d58:	e8 33 32 00 00       	call   119f90 <sys_mbox_post>
  }  
  return ERR_OK;
  116d5d:	c7 45 e8 00 00 00 00 	movl   $0x0,0xffffffe8(%ebp)
  116d64:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
}
  116d67:	c9                   	leave  
  116d68:	c3                   	ret    
  116d69:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

00116d70 <poll_tcp>:


static err_t
poll_tcp(void *arg, struct tcp_pcb *pcb)
{
  116d70:	55                   	push   %ebp
  116d71:	89 e5                	mov    %esp,%ebp
  116d73:	83 ec 18             	sub    $0x18,%esp
  struct netconn *conn;

  conn = arg;
  116d76:	8b 45 08             	mov    0x8(%ebp),%eax
  116d79:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  if (conn != NULL &&
  116d7c:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  116d80:	74 2e                	je     116db0 <poll_tcp+0x40>
  116d82:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  116d85:	8b 40 04             	mov    0x4(%eax),%eax
  116d88:	83 f8 01             	cmp    $0x1,%eax
  116d8b:	74 0b                	je     116d98 <poll_tcp+0x28>
  116d8d:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  116d90:	8b 40 04             	mov    0x4(%eax),%eax
  116d93:	83 f8 05             	cmp    $0x5,%eax
  116d96:	75 18                	jne    116db0 <poll_tcp+0x40>
  116d98:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  116d9b:	8b 40 1c             	mov    0x1c(%eax),%eax
  116d9e:	85 c0                	test   %eax,%eax
  116da0:	74 0e                	je     116db0 <poll_tcp+0x40>
     (conn->state == NETCONN_WRITE || conn->state == NETCONN_CLOSE) &&
     conn->sem != SYS_SEM_NULL) {
    sys_sem_signal(conn->sem);
  116da2:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  116da5:	8b 40 1c             	mov    0x1c(%eax),%eax
  116da8:	89 04 24             	mov    %eax,(%esp)
  116dab:	e8 20 30 00 00       	call   119dd0 <sys_sem_signal>
  }
  return ERR_OK;
  116db0:	b8 00 00 00 00       	mov    $0x0,%eax
}
  116db5:	c9                   	leave  
  116db6:	c3                   	ret    
  116db7:	89 f6                	mov    %esi,%esi
  116db9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00116dc0 <sent_tcp>:

static err_t
sent_tcp(void *arg, struct tcp_pcb *pcb, u16_t len)
{
  116dc0:	55                   	push   %ebp
  116dc1:	89 e5                	mov    %esp,%ebp
  116dc3:	83 ec 28             	sub    $0x28,%esp
  116dc6:	8b 45 10             	mov    0x10(%ebp),%eax
  116dc9:	66 89 45 ec          	mov    %ax,0xffffffec(%ebp)
  struct netconn *conn;

  conn = arg;
  116dcd:	8b 45 08             	mov    0x8(%ebp),%eax
  116dd0:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  if (conn != NULL && conn->sem != SYS_SEM_NULL) {
  116dd3:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  116dd7:	74 18                	je     116df1 <sent_tcp+0x31>
  116dd9:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  116ddc:	8b 40 1c             	mov    0x1c(%eax),%eax
  116ddf:	85 c0                	test   %eax,%eax
  116de1:	74 0e                	je     116df1 <sent_tcp+0x31>
    sys_sem_signal(conn->sem);
  116de3:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  116de6:	8b 40 1c             	mov    0x1c(%eax),%eax
  116de9:	89 04 24             	mov    %eax,(%esp)
  116dec:	e8 df 2f 00 00       	call   119dd0 <sys_sem_signal>
  }

  if (conn && conn->callback)
  116df1:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  116df5:	74 38                	je     116e2f <sent_tcp+0x6f>
  116df7:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  116dfa:	8b 40 28             	mov    0x28(%eax),%eax
  116dfd:	85 c0                	test   %eax,%eax
  116dff:	74 2e                	je     116e2f <sent_tcp+0x6f>
      if (tcp_sndbuf(conn->pcb.tcp) > TCP_SNDLOWAT)
  116e01:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  116e04:	8b 40 08             	mov    0x8(%eax),%eax
  116e07:	0f b7 40 6a          	movzwl 0x6a(%eax),%eax
  116e0b:	66 3d 00 04          	cmp    $0x400,%ax
  116e0f:	76 1e                	jbe    116e2f <sent_tcp+0x6f>
          (*conn->callback)(conn, NETCONN_EVT_SENDPLUS, len);
  116e11:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  116e14:	8b 50 28             	mov    0x28(%eax),%edx
  116e17:	0f b7 45 ec          	movzwl 0xffffffec(%ebp),%eax
  116e1b:	89 44 24 08          	mov    %eax,0x8(%esp)
  116e1f:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
  116e26:	00 
  116e27:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  116e2a:	89 04 24             	mov    %eax,(%esp)
  116e2d:	ff d2                	call   *%edx
  
  return ERR_OK;
  116e2f:	b8 00 00 00 00       	mov    $0x0,%eax
}
  116e34:	c9                   	leave  
  116e35:	c3                   	ret    
  116e36:	8d 76 00             	lea    0x0(%esi),%esi
  116e39:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00116e40 <err_tcp>:

static void
err_tcp(void *arg, err_t err)
{
  116e40:	55                   	push   %ebp
  116e41:	89 e5                	mov    %esp,%ebp
  116e43:	83 ec 28             	sub    $0x28,%esp
  116e46:	8b 45 0c             	mov    0xc(%ebp),%eax
  116e49:	88 45 ec             	mov    %al,0xffffffec(%ebp)
  struct netconn *conn;

  conn = arg;
  116e4c:	8b 45 08             	mov    0x8(%ebp),%eax
  116e4f:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)

  conn->pcb.tcp = NULL;
  116e52:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  116e55:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)

  
  conn->err = err;
  116e5c:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  116e5f:	0f b6 45 ec          	movzbl 0xffffffec(%ebp),%eax
  116e63:	88 42 0c             	mov    %al,0xc(%edx)
  if (conn->recvmbox != SYS_MBOX_NULL) {
  116e66:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  116e69:	8b 40 14             	mov    0x14(%eax),%eax
  116e6c:	85 c0                	test   %eax,%eax
  116e6e:	74 3e                	je     116eae <err_tcp+0x6e>
    /* Register event with callback */
    if (conn->callback)
  116e70:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  116e73:	8b 40 28             	mov    0x28(%eax),%eax
  116e76:	85 c0                	test   %eax,%eax
  116e78:	74 1e                	je     116e98 <err_tcp+0x58>
      (*conn->callback)(conn, NETCONN_EVT_RCVPLUS, 0);
  116e7a:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  116e7d:	8b 50 28             	mov    0x28(%eax),%edx
  116e80:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  116e87:	00 
  116e88:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  116e8f:	00 
  116e90:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  116e93:	89 04 24             	mov    %eax,(%esp)
  116e96:	ff d2                	call   *%edx
    sys_mbox_post(conn->recvmbox, NULL);
  116e98:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  116e9b:	8b 40 14             	mov    0x14(%eax),%eax
  116e9e:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  116ea5:	00 
  116ea6:	89 04 24             	mov    %eax,(%esp)
  116ea9:	e8 e2 30 00 00       	call   119f90 <sys_mbox_post>
  }
  if (conn->mbox != SYS_MBOX_NULL) {
  116eae:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  116eb1:	8b 40 10             	mov    0x10(%eax),%eax
  116eb4:	85 c0                	test   %eax,%eax
  116eb6:	74 16                	je     116ece <err_tcp+0x8e>
    sys_mbox_post(conn->mbox, NULL);
  116eb8:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  116ebb:	8b 40 10             	mov    0x10(%eax),%eax
  116ebe:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  116ec5:	00 
  116ec6:	89 04 24             	mov    %eax,(%esp)
  116ec9:	e8 c2 30 00 00       	call   119f90 <sys_mbox_post>
  }
  if (conn->acceptmbox != SYS_MBOX_NULL) {
  116ece:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  116ed1:	8b 40 18             	mov    0x18(%eax),%eax
  116ed4:	85 c0                	test   %eax,%eax
  116ed6:	74 3e                	je     116f16 <err_tcp+0xd6>
     /* Register event with callback */
    if (conn->callback)
  116ed8:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  116edb:	8b 40 28             	mov    0x28(%eax),%eax
  116ede:	85 c0                	test   %eax,%eax
  116ee0:	74 1e                	je     116f00 <err_tcp+0xc0>
      (*conn->callback)(conn, NETCONN_EVT_RCVPLUS, 0);
  116ee2:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  116ee5:	8b 50 28             	mov    0x28(%eax),%edx
  116ee8:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  116eef:	00 
  116ef0:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  116ef7:	00 
  116ef8:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  116efb:	89 04 24             	mov    %eax,(%esp)
  116efe:	ff d2                	call   *%edx
    sys_mbox_post(conn->acceptmbox, NULL);
  116f00:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  116f03:	8b 40 18             	mov    0x18(%eax),%eax
  116f06:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  116f0d:	00 
  116f0e:	89 04 24             	mov    %eax,(%esp)
  116f11:	e8 7a 30 00 00       	call   119f90 <sys_mbox_post>
  }
  if (conn->sem != SYS_SEM_NULL) {
  116f16:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  116f19:	8b 40 1c             	mov    0x1c(%eax),%eax
  116f1c:	85 c0                	test   %eax,%eax
  116f1e:	74 0e                	je     116f2e <err_tcp+0xee>
    sys_sem_signal(conn->sem);
  116f20:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  116f23:	8b 40 1c             	mov    0x1c(%eax),%eax
  116f26:	89 04 24             	mov    %eax,(%esp)
  116f29:	e8 a2 2e 00 00       	call   119dd0 <sys_sem_signal>
  }
}
  116f2e:	c9                   	leave  
  116f2f:	c3                   	ret    

00116f30 <setup_tcp>:

static void
setup_tcp(struct netconn *conn)
{
  116f30:	55                   	push   %ebp
  116f31:	89 e5                	mov    %esp,%ebp
  116f33:	83 ec 28             	sub    $0x28,%esp
  struct tcp_pcb *pcb;
  
  pcb = conn->pcb.tcp;
  116f36:	8b 45 08             	mov    0x8(%ebp),%eax
  116f39:	8b 40 08             	mov    0x8(%eax),%eax
  116f3c:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  tcp_arg(pcb, conn);
  116f3f:	8b 45 08             	mov    0x8(%ebp),%eax
  116f42:	89 44 24 04          	mov    %eax,0x4(%esp)
  116f46:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  116f49:	89 04 24             	mov    %eax,(%esp)
  116f4c:	e8 7f a5 ff ff       	call   1114d0 <tcp_arg>
  tcp_recv(pcb, recv_tcp);
  116f51:	c7 44 24 04 b0 6c 11 	movl   $0x116cb0,0x4(%esp)
  116f58:	00 
  116f59:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  116f5c:	89 04 24             	mov    %eax,(%esp)
  116f5f:	e8 7c a5 ff ff       	call   1114e0 <tcp_recv>
  tcp_sent(pcb, sent_tcp);
  116f64:	c7 44 24 04 c0 6d 11 	movl   $0x116dc0,0x4(%esp)
  116f6b:	00 
  116f6c:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  116f6f:	89 04 24             	mov    %eax,(%esp)
  116f72:	e8 89 a5 ff ff       	call   111500 <tcp_sent>
  tcp_poll(pcb, poll_tcp, 4);
  116f77:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  116f7e:	00 
  116f7f:	c7 44 24 04 70 6d 11 	movl   $0x116d70,0x4(%esp)
  116f86:	00 
  116f87:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  116f8a:	89 04 24             	mov    %eax,(%esp)
  116f8d:	e8 ae a5 ff ff       	call   111540 <tcp_poll>
  tcp_err(pcb, err_tcp);
  116f92:	c7 44 24 04 40 6e 11 	movl   $0x116e40,0x4(%esp)
  116f99:	00 
  116f9a:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  116f9d:	89 04 24             	mov    %eax,(%esp)
  116fa0:	e8 6b a5 ff ff       	call   111510 <tcp_err>
}
  116fa5:	c9                   	leave  
  116fa6:	c3                   	ret    
  116fa7:	89 f6                	mov    %esi,%esi
  116fa9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00116fb0 <accept_function>:

static err_t
accept_function(void *arg, struct tcp_pcb *newpcb, err_t err)
{
  116fb0:	55                   	push   %ebp
  116fb1:	89 e5                	mov    %esp,%ebp
  116fb3:	83 ec 28             	sub    $0x28,%esp
  116fb6:	8b 45 10             	mov    0x10(%ebp),%eax
  116fb9:	88 45 ec             	mov    %al,0xffffffec(%ebp)
  sys_mbox_t mbox;
  struct netconn *newconn;
  struct netconn *conn;
  
#if API_MSG_DEBUG
#if TCP_DEBUG
  tcp_debug_print_state(newpcb->state);
#endif /* TCP_DEBUG */
#endif /* API_MSG_DEBUG */
  conn = (struct netconn *)arg;
  116fbc:	8b 45 08             	mov    0x8(%ebp),%eax
  116fbf:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  mbox = conn->acceptmbox;
  116fc2:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  116fc5:	8b 40 18             	mov    0x18(%eax),%eax
  116fc8:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  newconn = memp_malloc(MEMP_NETCONN);
  116fcb:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  116fd2:	e8 f9 79 ff ff       	call   10e9d0 <memp_malloc>
  116fd7:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  if (newconn == NULL) {
  116fda:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  116fde:	75 0c                	jne    116fec <accept_function+0x3c>
    return ERR_MEM;
  116fe0:	c7 45 e8 ff ff ff ff 	movl   $0xffffffff,0xffffffe8(%ebp)
  116fe7:	e9 58 01 00 00       	jmp    117144 <accept_function+0x194>
  }
  newconn->type = NETCONN_TCP;
  116fec:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  116fef:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  newconn->pcb.tcp = newpcb;
  116ff5:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  116ff8:	8b 45 0c             	mov    0xc(%ebp),%eax
  116ffb:	89 42 08             	mov    %eax,0x8(%edx)
  setup_tcp(newconn);
  116ffe:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  117001:	89 04 24             	mov    %eax,(%esp)
  117004:	e8 27 ff ff ff       	call   116f30 <setup_tcp>
  newconn->recvmbox = sys_mbox_new();
  117009:	e8 52 2e 00 00       	call   119e60 <sys_mbox_new>
  11700e:	89 c2                	mov    %eax,%edx
  117010:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  117013:	89 50 14             	mov    %edx,0x14(%eax)
  if (newconn->recvmbox == SYS_MBOX_NULL) {
  117016:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  117019:	8b 40 14             	mov    0x14(%eax),%eax
  11701c:	85 c0                	test   %eax,%eax
  11701e:	75 1f                	jne    11703f <accept_function+0x8f>
    memp_free(MEMP_NETCONN, newconn);
  117020:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  117023:	89 44 24 04          	mov    %eax,0x4(%esp)
  117027:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  11702e:	e8 8d 7a ff ff       	call   10eac0 <memp_free>
    return ERR_MEM;
  117033:	c7 45 e8 ff ff ff ff 	movl   $0xffffffff,0xffffffe8(%ebp)
  11703a:	e9 05 01 00 00       	jmp    117144 <accept_function+0x194>
  }
  newconn->mbox = sys_mbox_new();
  11703f:	e8 1c 2e 00 00       	call   119e60 <sys_mbox_new>
  117044:	89 c2                	mov    %eax,%edx
  117046:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  117049:	89 50 10             	mov    %edx,0x10(%eax)
  if (newconn->mbox == SYS_MBOX_NULL) {
  11704c:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  11704f:	8b 40 10             	mov    0x10(%eax),%eax
  117052:	85 c0                	test   %eax,%eax
  117054:	75 2d                	jne    117083 <accept_function+0xd3>
    sys_mbox_free(newconn->recvmbox);
  117056:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  117059:	8b 40 14             	mov    0x14(%eax),%eax
  11705c:	89 04 24             	mov    %eax,(%esp)
  11705f:	e8 bc 2e 00 00       	call   119f20 <sys_mbox_free>
    memp_free(MEMP_NETCONN, newconn);
  117064:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  117067:	89 44 24 04          	mov    %eax,0x4(%esp)
  11706b:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  117072:	e8 49 7a ff ff       	call   10eac0 <memp_free>
    return ERR_MEM;
  117077:	c7 45 e8 ff ff ff ff 	movl   $0xffffffff,0xffffffe8(%ebp)
  11707e:	e9 c1 00 00 00       	jmp    117144 <accept_function+0x194>
  }
  newconn->sem = sys_sem_new(0);
  117083:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  11708a:	e8 c1 2c 00 00       	call   119d50 <sys_sem_new>
  11708f:	89 c2                	mov    %eax,%edx
  117091:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  117094:	89 50 1c             	mov    %edx,0x1c(%eax)
  if (newconn->sem == SYS_SEM_NULL) {
  117097:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  11709a:	8b 40 1c             	mov    0x1c(%eax),%eax
  11709d:	85 c0                	test   %eax,%eax
  11709f:	75 38                	jne    1170d9 <accept_function+0x129>
    sys_mbox_free(newconn->recvmbox);
  1170a1:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1170a4:	8b 40 14             	mov    0x14(%eax),%eax
  1170a7:	89 04 24             	mov    %eax,(%esp)
  1170aa:	e8 71 2e 00 00       	call   119f20 <sys_mbox_free>
    sys_mbox_free(newconn->mbox);
  1170af:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1170b2:	8b 40 10             	mov    0x10(%eax),%eax
  1170b5:	89 04 24             	mov    %eax,(%esp)
  1170b8:	e8 63 2e 00 00       	call   119f20 <sys_mbox_free>
    memp_free(MEMP_NETCONN, newconn);
  1170bd:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1170c0:	89 44 24 04          	mov    %eax,0x4(%esp)
  1170c4:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  1170cb:	e8 f0 79 ff ff       	call   10eac0 <memp_free>
    return ERR_MEM;
  1170d0:	c7 45 e8 ff ff ff ff 	movl   $0xffffffff,0xffffffe8(%ebp)
  1170d7:	eb 6b                	jmp    117144 <accept_function+0x194>
  }
  newconn->acceptmbox = SYS_MBOX_NULL;
  1170d9:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1170dc:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
  newconn->err = err;
  1170e3:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  1170e6:	0f b6 45 ec          	movzbl 0xffffffec(%ebp),%eax
  1170ea:	88 42 0c             	mov    %al,0xc(%edx)
  /* Register event with callback */
  if (conn->callback)
  1170ed:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1170f0:	8b 40 28             	mov    0x28(%eax),%eax
  1170f3:	85 c0                	test   %eax,%eax
  1170f5:	74 34                	je     11712b <accept_function+0x17b>
  {
    (*conn->callback)(conn, NETCONN_EVT_RCVPLUS, 0);
  1170f7:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1170fa:	8b 50 28             	mov    0x28(%eax),%edx
  1170fd:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  117104:	00 
  117105:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  11710c:	00 
  11710d:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  117110:	89 04 24             	mov    %eax,(%esp)
  117113:	ff d2                	call   *%edx
    /* We have to set the callback here even though
     * the new socket is unknown. Mark the socket as -1. */
    newconn->callback = conn->callback;
  117115:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  117118:	8b 50 28             	mov    0x28(%eax),%edx
  11711b:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  11711e:	89 50 28             	mov    %edx,0x28(%eax)
    newconn->socket = -1;
  117121:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  117124:	c7 40 20 ff ff ff ff 	movl   $0xffffffff,0x20(%eax)
  }
  
  sys_mbox_post(mbox, newconn);
  11712b:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  11712e:	89 44 24 04          	mov    %eax,0x4(%esp)
  117132:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  117135:	89 04 24             	mov    %eax,(%esp)
  117138:	e8 53 2e 00 00       	call   119f90 <sys_mbox_post>
  return ERR_OK;
  11713d:	c7 45 e8 00 00 00 00 	movl   $0x0,0xffffffe8(%ebp)
  117144:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
}
  117147:	c9                   	leave  
  117148:	c3                   	ret    
  117149:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

00117150 <do_newconn>:
#endif /* LWIP_TCP */

static void
do_newconn(struct api_msg_msg *msg)
{
  117150:	55                   	push   %ebp
  117151:	89 e5                	mov    %esp,%ebp
  117153:	53                   	push   %ebx
  117154:	83 ec 14             	sub    $0x14,%esp
   if(msg->conn->pcb.tcp != NULL) {
  117157:	8b 45 08             	mov    0x8(%ebp),%eax
  11715a:	8b 00                	mov    (%eax),%eax
  11715c:	8b 40 08             	mov    0x8(%eax),%eax
  11715f:	85 c0                	test   %eax,%eax
  117161:	74 1d                	je     117180 <do_newconn+0x30>
   /* This "new" connection already has a PCB allocated. */
   /* Is this an error condition? Should it be deleted? 
      We currently just are happy and return. */
     sys_mbox_post(msg->conn->mbox, NULL);
  117163:	8b 45 08             	mov    0x8(%ebp),%eax
  117166:	8b 00                	mov    (%eax),%eax
  117168:	8b 40 10             	mov    0x10(%eax),%eax
  11716b:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  117172:	00 
  117173:	89 04 24             	mov    %eax,(%esp)
  117176:	e8 15 2e 00 00       	call   119f90 <sys_mbox_post>
     return;
  11717b:	e9 a8 01 00 00       	jmp    117328 <do_newconn+0x1d8>
   }

   msg->conn->err = ERR_OK;
  117180:	8b 45 08             	mov    0x8(%ebp),%eax
  117183:	8b 00                	mov    (%eax),%eax
  117185:	c6 40 0c 00          	movb   $0x0,0xc(%eax)

   /* Allocate a PCB for this connection */
   switch(msg->conn->type) {
  117189:	8b 45 08             	mov    0x8(%ebp),%eax
  11718c:	8b 00                	mov    (%eax),%eax
  11718e:	8b 00                	mov    (%eax),%eax
  117190:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  117193:	83 7d f8 04          	cmpl   $0x4,0xfffffff8(%ebp)
  117197:	0f 87 73 01 00 00    	ja     117310 <do_newconn+0x1c0>
  11719d:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  1171a0:	8b 04 95 68 af 11 00 	mov    0x11af68(,%edx,4),%eax
  1171a7:	ff e0                	jmp    *%eax
#if LWIP_RAW
   case NETCONN_RAW:
      msg->conn->pcb.raw = raw_new(msg->msg.bc.port); /* misusing the port field */
  1171a9:	8b 45 08             	mov    0x8(%ebp),%eax
  1171ac:	8b 18                	mov    (%eax),%ebx
  1171ae:	8b 45 08             	mov    0x8(%ebp),%eax
  1171b1:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  1171b5:	0f b7 c0             	movzwl %ax,%eax
  1171b8:	89 04 24             	mov    %eax,(%esp)
  1171bb:	e8 b0 8a ff ff       	call   10fc70 <raw_new>
  1171c0:	89 43 08             	mov    %eax,0x8(%ebx)
      raw_recv(msg->conn->pcb.raw, recv_raw, msg->conn);
  1171c3:	8b 45 08             	mov    0x8(%ebp),%eax
  1171c6:	8b 10                	mov    (%eax),%edx
  1171c8:	8b 45 08             	mov    0x8(%ebp),%eax
  1171cb:	8b 00                	mov    (%eax),%eax
  1171cd:	8b 40 08             	mov    0x8(%eax),%eax
  1171d0:	89 54 24 08          	mov    %edx,0x8(%esp)
  1171d4:	c7 44 24 04 e0 6a 11 	movl   $0x116ae0,0x4(%esp)
  1171db:	00 
  1171dc:	89 04 24             	mov    %eax,(%esp)
  1171df:	e8 8c 88 ff ff       	call   10fa70 <raw_recv>
     break;
  1171e4:	e9 27 01 00 00       	jmp    117310 <do_newconn+0x1c0>
#endif
#if LWIP_UDP
   case NETCONN_UDPLITE:
      msg->conn->pcb.udp = udp_new();
  1171e9:	8b 45 08             	mov    0x8(%ebp),%eax
  1171ec:	8b 18                	mov    (%eax),%ebx
  1171ee:	e8 fd e5 ff ff       	call   1157f0 <udp_new>
  1171f3:	89 43 08             	mov    %eax,0x8(%ebx)
      if(msg->conn->pcb.udp == NULL) {
  1171f6:	8b 45 08             	mov    0x8(%ebp),%eax
  1171f9:	8b 00                	mov    (%eax),%eax
  1171fb:	8b 40 08             	mov    0x8(%eax),%eax
  1171fe:	85 c0                	test   %eax,%eax
  117200:	75 0e                	jne    117210 <do_newconn+0xc0>
         msg->conn->err = ERR_MEM;
  117202:	8b 45 08             	mov    0x8(%ebp),%eax
  117205:	8b 00                	mov    (%eax),%eax
  117207:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
         break;
  11720b:	e9 00 01 00 00       	jmp    117310 <do_newconn+0x1c0>
      }
      udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_UDPLITE);
  117210:	8b 45 08             	mov    0x8(%ebp),%eax
  117213:	8b 00                	mov    (%eax),%eax
  117215:	8b 40 08             	mov    0x8(%eax),%eax
  117218:	c6 40 10 02          	movb   $0x2,0x10(%eax)
      udp_recv(msg->conn->pcb.udp, recv_udp, msg->conn);
  11721c:	8b 45 08             	mov    0x8(%ebp),%eax
  11721f:	8b 10                	mov    (%eax),%edx
  117221:	8b 45 08             	mov    0x8(%ebp),%eax
  117224:	8b 00                	mov    (%eax),%eax
  117226:	8b 40 08             	mov    0x8(%eax),%eax
  117229:	89 54 24 08          	mov    %edx,0x8(%esp)
  11722d:	c7 44 24 04 d0 6b 11 	movl   $0x116bd0,0x4(%esp)
  117234:	00 
  117235:	89 04 24             	mov    %eax,(%esp)
  117238:	e8 23 e5 ff ff       	call   115760 <udp_recv>
      break;
  11723d:	e9 ce 00 00 00       	jmp    117310 <do_newconn+0x1c0>
   case NETCONN_UDPNOCHKSUM:
      msg->conn->pcb.udp = udp_new();
  117242:	8b 45 08             	mov    0x8(%ebp),%eax
  117245:	8b 18                	mov    (%eax),%ebx
  117247:	e8 a4 e5 ff ff       	call   1157f0 <udp_new>
  11724c:	89 43 08             	mov    %eax,0x8(%ebx)
      if(msg->conn->pcb.udp == NULL) {
  11724f:	8b 45 08             	mov    0x8(%ebp),%eax
  117252:	8b 00                	mov    (%eax),%eax
  117254:	8b 40 08             	mov    0x8(%eax),%eax
  117257:	85 c0                	test   %eax,%eax
  117259:	75 0e                	jne    117269 <do_newconn+0x119>
         msg->conn->err = ERR_MEM;
  11725b:	8b 45 08             	mov    0x8(%ebp),%eax
  11725e:	8b 00                	mov    (%eax),%eax
  117260:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
         break;
  117264:	e9 a7 00 00 00       	jmp    117310 <do_newconn+0x1c0>
      }
      udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_NOCHKSUM);
  117269:	8b 45 08             	mov    0x8(%ebp),%eax
  11726c:	8b 00                	mov    (%eax),%eax
  11726e:	8b 40 08             	mov    0x8(%eax),%eax
  117271:	c6 40 10 01          	movb   $0x1,0x10(%eax)
      udp_recv(msg->conn->pcb.udp, recv_udp, msg->conn);
  117275:	8b 45 08             	mov    0x8(%ebp),%eax
  117278:	8b 10                	mov    (%eax),%edx
  11727a:	8b 45 08             	mov    0x8(%ebp),%eax
  11727d:	8b 00                	mov    (%eax),%eax
  11727f:	8b 40 08             	mov    0x8(%eax),%eax
  117282:	89 54 24 08          	mov    %edx,0x8(%esp)
  117286:	c7 44 24 04 d0 6b 11 	movl   $0x116bd0,0x4(%esp)
  11728d:	00 
  11728e:	89 04 24             	mov    %eax,(%esp)
  117291:	e8 ca e4 ff ff       	call   115760 <udp_recv>
      break;
  117296:	eb 78                	jmp    117310 <do_newconn+0x1c0>
   case NETCONN_UDP:
      msg->conn->pcb.udp = udp_new();
  117298:	8b 45 08             	mov    0x8(%ebp),%eax
  11729b:	8b 18                	mov    (%eax),%ebx
  11729d:	e8 4e e5 ff ff       	call   1157f0 <udp_new>
  1172a2:	89 43 08             	mov    %eax,0x8(%ebx)
      if(msg->conn->pcb.udp == NULL) {
  1172a5:	8b 45 08             	mov    0x8(%ebp),%eax
  1172a8:	8b 00                	mov    (%eax),%eax
  1172aa:	8b 40 08             	mov    0x8(%eax),%eax
  1172ad:	85 c0                	test   %eax,%eax
  1172af:	75 0b                	jne    1172bc <do_newconn+0x16c>
         msg->conn->err = ERR_MEM;
  1172b1:	8b 45 08             	mov    0x8(%ebp),%eax
  1172b4:	8b 00                	mov    (%eax),%eax
  1172b6:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
         break;
  1172ba:	eb 54                	jmp    117310 <do_newconn+0x1c0>
      }
      udp_recv(msg->conn->pcb.udp, recv_udp, msg->conn);
  1172bc:	8b 45 08             	mov    0x8(%ebp),%eax
  1172bf:	8b 10                	mov    (%eax),%edx
  1172c1:	8b 45 08             	mov    0x8(%ebp),%eax
  1172c4:	8b 00                	mov    (%eax),%eax
  1172c6:	8b 40 08             	mov    0x8(%eax),%eax
  1172c9:	89 54 24 08          	mov    %edx,0x8(%esp)
  1172cd:	c7 44 24 04 d0 6b 11 	movl   $0x116bd0,0x4(%esp)
  1172d4:	00 
  1172d5:	89 04 24             	mov    %eax,(%esp)
  1172d8:	e8 83 e4 ff ff       	call   115760 <udp_recv>
      break;
  1172dd:	eb 31                	jmp    117310 <do_newconn+0x1c0>
#endif /* LWIP_UDP */
#if LWIP_TCP
   case NETCONN_TCP:
      msg->conn->pcb.tcp = tcp_new();
  1172df:	8b 45 08             	mov    0x8(%ebp),%eax
  1172e2:	8b 18                	mov    (%eax),%ebx
  1172e4:	e8 c7 a1 ff ff       	call   1114b0 <tcp_new>
  1172e9:	89 43 08             	mov    %eax,0x8(%ebx)
      if(msg->conn->pcb.tcp == NULL) {
  1172ec:	8b 45 08             	mov    0x8(%ebp),%eax
  1172ef:	8b 00                	mov    (%eax),%eax
  1172f1:	8b 40 08             	mov    0x8(%eax),%eax
  1172f4:	85 c0                	test   %eax,%eax
  1172f6:	75 0b                	jne    117303 <do_newconn+0x1b3>
         msg->conn->err = ERR_MEM;
  1172f8:	8b 45 08             	mov    0x8(%ebp),%eax
  1172fb:	8b 00                	mov    (%eax),%eax
  1172fd:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
         break;
  117301:	eb 0d                	jmp    117310 <do_newconn+0x1c0>
      }
      setup_tcp(msg->conn);
  117303:	8b 45 08             	mov    0x8(%ebp),%eax
  117306:	8b 00                	mov    (%eax),%eax
  117308:	89 04 24             	mov    %eax,(%esp)
  11730b:	e8 20 fc ff ff       	call   116f30 <setup_tcp>
      break;
#endif
   }
   
  
  sys_mbox_post(msg->conn->mbox, NULL);
  117310:	8b 45 08             	mov    0x8(%ebp),%eax
  117313:	8b 00                	mov    (%eax),%eax
  117315:	8b 40 10             	mov    0x10(%eax),%eax
  117318:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  11731f:	00 
  117320:	89 04 24             	mov    %eax,(%esp)
  117323:	e8 68 2c 00 00       	call   119f90 <sys_mbox_post>
}
  117328:	83 c4 14             	add    $0x14,%esp
  11732b:	5b                   	pop    %ebx
  11732c:	5d                   	pop    %ebp
  11732d:	c3                   	ret    
  11732e:	89 f6                	mov    %esi,%esi

00117330 <do_delconn>:


static void
do_delconn(struct api_msg_msg *msg)
{
  117330:	55                   	push   %ebp
  117331:	89 e5                	mov    %esp,%ebp
  117333:	83 ec 18             	sub    $0x18,%esp
  if (msg->conn->pcb.tcp != NULL) {
  117336:	8b 45 08             	mov    0x8(%ebp),%eax
  117339:	8b 00                	mov    (%eax),%eax
  11733b:	8b 40 08             	mov    0x8(%eax),%eax
  11733e:	85 c0                	test   %eax,%eax
  117340:	0f 84 55 01 00 00    	je     11749b <do_delconn+0x16b>
    switch (msg->conn->type) {
  117346:	8b 45 08             	mov    0x8(%ebp),%eax
  117349:	8b 00                	mov    (%eax),%eax
  11734b:	8b 00                	mov    (%eax),%eax
  11734d:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  117350:	83 7d fc 03          	cmpl   $0x3,0xfffffffc(%ebp)
  117354:	77 08                	ja     11735e <do_delconn+0x2e>
  117356:	83 7d fc 01          	cmpl   $0x1,0xfffffffc(%ebp)
  11735a:	73 22                	jae    11737e <do_delconn+0x4e>
  11735c:	eb 44                	jmp    1173a2 <do_delconn+0x72>
  11735e:	83 7d fc 04          	cmpl   $0x4,0xfffffffc(%ebp)
  117362:	74 05                	je     117369 <do_delconn+0x39>
  117364:	e9 32 01 00 00       	jmp    11749b <do_delconn+0x16b>
#if LWIP_RAW
    case NETCONN_RAW:
      raw_remove(msg->conn->pcb.raw);
  117369:	8b 45 08             	mov    0x8(%ebp),%eax
  11736c:	8b 00                	mov    (%eax),%eax
  11736e:	8b 40 08             	mov    0x8(%eax),%eax
  117371:	89 04 24             	mov    %eax,(%esp)
  117374:	e8 87 88 ff ff       	call   10fc00 <raw_remove>
      break;
  117379:	e9 1d 01 00 00       	jmp    11749b <do_delconn+0x16b>
#endif
#if LWIP_UDP
    case NETCONN_UDPLITE:
      /* FALLTHROUGH */
    case NETCONN_UDPNOCHKSUM:
      /* FALLTHROUGH */
    case NETCONN_UDP:
      msg->conn->pcb.udp->recv_arg = NULL;
  11737e:	8b 45 08             	mov    0x8(%ebp),%eax
  117381:	8b 00                	mov    (%eax),%eax
  117383:	8b 40 08             	mov    0x8(%eax),%eax
  117386:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
      udp_remove(msg->conn->pcb.udp);
  11738d:	8b 45 08             	mov    0x8(%ebp),%eax
  117390:	8b 00                	mov    (%eax),%eax
  117392:	8b 40 08             	mov    0x8(%eax),%eax
  117395:	89 04 24             	mov    %eax,(%esp)
  117398:	e8 e3 e3 ff ff       	call   115780 <udp_remove>
      break;
  11739d:	e9 f9 00 00 00       	jmp    11749b <do_delconn+0x16b>
#endif /* LWIP_UDP */
#if LWIP_TCP      
    case NETCONN_TCP:
      if (msg->conn->pcb.tcp->state == LISTEN) {
  1173a2:	8b 45 08             	mov    0x8(%ebp),%eax
  1173a5:	8b 00                	mov    (%eax),%eax
  1173a7:	8b 40 08             	mov    0x8(%eax),%eax
  1173aa:	8b 40 10             	mov    0x10(%eax),%eax
  1173ad:	83 f8 01             	cmp    $0x1,%eax
  1173b0:	75 45                	jne    1173f7 <do_delconn+0xc7>
  tcp_arg(msg->conn->pcb.tcp, NULL);
  1173b2:	8b 45 08             	mov    0x8(%ebp),%eax
  1173b5:	8b 00                	mov    (%eax),%eax
  1173b7:	8b 40 08             	mov    0x8(%eax),%eax
  1173ba:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  1173c1:	00 
  1173c2:	89 04 24             	mov    %eax,(%esp)
  1173c5:	e8 06 a1 ff ff       	call   1114d0 <tcp_arg>
  tcp_accept(msg->conn->pcb.tcp, NULL);  
  1173ca:	8b 45 08             	mov    0x8(%ebp),%eax
  1173cd:	8b 00                	mov    (%eax),%eax
  1173cf:	8b 40 08             	mov    0x8(%eax),%eax
  1173d2:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  1173d9:	00 
  1173da:	89 04 24             	mov    %eax,(%esp)
  1173dd:	e8 4e a1 ff ff       	call   111530 <tcp_accept>
  tcp_close(msg->conn->pcb.tcp);
  1173e2:	8b 45 08             	mov    0x8(%ebp),%eax
  1173e5:	8b 00                	mov    (%eax),%eax
  1173e7:	8b 40 08             	mov    0x8(%eax),%eax
  1173ea:	89 04 24             	mov    %eax,(%esp)
  1173ed:	e8 4e 8e ff ff       	call   110240 <tcp_close>
  1173f2:	e9 a4 00 00 00       	jmp    11749b <do_delconn+0x16b>
      } else {
  tcp_arg(msg->conn->pcb.tcp, NULL);
  1173f7:	8b 45 08             	mov    0x8(%ebp),%eax
  1173fa:	8b 00                	mov    (%eax),%eax
  1173fc:	8b 40 08             	mov    0x8(%eax),%eax
  1173ff:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  117406:	00 
  117407:	89 04 24             	mov    %eax,(%esp)
  11740a:	e8 c1 a0 ff ff       	call   1114d0 <tcp_arg>
  tcp_sent(msg->conn->pcb.tcp, NULL);
  11740f:	8b 45 08             	mov    0x8(%ebp),%eax
  117412:	8b 00                	mov    (%eax),%eax
  117414:	8b 40 08             	mov    0x8(%eax),%eax
  117417:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  11741e:	00 
  11741f:	89 04 24             	mov    %eax,(%esp)
  117422:	e8 d9 a0 ff ff       	call   111500 <tcp_sent>
  tcp_recv(msg->conn->pcb.tcp, NULL);  
  117427:	8b 45 08             	mov    0x8(%ebp),%eax
  11742a:	8b 00                	mov    (%eax),%eax
  11742c:	8b 40 08             	mov    0x8(%eax),%eax
  11742f:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  117436:	00 
  117437:	89 04 24             	mov    %eax,(%esp)
  11743a:	e8 a1 a0 ff ff       	call   1114e0 <tcp_recv>
  tcp_poll(msg->conn->pcb.tcp, NULL, 0);
  11743f:	8b 45 08             	mov    0x8(%ebp),%eax
  117442:	8b 00                	mov    (%eax),%eax
  117444:	8b 40 08             	mov    0x8(%eax),%eax
  117447:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  11744e:	00 
  11744f:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  117456:	00 
  117457:	89 04 24             	mov    %eax,(%esp)
  11745a:	e8 e1 a0 ff ff       	call   111540 <tcp_poll>
  tcp_err(msg->conn->pcb.tcp, NULL);
  11745f:	8b 45 08             	mov    0x8(%ebp),%eax
  117462:	8b 00                	mov    (%eax),%eax
  117464:	8b 40 08             	mov    0x8(%eax),%eax
  117467:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  11746e:	00 
  11746f:	89 04 24             	mov    %eax,(%esp)
  117472:	e8 99 a0 ff ff       	call   111510 <tcp_err>
  if (tcp_close(msg->conn->pcb.tcp) != ERR_OK) {
  117477:	8b 45 08             	mov    0x8(%ebp),%eax
  11747a:	8b 00                	mov    (%eax),%eax
  11747c:	8b 40 08             	mov    0x8(%eax),%eax
  11747f:	89 04 24             	mov    %eax,(%esp)
  117482:	e8 b9 8d ff ff       	call   110240 <tcp_close>
  117487:	84 c0                	test   %al,%al
  117489:	74 10                	je     11749b <do_delconn+0x16b>
    tcp_abort(msg->conn->pcb.tcp);
  11748b:	8b 45 08             	mov    0x8(%ebp),%eax
  11748e:	8b 00                	mov    (%eax),%eax
  117490:	8b 40 08             	mov    0x8(%eax),%eax
  117493:	89 04 24             	mov    %eax,(%esp)
  117496:	e8 b5 8e ff ff       	call   110350 <tcp_abort>
  }
      }
#endif
    default:  
    break;
    }
  }
  /* Trigger select() in socket layer */
  if (msg->conn->callback)
  11749b:	8b 45 08             	mov    0x8(%ebp),%eax
  11749e:	8b 00                	mov    (%eax),%eax
  1174a0:	8b 40 28             	mov    0x28(%eax),%eax
  1174a3:	85 c0                	test   %eax,%eax
  1174a5:	74 44                	je     1174eb <do_delconn+0x1bb>
  {
      (*msg->conn->callback)(msg->conn, NETCONN_EVT_RCVPLUS, 0);
  1174a7:	8b 45 08             	mov    0x8(%ebp),%eax
  1174aa:	8b 00                	mov    (%eax),%eax
  1174ac:	8b 50 28             	mov    0x28(%eax),%edx
  1174af:	8b 45 08             	mov    0x8(%ebp),%eax
  1174b2:	8b 00                	mov    (%eax),%eax
  1174b4:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  1174bb:	00 
  1174bc:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  1174c3:	00 
  1174c4:	89 04 24             	mov    %eax,(%esp)
  1174c7:	ff d2                	call   *%edx
      (*msg->conn->callback)(msg->conn, NETCONN_EVT_SENDPLUS, 0);
  1174c9:	8b 45 08             	mov    0x8(%ebp),%eax
  1174cc:	8b 00                	mov    (%eax),%eax
  1174ce:	8b 50 28             	mov    0x28(%eax),%edx
  1174d1:	8b 45 08             	mov    0x8(%ebp),%eax
  1174d4:	8b 00                	mov    (%eax),%eax
  1174d6:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  1174dd:	00 
  1174de:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
  1174e5:	00 
  1174e6:	89 04 24             	mov    %eax,(%esp)
  1174e9:	ff d2                	call   *%edx
  }
  
  if (msg->conn->mbox != SYS_MBOX_NULL) {
  1174eb:	8b 45 08             	mov    0x8(%ebp),%eax
  1174ee:	8b 00                	mov    (%eax),%eax
  1174f0:	8b 40 10             	mov    0x10(%eax),%eax
  1174f3:	85 c0                	test   %eax,%eax
  1174f5:	74 18                	je     11750f <do_delconn+0x1df>
    sys_mbox_post(msg->conn->mbox, NULL);
  1174f7:	8b 45 08             	mov    0x8(%ebp),%eax
  1174fa:	8b 00                	mov    (%eax),%eax
  1174fc:	8b 40 10             	mov    0x10(%eax),%eax
  1174ff:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  117506:	00 
  117507:	89 04 24             	mov    %eax,(%esp)
  11750a:	e8 81 2a 00 00       	call   119f90 <sys_mbox_post>
  }
}
  11750f:	c9                   	leave  
  117510:	c3                   	ret    
  117511:	eb 0d                	jmp    117520 <do_bind>
  117513:	90                   	nop    
  117514:	90                   	nop    
  117515:	90                   	nop    
  117516:	90                   	nop    
  117517:	90                   	nop    
  117518:	90                   	nop    
  117519:	90                   	nop    
  11751a:	90                   	nop    
  11751b:	90                   	nop    
  11751c:	90                   	nop    
  11751d:	90                   	nop    
  11751e:	90                   	nop    
  11751f:	90                   	nop    

00117520 <do_bind>:

static void
do_bind(struct api_msg_msg *msg)
{
  117520:	55                   	push   %ebp
  117521:	89 e5                	mov    %esp,%ebp
  117523:	53                   	push   %ebx
  117524:	83 ec 14             	sub    $0x14,%esp
  if (msg->conn->pcb.tcp == NULL) {
  117527:	8b 45 08             	mov    0x8(%ebp),%eax
  11752a:	8b 00                	mov    (%eax),%eax
  11752c:	8b 40 08             	mov    0x8(%eax),%eax
  11752f:	85 c0                	test   %eax,%eax
  117531:	0f 85 25 01 00 00    	jne    11765c <do_bind+0x13c>
    switch (msg->conn->type) {
  117537:	8b 45 08             	mov    0x8(%ebp),%eax
  11753a:	8b 00                	mov    (%eax),%eax
  11753c:	8b 00                	mov    (%eax),%eax
  11753e:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  117541:	83 7d f4 04          	cmpl   $0x4,0xfffffff4(%ebp)
  117545:	0f 87 11 01 00 00    	ja     11765c <do_bind+0x13c>
  11754b:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
  11754e:	8b 04 95 7c af 11 00 	mov    0x11af7c(,%edx,4),%eax
  117555:	ff e0                	jmp    *%eax
#if LWIP_RAW
    case NETCONN_RAW:
      msg->conn->pcb.raw = raw_new(msg->msg.bc.port); /* misusing the port field as protocol */
  117557:	8b 45 08             	mov    0x8(%ebp),%eax
  11755a:	8b 18                	mov    (%eax),%ebx
  11755c:	8b 45 08             	mov    0x8(%ebp),%eax
  11755f:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  117563:	0f b7 c0             	movzwl %ax,%eax
  117566:	89 04 24             	mov    %eax,(%esp)
  117569:	e8 02 87 ff ff       	call   10fc70 <raw_new>
  11756e:	89 43 08             	mov    %eax,0x8(%ebx)
      raw_recv(msg->conn->pcb.raw, recv_raw, msg->conn);
  117571:	8b 45 08             	mov    0x8(%ebp),%eax
  117574:	8b 10                	mov    (%eax),%edx
  117576:	8b 45 08             	mov    0x8(%ebp),%eax
  117579:	8b 00                	mov    (%eax),%eax
  11757b:	8b 40 08             	mov    0x8(%eax),%eax
  11757e:	89 54 24 08          	mov    %edx,0x8(%esp)
  117582:	c7 44 24 04 e0 6a 11 	movl   $0x116ae0,0x4(%esp)
  117589:	00 
  11758a:	89 04 24             	mov    %eax,(%esp)
  11758d:	e8 de 84 ff ff       	call   10fa70 <raw_recv>
      break;
  117592:	e9 c5 00 00 00       	jmp    11765c <do_bind+0x13c>
#endif
#if LWIP_UDP
    case NETCONN_UDPLITE:
      msg->conn->pcb.udp = udp_new();
  117597:	8b 45 08             	mov    0x8(%ebp),%eax
  11759a:	8b 18                	mov    (%eax),%ebx
  11759c:	e8 4f e2 ff ff       	call   1157f0 <udp_new>
  1175a1:	89 43 08             	mov    %eax,0x8(%ebx)
      udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_UDPLITE);
  1175a4:	8b 45 08             	mov    0x8(%ebp),%eax
  1175a7:	8b 00                	mov    (%eax),%eax
  1175a9:	8b 40 08             	mov    0x8(%eax),%eax
  1175ac:	c6 40 10 02          	movb   $0x2,0x10(%eax)
      udp_recv(msg->conn->pcb.udp, recv_udp, msg->conn);
  1175b0:	8b 45 08             	mov    0x8(%ebp),%eax
  1175b3:	8b 10                	mov    (%eax),%edx
  1175b5:	8b 45 08             	mov    0x8(%ebp),%eax
  1175b8:	8b 00                	mov    (%eax),%eax
  1175ba:	8b 40 08             	mov    0x8(%eax),%eax
  1175bd:	89 54 24 08          	mov    %edx,0x8(%esp)
  1175c1:	c7 44 24 04 d0 6b 11 	movl   $0x116bd0,0x4(%esp)
  1175c8:	00 
  1175c9:	89 04 24             	mov    %eax,(%esp)
  1175cc:	e8 8f e1 ff ff       	call   115760 <udp_recv>
      break;
  1175d1:	e9 86 00 00 00       	jmp    11765c <do_bind+0x13c>
    case NETCONN_UDPNOCHKSUM:
      msg->conn->pcb.udp = udp_new();
  1175d6:	8b 45 08             	mov    0x8(%ebp),%eax
  1175d9:	8b 18                	mov    (%eax),%ebx
  1175db:	e8 10 e2 ff ff       	call   1157f0 <udp_new>
  1175e0:	89 43 08             	mov    %eax,0x8(%ebx)
      udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_NOCHKSUM);
  1175e3:	8b 45 08             	mov    0x8(%ebp),%eax
  1175e6:	8b 00                	mov    (%eax),%eax
  1175e8:	8b 40 08             	mov    0x8(%eax),%eax
  1175eb:	c6 40 10 01          	movb   $0x1,0x10(%eax)
      udp_recv(msg->conn->pcb.udp, recv_udp, msg->conn);
  1175ef:	8b 45 08             	mov    0x8(%ebp),%eax
  1175f2:	8b 10                	mov    (%eax),%edx
  1175f4:	8b 45 08             	mov    0x8(%ebp),%eax
  1175f7:	8b 00                	mov    (%eax),%eax
  1175f9:	8b 40 08             	mov    0x8(%eax),%eax
  1175fc:	89 54 24 08          	mov    %edx,0x8(%esp)
  117600:	c7 44 24 04 d0 6b 11 	movl   $0x116bd0,0x4(%esp)
  117607:	00 
  117608:	89 04 24             	mov    %eax,(%esp)
  11760b:	e8 50 e1 ff ff       	call   115760 <udp_recv>
      break;
  117610:	eb 4a                	jmp    11765c <do_bind+0x13c>
    case NETCONN_UDP:
      msg->conn->pcb.udp = udp_new();
  117612:	8b 45 08             	mov    0x8(%ebp),%eax
  117615:	8b 18                	mov    (%eax),%ebx
  117617:	e8 d4 e1 ff ff       	call   1157f0 <udp_new>
  11761c:	89 43 08             	mov    %eax,0x8(%ebx)
      udp_recv(msg->conn->pcb.udp, recv_udp, msg->conn);
  11761f:	8b 45 08             	mov    0x8(%ebp),%eax
  117622:	8b 10                	mov    (%eax),%edx
  117624:	8b 45 08             	mov    0x8(%ebp),%eax
  117627:	8b 00                	mov    (%eax),%eax
  117629:	8b 40 08             	mov    0x8(%eax),%eax
  11762c:	89 54 24 08          	mov    %edx,0x8(%esp)
  117630:	c7 44 24 04 d0 6b 11 	movl   $0x116bd0,0x4(%esp)
  117637:	00 
  117638:	89 04 24             	mov    %eax,(%esp)
  11763b:	e8 20 e1 ff ff       	call   115760 <udp_recv>
      break;
  117640:	eb 1a                	jmp    11765c <do_bind+0x13c>
#endif /* LWIP_UDP */
#if LWIP_TCP      
    case NETCONN_TCP:
      msg->conn->pcb.tcp = tcp_new();
  117642:	8b 45 08             	mov    0x8(%ebp),%eax
  117645:	8b 18                	mov    (%eax),%ebx
  117647:	e8 64 9e ff ff       	call   1114b0 <tcp_new>
  11764c:	89 43 08             	mov    %eax,0x8(%ebx)
      setup_tcp(msg->conn);
  11764f:	8b 45 08             	mov    0x8(%ebp),%eax
  117652:	8b 00                	mov    (%eax),%eax
  117654:	89 04 24             	mov    %eax,(%esp)
  117657:	e8 d4 f8 ff ff       	call   116f30 <setup_tcp>
#endif /* LWIP_TCP */
    default:  
    break;
    }
  }
  switch (msg->conn->type) {
  11765c:	8b 45 08             	mov    0x8(%ebp),%eax
  11765f:	8b 00                	mov    (%eax),%eax
  117661:	8b 00                	mov    (%eax),%eax
  117663:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  117666:	83 7d f8 03          	cmpl   $0x3,0xfffffff8(%ebp)
  11766a:	77 08                	ja     117674 <do_bind+0x154>
  11766c:	83 7d f8 01          	cmpl   $0x1,0xfffffff8(%ebp)
  117670:	73 31                	jae    1176a3 <do_bind+0x183>
  117672:	eb 61                	jmp    1176d5 <do_bind+0x1b5>
  117674:	83 7d f8 04          	cmpl   $0x4,0xfffffff8(%ebp)
  117678:	74 05                	je     11767f <do_bind+0x15f>
  11767a:	e9 86 00 00 00       	jmp    117705 <do_bind+0x1e5>
#if LWIP_RAW
  case NETCONN_RAW:
    msg->conn->err = raw_bind(msg->conn->pcb.raw,msg->msg.bc.ipaddr);
  11767f:	8b 45 08             	mov    0x8(%ebp),%eax
  117682:	8b 18                	mov    (%eax),%ebx
  117684:	8b 45 08             	mov    0x8(%ebp),%eax
  117687:	8b 50 08             	mov    0x8(%eax),%edx
  11768a:	8b 45 08             	mov    0x8(%ebp),%eax
  11768d:	8b 00                	mov    (%eax),%eax
  11768f:	8b 40 08             	mov    0x8(%eax),%eax
  117692:	89 54 24 04          	mov    %edx,0x4(%esp)
  117696:	89 04 24             	mov    %eax,(%esp)
  117699:	e8 72 83 ff ff       	call   10fa10 <raw_bind>
  11769e:	88 43 0c             	mov    %al,0xc(%ebx)
    break;
  1176a1:	eb 62                	jmp    117705 <do_bind+0x1e5>
#endif
#if LWIP_UDP
  case NETCONN_UDPLITE:
    /* FALLTHROUGH */
  case NETCONN_UDPNOCHKSUM:
    /* FALLTHROUGH */
  case NETCONN_UDP:
    msg->conn->err = udp_bind(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  1176a3:	8b 45 08             	mov    0x8(%ebp),%eax
  1176a6:	8b 18                	mov    (%eax),%ebx
  1176a8:	8b 45 08             	mov    0x8(%ebp),%eax
  1176ab:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  1176af:	0f b7 c8             	movzwl %ax,%ecx
  1176b2:	8b 45 08             	mov    0x8(%ebp),%eax
  1176b5:	8b 50 08             	mov    0x8(%eax),%edx
  1176b8:	8b 45 08             	mov    0x8(%ebp),%eax
  1176bb:	8b 00                	mov    (%eax),%eax
  1176bd:	8b 40 08             	mov    0x8(%eax),%eax
  1176c0:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  1176c4:	89 54 24 04          	mov    %edx,0x4(%esp)
  1176c8:	89 04 24             	mov    %eax,(%esp)
  1176cb:	e8 a0 dd ff ff       	call   115470 <udp_bind>
  1176d0:	88 43 0c             	mov    %al,0xc(%ebx)
    break;
  1176d3:	eb 30                	jmp    117705 <do_bind+0x1e5>
#endif /* LWIP_UDP */
#if LWIP_TCP
  case NETCONN_TCP:
    msg->conn->err = tcp_bind(msg->conn->pcb.tcp,
  1176d5:	8b 45 08             	mov    0x8(%ebp),%eax
  1176d8:	8b 18                	mov    (%eax),%ebx
  1176da:	8b 45 08             	mov    0x8(%ebp),%eax
  1176dd:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  1176e1:	0f b7 c8             	movzwl %ax,%ecx
  1176e4:	8b 45 08             	mov    0x8(%ebp),%eax
  1176e7:	8b 50 08             	mov    0x8(%eax),%edx
  1176ea:	8b 45 08             	mov    0x8(%ebp),%eax
  1176ed:	8b 00                	mov    (%eax),%eax
  1176ef:	8b 40 08             	mov    0x8(%eax),%eax
  1176f2:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  1176f6:	89 54 24 04          	mov    %edx,0x4(%esp)
  1176fa:	89 04 24             	mov    %eax,(%esp)
  1176fd:	e8 ce 8d ff ff       	call   1104d0 <tcp_bind>
  117702:	88 43 0c             	mov    %al,0xc(%ebx)
            msg->msg.bc.ipaddr, msg->msg.bc.port);
#endif /* LWIP_TCP */
  default:
    break;
  }
  sys_mbox_post(msg->conn->mbox, NULL);
  117705:	8b 45 08             	mov    0x8(%ebp),%eax
  117708:	8b 00                	mov    (%eax),%eax
  11770a:	8b 40 10             	mov    0x10(%eax),%eax
  11770d:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  117714:	00 
  117715:	89 04 24             	mov    %eax,(%esp)
  117718:	e8 73 28 00 00       	call   119f90 <sys_mbox_post>
}
  11771d:	83 c4 14             	add    $0x14,%esp
  117720:	5b                   	pop    %ebx
  117721:	5d                   	pop    %ebp
  117722:	c3                   	ret    
  117723:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  117729:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00117730 <do_connected>:
#if LWIP_TCP

static err_t
do_connected(void *arg, struct tcp_pcb *pcb, err_t err)
{
  117730:	55                   	push   %ebp
  117731:	89 e5                	mov    %esp,%ebp
  117733:	83 ec 28             	sub    $0x28,%esp
  117736:	8b 45 10             	mov    0x10(%ebp),%eax
  117739:	88 45 ec             	mov    %al,0xffffffec(%ebp)
  struct netconn *conn;

  conn = arg;
  11773c:	8b 45 08             	mov    0x8(%ebp),%eax
  11773f:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)

  if (conn == NULL) {
  117742:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  117746:	75 09                	jne    117751 <do_connected+0x21>
    return ERR_VAL;
  117748:	c7 45 e8 f9 ff ff ff 	movl   $0xfffffff9,0xffffffe8(%ebp)
  11774f:	eb 41                	jmp    117792 <do_connected+0x62>
  }
  
  conn->err = err;
  117751:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  117754:	0f b6 45 ec          	movzbl 0xffffffec(%ebp),%eax
  117758:	88 42 0c             	mov    %al,0xc(%edx)
  if (conn->type == NETCONN_TCP && err == ERR_OK) {
  11775b:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  11775e:	8b 00                	mov    (%eax),%eax
  117760:	85 c0                	test   %eax,%eax
  117762:	75 11                	jne    117775 <do_connected+0x45>
  117764:	80 7d ec 00          	cmpb   $0x0,0xffffffec(%ebp)
  117768:	75 0b                	jne    117775 <do_connected+0x45>
    setup_tcp(conn);
  11776a:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  11776d:	89 04 24             	mov    %eax,(%esp)
  117770:	e8 bb f7 ff ff       	call   116f30 <setup_tcp>
  }    
  sys_mbox_post(conn->mbox, NULL);
  117775:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  117778:	8b 40 10             	mov    0x10(%eax),%eax
  11777b:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  117782:	00 
  117783:	89 04 24             	mov    %eax,(%esp)
  117786:	e8 05 28 00 00       	call   119f90 <sys_mbox_post>
  return ERR_OK;
  11778b:	c7 45 e8 00 00 00 00 	movl   $0x0,0xffffffe8(%ebp)
  117792:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
}
  117795:	c9                   	leave  
  117796:	c3                   	ret    
  117797:	89 f6                	mov    %esi,%esi
  117799:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

001177a0 <do_connect>:
#endif  

static void
do_connect(struct api_msg_msg *msg)
{
  1177a0:	55                   	push   %ebp
  1177a1:	89 e5                	mov    %esp,%ebp
  1177a3:	53                   	push   %ebx
  1177a4:	83 ec 24             	sub    $0x24,%esp
  if (msg->conn->pcb.tcp == NULL) {
  1177a7:	8b 45 08             	mov    0x8(%ebp),%eax
  1177aa:	8b 00                	mov    (%eax),%eax
  1177ac:	8b 40 08             	mov    0x8(%eax),%eax
  1177af:	85 c0                	test   %eax,%eax
  1177b1:	0f 85 e3 01 00 00    	jne    11799a <do_connect+0x1fa>
    switch (msg->conn->type) {
  1177b7:	8b 45 08             	mov    0x8(%ebp),%eax
  1177ba:	8b 00                	mov    (%eax),%eax
  1177bc:	8b 00                	mov    (%eax),%eax
  1177be:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  1177c1:	83 7d f4 04          	cmpl   $0x4,0xfffffff4(%ebp)
  1177c5:	0f 87 cf 01 00 00    	ja     11799a <do_connect+0x1fa>
  1177cb:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
  1177ce:	8b 04 95 90 af 11 00 	mov    0x11af90(,%edx,4),%eax
  1177d5:	ff e0                	jmp    *%eax
#if LWIP_RAW
    case NETCONN_RAW:
      msg->conn->pcb.raw = raw_new(msg->msg.bc.port); /* misusing the port field as protocol */
  1177d7:	8b 45 08             	mov    0x8(%ebp),%eax
  1177da:	8b 18                	mov    (%eax),%ebx
  1177dc:	8b 45 08             	mov    0x8(%ebp),%eax
  1177df:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  1177e3:	0f b7 c0             	movzwl %ax,%eax
  1177e6:	89 04 24             	mov    %eax,(%esp)
  1177e9:	e8 82 84 ff ff       	call   10fc70 <raw_new>
  1177ee:	89 43 08             	mov    %eax,0x8(%ebx)
      raw_recv(msg->conn->pcb.raw, recv_raw, msg->conn);
  1177f1:	8b 45 08             	mov    0x8(%ebp),%eax
  1177f4:	8b 10                	mov    (%eax),%edx
  1177f6:	8b 45 08             	mov    0x8(%ebp),%eax
  1177f9:	8b 00                	mov    (%eax),%eax
  1177fb:	8b 40 08             	mov    0x8(%eax),%eax
  1177fe:	89 54 24 08          	mov    %edx,0x8(%esp)
  117802:	c7 44 24 04 e0 6a 11 	movl   $0x116ae0,0x4(%esp)
  117809:	00 
  11780a:	89 04 24             	mov    %eax,(%esp)
  11780d:	e8 5e 82 ff ff       	call   10fa70 <raw_recv>
      break;
  117812:	e9 83 01 00 00       	jmp    11799a <do_connect+0x1fa>
#endif
#if LWIP_UDP
    case NETCONN_UDPLITE:
      msg->conn->pcb.udp = udp_new();
  117817:	8b 45 08             	mov    0x8(%ebp),%eax
  11781a:	8b 18                	mov    (%eax),%ebx
  11781c:	e8 cf df ff ff       	call   1157f0 <udp_new>
  117821:	89 43 08             	mov    %eax,0x8(%ebx)
      if (msg->conn->pcb.udp == NULL) {
  117824:	8b 45 08             	mov    0x8(%ebp),%eax
  117827:	8b 00                	mov    (%eax),%eax
  117829:	8b 40 08             	mov    0x8(%eax),%eax
  11782c:	85 c0                	test   %eax,%eax
  11782e:	75 26                	jne    117856 <do_connect+0xb6>
  msg->conn->err = ERR_MEM;
  117830:	8b 45 08             	mov    0x8(%ebp),%eax
  117833:	8b 00                	mov    (%eax),%eax
  117835:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  sys_mbox_post(msg->conn->mbox, NULL);
  117839:	8b 45 08             	mov    0x8(%ebp),%eax
  11783c:	8b 00                	mov    (%eax),%eax
  11783e:	8b 40 10             	mov    0x10(%eax),%eax
  117841:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  117848:	00 
  117849:	89 04 24             	mov    %eax,(%esp)
  11784c:	e8 3f 27 00 00       	call   119f90 <sys_mbox_post>
  return;
  117851:	e9 1d 02 00 00       	jmp    117a73 <do_connect+0x2d3>
      }
      udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_UDPLITE);
  117856:	8b 45 08             	mov    0x8(%ebp),%eax
  117859:	8b 00                	mov    (%eax),%eax
  11785b:	8b 40 08             	mov    0x8(%eax),%eax
  11785e:	c6 40 10 02          	movb   $0x2,0x10(%eax)
      udp_recv(msg->conn->pcb.udp, recv_udp, msg->conn);
  117862:	8b 45 08             	mov    0x8(%ebp),%eax
  117865:	8b 10                	mov    (%eax),%edx
  117867:	8b 45 08             	mov    0x8(%ebp),%eax
  11786a:	8b 00                	mov    (%eax),%eax
  11786c:	8b 40 08             	mov    0x8(%eax),%eax
  11786f:	89 54 24 08          	mov    %edx,0x8(%esp)
  117873:	c7 44 24 04 d0 6b 11 	movl   $0x116bd0,0x4(%esp)
  11787a:	00 
  11787b:	89 04 24             	mov    %eax,(%esp)
  11787e:	e8 dd de ff ff       	call   115760 <udp_recv>
      break;
  117883:	e9 12 01 00 00       	jmp    11799a <do_connect+0x1fa>
    case NETCONN_UDPNOCHKSUM:
      msg->conn->pcb.udp = udp_new();
  117888:	8b 45 08             	mov    0x8(%ebp),%eax
  11788b:	8b 18                	mov    (%eax),%ebx
  11788d:	e8 5e df ff ff       	call   1157f0 <udp_new>
  117892:	89 43 08             	mov    %eax,0x8(%ebx)
      if (msg->conn->pcb.udp == NULL) {
  117895:	8b 45 08             	mov    0x8(%ebp),%eax
  117898:	8b 00                	mov    (%eax),%eax
  11789a:	8b 40 08             	mov    0x8(%eax),%eax
  11789d:	85 c0                	test   %eax,%eax
  11789f:	75 26                	jne    1178c7 <do_connect+0x127>
  msg->conn->err = ERR_MEM;
  1178a1:	8b 45 08             	mov    0x8(%ebp),%eax
  1178a4:	8b 00                	mov    (%eax),%eax
  1178a6:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  sys_mbox_post(msg->conn->mbox, NULL);
  1178aa:	8b 45 08             	mov    0x8(%ebp),%eax
  1178ad:	8b 00                	mov    (%eax),%eax
  1178af:	8b 40 10             	mov    0x10(%eax),%eax
  1178b2:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  1178b9:	00 
  1178ba:	89 04 24             	mov    %eax,(%esp)
  1178bd:	e8 ce 26 00 00       	call   119f90 <sys_mbox_post>
  return;
  1178c2:	e9 ac 01 00 00       	jmp    117a73 <do_connect+0x2d3>
      }
      udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_NOCHKSUM);
  1178c7:	8b 45 08             	mov    0x8(%ebp),%eax
  1178ca:	8b 00                	mov    (%eax),%eax
  1178cc:	8b 40 08             	mov    0x8(%eax),%eax
  1178cf:	c6 40 10 01          	movb   $0x1,0x10(%eax)
      udp_recv(msg->conn->pcb.udp, recv_udp, msg->conn);
  1178d3:	8b 45 08             	mov    0x8(%ebp),%eax
  1178d6:	8b 10                	mov    (%eax),%edx
  1178d8:	8b 45 08             	mov    0x8(%ebp),%eax
  1178db:	8b 00                	mov    (%eax),%eax
  1178dd:	8b 40 08             	mov    0x8(%eax),%eax
  1178e0:	89 54 24 08          	mov    %edx,0x8(%esp)
  1178e4:	c7 44 24 04 d0 6b 11 	movl   $0x116bd0,0x4(%esp)
  1178eb:	00 
  1178ec:	89 04 24             	mov    %eax,(%esp)
  1178ef:	e8 6c de ff ff       	call   115760 <udp_recv>
      break;
  1178f4:	e9 a1 00 00 00       	jmp    11799a <do_connect+0x1fa>
    case NETCONN_UDP:
      msg->conn->pcb.udp = udp_new();
  1178f9:	8b 45 08             	mov    0x8(%ebp),%eax
  1178fc:	8b 18                	mov    (%eax),%ebx
  1178fe:	e8 ed de ff ff       	call   1157f0 <udp_new>
  117903:	89 43 08             	mov    %eax,0x8(%ebx)
      if (msg->conn->pcb.udp == NULL) {
  117906:	8b 45 08             	mov    0x8(%ebp),%eax
  117909:	8b 00                	mov    (%eax),%eax
  11790b:	8b 40 08             	mov    0x8(%eax),%eax
  11790e:	85 c0                	test   %eax,%eax
  117910:	75 26                	jne    117938 <do_connect+0x198>
  msg->conn->err = ERR_MEM;
  117912:	8b 45 08             	mov    0x8(%ebp),%eax
  117915:	8b 00                	mov    (%eax),%eax
  117917:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  sys_mbox_post(msg->conn->mbox, NULL);
  11791b:	8b 45 08             	mov    0x8(%ebp),%eax
  11791e:	8b 00                	mov    (%eax),%eax
  117920:	8b 40 10             	mov    0x10(%eax),%eax
  117923:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  11792a:	00 
  11792b:	89 04 24             	mov    %eax,(%esp)
  11792e:	e8 5d 26 00 00       	call   119f90 <sys_mbox_post>
  return;
  117933:	e9 3b 01 00 00       	jmp    117a73 <do_connect+0x2d3>
      }
      udp_recv(msg->conn->pcb.udp, recv_udp, msg->conn);
  117938:	8b 45 08             	mov    0x8(%ebp),%eax
  11793b:	8b 10                	mov    (%eax),%edx
  11793d:	8b 45 08             	mov    0x8(%ebp),%eax
  117940:	8b 00                	mov    (%eax),%eax
  117942:	8b 40 08             	mov    0x8(%eax),%eax
  117945:	89 54 24 08          	mov    %edx,0x8(%esp)
  117949:	c7 44 24 04 d0 6b 11 	movl   $0x116bd0,0x4(%esp)
  117950:	00 
  117951:	89 04 24             	mov    %eax,(%esp)
  117954:	e8 07 de ff ff       	call   115760 <udp_recv>
      break;
  117959:	eb 3f                	jmp    11799a <do_connect+0x1fa>
#endif /* LWIP_UDP */
#if LWIP_TCP      
    case NETCONN_TCP:
      msg->conn->pcb.tcp = tcp_new();      
  11795b:	8b 45 08             	mov    0x8(%ebp),%eax
  11795e:	8b 18                	mov    (%eax),%ebx
  117960:	e8 4b 9b ff ff       	call   1114b0 <tcp_new>
  117965:	89 43 08             	mov    %eax,0x8(%ebx)
      if (msg->conn->pcb.tcp == NULL) {
  117968:	8b 45 08             	mov    0x8(%ebp),%eax
  11796b:	8b 00                	mov    (%eax),%eax
  11796d:	8b 40 08             	mov    0x8(%eax),%eax
  117970:	85 c0                	test   %eax,%eax
  117972:	75 26                	jne    11799a <do_connect+0x1fa>
  msg->conn->err = ERR_MEM;
  117974:	8b 45 08             	mov    0x8(%ebp),%eax
  117977:	8b 00                	mov    (%eax),%eax
  117979:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  sys_mbox_post(msg->conn->mbox, NULL);
  11797d:	8b 45 08             	mov    0x8(%ebp),%eax
  117980:	8b 00                	mov    (%eax),%eax
  117982:	8b 40 10             	mov    0x10(%eax),%eax
  117985:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  11798c:	00 
  11798d:	89 04 24             	mov    %eax,(%esp)
  117990:	e8 fb 25 00 00       	call   119f90 <sys_mbox_post>
  return;
  117995:	e9 d9 00 00 00       	jmp    117a73 <do_connect+0x2d3>
      }
#endif
    default:
      break;
    }
  }
  switch (msg->conn->type) {
  11799a:	8b 45 08             	mov    0x8(%ebp),%eax
  11799d:	8b 00                	mov    (%eax),%eax
  11799f:	8b 00                	mov    (%eax),%eax
  1179a1:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  1179a4:	83 7d f8 03          	cmpl   $0x3,0xfffffff8(%ebp)
  1179a8:	77 0b                	ja     1179b5 <do_connect+0x215>
  1179aa:	83 7d f8 01          	cmpl   $0x1,0xfffffff8(%ebp)
  1179ae:	73 44                	jae    1179f4 <do_connect+0x254>
  1179b0:	e9 81 00 00 00       	jmp    117a36 <do_connect+0x296>
  1179b5:	83 7d f8 04          	cmpl   $0x4,0xfffffff8(%ebp)
  1179b9:	74 05                	je     1179c0 <do_connect+0x220>
  1179bb:	e9 b3 00 00 00       	jmp    117a73 <do_connect+0x2d3>
#if LWIP_RAW
  case NETCONN_RAW:
    raw_connect(msg->conn->pcb.raw, msg->msg.bc.ipaddr);
  1179c0:	8b 45 08             	mov    0x8(%ebp),%eax
  1179c3:	8b 50 08             	mov    0x8(%eax),%edx
  1179c6:	8b 45 08             	mov    0x8(%ebp),%eax
  1179c9:	8b 00                	mov    (%eax),%eax
  1179cb:	8b 40 08             	mov    0x8(%eax),%eax
  1179ce:	89 54 24 04          	mov    %edx,0x4(%esp)
  1179d2:	89 04 24             	mov    %eax,(%esp)
  1179d5:	e8 66 80 ff ff       	call   10fa40 <raw_connect>
    sys_mbox_post(msg->conn->mbox, NULL);
  1179da:	8b 45 08             	mov    0x8(%ebp),%eax
  1179dd:	8b 00                	mov    (%eax),%eax
  1179df:	8b 40 10             	mov    0x10(%eax),%eax
  1179e2:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  1179e9:	00 
  1179ea:	89 04 24             	mov    %eax,(%esp)
  1179ed:	e8 9e 25 00 00       	call   119f90 <sys_mbox_post>
    break;
  1179f2:	eb 7f                	jmp    117a73 <do_connect+0x2d3>
#endif
#if LWIP_UDP
  case NETCONN_UDPLITE:
    /* FALLTHROUGH */
  case NETCONN_UDPNOCHKSUM:
    /* FALLTHROUGH */
  case NETCONN_UDP:
    udp_connect(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  1179f4:	8b 45 08             	mov    0x8(%ebp),%eax
  1179f7:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  1179fb:	0f b7 c8             	movzwl %ax,%ecx
  1179fe:	8b 45 08             	mov    0x8(%ebp),%eax
  117a01:	8b 50 08             	mov    0x8(%eax),%edx
  117a04:	8b 45 08             	mov    0x8(%ebp),%eax
  117a07:	8b 00                	mov    (%eax),%eax
  117a09:	8b 40 08             	mov    0x8(%eax),%eax
  117a0c:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  117a10:	89 54 24 04          	mov    %edx,0x4(%esp)
  117a14:	89 04 24             	mov    %eax,(%esp)
  117a17:	e8 34 dc ff ff       	call   115650 <udp_connect>
    sys_mbox_post(msg->conn->mbox, NULL);
  117a1c:	8b 45 08             	mov    0x8(%ebp),%eax
  117a1f:	8b 00                	mov    (%eax),%eax
  117a21:	8b 40 10             	mov    0x10(%eax),%eax
  117a24:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  117a2b:	00 
  117a2c:	89 04 24             	mov    %eax,(%esp)
  117a2f:	e8 5c 25 00 00       	call   119f90 <sys_mbox_post>
    break;
  117a34:	eb 3d                	jmp    117a73 <do_connect+0x2d3>
#endif 
#if LWIP_TCP      
  case NETCONN_TCP:
    /*    tcp_arg(msg->conn->pcb.tcp, msg->conn);*/
    setup_tcp(msg->conn);
  117a36:	8b 45 08             	mov    0x8(%ebp),%eax
  117a39:	8b 00                	mov    (%eax),%eax
  117a3b:	89 04 24             	mov    %eax,(%esp)
  117a3e:	e8 ed f4 ff ff       	call   116f30 <setup_tcp>
    tcp_connect(msg->conn->pcb.tcp, msg->msg.bc.ipaddr, msg->msg.bc.port,
  117a43:	8b 45 08             	mov    0x8(%ebp),%eax
  117a46:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  117a4a:	0f b7 d0             	movzwl %ax,%edx
  117a4d:	8b 45 08             	mov    0x8(%ebp),%eax
  117a50:	8b 48 08             	mov    0x8(%eax),%ecx
  117a53:	8b 45 08             	mov    0x8(%ebp),%eax
  117a56:	8b 00                	mov    (%eax),%eax
  117a58:	8b 40 08             	mov    0x8(%eax),%eax
  117a5b:	c7 44 24 0c 30 77 11 	movl   $0x117730,0xc(%esp)
  117a62:	00 
  117a63:	89 54 24 08          	mov    %edx,0x8(%esp)
  117a67:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  117a6b:	89 04 24             	mov    %eax,(%esp)
  117a6e:	e8 0d 90 ff ff       	call   110a80 <tcp_connect>
    do_connected);
    /*tcp_output(msg->conn->pcb.tcp);*/
#endif

  default:
    break;
  }
}
  117a73:	83 c4 24             	add    $0x24,%esp
  117a76:	5b                   	pop    %ebx
  117a77:	5d                   	pop    %ebp
  117a78:	c3                   	ret    
  117a79:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

00117a80 <do_disconnect>:

static void
do_disconnect(struct api_msg_msg *msg)
{
  117a80:	55                   	push   %ebp
  117a81:	89 e5                	mov    %esp,%ebp
  117a83:	83 ec 18             	sub    $0x18,%esp

  switch (msg->conn->type) {
  117a86:	8b 45 08             	mov    0x8(%ebp),%eax
  117a89:	8b 00                	mov    (%eax),%eax
  117a8b:	8b 00                	mov    (%eax),%eax
  117a8d:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  117a90:	83 7d fc 01          	cmpl   $0x1,0xfffffffc(%ebp)
  117a94:	72 18                	jb     117aae <do_disconnect+0x2e>
  117a96:	83 7d fc 03          	cmpl   $0x3,0xfffffffc(%ebp)
  117a9a:	76 02                	jbe    117a9e <do_disconnect+0x1e>
  117a9c:	eb 10                	jmp    117aae <do_disconnect+0x2e>
#if LWIP_RAW
  case NETCONN_RAW:
    /* Do nothing as connecting is only a helper for upper lwip layers */
    break;
#endif
#if LWIP_UDP
  case NETCONN_UDPLITE:
    /* FALLTHROUGH */
  case NETCONN_UDPNOCHKSUM:
    /* FALLTHROUGH */
  case NETCONN_UDP:
    udp_disconnect(msg->conn->pcb.udp);
  117a9e:	8b 45 08             	mov    0x8(%ebp),%eax
  117aa1:	8b 00                	mov    (%eax),%eax
  117aa3:	8b 40 08             	mov    0x8(%eax),%eax
  117aa6:	89 04 24             	mov    %eax,(%esp)
  117aa9:	e8 82 dc ff ff       	call   115730 <udp_disconnect>
    break;
#endif 
  case NETCONN_TCP:
    break;
  }
  sys_mbox_post(msg->conn->mbox, NULL);
  117aae:	8b 45 08             	mov    0x8(%ebp),%eax
  117ab1:	8b 00                	mov    (%eax),%eax
  117ab3:	8b 40 10             	mov    0x10(%eax),%eax
  117ab6:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  117abd:	00 
  117abe:	89 04 24             	mov    %eax,(%esp)
  117ac1:	e8 ca 24 00 00       	call   119f90 <sys_mbox_post>
}
  117ac6:	c9                   	leave  
  117ac7:	c3                   	ret    
  117ac8:	90                   	nop    
  117ac9:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

00117ad0 <do_listen>:


static void
do_listen(struct api_msg_msg *msg)
{
  117ad0:	55                   	push   %ebp
  117ad1:	89 e5                	mov    %esp,%ebp
  117ad3:	53                   	push   %ebx
  117ad4:	83 ec 14             	sub    $0x14,%esp
  if (msg->conn->pcb.tcp != NULL) {
  117ad7:	8b 45 08             	mov    0x8(%ebp),%eax
  117ada:	8b 00                	mov    (%eax),%eax
  117adc:	8b 40 08             	mov    0x8(%eax),%eax
  117adf:	85 c0                	test   %eax,%eax
  117ae1:	0f 84 b1 00 00 00    	je     117b98 <do_listen+0xc8>
    switch (msg->conn->type) {
  117ae7:	8b 45 08             	mov    0x8(%ebp),%eax
  117aea:	8b 00                	mov    (%eax),%eax
  117aec:	8b 00                	mov    (%eax),%eax
  117aee:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  117af1:	83 7d f8 03          	cmpl   $0x3,0xfffffff8(%ebp)
  117af5:	77 0c                	ja     117b03 <do_listen+0x33>
  117af7:	83 7d f8 01          	cmpl   $0x1,0xfffffff8(%ebp)
  117afb:	0f 83 97 00 00 00    	jae    117b98 <do_listen+0xc8>
  117b01:	eb 05                	jmp    117b08 <do_listen+0x38>
  117b03:	e9 90 00 00 00       	jmp    117b98 <do_listen+0xc8>
#if LWIP_RAW
    case NETCONN_RAW:
      LWIP_DEBUGF(API_MSG_DEBUG, ("api_msg: listen RAW: cannot listen for RAW.\n"));
      break;
#endif
#if LWIP_UDP
    case NETCONN_UDPLITE:
      /* FALLTHROUGH */
    case NETCONN_UDPNOCHKSUM:
      /* FALLTHROUGH */
    case NETCONN_UDP:
      LWIP_DEBUGF(API_MSG_DEBUG, ("api_msg: listen UDP: cannot listen for UDP.\n"));
      break;
#endif /* LWIP_UDP */
#if LWIP_TCP      
    case NETCONN_TCP:
      msg->conn->pcb.tcp = tcp_listen(msg->conn->pcb.tcp);
  117b08:	8b 45 08             	mov    0x8(%ebp),%eax
  117b0b:	8b 18                	mov    (%eax),%ebx
  117b0d:	8b 45 08             	mov    0x8(%ebp),%eax
  117b10:	8b 00                	mov    (%eax),%eax
  117b12:	8b 40 08             	mov    0x8(%eax),%eax
  117b15:	89 04 24             	mov    %eax,(%esp)
  117b18:	e8 e3 8c ff ff       	call   110800 <tcp_listen>
  117b1d:	89 43 08             	mov    %eax,0x8(%ebx)
      if (msg->conn->pcb.tcp == NULL) {
  117b20:	8b 45 08             	mov    0x8(%ebp),%eax
  117b23:	8b 00                	mov    (%eax),%eax
  117b25:	8b 40 08             	mov    0x8(%eax),%eax
  117b28:	85 c0                	test   %eax,%eax
  117b2a:	75 0b                	jne    117b37 <do_listen+0x67>
  msg->conn->err = ERR_MEM;
  117b2c:	8b 45 08             	mov    0x8(%ebp),%eax
  117b2f:	8b 00                	mov    (%eax),%eax
  117b31:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  117b35:	eb 61                	jmp    117b98 <do_listen+0xc8>
      } else {
  if (msg->conn->acceptmbox == SYS_MBOX_NULL) {
  117b37:	8b 45 08             	mov    0x8(%ebp),%eax
  117b3a:	8b 00                	mov    (%eax),%eax
  117b3c:	8b 40 18             	mov    0x18(%eax),%eax
  117b3f:	85 c0                	test   %eax,%eax
  117b41:	75 24                	jne    117b67 <do_listen+0x97>
    msg->conn->acceptmbox = sys_mbox_new();
  117b43:	8b 45 08             	mov    0x8(%ebp),%eax
  117b46:	8b 18                	mov    (%eax),%ebx
  117b48:	e8 13 23 00 00       	call   119e60 <sys_mbox_new>
  117b4d:	89 43 18             	mov    %eax,0x18(%ebx)
    if (msg->conn->acceptmbox == SYS_MBOX_NULL) {
  117b50:	8b 45 08             	mov    0x8(%ebp),%eax
  117b53:	8b 00                	mov    (%eax),%eax
  117b55:	8b 40 18             	mov    0x18(%eax),%eax
  117b58:	85 c0                	test   %eax,%eax
  117b5a:	75 0b                	jne    117b67 <do_listen+0x97>
      msg->conn->err = ERR_MEM;
  117b5c:	8b 45 08             	mov    0x8(%ebp),%eax
  117b5f:	8b 00                	mov    (%eax),%eax
  117b61:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
      break;
  117b65:	eb 31                	jmp    117b98 <do_listen+0xc8>
    }
  }
  tcp_arg(msg->conn->pcb.tcp, msg->conn);
  117b67:	8b 45 08             	mov    0x8(%ebp),%eax
  117b6a:	8b 10                	mov    (%eax),%edx
  117b6c:	8b 45 08             	mov    0x8(%ebp),%eax
  117b6f:	8b 00                	mov    (%eax),%eax
  117b71:	8b 40 08             	mov    0x8(%eax),%eax
  117b74:	89 54 24 04          	mov    %edx,0x4(%esp)
  117b78:	89 04 24             	mov    %eax,(%esp)
  117b7b:	e8 50 99 ff ff       	call   1114d0 <tcp_arg>
  tcp_accept(msg->conn->pcb.tcp, accept_function);
  117b80:	8b 45 08             	mov    0x8(%ebp),%eax
  117b83:	8b 00                	mov    (%eax),%eax
  117b85:	8b 40 08             	mov    0x8(%eax),%eax
  117b88:	c7 44 24 04 b0 6f 11 	movl   $0x116fb0,0x4(%esp)
  117b8f:	00 
  117b90:	89 04 24             	mov    %eax,(%esp)
  117b93:	e8 98 99 ff ff       	call   111530 <tcp_accept>
      }
#endif
    default:
      break;
    }
  }
  sys_mbox_post(msg->conn->mbox, NULL);
  117b98:	8b 45 08             	mov    0x8(%ebp),%eax
  117b9b:	8b 00                	mov    (%eax),%eax
  117b9d:	8b 40 10             	mov    0x10(%eax),%eax
  117ba0:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  117ba7:	00 
  117ba8:	89 04 24             	mov    %eax,(%esp)
  117bab:	e8 e0 23 00 00       	call   119f90 <sys_mbox_post>
}
  117bb0:	83 c4 14             	add    $0x14,%esp
  117bb3:	5b                   	pop    %ebx
  117bb4:	5d                   	pop    %ebp
  117bb5:	c3                   	ret    
  117bb6:	8d 76 00             	lea    0x0(%esi),%esi
  117bb9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00117bc0 <do_accept>:

static void
do_accept(struct api_msg_msg *msg)
{
  117bc0:	55                   	push   %ebp
  117bc1:	89 e5                	mov    %esp,%ebp
  117bc3:	83 ec 04             	sub    $0x4,%esp
  if (msg->conn->pcb.tcp != NULL) {
  117bc6:	8b 45 08             	mov    0x8(%ebp),%eax
  117bc9:	8b 00                	mov    (%eax),%eax
  117bcb:	8b 40 08             	mov    0x8(%eax),%eax
  117bce:	85 c0                	test   %eax,%eax
  117bd0:	74 16                	je     117be8 <do_accept+0x28>
    switch (msg->conn->type) {
  117bd2:	8b 45 08             	mov    0x8(%ebp),%eax
  117bd5:	8b 00                	mov    (%eax),%eax
  117bd7:	8b 00                	mov    (%eax),%eax
  117bd9:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  117bdc:	83 7d fc 01          	cmpl   $0x1,0xfffffffc(%ebp)
  117be0:	72 06                	jb     117be8 <do_accept+0x28>
  117be2:	83 7d fc 03          	cmpl   $0x3,0xfffffffc(%ebp)
  117be6:	76 00                	jbe    117be8 <do_accept+0x28>
#if LWIP_RAW
    case NETCONN_RAW:
      LWIP_DEBUGF(API_MSG_DEBUG, ("api_msg: accept RAW: cannot accept for RAW.\n"));
      break;
#endif
#if LWIP_UDP
    case NETCONN_UDPLITE:
      /* FALLTHROUGH */
    case NETCONN_UDPNOCHKSUM:
      /* FALLTHROUGH */
    case NETCONN_UDP:    
      LWIP_DEBUGF(API_MSG_DEBUG, ("api_msg: accept UDP: cannot accept for UDP.\n"));
      break;
#endif /* LWIP_UDP */
    case NETCONN_TCP:
      break;
    }
  }
}
  117be8:	c9                   	leave  
  117be9:	c3                   	ret    
  117bea:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

00117bf0 <do_send>:

static void
do_send(struct api_msg_msg *msg)
{
  117bf0:	55                   	push   %ebp
  117bf1:	89 e5                	mov    %esp,%ebp
  117bf3:	83 ec 18             	sub    $0x18,%esp
  if (msg->conn->pcb.tcp != NULL) {
  117bf6:	8b 45 08             	mov    0x8(%ebp),%eax
  117bf9:	8b 00                	mov    (%eax),%eax
  117bfb:	8b 40 08             	mov    0x8(%eax),%eax
  117bfe:	85 c0                	test   %eax,%eax
  117c00:	74 54                	je     117c56 <do_send+0x66>
    switch (msg->conn->type) {
  117c02:	8b 45 08             	mov    0x8(%ebp),%eax
  117c05:	8b 00                	mov    (%eax),%eax
  117c07:	8b 00                	mov    (%eax),%eax
  117c09:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  117c0c:	83 7d fc 01          	cmpl   $0x1,0xfffffffc(%ebp)
  117c10:	72 44                	jb     117c56 <do_send+0x66>
  117c12:	83 7d fc 03          	cmpl   $0x3,0xfffffffc(%ebp)
  117c16:	76 24                	jbe    117c3c <do_send+0x4c>
  117c18:	83 7d fc 04          	cmpl   $0x4,0xfffffffc(%ebp)
  117c1c:	74 02                	je     117c20 <do_send+0x30>
  117c1e:	eb 36                	jmp    117c56 <do_send+0x66>
#if LWIP_RAW
    case NETCONN_RAW:
      raw_send(msg->conn->pcb.raw, msg->msg.p);
  117c20:	8b 45 08             	mov    0x8(%ebp),%eax
  117c23:	8b 50 08             	mov    0x8(%eax),%edx
  117c26:	8b 45 08             	mov    0x8(%ebp),%eax
  117c29:	8b 00                	mov    (%eax),%eax
  117c2b:	8b 40 08             	mov    0x8(%eax),%eax
  117c2e:	89 54 24 04          	mov    %edx,0x4(%esp)
  117c32:	89 04 24             	mov    %eax,(%esp)
  117c35:	e8 96 7f ff ff       	call   10fbd0 <raw_send>
      break;
  117c3a:	eb 1a                	jmp    117c56 <do_send+0x66>
#endif
#if LWIP_UDP
    case NETCONN_UDPLITE:
      /* FALLTHROUGH */
    case NETCONN_UDPNOCHKSUM:
      /* FALLTHROUGH */
    case NETCONN_UDP:
      udp_send(msg->conn->pcb.udp, msg->msg.p);
  117c3c:	8b 45 08             	mov    0x8(%ebp),%eax
  117c3f:	8b 50 08             	mov    0x8(%eax),%edx
  117c42:	8b 45 08             	mov    0x8(%ebp),%eax
  117c45:	8b 00                	mov    (%eax),%eax
  117c47:	8b 40 08             	mov    0x8(%eax),%eax
  117c4a:	89 54 24 04          	mov    %edx,0x4(%esp)
  117c4e:	89 04 24             	mov    %eax,(%esp)
  117c51:	e8 fa d4 ff ff       	call   115150 <udp_send>
      break;
#endif /* LWIP_UDP */
    case NETCONN_TCP:
      break;
    }
  }
  sys_mbox_post(msg->conn->mbox, NULL);
  117c56:	8b 45 08             	mov    0x8(%ebp),%eax
  117c59:	8b 00                	mov    (%eax),%eax
  117c5b:	8b 40 10             	mov    0x10(%eax),%eax
  117c5e:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  117c65:	00 
  117c66:	89 04 24             	mov    %eax,(%esp)
  117c69:	e8 22 23 00 00       	call   119f90 <sys_mbox_post>
}
  117c6e:	c9                   	leave  
  117c6f:	c3                   	ret    

00117c70 <do_recv>:

static void
do_recv(struct api_msg_msg *msg)
{
  117c70:	55                   	push   %ebp
  117c71:	89 e5                	mov    %esp,%ebp
  117c73:	83 ec 08             	sub    $0x8,%esp
#if LWIP_TCP
  if (msg->conn->pcb.tcp != NULL) {
  117c76:	8b 45 08             	mov    0x8(%ebp),%eax
  117c79:	8b 00                	mov    (%eax),%eax
  117c7b:	8b 40 08             	mov    0x8(%eax),%eax
  117c7e:	85 c0                	test   %eax,%eax
  117c80:	74 29                	je     117cab <do_recv+0x3b>
    if (msg->conn->type == NETCONN_TCP) {
  117c82:	8b 45 08             	mov    0x8(%ebp),%eax
  117c85:	8b 00                	mov    (%eax),%eax
  117c87:	8b 00                	mov    (%eax),%eax
  117c89:	85 c0                	test   %eax,%eax
  117c8b:	75 1e                	jne    117cab <do_recv+0x3b>
      tcp_recved(msg->conn->pcb.tcp, msg->msg.len);
  117c8d:	8b 45 08             	mov    0x8(%ebp),%eax
  117c90:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  117c94:	0f b7 d0             	movzwl %ax,%edx
  117c97:	8b 45 08             	mov    0x8(%ebp),%eax
  117c9a:	8b 00                	mov    (%eax),%eax
  117c9c:	8b 40 08             	mov    0x8(%eax),%eax
  117c9f:	89 54 24 04          	mov    %edx,0x4(%esp)
  117ca3:	89 04 24             	mov    %eax,(%esp)
  117ca6:	e8 55 8c ff ff       	call   110900 <tcp_recved>
    }
  }
#endif  
  sys_mbox_post(msg->conn->mbox, NULL);
  117cab:	8b 45 08             	mov    0x8(%ebp),%eax
  117cae:	8b 00                	mov    (%eax),%eax
  117cb0:	8b 40 10             	mov    0x10(%eax),%eax
  117cb3:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  117cba:	00 
  117cbb:	89 04 24             	mov    %eax,(%esp)
  117cbe:	e8 cd 22 00 00       	call   119f90 <sys_mbox_post>
}
  117cc3:	c9                   	leave  
  117cc4:	c3                   	ret    
  117cc5:	8d 74 26 00          	lea    0x0(%esi),%esi
  117cc9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00117cd0 <do_write>:

static void
do_write(struct api_msg_msg *msg)
{
  117cd0:	55                   	push   %ebp
  117cd1:	89 e5                	mov    %esp,%ebp
  117cd3:	53                   	push   %ebx
  117cd4:	83 ec 24             	sub    $0x24,%esp
#if LWIP_TCP  
  err_t err;
#endif  
  if (msg->conn->pcb.tcp != NULL) {
  117cd7:	8b 45 08             	mov    0x8(%ebp),%eax
  117cda:	8b 00                	mov    (%eax),%eax
  117cdc:	8b 40 08             	mov    0x8(%eax),%eax
  117cdf:	85 c0                	test   %eax,%eax
  117ce1:	0f 84 0b 01 00 00    	je     117df2 <do_write+0x122>
    switch (msg->conn->type) {
  117ce7:	8b 45 08             	mov    0x8(%ebp),%eax
  117cea:	8b 00                	mov    (%eax),%eax
  117cec:	8b 00                	mov    (%eax),%eax
  117cee:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
  117cf1:	83 7d e8 03          	cmpl   $0x3,0xffffffe8(%ebp)
  117cf5:	77 08                	ja     117cff <do_write+0x2f>
  117cf7:	83 7d e8 01          	cmpl   $0x1,0xffffffe8(%ebp)
  117cfb:	73 1b                	jae    117d18 <do_write+0x48>
  117cfd:	eb 27                	jmp    117d26 <do_write+0x56>
  117cff:	83 7d e8 04          	cmpl   $0x4,0xffffffe8(%ebp)
  117d03:	74 05                	je     117d0a <do_write+0x3a>
  117d05:	e9 e8 00 00 00       	jmp    117df2 <do_write+0x122>
#if LWIP_RAW
    case NETCONN_RAW:
      msg->conn->err = ERR_VAL;
  117d0a:	8b 45 08             	mov    0x8(%ebp),%eax
  117d0d:	8b 00                	mov    (%eax),%eax
  117d0f:	c6 40 0c f9          	movb   $0xf9,0xc(%eax)
      break;
  117d13:	e9 da 00 00 00       	jmp    117df2 <do_write+0x122>
#endif
#if LWIP_UDP 
    case NETCONN_UDPLITE:
      /* FALLTHROUGH */
    case NETCONN_UDPNOCHKSUM:
      /* FALLTHROUGH */
    case NETCONN_UDP:
      msg->conn->err = ERR_VAL;
  117d18:	8b 45 08             	mov    0x8(%ebp),%eax
  117d1b:	8b 00                	mov    (%eax),%eax
  117d1d:	c6 40 0c f9          	movb   $0xf9,0xc(%eax)
      break;
  117d21:	e9 cc 00 00 00       	jmp    117df2 <do_write+0x122>
#endif /* LWIP_UDP */
#if LWIP_TCP 
    case NETCONN_TCP:      
      err = tcp_write(msg->conn->pcb.tcp, msg->msg.w.dataptr,
  117d26:	8b 45 08             	mov    0x8(%ebp),%eax
  117d29:	0f b6 40 0e          	movzbl 0xe(%eax),%eax
  117d2d:	0f b6 d0             	movzbl %al,%edx
  117d30:	8b 45 08             	mov    0x8(%ebp),%eax
  117d33:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  117d37:	0f b7 c8             	movzwl %ax,%ecx
  117d3a:	8b 45 08             	mov    0x8(%ebp),%eax
  117d3d:	8b 58 08             	mov    0x8(%eax),%ebx
  117d40:	8b 45 08             	mov    0x8(%ebp),%eax
  117d43:	8b 00                	mov    (%eax),%eax
  117d45:	8b 40 08             	mov    0x8(%eax),%eax
  117d48:	89 54 24 0c          	mov    %edx,0xc(%esp)
  117d4c:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  117d50:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  117d54:	89 04 24             	mov    %eax,(%esp)
  117d57:	e8 d4 99 ff ff       	call   111730 <tcp_write>
  117d5c:	88 45 fb             	mov    %al,0xfffffffb(%ebp)
                      msg->msg.w.len, msg->msg.w.copy);
      /* This is the Nagle algorithm: inhibit the sending of new TCP
   segments when new outgoing data arrives from the user if any
   previously transmitted data on the connection remains
   unacknowledged. */
      if(err == ERR_OK && (msg->conn->pcb.tcp->unacked == NULL || (msg->conn->pcb.tcp->flags & TF_NODELAY)) ) {
  117d5f:	80 7d fb 00          	cmpb   $0x0,0xfffffffb(%ebp)
  117d63:	75 35                	jne    117d9a <do_write+0xca>
  117d65:	8b 45 08             	mov    0x8(%ebp),%eax
  117d68:	8b 00                	mov    (%eax),%eax
  117d6a:	8b 40 08             	mov    0x8(%eax),%eax
  117d6d:	8b 40 74             	mov    0x74(%eax),%eax
  117d70:	85 c0                	test   %eax,%eax
  117d72:	74 16                	je     117d8a <do_write+0xba>
  117d74:	8b 45 08             	mov    0x8(%ebp),%eax
  117d77:	8b 00                	mov    (%eax),%eax
  117d79:	8b 40 08             	mov    0x8(%eax),%eax
  117d7c:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  117d80:	0f b6 c0             	movzbl %al,%eax
  117d83:	83 e0 40             	and    $0x40,%eax
  117d86:	85 c0                	test   %eax,%eax
  117d88:	74 10                	je     117d9a <do_write+0xca>
  tcp_output(msg->conn->pcb.tcp);
  117d8a:	8b 45 08             	mov    0x8(%ebp),%eax
  117d8d:	8b 00                	mov    (%eax),%eax
  117d8f:	8b 40 08             	mov    0x8(%eax),%eax
  117d92:	89 04 24             	mov    %eax,(%esp)
  117d95:	e8 b6 a0 ff ff       	call   111e50 <tcp_output>
      }
      msg->conn->err = err;
  117d9a:	8b 45 08             	mov    0x8(%ebp),%eax
  117d9d:	8b 10                	mov    (%eax),%edx
  117d9f:	0f b6 45 fb          	movzbl 0xfffffffb(%ebp),%eax
  117da3:	88 42 0c             	mov    %al,0xc(%edx)
      if (msg->conn->callback)
  117da6:	8b 45 08             	mov    0x8(%ebp),%eax
  117da9:	8b 00                	mov    (%eax),%eax
  117dab:	8b 40 28             	mov    0x28(%eax),%eax
  117dae:	85 c0                	test   %eax,%eax
  117db0:	74 40                	je     117df2 <do_write+0x122>
          if (err == ERR_OK)
  117db2:	80 7d fb 00          	cmpb   $0x0,0xfffffffb(%ebp)
  117db6:	75 3a                	jne    117df2 <do_write+0x122>
          {
              if (tcp_sndbuf(msg->conn->pcb.tcp) <= TCP_SNDLOWAT)
  117db8:	8b 45 08             	mov    0x8(%ebp),%eax
  117dbb:	8b 00                	mov    (%eax),%eax
  117dbd:	8b 40 08             	mov    0x8(%eax),%eax
  117dc0:	0f b7 40 6a          	movzwl 0x6a(%eax),%eax
  117dc4:	66 3d 00 04          	cmp    $0x400,%ax
  117dc8:	77 28                	ja     117df2 <do_write+0x122>
                  (*msg->conn->callback)(msg->conn, NETCONN_EVT_SENDMINUS, msg->msg.w.len);
  117dca:	8b 45 08             	mov    0x8(%ebp),%eax
  117dcd:	8b 00                	mov    (%eax),%eax
  117dcf:	8b 48 28             	mov    0x28(%eax),%ecx
  117dd2:	8b 45 08             	mov    0x8(%ebp),%eax
  117dd5:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  117dd9:	0f b7 d0             	movzwl %ax,%edx
  117ddc:	8b 45 08             	mov    0x8(%ebp),%eax
  117ddf:	8b 00                	mov    (%eax),%eax
  117de1:	89 54 24 08          	mov    %edx,0x8(%esp)
  117de5:	c7 44 24 04 03 00 00 	movl   $0x3,0x4(%esp)
  117dec:	00 
  117ded:	89 04 24             	mov    %eax,(%esp)
  117df0:	ff d1                	call   *%ecx
          }
#endif
    default:
      break;
    }
  }
  sys_mbox_post(msg->conn->mbox, NULL);
  117df2:	8b 45 08             	mov    0x8(%ebp),%eax
  117df5:	8b 00                	mov    (%eax),%eax
  117df7:	8b 40 10             	mov    0x10(%eax),%eax
  117dfa:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  117e01:	00 
  117e02:	89 04 24             	mov    %eax,(%esp)
  117e05:	e8 86 21 00 00       	call   119f90 <sys_mbox_post>
}
  117e0a:	83 c4 24             	add    $0x24,%esp
  117e0d:	5b                   	pop    %ebx
  117e0e:	5d                   	pop    %ebp
  117e0f:	c3                   	ret    

00117e10 <do_close>:

static void
do_close(struct api_msg_msg *msg)
{
  117e10:	55                   	push   %ebp
  117e11:	89 e5                	mov    %esp,%ebp
  117e13:	83 ec 28             	sub    $0x28,%esp
  err_t err;

  err = ERR_OK;
  117e16:	c6 45 ff 00          	movb   $0x0,0xffffffff(%ebp)

  if (msg->conn->pcb.tcp != NULL) {
  117e1a:	8b 45 08             	mov    0x8(%ebp),%eax
  117e1d:	8b 00                	mov    (%eax),%eax
  117e1f:	8b 40 08             	mov    0x8(%eax),%eax
  117e22:	85 c0                	test   %eax,%eax
  117e24:	74 49                	je     117e6f <do_close+0x5f>
    switch (msg->conn->type) {
  117e26:	8b 45 08             	mov    0x8(%ebp),%eax
  117e29:	8b 00                	mov    (%eax),%eax
  117e2b:	8b 00                	mov    (%eax),%eax
  117e2d:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  117e30:	83 7d ec 03          	cmpl   $0x3,0xffffffec(%ebp)
  117e34:	77 08                	ja     117e3e <do_close+0x2e>
  117e36:	83 7d ec 01          	cmpl   $0x1,0xffffffec(%ebp)
  117e3a:	73 33                	jae    117e6f <do_close+0x5f>
  117e3c:	eb 02                	jmp    117e40 <do_close+0x30>
  117e3e:	eb 2f                	jmp    117e6f <do_close+0x5f>
#if LWIP_RAW
    case NETCONN_RAW:
      break;
#endif
#if LWIP_UDP
    case NETCONN_UDPLITE:
      /* FALLTHROUGH */
    case NETCONN_UDPNOCHKSUM:
      /* FALLTHROUGH */
    case NETCONN_UDP:
      break;
#endif /* LWIP_UDP */
#if LWIP_TCP
    case NETCONN_TCP:
      if (msg->conn->pcb.tcp->state == LISTEN) {
  117e40:	8b 45 08             	mov    0x8(%ebp),%eax
  117e43:	8b 00                	mov    (%eax),%eax
  117e45:	8b 40 08             	mov    0x8(%eax),%eax
  117e48:	8b 40 10             	mov    0x10(%eax),%eax
  117e4b:	83 f8 01             	cmp    $0x1,%eax
  117e4e:	75 13                	jne    117e63 <do_close+0x53>
  err = tcp_close(msg->conn->pcb.tcp);
  117e50:	8b 45 08             	mov    0x8(%ebp),%eax
  117e53:	8b 00                	mov    (%eax),%eax
  117e55:	8b 40 08             	mov    0x8(%eax),%eax
  117e58:	89 04 24             	mov    %eax,(%esp)
  117e5b:	e8 e0 83 ff ff       	call   110240 <tcp_close>
  117e60:	88 45 ff             	mov    %al,0xffffffff(%ebp)
      }
      msg->conn->err = err;      
  117e63:	8b 45 08             	mov    0x8(%ebp),%eax
  117e66:	8b 10                	mov    (%eax),%edx
  117e68:	0f b6 45 ff          	movzbl 0xffffffff(%ebp),%eax
  117e6c:	88 42 0c             	mov    %al,0xc(%edx)
#endif
    default:      
      break;
    }
  }
  sys_mbox_post(msg->conn->mbox, NULL);
  117e6f:	8b 45 08             	mov    0x8(%ebp),%eax
  117e72:	8b 00                	mov    (%eax),%eax
  117e74:	8b 40 10             	mov    0x10(%eax),%eax
  117e77:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  117e7e:	00 
  117e7f:	89 04 24             	mov    %eax,(%esp)
  117e82:	e8 09 21 00 00       	call   119f90 <sys_mbox_post>
}
  117e87:	c9                   	leave  
  117e88:	c3                   	ret    
  117e89:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

00117e90 <api_msg_input>:

typedef void (* api_msg_decode)(struct api_msg_msg *msg);
static api_msg_decode decode[API_MSG_MAX] = {
  do_newconn,
  do_delconn,
  do_bind,
  do_connect,
  do_disconnect,
  do_listen,
  do_accept,
  do_send,
  do_recv,
  do_write,
  do_close
  };
void
api_msg_input(struct api_msg *msg)
{  
  117e90:	55                   	push   %ebp
  117e91:	89 e5                	mov    %esp,%ebp
  117e93:	83 ec 08             	sub    $0x8,%esp
  decode[msg->type](&(msg->msg));
  117e96:	8b 45 08             	mov    0x8(%ebp),%eax
  117e99:	8b 00                	mov    (%eax),%eax
  117e9b:	8b 14 85 c0 cb 11 00 	mov    0x11cbc0(,%eax,4),%edx
  117ea2:	8b 45 08             	mov    0x8(%ebp),%eax
  117ea5:	83 c0 04             	add    $0x4,%eax
  117ea8:	89 04 24             	mov    %eax,(%esp)
  117eab:	ff d2                	call   *%edx
}
  117ead:	c9                   	leave  
  117eae:	c3                   	ret    
  117eaf:	90                   	nop    

00117eb0 <api_msg_post>:

void
api_msg_post(struct api_msg *msg)
{
  117eb0:	55                   	push   %ebp
  117eb1:	89 e5                	mov    %esp,%ebp
  117eb3:	83 ec 08             	sub    $0x8,%esp
  tcpip_apimsg(msg);
  117eb6:	8b 45 08             	mov    0x8(%ebp),%eax
  117eb9:	89 04 24             	mov    %eax,(%esp)
  117ebc:	e8 ef 1d 00 00       	call   119cb0 <tcpip_apimsg>
}
  117ec1:	c9                   	leave  
  117ec2:	c3                   	ret    
  117ec3:	90                   	nop    
  117ec4:	90                   	nop    
  117ec5:	90                   	nop    
  117ec6:	90                   	nop    
  117ec7:	90                   	nop    
  117ec8:	90                   	nop    
  117ec9:	90                   	nop    
  117eca:	90                   	nop    
  117ecb:	90                   	nop    
  117ecc:	90                   	nop    
  117ecd:	90                   	nop    
  117ece:	90                   	nop    
  117ecf:	90                   	nop    

00117ed0 <lwip_strerr>:


char *
lwip_strerr(err_t err)
{
  117ed0:	55                   	push   %ebp
  117ed1:	89 e5                	mov    %esp,%ebp
  117ed3:	83 ec 04             	sub    $0x4,%esp
  117ed6:	8b 45 08             	mov    0x8(%ebp),%eax
  117ed9:	88 45 fc             	mov    %al,0xfffffffc(%ebp)
  return err_strerr[-err];
  117edc:	0f be 45 fc          	movsbl 0xfffffffc(%ebp),%eax
  117ee0:	f7 d8                	neg    %eax
  117ee2:	8b 04 85 00 cc 11 00 	mov    0x11cc00(,%eax,4),%eax

}
  117ee9:	c9                   	leave  
  117eea:	c3                   	ret    
  117eeb:	90                   	nop    
  117eec:	90                   	nop    
  117eed:	90                   	nop    
  117eee:	90                   	nop    
  117eef:	90                   	nop    

00117ef0 <get_socket>:


static struct lwip_socket *
get_socket(int s)
{
  117ef0:	55                   	push   %ebp
  117ef1:	89 e5                	mov    %esp,%ebp
  117ef3:	83 ec 14             	sub    $0x14,%esp
  struct lwip_socket *sock;

  if ((s < 0) || (s > NUM_SOCKETS)) {
  117ef6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  117efa:	78 06                	js     117f02 <get_socket+0x12>
  117efc:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
  117f00:	7e 09                	jle    117f0b <get_socket+0x1b>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("get_socket(%d): invalid\n", s));
    set_errno(EBADF);
    return NULL;
  117f02:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  117f09:	eb 2d                	jmp    117f38 <get_socket+0x48>
  }

  sock = &sockets[s];
  117f0b:	8b 55 08             	mov    0x8(%ebp),%edx
  117f0e:	89 d0                	mov    %edx,%eax
  117f10:	c1 e0 02             	shl    $0x2,%eax
  117f13:	01 d0                	add    %edx,%eax
  117f15:	c1 e0 02             	shl    $0x2,%eax
  117f18:	05 60 99 13 00       	add    $0x139960,%eax
  117f1d:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)

  if (!sock->conn) {
  117f20:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  117f23:	8b 00                	mov    (%eax),%eax
  117f25:	85 c0                	test   %eax,%eax
  117f27:	75 09                	jne    117f32 <get_socket+0x42>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("get_socket(%d): not active\n", s));
    set_errno(EBADF);
    return NULL;
  117f29:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  117f30:	eb 06                	jmp    117f38 <get_socket+0x48>
  }

  return sock;
  117f32:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  117f35:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  117f38:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  117f3b:	c9                   	leave  
  117f3c:	c3                   	ret    
  117f3d:	8d 76 00             	lea    0x0(%esi),%esi

00117f40 <alloc_socket>:

static int
alloc_socket(struct netconn *newconn)
{
  117f40:	55                   	push   %ebp
  117f41:	89 e5                	mov    %esp,%ebp
  117f43:	83 ec 18             	sub    $0x18,%esp
  int i;

  if (!socksem)
  117f46:	a1 44 99 13 00       	mov    0x139944,%eax
  117f4b:	85 c0                	test   %eax,%eax
  117f4d:	75 11                	jne    117f60 <alloc_socket+0x20>
      socksem = sys_sem_new(1);
  117f4f:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  117f56:	e8 f5 1d 00 00       	call   119d50 <sys_sem_new>
  117f5b:	a3 44 99 13 00       	mov    %eax,0x139944

  /* Protect socket array */
  sys_sem_wait(socksem);
  117f60:	a1 44 99 13 00       	mov    0x139944,%eax
  117f65:	89 04 24             	mov    %eax,(%esp)
  117f68:	e8 a3 7e ff ff       	call   10fe10 <sys_sem_wait>

  /* allocate a new socket identifier */
  for(i = 0; i < NUM_SOCKETS; ++i) {
  117f6d:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
  117f74:	e9 d4 00 00 00       	jmp    11804d <alloc_socket+0x10d>
    if (!sockets[i].conn) {
  117f79:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  117f7c:	89 d0                	mov    %edx,%eax
  117f7e:	c1 e0 02             	shl    $0x2,%eax
  117f81:	01 d0                	add    %edx,%eax
  117f83:	c1 e0 02             	shl    $0x2,%eax
  117f86:	8b 80 60 99 13 00    	mov    0x139960(%eax),%eax
  117f8c:	85 c0                	test   %eax,%eax
  117f8e:	0f 85 b5 00 00 00    	jne    118049 <alloc_socket+0x109>
      sockets[i].conn = newconn;
  117f94:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  117f97:	89 d0                	mov    %edx,%eax
  117f99:	c1 e0 02             	shl    $0x2,%eax
  117f9c:	01 d0                	add    %edx,%eax
  117f9e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  117fa5:	8b 45 08             	mov    0x8(%ebp),%eax
  117fa8:	89 82 60 99 13 00    	mov    %eax,0x139960(%edx)
      sockets[i].lastdata = NULL;
  117fae:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  117fb1:	89 d0                	mov    %edx,%eax
  117fb3:	c1 e0 02             	shl    $0x2,%eax
  117fb6:	01 d0                	add    %edx,%eax
  117fb8:	c1 e0 02             	shl    $0x2,%eax
  117fbb:	c7 80 64 99 13 00 00 	movl   $0x0,0x139964(%eax)
  117fc2:	00 00 00 
      sockets[i].lastoffset = 0;
  117fc5:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  117fc8:	89 d0                	mov    %edx,%eax
  117fca:	c1 e0 02             	shl    $0x2,%eax
  117fcd:	01 d0                	add    %edx,%eax
  117fcf:	c1 e0 02             	shl    $0x2,%eax
  117fd2:	66 c7 80 68 99 13 00 	movw   $0x0,0x139968(%eax)
  117fd9:	00 00 
      sockets[i].rcvevent = 0;
  117fdb:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  117fde:	89 d0                	mov    %edx,%eax
  117fe0:	c1 e0 02             	shl    $0x2,%eax
  117fe3:	01 d0                	add    %edx,%eax
  117fe5:	c1 e0 02             	shl    $0x2,%eax
  117fe8:	66 c7 80 6a 99 13 00 	movw   $0x0,0x13996a(%eax)
  117fef:	00 00 
      sockets[i].sendevent = 1; /* TCP send buf is empty */
  117ff1:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  117ff4:	89 d0                	mov    %edx,%eax
  117ff6:	c1 e0 02             	shl    $0x2,%eax
  117ff9:	01 d0                	add    %edx,%eax
  117ffb:	c1 e0 02             	shl    $0x2,%eax
  117ffe:	66 c7 80 6c 99 13 00 	movw   $0x1,0x13996c(%eax)
  118005:	01 00 
      sockets[i].flags = 0;
  118007:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  11800a:	89 d0                	mov    %edx,%eax
  11800c:	c1 e0 02             	shl    $0x2,%eax
  11800f:	01 d0                	add    %edx,%eax
  118011:	c1 e0 02             	shl    $0x2,%eax
  118014:	66 c7 80 6e 99 13 00 	movw   $0x0,0x13996e(%eax)
  11801b:	00 00 
      sockets[i].err = 0;
  11801d:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  118020:	89 d0                	mov    %edx,%eax
  118022:	c1 e0 02             	shl    $0x2,%eax
  118025:	01 d0                	add    %edx,%eax
  118027:	c1 e0 02             	shl    $0x2,%eax
  11802a:	c7 80 70 99 13 00 00 	movl   $0x0,0x139970(%eax)
  118031:	00 00 00 
      sys_sem_signal(socksem);
  118034:	a1 44 99 13 00       	mov    0x139944,%eax
  118039:	89 04 24             	mov    %eax,(%esp)
  11803c:	e8 8f 1d 00 00       	call   119dd0 <sys_sem_signal>
      return i;
  118041:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  118044:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  118047:	eb 22                	jmp    11806b <alloc_socket+0x12b>
  118049:	83 45 fc 01          	addl   $0x1,0xfffffffc(%ebp)
  11804d:	83 7d fc 03          	cmpl   $0x3,0xfffffffc(%ebp)
  118051:	0f 8e 22 ff ff ff    	jle    117f79 <alloc_socket+0x39>
    }
  }
  sys_sem_signal(socksem);
  118057:	a1 44 99 13 00       	mov    0x139944,%eax
  11805c:	89 04 24             	mov    %eax,(%esp)
  11805f:	e8 6c 1d 00 00       	call   119dd0 <sys_sem_signal>
  return -1;
  118064:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  11806b:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  11806e:	c9                   	leave  
  11806f:	c3                   	ret    

00118070 <lwip_accept>:

int
lwip_accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
  118070:	55                   	push   %ebp
  118071:	89 e5                	mov    %esp,%ebp
  118073:	83 ec 48             	sub    $0x48,%esp
  struct lwip_socket *sock;
  struct netconn *newconn;
  struct ip_addr naddr;
  u16_t port;
  int newsock;
  struct sockaddr_in sin;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d)...\n", s));
  sock = get_socket(s);
  118076:	8b 45 08             	mov    0x8(%ebp),%eax
  118079:	89 04 24             	mov    %eax,(%esp)
  11807c:	e8 6f fe ff ff       	call   117ef0 <get_socket>
  118081:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  if (!sock) {
  118084:	83 7d f4 00          	cmpl   $0x0,0xfffffff4(%ebp)
  118088:	75 0c                	jne    118096 <lwip_accept+0x26>
    set_errno(EBADF);
    return -1;
  11808a:	c7 45 cc ff ff ff ff 	movl   $0xffffffff,0xffffffcc(%ebp)
  118091:	e9 28 01 00 00       	jmp    1181be <lwip_accept+0x14e>
  }

  newconn = netconn_accept(sock->conn);
  118096:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  118099:	8b 00                	mov    (%eax),%eax
  11809b:	89 04 24             	mov    %eax,(%esp)
  11809e:	e8 ad e3 ff ff       	call   116450 <netconn_accept>
  1180a3:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)

  /* get the IP address and port of the remote host */
  netconn_peer(newconn, &naddr, &port);
  1180a6:	8d 45 ee             	lea    0xffffffee(%ebp),%eax
  1180a9:	89 44 24 08          	mov    %eax,0x8(%esp)
  1180ad:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
  1180b0:	89 44 24 04          	mov    %eax,0x4(%esp)
  1180b4:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1180b7:	89 04 24             	mov    %eax,(%esp)
  1180ba:	e8 21 df ff ff       	call   115fe0 <netconn_peer>

  memset(&sin, 0, sizeof(sin));
  1180bf:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
  1180c6:	00 
  1180c7:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  1180ce:	00 
  1180cf:	8d 45 dc             	lea    0xffffffdc(%ebp),%eax
  1180d2:	89 04 24             	mov    %eax,(%esp)
  1180d5:	e8 f6 dd fe ff       	call   105ed0 <memset>
  sin.sin_len = sizeof(sin);
  1180da:	c6 45 dc 10          	movb   $0x10,0xffffffdc(%ebp)
  sin.sin_family = AF_INET;
  1180de:	c6 45 dd 02          	movb   $0x2,0xffffffdd(%ebp)
  sin.sin_port = htons(port);
  1180e2:	0f b7 45 ee          	movzwl 0xffffffee(%ebp),%eax
  1180e6:	0f b7 c0             	movzwl %ax,%eax
  1180e9:	89 04 24             	mov    %eax,(%esp)
  1180ec:	e8 8f 61 ff ff       	call   10e280 <htons>
  1180f1:	66 89 45 de          	mov    %ax,0xffffffde(%ebp)
  sin.sin_addr.s_addr = naddr.addr;
  1180f5:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  1180f8:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)

  if (*addrlen > sizeof(sin))
  1180fb:	8b 45 10             	mov    0x10(%ebp),%eax
  1180fe:	8b 00                	mov    (%eax),%eax
  118100:	83 f8 10             	cmp    $0x10,%eax
  118103:	76 09                	jbe    11810e <lwip_accept+0x9e>
      *addrlen = sizeof(sin);
  118105:	8b 45 10             	mov    0x10(%ebp),%eax
  118108:	c7 00 10 00 00 00    	movl   $0x10,(%eax)

  memcpy(addr, &sin, *addrlen);
  11810e:	8b 45 10             	mov    0x10(%ebp),%eax
  118111:	8b 00                	mov    (%eax),%eax
  118113:	89 44 24 08          	mov    %eax,0x8(%esp)
  118117:	8d 45 dc             	lea    0xffffffdc(%ebp),%eax
  11811a:	89 44 24 04          	mov    %eax,0x4(%esp)
  11811e:	8b 45 0c             	mov    0xc(%ebp),%eax
  118121:	89 04 24             	mov    %eax,(%esp)
  118124:	e8 67 dd fe ff       	call   105e90 <memcpy>

  newsock = alloc_socket(newconn);
  118129:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  11812c:	89 04 24             	mov    %eax,(%esp)
  11812f:	e8 0c fe ff ff       	call   117f40 <alloc_socket>
  118134:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  if (newsock == -1) {
  118137:	83 7d fc ff          	cmpl   $0xffffffff,0xfffffffc(%ebp)
  11813b:	75 1e                	jne    11815b <lwip_accept+0xeb>
    netconn_delete(newconn);
  11813d:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  118140:	89 04 24             	mov    %eax,(%esp)
  118143:	e8 f8 dc ff ff       	call   115e40 <netconn_delete>
  sock_set_errno(sock, ENOBUFS);
  118148:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  11814b:	c7 40 10 69 00 00 00 	movl   $0x69,0x10(%eax)
  return -1;
  118152:	c7 45 cc ff ff ff ff 	movl   $0xffffffff,0xffffffcc(%ebp)
  118159:	eb 63                	jmp    1181be <lwip_accept+0x14e>
  }
  newconn->callback = event_callback;
  11815b:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  11815e:	c7 40 28 20 90 11 00 	movl   $0x119020,0x28(%eax)
  sock = get_socket(newsock);
  118165:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  118168:	89 04 24             	mov    %eax,(%esp)
  11816b:	e8 80 fd ff ff       	call   117ef0 <get_socket>
  118170:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)

  sys_sem_wait(socksem);
  118173:	a1 44 99 13 00       	mov    0x139944,%eax
  118178:	89 04 24             	mov    %eax,(%esp)
  11817b:	e8 90 7c ff ff       	call   10fe10 <sys_sem_wait>
  sock->rcvevent += -1 - newconn->socket;
  118180:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  118183:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
  118187:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  11818a:	8b 40 20             	mov    0x20(%eax),%eax
  11818d:	f7 d0                	not    %eax
  11818f:	01 c2                	add    %eax,%edx
  118191:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  118194:	66 89 50 0a          	mov    %dx,0xa(%eax)
  newconn->socket = newsock;
  118198:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  11819b:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  11819e:	89 42 20             	mov    %eax,0x20(%edx)
  sys_sem_signal(socksem);
  1181a1:	a1 44 99 13 00       	mov    0x139944,%eax
  1181a6:	89 04 24             	mov    %eax,(%esp)
  1181a9:	e8 22 1c 00 00       	call   119dd0 <sys_sem_signal>

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d) returning new sock=%d addr=", s, newsock));
  ip_addr_debug_print(SOCKETS_DEBUG, &naddr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u\n", port));

  sock_set_errno(sock, 0);
  1181ae:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  1181b1:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  return newsock;
  1181b8:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1181bb:	89 45 cc             	mov    %eax,0xffffffcc(%ebp)
  1181be:	8b 45 cc             	mov    0xffffffcc(%ebp),%eax
}
  1181c1:	c9                   	leave  
  1181c2:	c3                   	ret    
  1181c3:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  1181c9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

001181d0 <lwip_bind>:

int
lwip_bind(int s, struct sockaddr *name, socklen_t namelen)
{
  1181d0:	55                   	push   %ebp
  1181d1:	89 e5                	mov    %esp,%ebp
  1181d3:	83 ec 28             	sub    $0x28,%esp
  struct lwip_socket *sock;
  struct ip_addr local_addr;
  u16_t local_port;
  err_t err;

  sock = get_socket(s);
  1181d6:	8b 45 08             	mov    0x8(%ebp),%eax
  1181d9:	89 04 24             	mov    %eax,(%esp)
  1181dc:	e8 0f fd ff ff       	call   117ef0 <get_socket>
  1181e1:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  if (!sock) {
  1181e4:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  1181e8:	75 0c                	jne    1181f6 <lwip_bind+0x26>
    set_errno(EBADF);
    return -1;
  1181ea:	c7 45 e8 ff ff ff ff 	movl   $0xffffffff,0xffffffe8(%ebp)
  1181f1:	e9 88 00 00 00       	jmp    11827e <lwip_bind+0xae>
  }

  local_addr.addr = ((struct sockaddr_in *)name)->sin_addr.s_addr;
  1181f6:	8b 45 0c             	mov    0xc(%ebp),%eax
  1181f9:	8b 40 04             	mov    0x4(%eax),%eax
  1181fc:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  local_port = ((struct sockaddr_in *)name)->sin_port;
  1181ff:	8b 45 0c             	mov    0xc(%ebp),%eax
  118202:	0f b7 40 02          	movzwl 0x2(%eax),%eax
  118206:	66 89 45 fc          	mov    %ax,0xfffffffc(%ebp)

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d, addr=", s));
  ip_addr_debug_print(SOCKETS_DEBUG, &local_addr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u)\n", ntohs(local_port)));

  err = netconn_bind(sock->conn, &local_addr, ntohs(local_port));
  11820a:	0f b7 45 fc          	movzwl 0xfffffffc(%ebp),%eax
  11820e:	89 04 24             	mov    %eax,(%esp)
  118211:	e8 9a 60 ff ff       	call   10e2b0 <ntohs>
  118216:	0f b7 d0             	movzwl %ax,%edx
  118219:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  11821c:	8b 08                	mov    (%eax),%ecx
  11821e:	89 54 24 08          	mov    %edx,0x8(%esp)
  118222:	8d 45 f4             	lea    0xfffffff4(%ebp),%eax
  118225:	89 44 24 04          	mov    %eax,0x4(%esp)
  118229:	89 0c 24             	mov    %ecx,(%esp)
  11822c:	e8 ff de ff ff       	call   116130 <netconn_bind>
  118231:	88 45 ff             	mov    %al,0xffffffff(%ebp)

  if (err != ERR_OK) {
  118234:	80 7d ff 00          	cmpb   $0x0,0xffffffff(%ebp)
  118238:	74 33                	je     11826d <lwip_bind+0x9d>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d) failed, err=%d\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
  11823a:	0f b6 45 ff          	movzbl 0xffffffff(%ebp),%eax
  11823e:	3c 0a                	cmp    $0xa,%al
  118240:	77 12                	ja     118254 <lwip_bind+0x84>
  118242:	0f be 45 ff          	movsbl 0xffffffff(%ebp),%eax
  118246:	f7 d8                	neg    %eax
  118248:	8b 04 85 40 cc 11 00 	mov    0x11cc40(,%eax,4),%eax
  11824f:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  118252:	eb 07                	jmp    11825b <lwip_bind+0x8b>
  118254:	c7 45 ec 05 00 00 00 	movl   $0x5,0xffffffec(%ebp)
  11825b:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  11825e:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
  118261:	89 50 10             	mov    %edx,0x10(%eax)
    return -1;
  118264:	c7 45 e8 ff ff ff ff 	movl   $0xffffffff,0xffffffe8(%ebp)
  11826b:	eb 11                	jmp    11827e <lwip_bind+0xae>
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d) succeeded\n", s));
  sock_set_errno(sock, 0);
  11826d:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  118270:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  return 0;
  118277:	c7 45 e8 00 00 00 00 	movl   $0x0,0xffffffe8(%ebp)
  11827e:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
}
  118281:	c9                   	leave  
  118282:	c3                   	ret    
  118283:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  118289:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00118290 <lwip_close>:

int
lwip_close(int s)
{
  118290:	55                   	push   %ebp
  118291:	89 e5                	mov    %esp,%ebp
  118293:	83 ec 18             	sub    $0x18,%esp
  struct lwip_socket *sock;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_close(%d)\n", s));
  if (!socksem)
  118296:	a1 44 99 13 00       	mov    0x139944,%eax
  11829b:	85 c0                	test   %eax,%eax
  11829d:	75 11                	jne    1182b0 <lwip_close+0x20>
      socksem = sys_sem_new(1);
  11829f:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  1182a6:	e8 a5 1a 00 00       	call   119d50 <sys_sem_new>
  1182ab:	a3 44 99 13 00       	mov    %eax,0x139944

  /* We cannot allow multiple closes of the same socket. */
  sys_sem_wait(socksem);
  1182b0:	a1 44 99 13 00       	mov    0x139944,%eax
  1182b5:	89 04 24             	mov    %eax,(%esp)
  1182b8:	e8 53 7b ff ff       	call   10fe10 <sys_sem_wait>

  sock = get_socket(s);
  1182bd:	8b 45 08             	mov    0x8(%ebp),%eax
  1182c0:	89 04 24             	mov    %eax,(%esp)
  1182c3:	e8 28 fc ff ff       	call   117ef0 <get_socket>
  1182c8:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  if (!sock) {
  1182cb:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  1182cf:	75 16                	jne    1182e7 <lwip_close+0x57>
      sys_sem_signal(socksem);
  1182d1:	a1 44 99 13 00       	mov    0x139944,%eax
  1182d6:	89 04 24             	mov    %eax,(%esp)
  1182d9:	e8 f2 1a 00 00       	call   119dd0 <sys_sem_signal>
      set_errno(EBADF);
      return -1;
  1182de:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  1182e5:	eb 5f                	jmp    118346 <lwip_close+0xb6>
  }

  netconn_delete(sock->conn);
  1182e7:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1182ea:	8b 00                	mov    (%eax),%eax
  1182ec:	89 04 24             	mov    %eax,(%esp)
  1182ef:	e8 4c db ff ff       	call   115e40 <netconn_delete>
  if (sock->lastdata) {
  1182f4:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1182f7:	8b 40 04             	mov    0x4(%eax),%eax
  1182fa:	85 c0                	test   %eax,%eax
  1182fc:	74 0e                	je     11830c <lwip_close+0x7c>
    netbuf_delete(sock->lastdata);
  1182fe:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  118301:	8b 40 04             	mov    0x4(%eax),%eax
  118304:	89 04 24             	mov    %eax,(%esp)
  118307:	e8 84 d5 ff ff       	call   115890 <netbuf_delete>
  }
  sock->lastdata = NULL;
  11830c:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  11830f:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  sock->lastoffset = 0;
  118316:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  118319:	66 c7 40 08 00 00    	movw   $0x0,0x8(%eax)
  sock->conn = NULL;
  11831f:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  118322:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  sys_sem_signal(socksem);
  118328:	a1 44 99 13 00       	mov    0x139944,%eax
  11832d:	89 04 24             	mov    %eax,(%esp)
  118330:	e8 9b 1a 00 00       	call   119dd0 <sys_sem_signal>
  sock_set_errno(sock, 0);
  118335:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  118338:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  return 0;
  11833f:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  118346:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  118349:	c9                   	leave  
  11834a:	c3                   	ret    
  11834b:	90                   	nop    
  11834c:	8d 74 26 00          	lea    0x0(%esi),%esi

00118350 <lwip_connect>:

int
lwip_connect(int s, struct sockaddr *name, socklen_t namelen)
{
  118350:	55                   	push   %ebp
  118351:	89 e5                	mov    %esp,%ebp
  118353:	83 ec 28             	sub    $0x28,%esp
  struct lwip_socket *sock;
  err_t err;

  sock = get_socket(s);
  118356:	8b 45 08             	mov    0x8(%ebp),%eax
  118359:	89 04 24             	mov    %eax,(%esp)
  11835c:	e8 8f fb ff ff       	call   117ef0 <get_socket>
  118361:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  if (!sock) {
  118364:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  118368:	75 0c                	jne    118376 <lwip_connect+0x26>
    set_errno(EBADF);
    return -1;
  11836a:	c7 45 e8 ff ff ff ff 	movl   $0xffffffff,0xffffffe8(%ebp)
  118371:	e9 a5 00 00 00       	jmp    11841b <lwip_connect+0xcb>
  }

  if (((struct sockaddr_in *)name)->sin_family == AF_UNSPEC) {
  118376:	8b 45 0c             	mov    0xc(%ebp),%eax
  118379:	0f b6 40 01          	movzbl 0x1(%eax),%eax
  11837d:	84 c0                	test   %al,%al
  11837f:	75 12                	jne    118393 <lwip_connect+0x43>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d, AF_UNSPEC)\n", s));
    err = netconn_disconnect(sock->conn);
  118381:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  118384:	8b 00                	mov    (%eax),%eax
  118386:	89 04 24             	mov    %eax,(%esp)
  118389:	e8 72 df ff ff       	call   116300 <netconn_disconnect>
  11838e:	88 45 fd             	mov    %al,0xfffffffd(%ebp)
  118391:	eb 3e                	jmp    1183d1 <lwip_connect+0x81>
  } else {
    struct ip_addr remote_addr;
    u16_t remote_port;

    remote_addr.addr = ((struct sockaddr_in *)name)->sin_addr.s_addr;
  118393:	8b 45 0c             	mov    0xc(%ebp),%eax
  118396:	8b 40 04             	mov    0x4(%eax),%eax
  118399:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
    remote_port = ((struct sockaddr_in *)name)->sin_port;
  11839c:	8b 45 0c             	mov    0xc(%ebp),%eax
  11839f:	0f b7 40 02          	movzwl 0x2(%eax),%eax
  1183a3:	66 89 45 fe          	mov    %ax,0xfffffffe(%ebp)

    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d, addr=", s));
    ip_addr_debug_print(SOCKETS_DEBUG, &remote_addr);
    LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u)\n", ntohs(remote_port)));

    err = netconn_connect(sock->conn, &remote_addr, ntohs(remote_port));
  1183a7:	0f b7 45 fe          	movzwl 0xfffffffe(%ebp),%eax
  1183ab:	89 04 24             	mov    %eax,(%esp)
  1183ae:	e8 fd 5e ff ff       	call   10e2b0 <ntohs>
  1183b3:	0f b7 d0             	movzwl %ax,%edx
  1183b6:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1183b9:	8b 08                	mov    (%eax),%ecx
  1183bb:	89 54 24 08          	mov    %edx,0x8(%esp)
  1183bf:	8d 45 f4             	lea    0xfffffff4(%ebp),%eax
  1183c2:	89 44 24 04          	mov    %eax,0x4(%esp)
  1183c6:	89 0c 24             	mov    %ecx,(%esp)
  1183c9:	e8 52 de ff ff       	call   116220 <netconn_connect>
  1183ce:	88 45 fd             	mov    %al,0xfffffffd(%ebp)
   }

  if (err != ERR_OK) {
  1183d1:	80 7d fd 00          	cmpb   $0x0,0xfffffffd(%ebp)
  1183d5:	74 33                	je     11840a <lwip_connect+0xba>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d) failed, err=%d\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
  1183d7:	0f b6 45 fd          	movzbl 0xfffffffd(%ebp),%eax
  1183db:	3c 0a                	cmp    $0xa,%al
  1183dd:	77 12                	ja     1183f1 <lwip_connect+0xa1>
  1183df:	0f be 45 fd          	movsbl 0xfffffffd(%ebp),%eax
  1183e3:	f7 d8                	neg    %eax
  1183e5:	8b 04 85 40 cc 11 00 	mov    0x11cc40(,%eax,4),%eax
  1183ec:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  1183ef:	eb 07                	jmp    1183f8 <lwip_connect+0xa8>
  1183f1:	c7 45 ec 05 00 00 00 	movl   $0x5,0xffffffec(%ebp)
  1183f8:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1183fb:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
  1183fe:	89 50 10             	mov    %edx,0x10(%eax)
    return -1;
  118401:	c7 45 e8 ff ff ff ff 	movl   $0xffffffff,0xffffffe8(%ebp)
  118408:	eb 11                	jmp    11841b <lwip_connect+0xcb>
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d) succeeded\n", s));
  sock_set_errno(sock, 0);
  11840a:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  11840d:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  return 0;
  118414:	c7 45 e8 00 00 00 00 	movl   $0x0,0xffffffe8(%ebp)
  11841b:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
}
  11841e:	c9                   	leave  
  11841f:	c3                   	ret    

00118420 <lwip_listen>:

int
lwip_listen(int s, int backlog)
{
  118420:	55                   	push   %ebp
  118421:	89 e5                	mov    %esp,%ebp
  118423:	83 ec 28             	sub    $0x28,%esp
  struct lwip_socket *sock;
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_listen(%d, backlog=%d)\n", s, backlog));
  sock = get_socket(s);
  118426:	8b 45 08             	mov    0x8(%ebp),%eax
  118429:	89 04 24             	mov    %eax,(%esp)
  11842c:	e8 bf fa ff ff       	call   117ef0 <get_socket>
  118431:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  if (!sock) {
  118434:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  118438:	75 09                	jne    118443 <lwip_listen+0x23>
    set_errno(EBADF);
    return -1;
  11843a:	c7 45 e8 ff ff ff ff 	movl   $0xffffffff,0xffffffe8(%ebp)
  118441:	eb 5a                	jmp    11849d <lwip_listen+0x7d>
  }

  err = netconn_listen(sock->conn);
  118443:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  118446:	8b 00                	mov    (%eax),%eax
  118448:	89 04 24             	mov    %eax,(%esp)
  11844b:	e8 40 df ff ff       	call   116390 <netconn_listen>
  118450:	88 45 ff             	mov    %al,0xffffffff(%ebp)

  if (err != ERR_OK) {
  118453:	80 7d ff 00          	cmpb   $0x0,0xffffffff(%ebp)
  118457:	74 33                	je     11848c <lwip_listen+0x6c>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_listen(%d) failed, err=%d\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
  118459:	0f b6 45 ff          	movzbl 0xffffffff(%ebp),%eax
  11845d:	3c 0a                	cmp    $0xa,%al
  11845f:	77 12                	ja     118473 <lwip_listen+0x53>
  118461:	0f be 45 ff          	movsbl 0xffffffff(%ebp),%eax
  118465:	f7 d8                	neg    %eax
  118467:	8b 04 85 40 cc 11 00 	mov    0x11cc40(,%eax,4),%eax
  11846e:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  118471:	eb 07                	jmp    11847a <lwip_listen+0x5a>
  118473:	c7 45 ec 05 00 00 00 	movl   $0x5,0xffffffec(%ebp)
  11847a:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  11847d:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
  118480:	89 50 10             	mov    %edx,0x10(%eax)
    return -1;
  118483:	c7 45 e8 ff ff ff ff 	movl   $0xffffffff,0xffffffe8(%ebp)
  11848a:	eb 11                	jmp    11849d <lwip_listen+0x7d>
  }

  sock_set_errno(sock, 0);
  11848c:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  11848f:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  return 0;
  118496:	c7 45 e8 00 00 00 00 	movl   $0x0,0xffffffe8(%ebp)
  11849d:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
}
  1184a0:	c9                   	leave  
  1184a1:	c3                   	ret    
  1184a2:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi
  1184a9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

001184b0 <lwip_recvfrom>:

int
lwip_recvfrom(int s, void *mem, int len, unsigned int flags,
        struct sockaddr *from, socklen_t *fromlen)
{
  1184b0:	55                   	push   %ebp
  1184b1:	89 e5                	mov    %esp,%ebp
  1184b3:	83 ec 48             	sub    $0x48,%esp
  struct lwip_socket *sock;
  struct netbuf *buf;
  u16_t buflen, copylen;
  struct ip_addr *addr;
  u16_t port;


  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d, %p, %d, 0x%x, ..)\n", s, mem, len, flags));
  sock = get_socket(s);
  1184b6:	8b 45 08             	mov    0x8(%ebp),%eax
  1184b9:	89 04 24             	mov    %eax,(%esp)
  1184bc:	e8 2f fa ff ff       	call   117ef0 <get_socket>
  1184c1:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  if (!sock) {
  1184c4:	83 7d ec 00          	cmpl   $0x0,0xffffffec(%ebp)
  1184c8:	75 0c                	jne    1184d6 <lwip_recvfrom+0x26>
    set_errno(EBADF);
    return -1;
  1184ca:	c7 45 cc ff ff ff ff 	movl   $0xffffffff,0xffffffcc(%ebp)
  1184d1:	e9 e3 01 00 00       	jmp    1186b9 <lwip_recvfrom+0x209>
  }

  /* Check if there is data left from the last recv operation. */
  if (sock->lastdata) {
  1184d6:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  1184d9:	8b 40 04             	mov    0x4(%eax),%eax
  1184dc:	85 c0                	test   %eax,%eax
  1184de:	74 0b                	je     1184eb <lwip_recvfrom+0x3b>
    buf = sock->lastdata;
  1184e0:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  1184e3:	8b 40 04             	mov    0x4(%eax),%eax
  1184e6:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
  1184e9:	eb 6b                	jmp    118556 <lwip_recvfrom+0xa6>
  } else {
    /* If this is non-blocking call, then check first */
    if (((flags & MSG_DONTWAIT) || (sock->flags & O_NONBLOCK))
  1184eb:	8b 45 14             	mov    0x14(%ebp),%eax
  1184ee:	83 e0 40             	and    $0x40,%eax
  1184f1:	85 c0                	test   %eax,%eax
  1184f3:	75 13                	jne    118508 <lwip_recvfrom+0x58>
  1184f5:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  1184f8:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
  1184fc:	0f b7 c0             	movzwl %ax,%eax
  1184ff:	25 00 08 00 00       	and    $0x800,%eax
  118504:	85 c0                	test   %eax,%eax
  118506:	74 22                	je     11852a <lwip_recvfrom+0x7a>
  118508:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  11850b:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  11850f:	66 85 c0             	test   %ax,%ax
  118512:	75 16                	jne    11852a <lwip_recvfrom+0x7a>
  && !sock->rcvevent)
    {
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d): returning EWOULDBLOCK\n", s));
      sock_set_errno(sock, EWOULDBLOCK);
  118514:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  118517:	c7 40 10 0b 00 00 00 	movl   $0xb,0x10(%eax)
      return -1;
  11851e:	c7 45 cc ff ff ff ff 	movl   $0xffffffff,0xffffffcc(%ebp)
  118525:	e9 8f 01 00 00       	jmp    1186b9 <lwip_recvfrom+0x209>
    }

    /* No data was left from the previous operation, so we try to get
       some from the network. */
    buf = netconn_recv(sock->conn);
  11852a:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  11852d:	8b 00                	mov    (%eax),%eax
  11852f:	89 04 24             	mov    %eax,(%esp)
  118532:	e8 79 df ff ff       	call   1164b0 <netconn_recv>
  118537:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)

    if (!buf) {
  11853a:	83 7d f0 00          	cmpl   $0x0,0xfffffff0(%ebp)
  11853e:	75 16                	jne    118556 <lwip_recvfrom+0xa6>
      /* We should really do some error checking here. */
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d): buf == NULL!\n", s));
      sock_set_errno(sock, 0);
  118540:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  118543:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
      return 0;
  11854a:	c7 45 cc 00 00 00 00 	movl   $0x0,0xffffffcc(%ebp)
  118551:	e9 63 01 00 00       	jmp    1186b9 <lwip_recvfrom+0x209>
    }
  }

  buflen = netbuf_len(buf);
  118556:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  118559:	89 04 24             	mov    %eax,(%esp)
  11855c:	e8 ff d4 ff ff       	call   115a60 <netbuf_len>
  118561:	66 89 45 f4          	mov    %ax,0xfffffff4(%ebp)

  buflen -= sock->lastoffset;
  118565:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  118568:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  11856c:	66 29 45 f4          	sub    %ax,0xfffffff4(%ebp)

  if (len > buflen) {
  118570:	0f b7 45 f4          	movzwl 0xfffffff4(%ebp),%eax
  118574:	3b 45 10             	cmp    0x10(%ebp),%eax
  118577:	7d 0a                	jge    118583 <lwip_recvfrom+0xd3>
    copylen = buflen;
  118579:	0f b7 45 f4          	movzwl 0xfffffff4(%ebp),%eax
  11857d:	66 89 45 f6          	mov    %ax,0xfffffff6(%ebp)
  118581:	eb 07                	jmp    11858a <lwip_recvfrom+0xda>
  } else {
    copylen = len;
  118583:	8b 45 10             	mov    0x10(%ebp),%eax
  118586:	66 89 45 f6          	mov    %ax,0xfffffff6(%ebp)
  }

  /* copy the contents of the received buffer into
     the supplied memory pointer mem */
  netbuf_copy_partial(buf, mem, copylen, sock->lastoffset);
  11858a:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  11858d:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  118591:	0f b7 c0             	movzwl %ax,%eax
  118594:	0f b7 55 f6          	movzwl 0xfffffff6(%ebp),%edx
  118598:	89 44 24 0c          	mov    %eax,0xc(%esp)
  11859c:	89 54 24 08          	mov    %edx,0x8(%esp)
  1185a0:	8b 45 0c             	mov    0xc(%ebp),%eax
  1185a3:	89 44 24 04          	mov    %eax,0x4(%esp)
  1185a7:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  1185aa:	89 04 24             	mov    %eax,(%esp)
  1185ad:	e8 7e d5 ff ff       	call   115b30 <netbuf_copy_partial>

  /* Check to see from where the data was. */
  if (from && fromlen) {
  1185b2:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
  1185b6:	0f 84 90 00 00 00    	je     11864c <lwip_recvfrom+0x19c>
  1185bc:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  1185c0:	0f 84 86 00 00 00    	je     11864c <lwip_recvfrom+0x19c>
    struct sockaddr_in sin;

    addr = netbuf_fromaddr(buf);
  1185c6:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  1185c9:	89 04 24             	mov    %eax,(%esp)
  1185cc:	e8 6f d6 ff ff       	call   115c40 <netbuf_fromaddr>
  1185d1:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
    port = netbuf_fromport(buf);
  1185d4:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  1185d7:	89 04 24             	mov    %eax,(%esp)
  1185da:	e8 71 d6 ff ff       	call   115c50 <netbuf_fromport>
  1185df:	66 89 45 fe          	mov    %ax,0xfffffffe(%ebp)

    memset(&sin, 0, sizeof(sin));
  1185e3:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
  1185ea:	00 
  1185eb:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  1185f2:	00 
  1185f3:	8d 45 dc             	lea    0xffffffdc(%ebp),%eax
  1185f6:	89 04 24             	mov    %eax,(%esp)
  1185f9:	e8 d2 d8 fe ff       	call   105ed0 <memset>
    sin.sin_len = sizeof(sin);
  1185fe:	c6 45 dc 10          	movb   $0x10,0xffffffdc(%ebp)
    sin.sin_family = AF_INET;
  118602:	c6 45 dd 02          	movb   $0x2,0xffffffdd(%ebp)
    sin.sin_port = htons(port);
  118606:	0f b7 45 fe          	movzwl 0xfffffffe(%ebp),%eax
  11860a:	89 04 24             	mov    %eax,(%esp)
  11860d:	e8 6e 5c ff ff       	call   10e280 <htons>
  118612:	66 89 45 de          	mov    %ax,0xffffffde(%ebp)
    sin.sin_addr.s_addr = addr->addr;
  118616:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  118619:	8b 00                	mov    (%eax),%eax
  11861b:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)

    if (*fromlen > sizeof(sin))
  11861e:	8b 45 1c             	mov    0x1c(%ebp),%eax
  118621:	8b 00                	mov    (%eax),%eax
  118623:	83 f8 10             	cmp    $0x10,%eax
  118626:	76 09                	jbe    118631 <lwip_recvfrom+0x181>
      *fromlen = sizeof(sin);
  118628:	8b 45 1c             	mov    0x1c(%ebp),%eax
  11862b:	c7 00 10 00 00 00    	movl   $0x10,(%eax)

    memcpy(from, &sin, *fromlen);
  118631:	8b 45 1c             	mov    0x1c(%ebp),%eax
  118634:	8b 00                	mov    (%eax),%eax
  118636:	89 44 24 08          	mov    %eax,0x8(%esp)
  11863a:	8d 45 dc             	lea    0xffffffdc(%ebp),%eax
  11863d:	89 44 24 04          	mov    %eax,0x4(%esp)
  118641:	8b 45 18             	mov    0x18(%ebp),%eax
  118644:	89 04 24             	mov    %eax,(%esp)
  118647:	e8 44 d8 fe ff       	call   105e90 <memcpy>

    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d): addr=", s));
    ip_addr_debug_print(SOCKETS_DEBUG, addr);
    LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u len=%u\n", port, copylen));
  } else {
#if SOCKETS_DEBUG > 0
    addr = netbuf_fromaddr(buf);
    port = netbuf_fromport(buf);

    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d): addr=", s));
    ip_addr_debug_print(SOCKETS_DEBUG, addr);
    LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u len=%u\n", port, copylen));
#endif

  }

  /* If this is a TCP socket, check if there is data left in the
     buffer. If so, it should be saved in the sock structure for next
     time around. */
  if (netconn_type(sock->conn) == NETCONN_TCP && buflen - copylen > 0) {
  11864c:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  11864f:	8b 00                	mov    (%eax),%eax
  118651:	89 04 24             	mov    %eax,(%esp)
  118654:	e8 77 d9 ff ff       	call   115fd0 <netconn_type>
  118659:	85 c0                	test   %eax,%eax
  11865b:	75 2d                	jne    11868a <lwip_recvfrom+0x1da>
  11865d:	0f b7 45 f4          	movzwl 0xfffffff4(%ebp),%eax
  118661:	0f b7 55 f6          	movzwl 0xfffffff6(%ebp),%edx
  118665:	29 d0                	sub    %edx,%eax
  118667:	85 c0                	test   %eax,%eax
  118669:	7e 1f                	jle    11868a <lwip_recvfrom+0x1da>
    sock->lastdata = buf;
  11866b:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
  11866e:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  118671:	89 42 04             	mov    %eax,0x4(%edx)
    sock->lastoffset += copylen;
  118674:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  118677:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  11867b:	89 c2                	mov    %eax,%edx
  11867d:	66 03 55 f6          	add    0xfffffff6(%ebp),%dx
  118681:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  118684:	66 89 50 08          	mov    %dx,0x8(%eax)
  118688:	eb 1e                	jmp    1186a8 <lwip_recvfrom+0x1f8>
  } else {
    sock->lastdata = NULL;
  11868a:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  11868d:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    sock->lastoffset = 0;
  118694:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  118697:	66 c7 40 08 00 00    	movw   $0x0,0x8(%eax)
    netbuf_delete(buf);
  11869d:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  1186a0:	89 04 24             	mov    %eax,(%esp)
  1186a3:	e8 e8 d1 ff ff       	call   115890 <netbuf_delete>
  }


  sock_set_errno(sock, 0);
  1186a8:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  1186ab:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  return copylen;
  1186b2:	0f b7 45 f6          	movzwl 0xfffffff6(%ebp),%eax
  1186b6:	89 45 cc             	mov    %eax,0xffffffcc(%ebp)
  1186b9:	8b 45 cc             	mov    0xffffffcc(%ebp),%eax
}
  1186bc:	c9                   	leave  
  1186bd:	c3                   	ret    
  1186be:	89 f6                	mov    %esi,%esi

001186c0 <lwip_read>:

int
lwip_read(int s, void *mem, int len)
{
  1186c0:	55                   	push   %ebp
  1186c1:	89 e5                	mov    %esp,%ebp
  1186c3:	83 ec 18             	sub    $0x18,%esp
  return lwip_recvfrom(s, mem, len, 0, NULL, NULL);
  1186c6:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
  1186cd:	00 
  1186ce:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  1186d5:	00 
  1186d6:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  1186dd:	00 
  1186de:	8b 45 10             	mov    0x10(%ebp),%eax
  1186e1:	89 44 24 08          	mov    %eax,0x8(%esp)
  1186e5:	8b 45 0c             	mov    0xc(%ebp),%eax
  1186e8:	89 44 24 04          	mov    %eax,0x4(%esp)
  1186ec:	8b 45 08             	mov    0x8(%ebp),%eax
  1186ef:	89 04 24             	mov    %eax,(%esp)
  1186f2:	e8 b9 fd ff ff       	call   1184b0 <lwip_recvfrom>
}
  1186f7:	c9                   	leave  
  1186f8:	c3                   	ret    
  1186f9:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

00118700 <lwip_recv>:

int
lwip_recv(int s, void *mem, int len, unsigned int flags)
{
  118700:	55                   	push   %ebp
  118701:	89 e5                	mov    %esp,%ebp
  118703:	83 ec 18             	sub    $0x18,%esp
  return lwip_recvfrom(s, mem, len, flags, NULL, NULL);
  118706:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
  11870d:	00 
  11870e:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  118715:	00 
  118716:	8b 45 14             	mov    0x14(%ebp),%eax
  118719:	89 44 24 0c          	mov    %eax,0xc(%esp)
  11871d:	8b 45 10             	mov    0x10(%ebp),%eax
  118720:	89 44 24 08          	mov    %eax,0x8(%esp)
  118724:	8b 45 0c             	mov    0xc(%ebp),%eax
  118727:	89 44 24 04          	mov    %eax,0x4(%esp)
  11872b:	8b 45 08             	mov    0x8(%ebp),%eax
  11872e:	89 04 24             	mov    %eax,(%esp)
  118731:	e8 7a fd ff ff       	call   1184b0 <lwip_recvfrom>
}
  118736:	c9                   	leave  
  118737:	c3                   	ret    
  118738:	90                   	nop    
  118739:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

00118740 <lwip_send>:

int
lwip_send(int s, void *data, int size, unsigned int flags)
{
  118740:	55                   	push   %ebp
  118741:	89 e5                	mov    %esp,%ebp
  118743:	83 ec 38             	sub    $0x38,%esp
  struct lwip_socket *sock;
  struct netbuf *buf;
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d, data=%p, size=%d, flags=0x%x)\n", s, data, size, flags));

  sock = get_socket(s);
  118746:	8b 45 08             	mov    0x8(%ebp),%eax
  118749:	89 04 24             	mov    %eax,(%esp)
  11874c:	e8 9f f7 ff ff       	call   117ef0 <get_socket>
  118751:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  if (!sock) {
  118754:	83 7d f4 00          	cmpl   $0x0,0xfffffff4(%ebp)
  118758:	75 0c                	jne    118766 <lwip_send+0x26>
    set_errno(EBADF);
    return -1;
  11875a:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,0xffffffe4(%ebp)
  118761:	e9 fc 00 00 00       	jmp    118862 <lwip_send+0x122>
  }

  switch (netconn_type(sock->conn)) {
  118766:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  118769:	8b 00                	mov    (%eax),%eax
  11876b:	89 04 24             	mov    %eax,(%esp)
  11876e:	e8 5d d8 ff ff       	call   115fd0 <netconn_type>
  118773:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
  118776:	83 7d e8 00          	cmpl   $0x0,0xffffffe8(%ebp)
  11877a:	74 6e                	je     1187ea <lwip_send+0xaa>
  11877c:	83 7d e8 04          	cmpl   $0x4,0xffffffe8(%ebp)
  118780:	0f 87 8f 00 00 00    	ja     118815 <lwip_send+0xd5>
  case NETCONN_RAW:
  case NETCONN_UDP:
  case NETCONN_UDPLITE:
  case NETCONN_UDPNOCHKSUM:
    /* create a buffer */
    buf = netbuf_new();
  118786:	e8 b5 d0 ff ff       	call   115840 <netbuf_new>
  11878b:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)

    if (!buf) {
  11878e:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  118792:	75 16                	jne    1187aa <lwip_send+0x6a>
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d) ENOBUFS\n", s));
      sock_set_errno(sock, ENOBUFS);
  118794:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  118797:	c7 40 10 69 00 00 00 	movl   $0x69,0x10(%eax)
      return -1;
  11879e:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,0xffffffe4(%ebp)
  1187a5:	e9 b8 00 00 00       	jmp    118862 <lwip_send+0x122>
    }

    /* make the buffer point to the data that should
       be sent */
    netbuf_ref(buf, data, size);
  1187aa:	8b 45 10             	mov    0x10(%ebp),%eax
  1187ad:	0f b7 c0             	movzwl %ax,%eax
  1187b0:	89 44 24 08          	mov    %eax,0x8(%esp)
  1187b4:	8b 45 0c             	mov    0xc(%ebp),%eax
  1187b7:	89 44 24 04          	mov    %eax,0x4(%esp)
  1187bb:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1187be:	89 04 24             	mov    %eax,(%esp)
  1187c1:	e8 da d1 ff ff       	call   1159a0 <netbuf_ref>

    /* send the data */
    err = netconn_send(sock->conn, buf);
  1187c6:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  1187c9:	8b 10                	mov    (%eax),%edx
  1187cb:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1187ce:	89 44 24 04          	mov    %eax,0x4(%esp)
  1187d2:	89 14 24             	mov    %edx,(%esp)
  1187d5:	e8 46 df ff ff       	call   116720 <netconn_send>
  1187da:	88 45 ff             	mov    %al,0xffffffff(%ebp)

    /* deallocated the buffer */
    netbuf_delete(buf);
  1187dd:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1187e0:	89 04 24             	mov    %eax,(%esp)
  1187e3:	e8 a8 d0 ff ff       	call   115890 <netbuf_delete>
    break;
  1187e8:	eb 2f                	jmp    118819 <lwip_send+0xd9>
  case NETCONN_TCP:
    err = netconn_write(sock->conn, data, size, NETCONN_COPY);
  1187ea:	8b 45 10             	mov    0x10(%ebp),%eax
  1187ed:	0f b7 d0             	movzwl %ax,%edx
  1187f0:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  1187f3:	8b 08                	mov    (%eax),%ecx
  1187f5:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
  1187fc:	00 
  1187fd:	89 54 24 08          	mov    %edx,0x8(%esp)
  118801:	8b 45 0c             	mov    0xc(%ebp),%eax
  118804:	89 44 24 04          	mov    %eax,0x4(%esp)
  118808:	89 0c 24             	mov    %ecx,(%esp)
  11880b:	e8 d0 df ff ff       	call   1167e0 <netconn_write>
  118810:	88 45 ff             	mov    %al,0xffffffff(%ebp)
    break;
  118813:	eb 04                	jmp    118819 <lwip_send+0xd9>
  default:
    err = ERR_ARG;
  118815:	c6 45 ff f8          	movb   $0xf8,0xffffffff(%ebp)
    break;
  }
  if (err != ERR_OK) {
  118819:	80 7d ff 00          	cmpb   $0x0,0xffffffff(%ebp)
  11881d:	74 33                	je     118852 <lwip_send+0x112>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d) err=%d\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
  11881f:	0f b6 45 ff          	movzbl 0xffffffff(%ebp),%eax
  118823:	3c 0a                	cmp    $0xa,%al
  118825:	77 12                	ja     118839 <lwip_send+0xf9>
  118827:	0f be 45 ff          	movsbl 0xffffffff(%ebp),%eax
  11882b:	f7 d8                	neg    %eax
  11882d:	8b 04 85 40 cc 11 00 	mov    0x11cc40(,%eax,4),%eax
  118834:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  118837:	eb 07                	jmp    118840 <lwip_send+0x100>
  118839:	c7 45 ec 05 00 00 00 	movl   $0x5,0xffffffec(%ebp)
  118840:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  118843:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
  118846:	89 50 10             	mov    %edx,0x10(%eax)
    return -1;
  118849:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,0xffffffe4(%ebp)
  118850:	eb 10                	jmp    118862 <lwip_send+0x122>
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d) ok size=%d\n", s, size));
  sock_set_errno(sock, 0);
  118852:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  118855:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  return size;
  11885c:	8b 45 10             	mov    0x10(%ebp),%eax
  11885f:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
  118862:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
}
  118865:	c9                   	leave  
  118866:	c3                   	ret    
  118867:	89 f6                	mov    %esi,%esi
  118869:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00118870 <lwip_sendto>:

int
lwip_sendto(int s, void *data, int size, unsigned int flags,
       struct sockaddr *to, socklen_t tolen)
{
  118870:	55                   	push   %ebp
  118871:	89 e5                	mov    %esp,%ebp
  118873:	83 ec 38             	sub    $0x38,%esp
  struct lwip_socket *sock;
  struct ip_addr remote_addr, addr;
  u16_t remote_port, port;
  int ret,connected;

  sock = get_socket(s);
  118876:	8b 45 08             	mov    0x8(%ebp),%eax
  118879:	89 04 24             	mov    %eax,(%esp)
  11887c:	e8 6f f6 ff ff       	call   117ef0 <get_socket>
  118881:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
  if (!sock) {
  118884:	83 7d f0 00          	cmpl   $0x0,0xfffffff0(%ebp)
  118888:	75 0c                	jne    118896 <lwip_sendto+0x26>
    set_errno(EBADF);
    return -1;
  11888a:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,0xffffffdc(%ebp)
  118891:	e9 be 00 00 00       	jmp    118954 <lwip_sendto+0xe4>
  }

  /* get the peer if currently connected */
  connected = (netconn_peer(sock->conn, &addr, &port) == ERR_OK);
  118896:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  118899:	8b 10                	mov    (%eax),%edx
  11889b:	8d 45 e6             	lea    0xffffffe6(%ebp),%eax
  11889e:	89 44 24 08          	mov    %eax,0x8(%esp)
  1188a2:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
  1188a5:	89 44 24 04          	mov    %eax,0x4(%esp)
  1188a9:	89 14 24             	mov    %edx,(%esp)
  1188ac:	e8 2f d7 ff ff       	call   115fe0 <netconn_peer>
  1188b1:	84 c0                	test   %al,%al
  1188b3:	0f 94 c0             	sete   %al
  1188b6:	0f b6 c0             	movzbl %al,%eax
  1188b9:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)

  remote_addr.addr = ((struct sockaddr_in *)to)->sin_addr.s_addr;
  1188bc:	8b 45 18             	mov    0x18(%ebp),%eax
  1188bf:	8b 40 04             	mov    0x4(%eax),%eax
  1188c2:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  remote_port = ((struct sockaddr_in *)to)->sin_port;
  1188c5:	8b 45 18             	mov    0x18(%ebp),%eax
  1188c8:	0f b7 40 02          	movzwl 0x2(%eax),%eax
  1188cc:	66 89 45 f6          	mov    %ax,0xfffffff6(%ebp)

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_sendto(%d, data=%p, size=%d, flags=0x%x to=", s, data, size, flags));
  ip_addr_debug_print(SOCKETS_DEBUG, &remote_addr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u\n", ntohs(remote_port)));

  netconn_connect(sock->conn, &remote_addr, ntohs(remote_port));
  1188d0:	0f b7 45 f6          	movzwl 0xfffffff6(%ebp),%eax
  1188d4:	89 04 24             	mov    %eax,(%esp)
  1188d7:	e8 d4 59 ff ff       	call   10e2b0 <ntohs>
  1188dc:	0f b7 d0             	movzwl %ax,%edx
  1188df:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  1188e2:	8b 08                	mov    (%eax),%ecx
  1188e4:	89 54 24 08          	mov    %edx,0x8(%esp)
  1188e8:	8d 45 ec             	lea    0xffffffec(%ebp),%eax
  1188eb:	89 44 24 04          	mov    %eax,0x4(%esp)
  1188ef:	89 0c 24             	mov    %ecx,(%esp)
  1188f2:	e8 29 d9 ff ff       	call   116220 <netconn_connect>

  ret = lwip_send(s, data, size, flags);
  1188f7:	8b 45 14             	mov    0x14(%ebp),%eax
  1188fa:	89 44 24 0c          	mov    %eax,0xc(%esp)
  1188fe:	8b 45 10             	mov    0x10(%ebp),%eax
  118901:	89 44 24 08          	mov    %eax,0x8(%esp)
  118905:	8b 45 0c             	mov    0xc(%ebp),%eax
  118908:	89 44 24 04          	mov    %eax,0x4(%esp)
  11890c:	8b 45 08             	mov    0x8(%ebp),%eax
  11890f:	89 04 24             	mov    %eax,(%esp)
  118912:	e8 29 fe ff ff       	call   118740 <lwip_send>
  118917:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)

  /* reset the remote address and port number
     of the connection */
  if (connected)
  11891a:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  11891e:	74 21                	je     118941 <lwip_sendto+0xd1>
    netconn_connect(sock->conn, &addr, port);
  118920:	0f b7 45 e6          	movzwl 0xffffffe6(%ebp),%eax
  118924:	0f b7 d0             	movzwl %ax,%edx
  118927:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  11892a:	8b 08                	mov    (%eax),%ecx
  11892c:	89 54 24 08          	mov    %edx,0x8(%esp)
  118930:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
  118933:	89 44 24 04          	mov    %eax,0x4(%esp)
  118937:	89 0c 24             	mov    %ecx,(%esp)
  11893a:	e8 e1 d8 ff ff       	call   116220 <netconn_connect>
  11893f:	eb 0d                	jmp    11894e <lwip_sendto+0xde>
  else
  netconn_disconnect(sock->conn);
  118941:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  118944:	8b 00                	mov    (%eax),%eax
  118946:	89 04 24             	mov    %eax,(%esp)
  118949:	e8 b2 d9 ff ff       	call   116300 <netconn_disconnect>
  return ret;
  11894e:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  118951:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
  118954:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
}
  118957:	c9                   	leave  
  118958:	c3                   	ret    
  118959:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

00118960 <lwip_socket>:

int
lwip_socket(int domain, int type, int protocol)
{
  118960:	55                   	push   %ebp
  118961:	89 e5                	mov    %esp,%ebp
  118963:	83 ec 28             	sub    $0x28,%esp
  struct netconn *conn;
  int i;

  /* create a netconn */
  switch (type) {
  118966:	8b 45 0c             	mov    0xc(%ebp),%eax
  118969:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
  11896c:	83 7d e8 02          	cmpl   $0x2,0xffffffe8(%ebp)
  118970:	74 31                	je     1189a3 <lwip_socket+0x43>
  118972:	83 7d e8 03          	cmpl   $0x3,0xffffffe8(%ebp)
  118976:	74 08                	je     118980 <lwip_socket+0x20>
  118978:	83 7d e8 01          	cmpl   $0x1,0xffffffe8(%ebp)
  11897c:	74 3e                	je     1189bc <lwip_socket+0x5c>
  11897e:	eb 55                	jmp    1189d5 <lwip_socket+0x75>
  case SOCK_RAW:
    conn = netconn_new_with_proto_and_callback(NETCONN_RAW, protocol, event_callback);
  118980:	8b 45 10             	mov    0x10(%ebp),%eax
  118983:	0f b7 c0             	movzwl %ax,%eax
  118986:	c7 44 24 08 20 90 11 	movl   $0x119020,0x8(%esp)
  11898d:	00 
  11898e:	89 44 24 04          	mov    %eax,0x4(%esp)
  118992:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  118999:	e8 c2 d2 ff ff       	call   115c60 <netconn_new_with_proto_and_callback>
  11899e:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_RAW, %d) = ", domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    break;
  1189a1:	eb 3b                	jmp    1189de <lwip_socket+0x7e>
  case SOCK_DGRAM:
    conn = netconn_new_with_callback(NETCONN_UDP, event_callback);
  1189a3:	c7 44 24 04 20 90 11 	movl   $0x119020,0x4(%esp)
  1189aa:	00 
  1189ab:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  1189b2:	e8 59 d4 ff ff       	call   115e10 <netconn_new_with_callback>
  1189b7:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_DGRAM, %d) = ", domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    break;
  1189ba:	eb 22                	jmp    1189de <lwip_socket+0x7e>
  case SOCK_STREAM:
    conn = netconn_new_with_callback(NETCONN_TCP, event_callback);
  1189bc:	c7 44 24 04 20 90 11 	movl   $0x119020,0x4(%esp)
  1189c3:	00 
  1189c4:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  1189cb:	e8 40 d4 ff ff       	call   115e10 <netconn_new_with_callback>
  1189d0:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_STREAM, %d) = ", domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    break;
  1189d3:	eb 09                	jmp    1189de <lwip_socket+0x7e>
  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%d, %d/UNKNOWN, %d) = -1\n", domain, type, protocol));
    set_errno(EINVAL);
    return -1;
  1189d5:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  1189dc:	eb 46                	jmp    118a24 <lwip_socket+0xc4>
  }

  if (!conn) {
  1189de:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  1189e2:	75 09                	jne    1189ed <lwip_socket+0x8d>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("-1 / ENOBUFS (could not create netconn)\n"));
    set_errno(ENOBUFS);
    return -1;
  1189e4:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  1189eb:	eb 37                	jmp    118a24 <lwip_socket+0xc4>
  }

  i = alloc_socket(conn);
  1189ed:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1189f0:	89 04 24             	mov    %eax,(%esp)
  1189f3:	e8 48 f5 ff ff       	call   117f40 <alloc_socket>
  1189f8:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)

  if (i == -1) {
  1189fb:	83 7d fc ff          	cmpl   $0xffffffff,0xfffffffc(%ebp)
  1189ff:	75 14                	jne    118a15 <lwip_socket+0xb5>
    netconn_delete(conn);
  118a01:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  118a04:	89 04 24             	mov    %eax,(%esp)
  118a07:	e8 34 d4 ff ff       	call   115e40 <netconn_delete>
  set_errno(ENOBUFS);
  return -1;
  118a0c:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  118a13:	eb 0f                	jmp    118a24 <lwip_socket+0xc4>
  }
  conn->socket = i;
  118a15:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  118a18:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  118a1b:	89 42 20             	mov    %eax,0x20(%edx)
  LWIP_DEBUGF(SOCKETS_DEBUG, ("%d\n", i));
  set_errno(0);
  return i;
  118a1e:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  118a21:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  118a24:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  118a27:	c9                   	leave  
  118a28:	c3                   	ret    
  118a29:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

00118a30 <lwip_write>:

int
lwip_write(int s, void *data, int size)
{
  118a30:	55                   	push   %ebp
  118a31:	89 e5                	mov    %esp,%ebp
  118a33:	83 ec 18             	sub    $0x18,%esp
   return lwip_send(s, data, size, 0);
  118a36:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  118a3d:	00 
  118a3e:	8b 45 10             	mov    0x10(%ebp),%eax
  118a41:	89 44 24 08          	mov    %eax,0x8(%esp)
  118a45:	8b 45 0c             	mov    0xc(%ebp),%eax
  118a48:	89 44 24 04          	mov    %eax,0x4(%esp)
  118a4c:	8b 45 08             	mov    0x8(%ebp),%eax
  118a4f:	89 04 24             	mov    %eax,(%esp)
  118a52:	e8 e9 fc ff ff       	call   118740 <lwip_send>
}
  118a57:	c9                   	leave  
  118a58:	c3                   	ret    
  118a59:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

00118a60 <lwip_selscan>:


static int
lwip_selscan(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset)
{
  118a60:	55                   	push   %ebp
  118a61:	89 e5                	mov    %esp,%ebp
  118a63:	53                   	push   %ebx
  118a64:	83 ec 34             	sub    $0x34,%esp
    int i, nready = 0;
  118a67:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
    fd_set lreadset, lwriteset, lexceptset;
    struct lwip_socket *p_sock;

    FD_ZERO(&lreadset);
  118a6e:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
  118a75:	00 
  118a76:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  118a7d:	00 
  118a7e:	8d 45 ee             	lea    0xffffffee(%ebp),%eax
  118a81:	89 04 24             	mov    %eax,(%esp)
  118a84:	e8 47 d4 fe ff       	call   105ed0 <memset>
    FD_ZERO(&lwriteset);
  118a89:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
  118a90:	00 
  118a91:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  118a98:	00 
  118a99:	8d 45 ec             	lea    0xffffffec(%ebp),%eax
  118a9c:	89 04 24             	mov    %eax,(%esp)
  118a9f:	e8 2c d4 fe ff       	call   105ed0 <memset>
    FD_ZERO(&lexceptset);
  118aa4:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
  118aab:	00 
  118aac:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  118ab3:	00 
  118ab4:	8d 45 ea             	lea    0xffffffea(%ebp),%eax
  118ab7:	89 04 24             	mov    %eax,(%esp)
  118aba:	e8 11 d4 fe ff       	call   105ed0 <memset>

    /* Go through each socket in each list to count number of sockets which
       currently match */
    for(i = 0; i < maxfdp1; i++)
  118abf:	c7 45 f0 00 00 00 00 	movl   $0x0,0xfffffff0(%ebp)
  118ac6:	e9 04 01 00 00       	jmp    118bcf <lwip_selscan+0x16f>
    {
        if (FD_ISSET(i, readset))
  118acb:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
  118ace:	89 d0                	mov    %edx,%eax
  118ad0:	c1 f8 1f             	sar    $0x1f,%eax
  118ad3:	c1 e8 1d             	shr    $0x1d,%eax
  118ad6:	01 d0                	add    %edx,%eax
  118ad8:	c1 f8 03             	sar    $0x3,%eax
  118adb:	89 c2                	mov    %eax,%edx
  118add:	8b 45 0c             	mov    0xc(%ebp),%eax
  118ae0:	0f b6 04 10          	movzbl (%eax,%edx,1),%eax
  118ae4:	0f b6 c0             	movzbl %al,%eax
  118ae7:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
  118aea:	83 e1 07             	and    $0x7,%ecx
  118aed:	d3 f8                	sar    %cl,%eax
  118aef:	83 e0 01             	and    $0x1,%eax
  118af2:	84 c0                	test   %al,%al
  118af4:	74 5a                	je     118b50 <lwip_selscan+0xf0>
        {
            /* See if netconn of this socket is ready for read */
            p_sock = get_socket(i);
  118af6:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  118af9:	89 04 24             	mov    %eax,(%esp)
  118afc:	e8 ef f3 ff ff       	call   117ef0 <get_socket>
  118b01:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
            if (p_sock && (p_sock->lastdata || p_sock->rcvevent))
  118b04:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  118b08:	74 46                	je     118b50 <lwip_selscan+0xf0>
  118b0a:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  118b0d:	8b 40 04             	mov    0x4(%eax),%eax
  118b10:	85 c0                	test   %eax,%eax
  118b12:	75 0c                	jne    118b20 <lwip_selscan+0xc0>
  118b14:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  118b17:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  118b1b:	66 85 c0             	test   %ax,%ax
  118b1e:	74 30                	je     118b50 <lwip_selscan+0xf0>
            {
                FD_SET(i, &lreadset);
  118b20:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
  118b23:	89 d0                	mov    %edx,%eax
  118b25:	c1 f8 1f             	sar    $0x1f,%eax
  118b28:	c1 e8 1d             	shr    $0x1d,%eax
  118b2b:	01 d0                	add    %edx,%eax
  118b2d:	c1 f8 03             	sar    $0x3,%eax
  118b30:	89 c3                	mov    %eax,%ebx
  118b32:	0f b6 44 05 ee       	movzbl 0xffffffee(%ebp,%eax,1),%eax
  118b37:	89 c2                	mov    %eax,%edx
  118b39:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
  118b3c:	83 e1 07             	and    $0x7,%ecx
  118b3f:	b8 01 00 00 00       	mov    $0x1,%eax
  118b44:	d3 e0                	shl    %cl,%eax
  118b46:	09 d0                	or     %edx,%eax
  118b48:	88 44 1d ee          	mov    %al,0xffffffee(%ebp,%ebx,1)
		LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for reading\n", i));
                nready++;
  118b4c:	83 45 f4 01          	addl   $0x1,0xfffffff4(%ebp)
            }
        }
        if (FD_ISSET(i, writeset))
  118b50:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
  118b53:	89 d0                	mov    %edx,%eax
  118b55:	c1 f8 1f             	sar    $0x1f,%eax
  118b58:	c1 e8 1d             	shr    $0x1d,%eax
  118b5b:	01 d0                	add    %edx,%eax
  118b5d:	c1 f8 03             	sar    $0x3,%eax
  118b60:	89 c2                	mov    %eax,%edx
  118b62:	8b 45 10             	mov    0x10(%ebp),%eax
  118b65:	0f b6 04 10          	movzbl (%eax,%edx,1),%eax
  118b69:	0f b6 c0             	movzbl %al,%eax
  118b6c:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
  118b6f:	83 e1 07             	and    $0x7,%ecx
  118b72:	d3 f8                	sar    %cl,%eax
  118b74:	83 e0 01             	and    $0x1,%eax
  118b77:	84 c0                	test   %al,%al
  118b79:	74 50                	je     118bcb <lwip_selscan+0x16b>
        {
            /* See if netconn of this socket is ready for write */
            p_sock = get_socket(i);
  118b7b:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  118b7e:	89 04 24             	mov    %eax,(%esp)
  118b81:	e8 6a f3 ff ff       	call   117ef0 <get_socket>
  118b86:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
            if (p_sock && p_sock->sendevent)
  118b89:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  118b8d:	74 3c                	je     118bcb <lwip_selscan+0x16b>
  118b8f:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  118b92:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  118b96:	66 85 c0             	test   %ax,%ax
  118b99:	74 30                	je     118bcb <lwip_selscan+0x16b>
            {
                FD_SET(i, &lwriteset);
  118b9b:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
  118b9e:	89 d0                	mov    %edx,%eax
  118ba0:	c1 f8 1f             	sar    $0x1f,%eax
  118ba3:	c1 e8 1d             	shr    $0x1d,%eax
  118ba6:	01 d0                	add    %edx,%eax
  118ba8:	c1 f8 03             	sar    $0x3,%eax
  118bab:	89 c3                	mov    %eax,%ebx
  118bad:	0f b6 44 05 ec       	movzbl 0xffffffec(%ebp,%eax,1),%eax
  118bb2:	89 c2                	mov    %eax,%edx
  118bb4:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
  118bb7:	83 e1 07             	and    $0x7,%ecx
  118bba:	b8 01 00 00 00       	mov    $0x1,%eax
  118bbf:	d3 e0                	shl    %cl,%eax
  118bc1:	09 d0                	or     %edx,%eax
  118bc3:	88 44 1d ec          	mov    %al,0xffffffec(%ebp,%ebx,1)
		LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for writing\n", i));
                nready++;
  118bc7:	83 45 f4 01          	addl   $0x1,0xfffffff4(%ebp)
  118bcb:	83 45 f0 01          	addl   $0x1,0xfffffff0(%ebp)
  118bcf:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  118bd2:	3b 45 08             	cmp    0x8(%ebp),%eax
  118bd5:	0f 8c f0 fe ff ff    	jl     118acb <lwip_selscan+0x6b>
            }
        }
    }
    *readset = lreadset;
  118bdb:	8b 55 0c             	mov    0xc(%ebp),%edx
  118bde:	0f b7 45 ee          	movzwl 0xffffffee(%ebp),%eax
  118be2:	66 89 02             	mov    %ax,(%edx)
    *writeset = lwriteset;
  118be5:	8b 55 10             	mov    0x10(%ebp),%edx
  118be8:	0f b7 45 ec          	movzwl 0xffffffec(%ebp),%eax
  118bec:	66 89 02             	mov    %ax,(%edx)
    FD_ZERO(exceptset);
  118bef:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
  118bf6:	00 
  118bf7:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  118bfe:	00 
  118bff:	8b 45 14             	mov    0x14(%ebp),%eax
  118c02:	89 04 24             	mov    %eax,(%esp)
  118c05:	e8 c6 d2 fe ff       	call   105ed0 <memset>

    return nready;
  118c0a:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
}
  118c0d:	83 c4 34             	add    $0x34,%esp
  118c10:	5b                   	pop    %ebx
  118c11:	5d                   	pop    %ebp
  118c12:	c3                   	ret    
  118c13:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  118c19:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00118c20 <lwip_select>:



int
lwip_select(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset,
               struct timeval *timeout)
{
  118c20:	55                   	push   %ebp
  118c21:	89 e5                	mov    %esp,%ebp
  118c23:	53                   	push   %ebx
  118c24:	83 ec 54             	sub    $0x54,%esp
    int i;
    int nready;
    fd_set lreadset, lwriteset, lexceptset;
    u32_t msectimeout;
    struct lwip_select_cb select_cb;
    struct lwip_select_cb *p_selcb;

    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select(%d, %p, %p, %p, tvsec=%ld tvusec=%ld)\n", maxfdp1, (void *)readset, (void *) writeset, (void *) exceptset, timeout ? timeout->tv_sec : -1L, timeout ? timeout->tv_usec : -1L));

    select_cb.next = 0;
  118c27:	c7 45 cc 00 00 00 00 	movl   $0x0,0xffffffcc(%ebp)
    select_cb.readset = readset;
  118c2e:	8b 45 0c             	mov    0xc(%ebp),%eax
  118c31:	89 45 d0             	mov    %eax,0xffffffd0(%ebp)
    select_cb.writeset = writeset;
  118c34:	8b 45 10             	mov    0x10(%ebp),%eax
  118c37:	89 45 d4             	mov    %eax,0xffffffd4(%ebp)
    select_cb.exceptset = exceptset;
  118c3a:	8b 45 14             	mov    0x14(%ebp),%eax
  118c3d:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
    select_cb.sem_signalled = 0;
  118c40:	c7 45 dc 00 00 00 00 	movl   $0x0,0xffffffdc(%ebp)

    /* Protect ourselves searching through the list */
    if (!selectsem)
  118c47:	a1 48 99 13 00       	mov    0x139948,%eax
  118c4c:	85 c0                	test   %eax,%eax
  118c4e:	75 11                	jne    118c61 <lwip_select+0x41>
        selectsem = sys_sem_new(1);
  118c50:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  118c57:	e8 f4 10 00 00       	call   119d50 <sys_sem_new>
  118c5c:	a3 48 99 13 00       	mov    %eax,0x139948
    sys_sem_wait(selectsem);
  118c61:	a1 48 99 13 00       	mov    0x139948,%eax
  118c66:	89 04 24             	mov    %eax,(%esp)
  118c69:	e8 a2 71 ff ff       	call   10fe10 <sys_sem_wait>

    if (readset)
  118c6e:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  118c72:	74 0c                	je     118c80 <lwip_select+0x60>
        lreadset = *readset;
  118c74:	8b 45 0c             	mov    0xc(%ebp),%eax
  118c77:	0f b7 00             	movzwl (%eax),%eax
  118c7a:	66 89 45 ea          	mov    %ax,0xffffffea(%ebp)
  118c7e:	eb 1b                	jmp    118c9b <lwip_select+0x7b>
    else
        FD_ZERO(&lreadset);
  118c80:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
  118c87:	00 
  118c88:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  118c8f:	00 
  118c90:	8d 45 ea             	lea    0xffffffea(%ebp),%eax
  118c93:	89 04 24             	mov    %eax,(%esp)
  118c96:	e8 35 d2 fe ff       	call   105ed0 <memset>
    if (writeset)
  118c9b:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  118c9f:	74 0c                	je     118cad <lwip_select+0x8d>
        lwriteset = *writeset;
  118ca1:	8b 45 10             	mov    0x10(%ebp),%eax
  118ca4:	0f b7 00             	movzwl (%eax),%eax
  118ca7:	66 89 45 e8          	mov    %ax,0xffffffe8(%ebp)
  118cab:	eb 1b                	jmp    118cc8 <lwip_select+0xa8>
    else
        FD_ZERO(&lwriteset);
  118cad:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
  118cb4:	00 
  118cb5:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  118cbc:	00 
  118cbd:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
  118cc0:	89 04 24             	mov    %eax,(%esp)
  118cc3:	e8 08 d2 fe ff       	call   105ed0 <memset>
    if (exceptset)
  118cc8:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
  118ccc:	74 0c                	je     118cda <lwip_select+0xba>
        lexceptset = *exceptset;
  118cce:	8b 45 14             	mov    0x14(%ebp),%eax
  118cd1:	0f b7 00             	movzwl (%eax),%eax
  118cd4:	66 89 45 e6          	mov    %ax,0xffffffe6(%ebp)
  118cd8:	eb 1b                	jmp    118cf5 <lwip_select+0xd5>
    else
        FD_ZERO(&lexceptset);
  118cda:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
  118ce1:	00 
  118ce2:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  118ce9:	00 
  118cea:	8d 45 e6             	lea    0xffffffe6(%ebp),%eax
  118ced:	89 04 24             	mov    %eax,(%esp)
  118cf0:	e8 db d1 fe ff       	call   105ed0 <memset>

    /* Go through each socket in each list to count number of sockets which
       currently match */
    nready = lwip_selscan(maxfdp1, &lreadset, &lwriteset, &lexceptset);
  118cf5:	8d 45 e6             	lea    0xffffffe6(%ebp),%eax
  118cf8:	89 44 24 0c          	mov    %eax,0xc(%esp)
  118cfc:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
  118cff:	89 44 24 08          	mov    %eax,0x8(%esp)
  118d03:	8d 45 ea             	lea    0xffffffea(%ebp),%eax
  118d06:	89 44 24 04          	mov    %eax,0x4(%esp)
  118d0a:	8b 45 08             	mov    0x8(%ebp),%eax
  118d0d:	89 04 24             	mov    %eax,(%esp)
  118d10:	e8 4b fd ff ff       	call   118a60 <lwip_selscan>
  118d15:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)

    /* If we don't have any current events, then suspend if we are supposed to */
    if (!nready)
  118d18:	83 7d f0 00          	cmpl   $0x0,0xfffffff0(%ebp)
  118d1c:	0f 85 af 02 00 00    	jne    118fd1 <lwip_select+0x3b1>
    {
        if (timeout && timeout->tv_sec == 0 && timeout->tv_usec == 0)
  118d22:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
  118d26:	0f 84 93 00 00 00    	je     118dbf <lwip_select+0x19f>
  118d2c:	8b 45 18             	mov    0x18(%ebp),%eax
  118d2f:	8b 00                	mov    (%eax),%eax
  118d31:	85 c0                	test   %eax,%eax
  118d33:	0f 85 86 00 00 00    	jne    118dbf <lwip_select+0x19f>
  118d39:	8b 45 18             	mov    0x18(%ebp),%eax
  118d3c:	8b 40 04             	mov    0x4(%eax),%eax
  118d3f:	85 c0                	test   %eax,%eax
  118d41:	75 7c                	jne    118dbf <lwip_select+0x19f>
        {
            sys_sem_signal(selectsem);
  118d43:	a1 48 99 13 00       	mov    0x139948,%eax
  118d48:	89 04 24             	mov    %eax,(%esp)
  118d4b:	e8 80 10 00 00       	call   119dd0 <sys_sem_signal>
            if (readset)
  118d50:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  118d54:	74 1b                	je     118d71 <lwip_select+0x151>
                FD_ZERO(readset);
  118d56:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
  118d5d:	00 
  118d5e:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  118d65:	00 
  118d66:	8b 45 0c             	mov    0xc(%ebp),%eax
  118d69:	89 04 24             	mov    %eax,(%esp)
  118d6c:	e8 5f d1 fe ff       	call   105ed0 <memset>
            if (writeset)
  118d71:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  118d75:	74 1b                	je     118d92 <lwip_select+0x172>
                FD_ZERO(writeset);
  118d77:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
  118d7e:	00 
  118d7f:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  118d86:	00 
  118d87:	8b 45 10             	mov    0x10(%ebp),%eax
  118d8a:	89 04 24             	mov    %eax,(%esp)
  118d8d:	e8 3e d1 fe ff       	call   105ed0 <memset>
            if (exceptset)
  118d92:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
  118d96:	74 1b                	je     118db3 <lwip_select+0x193>
                FD_ZERO(exceptset);
  118d98:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
  118d9f:	00 
  118da0:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  118da7:	00 
  118da8:	8b 45 14             	mov    0x14(%ebp),%eax
  118dab:	89 04 24             	mov    %eax,(%esp)
  118dae:	e8 1d d1 fe ff       	call   105ed0 <memset>

	    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: no timeout, returning 0\n"));
	    set_errno(0);

            return 0;
  118db3:	c7 45 c8 00 00 00 00 	movl   $0x0,0xffffffc8(%ebp)
  118dba:	e9 55 02 00 00       	jmp    119014 <lwip_select+0x3f4>
        }

        /* add our semaphore to list */
        /* We don't actually need any dynamic memory. Our entry on the
         * list is only valid while we are in this function, so it's ok
         * to use local variables */

        select_cb.sem = sys_sem_new(0);
  118dbf:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  118dc6:	e8 85 0f 00 00       	call   119d50 <sys_sem_new>
  118dcb:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
        /* Note that we are still protected */
        /* Put this select_cb on top of list */
        select_cb.next = select_cb_list;
  118dce:	a1 40 99 13 00       	mov    0x139940,%eax
  118dd3:	89 45 cc             	mov    %eax,0xffffffcc(%ebp)
        select_cb_list = &select_cb;
  118dd6:	8d 45 cc             	lea    0xffffffcc(%ebp),%eax
  118dd9:	a3 40 99 13 00       	mov    %eax,0x139940

        /* Now we can safely unprotect */
        sys_sem_signal(selectsem);
  118dde:	a1 48 99 13 00       	mov    0x139948,%eax
  118de3:	89 04 24             	mov    %eax,(%esp)
  118de6:	e8 e5 0f 00 00       	call   119dd0 <sys_sem_signal>

        /* Now just wait to be woken */
        if (timeout == 0)
  118deb:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
  118def:	75 09                	jne    118dfa <lwip_select+0x1da>
            /* Wait forever */
            msectimeout = 0;
  118df1:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
  118df8:	eb 37                	jmp    118e31 <lwip_select+0x211>
        else
            msectimeout =  ((timeout->tv_sec * 1000) + ((timeout->tv_usec + 500)/1000));
  118dfa:	8b 45 18             	mov    0x18(%ebp),%eax
  118dfd:	8b 00                	mov    (%eax),%eax
  118dff:	69 d8 e8 03 00 00    	imul   $0x3e8,%eax,%ebx
  118e05:	8b 45 18             	mov    0x18(%ebp),%eax
  118e08:	8b 40 04             	mov    0x4(%eax),%eax
  118e0b:	8d 88 f4 01 00 00    	lea    0x1f4(%eax),%ecx
  118e11:	c7 45 c4 d3 4d 62 10 	movl   $0x10624dd3,0xffffffc4(%ebp)
  118e18:	8b 45 c4             	mov    0xffffffc4(%ebp),%eax
  118e1b:	f7 e9                	imul   %ecx
  118e1d:	c1 fa 06             	sar    $0x6,%edx
  118e20:	89 c8                	mov    %ecx,%eax
  118e22:	c1 f8 1f             	sar    $0x1f,%eax
  118e25:	89 d1                	mov    %edx,%ecx
  118e27:	29 c1                	sub    %eax,%ecx
  118e29:	89 c8                	mov    %ecx,%eax
  118e2b:	8d 04 03             	lea    (%ebx,%eax,1),%eax
  118e2e:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)

        i = sys_sem_wait_timeout(select_cb.sem, msectimeout);
  118e31:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
  118e34:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  118e37:	89 44 24 04          	mov    %eax,0x4(%esp)
  118e3b:	89 14 24             	mov    %edx,(%esp)
  118e3e:	e8 cd 72 ff ff       	call   110110 <sys_sem_wait_timeout>
  118e43:	89 45 ec             	mov    %eax,0xffffffec(%ebp)

        /* Take us off the list */
        sys_sem_wait(selectsem);
  118e46:	a1 48 99 13 00       	mov    0x139948,%eax
  118e4b:	89 04 24             	mov    %eax,(%esp)
  118e4e:	e8 bd 6f ff ff       	call   10fe10 <sys_sem_wait>
        if (select_cb_list == &select_cb)
  118e53:	8b 15 40 99 13 00    	mov    0x139940,%edx
  118e59:	8d 45 cc             	lea    0xffffffcc(%ebp),%eax
  118e5c:	39 d0                	cmp    %edx,%eax
  118e5e:	75 0a                	jne    118e6a <lwip_select+0x24a>
            select_cb_list = select_cb.next;
  118e60:	8b 45 cc             	mov    0xffffffcc(%ebp),%eax
  118e63:	a3 40 99 13 00       	mov    %eax,0x139940
  118e68:	eb 2e                	jmp    118e98 <lwip_select+0x278>
        else
            for (p_selcb = select_cb_list; p_selcb; p_selcb = p_selcb->next)
  118e6a:	a1 40 99 13 00       	mov    0x139940,%eax
  118e6f:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  118e72:	eb 1e                	jmp    118e92 <lwip_select+0x272>
                if (p_selcb->next == &select_cb)
  118e74:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  118e77:	8b 10                	mov    (%eax),%edx
  118e79:	8d 45 cc             	lea    0xffffffcc(%ebp),%eax
  118e7c:	39 c2                	cmp    %eax,%edx
  118e7e:	75 0a                	jne    118e8a <lwip_select+0x26a>
                {
                    p_selcb->next = select_cb.next;
  118e80:	8b 55 cc             	mov    0xffffffcc(%ebp),%edx
  118e83:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  118e86:	89 10                	mov    %edx,(%eax)
                    break;
  118e88:	eb 0e                	jmp    118e98 <lwip_select+0x278>
  118e8a:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  118e8d:	8b 00                	mov    (%eax),%eax
  118e8f:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  118e92:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  118e96:	75 dc                	jne    118e74 <lwip_select+0x254>
                }

        sys_sem_signal(selectsem);
  118e98:	a1 48 99 13 00       	mov    0x139948,%eax
  118e9d:	89 04 24             	mov    %eax,(%esp)
  118ea0:	e8 2b 0f 00 00       	call   119dd0 <sys_sem_signal>

        sys_sem_free(select_cb.sem);
  118ea5:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  118ea8:	89 04 24             	mov    %eax,(%esp)
  118eab:	e8 f0 0e 00 00       	call   119da0 <sys_sem_free>
        if (i == 0)             /* Timeout */
  118eb0:	83 7d ec 00          	cmpl   $0x0,0xffffffec(%ebp)
  118eb4:	75 6f                	jne    118f25 <lwip_select+0x305>
        {
            if (readset)
  118eb6:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  118eba:	74 1b                	je     118ed7 <lwip_select+0x2b7>
                FD_ZERO(readset);
  118ebc:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
  118ec3:	00 
  118ec4:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  118ecb:	00 
  118ecc:	8b 45 0c             	mov    0xc(%ebp),%eax
  118ecf:	89 04 24             	mov    %eax,(%esp)
  118ed2:	e8 f9 cf fe ff       	call   105ed0 <memset>
            if (writeset)
  118ed7:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  118edb:	74 1b                	je     118ef8 <lwip_select+0x2d8>
                FD_ZERO(writeset);
  118edd:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
  118ee4:	00 
  118ee5:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  118eec:	00 
  118eed:	8b 45 10             	mov    0x10(%ebp),%eax
  118ef0:	89 04 24             	mov    %eax,(%esp)
  118ef3:	e8 d8 cf fe ff       	call   105ed0 <memset>
            if (exceptset)
  118ef8:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
  118efc:	74 1b                	je     118f19 <lwip_select+0x2f9>
                FD_ZERO(exceptset);
  118efe:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
  118f05:	00 
  118f06:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  118f0d:	00 
  118f0e:	8b 45 14             	mov    0x14(%ebp),%eax
  118f11:	89 04 24             	mov    %eax,(%esp)
  118f14:	e8 b7 cf fe ff       	call   105ed0 <memset>

	    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: timeout expired\n"));
	    set_errno(0);

            return 0;
  118f19:	c7 45 c8 00 00 00 00 	movl   $0x0,0xffffffc8(%ebp)
  118f20:	e9 ef 00 00 00       	jmp    119014 <lwip_select+0x3f4>
        }

        if (readset)
  118f25:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  118f29:	74 0c                	je     118f37 <lwip_select+0x317>
            lreadset = *readset;
  118f2b:	8b 45 0c             	mov    0xc(%ebp),%eax
  118f2e:	0f b7 00             	movzwl (%eax),%eax
  118f31:	66 89 45 ea          	mov    %ax,0xffffffea(%ebp)
  118f35:	eb 1b                	jmp    118f52 <lwip_select+0x332>
        else
            FD_ZERO(&lreadset);
  118f37:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
  118f3e:	00 
  118f3f:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  118f46:	00 
  118f47:	8d 45 ea             	lea    0xffffffea(%ebp),%eax
  118f4a:	89 04 24             	mov    %eax,(%esp)
  118f4d:	e8 7e cf fe ff       	call   105ed0 <memset>
        if (writeset)
  118f52:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  118f56:	74 0c                	je     118f64 <lwip_select+0x344>
            lwriteset = *writeset;
  118f58:	8b 45 10             	mov    0x10(%ebp),%eax
  118f5b:	0f b7 00             	movzwl (%eax),%eax
  118f5e:	66 89 45 e8          	mov    %ax,0xffffffe8(%ebp)
  118f62:	eb 1b                	jmp    118f7f <lwip_select+0x35f>
        else
            FD_ZERO(&lwriteset);
  118f64:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
  118f6b:	00 
  118f6c:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  118f73:	00 
  118f74:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
  118f77:	89 04 24             	mov    %eax,(%esp)
  118f7a:	e8 51 cf fe ff       	call   105ed0 <memset>
        if (exceptset)
  118f7f:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
  118f83:	74 0c                	je     118f91 <lwip_select+0x371>
            lexceptset = *exceptset;
  118f85:	8b 45 14             	mov    0x14(%ebp),%eax
  118f88:	0f b7 00             	movzwl (%eax),%eax
  118f8b:	66 89 45 e6          	mov    %ax,0xffffffe6(%ebp)
  118f8f:	eb 1b                	jmp    118fac <lwip_select+0x38c>
        else
            FD_ZERO(&lexceptset);
  118f91:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
  118f98:	00 
  118f99:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  118fa0:	00 
  118fa1:	8d 45 e6             	lea    0xffffffe6(%ebp),%eax
  118fa4:	89 04 24             	mov    %eax,(%esp)
  118fa7:	e8 24 cf fe ff       	call   105ed0 <memset>

        /* See what's set */
        nready = lwip_selscan(maxfdp1, &lreadset, &lwriteset, &lexceptset);
  118fac:	8d 45 e6             	lea    0xffffffe6(%ebp),%eax
  118faf:	89 44 24 0c          	mov    %eax,0xc(%esp)
  118fb3:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
  118fb6:	89 44 24 08          	mov    %eax,0x8(%esp)
  118fba:	8d 45 ea             	lea    0xffffffea(%ebp),%eax
  118fbd:	89 44 24 04          	mov    %eax,0x4(%esp)
  118fc1:	8b 45 08             	mov    0x8(%ebp),%eax
  118fc4:	89 04 24             	mov    %eax,(%esp)
  118fc7:	e8 94 fa ff ff       	call   118a60 <lwip_selscan>
  118fcc:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
  118fcf:	eb 0d                	jmp    118fde <lwip_select+0x3be>
    }
    else
        sys_sem_signal(selectsem);
  118fd1:	a1 48 99 13 00       	mov    0x139948,%eax
  118fd6:	89 04 24             	mov    %eax,(%esp)
  118fd9:	e8 f2 0d 00 00       	call   119dd0 <sys_sem_signal>

    if (readset)
  118fde:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  118fe2:	74 0a                	je     118fee <lwip_select+0x3ce>
        *readset = lreadset;
  118fe4:	8b 55 0c             	mov    0xc(%ebp),%edx
  118fe7:	0f b7 45 ea          	movzwl 0xffffffea(%ebp),%eax
  118feb:	66 89 02             	mov    %ax,(%edx)
    if (writeset)
  118fee:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  118ff2:	74 0a                	je     118ffe <lwip_select+0x3de>
        *writeset = lwriteset;
  118ff4:	8b 55 10             	mov    0x10(%ebp),%edx
  118ff7:	0f b7 45 e8          	movzwl 0xffffffe8(%ebp),%eax
  118ffb:	66 89 02             	mov    %ax,(%edx)
    if (exceptset)
  118ffe:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
  119002:	74 0a                	je     11900e <lwip_select+0x3ee>
        *exceptset = lexceptset;
  119004:	8b 55 14             	mov    0x14(%ebp),%edx
  119007:	0f b7 45 e6          	movzwl 0xffffffe6(%ebp),%eax
  11900b:	66 89 02             	mov    %ax,(%edx)

    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: nready=%d\n", nready));
    set_errno(0);

    return nready;
  11900e:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  119011:	89 45 c8             	mov    %eax,0xffffffc8(%ebp)
  119014:	8b 45 c8             	mov    0xffffffc8(%ebp),%eax
}
  119017:	83 c4 54             	add    $0x54,%esp
  11901a:	5b                   	pop    %ebx
  11901b:	5d                   	pop    %ebp
  11901c:	c3                   	ret    
  11901d:	8d 76 00             	lea    0x0(%esi),%esi

00119020 <event_callback>:


static void
event_callback(struct netconn *conn, enum netconn_evt evt, u16_t len)
{
  119020:	55                   	push   %ebp
  119021:	89 e5                	mov    %esp,%ebp
  119023:	83 ec 28             	sub    $0x28,%esp
  119026:	8b 45 10             	mov    0x10(%ebp),%eax
  119029:	66 89 45 ec          	mov    %ax,0xffffffec(%ebp)
    int s;
    struct lwip_socket *sock;
    struct lwip_select_cb *scb;

    /* Get socket */
    if (conn)
  11902d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  119031:	0f 84 ce 01 00 00    	je     119205 <event_callback+0x1e5>
    {
        s = conn->socket;
  119037:	8b 45 08             	mov    0x8(%ebp),%eax
  11903a:	8b 40 20             	mov    0x20(%eax),%eax
  11903d:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
        if (s < 0)
  119040:	83 7d f4 00          	cmpl   $0x0,0xfffffff4(%ebp)
  119044:	79 1e                	jns    119064 <event_callback+0x44>
        {
            /* Data comes in right away after an accept, even though
             * the server task might not have created a new socket yet.
             * Just count down (or up) if that's the case and we
             * will use the data later. Note that only receive events
             * can happen before the new socket is set up. */
            if (evt == NETCONN_EVT_RCVPLUS)
  119046:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  11904a:	0f 85 b5 01 00 00    	jne    119205 <event_callback+0x1e5>
                conn->socket--;
  119050:	8b 45 08             	mov    0x8(%ebp),%eax
  119053:	8b 40 20             	mov    0x20(%eax),%eax
  119056:	8d 50 ff             	lea    0xffffffff(%eax),%edx
  119059:	8b 45 08             	mov    0x8(%ebp),%eax
  11905c:	89 50 20             	mov    %edx,0x20(%eax)
            return;
  11905f:	e9 a1 01 00 00       	jmp    119205 <event_callback+0x1e5>
        }

        sock = get_socket(s);
  119064:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  119067:	89 04 24             	mov    %eax,(%esp)
  11906a:	e8 81 ee ff ff       	call   117ef0 <get_socket>
  11906f:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
        if (!sock)
  119072:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  119076:	0f 84 89 01 00 00    	je     119205 <event_callback+0x1e5>
            return;
    }
    else
        return;

    if (!selectsem)
  11907c:	a1 48 99 13 00       	mov    0x139948,%eax
  119081:	85 c0                	test   %eax,%eax
  119083:	75 11                	jne    119096 <event_callback+0x76>
        selectsem = sys_sem_new(1);
  119085:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  11908c:	e8 bf 0c 00 00       	call   119d50 <sys_sem_new>
  119091:	a3 48 99 13 00       	mov    %eax,0x139948

    sys_sem_wait(selectsem);
  119096:	a1 48 99 13 00       	mov    0x139948,%eax
  11909b:	89 04 24             	mov    %eax,(%esp)
  11909e:	e8 6d 6d ff ff       	call   10fe10 <sys_sem_wait>
    /* Set event as required */
    switch (evt)
  1190a3:	8b 45 0c             	mov    0xc(%ebp),%eax
  1190a6:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
  1190a9:	83 7d e8 01          	cmpl   $0x1,0xffffffe8(%ebp)
  1190ad:	74 27                	je     1190d6 <event_callback+0xb6>
  1190af:	83 7d e8 01          	cmpl   $0x1,0xffffffe8(%ebp)
  1190b3:	72 0e                	jb     1190c3 <event_callback+0xa3>
  1190b5:	83 7d e8 02          	cmpl   $0x2,0xffffffe8(%ebp)
  1190b9:	74 2e                	je     1190e9 <event_callback+0xc9>
  1190bb:	83 7d e8 03          	cmpl   $0x3,0xffffffe8(%ebp)
  1190bf:	74 33                	je     1190f4 <event_callback+0xd4>
  1190c1:	eb 3a                	jmp    1190fd <event_callback+0xdd>
    {
      case NETCONN_EVT_RCVPLUS:
        sock->rcvevent++;
  1190c3:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1190c6:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  1190ca:	8d 50 01             	lea    0x1(%eax),%edx
  1190cd:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1190d0:	66 89 50 0a          	mov    %dx,0xa(%eax)
        break;
  1190d4:	eb 27                	jmp    1190fd <event_callback+0xdd>
      case NETCONN_EVT_RCVMINUS:
        sock->rcvevent--;
  1190d6:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1190d9:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  1190dd:	8d 50 ff             	lea    0xffffffff(%eax),%edx
  1190e0:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1190e3:	66 89 50 0a          	mov    %dx,0xa(%eax)
        break;
  1190e7:	eb 14                	jmp    1190fd <event_callback+0xdd>
      case NETCONN_EVT_SENDPLUS:
        sock->sendevent = 1;
  1190e9:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1190ec:	66 c7 40 0c 01 00    	movw   $0x1,0xc(%eax)
        break;
  1190f2:	eb 09                	jmp    1190fd <event_callback+0xdd>
      case NETCONN_EVT_SENDMINUS:
        sock->sendevent = 0;
  1190f4:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1190f7:	66 c7 40 0c 00 00    	movw   $0x0,0xc(%eax)
        break;
    }
    sys_sem_signal(selectsem);
  1190fd:	a1 48 99 13 00       	mov    0x139948,%eax
  119102:	89 04 24             	mov    %eax,(%esp)
  119105:	e8 c6 0c 00 00       	call   119dd0 <sys_sem_signal>

    /* Now decide if anyone is waiting for this socket */
    /* NOTE: This code is written this way to protect the select link list
       but to avoid a deadlock situation by releasing socksem before
       signalling for the select. This means we need to go through the list
       multiple times ONLY IF a select was actually waiting. We go through
       the list the number of waiting select calls + 1. This list is
       expected to be small. */
    while (1)
    {
        sys_sem_wait(selectsem);
  11910a:	a1 48 99 13 00       	mov    0x139948,%eax
  11910f:	89 04 24             	mov    %eax,(%esp)
  119112:	e8 f9 6c ff ff       	call   10fe10 <sys_sem_wait>
        for (scb = select_cb_list; scb; scb = scb->next)
  119117:	a1 40 99 13 00       	mov    0x139940,%eax
  11911c:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  11911f:	e9 9a 00 00 00       	jmp    1191be <event_callback+0x19e>
        {
            if (scb->sem_signalled == 0)
  119124:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  119127:	8b 40 10             	mov    0x10(%eax),%eax
  11912a:	85 c0                	test   %eax,%eax
  11912c:	0f 85 84 00 00 00    	jne    1191b6 <event_callback+0x196>
            {
                /* Test this select call for our socket */
                if (scb->readset && FD_ISSET(s, scb->readset))
  119132:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  119135:	8b 40 04             	mov    0x4(%eax),%eax
  119138:	85 c0                	test   %eax,%eax
  11913a:	74 38                	je     119174 <event_callback+0x154>
  11913c:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  11913f:	8b 48 04             	mov    0x4(%eax),%ecx
  119142:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
  119145:	89 d0                	mov    %edx,%eax
  119147:	c1 f8 1f             	sar    $0x1f,%eax
  11914a:	c1 e8 1d             	shr    $0x1d,%eax
  11914d:	01 d0                	add    %edx,%eax
  11914f:	c1 f8 03             	sar    $0x3,%eax
  119152:	0f b6 04 01          	movzbl (%ecx,%eax,1),%eax
  119156:	0f b6 c0             	movzbl %al,%eax
  119159:	8b 4d f4             	mov    0xfffffff4(%ebp),%ecx
  11915c:	83 e1 07             	and    $0x7,%ecx
  11915f:	d3 f8                	sar    %cl,%eax
  119161:	83 e0 01             	and    $0x1,%eax
  119164:	84 c0                	test   %al,%al
  119166:	74 0c                	je     119174 <event_callback+0x154>
                    if (sock->rcvevent)
  119168:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  11916b:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  11916f:	66 85 c0             	test   %ax,%ax
  119172:	75 54                	jne    1191c8 <event_callback+0x1a8>
                        break;
                if (scb->writeset && FD_ISSET(s, scb->writeset))
  119174:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  119177:	8b 40 08             	mov    0x8(%eax),%eax
  11917a:	85 c0                	test   %eax,%eax
  11917c:	74 38                	je     1191b6 <event_callback+0x196>
  11917e:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  119181:	8b 48 08             	mov    0x8(%eax),%ecx
  119184:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
  119187:	89 d0                	mov    %edx,%eax
  119189:	c1 f8 1f             	sar    $0x1f,%eax
  11918c:	c1 e8 1d             	shr    $0x1d,%eax
  11918f:	01 d0                	add    %edx,%eax
  119191:	c1 f8 03             	sar    $0x3,%eax
  119194:	0f b6 04 01          	movzbl (%ecx,%eax,1),%eax
  119198:	0f b6 c0             	movzbl %al,%eax
  11919b:	8b 4d f4             	mov    0xfffffff4(%ebp),%ecx
  11919e:	83 e1 07             	and    $0x7,%ecx
  1191a1:	d3 f8                	sar    %cl,%eax
  1191a3:	83 e0 01             	and    $0x1,%eax
  1191a6:	84 c0                	test   %al,%al
  1191a8:	74 0c                	je     1191b6 <event_callback+0x196>
                    if (sock->sendevent)
  1191aa:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1191ad:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  1191b1:	66 85 c0             	test   %ax,%ax
  1191b4:	75 12                	jne    1191c8 <event_callback+0x1a8>
  1191b6:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1191b9:	8b 00                	mov    (%eax),%eax
  1191bb:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  1191be:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  1191c2:	0f 85 5c ff ff ff    	jne    119124 <event_callback+0x104>
                        break;
            }
        }
        if (scb)
  1191c8:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  1191cc:	74 2a                	je     1191f8 <event_callback+0x1d8>
        {
            scb->sem_signalled = 1;
  1191ce:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1191d1:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
            sys_sem_signal(selectsem);
  1191d8:	a1 48 99 13 00       	mov    0x139948,%eax
  1191dd:	89 04 24             	mov    %eax,(%esp)
  1191e0:	e8 eb 0b 00 00       	call   119dd0 <sys_sem_signal>
            sys_sem_signal(scb->sem);
  1191e5:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1191e8:	8b 40 14             	mov    0x14(%eax),%eax
  1191eb:	89 04 24             	mov    %eax,(%esp)
  1191ee:	e8 dd 0b 00 00       	call   119dd0 <sys_sem_signal>
        } else {
            sys_sem_signal(selectsem);
            break;
        }
    }
  1191f3:	e9 12 ff ff ff       	jmp    11910a <event_callback+0xea>
  1191f8:	a1 48 99 13 00       	mov    0x139948,%eax
  1191fd:	89 04 24             	mov    %eax,(%esp)
  119200:	e8 cb 0b 00 00       	call   119dd0 <sys_sem_signal>

}
  119205:	c9                   	leave  
  119206:	c3                   	ret    
  119207:	89 f6                	mov    %esi,%esi
  119209:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00119210 <lwip_shutdown>:




int lwip_shutdown(int s, int how)
{
  119210:	55                   	push   %ebp
  119211:	89 e5                	mov    %esp,%ebp
  119213:	83 ec 08             	sub    $0x8,%esp
  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_shutdown(%d, how=%d)\n", s, how));
  return lwip_close(s); /* XXX temporary hack until proper implementation */
  119216:	8b 45 08             	mov    0x8(%ebp),%eax
  119219:	89 04 24             	mov    %eax,(%esp)
  11921c:	e8 6f f0 ff ff       	call   118290 <lwip_close>
}
  119221:	c9                   	leave  
  119222:	c3                   	ret    
  119223:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  119229:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00119230 <lwip_getpeername>:

int lwip_getpeername (int s, struct sockaddr *name, socklen_t *namelen)
{
  119230:	55                   	push   %ebp
  119231:	89 e5                	mov    %esp,%ebp
  119233:	83 ec 38             	sub    $0x38,%esp
  struct lwip_socket *sock;
  struct sockaddr_in sin;
  struct ip_addr naddr;

  sock = get_socket(s);
  119236:	8b 45 08             	mov    0x8(%ebp),%eax
  119239:	89 04 24             	mov    %eax,(%esp)
  11923c:	e8 af ec ff ff       	call   117ef0 <get_socket>
  119241:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  if (!sock) {
  119244:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  119248:	75 0c                	jne    119256 <lwip_getpeername+0x26>
    set_errno(EBADF);
    return -1;
  11924a:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,0xffffffdc(%ebp)
  119251:	e9 99 00 00 00       	jmp    1192ef <lwip_getpeername+0xbf>
  }

  memset(&sin, 0, sizeof(sin));
  119256:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
  11925d:	00 
  11925e:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  119265:	00 
  119266:	8d 45 ec             	lea    0xffffffec(%ebp),%eax
  119269:	89 04 24             	mov    %eax,(%esp)
  11926c:	e8 5f cc fe ff       	call   105ed0 <memset>
  sin.sin_len = sizeof(sin);
  119271:	c6 45 ec 10          	movb   $0x10,0xffffffec(%ebp)
  sin.sin_family = AF_INET;
  119275:	c6 45 ed 02          	movb   $0x2,0xffffffed(%ebp)

  /* get the IP address and port of the remote host */
  netconn_peer(sock->conn, &naddr, &sin.sin_port);
  119279:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  11927c:	8b 10                	mov    (%eax),%edx
  11927e:	8d 45 ec             	lea    0xffffffec(%ebp),%eax
  119281:	83 c0 02             	add    $0x2,%eax
  119284:	89 44 24 08          	mov    %eax,0x8(%esp)
  119288:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
  11928b:	89 44 24 04          	mov    %eax,0x4(%esp)
  11928f:	89 14 24             	mov    %edx,(%esp)
  119292:	e8 49 cd ff ff       	call   115fe0 <netconn_peer>

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getpeername(%d, addr=", s));
  ip_addr_debug_print(SOCKETS_DEBUG, &naddr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%d)\n", sin.sin_port));

  sin.sin_port = htons(sin.sin_port);
  119297:	0f b7 45 ee          	movzwl 0xffffffee(%ebp),%eax
  11929b:	0f b7 c0             	movzwl %ax,%eax
  11929e:	89 04 24             	mov    %eax,(%esp)
  1192a1:	e8 da 4f ff ff       	call   10e280 <htons>
  1192a6:	66 89 45 ee          	mov    %ax,0xffffffee(%ebp)
  sin.sin_addr.s_addr = naddr.addr;
  1192aa:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  1192ad:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)

  if (*namelen > sizeof(sin))
  1192b0:	8b 45 10             	mov    0x10(%ebp),%eax
  1192b3:	8b 00                	mov    (%eax),%eax
  1192b5:	83 f8 10             	cmp    $0x10,%eax
  1192b8:	76 09                	jbe    1192c3 <lwip_getpeername+0x93>
      *namelen = sizeof(sin);
  1192ba:	8b 45 10             	mov    0x10(%ebp),%eax
  1192bd:	c7 00 10 00 00 00    	movl   $0x10,(%eax)

  memcpy(name, &sin, *namelen);
  1192c3:	8b 45 10             	mov    0x10(%ebp),%eax
  1192c6:	8b 00                	mov    (%eax),%eax
  1192c8:	89 44 24 08          	mov    %eax,0x8(%esp)
  1192cc:	8d 45 ec             	lea    0xffffffec(%ebp),%eax
  1192cf:	89 44 24 04          	mov    %eax,0x4(%esp)
  1192d3:	8b 45 0c             	mov    0xc(%ebp),%eax
  1192d6:	89 04 24             	mov    %eax,(%esp)
  1192d9:	e8 b2 cb fe ff       	call   105e90 <memcpy>
  sock_set_errno(sock, 0);
  1192de:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1192e1:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  return 0;
  1192e8:	c7 45 dc 00 00 00 00 	movl   $0x0,0xffffffdc(%ebp)
  1192ef:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
}
  1192f2:	c9                   	leave  
  1192f3:	c3                   	ret    
  1192f4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  1192fa:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

00119300 <lwip_getsockname>:

int lwip_getsockname (int s, struct sockaddr *name, socklen_t *namelen)
{
  119300:	55                   	push   %ebp
  119301:	89 e5                	mov    %esp,%ebp
  119303:	83 ec 38             	sub    $0x38,%esp
  struct lwip_socket *sock;
  struct sockaddr_in sin;
  struct ip_addr *naddr;

  sock = get_socket(s);
  119306:	8b 45 08             	mov    0x8(%ebp),%eax
  119309:	89 04 24             	mov    %eax,(%esp)
  11930c:	e8 df eb ff ff       	call   117ef0 <get_socket>
  119311:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  if (!sock) {
  119314:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  119318:	75 0c                	jne    119326 <lwip_getsockname+0x26>
    set_errno(EBADF);
    return -1;
  11931a:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,0xffffffdc(%ebp)
  119321:	e9 9b 00 00 00       	jmp    1193c1 <lwip_getsockname+0xc1>
  }

  memset(&sin, 0, sizeof(sin));
  119326:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
  11932d:	00 
  11932e:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  119335:	00 
  119336:	8d 45 ec             	lea    0xffffffec(%ebp),%eax
  119339:	89 04 24             	mov    %eax,(%esp)
  11933c:	e8 8f cb fe ff       	call   105ed0 <memset>
  sin.sin_len = sizeof(sin);
  119341:	c6 45 ec 10          	movb   $0x10,0xffffffec(%ebp)
  sin.sin_family = AF_INET;
  119345:	c6 45 ed 02          	movb   $0x2,0xffffffed(%ebp)

  /* get the IP address and port of the remote host */
  netconn_addr(sock->conn, &naddr, &sin.sin_port);
  119349:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  11934c:	8b 10                	mov    (%eax),%edx
  11934e:	8d 45 ec             	lea    0xffffffec(%ebp),%eax
  119351:	83 c0 02             	add    $0x2,%eax
  119354:	89 44 24 08          	mov    %eax,0x8(%esp)
  119358:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
  11935b:	89 44 24 04          	mov    %eax,0x4(%esp)
  11935f:	89 14 24             	mov    %edx,(%esp)
  119362:	e8 39 cd ff ff       	call   1160a0 <netconn_addr>

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockname(%d, addr=", s));
  ip_addr_debug_print(SOCKETS_DEBUG, naddr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%d)\n", sin.sin_port));

  sin.sin_port = htons(sin.sin_port);
  119367:	0f b7 45 ee          	movzwl 0xffffffee(%ebp),%eax
  11936b:	0f b7 c0             	movzwl %ax,%eax
  11936e:	89 04 24             	mov    %eax,(%esp)
  119371:	e8 0a 4f ff ff       	call   10e280 <htons>
  119376:	66 89 45 ee          	mov    %ax,0xffffffee(%ebp)
  sin.sin_addr.s_addr = naddr->addr;
  11937a:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  11937d:	8b 00                	mov    (%eax),%eax
  11937f:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)

  if (*namelen > sizeof(sin))
  119382:	8b 45 10             	mov    0x10(%ebp),%eax
  119385:	8b 00                	mov    (%eax),%eax
  119387:	83 f8 10             	cmp    $0x10,%eax
  11938a:	76 09                	jbe    119395 <lwip_getsockname+0x95>
      *namelen = sizeof(sin);
  11938c:	8b 45 10             	mov    0x10(%ebp),%eax
  11938f:	c7 00 10 00 00 00    	movl   $0x10,(%eax)

  memcpy(name, &sin, *namelen);
  119395:	8b 45 10             	mov    0x10(%ebp),%eax
  119398:	8b 00                	mov    (%eax),%eax
  11939a:	89 44 24 08          	mov    %eax,0x8(%esp)
  11939e:	8d 45 ec             	lea    0xffffffec(%ebp),%eax
  1193a1:	89 44 24 04          	mov    %eax,0x4(%esp)
  1193a5:	8b 45 0c             	mov    0xc(%ebp),%eax
  1193a8:	89 04 24             	mov    %eax,(%esp)
  1193ab:	e8 e0 ca fe ff       	call   105e90 <memcpy>
  sock_set_errno(sock, 0);
  1193b0:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1193b3:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  return 0;
  1193ba:	c7 45 dc 00 00 00 00 	movl   $0x0,0xffffffdc(%ebp)
  1193c1:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
}
  1193c4:	c9                   	leave  
  1193c5:	c3                   	ret    
  1193c6:	8d 76 00             	lea    0x0(%esi),%esi
  1193c9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

001193d0 <lwip_getsockopt>:

int lwip_getsockopt (int s, int level, int optname, void *optval, socklen_t *optlen)
{
  1193d0:	55                   	push   %ebp
  1193d1:	89 e5                	mov    %esp,%ebp
  1193d3:	83 ec 38             	sub    $0x38,%esp
  int err = 0;
  1193d6:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)
  struct lwip_socket *sock = get_socket(s);
  1193dd:	8b 45 08             	mov    0x8(%ebp),%eax
  1193e0:	89 04 24             	mov    %eax,(%esp)
  1193e3:	e8 08 eb ff ff       	call   117ef0 <get_socket>
  1193e8:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)

  if(!sock) {
  1193eb:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  1193ef:	75 0c                	jne    1193fd <lwip_getsockopt+0x2d>
   	set_errno(EBADF);
    return -1;
  1193f1:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,0xffffffe4(%ebp)
  1193f8:	e9 df 02 00 00       	jmp    1196dc <lwip_getsockopt+0x30c>
  }

  if( NULL == optval || NULL == optlen ) {
  1193fd:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
  119401:	74 06                	je     119409 <lwip_getsockopt+0x39>
  119403:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
  119407:	75 16                	jne    11941f <lwip_getsockopt+0x4f>
    sock_set_errno( sock, EFAULT );
  119409:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  11940c:	c7 40 10 0e 00 00 00 	movl   $0xe,0x10(%eax)
    return -1;
  119413:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,0xffffffe4(%ebp)
  11941a:	e9 bd 02 00 00       	jmp    1196dc <lwip_getsockopt+0x30c>
  }

  /* Do length and type checks for the various options first, to keep it readable. */
  switch( level ) {
  11941f:	8b 45 0c             	mov    0xc(%ebp),%eax
  119422:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
  119425:	83 7d e0 06          	cmpl   $0x6,0xffffffe0(%ebp)
  119429:	0f 84 a0 00 00 00    	je     1194cf <lwip_getsockopt+0xff>
  11942f:	81 7d e0 ff 0f 00 00 	cmpl   $0xfff,0xffffffe0(%ebp)
  119436:	74 0b                	je     119443 <lwip_getsockopt+0x73>
  119438:	83 7d e0 00          	cmpl   $0x0,0xffffffe0(%ebp)
  11943c:	74 6a                	je     1194a8 <lwip_getsockopt+0xd8>
  11943e:	e9 cc 00 00 00       	jmp    11950f <lwip_getsockopt+0x13f>
   
/* Level: SOL_SOCKET */
  case SOL_SOCKET:
      switch(optname) {
  119443:	8b 45 10             	mov    0x10(%ebp),%eax
  119446:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
  119449:	83 7d dc 20          	cmpl   $0x20,0xffffffdc(%ebp)
  11944d:	74 39                	je     119488 <lwip_getsockopt+0xb8>
  11944f:	83 7d dc 20          	cmpl   $0x20,0xffffffdc(%ebp)
  119453:	7f 14                	jg     119469 <lwip_getsockopt+0x99>
  119455:	83 7d dc 04          	cmpl   $0x4,0xffffffdc(%ebp)
  119459:	74 2d                	je     119488 <lwip_getsockopt+0xb8>
  11945b:	83 7d dc 08          	cmpl   $0x8,0xffffffdc(%ebp)
  11945f:	74 27                	je     119488 <lwip_getsockopt+0xb8>
  119461:	83 7d dc 02          	cmpl   $0x2,0xffffffdc(%ebp)
  119465:	74 21                	je     119488 <lwip_getsockopt+0xb8>
  119467:	eb 36                	jmp    11949f <lwip_getsockopt+0xcf>
  119469:	81 7d dc 00 02 00 00 	cmpl   $0x200,0xffffffdc(%ebp)
  119470:	74 16                	je     119488 <lwip_getsockopt+0xb8>
  119472:	81 7d dc 00 02 00 00 	cmpl   $0x200,0xffffffdc(%ebp)
  119479:	7c 24                	jl     11949f <lwip_getsockopt+0xcf>
  11947b:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  11947e:	2d 07 10 00 00       	sub    $0x1007,%eax
  119483:	83 f8 01             	cmp    $0x1,%eax
  119486:	77 17                	ja     11949f <lwip_getsockopt+0xcf>
         
      case SO_ACCEPTCONN:
      case SO_BROADCAST:
      /* UNIMPL case SO_DEBUG: */
      /* UNIMPL case SO_DONTROUTE: */
      case SO_ERROR:
      case SO_KEEPALIVE:
      /* UNIMPL case SO_OOBINLINE: */
      /* UNIMPL case SO_RCVBUF: */
      /* UNIMPL case SO_SNDBUF: */
      /* UNIMPL case SO_RCVLOWAT: */
      /* UNIMPL case SO_SNDLOWAT: */
#if SO_REUSE
      case SO_REUSEADDR:
      case SO_REUSEPORT:
#endif /* SO_REUSE */
      case SO_TYPE:
      /* UNIMPL case SO_USELOOPBACK: */
        if( *optlen < sizeof(int) ) {
  119488:	8b 45 18             	mov    0x18(%ebp),%eax
  11948b:	8b 00                	mov    (%eax),%eax
  11948d:	83 f8 03             	cmp    $0x3,%eax
  119490:	0f 87 80 00 00 00    	ja     119516 <lwip_getsockopt+0x146>
          err = EINVAL;
  119496:	c7 45 f8 16 00 00 00 	movl   $0x16,0xfffffff8(%ebp)
        }
          break;
  11949d:	eb 77                	jmp    119516 <lwip_getsockopt+0x146>

      default:
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, UNIMPL: optname=0x%x, ..)\n", s, optname));
        err = ENOPROTOOPT;
  11949f:	c7 45 f8 5c 00 00 00 	movl   $0x5c,0xfffffff8(%ebp)
      }  /* switch */
      break;
  1194a6:	eb 6e                	jmp    119516 <lwip_getsockopt+0x146>
                     
/* Level: IPPROTO_IP */
  case IPPROTO_IP:
      switch(optname) {
  1194a8:	8b 45 10             	mov    0x10(%ebp),%eax
  1194ab:	83 e8 01             	sub    $0x1,%eax
  1194ae:	83 f8 01             	cmp    $0x1,%eax
  1194b1:	77 13                	ja     1194c6 <lwip_getsockopt+0xf6>
      /* UNIMPL case IP_HDRINCL: */
      /* UNIMPL case IP_RCVDSTADDR: */
      /* UNIMPL case IP_RCVIF: */
      case IP_TTL:
      case IP_TOS:
        if( *optlen < sizeof(int) ) {
  1194b3:	8b 45 18             	mov    0x18(%ebp),%eax
  1194b6:	8b 00                	mov    (%eax),%eax
  1194b8:	83 f8 03             	cmp    $0x3,%eax
  1194bb:	77 59                	ja     119516 <lwip_getsockopt+0x146>
          err = EINVAL;
  1194bd:	c7 45 f8 16 00 00 00 	movl   $0x16,0xfffffff8(%ebp)
        }
        break;
  1194c4:	eb 50                	jmp    119516 <lwip_getsockopt+0x146>

      default:
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, UNIMPL: optname=0x%x, ..)\n", s, optname));
        err = ENOPROTOOPT;
  1194c6:	c7 45 f8 5c 00 00 00 	movl   $0x5c,0xfffffff8(%ebp)
      }  /* switch */
      break;
  1194cd:	eb 47                	jmp    119516 <lwip_getsockopt+0x146>
         
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
      if( *optlen < sizeof(int) ) {
  1194cf:	8b 45 18             	mov    0x18(%ebp),%eax
  1194d2:	8b 00                	mov    (%eax),%eax
  1194d4:	83 f8 03             	cmp    $0x3,%eax
  1194d7:	77 09                	ja     1194e2 <lwip_getsockopt+0x112>
        err = EINVAL;
  1194d9:	c7 45 f8 16 00 00 00 	movl   $0x16,0xfffffff8(%ebp)
        break;
  1194e0:	eb 34                	jmp    119516 <lwip_getsockopt+0x146>
    }
      
      /* If this is no TCP socket, ignore any options. */
      if ( sock->conn->type != NETCONN_TCP ) return 0;
  1194e2:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1194e5:	8b 00                	mov    (%eax),%eax
  1194e7:	8b 00                	mov    (%eax),%eax
  1194e9:	85 c0                	test   %eax,%eax
  1194eb:	74 0c                	je     1194f9 <lwip_getsockopt+0x129>
  1194ed:	c7 45 e4 00 00 00 00 	movl   $0x0,0xffffffe4(%ebp)
  1194f4:	e9 e3 01 00 00       	jmp    1196dc <lwip_getsockopt+0x30c>

      switch( optname ) {
  1194f9:	8b 45 10             	mov    0x10(%ebp),%eax
  1194fc:	83 e8 01             	sub    $0x1,%eax
  1194ff:	83 f8 01             	cmp    $0x1,%eax
  119502:	77 02                	ja     119506 <lwip_getsockopt+0x136>
      case TCP_NODELAY:
      case TCP_KEEPALIVE:
        break;
  119504:	eb 10                	jmp    119516 <lwip_getsockopt+0x146>
         
      default:
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_TCP, UNIMPL: optname=0x%x, ..)\n", s, optname));
        err = ENOPROTOOPT;
  119506:	c7 45 f8 5c 00 00 00 	movl   $0x5c,0xfffffff8(%ebp)
      }  /* switch */
      break;
  11950d:	eb 07                	jmp    119516 <lwip_getsockopt+0x146>

/* UNDEFINED LEVEL */
  default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, level=0x%x, UNIMPL: optname=0x%x, ..)\n", s, level, optname));
      err = ENOPROTOOPT;
  11950f:	c7 45 f8 5c 00 00 00 	movl   $0x5c,0xfffffff8(%ebp)
  }  /* switch */

   
  if( 0 != err ) {
  119516:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  11951a:	74 15                	je     119531 <lwip_getsockopt+0x161>
    sock_set_errno(sock, err);
  11951c:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  11951f:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  119522:	89 42 10             	mov    %eax,0x10(%edx)
    return -1;
  119525:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,0xffffffe4(%ebp)
  11952c:	e9 ab 01 00 00       	jmp    1196dc <lwip_getsockopt+0x30c>
  }
   


  /* Now do the actual option processing */

  switch(level) {
  119531:	8b 45 0c             	mov    0xc(%ebp),%eax
  119534:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
  119537:	83 7d d8 06          	cmpl   $0x6,0xffffffd8(%ebp)
  11953b:	0f 84 36 01 00 00    	je     119677 <lwip_getsockopt+0x2a7>
  119541:	81 7d d8 ff 0f 00 00 	cmpl   $0xfff,0xffffffd8(%ebp)
  119548:	74 0f                	je     119559 <lwip_getsockopt+0x189>
  11954a:	83 7d d8 00          	cmpl   $0x0,0xffffffd8(%ebp)
  11954e:	0f 84 e3 00 00 00    	je     119637 <lwip_getsockopt+0x267>
  119554:	e9 5e 01 00 00       	jmp    1196b7 <lwip_getsockopt+0x2e7>
   
/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch( optname ) {
  119559:	8b 45 10             	mov    0x10(%ebp),%eax
  11955c:	89 45 d4             	mov    %eax,0xffffffd4(%ebp)
  11955f:	83 7d d4 20          	cmpl   $0x20,0xffffffd4(%ebp)
  119563:	74 41                	je     1195a6 <lwip_getsockopt+0x1d6>
  119565:	83 7d d4 20          	cmpl   $0x20,0xffffffd4(%ebp)
  119569:	7f 17                	jg     119582 <lwip_getsockopt+0x1b2>
  11956b:	83 7d d4 04          	cmpl   $0x4,0xffffffd4(%ebp)
  11956f:	74 35                	je     1195a6 <lwip_getsockopt+0x1d6>
  119571:	83 7d d4 08          	cmpl   $0x8,0xffffffd4(%ebp)
  119575:	74 2f                	je     1195a6 <lwip_getsockopt+0x1d6>
  119577:	83 7d d4 02          	cmpl   $0x2,0xffffffd4(%ebp)
  11957b:	74 29                	je     1195a6 <lwip_getsockopt+0x1d6>
  11957d:	e9 35 01 00 00       	jmp    1196b7 <lwip_getsockopt+0x2e7>
  119582:	81 7d d4 07 10 00 00 	cmpl   $0x1007,0xffffffd4(%ebp)
  119589:	0f 84 8e 00 00 00    	je     11961d <lwip_getsockopt+0x24d>
  11958f:	81 7d d4 08 10 00 00 	cmpl   $0x1008,0xffffffd4(%ebp)
  119596:	74 2a                	je     1195c2 <lwip_getsockopt+0x1f2>
  119598:	81 7d d4 00 02 00 00 	cmpl   $0x200,0xffffffd4(%ebp)
  11959f:	74 05                	je     1195a6 <lwip_getsockopt+0x1d6>
  1195a1:	e9 11 01 00 00       	jmp    1196b7 <lwip_getsockopt+0x2e7>

    /* The option flags */
    case SO_ACCEPTCONN:
    case SO_BROADCAST:
    /* UNIMPL case SO_DEBUG: */
    /* UNIMPL case SO_DONTROUTE: */
    case SO_KEEPALIVE:
    /* UNIMPL case SO_OOBINCLUDE: */
#if SO_REUSE
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /*case SO_USELOOPBACK: UNIMPL */
      *(int*)optval = sock->conn->pcb.tcp->so_options & optname;
  1195a6:	8b 55 14             	mov    0x14(%ebp),%edx
  1195a9:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1195ac:	8b 00                	mov    (%eax),%eax
  1195ae:	8b 40 08             	mov    0x8(%eax),%eax
  1195b1:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  1195b5:	0f b7 c0             	movzwl %ax,%eax
  1195b8:	23 45 10             	and    0x10(%ebp),%eax
  1195bb:	89 02                	mov    %eax,(%edx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, optname=0x%x, ..) = %s\n", s, optname, (*(int*)optval?"on":"off")));
      break;
  1195bd:	e9 f5 00 00 00       	jmp    1196b7 <lwip_getsockopt+0x2e7>

    case SO_TYPE:
      switch (sock->conn->type) {
  1195c2:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1195c5:	8b 00                	mov    (%eax),%eax
  1195c7:	8b 00                	mov    (%eax),%eax
  1195c9:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
  1195cc:	83 7d e8 03          	cmpl   $0x3,0xffffffe8(%ebp)
  1195d0:	77 08                	ja     1195da <lwip_getsockopt+0x20a>
  1195d2:	83 7d e8 01          	cmpl   $0x1,0xffffffe8(%ebp)
  1195d6:	73 26                	jae    1195fe <lwip_getsockopt+0x22e>
  1195d8:	eb 16                	jmp    1195f0 <lwip_getsockopt+0x220>
  1195da:	83 7d e8 04          	cmpl   $0x4,0xffffffe8(%ebp)
  1195de:	74 02                	je     1195e2 <lwip_getsockopt+0x212>
  1195e0:	eb 2a                	jmp    11960c <lwip_getsockopt+0x23c>
      case NETCONN_RAW:
        *(int*)optval = SOCK_RAW;
  1195e2:	8b 45 14             	mov    0x14(%ebp),%eax
  1195e5:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
        break;
  1195eb:	e9 c7 00 00 00       	jmp    1196b7 <lwip_getsockopt+0x2e7>
      case NETCONN_TCP:
        *(int*)optval = SOCK_STREAM;
  1195f0:	8b 45 14             	mov    0x14(%ebp),%eax
  1195f3:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
        break;
  1195f9:	e9 b9 00 00 00       	jmp    1196b7 <lwip_getsockopt+0x2e7>
      case NETCONN_UDP:
      case NETCONN_UDPLITE:
      case NETCONN_UDPNOCHKSUM:
        *(int*)optval = SOCK_DGRAM;
  1195fe:	8b 45 14             	mov    0x14(%ebp),%eax
  119601:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
        break;
  119607:	e9 ab 00 00 00       	jmp    1196b7 <lwip_getsockopt+0x2e7>
      default: /* unrecognized socket type */
        *(int*)optval = sock->conn->type;
  11960c:	8b 55 14             	mov    0x14(%ebp),%edx
  11960f:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  119612:	8b 00                	mov    (%eax),%eax
  119614:	8b 00                	mov    (%eax),%eax
  119616:	89 02                	mov    %eax,(%edx)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, SO_TYPE): unrecognized socket type %d\n", s, *(int *)optval));
      }  /* switch */
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, SO_TYPE) = %d\n", s, *(int *)optval));
      break;
  119618:	e9 9a 00 00 00       	jmp    1196b7 <lwip_getsockopt+0x2e7>

    case SO_ERROR:
      *(int *)optval = sock->err;
  11961d:	8b 55 14             	mov    0x14(%ebp),%edx
  119620:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  119623:	8b 40 10             	mov    0x10(%eax),%eax
  119626:	89 02                	mov    %eax,(%edx)
      sock->err = 0;
  119628:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  11962b:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, SO_ERROR) = %d\n", s, *(int *)optval));
      break;
    }  /* switch */
    break;
  119632:	e9 80 00 00 00       	jmp    1196b7 <lwip_getsockopt+0x2e7>

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch( optname ) {
  119637:	8b 45 10             	mov    0x10(%ebp),%eax
  11963a:	89 45 d0             	mov    %eax,0xffffffd0(%ebp)
  11963d:	83 7d d0 01          	cmpl   $0x1,0xffffffd0(%ebp)
  119641:	74 1e                	je     119661 <lwip_getsockopt+0x291>
  119643:	83 7d d0 02          	cmpl   $0x2,0xffffffd0(%ebp)
  119647:	74 02                	je     11964b <lwip_getsockopt+0x27b>
  119649:	eb 6c                	jmp    1196b7 <lwip_getsockopt+0x2e7>
    case IP_TTL:
      *(int*)optval = sock->conn->pcb.tcp->ttl;
  11964b:	8b 55 14             	mov    0x14(%ebp),%edx
  11964e:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  119651:	8b 00                	mov    (%eax),%eax
  119653:	8b 40 08             	mov    0x8(%eax),%eax
  119656:	0f b6 40 0b          	movzbl 0xb(%eax),%eax
  11965a:	0f b6 c0             	movzbl %al,%eax
  11965d:	89 02                	mov    %eax,(%edx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_TTL) = %d\n", s, *(int *)optval));
      break;
  11965f:	eb 56                	jmp    1196b7 <lwip_getsockopt+0x2e7>
    case IP_TOS:
      *(int*)optval = sock->conn->pcb.tcp->tos;
  119661:	8b 55 14             	mov    0x14(%ebp),%edx
  119664:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  119667:	8b 00                	mov    (%eax),%eax
  119669:	8b 40 08             	mov    0x8(%eax),%eax
  11966c:	0f b6 40 0a          	movzbl 0xa(%eax),%eax
  119670:	0f b6 c0             	movzbl %al,%eax
  119673:	89 02                	mov    %eax,(%edx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_TOS) = %d\n", s, *(int *)optval));
      break;
    }  /* switch */
    break;
  119675:	eb 40                	jmp    1196b7 <lwip_getsockopt+0x2e7>

/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    switch( optname ) {
  119677:	8b 45 10             	mov    0x10(%ebp),%eax
  11967a:	89 45 cc             	mov    %eax,0xffffffcc(%ebp)
  11967d:	83 7d cc 01          	cmpl   $0x1,0xffffffcc(%ebp)
  119681:	74 08                	je     11968b <lwip_getsockopt+0x2bb>
  119683:	83 7d cc 02          	cmpl   $0x2,0xffffffcc(%ebp)
  119687:	74 1b                	je     1196a4 <lwip_getsockopt+0x2d4>
  119689:	eb 2c                	jmp    1196b7 <lwip_getsockopt+0x2e7>
    case TCP_NODELAY:
      *(int*)optval = (sock->conn->pcb.tcp->flags & TF_NODELAY);
  11968b:	8b 55 14             	mov    0x14(%ebp),%edx
  11968e:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  119691:	8b 00                	mov    (%eax),%eax
  119693:	8b 40 08             	mov    0x8(%eax),%eax
  119696:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  11969a:	0f b6 c0             	movzbl %al,%eax
  11969d:	83 e0 40             	and    $0x40,%eax
  1196a0:	89 02                	mov    %eax,(%edx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_TCP, TCP_NODELAY) = %s\n", s, (*(int*)optval)?"on":"off") );
      break;
  1196a2:	eb 13                	jmp    1196b7 <lwip_getsockopt+0x2e7>
    case TCP_KEEPALIVE:
      *(int*)optval = sock->conn->pcb.tcp->keepalive;
  1196a4:	8b 55 14             	mov    0x14(%ebp),%edx
  1196a7:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1196aa:	8b 00                	mov    (%eax),%eax
  1196ac:	8b 40 08             	mov    0x8(%eax),%eax
  1196af:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
  1196b5:	89 02                	mov    %eax,(%edx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, TCP_KEEPALIVE) = %d\n", s, *(int *)optval));
      break;
    }  /* switch */
    break;
  }


  sock_set_errno(sock, err);
  1196b7:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  1196ba:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1196bd:	89 42 10             	mov    %eax,0x10(%edx)
  return err ? -1 : 0;
  1196c0:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  1196c4:	74 09                	je     1196cf <lwip_getsockopt+0x2ff>
  1196c6:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  1196cd:	eb 07                	jmp    1196d6 <lwip_getsockopt+0x306>
  1196cf:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  1196d6:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  1196d9:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
  1196dc:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
}
  1196df:	c9                   	leave  
  1196e0:	c3                   	ret    
  1196e1:	eb 0d                	jmp    1196f0 <lwip_setsockopt>
  1196e3:	90                   	nop    
  1196e4:	90                   	nop    
  1196e5:	90                   	nop    
  1196e6:	90                   	nop    
  1196e7:	90                   	nop    
  1196e8:	90                   	nop    
  1196e9:	90                   	nop    
  1196ea:	90                   	nop    
  1196eb:	90                   	nop    
  1196ec:	90                   	nop    
  1196ed:	90                   	nop    
  1196ee:	90                   	nop    
  1196ef:	90                   	nop    

001196f0 <lwip_setsockopt>:

int lwip_setsockopt (int s, int level, int optname, const void *optval, socklen_t optlen)
{
  1196f0:	55                   	push   %ebp
  1196f1:	89 e5                	mov    %esp,%ebp
  1196f3:	83 ec 34             	sub    $0x34,%esp
  struct lwip_socket *sock = get_socket(s);
  1196f6:	8b 45 08             	mov    0x8(%ebp),%eax
  1196f9:	89 04 24             	mov    %eax,(%esp)
  1196fc:	e8 ef e7 ff ff       	call   117ef0 <get_socket>
  119701:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  int err = 0;
  119704:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)

  if(!sock) {
  11970b:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
  11970f:	75 0c                	jne    11971d <lwip_setsockopt+0x2d>
   	set_errno(EBADF);
    return -1;
  119711:	c7 45 e8 ff ff ff ff 	movl   $0xffffffff,0xffffffe8(%ebp)
  119718:	e9 7a 02 00 00       	jmp    119997 <lwip_setsockopt+0x2a7>
  }

  if( NULL == optval ) {
  11971d:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
  119721:	75 16                	jne    119739 <lwip_setsockopt+0x49>
    sock_set_errno( sock, EFAULT );
  119723:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  119726:	c7 40 10 0e 00 00 00 	movl   $0xe,0x10(%eax)
    return -1;
  11972d:	c7 45 e8 ff ff ff ff 	movl   $0xffffffff,0xffffffe8(%ebp)
  119734:	e9 5e 02 00 00       	jmp    119997 <lwip_setsockopt+0x2a7>
  }


  /* Do length and type checks for the various options first, to keep it readable. */
  switch( level ) {
  119739:	8b 45 0c             	mov    0xc(%ebp),%eax
  11973c:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
  11973f:	83 7d e4 06          	cmpl   $0x6,0xffffffe4(%ebp)
  119743:	74 7e                	je     1197c3 <lwip_setsockopt+0xd3>
  119745:	81 7d e4 ff 0f 00 00 	cmpl   $0xfff,0xffffffe4(%ebp)
  11974c:	74 0b                	je     119759 <lwip_setsockopt+0x69>
  11974e:	83 7d e4 00          	cmpl   $0x0,0xffffffe4(%ebp)
  119752:	74 4a                	je     11979e <lwip_setsockopt+0xae>
  119754:	e9 a8 00 00 00       	jmp    119801 <lwip_setsockopt+0x111>

/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch(optname) {
  119759:	8b 45 10             	mov    0x10(%ebp),%eax
  11975c:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
  11975f:	83 7d e0 08          	cmpl   $0x8,0xffffffe0(%ebp)
  119763:	74 1f                	je     119784 <lwip_setsockopt+0x94>
  119765:	83 7d e0 08          	cmpl   $0x8,0xffffffe0(%ebp)
  119769:	7f 08                	jg     119773 <lwip_setsockopt+0x83>
  11976b:	83 7d e0 04          	cmpl   $0x4,0xffffffe0(%ebp)
  11976f:	74 13                	je     119784 <lwip_setsockopt+0x94>
  119771:	eb 22                	jmp    119795 <lwip_setsockopt+0xa5>
  119773:	83 7d e0 20          	cmpl   $0x20,0xffffffe0(%ebp)
  119777:	74 0b                	je     119784 <lwip_setsockopt+0x94>
  119779:	81 7d e0 00 02 00 00 	cmpl   $0x200,0xffffffe0(%ebp)
  119780:	74 02                	je     119784 <lwip_setsockopt+0x94>
  119782:	eb 11                	jmp    119795 <lwip_setsockopt+0xa5>

    case SO_BROADCAST:
    /* UNIMPL case SO_DEBUG: */
    /* UNIMPL case SO_DONTROUTE: */
    case SO_KEEPALIVE:
    /* UNIMPL case SO_OOBINLINE: */
    /* UNIMPL case SO_RCVBUF: */
    /* UNIMPL case SO_SNDBUF: */
    /* UNIMPL case SO_RCVLOWAT: */
    /* UNIMPL case SO_SNDLOWAT: */
#if SO_REUSE
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /* UNIMPL case SO_USELOOPBACK: */
      if( optlen < sizeof(int) ) {
  119784:	8b 45 18             	mov    0x18(%ebp),%eax
  119787:	83 f8 03             	cmp    $0x3,%eax
  11978a:	77 7c                	ja     119808 <lwip_setsockopt+0x118>
        err = EINVAL;
  11978c:	c7 45 fc 16 00 00 00 	movl   $0x16,0xfffffffc(%ebp)
      }
      break;
  119793:	eb 73                	jmp    119808 <lwip_setsockopt+0x118>
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, SOL_SOCKET, UNIMPL: optname=0x%x, ..)\n", s, optname));
      err = ENOPROTOOPT;
  119795:	c7 45 fc 5c 00 00 00 	movl   $0x5c,0xfffffffc(%ebp)
    }  /* switch */
    break;
  11979c:	eb 6a                	jmp    119808 <lwip_setsockopt+0x118>

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch(optname) {
  11979e:	8b 45 10             	mov    0x10(%ebp),%eax
  1197a1:	83 e8 01             	sub    $0x1,%eax
  1197a4:	83 f8 01             	cmp    $0x1,%eax
  1197a7:	77 11                	ja     1197ba <lwip_setsockopt+0xca>
    /* UNIMPL case IP_HDRINCL: */
    /* UNIMPL case IP_RCVDSTADDR: */
    /* UNIMPL case IP_RCVIF: */
    case IP_TTL:
    case IP_TOS:
      if( optlen < sizeof(int) ) {
  1197a9:	8b 45 18             	mov    0x18(%ebp),%eax
  1197ac:	83 f8 03             	cmp    $0x3,%eax
  1197af:	77 57                	ja     119808 <lwip_setsockopt+0x118>
        err = EINVAL;
  1197b1:	c7 45 fc 16 00 00 00 	movl   $0x16,0xfffffffc(%ebp)
      }
        break;
  1197b8:	eb 4e                	jmp    119808 <lwip_setsockopt+0x118>
      default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, UNIMPL: optname=0x%x, ..)\n", s, optname));
      err = ENOPROTOOPT;
  1197ba:	c7 45 fc 5c 00 00 00 	movl   $0x5c,0xfffffffc(%ebp)
    }  /* switch */
    break;
  1197c1:	eb 45                	jmp    119808 <lwip_setsockopt+0x118>

/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    if( optlen < sizeof(int) ) {
  1197c3:	8b 45 18             	mov    0x18(%ebp),%eax
  1197c6:	83 f8 03             	cmp    $0x3,%eax
  1197c9:	77 09                	ja     1197d4 <lwip_setsockopt+0xe4>
      err = EINVAL;
  1197cb:	c7 45 fc 16 00 00 00 	movl   $0x16,0xfffffffc(%ebp)
        break;
  1197d2:	eb 34                	jmp    119808 <lwip_setsockopt+0x118>
    }

    /* If this is no TCP socket, ignore any options. */
    if ( sock->conn->type != NETCONN_TCP ) return 0;
  1197d4:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1197d7:	8b 00                	mov    (%eax),%eax
  1197d9:	8b 00                	mov    (%eax),%eax
  1197db:	85 c0                	test   %eax,%eax
  1197dd:	74 0c                	je     1197eb <lwip_setsockopt+0xfb>
  1197df:	c7 45 e8 00 00 00 00 	movl   $0x0,0xffffffe8(%ebp)
  1197e6:	e9 ac 01 00 00       	jmp    119997 <lwip_setsockopt+0x2a7>

    switch( optname ) {
  1197eb:	8b 45 10             	mov    0x10(%ebp),%eax
  1197ee:	83 e8 01             	sub    $0x1,%eax
  1197f1:	83 f8 01             	cmp    $0x1,%eax
  1197f4:	77 02                	ja     1197f8 <lwip_setsockopt+0x108>
    case TCP_NODELAY:
    case TCP_KEEPALIVE:
      break;
  1197f6:	eb 10                	jmp    119808 <lwip_setsockopt+0x118>

    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, UNIMPL: optname=0x%x, ..)\n", s, optname));
      err = ENOPROTOOPT;
  1197f8:	c7 45 fc 5c 00 00 00 	movl   $0x5c,0xfffffffc(%ebp)
    }  /* switch */
    break;
  1197ff:	eb 07                	jmp    119808 <lwip_setsockopt+0x118>

/* UNDEFINED LEVEL */      
  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, level=0x%x, UNIMPL: optname=0x%x, ..)\n", s, level, optname));
    err = ENOPROTOOPT;
  119801:	c7 45 fc 5c 00 00 00 	movl   $0x5c,0xfffffffc(%ebp)
  }  /* switch */


  if( 0 != err ) {
  119808:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  11980c:	74 15                	je     119823 <lwip_setsockopt+0x133>
    sock_set_errno(sock, err);
  11980e:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  119811:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  119814:	89 42 10             	mov    %eax,0x10(%edx)
    return -1;
  119817:	c7 45 e8 ff ff ff ff 	movl   $0xffffffff,0xffffffe8(%ebp)
  11981e:	e9 74 01 00 00       	jmp    119997 <lwip_setsockopt+0x2a7>
  }



  /* Now do the actual option processing */

  switch(level) {
  119823:	8b 45 0c             	mov    0xc(%ebp),%eax
  119826:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
  119829:	83 7d dc 06          	cmpl   $0x6,0xffffffdc(%ebp)
  11982d:	0f 84 d7 00 00 00    	je     11990a <lwip_setsockopt+0x21a>
  119833:	81 7d dc ff 0f 00 00 	cmpl   $0xfff,0xffffffdc(%ebp)
  11983a:	74 0f                	je     11984b <lwip_setsockopt+0x15b>
  11983c:	83 7d dc 00          	cmpl   $0x0,0xffffffdc(%ebp)
  119840:	0f 84 89 00 00 00    	je     1198cf <lwip_setsockopt+0x1df>
  119846:	e9 27 01 00 00       	jmp    119972 <lwip_setsockopt+0x282>

/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch(optname) {
  11984b:	8b 45 10             	mov    0x10(%ebp),%eax
  11984e:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
  119851:	83 7d d8 08          	cmpl   $0x8,0xffffffd8(%ebp)
  119855:	74 25                	je     11987c <lwip_setsockopt+0x18c>
  119857:	83 7d d8 08          	cmpl   $0x8,0xffffffd8(%ebp)
  11985b:	7f 0b                	jg     119868 <lwip_setsockopt+0x178>
  11985d:	83 7d d8 04          	cmpl   $0x4,0xffffffd8(%ebp)
  119861:	74 19                	je     11987c <lwip_setsockopt+0x18c>
  119863:	e9 0a 01 00 00       	jmp    119972 <lwip_setsockopt+0x282>
  119868:	83 7d d8 20          	cmpl   $0x20,0xffffffd8(%ebp)
  11986c:	74 0e                	je     11987c <lwip_setsockopt+0x18c>
  11986e:	81 7d d8 00 02 00 00 	cmpl   $0x200,0xffffffd8(%ebp)
  119875:	74 05                	je     11987c <lwip_setsockopt+0x18c>
  119877:	e9 f6 00 00 00       	jmp    119972 <lwip_setsockopt+0x282>

    /* The option flags */
    case SO_BROADCAST:
    /* UNIMPL case SO_DEBUG: */
    /* UNIMPL case SO_DONTROUTE: */
    case SO_KEEPALIVE:
    /* UNIMPL case SO_OOBINCLUDE: */
#if SO_REUSE
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /* UNIMPL case SO_USELOOPBACK: */
      if ( *(int*)optval ) {
  11987c:	8b 45 14             	mov    0x14(%ebp),%eax
  11987f:	8b 00                	mov    (%eax),%eax
  119881:	85 c0                	test   %eax,%eax
  119883:	74 24                	je     1198a9 <lwip_setsockopt+0x1b9>
        sock->conn->pcb.tcp->so_options |= optname;
  119885:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  119888:	8b 00                	mov    (%eax),%eax
  11988a:	8b 48 08             	mov    0x8(%eax),%ecx
  11988d:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  119890:	8b 00                	mov    (%eax),%eax
  119892:	8b 40 08             	mov    0x8(%eax),%eax
  119895:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  119899:	89 c2                	mov    %eax,%edx
  11989b:	8b 45 10             	mov    0x10(%ebp),%eax
  11989e:	09 d0                	or     %edx,%eax
  1198a0:	66 89 41 08          	mov    %ax,0x8(%ecx)
  1198a4:	e9 c9 00 00 00       	jmp    119972 <lwip_setsockopt+0x282>
      } else {
        sock->conn->pcb.tcp->so_options &= ~optname;
  1198a9:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1198ac:	8b 00                	mov    (%eax),%eax
  1198ae:	8b 48 08             	mov    0x8(%eax),%ecx
  1198b1:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1198b4:	8b 00                	mov    (%eax),%eax
  1198b6:	8b 40 08             	mov    0x8(%eax),%eax
  1198b9:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  1198bd:	89 c2                	mov    %eax,%edx
  1198bf:	8b 45 10             	mov    0x10(%ebp),%eax
  1198c2:	f7 d0                	not    %eax
  1198c4:	21 d0                	and    %edx,%eax
  1198c6:	66 89 41 08          	mov    %ax,0x8(%ecx)
      }
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, SOL_SOCKET, optname=0x%x, ..) -> %s\n", s, optname, (*(int*)optval?"on":"off")));
      break;
    }  /* switch */
    break;
  1198ca:	e9 a3 00 00 00       	jmp    119972 <lwip_setsockopt+0x282>

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch( optname ) {
  1198cf:	8b 45 10             	mov    0x10(%ebp),%eax
  1198d2:	89 45 d4             	mov    %eax,0xffffffd4(%ebp)
  1198d5:	83 7d d4 01          	cmpl   $0x1,0xffffffd4(%ebp)
  1198d9:	74 1d                	je     1198f8 <lwip_setsockopt+0x208>
  1198db:	83 7d d4 02          	cmpl   $0x2,0xffffffd4(%ebp)
  1198df:	74 05                	je     1198e6 <lwip_setsockopt+0x1f6>
  1198e1:	e9 8c 00 00 00       	jmp    119972 <lwip_setsockopt+0x282>
    case IP_TTL:
      sock->conn->pcb.tcp->ttl = (u8_t)(*(int*)optval);
  1198e6:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1198e9:	8b 00                	mov    (%eax),%eax
  1198eb:	8b 50 08             	mov    0x8(%eax),%edx
  1198ee:	8b 45 14             	mov    0x14(%ebp),%eax
  1198f1:	8b 00                	mov    (%eax),%eax
  1198f3:	88 42 0b             	mov    %al,0xb(%edx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, IP_TTL, ..) -> %u\n", s, sock->conn->pcb.tcp->ttl));
      break;
  1198f6:	eb 7a                	jmp    119972 <lwip_setsockopt+0x282>
    case IP_TOS:
      sock->conn->pcb.tcp->tos = (u8_t)(*(int*)optval);
  1198f8:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  1198fb:	8b 00                	mov    (%eax),%eax
  1198fd:	8b 50 08             	mov    0x8(%eax),%edx
  119900:	8b 45 14             	mov    0x14(%ebp),%eax
  119903:	8b 00                	mov    (%eax),%eax
  119905:	88 42 0a             	mov    %al,0xa(%edx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, IP_TOS, ..)-> %u\n", s, sock->conn->pcb.tcp->tos));
      break;
    }  /* switch */
    break;
  119908:	eb 68                	jmp    119972 <lwip_setsockopt+0x282>

/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    switch( optname ) {
  11990a:	8b 45 10             	mov    0x10(%ebp),%eax
  11990d:	89 45 d0             	mov    %eax,0xffffffd0(%ebp)
  119910:	83 7d d0 01          	cmpl   $0x1,0xffffffd0(%ebp)
  119914:	74 08                	je     11991e <lwip_setsockopt+0x22e>
  119916:	83 7d d0 02          	cmpl   $0x2,0xffffffd0(%ebp)
  11991a:	74 43                	je     11995f <lwip_setsockopt+0x26f>
  11991c:	eb 54                	jmp    119972 <lwip_setsockopt+0x282>
    case TCP_NODELAY:
      if ( *(int*)optval ) {
  11991e:	8b 45 14             	mov    0x14(%ebp),%eax
  119921:	8b 00                	mov    (%eax),%eax
  119923:	85 c0                	test   %eax,%eax
  119925:	74 1c                	je     119943 <lwip_setsockopt+0x253>
        sock->conn->pcb.tcp->flags |= TF_NODELAY;
  119927:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  11992a:	8b 00                	mov    (%eax),%eax
  11992c:	8b 50 08             	mov    0x8(%eax),%edx
  11992f:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  119932:	8b 00                	mov    (%eax),%eax
  119934:	8b 40 08             	mov    0x8(%eax),%eax
  119937:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  11993b:	83 c8 40             	or     $0x40,%eax
  11993e:	88 42 20             	mov    %al,0x20(%edx)
  119941:	eb 2f                	jmp    119972 <lwip_setsockopt+0x282>
      } else {
        sock->conn->pcb.tcp->flags &= ~TF_NODELAY;
  119943:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  119946:	8b 00                	mov    (%eax),%eax
  119948:	8b 50 08             	mov    0x8(%eax),%edx
  11994b:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  11994e:	8b 00                	mov    (%eax),%eax
  119950:	8b 40 08             	mov    0x8(%eax),%eax
  119953:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  119957:	83 e0 bf             	and    $0xffffffbf,%eax
  11995a:	88 42 20             	mov    %al,0x20(%edx)
      }
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_NODELAY) -> %s\n", s, (*(int *)optval)?"on":"off") );
      break;
  11995d:	eb 13                	jmp    119972 <lwip_setsockopt+0x282>
    case TCP_KEEPALIVE:
      sock->conn->pcb.tcp->keepalive = (u32_t)(*(int*)optval);
  11995f:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  119962:	8b 00                	mov    (%eax),%eax
  119964:	8b 50 08             	mov    0x8(%eax),%edx
  119967:	8b 45 14             	mov    0x14(%ebp),%eax
  11996a:	8b 00                	mov    (%eax),%eax
  11996c:	89 82 94 00 00 00    	mov    %eax,0x94(%edx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_KEEPALIVE) -> %u\n", s, sock->conn->pcb.tcp->keepalive));
      break;
    }  /* switch */
    break;
  }  /* switch */

  sock_set_errno(sock, err);
  119972:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
  119975:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  119978:	89 42 10             	mov    %eax,0x10(%edx)
  return err ? -1 : 0;
  11997b:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  11997f:	74 09                	je     11998a <lwip_setsockopt+0x29a>
  119981:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  119988:	eb 07                	jmp    119991 <lwip_setsockopt+0x2a1>
  11998a:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  119991:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  119994:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
  119997:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
}
  11999a:	c9                   	leave  
  11999b:	c3                   	ret    
  11999c:	8d 74 26 00          	lea    0x0(%esi),%esi

001199a0 <lwip_ioctl>:

int lwip_ioctl(int s, long cmd, void *argp)
{
  1199a0:	55                   	push   %ebp
  1199a1:	89 e5                	mov    %esp,%ebp
  1199a3:	83 ec 1c             	sub    $0x1c,%esp
  struct lwip_socket *sock = get_socket(s);
  1199a6:	8b 45 08             	mov    0x8(%ebp),%eax
  1199a9:	89 04 24             	mov    %eax,(%esp)
  1199ac:	e8 3f e5 ff ff       	call   117ef0 <get_socket>
  1199b1:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)

  if(!sock) {
  1199b4:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  1199b8:	75 0c                	jne    1199c6 <lwip_ioctl+0x26>
   	set_errno(EBADF);
    return -1;
  1199ba:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  1199c1:	e9 b3 00 00 00       	jmp    119a79 <lwip_ioctl+0xd9>
  }

  switch (cmd) {
  1199c6:	8b 45 0c             	mov    0xc(%ebp),%eax
  1199c9:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
  1199cc:	81 7d e8 7e 66 04 80 	cmpl   $0x8004667e,0xffffffe8(%ebp)
  1199d3:	74 49                	je     119a1e <lwip_ioctl+0x7e>
  1199d5:	81 7d e8 7f 66 04 40 	cmpl   $0x4004667f,0xffffffe8(%ebp)
  1199dc:	74 05                	je     1199e3 <lwip_ioctl+0x43>
  1199de:	e9 85 00 00 00       	jmp    119a68 <lwip_ioctl+0xc8>
  case FIONREAD:
    if (!argp) {
  1199e3:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  1199e7:	75 13                	jne    1199fc <lwip_ioctl+0x5c>
      sock_set_errno(sock, EINVAL);
  1199e9:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  1199ec:	c7 40 10 16 00 00 00 	movl   $0x16,0x10(%eax)
      return -1;
  1199f3:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  1199fa:	eb 7d                	jmp    119a79 <lwip_ioctl+0xd9>
    }

    *((u16_t*)argp) = sock->conn->recv_avail;
  1199fc:	8b 55 10             	mov    0x10(%ebp),%edx
  1199ff:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  119a02:	8b 00                	mov    (%eax),%eax
  119a04:	0f b7 40 24          	movzwl 0x24(%eax),%eax
  119a08:	66 89 02             	mov    %ax,(%edx)

    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONREAD, %p) = %u\n", s, argp, *((u16_t*)argp)));
    sock_set_errno(sock, 0);
  119a0b:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  119a0e:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
    return 0;
  119a15:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  119a1c:	eb 5b                	jmp    119a79 <lwip_ioctl+0xd9>

  case FIONBIO:
    if (argp && *(u32_t*)argp)
  119a1e:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  119a22:	74 1e                	je     119a42 <lwip_ioctl+0xa2>
  119a24:	8b 45 10             	mov    0x10(%ebp),%eax
  119a27:	8b 00                	mov    (%eax),%eax
  119a29:	85 c0                	test   %eax,%eax
  119a2b:	74 15                	je     119a42 <lwip_ioctl+0xa2>
      sock->flags |= O_NONBLOCK;
  119a2d:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  119a30:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
  119a34:	89 c2                	mov    %eax,%edx
  119a36:	80 ce 08             	or     $0x8,%dh
  119a39:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  119a3c:	66 89 50 0e          	mov    %dx,0xe(%eax)
  119a40:	eb 13                	jmp    119a55 <lwip_ioctl+0xb5>
    else
      sock->flags &= ~O_NONBLOCK;
  119a42:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  119a45:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
  119a49:	89 c2                	mov    %eax,%edx
  119a4b:	80 e6 f7             	and    $0xf7,%dh
  119a4e:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  119a51:	66 89 50 0e          	mov    %dx,0xe(%eax)
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONBIO, %d)\n", s, !!(sock->flags & O_NONBLOCK)));
    sock_set_errno(sock, 0);
  119a55:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  119a58:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
    return 0;
  119a5f:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  119a66:	eb 11                	jmp    119a79 <lwip_ioctl+0xd9>

  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, UNIMPL: 0x%lx, %p)\n", s, cmd, argp));
    sock_set_errno(sock, ENOSYS); /* not yet implemented */
  119a68:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  119a6b:	c7 40 10 26 00 00 00 	movl   $0x26,0x10(%eax)
    return -1;
  119a72:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  119a79:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  }
}
  119a7c:	c9                   	leave  
  119a7d:	c3                   	ret    
  119a7e:	90                   	nop    
  119a7f:	90                   	nop    

00119a80 <tcpip_tcp_timer>:


static void
tcpip_tcp_timer(void *arg)
{
  119a80:	55                   	push   %ebp
  119a81:	89 e5                	mov    %esp,%ebp
  119a83:	83 ec 18             	sub    $0x18,%esp
  (void)arg;

  tcp_tmr();
  119a86:	e8 75 67 ff ff       	call   110200 <tcp_tmr>
  if (tcp_active_pcbs || tcp_tw_pcbs) {
  119a8b:	a1 54 16 14 00       	mov    0x141654,%eax
  119a90:	85 c0                	test   %eax,%eax
  119a92:	75 09                	jne    119a9d <tcpip_tcp_timer+0x1d>
  119a94:	a1 64 16 14 00       	mov    0x141664,%eax
  119a99:	85 c0                	test   %eax,%eax
  119a9b:	74 1e                	je     119abb <tcpip_tcp_timer+0x3b>
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
  119a9d:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  119aa4:	00 
  119aa5:	c7 44 24 04 80 9a 11 	movl   $0x119a80,0x4(%esp)
  119aac:	00 
  119aad:	c7 04 24 fa 00 00 00 	movl   $0xfa,(%esp)
  119ab4:	e8 47 64 ff ff       	call   10ff00 <sys_timeout>
  119ab9:	eb 0a                	jmp    119ac5 <tcpip_tcp_timer+0x45>
  } else {
  tcpip_tcp_timer_active = 0;
  119abb:	c7 05 b4 99 13 00 00 	movl   $0x0,0x1399b4
  119ac2:	00 00 00 
  }
}
  119ac5:	c9                   	leave  
  119ac6:	c3                   	ret    
  119ac7:	89 f6                	mov    %esi,%esi
  119ac9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00119ad0 <tcp_timer_needed>:

void
tcp_timer_needed(void)
{
  119ad0:	55                   	push   %ebp
  119ad1:	89 e5                	mov    %esp,%ebp
  119ad3:	83 ec 18             	sub    $0x18,%esp
  if (!tcpip_tcp_timer_active && (tcp_active_pcbs || tcp_tw_pcbs)) {
  119ad6:	a1 b4 99 13 00       	mov    0x1399b4,%eax
  119adb:	85 c0                	test   %eax,%eax
  119add:	75 38                	jne    119b17 <tcp_timer_needed+0x47>
  119adf:	a1 54 16 14 00       	mov    0x141654,%eax
  119ae4:	85 c0                	test   %eax,%eax
  119ae6:	75 09                	jne    119af1 <tcp_timer_needed+0x21>
  119ae8:	a1 64 16 14 00       	mov    0x141664,%eax
  119aed:	85 c0                	test   %eax,%eax
  119aef:	74 26                	je     119b17 <tcp_timer_needed+0x47>
  tcpip_tcp_timer_active = 1;
  119af1:	c7 05 b4 99 13 00 01 	movl   $0x1,0x1399b4
  119af8:	00 00 00 
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
  119afb:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  119b02:	00 
  119b03:	c7 44 24 04 80 9a 11 	movl   $0x119a80,0x4(%esp)
  119b0a:	00 
  119b0b:	c7 04 24 fa 00 00 00 	movl   $0xfa,(%esp)
  119b12:	e8 e9 63 ff ff       	call   10ff00 <sys_timeout>
  }
}
  119b17:	c9                   	leave  
  119b18:	c3                   	ret    
  119b19:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

00119b20 <tcpip_thread>:
#endif /* LWIP_TCP */

static void
tcpip_thread(void *arg)
{
  119b20:	55                   	push   %ebp
  119b21:	89 e5                	mov    %esp,%ebp
  119b23:	83 ec 28             	sub    $0x28,%esp
  struct tcpip_msg *msg;

  (void)arg;

  ip_init();
  119b26:	e8 c5 2f ff ff       	call   10caf0 <ip_init>
#if LWIP_UDP  
  udp_init();
  119b2b:	e8 b0 b0 ff ff       	call   114be0 <udp_init>
#endif
#if LWIP_TCP
  tcp_init();
  119b30:	e8 8b 66 ff ff       	call   1101c0 <tcp_init>
#endif
  if (tcpip_init_done != NULL) {
  119b35:	a1 b0 99 13 00       	mov    0x1399b0,%eax
  119b3a:	85 c0                	test   %eax,%eax
  119b3c:	74 10                	je     119b4e <tcpip_thread+0x2e>
    tcpip_init_done(tcpip_init_done_arg);
  119b3e:	8b 15 b0 99 13 00    	mov    0x1399b0,%edx
  119b44:	a1 b8 99 13 00       	mov    0x1399b8,%eax
  119b49:	89 04 24             	mov    %eax,(%esp)
  119b4c:	ff d2                	call   *%edx
  }

  while (1) {                          /* MAIN Loop */
    sys_mbox_fetch(mbox, (void *)&msg);
  119b4e:	8d 45 fc             	lea    0xfffffffc(%ebp),%eax
  119b51:	8b 15 bc 99 13 00    	mov    0x1399bc,%edx
  119b57:	89 44 24 04          	mov    %eax,0x4(%esp)
  119b5b:	89 14 24             	mov    %edx,(%esp)
  119b5e:	e8 ad 61 ff ff       	call   10fd10 <sys_mbox_fetch>
    switch (msg->type) {
  119b63:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  119b66:	8b 00                	mov    (%eax),%eax
  119b68:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  119b6b:	83 7d ec 01          	cmpl   $0x1,0xffffffec(%ebp)
  119b6f:	74 1e                	je     119b8f <tcpip_thread+0x6f>
  119b71:	83 7d ec 01          	cmpl   $0x1,0xffffffec(%ebp)
  119b75:	72 08                	jb     119b7f <tcpip_thread+0x5f>
  119b77:	83 7d ec 02          	cmpl   $0x2,0xffffffec(%ebp)
  119b7b:	74 2c                	je     119ba9 <tcpip_thread+0x89>
  119b7d:	eb 3b                	jmp    119bba <tcpip_thread+0x9a>
    case TCPIP_MSG_API:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: API message %p\n", (void *)msg));
      api_msg_input(msg->msg.apimsg);
  119b7f:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  119b82:	8b 40 08             	mov    0x8(%eax),%eax
  119b85:	89 04 24             	mov    %eax,(%esp)
  119b88:	e8 03 e3 ff ff       	call   117e90 <api_msg_input>
      break;
  119b8d:	eb 2b                	jmp    119bba <tcpip_thread+0x9a>
    case TCPIP_MSG_INPUT:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: IP packet %p\n", (void *)msg));
      ip_input(msg->msg.inp.p, msg->msg.inp.netif);
  119b8f:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  119b92:	8b 50 0c             	mov    0xc(%eax),%edx
  119b95:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  119b98:	8b 40 08             	mov    0x8(%eax),%eax
  119b9b:	89 54 24 04          	mov    %edx,0x4(%esp)
  119b9f:	89 04 24             	mov    %eax,(%esp)
  119ba2:	e8 b9 2f ff ff       	call   10cb60 <ip_input>
      break;
  119ba7:	eb 11                	jmp    119bba <tcpip_thread+0x9a>
    case TCPIP_MSG_CALLBACK:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: CALLBACK %p\n", (void *)msg));
      msg->msg.cb.f(msg->msg.cb.ctx);
  119ba9:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  119bac:	8b 50 08             	mov    0x8(%eax),%edx
  119baf:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  119bb2:	8b 40 0c             	mov    0xc(%eax),%eax
  119bb5:	89 04 24             	mov    %eax,(%esp)
  119bb8:	ff d2                	call   *%edx
      break;
    default:
      break;
    }
    memp_free(MEMP_TCPIP_MSG, msg);
  119bba:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  119bbd:	89 44 24 04          	mov    %eax,0x4(%esp)
  119bc1:	c7 04 24 09 00 00 00 	movl   $0x9,(%esp)
  119bc8:	e8 f3 4e ff ff       	call   10eac0 <memp_free>
  }
  119bcd:	e9 7c ff ff ff       	jmp    119b4e <tcpip_thread+0x2e>
  119bd2:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi
  119bd9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00119be0 <tcpip_input>:
}

err_t
tcpip_input(struct pbuf *p, struct netif *inp)
{
  119be0:	55                   	push   %ebp
  119be1:	89 e5                	mov    %esp,%ebp
  119be3:	83 ec 28             	sub    $0x28,%esp
  struct tcpip_msg *msg;
  
  msg = memp_malloc(MEMP_TCPIP_MSG);
  119be6:	c7 04 24 09 00 00 00 	movl   $0x9,(%esp)
  119bed:	e8 de 4d ff ff       	call   10e9d0 <memp_malloc>
  119bf2:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  if (msg == NULL) {
  119bf5:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  119bf9:	75 14                	jne    119c0f <tcpip_input+0x2f>
    pbuf_free(p);    
  119bfb:	8b 45 08             	mov    0x8(%ebp),%eax
  119bfe:	89 04 24             	mov    %eax,(%esp)
  119c01:	e8 ba 58 ff ff       	call   10f4c0 <pbuf_free>
    return ERR_MEM;  
  119c06:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  119c0d:	eb 37                	jmp    119c46 <tcpip_input+0x66>
  }
  
  msg->type = TCPIP_MSG_INPUT;
  119c0f:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  119c12:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
  msg->msg.inp.p = p;
  119c18:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  119c1b:	8b 45 08             	mov    0x8(%ebp),%eax
  119c1e:	89 42 08             	mov    %eax,0x8(%edx)
  msg->msg.inp.netif = inp;
  119c21:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  119c24:	8b 45 0c             	mov    0xc(%ebp),%eax
  119c27:	89 42 0c             	mov    %eax,0xc(%edx)
  sys_mbox_post(mbox, msg);
  119c2a:	8b 15 bc 99 13 00    	mov    0x1399bc,%edx
  119c30:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  119c33:	89 44 24 04          	mov    %eax,0x4(%esp)
  119c37:	89 14 24             	mov    %edx,(%esp)
  119c3a:	e8 51 03 00 00       	call   119f90 <sys_mbox_post>
  return ERR_OK;
  119c3f:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  119c46:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  119c49:	c9                   	leave  
  119c4a:	c3                   	ret    
  119c4b:	90                   	nop    
  119c4c:	8d 74 26 00          	lea    0x0(%esi),%esi

00119c50 <tcpip_callback>:

err_t
tcpip_callback(void (*f)(void *ctx), void *ctx)
{
  119c50:	55                   	push   %ebp
  119c51:	89 e5                	mov    %esp,%ebp
  119c53:	83 ec 28             	sub    $0x28,%esp
  struct tcpip_msg *msg;
  
  msg = memp_malloc(MEMP_TCPIP_MSG);
  119c56:	c7 04 24 09 00 00 00 	movl   $0x9,(%esp)
  119c5d:	e8 6e 4d ff ff       	call   10e9d0 <memp_malloc>
  119c62:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  if (msg == NULL) {
  119c65:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  119c69:	75 09                	jne    119c74 <tcpip_callback+0x24>
    return ERR_MEM;  
  119c6b:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  119c72:	eb 37                	jmp    119cab <tcpip_callback+0x5b>
  }
  
  msg->type = TCPIP_MSG_CALLBACK;
  119c74:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  119c77:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
  msg->msg.cb.f = f;
  119c7d:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  119c80:	8b 45 08             	mov    0x8(%ebp),%eax
  119c83:	89 42 08             	mov    %eax,0x8(%edx)
  msg->msg.cb.ctx = ctx;
  119c86:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  119c89:	8b 45 0c             	mov    0xc(%ebp),%eax
  119c8c:	89 42 0c             	mov    %eax,0xc(%edx)
  sys_mbox_post(mbox, msg);
  119c8f:	8b 15 bc 99 13 00    	mov    0x1399bc,%edx
  119c95:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  119c98:	89 44 24 04          	mov    %eax,0x4(%esp)
  119c9c:	89 14 24             	mov    %edx,(%esp)
  119c9f:	e8 ec 02 00 00       	call   119f90 <sys_mbox_post>
  return ERR_OK;
  119ca4:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  119cab:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  119cae:	c9                   	leave  
  119caf:	c3                   	ret    

00119cb0 <tcpip_apimsg>:

void
tcpip_apimsg(struct api_msg *apimsg)
{
  119cb0:	55                   	push   %ebp
  119cb1:	89 e5                	mov    %esp,%ebp
  119cb3:	83 ec 18             	sub    $0x18,%esp
  struct tcpip_msg *msg;
  msg = memp_malloc(MEMP_TCPIP_MSG);
  119cb6:	c7 04 24 09 00 00 00 	movl   $0x9,(%esp)
  119cbd:	e8 0e 4d ff ff       	call   10e9d0 <memp_malloc>
  119cc2:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  if (msg == NULL) {
  119cc5:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  119cc9:	75 15                	jne    119ce0 <tcpip_apimsg+0x30>
    memp_free(MEMP_API_MSG, apimsg);
  119ccb:	8b 45 08             	mov    0x8(%ebp),%eax
  119cce:	89 44 24 04          	mov    %eax,0x4(%esp)
  119cd2:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  119cd9:	e8 e2 4d ff ff       	call   10eac0 <memp_free>
    return;
  119cde:	eb 27                	jmp    119d07 <tcpip_apimsg+0x57>
  }
  msg->type = TCPIP_MSG_API;
  119ce0:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  119ce3:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  msg->msg.apimsg = apimsg;
  119ce9:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  119cec:	8b 45 08             	mov    0x8(%ebp),%eax
  119cef:	89 42 08             	mov    %eax,0x8(%edx)
  sys_mbox_post(mbox, msg);
  119cf2:	8b 15 bc 99 13 00    	mov    0x1399bc,%edx
  119cf8:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  119cfb:	89 44 24 04          	mov    %eax,0x4(%esp)
  119cff:	89 14 24             	mov    %edx,(%esp)
  119d02:	e8 89 02 00 00       	call   119f90 <sys_mbox_post>
}
  119d07:	c9                   	leave  
  119d08:	c3                   	ret    
  119d09:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

00119d10 <tcpip_init>:

void
tcpip_init(void (* initfunc)(void *), void *arg)
{
  119d10:	55                   	push   %ebp
  119d11:	89 e5                	mov    %esp,%ebp
  119d13:	83 ec 18             	sub    $0x18,%esp
  tcpip_init_done = initfunc;
  119d16:	8b 45 08             	mov    0x8(%ebp),%eax
  119d19:	a3 b0 99 13 00       	mov    %eax,0x1399b0
  tcpip_init_done_arg = arg;
  119d1e:	8b 45 0c             	mov    0xc(%ebp),%eax
  119d21:	a3 b8 99 13 00       	mov    %eax,0x1399b8
  mbox = sys_mbox_new();
  119d26:	e8 35 01 00 00       	call   119e60 <sys_mbox_new>
  119d2b:	a3 bc 99 13 00       	mov    %eax,0x1399bc
  sys_thread_new(tcpip_thread, NULL, TCPIP_THREAD_PRIO);
  119d30:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  119d37:	00 
  119d38:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  119d3f:	00 
  119d40:	c7 04 24 20 9b 11 00 	movl   $0x119b20,(%esp)
  119d47:	e8 f4 03 00 00       	call   11a140 <sys_thread_new>
}
  119d4c:	c9                   	leave  
  119d4d:	c3                   	ret    
  119d4e:	90                   	nop    
  119d4f:	90                   	nop    

00119d50 <sys_sem_new>:

struct sys_timeouts sys_touts;

sys_sem_t sys_sem_new(u8_t count)
{
  119d50:	55                   	push   %ebp
  119d51:	89 e5                	mov    %esp,%ebp
  119d53:	83 ec 28             	sub    $0x28,%esp
  119d56:	8b 45 08             	mov    0x8(%ebp),%eax
  119d59:	88 45 ec             	mov    %al,0xffffffec(%ebp)
    sys_sem_t sem = (sys_sem_t)kmalloc(sem_size());
  119d5c:	e8 4f fe fe ff       	call   109bb0 <sem_size>
  119d61:	89 04 24             	mov    %eax,(%esp)
  119d64:	e8 e7 97 fe ff       	call   103550 <kmalloc>
  119d69:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
    if (!sem)
  119d6c:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  119d70:	75 09                	jne    119d7b <sys_sem_new+0x2b>
        return SYS_SEM_NULL;
  119d72:	c7 45 e8 00 00 00 00 	movl   $0x0,0xffffffe8(%ebp)
  119d79:	eb 19                	jmp    119d94 <sys_sem_new+0x44>
    sem_init(sem, count);
  119d7b:	0f b6 45 ec          	movzbl 0xffffffec(%ebp),%eax
  119d7f:	89 44 24 04          	mov    %eax,0x4(%esp)
  119d83:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  119d86:	89 04 24             	mov    %eax,(%esp)
  119d89:	e8 c2 fb fe ff       	call   109950 <sem_init>
    return sem;
  119d8e:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  119d91:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
  119d94:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
}
  119d97:	c9                   	leave  
  119d98:	c3                   	ret    
  119d99:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

00119da0 <sys_sem_free>:

void sys_sem_free(sys_sem_t sem)
{
  119da0:	55                   	push   %ebp
  119da1:	89 e5                	mov    %esp,%ebp
  119da3:	83 ec 08             	sub    $0x8,%esp
    sem_destroy(sem);
  119da6:	8b 45 08             	mov    0x8(%ebp),%eax
  119da9:	89 04 24             	mov    %eax,(%esp)
  119dac:	e8 df fb fe ff       	call   109990 <sem_destroy>
    kmfree((char*)sem, sem_size());
  119db1:	e8 fa fd fe ff       	call   109bb0 <sem_size>
  119db6:	89 44 24 04          	mov    %eax,0x4(%esp)
  119dba:	8b 45 08             	mov    0x8(%ebp),%eax
  119dbd:	89 04 24             	mov    %eax,(%esp)
  119dc0:	e8 bb 97 fe ff       	call   103580 <kmfree>
}
  119dc5:	c9                   	leave  
  119dc6:	c3                   	ret    
  119dc7:	89 f6                	mov    %esi,%esi
  119dc9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00119dd0 <sys_sem_signal>:

void sys_sem_signal(sys_sem_t sem)
{
  119dd0:	55                   	push   %ebp
  119dd1:	89 e5                	mov    %esp,%ebp
  119dd3:	83 ec 08             	sub    $0x8,%esp
    sem_post(sem);
  119dd6:	8b 45 08             	mov    0x8(%ebp),%eax
  119dd9:	89 04 24             	mov    %eax,(%esp)
  119ddc:	e8 ef fb fe ff       	call   1099d0 <sem_post>
}
  119de1:	c9                   	leave  
  119de2:	c3                   	ret    
  119de3:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  119de9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00119df0 <sys_arch_sem_wait>:

u32_t sys_arch_sem_wait(sys_sem_t sem, u32_t timeout)
{
  119df0:	55                   	push   %ebp
  119df1:	89 e5                	mov    %esp,%ebp
  119df3:	83 ec 28             	sub    $0x28,%esp
    int s = millitime(), p;
  119df6:	e8 65 e1 fe ff       	call   107f60 <millitime>
  119dfb:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
    int ret;

    if (timeout == 0)
  119dfe:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  119e02:	75 14                	jne    119e18 <sys_arch_sem_wait+0x28>
    {
        sem_wait(sem);
  119e04:	8b 45 08             	mov    0x8(%ebp),%eax
  119e07:	89 04 24             	mov    %eax,(%esp)
  119e0a:	e8 11 fc fe ff       	call   109a20 <sem_wait>
        return 0; // What should I return?...
  119e0f:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  119e16:	eb 35                	jmp    119e4d <sys_arch_sem_wait+0x5d>
    }

    ret = sem_timedwait(sem, timeout);
  119e18:	8b 45 0c             	mov    0xc(%ebp),%eax
  119e1b:	89 44 24 04          	mov    %eax,0x4(%esp)
  119e1f:	8b 45 08             	mov    0x8(%ebp),%eax
  119e22:	89 04 24             	mov    %eax,(%esp)
  119e25:	e8 66 fc fe ff       	call   109a90 <sem_timedwait>
  119e2a:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
    
    p = millitime() - s;
  119e2d:	e8 2e e1 fe ff       	call   107f60 <millitime>
  119e32:	2b 45 f4             	sub    0xfffffff4(%ebp),%eax
  119e35:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
    if (ret == 0)
  119e38:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  119e3c:	75 08                	jne    119e46 <sys_arch_sem_wait+0x56>
        return p;
  119e3e:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  119e41:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  119e44:	eb 07                	jmp    119e4d <sys_arch_sem_wait+0x5d>
    else
        return SYS_ARCH_TIMEOUT;
  119e46:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  119e4d:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  119e50:	c9                   	leave  
  119e51:	c3                   	ret    
  119e52:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi
  119e59:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00119e60 <sys_mbox_new>:

#define NSLOTS 128

struct mbox {
    struct spinlock lock;
    sys_sem_t free, queued;
    int count, head, next;
    void *slots[NSLOTS];
};

sys_mbox_t sys_mbox_new(void)
{
  119e60:	55                   	push   %ebp
  119e61:	89 e5                	mov    %esp,%ebp
  119e63:	83 ec 28             	sub    $0x28,%esp
    sys_mbox_t mbox = (sys_mbox_t)kmalloc(sizeof(struct mbox));
  119e66:	c7 04 24 48 02 00 00 	movl   $0x248,(%esp)
  119e6d:	e8 de 96 fe ff       	call   103550 <kmalloc>
  119e72:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
    if (!mbox)
  119e75:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  119e79:	75 0c                	jne    119e87 <sys_mbox_new+0x27>
        return SYS_MBOX_NULL;
  119e7b:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  119e82:	e9 8d 00 00 00       	jmp    119f14 <sys_mbox_new+0xb4>
    initlock(&mbox->lock, "mbox");
  119e87:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  119e8a:	c7 44 24 04 58 b0 11 	movl   $0x11b058,0x4(%esp)
  119e91:	00 
  119e92:	89 04 24             	mov    %eax,(%esp)
  119e95:	e8 46 bc fe ff       	call   105ae0 <initlock>
    mbox->free = (sem_t *)kmalloc(sem_size());
  119e9a:	e8 11 fd fe ff       	call   109bb0 <sem_size>
  119e9f:	89 04 24             	mov    %eax,(%esp)
  119ea2:	e8 a9 96 fe ff       	call   103550 <kmalloc>
  119ea7:	89 c2                	mov    %eax,%edx
  119ea9:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  119eac:	89 50 34             	mov    %edx,0x34(%eax)
    mbox->queued = (sem_t *)kmalloc(sem_size());
  119eaf:	e8 fc fc fe ff       	call   109bb0 <sem_size>
  119eb4:	89 04 24             	mov    %eax,(%esp)
  119eb7:	e8 94 96 fe ff       	call   103550 <kmalloc>
  119ebc:	89 c2                	mov    %eax,%edx
  119ebe:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  119ec1:	89 50 38             	mov    %edx,0x38(%eax)
    sem_init(mbox->free, NSLOTS);
  119ec4:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  119ec7:	8b 40 34             	mov    0x34(%eax),%eax
  119eca:	c7 44 24 04 80 00 00 	movl   $0x80,0x4(%esp)
  119ed1:	00 
  119ed2:	89 04 24             	mov    %eax,(%esp)
  119ed5:	e8 76 fa fe ff       	call   109950 <sem_init>
    sem_init(mbox->queued, 0);
  119eda:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  119edd:	8b 40 38             	mov    0x38(%eax),%eax
  119ee0:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  119ee7:	00 
  119ee8:	89 04 24             	mov    %eax,(%esp)
  119eeb:	e8 60 fa fe ff       	call   109950 <sem_init>
    mbox->count = 0;
  119ef0:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  119ef3:	c7 40 3c 00 00 00 00 	movl   $0x0,0x3c(%eax)
    mbox->head = -1;
  119efa:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  119efd:	c7 40 40 ff ff ff ff 	movl   $0xffffffff,0x40(%eax)
    mbox->next = 0;
  119f04:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  119f07:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
    return mbox;
  119f0e:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  119f11:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  119f14:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
};
  119f17:	c9                   	leave  
  119f18:	c3                   	ret    
  119f19:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

00119f20 <sys_mbox_free>:

void sys_mbox_free(sys_mbox_t mbox)
{
  119f20:	55                   	push   %ebp
  119f21:	89 e5                	mov    %esp,%ebp
  119f23:	83 ec 08             	sub    $0x8,%esp
    acquire(&mbox->lock);
  119f26:	8b 45 08             	mov    0x8(%ebp),%eax
  119f29:	89 04 24             	mov    %eax,(%esp)
  119f2c:	e8 df bb fe ff       	call   105b10 <acquire>
    sem_destroy(mbox->free);
  119f31:	8b 45 08             	mov    0x8(%ebp),%eax
  119f34:	8b 40 34             	mov    0x34(%eax),%eax
  119f37:	89 04 24             	mov    %eax,(%esp)
  119f3a:	e8 51 fa fe ff       	call   109990 <sem_destroy>
    sem_destroy(mbox->queued);
  119f3f:	8b 45 08             	mov    0x8(%ebp),%eax
  119f42:	8b 40 38             	mov    0x38(%eax),%eax
  119f45:	89 04 24             	mov    %eax,(%esp)
  119f48:	e8 43 fa fe ff       	call   109990 <sem_destroy>
    if (mbox->count != 0)
  119f4d:	8b 45 08             	mov    0x8(%ebp),%eax
  119f50:	8b 40 3c             	mov    0x3c(%eax),%eax
  119f53:	85 c0                	test   %eax,%eax
  119f55:	74 0c                	je     119f63 <sys_mbox_free+0x43>
        cprintf("sys_mbox_free: Warning: mbox not free\n");
  119f57:	c7 04 24 60 b0 11 00 	movl   $0x11b060,(%esp)
  119f5e:	e8 ad 67 fe ff       	call   100710 <cprintf>
    release(&mbox->lock);
  119f63:	8b 45 08             	mov    0x8(%ebp),%eax
  119f66:	89 04 24             	mov    %eax,(%esp)
  119f69:	e8 a2 bd fe ff       	call   105d10 <release>
    kmfree((char*)mbox, sizeof(struct mbox));
  119f6e:	c7 44 24 04 48 02 00 	movl   $0x248,0x4(%esp)
  119f75:	00 
  119f76:	8b 45 08             	mov    0x8(%ebp),%eax
  119f79:	89 04 24             	mov    %eax,(%esp)
  119f7c:	e8 ff 95 fe ff       	call   103580 <kmfree>
}
  119f81:	c9                   	leave  
  119f82:	c3                   	ret    
  119f83:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  119f89:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00119f90 <sys_mbox_post>:

void sys_mbox_post(sys_mbox_t mbox, void *msg)
{
  119f90:	55                   	push   %ebp
  119f91:	89 e5                	mov    %esp,%ebp
  119f93:	83 ec 18             	sub    $0x18,%esp
    sem_wait(mbox->free);
  119f96:	8b 45 08             	mov    0x8(%ebp),%eax
  119f99:	8b 40 34             	mov    0x34(%eax),%eax
  119f9c:	89 04 24             	mov    %eax,(%esp)
  119f9f:	e8 7c fa fe ff       	call   109a20 <sem_wait>
    acquire(&mbox->lock);
  119fa4:	8b 45 08             	mov    0x8(%ebp),%eax
  119fa7:	89 04 24             	mov    %eax,(%esp)
  119faa:	e8 61 bb fe ff       	call   105b10 <acquire>
    if (mbox->count == NSLOTS)
  119faf:	8b 45 08             	mov    0x8(%ebp),%eax
  119fb2:	8b 40 3c             	mov    0x3c(%eax),%eax
  119fb5:	3d 80 00 00 00       	cmp    $0x80,%eax
  119fba:	75 0d                	jne    119fc9 <sys_mbox_post+0x39>
    {
        release(&mbox->lock);
  119fbc:	8b 45 08             	mov    0x8(%ebp),%eax
  119fbf:	89 04 24             	mov    %eax,(%esp)
  119fc2:	e8 49 bd fe ff       	call   105d10 <release>
        return;
  119fc7:	eb 72                	jmp    11a03b <sys_mbox_post+0xab>
    }
    int slot = mbox->next;
  119fc9:	8b 45 08             	mov    0x8(%ebp),%eax
  119fcc:	8b 40 44             	mov    0x44(%eax),%eax
  119fcf:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
    mbox->next = (slot + 1) % NSLOTS;
  119fd2:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  119fd5:	83 c2 01             	add    $0x1,%edx
  119fd8:	89 d0                	mov    %edx,%eax
  119fda:	c1 f8 1f             	sar    $0x1f,%eax
  119fdd:	89 c1                	mov    %eax,%ecx
  119fdf:	c1 e9 19             	shr    $0x19,%ecx
  119fe2:	8d 04 0a             	lea    (%edx,%ecx,1),%eax
  119fe5:	83 e0 7f             	and    $0x7f,%eax
  119fe8:	29 c8                	sub    %ecx,%eax
  119fea:	89 c2                	mov    %eax,%edx
  119fec:	8b 45 08             	mov    0x8(%ebp),%eax
  119fef:	89 50 44             	mov    %edx,0x44(%eax)
    mbox->slots[slot] = msg;
  119ff2:	8b 4d fc             	mov    0xfffffffc(%ebp),%ecx
  119ff5:	8b 55 08             	mov    0x8(%ebp),%edx
  119ff8:	8b 45 0c             	mov    0xc(%ebp),%eax
  119ffb:	89 44 8a 48          	mov    %eax,0x48(%edx,%ecx,4)
    mbox->count++;
  119fff:	8b 45 08             	mov    0x8(%ebp),%eax
  11a002:	8b 40 3c             	mov    0x3c(%eax),%eax
  11a005:	8d 50 01             	lea    0x1(%eax),%edx
  11a008:	8b 45 08             	mov    0x8(%ebp),%eax
  11a00b:	89 50 3c             	mov    %edx,0x3c(%eax)
    if (mbox->head == -1)
  11a00e:	8b 45 08             	mov    0x8(%ebp),%eax
  11a011:	8b 40 40             	mov    0x40(%eax),%eax
  11a014:	83 f8 ff             	cmp    $0xffffffff,%eax
  11a017:	75 09                	jne    11a022 <sys_mbox_post+0x92>
        mbox->head = slot;
  11a019:	8b 55 08             	mov    0x8(%ebp),%edx
  11a01c:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  11a01f:	89 42 40             	mov    %eax,0x40(%edx)

    sem_post(mbox->queued);
  11a022:	8b 45 08             	mov    0x8(%ebp),%eax
  11a025:	8b 40 38             	mov    0x38(%eax),%eax
  11a028:	89 04 24             	mov    %eax,(%esp)
  11a02b:	e8 a0 f9 fe ff       	call   1099d0 <sem_post>
    release(&mbox->lock);
  11a030:	8b 45 08             	mov    0x8(%ebp),%eax
  11a033:	89 04 24             	mov    %eax,(%esp)
  11a036:	e8 d5 bc fe ff       	call   105d10 <release>
}
  11a03b:	c9                   	leave  
  11a03c:	c3                   	ret    
  11a03d:	8d 76 00             	lea    0x0(%esi),%esi

0011a040 <sys_arch_mbox_fetch>:

u32_t sys_arch_mbox_fetch(sys_mbox_t mbox, void **msg, u32_t timeout)
{
  11a040:	55                   	push   %ebp
  11a041:	89 e5                	mov    %esp,%ebp
  11a043:	83 ec 28             	sub    $0x28,%esp
    u32_t waited = sys_arch_sem_wait(mbox->queued, timeout);
  11a046:	8b 45 08             	mov    0x8(%ebp),%eax
  11a049:	8b 50 38             	mov    0x38(%eax),%edx
  11a04c:	8b 45 10             	mov    0x10(%ebp),%eax
  11a04f:	89 44 24 04          	mov    %eax,0x4(%esp)
  11a053:	89 14 24             	mov    %edx,(%esp)
  11a056:	e8 95 fd ff ff       	call   119df0 <sys_arch_sem_wait>
  11a05b:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
    acquire(&mbox->lock);
  11a05e:	8b 45 08             	mov    0x8(%ebp),%eax
  11a061:	89 04 24             	mov    %eax,(%esp)
  11a064:	e8 a7 ba fe ff       	call   105b10 <acquire>
    if (waited == SYS_ARCH_TIMEOUT)
  11a069:	83 7d f8 ff          	cmpl   $0xffffffff,0xfffffff8(%ebp)
  11a06d:	75 16                	jne    11a085 <sys_arch_mbox_fetch+0x45>
    {
        release(&mbox->lock);
  11a06f:	8b 45 08             	mov    0x8(%ebp),%eax
  11a072:	89 04 24             	mov    %eax,(%esp)
  11a075:	e8 96 bc fe ff       	call   105d10 <release>
        return waited;
  11a07a:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  11a07d:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  11a080:	e9 a6 00 00 00       	jmp    11a12b <sys_arch_mbox_fetch+0xeb>
    }

    int slot = mbox->head;
  11a085:	8b 45 08             	mov    0x8(%ebp),%eax
  11a088:	8b 40 40             	mov    0x40(%eax),%eax
  11a08b:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
    if (slot == -1)
  11a08e:	83 7d fc ff          	cmpl   $0xffffffff,0xfffffffc(%ebp)
  11a092:	75 20                	jne    11a0b4 <sys_arch_mbox_fetch+0x74>
    {
        release(&mbox->lock);
  11a094:	8b 45 08             	mov    0x8(%ebp),%eax
  11a097:	89 04 24             	mov    %eax,(%esp)
  11a09a:	e8 71 bc fe ff       	call   105d10 <release>
        cprintf("fetch failed!\n");
  11a09f:	c7 04 24 87 b0 11 00 	movl   $0x11b087,(%esp)
  11a0a6:	e8 65 66 fe ff       	call   100710 <cprintf>
        return SYS_ARCH_TIMEOUT; // XXX panic is not good...
  11a0ab:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  11a0b2:	eb 77                	jmp    11a12b <sys_arch_mbox_fetch+0xeb>
    }

    if (msg)
  11a0b4:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  11a0b8:	74 0f                	je     11a0c9 <sys_arch_mbox_fetch+0x89>
        *msg = mbox->slots[slot];
  11a0ba:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  11a0bd:	8b 45 08             	mov    0x8(%ebp),%eax
  11a0c0:	8b 54 90 48          	mov    0x48(%eax,%edx,4),%edx
  11a0c4:	8b 45 0c             	mov    0xc(%ebp),%eax
  11a0c7:	89 10                	mov    %edx,(%eax)

    mbox->head = (slot + 1) % NSLOTS;
  11a0c9:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  11a0cc:	83 c2 01             	add    $0x1,%edx
  11a0cf:	89 d0                	mov    %edx,%eax
  11a0d1:	c1 f8 1f             	sar    $0x1f,%eax
  11a0d4:	89 c1                	mov    %eax,%ecx
  11a0d6:	c1 e9 19             	shr    $0x19,%ecx
  11a0d9:	8d 04 0a             	lea    (%edx,%ecx,1),%eax
  11a0dc:	83 e0 7f             	and    $0x7f,%eax
  11a0df:	29 c8                	sub    %ecx,%eax
  11a0e1:	89 c2                	mov    %eax,%edx
  11a0e3:	8b 45 08             	mov    0x8(%ebp),%eax
  11a0e6:	89 50 40             	mov    %edx,0x40(%eax)
    mbox->count--;
  11a0e9:	8b 45 08             	mov    0x8(%ebp),%eax
  11a0ec:	8b 40 3c             	mov    0x3c(%eax),%eax
  11a0ef:	8d 50 ff             	lea    0xffffffff(%eax),%edx
  11a0f2:	8b 45 08             	mov    0x8(%ebp),%eax
  11a0f5:	89 50 3c             	mov    %edx,0x3c(%eax)
    if (mbox->count == 0)
  11a0f8:	8b 45 08             	mov    0x8(%ebp),%eax
  11a0fb:	8b 40 3c             	mov    0x3c(%eax),%eax
  11a0fe:	85 c0                	test   %eax,%eax
  11a100:	75 0a                	jne    11a10c <sys_arch_mbox_fetch+0xcc>
        mbox->head = -1;
  11a102:	8b 45 08             	mov    0x8(%ebp),%eax
  11a105:	c7 40 40 ff ff ff ff 	movl   $0xffffffff,0x40(%eax)

    sem_post(mbox->free);
  11a10c:	8b 45 08             	mov    0x8(%ebp),%eax
  11a10f:	8b 40 34             	mov    0x34(%eax),%eax
  11a112:	89 04 24             	mov    %eax,(%esp)
  11a115:	e8 b6 f8 fe ff       	call   1099d0 <sem_post>
    release(&mbox->lock);
  11a11a:	8b 45 08             	mov    0x8(%ebp),%eax
  11a11d:	89 04 24             	mov    %eax,(%esp)
  11a120:	e8 eb bb fe ff       	call   105d10 <release>
    return waited;
  11a125:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  11a128:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  11a12b:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  11a12e:	c9                   	leave  
  11a12f:	c3                   	ret    

0011a130 <sys_jiffies>:

u32_t sys_jiffies(void)
{
  11a130:	55                   	push   %ebp
  11a131:	89 e5                	mov    %esp,%ebp
  11a133:	83 ec 08             	sub    $0x8,%esp
    return millitime();
  11a136:	e8 25 de fe ff       	call   107f60 <millitime>
}
  11a13b:	c9                   	leave  
  11a13c:	c3                   	ret    
  11a13d:	8d 76 00             	lea    0x0(%esi),%esi

0011a140 <sys_thread_new>:

sys_thread_t sys_thread_new(void (* thread)(void *arg), void *arg, int prio)
{
  11a140:	55                   	push   %ebp
  11a141:	89 e5                	mov    %esp,%ebp
  11a143:	83 ec 18             	sub    $0x18,%esp
    return kproc_start(thread, arg, prio, 0, 0);;
  11a146:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  11a14d:	00 
  11a14e:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  11a155:	00 
  11a156:	8b 45 10             	mov    0x10(%ebp),%eax
  11a159:	89 44 24 08          	mov    %eax,0x8(%esp)
  11a15d:	8b 45 0c             	mov    0xc(%ebp),%eax
  11a160:	89 44 24 04          	mov    %eax,0x4(%esp)
  11a164:	8b 45 08             	mov    0x8(%ebp),%eax
  11a167:	89 04 24             	mov    %eax,(%esp)
  11a16a:	e8 51 fa fe ff       	call   109bc0 <kproc_start>
}
  11a16f:	c9                   	leave  
  11a170:	c3                   	ret    
  11a171:	eb 0d                	jmp    11a180 <sys_arch_timeouts>
  11a173:	90                   	nop    
  11a174:	90                   	nop    
  11a175:	90                   	nop    
  11a176:	90                   	nop    
  11a177:	90                   	nop    
  11a178:	90                   	nop    
  11a179:	90                   	nop    
  11a17a:	90                   	nop    
  11a17b:	90                   	nop    
  11a17c:	90                   	nop    
  11a17d:	90                   	nop    
  11a17e:	90                   	nop    
  11a17f:	90                   	nop    

0011a180 <sys_arch_timeouts>:

struct sys_timeouts *
sys_arch_timeouts(void)
{
  11a180:	55                   	push   %ebp
  11a181:	89 e5                	mov    %esp,%ebp
  11a183:	83 ec 08             	sub    $0x8,%esp
    if (cp)
  11a186:	e8 05 97 fe ff       	call   103890 <cpu>
  11a18b:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  11a192:	85 c0                	test   %eax,%eax
  11a194:	74 1a                	je     11a1b0 <sys_arch_timeouts+0x30>
        return &cp->thr->timeouts;
  11a196:	e8 f5 96 fe ff       	call   103890 <cpu>
  11a19b:	8b 04 85 20 0c 14 00 	mov    0x140c20(,%eax,4),%eax
  11a1a2:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
  11a1a8:	83 c0 08             	add    $0x8,%eax
  11a1ab:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  11a1ae:	eb 07                	jmp    11a1b7 <sys_arch_timeouts+0x37>
    else
        return &sys_touts;
  11a1b0:	c7 45 fc 6c 16 14 00 	movl   $0x14166c,0xfffffffc(%ebp)
  11a1b7:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
}
  11a1ba:	c9                   	leave  
  11a1bb:	c3                   	ret    
